{"title":"Leetcode1-500","uid":"ab2eededdd25843ff0dfd005b352f815","slug":"Leetcode1-500","date":"2021-08-16T13:41:20.000Z","updated":"2022-08-22T10:05:11.593Z","comments":true,"path":"api/articles/Leetcode1-500.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/960_593_0/t01039b44f7c7ca5ca3.jpg","content":"<h1 id=\"1-两数之和-找sum的2个idx-2sum-枚举Si-find之前是否存在target-Si-hash表-O-1-search\"><a href=\"#1-两数之和-找sum的2个idx-2sum-枚举Si-find之前是否存在target-Si-hash表-O-1-search\" class=\"headerlink\" title=\"1.两数之和 找sum的2个idx:2sum (枚举Si,find之前是否存在target-Si [hash表 O(1)search])\"></a>1.两数之和 找sum的2个idx:2sum (枚举Si,find之前是否存在target-Si [hash表 O(1)search])</h1><p>平衡树：map O(logn) –&gt; hash表：unordered_map O(1):target-Si</p>\n<p>hash[val] &#x3D; idx:             hash[nums[i]] &#x3D; i; &#x2F;&#x2F;没找到，就放入hash表</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;枚举Si,find之前是否存在target-Si [hash表 O(1)search]\n&#x2F;&#x2F;sort:pair&lt;num,idx&gt;下标会变...\n&#x2F;&#x2F;平衡树：map O(logn) --&gt; hash表：unordered_map O(1):target-Si\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tunordered_map&lt;int, int&gt; hash;&#x2F;&#x2F;存下标版\n\n\t\tfor(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n\t\t\tint r &#x3D; target - nums[i];\n\t\t\tif(hash.count(r))\n\t\t\t\treturn &#123;hash[r], i&#125;;\n\t\t\thash[nums[i]] &#x3D; i; &#x2F;&#x2F;没找到，就放入hash表\n\t\t&#125;\n\t\treturn vector&lt;int&gt;();&#x2F;&#x2F;&#123;,&#125;&#x3D;&#x3D;make_pair(,) 或 &#123;&#125;   :降T(n)\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"2-两数相加-竖式加法（链表-个十百-秦九韶）\"><a href=\"#2-两数相加-竖式加法（链表-个十百-秦九韶）\" class=\"headerlink\" title=\"2.两数相加 竖式加法（链表-个十百 秦九韶）\"></a>2.两数相加 竖式加法（链表-个十百 秦九韶）</h1><p>dummy cur 进位t + l1 + l2 %10 &#x2F;10</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n\tListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n\t\tauto dummy &#x3D; new ListNode(-1), cur &#x3D; dummy;&#x2F;&#x2F;虚拟头结点dummy\n\t\tint t &#x3D; 0;&#x2F;&#x2F;进位\n\t\twhile(l1 || l2 || t) &#123; &#x2F;&#x2F;如果最高位有进位t，则需在最前面补1.\n\t\t\tif(l1) t +&#x3D; l1-&gt;val, l1 &#x3D; l1-&gt;next;\n\t\t\tif(l2) t +&#x3D; l2-&gt;val, l2 &#x3D; l2-&gt;next;\n\t\t\tcur &#x3D; cur-&gt;next &#x3D; new ListNode(t % 10);\n\t\t\tt &#x2F;&#x3D; 10;\n\t\t&#125;\n\t\treturn dummy-&gt;next;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"3-无重复字符的最长-连续-子串-双指针-hash表\"><a href=\"#3-无重复字符的最长-连续-子串-双指针-hash表\" class=\"headerlink\" title=\"3 无重复字符的最长(连续)子串:双指针+hash表\"></a>3 无重复字符的最长(连续)子串:双指针+hash表</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;3. 无重复字符的最长(连续)子串  aabcdde : abcd 4\n&#x2F;&#x2F;双指针 滑动窗口 (优化：单调性j-&gt;j&#39;,i-&gt;i&#39; 2n次：O(n)不回头)  \n&#x2F;&#x2F;对S[i+1],hash表中S(i+1)若存在：j右移到剔除前一个S(i+1)为止 len&#x3D;max\n&#x2F;&#x2F;hash[val] &#x3D; cnt\nclass Solution &#123;\npublic:\n\tint lengthOfLongestSubstring(string s) &#123;\n\t\tunordered_map&lt;char, int&gt; hash;&#x2F;&#x2F;或unordered_mulset 记录次数\n\t\tint res &#x3D; 0;\n\t\tfor(int i &#x3D; 0, j &#x3D; 0; i &lt; s.size(); i++) &#123;\n\t\t\thash[s[i]]++;\n\t\t\twhile(hash[s[i]] &gt; 1) hash[s[j++]]--; &#x2F;&#x2F;\n\t\t\tres &#x3D; max(res, i - j + 1);\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"4-寻找两个正序数组的中位数-套（找K-th）\"><a href=\"#4-寻找两个正序数组的中位数-套（找K-th）\" class=\"headerlink\" title=\"4. 寻找两个正序数组的中位数 套（找K-th）\"></a>4. 寻找两个正序数组的中位数 套（找K-th）</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210319170208173.png\" alt=\"image-20210319170208173\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;4. 寻找两个正序数组的中位数 难 (递归):O(log(n+m))  (二分):O(log(min(m,n))\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;50&#x2F;\n\nclass Solution &#123;\npublic:\n\tdouble findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n\t\tint total &#x3D; nums1.size() + nums2.size(); &#x2F;&#x2F; 分奇偶\n\t\tif (total % 2 &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tint left &#x3D; findKthNumber(nums1, 0, nums2, 0, total &#x2F; 2);\n\t\t\tint right &#x3D; findKthNumber(nums1, 0, nums2, 0, total &#x2F; 2 + 1);\n\t\t\treturn (left + right) &#x2F; 2.0;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn findKthNumber(nums1, 0, nums2, 0, total &#x2F; 2 + 1);\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;从idx &#x3D; i,j打头\n\tint findKthNumber(vector&lt;int&gt; &amp;nums1, int i, vector&lt;int&gt; &amp;nums2, int j, int k)\n\t&#123;\n\t\tif (nums1.size() - i &gt; nums2.size() - j) return findKthNumber(nums2, j, nums1, i, k);&#x2F;&#x2F;swap12:1短2长\n\t\tif (k &#x3D;&#x3D; 1) return min(nums1[i], nums2[j]);\n\t\tif (nums1.size() &#x3D;&#x3D; i) return nums2[j + k - 1];&#x2F;&#x2F;n1到头,k&#x3D;1时：n2[j]\n\t\t&#x2F;&#x2F;1短，min(n1.size())防越界！！！\n\t\tint si &#x3D; min(i + k &#x2F; 2, int(nums1.size())), sj &#x3D; j + k &#x2F; 2; &#x2F;&#x2F; k&#x2F;2的后一个\n\t\tif (nums1[si - 1] &gt; nums2[sj - 1])\n\t\t\treturn findKthNumber(nums1, i, nums2, sj, k - (sj - j));\n\t\telse\n\t\t\treturn findKthNumber(nums1, si, nums2, j, k - (si - i));\n\t&#125;\n&#125;;</code></pre>\n\n<h1 id=\"5-最长回文子串-枚举中点i，更新max-res-O-n-n\"><a href=\"#5-最长回文子串-枚举中点i，更新max-res-O-n-n\" class=\"headerlink\" title=\"5. 最长回文子串 (枚举中点i，更新max_res: O(n*n))\"></a>5. 最长回文子串 (枚举中点i，更新max_res: O(n*n))</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;5. 最长回文子串 N&#x3D;1000 枚举中点i，更新max_res: O(n*n)  优于  DP还要开数组:S(n)大点\n&#x2F;*\nO(nlogn) str_hash(Karp_Rabin)+二分:Acwing139 0x10ds(N&#x3D;100w)    O(n):Manacher\nhash的O(n)解法:\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;893&#x2F;\n*&#x2F;\nclass Solution &#123;\npublic:\n\tstring longestPalindrome(string s) &#123;\n\t\tstring res;\n\t\tfor (int i &#x3D; 0; i &lt; s.size(); i++)&#x2F;&#x2F;枚举中心点i\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;回文串(l,r)长：奇 \n\t\t\tint l &#x3D; i - 1, r &#x3D; i + 1;\n\t\t\twhile(l &gt;&#x3D; 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] &#x3D;&#x3D; s[r]) l--, r++; &#x2F;&#x2F; end:l!&#x3D;r [l+1,r-1]\n\t\t\tif(res.size() &lt; r - l - 1) res &#x3D; s.substr(l + 1, r - l - 1); &#x2F;&#x2F;更新max_res\n\t\t\t&#x2F;&#x2F;偶  \n\t\t\tl &#x3D; i, r &#x3D; i + 1;\n\t\t\twhile(l &gt;&#x3D; 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] &#x3D;&#x3D; s[r]) l--, r++;\n\t\t\tif(res.size() &lt; r - l - 1) res &#x3D; s.substr(l + 1, r - l - 1);\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"6-Z字形变换-找规律\"><a href=\"#6-Z字形变换-找规律\" class=\"headerlink\" title=\"6. Z字形变换(找规律)\"></a>6. Z字形变换(找规律)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210319175739367.png\" alt=\"image-20210319175739367\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;6. Z字形变换 (加密机制) n&#x3D;4 1234...草稿纸找规律\n&#x2F;*\n输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 4\n输出: &quot;LDREOEIIECIHNTSG&quot;\n解释:\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n\n从中我们发现，对于行数是 n 的情况：\n1.对于第一行和最后一行，是公差为 2(n−1) 的等差数列，首项是 0 和 n−1；\n2.对于第 i 行(0&lt;i&lt;n−1)，是两个公差为 2(n−1) 的等差数列交替排列，首项分别是 i 和 2n−2−i；\n*&#x2F;\n\nclass Solution &#123;\npublic:\n\tstring convert(string s, int n) &#123;\n\t\tstring res;\n\t\tif(n &#x3D;&#x3D; 1) return s; &#x2F;&#x2F;特判n&#x3D;&#x3D;1,影响for loop\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tif(i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) &#123; &#x2F;&#x2F;首 尾\n\t\t\t\tfor (int j &#x3D; i; j &lt; s.size(); j +&#x3D; 2 * n - 2)\n\t\t\t\t\tres +&#x3D; s[j];\n\t\t\t&#125; else &#123; &#x2F;&#x2F; j,k首项不同，交替打印\n\t\t\t\tfor (int j &#x3D; i, k &#x3D; 2 * n - 2 - i; j &lt; s.size() || k &lt; s.size(); j +&#x3D; 2 * n - 2, k +&#x3D; 2 * n - 2) &#123;\n\t\t\t\t\tif(j &lt; s.size()) res +&#x3D; s[j];\n\t\t\t\t\tif(k &lt; s.size()) res +&#x3D; s[k];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;类似：剑指Acwing40 蛇形矩阵 顺时针打印矩阵</code></pre>\n\n<h1 id=\"7-整数反转-秦九韶res-x3D-res-10-x-10-x-x2F-x3D-10\"><a href=\"#7-整数反转-秦九韶res-x3D-res-10-x-10-x-x2F-x3D-10\" class=\"headerlink\" title=\"7.整数反转(秦九韶res &#x3D; res * 10 + x % 10; x &#x2F;&#x3D; 10;)\"></a>7.整数反转(秦九韶res &#x3D; res * 10 + x % 10; x &#x2F;&#x3D; 10;)</h1><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\npublic:\n\tint reverse(int x) &#123;\n\t\tint res &#x3D; 0;\n\t\twhile(x) &#123; \n\t\t\t&#x2F;&#x2F;res &#x3D; res*10+x%10&gt;INT_MAX 就溢出:return 0\n\t\t\tif(x &gt; 0 &amp;&amp; res &gt; (INT_MAX - x % 10) &#x2F; 10) return 0;\n\t\t\tif(x &lt; 0 &amp;&amp; res &lt; (INT_MIN - x % 10) &#x2F; 10) return 0;&#x2F;&#x2F;负-负&#x3D;负+正 不会溢出\n\t\t\tres &#x3D; res * 10 + x % 10; &#x2F;&#x2F; 负数 % 10 &#x3D; 负数\n\t\t\tx &#x2F;&#x3D; 10;\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n<h1 id=\"8-atoi\"><a href=\"#8-atoi\" class=\"headerlink\" title=\"8.atoi\"></a>8.atoi</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;8. 字符串转换整数 (atoi)\nclass Solution &#123;\npublic:\n\tint myAtoi(string str) &#123;\n\t\tint k &#x3D; 0;\n\t\twhile(k &lt; str.size() &amp;&amp; str[k] &#x3D;&#x3D; &#39; &#39;) k++;\n\t\tif(k &#x3D;&#x3D; str.size()) return 0;\n\n\t\tint minus &#x3D; 1;\n\t\tif(str[k] &#x3D;&#x3D; &#39;-&#39;) minus &#x3D; -1, k++;\n\t\telse if(str[k] &#x3D;&#x3D; &#39;+&#39;) k++;\n\n\t\tint res &#x3D; 0;\n\t\twhile(k &lt; str.size() &amp;&amp; str[k] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[k] &lt;&#x3D; &#39;9&#39;) &#123;\n\t\t\tint x &#x3D; str[k] - &#39;0&#39;;\n\t\t\tif (minus &gt; 0 &amp;&amp; res &gt; (INT_MAX - x) &#x2F; 10) return INT_MAX;\n\t\t\tif (minus &lt; 0 &amp;&amp; -res &lt; (INT_MIN + x) &#x2F; 10) return INT_MIN;\n\t\t\tif(-res * 10 - x &#x3D;&#x3D; INT_MIN) return INT_MIN;&#x2F;&#x2F;MIN比MAX绝对值多一:特判!(-2^31-1~2^31)\n\t\t\tres &#x3D; res * 10 + x;\n\t\t\tk++;\n\t\t\tif(res &gt; INT_MAX) break;\n\t\t&#125;\n\n\t\tres *&#x3D; minus;\n\t\tif(res &gt; INT_MAX) res &#x3D; INT_MAX;\n\t\tif(res &lt; INT_MIN) res &#x3D; INT_MIN;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"9-回文数-to-string-if-x-lt-0-x-amp-amp-x-10-x3D-x3D-0-return-false-if-s-x3D-x3D-x-s-x3D-x3D-x-x2F-10-return-true\"><a href=\"#9-回文数-to-string-if-x-lt-0-x-amp-amp-x-10-x3D-x3D-0-return-false-if-s-x3D-x3D-x-s-x3D-x3D-x-x2F-10-return-true\" class=\"headerlink\" title=\"9.回文数(to_string,if (x &lt; 0 || x &amp;&amp; x % 10 &#x3D;&#x3D; 0) return false; if (s &#x3D;&#x3D; x || s &#x3D;&#x3D; x &#x2F; 10) return true;)\"></a>9.回文数(to_string,if (x &lt; 0 || x &amp;&amp; x % 10 &#x3D;&#x3D; 0) return false; if (s &#x3D;&#x3D; x || s &#x3D;&#x3D; x &#x2F; 10) return true;)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;9. 回文数\n&#x2F;&#x2F;to_string法: str反转&#x3D;&#x3D;self\nclass Solution &#123;\npublic:\n\tbool isPalindrome(int x) &#123;\n\t\tif(x &lt; 0) return 0;\n\t\tstring s &#x3D; to_string(x);\n\t\treturn s &#x3D;&#x3D; string(s.rbegin(), s.rend());\n\t&#125;\n&#125;;\n&#x2F;&#x2F;数值法(不防溢出 LL)\nclass Solution &#123;\npublic:\n\tbool isPalindrome(int x) &#123;\n\t\tif(x &lt; 0) return 0;\n\t\tint y &#x3D; x;\n\t\tlong long res &#x3D; 0;\n\t\twhile(x) &#123;\n\t\t\tres &#x3D; res * 10 + x % 10;&#x2F;&#x2F;倒序\n\t\t\tx &#x2F;&#x3D; 10;\n\t\t&#125;\n\t\treturn res &#x3D;&#x3D; y;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;只算后一半逆序 &#x3D;&#x3D; 前一半   防溢出\nclass Solution &#123;\npublic:\n\tbool isPalindrome(int x) &#123;\n\t\tif (x &lt; 0 || x &amp;&amp; x % 10 &#x3D;&#x3D; 0) return false;&#x2F;&#x2F;负号 个位为0\n\t\tint s &#x3D; 0;\n\t\twhile (s &lt;&#x3D; x)\n\t\t&#123;\n\t\t\ts &#x3D; s * 10 + x % 10;\n\t\t\tif (s &#x3D;&#x3D; x || s &#x3D;&#x3D; x &#x2F; 10) return true;\n\t\t\t&#x2F;&#x2F; 分别处理整数长度是奇数121或者偶数1221的情况\n\t\t\tx &#x2F;&#x3D; 10;\n\t\t&#125;\n\t\treturn false;\n\t&#125;\n&#125;;\n</code></pre>\n\n<h1 id=\"10-DP：-正则匹配-“-”作为整体\"><a href=\"#10-DP：-正则匹配-“-”作为整体\" class=\"headerlink\" title=\"10.DP：.*正则匹配 “-*”作为整体\"></a>10.DP：.*正则匹配 “-*”作为整体</h1><p><a href=\"https://www.acwing.com/video/932/\">https://www.acwing.com/video/932/</a></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20220720152656143.png\" alt=\"image-20220720152656143\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210320205501531.png\" alt=\"image-20210320205501531\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\nDP优化(类似完全背包)：\n前缀 O(n^3)-&gt;O(n^2): p[j]&#x3D;&#x3D;&#39;*&#39;时\nf[i,j] &#x3D; f[i,j-2] || (f[i-1,j-2] &amp;&amp; s[i] || f[i-2,j-2] &amp;&amp; s[i] &amp;&amp; s[i-1]||...)\nf[i,j] &#x3D; f[i,j-2] || (f[i-1,j] &amp;&amp; s[i]可以和p[j - 1]匹配)\n*&#x2F;\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;bool&gt;&gt;f;\n\tint n, m;\n\tbool isMatch(string s, string p) &#123;\n\t\tn &#x3D; s.size(), m &#x3D; p.size();\n\t\ts &#x3D; &#39; &#39; + s, p &#x3D; &#39; &#39; + p; &#x2F;&#x2F; str_idx从1开始!!!\n\t\tf &#x3D; vector&lt;vector&lt;bool&gt;&gt;(n + 1, vector&lt;bool&gt;(m + 1));\n\t\tf[0][0] &#x3D; true;\n\t\tfor (int i &#x3D; 0; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123; &#x2F;&#x2F;00init了，i0没意义。j0&#x3D;&#39; &#39;匹i1：匹不了没意义 pass\n\t\t\t\tif(j + 1 &lt;&#x3D; m &amp;&amp;  p[j + 1] &#x3D;&#x3D; &#39;*&#39;) continue; &#x2F;&#x2F; 不单独考虑p[j]\n\t\t\t\tif(i &amp;&amp; p[j] !&#x3D; &#39;*&#39;) &#123; &#x2F;&#x2F;idx从1开始\n\t\t\t\t\tf[i][j] &#x3D; f[i - 1][j - 1] &amp;&amp; (s[i] &#x3D;&#x3D; p[j] || p[j] &#x3D;&#x3D; &#39;.&#39;);\n\t\t\t\t&#125; else if(p[j] &#x3D;&#x3D; &#39;*&#39;) &#123;\n\t\t\t\t\tf[i][j] &#x3D; f[i][j - 2] || i &amp;&amp; f[i - 1][j] &amp;&amp; (s[i] &#x3D;&#x3D; p[j - 1] || p[j - 1] &#x3D;&#x3D; &#39;.&#39;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\treturn f[n][m];\n\t&#125;\n&#125;;\n</code></pre>\n\n<p>后缀解法：</p>\n<p><a href=\"https://www.acwing.com/solution/content/102/\">https://www.acwing.com/solution/content/102/</a></p>\n<h1 id=\"11-盛最多水的容器-移动较短边，判断面积是否有可能增大\"><a href=\"#11-盛最多水的容器-移动较短边，判断面积是否有可能增大\" class=\"headerlink\" title=\"11.盛最多水的容器(移动较短边，判断面积是否有可能增大)\"></a>11.盛最多水的容器(移动较短边，判断面积是否有可能增大)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210320212119402.png\" alt=\"image-20210320212119402\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Acwing1575\n&#x2F;*\n单调栈+二分：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;13804&#x2F;\n双指针O(n)，思维跳跃：LR比较，低的向中间靠拢，更新max_area(L定，R低，&lt;-靠)\ncorrectness proof:反证法，if L&lt;&#x3D;R 1-6-4，存在更大的best，矛盾。\n！！！移动较短边，判断面积是否有可能增大~属于贪心题！\n*&#x2F;\nclass Solution &#123;\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0, j &#x3D; height.size() - 1; i &lt; j;) &#123;\n            res &#x3D; max(res, min(height[i], height[j]) * (j - i));\n            if(height[i] &gt; height[j]) j--;\n            else i++;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"12-int2罗马数字\"><a href=\"#12-int2罗马数字\" class=\"headerlink\" title=\"12. int2罗马数字\"></a>12. int2罗马数字</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210320215717347.png\" alt=\"image-20210320215717347\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;12 整数转罗马数字\nclass Solution &#123;\npublic:\n    string intToRoman(int num) &#123;\n        int values[] &#x3D; &#123;\n            1000,\n            900, 500, 400, 100,\n            90, 50, 40, 10,\n            9, 5, 4, 1\n        &#125;;\n        string reps[] &#x3D; &#123; &#x2F;&#x2F; 单位representations\n            &quot;M&quot;,\n            &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;,\n            &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;,\n            &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;\n        &#125;;\n        string res;\n        for(int i &#x3D; 0; i &lt; 13; i++) &#123;\n            while(num &gt;&#x3D; values[i]) &#123; &#x2F;&#x2F; &gt;&#x3D;\n                num -&#x3D; values[i];\n                res +&#x3D; reps[i];\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n<h1 id=\"13-罗马数字2int-hash-lt-gt\"><a href=\"#13-罗马数字2int-hash-lt-gt\" class=\"headerlink\" title=\"13. 罗马数字2int hash+ [&lt;-,&gt;+]\"></a>13. 罗马数字2int hash+ [&lt;-,&gt;+]</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210320221922671.png\" alt=\"image-20210320221922671\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int romanToInt(string s) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        hash[&#39;I&#39;] &#x3D; 1, hash[&#39;V&#39;] &#x3D; 5;\n        hash[&#39;X&#39;] &#x3D; 10, hash[&#39;L&#39;] &#x3D; 50;\n        hash[&#39;C&#39;] &#x3D; 100, hash[&#39;D&#39;] &#x3D; 500;\n        hash[&#39;M&#39;] &#x3D; 1000;\n\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(i + 1 &lt; s.size() &amp;&amp; hash[s[i]] &lt; hash[s[i+1]]) res -&#x3D; hash[s[i]];\n            else res +&#x3D; hash[s[i]];\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"14-LCP-for-auto-amp-str-strs-能匹配上才接c\"><a href=\"#14-LCP-for-auto-amp-str-strs-能匹配上才接c\" class=\"headerlink\" title=\"14. LCP [for(auto&amp; str : strs)  能匹配上才接c]\"></a>14. LCP [for(auto&amp; str : strs)  能匹配上才接c]</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;\n        string res;\n        if(!strs.size()) return res;\n\n        for(int i &#x3D; 0;;i++) &#123;\n            if(i &gt; strs[0].size()) return res;\n            char c &#x3D; strs[0][i];\n            for(auto&amp; str : strs) &#x2F;&#x2F;auto&amp; str\n                if(str.size() &lt;&#x3D; i || str[i] !&#x3D; c) &#x2F;&#x2F;匹配不上：end或!&#x3D;\n                    return res;\n            res +&#x3D; c; &#x2F;&#x2F;能匹配上才接c\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"15-18-3sum-sort-dedup-min-3sum-gt-x3D-0-if-x3D-x3D-0-x2F-双指针\"><a href=\"#15-18-3sum-sort-dedup-min-3sum-gt-x3D-0-if-x3D-x3D-0-x2F-双指针\" class=\"headerlink\" title=\"15[~18]. 3sum (sort+dedup+min(3sum&gt;&#x3D;0) + if&#x3D;&#x3D;0 &#x2F; 双指针)\"></a>15[~18]. 3sum (sort+dedup+min(3sum&gt;&#x3D;0) + if&#x3D;&#x3D;0 &#x2F; 双指针)</h1><p>双指针：<img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210321093352701.png\" alt=\"image-20210321093352701\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210321093434345.png\" alt=\"image-20210321093434345\"></p>\n<p>target&#x3D;-n[i],value&#x3D;n[i]</p>\n<p>min(3sum&gt;&#x3D;0) + if&#x3D;&#x3D;0</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        sort(nums.begin(), nums.end());\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            if(i &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;\n            for(int j &#x3D; i + 1, k &#x3D; nums.size() - 1; j &lt; k; j++) &#123;\n                if(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;\n                while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;&#x3D; 0) k--; &#x2F;&#x2F;k-1 !!!\n                if(nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0) &#x2F;&#x2F;&#x3D;&#x3D;0\n                    res.push_back(&#123;nums[i], nums[j], nums[k]&#125;);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"16-最接近的三数之和\"><a href=\"#16-最接近的三数之和\" class=\"headerlink\" title=\"16. 最接近的三数之和\"></a>16. 最接近的三数之和</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210321100338274.png\" alt=\"image-20210321100338274\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tint threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tpair&lt;int, int&gt; res(INT_MAX, INT_MAX); &#x2F;&#x2F; &#123;residual,val&#125;\n\t\tsort(nums.begin(), nums.end());\n\t\tfor(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n\t\t\tif(i &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;\n\t\t\tfor(int j &#x3D; i + 1, k &#x3D; nums.size() - 1; j &lt; k; j++) &#123;\n\t\t\t\tif(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;\n\t\t\t\t&#x2F;&#x2F;+n[k-1]&lt; , n[k] is left !!!故+n[k-1]一定&lt;target\n                while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;&#x3D; target) k--; \n\t\t\t\tint s &#x3D; nums[i] + nums[j] + nums[k];\n\t\t\t\tres &#x3D; min(res, &#123;abs(s - target), s&#125;);&#x2F;&#x2F;\n\t\t\t\tif( j &lt; k - 1) &#123;\n\t\t\t\t\tint s &#x3D; nums[i] + nums[j] + nums[k - 1]; &#x2F;&#x2F;\n\t\t\t\t\tres &#x3D; min(res, &#123;target - s, s&#125;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn res.second;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"17-2-abc-9字母组合-爆搜dfs\"><a href=\"#17-2-abc-9字母组合-爆搜dfs\" class=\"headerlink\" title=\"17. 2(abc)~9字母组合     爆搜dfs\"></a>17. 2(abc)~9字母组合     爆搜dfs</h1><p>$$ T(n)&#x3D;4^n*n$$</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tvector&lt;string&gt; ans;\n\tstring strs[10] &#x3D; &#123;\n\t\t&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;,\n\t\t&quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, \n\t\t&quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;\n\t&#125;;\n\n\tvector&lt;string&gt; letterCombinations(string digits) &#123;\n\t\tif(digits.empty()) return ans; &#x2F;&#x2F;\n\t\tdfs(digits, 0, &quot;&quot;);\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(string&amp; digits, int u, string path) &#123;\n\t\tif(u &#x3D;&#x3D; digits.size()) ans.push_back(path);\n\t\telse &#123;\n\t\t\tfor(auto c : strs[digits[u] - &#39;0&#39;])\n\t\t\t\tdfs(digits, u + 1, path + c);\n\t\t&#125;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"18-4sum-lt-–-3sum-0–-gt-target\"><a href=\"#18-4sum-lt-–-3sum-0–-gt-target\" class=\"headerlink\" title=\"18. 4sum &lt;– 3sum , 0–&gt;target\"></a>18. 4sum &lt;– 3sum , 0–&gt;target</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tsort(nums.begin(), nums.end());\n\t\tfor(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n\t\t\tif(i &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;\n\t\t\tfor(int j &#x3D; i + 1; j &lt; nums.size(); j++) &#123; &#x2F;&#x2F;\n\t\t\t\tif(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;\n\t\t\t\tfor(int k &#x3D; j + 1, u &#x3D; nums.size() - 1; k &lt; u; k++) &#123;\n\t\t\t\t\tif(k &gt; j + 1 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) continue;\n\t\t\t\t\twhile(k &lt; u - 1 &amp;&amp; nums[i] + nums[j] + nums[k] + nums[u - 1] &gt;&#x3D; target) u--; &#x2F;&#x2F;u-1 !!!\n\t\t\t\t\tif(nums[i] + nums[j] + nums[k] + nums[u] &#x3D;&#x3D; target) &#x2F;&#x2F;&#x3D;&#x3D;target\n\t\t\t\t\t\tres.push_back(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);\n\t\t\t\t&#125;\t\t\t\t\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"19-删除链表的倒数第-N-个节点\"><a href=\"#19-删除链表的倒数第-N-个节点\" class=\"headerlink\" title=\"19. 删除链表的倒数第 N 个节点\"></a>19. 删除链表的倒数第 N 个节点</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210321113730932.png\" alt=\"image-20210321113730932\"></p>\n<p>+dummy(first):0~n    倒数第k+1&#x3D;&#x3D;正数第n+1-(k+1)&#x3D;n-k个点，要跳n-k-1步！</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int k) &#123; &#x2F;&#x2F;n--&gt;k\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n\n        int n &#x3D; 0;\n        for(auto p &#x3D; dummy; p; p &#x3D; p-&gt;next) n++;\n\n        auto p &#x3D; dummy;\n        for(int i &#x3D; 0; i &lt; n - k - 1; i++) p &#x3D; p-&gt;next;\n        p-&gt;next &#x3D; p-&gt;next-&gt;next;\n\n        return dummy-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n<h1 id=\"20-有效的括号-stk\"><a href=\"#20-有效的括号-stk\" class=\"headerlink\" title=\"20.有效的括号 stk\"></a>20.有效的括号 stk</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210321120004060.png\" alt=\"image-20210321120004060\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        stack&lt;char&gt; stk;\n\n        for(auto c : s) &#123;\n            if(c &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;[&#39; || c &#x3D;&#x3D; &#39;&#123;&#39;) stk.push(c);\n            else &#123;\n                if(stk.size() &amp;&amp; abs(stk.top() - c) &lt;&#x3D; 2) stk.pop();\n                else return false; &#x2F;&#x2F;不匹配\n            &#125;\n        &#125;\n        return stk.empty(); &#x2F;&#x2F;落单\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"21-合并两个有序链表-2路归并\"><a href=\"#21-合并两个有序链表-2路归并\" class=\"headerlink\" title=\"21. 合并两个有序链表 2路归并\"></a>21. 合并两个有序链表 2路归并</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;\n        auto dummy &#x3D; new ListNode(-1), tail &#x3D; dummy;\n        while(l1 &amp;&amp; l2) &#123;\n            if(l1-&gt;val &lt; l2-&gt;val) &#123;\n                tail &#x3D; tail-&gt;next &#x3D; l1;\n                l1 &#x3D; l1-&gt;next;\n            &#125;\n            else &#123;\n                tail &#x3D; tail-&gt;next &#x3D; l2;\n                l2 &#x3D; l2-&gt;next;\n            &#125;\n        &#125;\n        if(l1) tail-&gt;next &#x3D; l1;\n        if(l2) tail-&gt;next &#x3D; l2;\n        return dummy-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"22-生成n个合法-seq-递归\"><a href=\"#22-生成n个合法-seq-递归\" class=\"headerlink\" title=\"22.生成n个合法()seq  递归\"></a>22.生成n个合法()seq  递归</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n递归。\n每次可以放置左括号的条件是当前[左括号的数目不超过n]。\n每次可以放置右括号的条件是当前[右括号的数目不超过左括号的数目]。\ncase数&#x3D;Catalan&#x3D;C(n,m)&#x2F;(n+1)\n*&#x2F;\n&#x2F;&#x2F;正：已有cnt\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;string&gt; generateParenthesis(int n) &#123;\n        dfs(n, 0, 0, &quot;&quot;);\n        return ans;\n    &#125;\n     void dfs(int n,int lc,int rc, string seq) &#123;\n         if(lc &#x3D;&#x3D; n &amp;&amp; rc &#x3D;&#x3D; n) ans.push_back(seq);\n         else &#123;\n             if(lc &lt; n) dfs(n, lc + 1, rc, seq + &#39;(&#39;);\n             if(rc &lt; n &amp;&amp; lc &gt; rc) dfs(n, lc, rc + 1, seq + &#39;)&#39;);\n         &#125;\n     &#125;\n&#125;;\n\n&#x2F;&#x2F;反：还需要cnt\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;string&gt; generateParenthesis(int n) &#123;\n        dfs(n, n, &quot;&quot;);\n        return ans;\n    &#125;\n     void dfs(int lc,int rc, string seq) &#123;\n         if(!lc &amp;&amp; !rc) ans.push_back(seq);\n         else &#123;\n             if(lc &lt; rc) dfs(lc, rc - 1, seq + &#39;)&#39;);\n             if(lc) dfs(lc - 1, rc, seq + &#39;(&#39;);\n         &#125;\n     &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"！！！23-K路归并-heap-（148）\"><a href=\"#！！！23-K路归并-heap-（148）\" class=\"headerlink\" title=\"！！！23. K路归并  heap  （148）\"></a>！！！23. K路归并  heap  （148）</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;小根堆，K个min入堆，insert:O(logK)\n&#x2F;&#x2F; priority_queue &lt;int,vector&lt;int&gt; ,greater&lt;int&gt;&gt; q;\nclass Solution &#123;\npublic:\n\n    struct Cmp &#123;\n        bool operator() (ListNode* a, ListNode* b) &#123;\n            return a-&gt;val &gt; b-&gt;val;\n        &#125;\n    &#125;;\n\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        priority_queue &lt;ListNode*,vector&lt;ListNode*&gt; , Cmp&gt; heap;\n        auto dummy &#x3D; new ListNode(-1), tail &#x3D; dummy;\n        for(auto l : lists) if(l) heap.push(l);\n\n        while(heap.size()) &#123;\n            auto t &#x3D; heap.top();\n            heap.pop();\n\n            tail &#x3D; tail-&gt;next &#x3D; t;\n            if(t-&gt;next) heap.push(t-&gt;next);\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n&#x2F;*\n(二分治合并) O(nlogk)  mergesort变形\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;71&#x2F;\n*&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) &#123;\n        ListNode *head &#x3D; new ListNode(0);\n        ListNode *cur &#x3D; head;\n        while (l1 !&#x3D; NULL &amp;&amp; l2 !&#x3D; NULL) &#123;\n            if (l1 -&gt; val &lt; l2 -&gt; val) &#123;\n                cur -&gt; next &#x3D; l1;\n                l1 &#x3D; l1 -&gt; next;\n            &#125;\n            else &#123;\n                cur -&gt; next &#x3D; l2;\n                l2 &#x3D; l2 -&gt; next;\n            &#125;\n            cur &#x3D; cur -&gt; next;\n        &#125;\n        cur -&gt; next &#x3D; (l1 !&#x3D; NULL ? l1 : l2);\n        return head -&gt; next;\n    &#125;\n\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        if (lists.size() &#x3D;&#x3D; 0)\n            return NULL;\n        if (lists.size() &#x3D;&#x3D; 1)\n            return lists[0];\n\n        int mid &#x3D; lists.size() &#x2F; 2;\n        vector&lt;ListNode*&gt; left &#x3D; vector&lt;ListNode*&gt;(lists.begin(), lists.begin() + mid);\n        vector&lt;ListNode*&gt; right &#x3D; vector&lt;ListNode*&gt;(lists.begin() + mid, lists.end());\n        ListNode *l1 &#x3D; mergeKLists(left);\n        ListNode *l2 &#x3D; mergeKLists(right);\n        return merge2Lists(l1, l2);\n    &#125;\n&#125;;\n</code></pre>\n\n<p>Java O(NlogK)</p>\n<ol>\n<li>【堆】  22归并 自底向上</li>\n</ol>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210522093445967.png\" alt=\"image-20210522093445967\"></p>\n<ol start=\"2\">\n<li>DP向上 【链表模拟每层merge】（用于148题：排序链表）</li>\n</ol>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210522094037769.png\" alt=\"image-20210522094037769\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210522094121807.png\" alt=\"image-20210522094121807\"></p>\n<p>3.归并  自顶向下 [分治]</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210522094432567.png\" alt=\"image-20210522094432567\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210522094454445.png\" alt=\"image-20210522094454445\"></p>\n<h1 id=\"24-两两交换链表中的节点-pab\"><a href=\"#24-两两交换链表中的节点-pab\" class=\"headerlink\" title=\"24. 两两交换链表中的节点 pab\"></a>24. 两两交换链表中的节点 pab</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* swapPairs(ListNode* head) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n\n        for(auto p &#x3D; dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;\n            auto a &#x3D; p-&gt;next, b &#x3D; a-&gt;next;\n            p-&gt;next &#x3D; b;\n            a-&gt;next &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            p &#x3D; a;\n        &#125;\n         return dummy-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"25-lt-24-K-swap\"><a href=\"#25-lt-24-K-swap\" class=\"headerlink\" title=\"25.&lt;-24  K_swap\"></a>25.&lt;-24  K_swap</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210321165313653.png\" alt=\"image-20210321165313653\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n        for(auto p &#x3D; dummy;;) &#123;\n            auto q &#x3D; p;\n            for(int i &#x3D; 0; i &lt; k &amp;&amp; q; i++) q &#x3D; q-&gt;next;\n            if(!q) break;\n            auto a &#x3D; p-&gt;next, b &#x3D; a-&gt;next;\n            for(int i &#x3D; 0; i &lt; k - 1; i++) &#123; &#x2F;&#x2F;a+&#x3D;2 &#x3D; k-1\n                auto c &#x3D; b-&gt;next;\n                b-&gt;next &#x3D; a;\n                a &#x3D; b, b &#x3D; c;\n            &#125;\n            auto c &#x3D; p-&gt;next; &#x2F;&#x2F;c\n            p-&gt;next &#x3D; a, c-&gt;next &#x3D; b;\n            p &#x3D;  c;\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"26-删除排序数组中的重复项：双指针原地覆盖\"><a href=\"#26-删除排序数组中的重复项：双指针原地覆盖\" class=\"headerlink\" title=\"26. 删除排序数组中的重复项：双指针原地覆盖\"></a>26. 删除排序数组中的重复项：双指针原地覆盖</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n原地覆盖val：不开数组不递归\nSTL:unique  双指针\n*&#x2F;\nclass Solution &#123;\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        int k &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)\n            if(!i || nums[i] !&#x3D; nums[i - 1]) &#x2F;&#x2F;i&#x3D;&#x3D;0 or !&#x3D;\n                nums[k++] &#x3D; nums[i];\n        \n        return k;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"27-lt-26-val去重\"><a href=\"#27-lt-26-val去重\" class=\"headerlink\" title=\"27.&lt;-26   val去重\"></a>27.&lt;-26   val去重</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;27&lt;-26   val去重\nclass Solution &#123;\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;\n\t\tint k &#x3D; 0;\n\t\tfor(int i &#x3D; 0; i &lt; nums.size(); i++)\n\t\t\tif(nums[i] !&#x3D; val) &#x2F;&#x2F;\n\t\t\t\tnums[k++] &#x3D; nums[i];\n\t\treturn k;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"28-实现-strStr-裸KMP\"><a href=\"#28-实现-strStr-裸KMP\" class=\"headerlink\" title=\"28. 实现 strStr()    裸KMP\"></a>28. 实现 strStr()    裸KMP</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;KMP 字符串哈希 BM Sunday\nclass Solution &#123;\npublic:\n\tint strStr(string s, string p) &#123;\n\t\tif(p.empty()) return 0;\n\t\tint n &#x3D; s.size(), m &#x3D; p.size();\n\t\ts &#x3D; &#39; &#39; + s, p &#x3D; &#39; &#39; + p;\n\n\t\tvector&lt;int&gt; next(m + 1);\n\t\t&#x2F;&#x2F;next[1] &#x3D; 0; &#x2F;&#x2F;求next\n\t\tfor(int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i++) &#123;\n\t\t\twhile(j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; next[j];\n\t\t\tif(p[i] &#x3D;&#x3D; p[j + 1]) j++;\n\t\t\tnext[i] &#x3D; j;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 匹配\n\t\tfor(int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n\t\t\twhile(j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; next[j];\n\t\t\tif(s[i] &#x3D;&#x3D; p[j + 1]) j++;\n\t\t\tif(j &#x3D;&#x3D; m) return i - m; &#x2F;&#x2F; (i - m + 1)-1 ,idx from 1\n\t\t&#125;\n\n\t\treturn -1;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"29-两数相除-only-qmi二进制划分\"><a href=\"#29-两数相除-only-qmi二进制划分\" class=\"headerlink\" title=\"29. 两数相除(only+-  qmi二进制划分)\"></a>29. 两数相除(only+-  qmi二进制划分)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210322154057055.png\" alt=\"image-20210322154057055\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210322154127136.png\" alt=\"image-20210322154127136\"></p>\n<p>如果除法结果溢出(所以要LL！！！！！)，则返回 2^31^ − 1。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;29 两数相除 a&#x2F;b&#x3D;(110)&#x3D;2^1+2^2 O(log30)\n&#x2F;&#x2F;思想：2分&#x2F;倍增&#x2F;快速幂&#x2F;二进制划分\nclass Solution &#123;\npublic:\n\tint divide(int x, int y) &#123;\n\t\ttypedef long long LL;\n\t\tvector&lt;LL&gt; exp;\n\t\tbool is_minus &#x3D; false;\n\t\tif(x &gt; 0 &amp;&amp; y &lt; 0 || x &lt; 0 &amp;&amp; y &gt; 0) is_minus &#x3D; true;\n\n\t\tLL a &#x3D; abs((LL) x), b &#x3D; abs((LL) y);&#x2F;&#x2F;(LL) (-2^31)&#x2F;(-1)&#x3D;2^31溢出\n\t\tfor(LL i &#x3D; b; i &lt;&#x3D; a; i &#x3D; i + i) exp.push_back(i); &#x2F;&#x2F;LL i qmi思想变形\n\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; exp.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n\t\t\tif(a &gt;&#x3D; exp[i]) &#123;\n\t\t\t\ta -&#x3D; exp[i];\n\t\t\t\tres +&#x3D; 1ll &lt;&lt; i; &#x2F;&#x2F;二进制划分 2^31溢出 1ll!!!!!\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif(is_minus) res &#x3D; -res;\n\t\tif(res &lt; INT_MIN || res &gt; INT_MAX) res &#x3D; INT_MAX;&#x2F;&#x2F;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"30-串联所有-等长-单词的子串-分组-滑动窗口-2-hash表-tot-wd-同LC76\"><a href=\"#30-串联所有-等长-单词的子串-分组-滑动窗口-2-hash表-tot-wd-同LC76\" class=\"headerlink\" title=\"30.串联所有[等长]单词的子串(分组+滑动窗口 2*hash表:tot wd 同LC76~)\"></a>30.串联所有[等长]单词的子串(分组+滑动窗口 2*hash表:tot wd 同LC76~)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210322164813734.png\" alt=\"image-20210322164813734\"></p>\n<p>&#x2F;&#x2F;–  (tot-1)&lt;tot [tot内]</p>\n<p>&#x2F;&#x2F;(tot-1)++  &lt;&#x3D;tot [tot内]</p>\n<p>if(cnt &#x3D;&#x3D; m) res.push_back(j - (m - 1) * w); &#x2F;&#x2F;“j_end”右移了一个w</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;30 串联所有单词的子串\n&#x2F;&#x2F;best解法 str_hash&#x2F;Rabin_Karp: O(n)&#x3D;O(n&#x2F;w)*w\n&#x2F;&#x2F;双指针： O(n*w)&#x3D;O(n&#x2F;w*w)*w     一些【长度相同】的单词 words  等长，可优化\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;\n        vector&lt;int&gt; res;\n        if(words.empty()) return res;\n        int n &#x3D; s.size(), m &#x3D; words.size(), w &#x3D; words[0].size();\n        unordered_map&lt;string, int&gt; tot;\n        for(auto&amp; word : words) tot[word] ++;\n\n        for(int i &#x3D; 0; i &lt; w; i++) &#123;\n            unordered_map&lt;string, int&gt; wd;\n            int cnt &#x3D; 0;\n            for(int j &#x3D; i; j + w &lt;&#x3D; n; j +&#x3D; w) &#123; &#x2F;&#x2F;m * w固定滑动窗口\n                if(j &gt;&#x3D; i + m * w) &#123;\n                    auto word &#x3D; s.substr(j - m * w, w);\n                    wd[word]--;\n                    if(wd[word] &lt; tot[word]) cnt--; &#x2F;&#x2F;--  (tot-1)&lt;tot [tot内]\n                &#125;\n                auto word &#x3D; s.substr(j, w);\n                wd[word]++;\n                if(wd[word] &lt;&#x3D; tot[word]) cnt++; &#x2F;&#x2F;(tot-1)++  &lt;&#x3D;tot [tot内]\n                if(cnt &#x3D;&#x3D; m) res.push_back(j - (m - 1) * w); &#x2F;&#x2F;&quot;j_end&quot;右移了一个w\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"31-nextPermutation-13-542-gt-14-235\"><a href=\"#31-nextPermutation-13-542-gt-14-235\" class=\"headerlink\" title=\"31. nextPermutation 13,542-&gt;14,235\"></a>31. nextPermutation 13,542-&gt;14,235</h1><p>“&lt;-“找到第一个非降序: 与【&gt;它的min】 swap，reverse(降序)为升序</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tvoid nextPermutation(vector&lt;int&gt;&amp; nums) &#123;\n\t\tint k &#x3D; nums.size() - 1;\n\t\twhile(k &gt; 0 &amp;&amp; nums[k - 1] &gt;&#x3D; nums[k]) k--;\n\t\tif(k &lt;&#x3D; 0) &#123;\n\t\t\treverse(nums.begin(), nums.end());\n\t\t&#125; else &#123;\n\t\t\tint t &#x3D; k;&#x2F;&#x2F;需要小升一下的数\n\t\t\twhile(t &lt; nums.size() &amp;&amp; nums[t] &gt; nums[k - 1]) t++;&#x2F;&#x2F;t恰好&lt;&#x3D;\n\t\t\tswap(nums[t - 1], nums[k - 1]);&#x2F;&#x2F;t-1恰好&gt; min(&gt;) swap\n\t\t\treverse(nums.begin() + k, nums.end());\n\t\t&#125;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"32-最长有效括号-分段合法stk-x2F-cnt-x2F-DP\"><a href=\"#32-最长有效括号-分段合法stk-x2F-cnt-x2F-DP\" class=\"headerlink\" title=\"32. 最长有效括号 分段合法stk&#x2F;cnt&#x2F;DP\"></a>32. 最长有效括号 分段合法stk&#x2F;cnt&#x2F;DP</h1><p>（反证）[合法序列]分段思想！！！ </p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210323104301047.png\" alt=\"image-20210323104301047\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;yxc stack\nclass Solution &#123;\npublic:\n\tint longestValidParentheses(string s) &#123;\n\t\tstack&lt;int&gt; stk;\n\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0, start &#x3D; -1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F;start&#x3D;&#x3D;区间的prev\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;(&#39;) stk.push(i);\n\t\t\telse &#123;\n\t\t\t\tif (stk.size()) &#123;\n\t\t\t\t\tstk.pop();\n\t\t\t\t\tif (stk.size())\n\t\t\t\t\t\tans &#x3D; max(ans, i - stk.top());\n\t\t\t\t\telse\n\t\t\t\t\t\tans &#x3D; max(ans, i - start);\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tstart &#x3D; i;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;;\n\n&#x2F;*\nO(n) 3种解法 https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;114&#x2F;\n双向扫描cnt法：\n(+1 )-1 [start,i]区间 &lt;0更新start&#x3D;i+1;&#x3D;&#x3D;0更新答案;&gt;0略过 &quot;()(((&quot;反向扫描&lt;-解决\n*&#x2F;\nclass Solution &#123;\npublic:\n\tint longestValidParentheses(string s) &#123;\n\t\tint n &#x3D; s.length();\n\t\tint start &#x3D; 0, val &#x3D; 0, ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;(&#39;) val++;\n\t\t\telse val--;\n\t\t\tif (val &lt; 0) &#123;\n\t\t\t\tval &#x3D; 0;\n\t\t\t\tstart &#x3D; i + 1;&#x2F;&#x2F;合法段：分段合法\n\t\t\t&#125;\n\t\t\telse if (val &#x3D;&#x3D; 0)\n\t\t\t\tans &#x3D; max(ans, i - start + 1);\n\t\t&#125;\n\n\t\tstart &#x3D; n - 1; val &#x3D; 0;\n\t\tfor (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;)&#39;) val++;\n\t\t\telse val--;\n\t\t\tif (val &lt; 0) &#123;\n\t\t\t\tval &#x3D; 0;\n\t\t\t\tstart &#x3D; i - 1;\n\t\t\t&#125;\n\t\t\telse if (val &#x3D;&#x3D; 0)\n\t\t\t\tans &#x3D; max(ans, start - i + 1);\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;;\n\n\n&#x2F;*\n(栈) O(n)  类似于法一！\n1.用栈维护当前待匹配的左括号的位置。同时用start记录一个新的可能合法的子串的起始位置。初始设为 0。\n2.遇到左括号，当前位置进栈。\n3.遇到右括号，如果当前栈不空，则当前栈顶出栈。\n出栈后，如果栈为空，则更新答案 i - start + 1；否则更新答案 i - st.top()。\n4.遇到右括号且当前栈为空，则当前的 start 开始的子串不再可能为合法子串了，下一个合法子串的起始位置是 i + 1，\n更新 start &#x3D; i + 1。\n*&#x2F;\nclass Solution &#123;\npublic:\n\tint longestValidParentheses(string s) &#123;\n\t\tint n &#x3D; s.length();\n\t\tstack&lt;int&gt; st;\n\n\t\tint start &#x3D; 0, ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;(&#39;)\n\t\t\t\tst.push(i);\n\t\t\telse &#123;\n\t\t\t\tif (!st.empty()) &#123;\n\t\t\t\t\tst.pop();\n\t\t\t\t\tif (st.empty())\n\t\t\t\t\t\tans &#x3D; max(ans, i - start + 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tans &#x3D; max(ans, i - st.top());\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tstart &#x3D; i + 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;;\n\n&#x2F;*\n(动态规划) O(n)  难想！\n1.设 f(i) 为以 i 为结尾的最长合法子串。\n2.初始时，f(0)&#x3D;0。\n3.转移时，我们仅考虑当前字符是 ) 的时候。如果上一个字符是 (，即 ...() 结尾的情况，则 f(i)&#x3D;f(i−1)+2。\n4.如果上一个字符是 )，即 ...)) 的情况，则我们通过上一个字符的动规结果，判断是否能匹配末尾的 )。判断 s[i - f(i - 1) - 1] 是 (，即 ...((合法))，则可以转移 f(i)&#x3D;f(i−1)+2+f(i−f(i−1)−2)。\n5.最终答案为动规数组中的最大值。\n*&#x2F;\nclass Solution &#123;\npublic:\n\tint longestValidParentheses(string s) &#123;\n\t\tint n &#x3D; s.length();\n\t\tvector&lt;int&gt; f(n, 0);\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;\n\t\t\t\tif (s[i - 1] &#x3D;&#x3D; &#39;(&#39;) &#123;\n\t\t\t\t\tif (i &gt;&#x3D; 2) f[i] &#x3D; f[i - 2] + 2;\n\t\t\t\t\telse f[i] &#x3D; 2;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tif (i - f[i - 1] - 1 &gt;&#x3D; 0 &amp;&amp; s[i - f[i - 1] - 1] &#x3D;&#x3D; &#39;(&#39;)\n\t\t\t\t\t\tif (i - f[i - 1] - 2 &gt;&#x3D; 0)\n\t\t\t\t\t\t\tf[i] &#x3D; f[i - 1] + 2 + f[i - f[i - 1] - 2];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tf[i] &#x3D; f[i - 1] + 2;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\tans &#x3D; max(ans, f[i]);\n\n\t\treturn ans;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"33-搜索旋转排序数组H-二分l-x3D-mid-—-gt-1-两段性-gt-x3D-nums-0-1段满足-2段不满足\"><a href=\"#33-搜索旋转排序数组H-二分l-x3D-mid-—-gt-1-两段性-gt-x3D-nums-0-1段满足-2段不满足\" class=\"headerlink\" title=\"33.搜索旋转排序数组H (二分l &#x3D; mid;—-&gt;+1 两段性:&gt;&#x3D; nums[0] 1段满足 2段不满足)\"></a>33.搜索旋转排序数组H (二分l &#x3D; mid;—-&gt;+1 两段性:&gt;&#x3D; nums[0] 1段满足 2段不满足)</h1><p>分界点二分  find性质 &gt;&#x3D; nums[0]：1段满足 2段不满足</p>\n<p>else l &#x3D; mid + 1;&#x2F;&#x2F;mid属于左半边 版本一</p>\n<p>else r &#x3D; mid - 1;&#x2F;&#x2F;mid属于右半边 版本二 l &#x3D; mid;—-&gt;+1【l &#x3D; mid;—–&gt; int mid &#x3D; l + r + 1 &gt;&gt; 1;】</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tint search(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tif(nums.empty()) return -1;\n\t\t&#x2F;&#x2F;二分两段\n\t\tint l &#x3D; 0, r &#x3D; nums.size() - 1;\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; nums[0]) l &#x3D; mid;\n\t\t\telse r &#x3D; mid - 1;&#x2F;&#x2F;mid属于右半边 版本二 +1\n\t\t&#125;\n\t\t&#x2F;&#x2F;l&#x3D;r&#x3D;mid &gt;&#x3D;n[0]:target定在哪一段\n\t\tif(target &gt;&#x3D; nums[0]) l &#x3D; 0;\n\t\telse l &#x3D; r + 1, r &#x3D; nums.size() - 1;\n\t\t\n\t\t&#x2F;&#x2F; 二分 &gt;&#x3D;target的min\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; target) r &#x3D; mid;\n\t\t\telse l &#x3D; mid + 1;&#x2F;&#x2F;mid属于左半边 版本一\n\t\t&#125;\n\t\t&#x2F;&#x2F; (不)存在\n\t\tif(nums[r] &#x3D;&#x3D; target) return r;\n\t\treturn -1;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"34-在排序数组中查找元素的第一个和最后一个位置M-gt-二分-lt-二分-gt-x3D-x2F-lt-x3D-target\"><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置M-gt-二分-lt-二分-gt-x3D-x2F-lt-x3D-target\" class=\"headerlink\" title=\"34.在排序数组中查找元素的第一个和最后一个位置M(-&gt;二分&lt;-二分   &gt;&#x3D;&#x2F;&lt;&#x3D;target)\"></a>34.在排序数组中查找元素的第一个和最后一个位置M(-&gt;二分&lt;-二分   &gt;&#x3D;&#x2F;&lt;&#x3D;target)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210323114302323.png\" alt=\"image-20210323114302323\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tvector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tif(nums.empty()) return &#123;-1, -1&#125;;\n\t\t&#x2F;&#x2F;左端点\n\t\tint l &#x3D; 0, r &#x3D; nums.size() - 1;\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; target) r &#x3D; mid;\n\t\t\telse l &#x3D; mid + 1;\n\t\t&#125;\n\t\t&#x2F;&#x2F;不存在\n\t\tif(nums[r] !&#x3D; target) return &#123;-1, -1&#125;;\n\t\tint L &#x3D; r;\n\t\t&#x2F;&#x2F;右端点\n\t\tl &#x3D; 0, r &#x3D; nums.size() - 1;\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\t\tif(nums[mid] &lt;&#x3D; target) l &#x3D; mid;&#x2F;&#x2F;mid属右\n\t\t\telse r &#x3D; mid - 1;\n\t\t&#125;\n\t\treturn &#123;L, r&#125;;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"35-搜索【插入位置】E-gt-x3D-target的min-first-lt-二分-r-x3D-size\"><a href=\"#35-搜索【插入位置】E-gt-x3D-target的min-first-lt-二分-r-x3D-size\" class=\"headerlink\" title=\"35. 搜索【插入位置】E(&gt;&#x3D; target的min(first)  &lt;-二分  r&#x3D;size)\"></a>35. 搜索【插入位置】E(&gt;&#x3D; target的min(first)  &lt;-二分  r&#x3D;size)</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n\tint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\t&#x2F;&#x2F; &gt;&#x3D; target的min(first)  &lt;-二分\n\t\tint l &#x3D; 0, r &#x3D; nums.size(); &#x2F;&#x2F;size\n\n\t\twhile(l &lt; r) &#123; &#x2F;&#x2F;&lt;size 不加哨兵\n\t\t\tint mid &#x3D; l + r &gt;&gt; 1; &#x2F;&#x2F;下取整floor\n\t\t\tif(nums[mid] &gt;&#x3D; target) r &#x3D; mid;\n\t\t\telse l &#x3D; mid + 1;\n\t\t&#125;\n\t\treturn l;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"36-有效的数独-判断行-x2F-列-x2F-九宫格不同-模拟题-bool-st-9-ij-x2F-ji-x2F-ij-xy\"><a href=\"#36-有效的数独-判断行-x2F-列-x2F-九宫格不同-模拟题-bool-st-9-ij-x2F-ji-x2F-ij-xy\" class=\"headerlink\" title=\"36.有效的数独 判断行&#x2F;列&#x2F;九宫格不同 ( 模拟题 bool st[9];      ij &#x2F; ji &#x2F; ij+xy)\"></a>36.有效的数独 判断行&#x2F;列&#x2F;九宫格不同 ( 模拟题 bool st[9];      ij &#x2F; ji &#x2F; ij+xy)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tbool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n\t\tbool st[9];\n\n\t\t&#x2F;&#x2F;判断行\n\t\tfor (int i &#x3D; 0; i &lt; 9; i++) &#123;\n\t\t\tmemset(st, 0, sizeof st);\n\t\t\tfor (int j &#x3D; 0; j &lt; 9; j++) &#123;\n\t\t\t\tif(board[i][j] !&#x3D; &#39;.&#39;) &#123;\n\t\t\t\t\tint t &#x3D; board[i][j] - &#39;1&#39;;\n\t\t\t\t\tif(st[t]) return false; &#x2F;&#x2F;visited &#x3D;&#x3D;\n\t\t\t\t\tst[t] &#x3D; true;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;判断列 [j][i]\n\t\tfor (int i &#x3D; 0; i &lt; 9; i++) &#123;\n\t\t\tmemset(st, 0, sizeof st);\n\t\t\tfor (int j &#x3D; 0; j &lt; 9; j++) &#123;\n\t\t\t\tif(board[j][i] !&#x3D; &#39;.&#39;) &#123; &#x2F;&#x2F;\n\t\t\t\t\tint t &#x3D; board[j][i] - &#39;1&#39;; &#x2F;&#x2F;\n\t\t\t\t\tif(st[t]) return false;\n\t\t\t\t\tst[t] &#x3D; true;\n\t\t\t\t&#125;\n\t\t\t&#125; \n\t\t&#125;\n\n\t\t&#x2F;&#x2F;判断小方格[i + x][j + y]\n\t\tfor (int i &#x3D; 0; i &lt; 9; i +&#x3D; 3) &#123;\n\t\t\tfor (int j &#x3D; 0; j &lt; 9; j +&#x3D; 3) &#123;&#x2F;&#x2F;anchor:i j\n\t\t\t\tmemset(st, 0, sizeof st);\n\t\t\t\tfor (int x &#x3D; 0; x &lt; 3; x++)\n\t\t\t\t\tfor (int y &#x3D; 0; y &lt; 3; y++)&#x2F;&#x2F;offset:x y\n\t\t\t\t\t\tif(board[i + x][j + y] !&#x3D; &#39;.&#39;) &#123;\n\t\t\t\t\t\t\tint t &#x3D; board[i + x][j + y] - &#39;1&#39;;\n\t\t\t\t\t\t\tif(st[t]) return false;\n\t\t\t\t\t\t\tst[t] &#x3D; true;\n\t\t\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"37-解数独-r-c-cell-dfs-回溯\"><a href=\"#37-解数独-r-c-cell-dfs-回溯\" class=\"headerlink\" title=\"37.解数独 (r c  cell dfs 回溯)\"></a>37.解数独 (r c  cell dfs 回溯)</h1><p>进阶： (0x20搜索9*9状压优化 )、16*16 </p>\n<p><code>row[i][t] = col[j][t] = cell[i / 3][j / 3][t]</code></p>\n<p><code>填  变flag  dfs_next next行不通：回溯!</code></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tbool row[9][9], col[9][9], cell[3][3][9];&#x2F;&#x2F;i行j列num出现过&#x3D;T&#x2F;F\n\n\tvoid solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n\t\tmemset(row, 0, sizeof row);\n\t\tmemset(col, 0, sizeof col);\n\t\tmemset(cell, 0, sizeof cell);\n\t\t\n\t\tfor (int i &#x3D; 0; i &lt; 9; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt; 9; j++)\n\t\t\t\tif(board[i][j] !&#x3D; &#39;.&#39;) &#123;\n\t\t\t\t\tint t &#x3D; board[i][j] - &#39;1&#39;;\n\t\t\t\t\trow[i][t] &#x3D; col[j][t] &#x3D; cell[i &#x2F; 3][j &#x2F; 3][t] &#x3D; true;&#x2F;&#x2F;\n\t\t\t\t&#125;\n\t\tdfs(board, 0, 0);\n\t&#125;\n\n\tbool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123;\n\t\tif(y &#x3D;&#x3D; 9) x++, y &#x3D; 0;\n\t\tif(x &#x3D;&#x3D; 9) return true;\n\t\t&#x2F;&#x2F;cur不可填：next\n\t\tif(board[x][y] !&#x3D; &#39;.&#39;) return dfs(board, x, y + 1);\n\t\t&#x2F;&#x2F;可填：dfs搜cur填i\n\t\tfor (int i &#x3D; 0; i &lt; 9; i++)\n\t\t\tif(!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x &#x2F; 3][y &#x2F; 3][i]) &#123;\n\t\t\t\tboard[x][y] &#x3D; &#39;1&#39; + i;\n\t\t\t\trow[x][i] &#x3D; col[y][i] &#x3D; cell[x &#x2F; 3][y &#x2F; 3][i] &#x3D; true;\n\t\t\t\t&#x2F;&#x2F;递归更新next答案\n\t\t\t\tif(dfs(board, x, y + 1)) return true;\n\t\t\t\t&#x2F;&#x2F;next行不通：回溯!\n\t\t\t\tboard[x][y] &#x3D; &#39;.&#39;;\n\t\t\t\trow[x][i] &#x3D; col[y][i] &#x3D; cell[x &#x2F; 3][y &#x2F; 3][i] &#x3D; false;\n\t\t\t&#125;\n\t\treturn false;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"38-外观数列-序列中的每一项都是对前一项的描述。-cnt-num-双指针-j-k\"><a href=\"#38-外观数列-序列中的每一项都是对前一项的描述。-cnt-num-双指针-j-k\" class=\"headerlink\" title=\"38.外观数列(序列中的每一项都是对前一项的描述。 cnt+num) 双指针[j,k)\"></a>38.外观数列(序列中的每一项都是对前一项的描述。 cnt+num) 双指针[j,k)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tstring countAndSay(int n) &#123;\n\t\tstring s &#x3D; &quot;1&quot;;\n\t\tfor (int i &#x3D; 0; i &lt; n - 1; i++) &#123;&#x2F;&#x2F;第n项 变换n-1次\n\t\t\tstring t; &#x2F;&#x2F;t &#x3D; s;错！\n\t\t\t&#x2F;&#x2F;s[j,k):num&#x3D;&#x3D;\n\t\t\tfor (int j &#x3D; 0; j &lt; s.size();) &#123;\n\t\t\t\tint k &#x3D; j + 1;\n\t\t\t\twhile(k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; s[j]) k++;&#x2F;&#x2F;s[k]!&#x3D;s[j]\n\t\t\t\tt +&#x3D; to_string(k - j) + s[j];&#x2F;&#x2F;k-j个连续s[j]\n\t\t\t\tj &#x3D; k; &#x2F;&#x2F;别忘！！！\n\t\t\t&#125;\n\t\t\ts &#x3D; t;\n\t\t&#125;\n\t\treturn s;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"39-组合总和-递归-无限制重复被选\"><a href=\"#39-组合总和-递归-无限制重复被选\" class=\"headerlink\" title=\"39.组合总和(递归   无限制重复被选)\"></a>39.组合总和(递归   无限制重复被选)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n找出 不重复集candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的数字可以[无限制重复被选取]。\n\n说明：\n所有数字（包括 target）都是正整数。\n解集不能包含重复的组合。 \n*&#x2F;\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; ans;\n\tvector&lt;int&gt; path;\n\t\n\tvector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; c, int target) &#123;\n\t\tdfs(c, 0 , target);\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(vector&lt;int&gt;&amp; c, int u, int target) &#123; &#x2F;&#x2F;target&#x3D;剩余和\n\t\tif(target &#x3D;&#x3D; 0) &#123;\n\t\t\tans.push_back(path);\n\t\t\treturn;\n\t\t&#125;\n\t\tif(u &#x3D;&#x3D; c.size()) return;\n\t\t&#x2F;&#x2F;枚举选i个c[u]\n\t\tfor (int i &#x3D; 0; c[u] * i &lt;&#x3D; target; i++) &#123;\n\t\t\tdfs(c, u+1, target - c[u] * i);&#x2F;&#x2F;0 i&#x3D;1 2 3 4\n\t\t\tpath.push_back(c[u]);&#x2F;&#x2F;i&#x3D;1(用于next loop) 2 3 4 5F\n\t\t&#125;\n\t\t&#x2F;&#x2F;回溯所有c[u]\n\t\tfor (int i &#x3D; 0; c[u] * i &lt;&#x3D; target; i++) &#123;\n\t\t\tpath.pop_back();\n\t\t&#125;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"40-组合总和II-个数限制cnt-有重复，sort\"><a href=\"#40-组合总和II-个数限制cnt-有重复，sort\" class=\"headerlink\" title=\"40.组合总和II +个数限制cnt(有重复，sort)\"></a>40.组合总和II +个数限制cnt(有重复，sort)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">!!!\t\tsort(c.begin(),c.end());\n\t\t\n\t\tint k &#x3D; u + 1;\n\t\twhile(k &lt; c.size() &amp;&amp; c[k] &#x3D;&#x3D; c[u]) k++;\n\t\tint cnt &#x3D; k - u;&#x2F;&#x2F;c[u, k)&#x3D;&#x3D;  集合中共cnt个u</code></pre>\n\n\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n可重复集中所有可以使数字和为 target 的组合。\n每个数字在每个组合中只能使用一次\n【+given number个数限制：多重背包】\n解法：sort c[u, k)&#x3D;&#x3D; &#x2F; hash表:unordered_map\nc[u] * i &lt;&#x3D; target &amp;&amp; i &lt;&#x3D; cnt\n*&#x2F;\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; ans;\n\tvector&lt;int&gt; path;\n\n\tvector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; c, int target) &#123;\n\t\tsort(c.begin(),c.end());\n\t\tdfs(c, 0 , target);\n\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(vector&lt;int&gt;&amp; c, int u,  int target) &#123;\n\t\tif(target &#x3D;&#x3D; 0) &#123;\n\t\t\tans.push_back(path);\n\t\t\treturn;\n\t\t&#125;\n\t\tif(u &#x3D;&#x3D; c.size()) return;\n\n\t\tint k &#x3D; u + 1;\n\t\twhile(k &lt; c.size() &amp;&amp; c[k] &#x3D;&#x3D; c[u]) k++;\n\t\tint cnt &#x3D; k - u;&#x2F;&#x2F;集合中共cnt个u\n\t\t&#x2F;&#x2F;c[u]可用&lt;&#x3D;cnt个\n\t\tfor (int i &#x3D; 0; c[u] * i &lt;&#x3D; target &amp;&amp; i &lt;&#x3D; cnt; i++) &#123;\n\t\t\tdfs(c, k, target - c[u] * i);\n\t\t\tpath.push_back(c[u]);\n\t\t&#125;\n\n\t\tfor (int i &#x3D; 0; c[u] * i &lt;&#x3D; target &amp;&amp; i &lt;&#x3D; cnt; i++) &#123;\n\t\t\tpath.pop_back();\n\t\t&#125;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"41-缺失的第一个正数-unordered-set\"><a href=\"#41-缺失的第一个正数-unordered-set\" class=\"headerlink\" title=\"41. 缺失的第一个正数  unordered_set\"></a>41. 缺失的第一个正数  unordered_set</h1><p>sort+scan,从1开始 ：O(nlogn)</p>\n<p>hash表：O(n) </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;int&gt; hash;\n        for(auto x : nums) hash.insert(x); &#x2F;&#x2F;for(auto x : nums)\n\n        int ans &#x3D; 1;\n        while(hash.count(ans)) ans ++; &#x2F;&#x2F;while\n\n        return ans;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"42-接雨水-单调栈变形-难\"><a href=\"#42-接雨水-单调栈变形-难\" class=\"headerlink\" title=\"42. 接雨水(单调栈变形 难)\"></a>42. 接雨水(单调栈变形 难)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210324175125293.png\" alt=\"image-20210324175125293\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210324224427607.png\" alt=\"image-20210324224427607\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">算法1\n(三次线性扫描) O(n)\n观察整个图形，考虑对水的面积按 列 进行拆解\n注意到，每个矩形条上方所能接受的水的高度，是由它左边 最高的 矩形，和右边 最高的 矩形决定的。具体地，假设第 i 个矩形条的高度为 height[i]，且矩形条左边 最高的 矩形条的高度为 left_max[i]，右边 最高的 矩形条高度为 right_max[i]，则该矩形条上方能接受水的高度为 min(left_max[i], right_max[i]) - height[i]。\n需要分别从左向右扫描求 left_max，从右向左求 right_max，最后统计答案即可。\n注意特判 n 为 0。\n时间复杂度\n三次线性扫描，故只需要 O(n) 的时间。\n空间复杂度\n需要额外 O(n) 的空间记录每个位置左边最高的高度和右边最高的高度。\nC++ 代码\nclass Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        int n &#x3D; height.size(), ans &#x3D; 0;\n        if (n &#x3D;&#x3D; 0)\n            return 0;\n\n        vector&lt;int&gt; left_max(n), right_max(n);\n\n        left_max[0] &#x3D; height[0];\n        for (int i &#x3D; 1; i &lt; n; i++) \n            left_max[i] &#x3D; max(left_max[i - 1], height[i]);\n\n        right_max[n - 1] &#x3D; height[n - 1];\n        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--)\n            right_max[i] &#x3D; max(right_max[i + 1], height[i]);\n\n        for (int i &#x3D; 0; i &lt; n; i++)\n            ans +&#x3D; min(left_max[i], right_max[i]) - height[i]; &#x2F;&#x2F;\n\n        return ans;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;改进版：双指针\nclass Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        int n &#x3D; height.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int l &#x3D; 0, r &#x3D; n - 1;\n        int leftmost &#x3D; height[l], rightmost &#x3D; height[r];\n        int res &#x3D; 0;\n        while (l &lt;&#x3D; r) &#123;\n            if (leftmost &lt; rightmost) &#123;\n                res +&#x3D; leftmost - height[l++];\n                leftmost &#x3D; max(leftmost, height[l]);\n            &#125; else &#123;\n                res +&#x3D; rightmost - height[r--];\n                rightmost &#x3D; max(rightmost, height[r]);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n作者：小雨\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;499&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n    \n\n算法2\n(单调栈) O(n)\n换一种思路，考虑每个位置左边和右边 第一个 比自身不低的矩形条，以及三个矩形条构成的 U 型，相当于对水的面积按 行 进行拆解。\n维护严格单调递减的单调栈。在每次检查栈顶要出栈时，i 为右边第一个比 st.top() 不低的矩形，st.top() 弹出栈顶，并将其记为 top。\n假设此时栈中仍然存在矩形，现在 st.top()（弹栈后的栈顶）、top 与 i 三个位置构成一个 U 型，其中 top 位置代表 U 型的底部，此时可以计算出该 U 型所能接受的水的面积为 (i - st.top() - 1) * (min(height[st.top()], height[i]) - height[top])。\n最后当前矩形进栈。\n时间复杂度\n每个元素最多进栈一次出栈一次，故只需要 O(n) 的时间。\n空间复杂度\n需要额外 O(n) 的空间存储单调栈。\nC++ 代码\nclass Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        int n &#x3D; height.size(), ans &#x3D; 0;\n        stack&lt;int&gt; st;\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            while (!st.empty() &amp;&amp; height[st.top()] &lt;&#x3D; height[i]) &#123;\n                int top &#x3D; st.top();\n                st.pop();\n                if (st.empty()) break;\n                ans +&#x3D; (i - st.top() - 1) \n                        * (min(height[st.top()], height[i]) - height[top]);\n            &#125;\n            st.push(i);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;121&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"43-字符串相乘-str竖式乘-x2F-高精度乘法的基本模板-C-i-j-x3D-A-i-B-j-统一进位-去首0\"><a href=\"#43-字符串相乘-str竖式乘-x2F-高精度乘法的基本模板-C-i-j-x3D-A-i-B-j-统一进位-去首0\" class=\"headerlink\" title=\"43 字符串相乘(str竖式乘&#x2F;高精度乘法的基本模板)     C[i + j] +&#x3D; A[i] * B[j];  统一进位 去首0\"></a>43 字符串相乘(str竖式乘&#x2F;高精度乘法的基本模板)     C[i + j] +&#x3D; A[i] * B[j];  统一进位 去首0</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210325092901453.png\" alt=\"image-20210325092901453\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string multiply(string num1, string num2) &#123;\n        vector&lt;int&gt; A, B;\n        int n &#x3D; num1.size(), m &#x3D; num2.size();\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) A.push_back(num1[i] - &#39;0&#39;);&#x2F;&#x2F;+-&#39;0&#39;\n        for(int i &#x3D; m - 1; i &gt;&#x3D; 0; i--) B.push_back(num2[i] - &#39;0&#39;);\n\n        vector&lt;int&gt; C(n + m);\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; m; j++)\n                C[i + j] +&#x3D; A[i] * B[j];\n\n        for(int i &#x3D; 0, t &#x3D; 0; i &lt; C.size(); i++) &#123;\n            t +&#x3D; C[i];\n            C[i] &#x3D; t % 10; &#x2F;&#x2F;t % 10\n            t &#x2F;&#x3D; 10;\n        &#125;\n\n        int k &#x3D;  C.size() - 1;\n        while(k &gt; 0 &amp;&amp; !C[k]) k--; &#x2F;&#x2F;去除首0     k&gt;&#x3D;0错！:0*0&#x3D;&quot;&quot; !&#x3D;&quot;0&quot;\n\n        string res;\n        while(k &gt;&#x3D; 0) res +&#x3D; C[k--] + &#39;0&#39;;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"—44-通配符匹配-10-简化版-DP-单独匹一切\"><a href=\"#—44-通配符匹配-10-简化版-DP-单独匹一切\" class=\"headerlink\" title=\"—44.通配符匹配(10.简化版)DP *单独匹一切\"></a>—44.通配符匹配(10.简化版)DP *单独匹一切</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210325100826713.png\" alt=\"image-20210325100826713\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n&#39;?&#39; 可以匹配任何单个字符。\n&#39;*&#39; 可以匹配任意字符串（包括空字符串）。 可以不同\n*&#x2F;\nclass Solution &#123;\npublic:\n    bool isMatch(string s, string p) &#123;\n        int n &#x3D; s.size(), m &#x3D; p.size();\n        s &#x3D; &#39; &#39; + s, p &#x3D; &#39; &#39; + p; &#x2F;&#x2F; 1开始  易忘！！！\n        vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1));\n        f[0][0] &#x3D; true;\n\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++)\n            for(int j &#x3D; 1; j &lt;&#x3D; m; j++)\n                if(p[j] &#x3D;&#x3D; &#39;*&#39;)\n                    f[i][j] &#x3D; f[i][j - 1] || i &amp;&amp; f[i - 1][j];\n                else if(s[i] &#x3D;&#x3D; p[j] || p[j] &#x3D;&#x3D; &#39;?&#39;)\n                    f[i][j] &#x3D; i &amp;&amp; f[i - 1][j - 1];\n\n        return f[n][m]; \n    &#125;\n&#125;;</code></pre>\n\n<p>&#x2F;*<br>法二：贪心 AC自动机 wildcard matching<br><a href=\"https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/\">https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/</a><br>*&#x2F;</p>\n<h1 id=\"45-跳跃游戏-II-贪心-优化逆DP-last-最早的可以一步到达-i-的位置-随着-i-单调递增\"><a href=\"#45-跳跃游戏-II-贪心-优化逆DP-last-最早的可以一步到达-i-的位置-随着-i-单调递增\" class=\"headerlink\" title=\"45.跳跃游戏 II  贪心(优化逆DP) last:最早的可以一步到达 i 的位置, 随着 i 单调递增\"></a>45.跳跃游戏 II  贪心(优化逆DP) last:最早的可以一步到达 i 的位置, 随着 i 单调递增</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n给定一个非负整数数组，你最初位于数组的第一个位置。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n目标是out[使用最少的跳跃次数]到达数组的最后一个位置。\n\n最短路模型时间复杂度必然会到 O(n*n)\n\n对方法一优化：(动态规划，+贪心优化) O(n*n)--&gt;O(n)\n首先定义两个指针 last 和 i，数组 f[i] 表示到达 i 所需要的最少步数。\n定义 last 为第一次到达 i 时上一步的位置，last 从 0 开始。\n根据贪心得知，令 f[i] &#x3D; f[last] + 1 后，f[i] 就会是最优值。\n故可以根据 i 来让 last 向后移动，找到【最早的可以一步到达 i 的位置】，然后根据 f[last] 更新 f[i]。\n\n核心思想是动态规划，即 f[i] 表示到达 i 的最少步数。转移时，可以利用贪心来优化，免除了循环 n 来寻找可以转移到位置 i 的最优决策。\n【最早的可以一步到达 i 的位置】：\n这里的贪心思想为，如果在某个位置 last 可以一步到达 i，则 last 之后的位置就都不必再枚举了，\n而且这个 last 是随着 i 单调递增的，所以我们在动态规划的过程中，维护 last 变量。\n\nlast 一定是随着 i 递增的：\n如果有小于 last 的点可以到达 i，会产生矛盾\n假设 last′&lt;last 且也可以到达 i，可以考虑在什么情况下会放弃 last′ 的位置继续向后移动呢？根据算法定义，\n一定存在某个点 j，满足 j&gt;last′+num(last′)，而 i&gt;j，所以 i&gt;last′+num(last′)，即 last′ 一定无法到达 i，矛盾。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; f(n);\n        f[0] &#x3D; 0;\n        int last &#x3D; 0;\n\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            &#x2F;&#x2F; 依次求 f[i] 的值。\n            while (i &gt; last + nums[last]) &#x2F;&#x2F; 【最早的可以一步到达 i 的位置】 根据 i 来更新 last。\n                last++; &#x2F;&#x2F;[last 一定是随着 i 递增的]\n\n            f[i] &#x3D; f[last] + 1; &#x2F;&#x2F; 根据 f[last] 更新 f[i]。\n        &#125;\n        return f[n - 1];\n    &#125;\n&#125;;</code></pre>\n\n<p>&#x2F;*<br>方法一：&lt;-反向查找出发位置 递推 O(n*n)<br>如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？<br>直观上来看，我们可以「贪心」地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。<br>因此，我们可以从左到右遍历数组，选择第一个满足要求的位置。</p>\n<p>方法二：正向查找可到达的最大位置  O(n)<br>从下标 0 出发，[最远可到达]下标 2（max_far）。<br>下标 0 可到达的位置中，下标 1 的值是 3，[从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。]<br><strong>！且last有单调性！</strong><br>在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。<br>在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。<br>如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。<br>*&#x2F;<br>作者：LeetCode-Solution<br>链接：<a href=\"https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/\">https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/</a></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) \n    &#123;\n        int max_far &#x3D; 0;&#x2F;&#x2F; 目前能跳到的最远位置\n        int step &#x3D; 0;   &#x2F;&#x2F; 跳跃次数\n        int end &#x3D; 0;    &#x2F;&#x2F; 上次跳跃可达范围右边界（下次的最右起跳点）\n        for (int i &#x3D; 0; i &lt; nums.size() - 1; i++)\n        &#123;\n            max_far &#x3D; std::max(max_far, i + nums[i]);\n            &#x2F;&#x2F; 到达上次跳跃能到达的右边界了\n            if (i &#x3D;&#x3D; end)\n            &#123;\n                end &#x3D; max_far;  &#x2F;&#x2F; 目前能跳到的最远位置变成了下次起跳位置的有边界\n                step++;         &#x2F;&#x2F; 进入下一次跳跃\n            &#125;\n        &#125;\n        return step;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"46-全排列\"><a href=\"#46-全排列\" class=\"headerlink\" title=\"46.全排列\"></a>46.全排列</h1><p>搜索树一共有 n!+n!&#x2F;2!+n!&#x2F;3!+…&#x3D;n!(1+1&#x2F;2!+1&#x2F;3!+…)≤n!(1+1&#x2F;2+1&#x2F;4+1&#x2F;8+…)&#x3D;2n!个内部节点，在每个内部节点内均会for循环 n 次，因此内部节点的计算量也是 O(n×n!)。 所以总时间复杂度是 O(n×n!)。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;bool&gt; st;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) st.push_back(false);\n        dfs(nums, 0);\n        return ans;\n    &#125;\n\n    void dfs(vector&lt;int&gt; &amp;nums, int u)\n    &#123;\n        if (u &#x3D;&#x3D; nums.size())\n        &#123;\n            ans.push_back(path);\n            return ;\n        &#125;\n\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ )\n            if (!st[i])\n            &#123;\n                st[i] &#x3D; true;\n                path.push_back(nums[i]); &#x2F;&#x2F; path[u] &#x3D; nums[i];\n                dfs(nums, u + 1);\n                st[i] &#x3D; false;\n                path.pop_back(); &#x2F;&#x2F; 没有了vector&lt;bool&gt;(nums.size()); 就必须pop！！！\n            &#125;\n    &#125;\n&#125;;\n\n\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;bool&gt; st;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        st &#x3D; vector&lt;bool&gt;(nums.size()); &#x2F;&#x2F;\n        path &#x3D; vector&lt;int&gt;(nums.size()); &#x2F;&#x2F;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) st.push_back(false);\n        dfs(nums, 0);\n        return ans;\n    &#125;\n\n    void dfs(vector&lt;int&gt; &amp;nums, int u)\n    &#123;\n        if (u &#x3D;&#x3D; nums.size())\n        &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ )\n            if (!st[i])\n            &#123;\n                path[u] &#x3D; nums[i];\n                st[i] &#x3D; true;\n                dfs(nums, u + 1);\n                st[i] &#x3D; false;\n                &#x2F;&#x2F;path[u] &#x3D; 0; &#x2F;&#x2F;false 就会覆盖,需要配合&#x2F;&#x2F; &#x2F;&#x2F; !!!\n            &#125;\n    &#125;\n&#125;;\n</code></pre>\n\n<p>policy2: 字母枚举位置：字典序</p>\n<p><a href=\"https://www.acwing.com/solution/content/4340/\">https://www.acwing.com/solution/content/4340/</a></p>\n<p>这两段代码只有两个字母之差：<br>path[u] &#x3D; nums[i]; &#x2F;&#x2F;将未使用过的数字放到指定位置</p>\n<p>path[i] &#x3D; nums[u]; &#x2F;&#x2F;将指定数字放入未使用的位置</p>\n<h1 id=\"47-全排列II（有重复数字）\"><a href=\"#47-全排列II（有重复数字）\" class=\"headerlink\" title=\"47. 全排列II（有重复数字）\"></a>47. 全排列II（有重复数字）</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326113906234.png\" alt=\"image-20210326113906234\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n相同数字不可跳着用，必须挨个用！\n本质就是对于重复的点之间相对位置不变。如[1,1,1,3,3],在放第一个1的位置后，后面的1不能放在其前面，\n这样就避免了重复\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;bool&gt; st;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(), nums.end()); &#x2F;&#x2F;\n        st &#x3D; vector&lt;bool&gt;(nums.size()); &#x2F;&#x2F;\n        path &#x3D; vector&lt;int&gt;(nums.size()); &#x2F;&#x2F;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) st.push_back(false);\n        dfs(nums, 0);\n        return ans;\n    &#125;\n\n    void dfs(vector&lt;int&gt; &amp;nums, int u)\n    &#123;\n        if (u &#x3D;&#x3D; nums.size())\n        &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ )\n            if (!st[i])\n            &#123;\n            \tif(i &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i] &amp;&amp; ! st[i - 1]) continue; &#x2F;&#x2F;跳着用\n                path[u] &#x3D; nums[i];\n                st[i] &#x3D; true;\n                dfs(nums, u + 1);\n                st[i] &#x3D; false;\n            &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"48-旋转图像\"><a href=\"#48-旋转图像\" class=\"headerlink\" title=\"48.旋转图像\"></a>48.旋转图像</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326120138977.png\" alt=\"image-20210326120138977\"></p>\n<p>方阵  顺时针旋转90度&#x3D;&#x3D;沿对角线翻转+沿纵轴翻转（swap）</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; i; j++)\n                swap(matrix[i][j], matrix[j][i]);\n\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0, k &#x3D; n - 1; j &lt; k; j++, k--)\n                swap(matrix[i][j], matrix[i][k]);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"49-字母异位词分组-sort正序做hash索引\"><a href=\"#49-字母异位词分组-sort正序做hash索引\" class=\"headerlink\" title=\"49.字母异位词分组(sort正序做hash索引)\"></a>49.字母异位词分组(sort正序做hash索引)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326153649835.png\" alt=\"image-20210326153649835\"></p>\n<p>或者想出一种与字母顺序无关的str_hash法</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;\n        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;\n        for(auto&amp; str: strs) &#123;\n            string nstr &#x3D; str;\n            sort(nstr.begin(), nstr.end());\n            hash[nstr].push_back(str);\n        &#125;\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n        for(auto&amp; item: hash) res.push_back(item.second);\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n\n\n<h1 id=\"50-Pow-x-n-qmi模板-二进制拆分\"><a href=\"#50-Pow-x-n-qmi模板-二进制拆分\" class=\"headerlink\" title=\"50.Pow(x, n) qmi模板  二进制拆分\"></a>50.Pow(x, n) qmi模板  二进制拆分</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326160213444.png\" alt=\"image-20210326160213444\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    double myPow(double x, int n) &#123;\n        typedef long long LL;\n        bool is_minus &#x3D; n &lt; 0;\n        double res &#x3D; 1;\n        for(LL k &#x3D; abs(LL(n)); k; k &gt;&gt;&#x3D; 1) &#123;\n            if(k &amp; 1) res *&#x3D; x;\n            x *&#x3D; x;\n        &#125;\n        if(is_minus) res &#x3D; 1 &#x2F; res;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"51-N皇后：case-col-i-dg-u-i-n-udg-u-i-O-n-n\"><a href=\"#51-N皇后：case-col-i-dg-u-i-n-udg-u-i-O-n-n\" class=\"headerlink\" title=\"51.N皇后：case  col[i] dg[u - i + n] udg[u + i]  O(n*n!)\"></a>51.N皇后：case  col[i] dg[u - i + n] udg[u + i]  O(n*n!)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326161704489.png\" alt=\"image-20210326161704489\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int n;\n    vector&lt;bool&gt; col, dg, udg;\n    vector&lt;vector&lt;string&gt;&gt; ans;\n    vector&lt;string&gt; path;\n\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int _n) &#123;\n        n &#x3D; _n;\n        col &#x3D; vector&lt;bool&gt;(n);\n        dg &#x3D; udg &#x3D; vector&lt;bool&gt;(n * 2);\n        path &#x3D; vector&lt;string&gt;(n, string(n, &#39;.&#39;));\n\n        dfs(0);\n        return ans;\n    &#125;\n\n    void dfs(int u) &#123;\n        if(u &#x3D;&#x3D; n) &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            if(!col[i] &amp;&amp; !dg[u - i + n] &amp;&amp; !udg[u + i]) &#123;\n                col[i] &#x3D; dg[u - i + n] &#x3D; udg[u + i] &#x3D; true;\n                path[u][i] &#x3D; &#39;Q&#39;;\n                dfs(u + 1);\n                path[u][i] &#x3D; &#39;.&#39;;\n                col[i] &#x3D; dg[u - i + n] &#x3D; udg[u + i] &#x3D; false;\n            &#125;\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"52-N皇后II-case数-if-u-x3D-x3D-n-return-1-res-x3D-dfs-u-1-O-n\"><a href=\"#52-N皇后II-case数-if-u-x3D-x3D-n-return-1-res-x3D-dfs-u-1-O-n\" class=\"headerlink\" title=\"52.N皇后II   case数   if(u &#x3D;&#x3D; n) return 1;  res +&#x3D; dfs(u + 1);  O(n!)\"></a>52.N皇后II   case数   if(u &#x3D;&#x3D; n) return 1;  res +&#x3D; dfs(u + 1);  O(n!)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;52 N皇后II    51---&gt;res.size() if(u &#x3D;&#x3D; n) return 1;  res +&#x3D; dfs(u + 1);\nclass Solution &#123;\npublic:\n    int n;\n    vector&lt;bool&gt; col, dg, udg;\n    \n    int totalNQueens(int _n) &#123;\n        n &#x3D; _n;\n        col &#x3D; vector&lt;bool&gt;(n);\n        dg &#x3D; udg &#x3D; vector&lt;bool&gt;(n * 2);\n\n        return dfs(0);\n    &#125;\n\n    int dfs(int u) &#123;\n        if(u &#x3D;&#x3D; n) return 1;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            if(!col[i] &amp;&amp; !dg[u - i + n] &amp;&amp; !udg[u + i]) &#123;\n                col[i] &#x3D; dg[u - i + n] &#x3D; udg[u + i] &#x3D; true;\n                res +&#x3D; dfs(u + 1);\n                col[i] &#x3D; dg[u - i + n] &#x3D; udg[u + i] &#x3D; false;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"—-why-yxc版分治是O-n-53-最大子序和-DP：f-i-x3D-max-nums-i-nums-i-f-i-1-、-分治：-lt-–mid–-gt-lmax-区间前一半的最大后缀和-rmax-区间后一半的最大前缀和\"><a href=\"#—-why-yxc版分治是O-n-53-最大子序和-DP：f-i-x3D-max-nums-i-nums-i-f-i-1-、-分治：-lt-–mid–-gt-lmax-区间前一半的最大后缀和-rmax-区间后一半的最大前缀和\" class=\"headerlink\" title=\"—[why? yxc版分治是O(n)?] 53.最大子序和  DP：f[i] &#x3D; max(nums[i], nums[i] + f[i-1])、 分治：&lt;–mid–&gt; lmax:区间前一半的最大后缀和  rmax:区间后一半的最大前缀和\"></a>—[why? yxc版分治是O(n)?] 53.最大子序和  DP：f[i] &#x3D; max(nums[i], nums[i] + f[i-1])、 分治：&lt;–mid–&gt; lmax:区间前一半的最大后缀和  rmax:区间后一半的最大前缀和</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326170016402.png\" alt=\"image-20210326170016402\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;DP T&#x3D;O(n)  S&#x3D;O(1)   f[i] &#x3D; max(nums[i], nums[i] + f[i-1])\nclass Solution &#123;\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; INT_MIN;\n        for(int i &#x3D; 0, last &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            last &#x3D; nums[i] + max(last, 0);\n            res &#x3D; max(res, last);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;分治 O(n) why？？？\n&#x2F;* yxc\n(不)跨  前后半区间和sum\nres.ls &#x3D; max(L.ls, L.sum + R.ls);\nres.rs &#x3D; max(R.rs, R.sum + L.rs);\n*&#x2F;\nclass Solution &#123;\npublic:\n    struct Node &#123;\n        int sum, s, ls, rs;\n    &#125;;\n\n    Node build(vector&lt;int&gt;&amp; nums, int l, int r) &#123;\n        if(l &#x3D;&#x3D; r) &#123;\n            int v &#x3D; max(nums[l], 0); &#x2F;&#x2F;所以特判全负\n            return &#123;nums[l], v, v, v&#125;;\n        &#125;\n        int mid &#x3D; (l + r) &gt;&gt; 1;\n        auto L &#x3D; build(nums, l, mid), R &#x3D; build(nums, mid + 1, r);\n        Node res;\n        res.sum &#x3D; L.sum + R.sum;\n        res.s &#x3D; max(max(L.s, R.s), L.rs + R.ls);\n        res.ls &#x3D; max(L.ls, L.sum + R.ls);\n        res.rs &#x3D; max(R.rs, R.sum + L.rs);\n        return res;\n    &#125;\n\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; INT_MIN;\n        for(auto x: nums) res &#x3D; max(res, x);\n        if(res &lt; 0) return res; &#x2F;&#x2F;特判：全为负数\n        auto t &#x3D; build(nums, 0, nums.size() - 1);\n        return  t.s;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;分治 O(n*logn)\n&#x2F;&#x2F; &lt;--mid--&gt; lmax:区间前一半的最大后缀和  rmax:区间后一半的最大前缀和\nclass Solution &#123;\npublic:\n    int calc(int l, int r, vector&lt;int&gt;&amp; nums) &#123;\n        if (l &#x3D;&#x3D; r)\n            return nums[l];\n        int mid &#x3D; (l + r) &gt;&gt; 1;\n        int lmax &#x3D; nums[mid], lsum &#x3D; 0, rmax &#x3D; nums[mid + 1], rsum &#x3D; 0;\n\n        for (int i &#x3D; mid; i &gt;&#x3D; l; i--) &#123;\n            lsum +&#x3D; nums[i];\n            lmax &#x3D; max(lmax, lsum);\n        &#125;\n\n        for (int i &#x3D; mid + 1; i &lt;&#x3D; r; i++) &#123;\n            rsum +&#x3D; nums[i];\n            rmax &#x3D; max(rmax, rsum);\n        &#125;\n\n        return max(max(calc(l, mid, nums), calc(mid + 1, r, nums)), lmax + rmax);\n    &#125;\n\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        return calc(0, n - 1, nums);\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;133&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;拓展：acwing245 你能回答这些问题吗？  线段树 algo提高课\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;1608&#x2F;1&#x2F;\n</code></pre>\n\n\n\n<h1 id=\"54-螺旋矩阵\"><a href=\"#54-螺旋矩阵\" class=\"headerlink\" title=\"54. 螺旋矩阵\"></a>54. 螺旋矩阵</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326204148217.png\" alt=\"image-20210326204148217\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tvector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n\t\tvector&lt;int&gt; res;\n\t\tif(matrix.empty()) return res;\n\t\tint n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n\t\tvector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m, false));&#x2F;&#x2F;\n\t\t\n\t\tint dx[] &#x3D; &#123;0, 1, 0, -1&#125;, dy[] &#x3D; &#123;1, 0 ,-1, 0&#125;;\n\t\t&#x2F;&#x2F;先向右\n\t\tfor (int i &#x3D; 0, x &#x3D; 0, y &#x3D; 0, d &#x3D; 0; i &lt; n * m; i++)\n\t\t&#123;\n\t\t\tres.push_back(matrix[x][y]);\n\t\t\tst[x][y] &#x3D; true;\n\t\t\t&#x2F;&#x2F;合法next_pos\n\t\t\tint a &#x3D; x + dx[d], b &#x3D; y + dy[d];\n\t\t\tif(a &lt; 0 || a &gt;&#x3D; n || b &lt; 0 || b &gt;&#x3D; m || st[a][b])&#x2F;&#x2F;st可省： res[a][b]\n\t\t\t&#123;\n\t\t\t\td &#x3D; (d + 1) % 4;\n\t\t\t\ta &#x3D; x + dx[d], b &#x3D; y + dy[d];\n\t\t\t&#125;\n\t\t\tx &#x3D; a, y &#x3D; b;&#x2F;&#x2F;更新\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"55-跳跃游戏-能否跳到（45-II-到最后min-steps）\"><a href=\"#55-跳跃游戏-能否跳到（45-II-到最后min-steps）\" class=\"headerlink\" title=\"55. 跳跃游戏:能否跳到（45 II:到最后min steps）\"></a>55. 跳跃游戏:能否跳到（45 II:到最后min steps）</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断【是否能够到达】最后一个下标。\n输入：nums &#x3D; [3,2,1,0,4]\n输出：false\n能跳到的区间必然是连续的一段：No、Yes矛盾\nj&#x3D;最远能到达&#x3D;i+n[i] 有i到达不了，就到不了最后\n*&#x2F;\nclass Solution &#123;\npublic:\n    bool canJump(vector&lt;int&gt;&amp; nums) &#123;\n        for(int i &#x3D; 0, j &#x3D; 0; i &lt; nums.size() ; i++) &#123;\n            if(j &lt; i) return false;\n            j &#x3D; max(j, i + nums[i]);\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"56-合并区间\"><a href=\"#56-合并区间\" class=\"headerlink\" title=\"56.合并区间\"></a>56.合并区间</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326210555271.png\" alt=\"image-20210326210555271\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; a) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n\n        sort(a.begin(), a.end());\n        int l &#x3D; a[0][0], r &#x3D; a[0][1];\n        for(int i &#x3D; 1; i &lt; a.size(); i++) &#123;\n            if(r &lt; a[i][0]) &#123; &#x2F;&#x2F;没交集\n                res.push_back(&#123;l, r&#125;);\n                l &#x3D; a[i][0], r &#x3D; a[i][1];\n            &#125; else &#123; &#x2F;&#x2F;有交集\n                r &#x3D; max(r, a[i][1]); &#x2F;&#x2F;r &#x3D; a[i][1];错！没考虑前包含后！\n            &#125;\n        &#125;\n        res.push_back(&#123;l, r&#125;);\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"57-插入区间-模拟\"><a href=\"#57-插入区间-模拟\" class=\"headerlink\" title=\"57.插入区间 模拟\"></a>57.插入区间 模拟</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210326212801154.png\" alt=\"image-20210326212801154\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int k &#x3D; 0;\n        while(k &lt; a.size() &amp;&amp; a[k][1] &lt; b[0]) res.push_back(a[k++]);\n        \n        if(k &lt; a.size()) &#123;\n            b[0] &#x3D; min(b[0], a[k][0]); &#x2F;&#x2F;定bl\n            while(k &lt; a.size() &amp;&amp; a[k][0] &lt;&#x3D; b[1]) b[1] &#x3D; max(b[1], a[k++][1]); &#x2F;&#x2F;没断，定br\n        &#125;\n        res.push_back(b);\n\n        while(k &lt; a.size()) res.push_back(a[k++]);\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"58-最后一个单词的长度-stringstream、双指针\"><a href=\"#58-最后一个单词的长度-stringstream、双指针\" class=\"headerlink\" title=\"58.最后一个单词的长度(stringstream、双指针)\"></a>58.最后一个单词的长度(stringstream、双指针)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;stringstream ssin(s);   while(ssin &gt;&gt; word)\nclass Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        stringstream ssin(s);\n        int res &#x3D; 0;\n        string word;\n        while(ssin &gt;&gt; word) res &#x3D; word.size();\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;双指针\nclass Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        for(int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n            if(s[i] &#x3D;&#x3D; &#39; &#39;) continue;\n            int j &#x3D; i - 1;\n            while(j &gt;&#x3D; 0 &amp;&amp; s[j] !&#x3D; &#39; &#39;) j--;\n            return  i - j;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"59-螺旋矩阵-II-同54\"><a href=\"#59-螺旋矩阵-II-同54\" class=\"headerlink\" title=\"59. 螺旋矩阵 II 同54\"></a>59. 螺旋矩阵 II 同54</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n));\n\n\t\tint dx[] &#x3D; &#123;0, 1, 0, -1&#125;, dy[] &#x3D; &#123;1, 0 ,-1, 0&#125;;\n\t\tfor (int i &#x3D; 1, x &#x3D; 0, y &#x3D; 0, d &#x3D; 0; i &lt;&#x3D; n * n; i++) &#123;\n\t\t\tres[x][y] &#x3D; i;\n\t\t\tint a &#x3D; x + dx[d], b &#x3D; y + dy[d];\n\t\t\tif(a &lt; 0 || a &gt;&#x3D; n || b &lt; 0 || b &gt;&#x3D; n || res[a][b])\n\t\t\t&#123;\n\t\t\t\td &#x3D; (d + 1) % 4;\n\t\t\t\ta &#x3D; x + dx[d], b &#x3D; y + dy[d];\n\t\t\t&#125;\n\t\t\tx &#x3D; a, y &#x3D; b;&#x2F;&#x2F;更新\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"60-第k个排列-if-fact-lt-k-k-x3D-fact\"><a href=\"#60-第k个排列-if-fact-lt-k-k-x3D-fact\" class=\"headerlink\" title=\"60. 第k个排列   if(fact &lt; k) k -&#x3D; fact;\"></a>60. 第k个排列   if(fact &lt; k) k -&#x3D; fact;</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210327110343788.png\" alt=\"image-20210327110343788\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;next_permutation k-1次 O(n!*k)\nclass Solution &#123;\npublic:\n    string getPermutation(int n, int k) &#123;\n        string res;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) res +&#x3D; to_string(i);\n        for(int i &#x3D; 0; i &lt; k - 1; i++)\n            next_permutation(res.begin(), res.end()); \n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;O(n*n)\nclass Solution &#123;\npublic:\n    string getPermutation(int n, int k) &#123;\n        string res;\n        vector&lt;bool&gt; st(10);\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            int fact &#x3D; 1;\n            for(int j &#x3D; 1; j &lt;&#x3D; n - i - 1; j++) fact *&#x3D; j; &#x2F;&#x2F;(n-1)!\n\n            for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n                if(!st[j]) &#123;\n                    if(fact &lt; k) k -&#x3D; fact; &#x2F;&#x2F;！！！\n                    else &#123;\n                        res +&#x3D; to_string(j);\n                        st[j] &#x3D; true;\n                        break; &#x2F;&#x2F;枚举填j，填完退出循环\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"61-旋转链表-rotateRight-k-k-x3D-n-tail-p\"><a href=\"#61-旋转链表-rotateRight-k-k-x3D-n-tail-p\" class=\"headerlink\" title=\"61.旋转链表:rotateRight_k       k %&#x3D; n;  tail  p\"></a>61.旋转链表:rotateRight_k       k %&#x3D; n;  tail  p</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210327111751789.png\" alt=\"image-20210327111751789\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* rotateRight(ListNode* head, int k) &#123;\n        if(!head) return head;\n        int n &#x3D; 0;\n        ListNode* tail;\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next) &#123;\n            tail &#x3D; p;\n            n++;\n        &#125;\n        k %&#x3D; n; &#x2F;&#x2F;k &gt;&#x3D; n \n        if(!k) return head;\n\n        auto p &#x3D; head;\n        for(int i &#x3D; 0; i &lt; n - k - 1; i++) p &#x3D; p-&gt;next;\n        tail-&gt;next &#x3D; head;\n        head &#x3D; p-&gt;next;\n        p-&gt;next &#x3D; nullptr;\n        return head;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"62-64-不同路径-m-n-左上-gt-右下\"><a href=\"#62-64-不同路径-m-n-左上-gt-右下\" class=\"headerlink\" title=\"62.[-64]不同路径    m*n 左上-&gt;右下\"></a>62.[-64]不同路径    m*n 左上-&gt;右下</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int uniquePaths(int m, int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m));\n\n        for(int i &#x3D; 0; i &lt; n; i++) \n            for(int j &#x3D; 0; j &lt; m; j++)\n                if(!i &amp;&amp; !j) f[i][j] &#x3D; 1;\n                else &#123;\n                    if(i) f[i][j] +&#x3D; f[i - 1][j]; &#x2F;&#x2F;\n                    if(j) f[i][j] +&#x3D; f[i][j - 1]; &#x2F;&#x2F;\n                &#125;\n        return f[n - 1][m - 1]; &#x2F;&#x2F;nm mn都行\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"63-不同路径II-默认f-有障碍物1-x3D-0\"><a href=\"#63-不同路径II-默认f-有障碍物1-x3D-0\" class=\"headerlink\" title=\"63.不同路径II  默认f[有障碍物1]&#x3D;0\"></a>63.不同路径II  默认f[有障碍物1]&#x3D;0</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; o) &#123;\n        int m &#x3D; o.size();\n        if(!m) return 0;\n        int n &#x3D; o[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(n));\n\n        for(int i &#x3D; 0; i &lt; m; i++) \n            for(int j &#x3D; 0; j &lt; n; j++)\n                if(!o[i][j] &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F;无障碍\n                    if(!i &amp;&amp; !j) f[i][j] &#x3D; 1;\n                    else &#123;\n                        if(i) f[i][j] +&#x3D; f[i - 1][j]; &#x2F;&#x2F;\n                        if(j) f[i][j] +&#x3D; f[i][j - 1]; &#x2F;&#x2F;\n                    &#125;\n                &#125;\n                \n        return f[m - 1][n - 1];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"64-最小路径和-weight-算min\"><a href=\"#64-最小路径和-weight-算min\" class=\"headerlink\" title=\"64.最小路径和  +weight 算min\"></a>64.最小路径和  +weight 算min</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210327115335145.png\" alt=\"image-20210327115335145\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int n &#x3D; grid.size();\n        if(!n) return 0;\n        int m &#x3D; grid[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, INT_MAX));&#x2F;&#x2F;min init&#x3D;INT_MAX\n\n        for(int i &#x3D; 0; i &lt; n; i++) \n            for(int j &#x3D; 0; j &lt; m; j++)\n                if(!i &amp;&amp; !j) f[i][j] &#x3D; grid[i][j];\n                else &#123;\n                    if(i) f[i][j] &#x3D; min(f[i][j], f[i - 1][j] + grid[i][j]); &#x2F;&#x2F;\n                    if(j) f[i][j] &#x3D; min(f[i][j], f[i][j - 1] + grid[i][j]); &#x2F;&#x2F;\n                &#125;\n        return f[n - 1][m - 1];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"65-有效数字-bool-s2f-模拟-e-NeN-e-e\"><a href=\"#65-有效数字-bool-s2f-模拟-e-NeN-e-e\" class=\"headerlink\" title=\"65.有效数字     bool:s2f 模拟 +- .e NeN e. e+-\"></a>65.有效数字     bool:s2f 模拟 +- .e NeN e. e+-</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210327122619721.png\" alt=\"image-20210327122619721\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n(模拟，字符串处理) O(n)\n先去除行首和行尾空格；\n行首如果有一个正负号，直接忽略；\n如果字符串为空或只有一个&#39;.&#39;，则不是一个合法数；\n循环整个字符串，去掉以下几种情况：\n(1) &#39;.&#39;或&#39;e&#39;多于1个;\n(2) &#39;.&#39;在&#39;e&#39;后面出现；\n(3) &#39;e&#39;后面或前面为空，或者&#39;e&#39;前面紧跟着&#39;.&#39;；  &quot;.e&quot;\n(4) &#39;e&#39;后面紧跟着正负号，但正负号后面为空；    &quot;e+&quot;\n剩下的情况都合法；\n*&#x2F;\nclass Solution &#123;\npublic:\n    bool isNumber(string s) &#123;\n        int l &#x3D; 0, r &#x3D; s.size() - 1;\n        while (l &lt;&#x3D; r &amp;&amp; s[l] &#x3D;&#x3D; &#39; &#39;) l ++ ;\n        while (l &lt;&#x3D; r &amp;&amp; s[r] &#x3D;&#x3D; &#39; &#39;) r -- ;\n        if (l &gt; r) return false;\n        s &#x3D; s.substr(l, r - l + 1);\n        if (s[0] &#x3D;&#x3D; &#39;-&#39; || s[0] &#x3D;&#x3D; &#39;+&#39;) s &#x3D; s.substr(1);\n        if (s.empty() || s[0] &#x3D;&#x3D; &#39;.&#39; &amp;&amp; (s.size() &#x3D;&#x3D; 1 || s[1] &#x3D;&#x3D; &#39;e&#39; || s[1] &#x3D;&#x3D; &#39;E&#39;)) \n            return false; &#x2F;&#x2F;&quot;.e&quot;\n\n        int dot &#x3D; 0, e &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            if (s[i] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                if(dot &gt; 0 || e &gt; 0) return false; &#x2F;&#x2F;&quot;e.&quot;\n                dot ++ ;\n            &#125; else if (s[i] &#x3D;&#x3D; &#39;e&#39; || s[i] &#x3D;&#x3D; &#39;E&#39;) &#123;\n                e ++ ;\n                if (!i || i + 1 &#x3D;&#x3D; s.size() || e &gt; 1 ) return false;\n                if (s[i + 1] &#x3D;&#x3D; &#39;+&#39; || s[i + 1] &#x3D;&#x3D; &#39;-&#39;)\n                &#123;\n                    if (i + 2 &#x3D;&#x3D; s.size()) return false;&#x2F;&#x2F;&quot;e+-&quot;\n                    i ++ ;\n                &#125;\n            &#125;\n            else if (s[i] &lt; &#39;0&#39; || s[i] &gt; &#39;9&#39;) return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"66-array-加一-reverse-进位t\"><a href=\"#66-array-加一-reverse-进位t\" class=\"headerlink\" title=\"66.(array)加一  reverse 进位t\"></a>66.(array)加一  reverse 进位t</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;\n        reverse(digits.begin(), digits.end());\n        int t &#x3D; 1;\n        for(auto&amp; x: digits) &#123;\n            t +&#x3D; x;\n            x &#x3D; t % 10;\n            t &#x2F;&#x3D; 10;\n        &#125;\n        if(t) digits.push_back(t);\n\n        reverse(digits.begin(), digits.end());\n        return digits;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"67-二进制求和-reverse-t-同66\"><a href=\"#67-二进制求和-reverse-t-同66\" class=\"headerlink\" title=\"67.二进制求和 reverse t 同66\"></a>67.二进制求和 reverse t 同66</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string addBinary(string a, string b) &#123;\n        reverse(a.begin(), a.end());\n        reverse(b.begin(), b.end());\n        \n        string c;\n        for(int i &#x3D; 0, t &#x3D; 0; i &lt; a.size() || i &lt; b.size() || t; i++) &#123; &#x2F;&#x2F; || t\n            if(i &lt; a.size()) t +&#x3D; a[i] - &#39;0&#39;;\n            if(i &lt; b.size()) t +&#x3D; b[i] - &#39;0&#39;;\n            c +&#x3D; to_string(t % 2);\n            t &#x2F;&#x3D; 2;\n        &#125;\n\n        reverse(c.begin(), c.end());\n        return c;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"68-文本左右对齐\"><a href=\"#68-文本左右对齐\" class=\"headerlink\" title=\"68.文本左右对齐\"></a>68.文本左右对齐</h1><p>if (j &#x3D;&#x3D; words.size() || j &#x3D;&#x3D; i + 1) { &#x2F;&#x2F;左对齐</p>\n<p>int cnt &#x3D; j - i - 1, r &#x3D; maxWidth - len + cnt; &#x2F;&#x2F;均分space</p>\n<p>while (k &lt; r % cnt) line +&#x3D; string(r &#x2F; cnt + 1, ‘ ‘) + words[i + k + 1], k++;<br>while (k &lt; cnt) line +&#x3D; string(r &#x2F; cnt, ‘ ‘) + words[i + k + 1], k++;</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123;\n        vector&lt;string&gt; res;\n        for (int i &#x3D; 0; i &lt; words.size();)\n        &#123;\n            int j &#x3D; i + 1, len &#x3D; words[i].size();\n            while (j &lt; words.size() &amp;&amp; len + 1 + words[j].size() &lt;&#x3D; maxWidth)\n                len +&#x3D; 1 + words[j ++ ].size();\n\n            string line &#x3D; words[i];\n            if (j &#x3D;&#x3D; words.size() || j &#x3D;&#x3D; i + 1) &#123; &#x2F;&#x2F;左对齐\n                for (int k &#x3D; i + 1; k &lt; j; k ++ ) line +&#x3D; &#39; &#39; + words[k];\n                while (line.size() &lt; maxWidth) line +&#x3D; &#39; &#39;;\n            &#125; else &#123; &#x2F;&#x2F;左右对齐\n                int cnt &#x3D; j - i - 1, r &#x3D; maxWidth - len + cnt; &#x2F;&#x2F;均分space\n                int k &#x3D; 0;\n                while (k &lt; r % cnt) line +&#x3D; string(r &#x2F; cnt + 1, &#39; &#39;) + words[i + k + 1], k++;\n                while (k &lt; cnt) line +&#x3D; string(r &#x2F; cnt, &#39; &#39;) + words[i + k + 1], k++;\n            &#125;\n            res.push_back(line);\n            i &#x3D; j;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"69-x-的平方根-sqrt-floor-二分找-max-y-2-lt-x3D-x\"><a href=\"#69-x-的平方根-sqrt-floor-二分找-max-y-2-lt-x3D-x\" class=\"headerlink\" title=\"69.x 的平方根 sqrt+floor  二分找 max_y^2 &lt;&#x3D; x\"></a>69.x 的平方根 sqrt+floor  二分找 max_y^2 &lt;&#x3D; x</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n&lt;防止x&#x3D;&#x3D;INT_MAX  mid*mid越界&gt;\nl + 1ll + r\nif(mid &lt;&#x3D; x &#x2F; mid)\n*&#x2F;\nclass Solution &#123;\npublic:\n    int mySqrt(int x) &#123;\n        int l &#x3D; 0, r &#x3D; x;\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + 1ll + r &gt;&gt; 1;\n            if(mid &lt;&#x3D; x &#x2F; mid) l &#x3D; mid;\n            else r &#x3D; mid - 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"70-爬楼梯-每次你可以爬1或2个台阶-fib-0-x3D-1-fib-1-x3D-1-fib-2-x3D-2-滚动abc-while-–n-x2F-x2F-loop-n-1\"><a href=\"#70-爬楼梯-每次你可以爬1或2个台阶-fib-0-x3D-1-fib-1-x3D-1-fib-2-x3D-2-滚动abc-while-–n-x2F-x2F-loop-n-1\" class=\"headerlink\" title=\"70.爬楼梯 每次你可以爬1或2个台阶 fib(0)&#x3D;1 fib(1)&#x3D;1 fib(2)&#x3D;2 滚动abc while(–n) { &#x2F;&#x2F; loop:n-1\"></a>70.爬楼梯 每次你可以爬1或2个台阶 fib(0)&#x3D;1 fib(1)&#x3D;1 fib(2)&#x3D;2 滚动abc while(–n) { &#x2F;&#x2F; loop:n-1</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210327170338066.png\" alt=\"image-20210327170338066\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int climbStairs(int n) &#123;\n        int a &#x3D; 1, b &#x3D; 1;\n        while(--n) &#123; &#x2F;&#x2F; loop:n-1\n            int c &#x3D; a + b;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n        return b;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"71-简化路径-模拟stk操作-back-string-res-pop-back-x3D-clear\"><a href=\"#71-简化路径-模拟stk操作-back-string-res-pop-back-x3D-clear\" class=\"headerlink\" title=\"71 简化路径 模拟stk操作  back() string res.pop_back(); +&#x3D; clear\"></a>71 简化路径 模拟stk操作  back() string res.pop_back(); +&#x3D; clear</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n如果遇到 &quot;..&quot;，则返回上级目录；\n如果遇到 &quot;.&quot;或多余的斜杠，则不做任何处理：\n其它情况，表示进入某个子目录，我们在 res 后面补上新路径即可；\n*&#x2F;\nclass Solution &#123;\npublic:\n    string simplifyPath(string path) &#123;\n        if (path.back() !&#x3D; &#39;&#x2F;&#39;) path +&#x3D; &#39;&#x2F;&#39;; &#x2F;&#x2F; &quot;..http:&#x2F;&#x2F;cache.itzy8.top&#x2F;为一个单位&quot;\n        string res, name;\n        for (auto c : path) &#123;\n            if(c !&#x3D; &#39;&#x2F;&#39;) name +&#x3D; c;\n            else &#123;\n                if (name &#x3D;&#x3D; &quot;..&quot;) &#123;\n                    while (res.size() &amp;&amp; res.back() !&#x3D; &#39;&#x2F;&#39;) res.pop_back(); &#x2F;&#x2F; del name\n                    if (res.size()) res.pop_back(); &#x2F;&#x2F; del &#x2F;\n                &#125; else if (name !&#x3D; &quot;&quot; &amp;&amp; name !&#x3D; &quot;.&quot;) &#123;\n                    res +&#x3D; &#39;&#x2F;&#39; + name;\n                &#125;\n                name.clear();\n            &#125;\n        &#125;\n        if (res.empty()) res &#x3D; &quot;&#x2F;&quot;;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"72-编辑距离a-gt-b-steps-DP-三类\"><a href=\"#72-编辑距离a-gt-b-steps-DP-三类\" class=\"headerlink\" title=\"72.编辑距离a-&gt;b_steps  DP 三类\"></a>72.编辑距离a-&gt;b_steps  DP 三类</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210330154734516.png\" alt=\"image-20210330154734516\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minDistance(string a, string b) &#123;\n        int n &#x3D; a.size(), m &#x3D; b.size();\n        a &#x3D; &#39; &#39; + a, b &#x3D; &#39; &#39; + b; &#x2F;&#x2F; 1...\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1));\n\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) f[i][0] &#x3D; i;\n        for(int i &#x3D; 1; i &lt;&#x3D; m; i++) f[0][i] &#x3D; i;\n        \n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            for(int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123;\n                f[i][j] &#x3D; min(f[i - 1][j], f[i][j - 1]) + 1;&#x2F;&#x2F;type 1 2\n                int t &#x3D; a[i] !&#x3D; b[j];\n                f[i][j] &#x3D; min(f[i][j], f[i - 1][j - 1] + t);&#x2F;&#x2F;type 3\n            &#125;\n        return f[n][m];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"73-矩阵置零：原地-0就刷\"><a href=\"#73-矩阵置零：原地-0就刷\" class=\"headerlink\" title=\"73.矩阵置零：原地  0就刷\"></a>73.矩阵置零：原地  0就刷</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210330220045831.png\" alt=\"image-20210330220045831\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if (matrix.empty()) return;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        int col0 &#x3D; 1, row0 &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            if (!matrix[i][0]) col0 &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; m; i ++ )\n            if (!matrix[0][i]) row0 &#x3D; 0;\n        for (int i &#x3D; 1; i &lt; n; i ++ )\n            for (int j &#x3D; 1; j &lt; m; j ++ )\n                if (!matrix[i][j])\n                &#123;\n                    matrix[i][0] &#x3D; 0;\n                    matrix[0][j] &#x3D; 0;\n                &#125;\n        for (int i &#x3D; 1; i &lt; n; i ++ )\n            if (!matrix[i][0])\n                for (int j &#x3D; 1; j &lt; m; j ++ )\n                    matrix[i][j] &#x3D; 0;\n\n        for (int i &#x3D; 1; i &lt; m; i ++ )\n            if (!matrix[0][i])\n                for (int j &#x3D; 1; j &lt; n; j ++ )\n                    matrix[j][i] &#x3D; 0;\n\n        if (!col0)\n            for (int i &#x3D; 0; i &lt; n; i ++ )\n                matrix[i][0] &#x3D; 0;\n\n        if (!row0)\n            for (int i &#x3D; 0; i &lt; m; i ++ )\n                matrix[0][i] &#x3D; 0;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"74-搜索二维矩阵-1D二分-坐标变换-mid-x2F-m-mid-m\"><a href=\"#74-搜索二维矩阵-1D二分-坐标变换-mid-x2F-m-mid-m\" class=\"headerlink\" title=\"74. 搜索二维矩阵 1D二分+坐标变换(mid&#x2F;m,mid%m)\"></a>74. 搜索二维矩阵 1D二分+坐标变换(mid&#x2F;m,mid%m)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;\n        if(matrix.empty()) return false;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        int l &#x3D; 0, r &#x3D; n * m - 1;\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if(matrix[mid &#x2F; m][mid % m] &gt;&#x3D; target) r &#x3D; mid;\n            else l &#x3D; mid + 1;\n        &#125;\n        return matrix[r &#x2F; m][r % m] &#x3D;&#x3D; target;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"75-颜色分类-荷兰国旗问题-00111222-cnt-ijk\"><a href=\"#75-颜色分类-荷兰国旗问题-00111222-cnt-ijk\" class=\"headerlink\" title=\"75.颜色分类 荷兰国旗问题 00111222 cnt ijk\"></a>75.颜色分类 荷兰国旗问题 00111222 cnt ijk</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210330225227198.png\" alt=\"image-20210330225227198\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\nArrays.sort(nums);\nsort(nums.begin(),nums.end());\ncnt012 重写\n&lt;仅使用常数空间的一趟扫描算法&gt;\n三指针做法：[i)[j)[k)\n*&#x2F;\nclass Solution &#123;\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) &#123;\n        for (int i &#x3D; 0, j &#x3D; 0, k &#x3D; nums.size() - 1; i &lt;&#x3D; k;) &#123;&#x2F;&#x2F;i&gt;k结束\n            if (nums[i] &#x3D;&#x3D; 0) swap(nums[i ++ ], nums[j ++ ]);\n            else if (nums[i] &#x3D;&#x3D; 2) swap(nums[i], nums[k -- ]);&#x2F;&#x2F;i不++ 不确定！！！\n            else i ++ ;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;leetcode&#x2F;content&#x2F;91&#x2F;\n&#x2F;&#x2F; 计数+覆盖！！！\nclass Solution &#123;\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) &#123;\n        int count[3] &#x3D; &#123;0&#125;;\n\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)\n            ++count[nums[i]];\n\n        for(int i &#x3D; 0, t &#x3D; 0;i &lt; 3; ++i)\n            for(int j &#x3D; 0; j &lt; count[i]; ++j)\n                nums[t++] &#x3D; i;\n\n    &#125;\n&#125;;\n\n</code></pre>\n\n\n\n\n\n<h1 id=\"？76-最小覆盖子串-双指针-2-hash表-同LC30\"><a href=\"#？76-最小覆盖子串-双指针-2-hash表-同LC30\" class=\"headerlink\" title=\"？76.最小覆盖子串(双指针 2*hash表 同LC30~)\"></a>？76.最小覆盖子串(双指针 2*hash表 同LC30~)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210331095844676.png\" alt=\"image-20210331095844676\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string minWindow(string s, string t) &#123;\n        unordered_map&lt;char, int&gt; hs, ht;\n        for(auto c: t) ht[c]++;\n\n        string res;\n        int cnt &#x3D; 0;\n        for(int i &#x3D; 0, j &#x3D; 0; i &lt; s.size(); i++) &#123;\n            hs[s[i]]++;\n            if(hs[s[i]] &lt;&#x3D; ht[s[i]]) cnt++;\n\n            while(hs[s[j]] &gt; ht[s[j]]) hs[s[j++]]--; &#x2F;&#x2F;\n            if(cnt &#x3D;&#x3D; t.size()) &#123;\n                if(res.empty() || i - j + 1 &lt; res.size()) &#x2F;&#x2F;最小子串\n                res &#x3D; s.substr(j, i - j + 1);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"77-组合-枚举n取k的所有方案-爆搜\"><a href=\"#77-组合-枚举n取k的所有方案-爆搜\" class=\"headerlink\" title=\"77.组合  枚举n取k的所有方案 爆搜\"></a>77.组合  枚举n取k的所有方案 爆搜</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;\n        dfs(n, k, 1); &#x2F;&#x2F; n, residual_need, 枚举i允许的start\n        return ans;\n    &#125;\n\n    void dfs(int n, int k, int start) &#123;\n        if(!k) &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        for(int i &#x3D; start; i &lt;&#x3D; n; i++) &#123;\n            path.push_back(i);\n            dfs(n, k - 1,  i + 1); &#x2F;&#x2F;只准顺序遍历\n            path.pop_back();\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"78-子集-不重复nums的幂集-n位01bin表示case-1就选\"><a href=\"#78-子集-不重复nums的幂集-n位01bin表示case-1就选\" class=\"headerlink\" title=\"78.子集  不重复nums的幂集 n位01bin表示case 1就选\"></a>78.子集  不重复nums的幂集 n位01bin表示case 1就选</h1><p>递归：枚举每个数选不选 [若不记录方案：$O(2^n)$]</p>\n<p>迭代：二进制划分 都是$O(2^n*n)$，两重loop</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int n &#x3D; nums.size();\n        for(int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i++) &#123; &#x2F;&#x2F;0~2^n-1\n            vector&lt;int&gt; path;\n            for(int j &#x3D; 0; j &lt; n; j++)\n                if(i &gt;&gt; j &amp; 1) &#x2F;&#x2F;i的第j位是1\n                    path.push_back(nums[j]); &#x2F;&#x2F;\n            res.push_back(path);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"79-单词搜索-爆搜起点-4方向-不回头’-’回溯\"><a href=\"#79-单词搜索-爆搜起点-4方向-不回头’-’回溯\" class=\"headerlink\" title=\"79.单词搜索  爆搜起点+4方向 不回头’.’回溯\"></a>79.单词搜索  爆搜起点+4方向 不回头’.’回溯</h1><p>不能走回头路，所以除了单词首字母外，仅有三种选择。所以总时间复杂度是 $O(n^2*3^k)$.</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;\n        for(int i &#x3D; 0; i &lt; board.size(); i++) \n            for(int j &#x3D; 0; j &lt; board[i].size(); j++) \n                if(dfs(board, word, 0, i, j)) return true;\n        return false;\n    &#125;\n    \n    int  dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int u, int x, int y) &#123;\n        if(board[x][y] !&#x3D; word[u]) return false;\n        if(u &#x3D;&#x3D; word.size() - 1) return true;\n\n        char t &#x3D; board[x][y];\n        board[x][y] &#x3D; &#39;.&#39;; &#x2F;&#x2F;visited\n        for(int i &#x3D; 0; i &lt; 4; i++) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if(a &lt; 0 || a &gt;&#x3D; board.size() || b &lt; 0 || b &gt;&#x3D; board[0].size() || board[a][b] &#x3D;&#x3D; &#39;.&#39;) continue; &#x2F;&#x2F;换方向\n            if(dfs(board, word, u + 1, a, b)) return true; &#x2F;&#x2F;递归\n        &#125;\n        board[x][y] &#x3D; t; &#x2F;&#x2F;回溯\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n\n<h1 id=\"80-删除排序数组中的重复项-II-LC16-x3D-x3D-最多保留2个-k-lt-2-nums-k-1-x3D-x-nums-k-2-x3D-x\"><a href=\"#80-删除排序数组中的重复项-II-LC16-x3D-x3D-最多保留2个-k-lt-2-nums-k-1-x3D-x-nums-k-2-x3D-x\" class=\"headerlink\" title=\"80. 删除排序数组中的重复项 II (LC16)  &#x3D;&#x3D;最多保留2个 (k &lt; 2 || nums[k - 1] !&#x3D; x || nums[k - 2] !&#x3D; x)\"></a>80. 删除排序数组中的重复项 II (LC16)  &#x3D;&#x3D;最多保留2个 (k &lt; 2 || nums[k - 1] !&#x3D; x || nums[k - 2] !&#x3D; x)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        int k &#x3D; 0;\n        for(auto x: nums) &#123;\n            if(k &lt; 2 || nums[k - 1] !&#x3D; x || nums[k - 2] !&#x3D; x) &#x2F;&#x2F;\n                nums[k++] &#x3D; x;\n        &#125;\n        return k;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"81-搜索旋转排序数组-II-33-有重复-二分-while-R-gt-x3D-0-amp-amp-nums-R-x3D-x3D-nums-0-R–-x2F-x2F-保持两段性\"><a href=\"#81-搜索旋转排序数组-II-33-有重复-二分-while-R-gt-x3D-0-amp-amp-nums-R-x3D-x3D-nums-0-R–-x2F-x2F-保持两段性\" class=\"headerlink\" title=\"81.搜索旋转排序数组 II(33)有重复    二分  while(R &gt;&#x3D; 0 &amp;&amp; nums[R] &#x3D;&#x3D; nums[0]) R–; &#x2F;&#x2F;保持两段性\"></a>81.搜索旋转排序数组 II(33)有重复    二分  while(R &gt;&#x3D; 0 &amp;&amp; nums[R] &#x3D;&#x3D; nums[0]) R–; &#x2F;&#x2F;保持两段性</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210408152057728.png\" alt=\"image-20210408152057728\"></p>\n<p>while(R &gt;&#x3D; 0 &amp;&amp; nums[R] &#x3D;&#x3D; nums[0]) R–;  &#x2F;&#x2F;保持两段性</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;最坏O(n)\nclass Solution &#123;\npublic:\n    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tif(nums.empty()) return false;\n        int R &#x3D; nums.size() - 1;\n        while(R &gt;&#x3D; 0 &amp;&amp; nums[R] &#x3D;&#x3D; nums[0]) R--; &#x2F;&#x2F;保持两段性\n        if(R &lt; 0) return nums[0] &#x3D;&#x3D; target;\n\n\t\t&#x2F;&#x2F;二分两段\n\t\tint l &#x3D; 0, r &#x3D; R;\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; nums[0]) l &#x3D; mid;\n\t\t\telse r &#x3D; mid - 1;\n\t\t&#125;\n\t\t&#x2F;&#x2F;l&#x3D;r&#x3D;mid &gt;&#x3D;n[0]:target定在哪一段\n\t\tif(target &gt;&#x3D; nums[0]) l &#x3D; 0;\n\t\telse l &#x3D; r + 1, r &#x3D; R;\n\t\t\n\t\t&#x2F;&#x2F; 二分 &gt;&#x3D;target的min\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; target) r &#x3D; mid; &#x2F;&#x2F;的min\n\t\t\telse l &#x3D; mid + 1;\n\t\t&#125;\n\n\t\treturn nums[r] &#x3D;&#x3D; target;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;最坏O(n)，线性扫描\nclass Solution &#123;\npublic:\n    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        for (auto &amp;v : nums)\n            if (v &#x3D;&#x3D; target)\n                return true;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"82-删除排序链表中的重复元素-II-83升序-删完-双指针\"><a href=\"#82-删除排序链表中的重复元素-II-83升序-删完-双指针\" class=\"headerlink\" title=\"82.删除排序链表中的重复元素 II 83升序 删完 双指针\"></a>82.删除排序链表中的重复元素 II 83升序 删完 双指针</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210408153902770.png\" alt=\"image-20210408153902770\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n        auto p &#x3D; dummy;&#x2F;&#x2F;prev\n        while (p-&gt;next)&#x2F;&#x2F;first\n        &#123;\n            auto q &#x3D; p-&gt;next-&gt;next;\n            while (q &amp;&amp; q-&gt;val &#x3D;&#x3D; p-&gt;next-&gt;val) q &#x3D; q-&gt;next;\n            if (p-&gt;next-&gt;next &#x3D;&#x3D; q) p &#x3D; p-&gt;next;&#x2F;&#x2F;1\n            else p-&gt;next &#x3D; q;&#x2F;&#x2F;2\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"83-删除排序链表中的重复元素-82升序-留一个\"><a href=\"#83-删除排序链表中的重复元素-82升序-留一个\" class=\"headerlink\" title=\"83.删除排序链表中的重复元素 82升序 留一个\"></a>83.删除排序链表中的重复元素 82升序 留一个</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if (!head) return head;\n        auto p &#x3D; head;\n        while (p-&gt;next)\n        &#123;\n            if (p-&gt;val &#x3D;&#x3D; p-&gt;next-&gt;val) p-&gt;next &#x3D; p-&gt;next-&gt;next;\n            else p &#x3D; p-&gt;next;\n        &#125;\n        return head;\n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if (!head) return head;\n        auto cur &#x3D; head;\n        for(auto p &#x3D; head-&gt;next; p; p &#x3D; p-&gt;next)\n            if ( p-&gt;val !&#x3D; cur-&gt;val) cur &#x3D; cur-&gt;next &#x3D; p;\n        \n        cur-&gt;next &#x3D; NULL;\n        return head;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"84-柱状图中最大的矩形-单调栈-heights-cur-i-st-top-1\"><a href=\"#84-柱状图中最大的矩形-单调栈-heights-cur-i-st-top-1\" class=\"headerlink\" title=\"84.柱状图中最大的矩形 单调栈 heights[cur] * (i - st.top() - 1)\"></a>84.柱状图中最大的矩形 单调栈 heights[cur] * (i - st.top() - 1)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210409084926958.png\" alt=\"image-20210409084926958\"></p>\n<p>while(比他高)pop</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;84. 柱状图中最大的矩形\n&#x2F;&#x2F;单调栈：\n&#x2F;&#x2F;枚举上边界h：(L,R)第一个比它低的位置R-L-1就是宽度\nclass Solution &#123;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; h) &#123;\n        int n &#x3D; h.size();\n        vector&lt;int&gt; left(n), right(n);\n        stack&lt;int&gt; stk;\n\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            while(stk.size() &amp;&amp; h[stk.top()] &gt;&#x3D; h[i]) stk.pop();\n            if(stk.empty()) left[i] &#x3D; -1;\n            else left[i] &#x3D; stk.top();\n            stk.push(i);\n        &#125;\n    \n        stk &#x3D; stack&lt;int&gt;();\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;\n            while(stk.size() &amp;&amp; h[stk.top()] &gt;&#x3D; h[i]) stk.pop();\n            if(stk.empty()) right[i] &#x3D; n;\n            else right[i] &#x3D; stk.top();\n            stk.push(i);\n        &#125;\n\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, h[i] * (right[i] - left[i] - 1));\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;*\n(单调栈) O(n) 同李煜东~\n1.此题的本质是找到每个柱形条左边和右边最近的比自己低的矩形条，然后用宽度乘上当前柱形条的高度作为备选答案。\n2.解决此类问题的经典做法是单调栈，维护一个单调递增的栈，如果当前柱形条 i 的高度比栈顶要低，则栈顶元素 cur 出栈。\n【cur出栈后，cur 右边第一个比它低的柱形条就是 i，左边第一个比它低的柱形条是当前栈中的 top。】不断出栈直到栈为空或者柱形条 i 不再比 top 低。\n3.满足 2 之后，当前矩形条 i 进栈。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;\n        int n &#x3D; heights.size(), ans &#x3D; 0;\n        heights.push_back(-1);\n        &#x2F;&#x2F; 为了算法书写方便，在数组末尾添加高度 -1\n        &#x2F;&#x2F; 这会使得栈中所有数字在最后出栈。\n\n        stack&lt;int&gt; st;\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;\n                int cur &#x3D; st.top();\n                st.pop();\n\n                if (st.empty())\n                    ans &#x3D; max(ans, heights[cur] * i);&#x2F;&#x2F;0 ~ i-1\n                else\n                    ans &#x3D; max(ans, heights[cur] \n                            * (i - st.top() - 1)); &#x2F;&#x2F;!!!\n            &#125;\n            st.push(i);\n        &#125;\n\n        return ans;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;140&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n\n\n<h1 id=\"85-全1的-最大矩形-的面积-84-gt-2D-DP\"><a href=\"#85-全1的-最大矩形-的面积-84-gt-2D-DP\" class=\"headerlink\" title=\"85.(全1的)最大矩形(的面积) 84-&gt;2D+DP\"></a>85.(全1的)最大矩形(的面积) 84-&gt;2D+DP</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210409104255325.png\" alt=\"image-20210409104255325\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;85.(全1的 2D)最大矩形(的面积)\n&#x2F;&#x2F;拓展 最大正方形：DP\n&#x2F;&#x2F;左上(右下(全1：增量or前缀和 O1))&#x3D;n^4\n\n&#x2F;&#x2F;套上题单调栈O(n)、枚举下边界+排与排DP\n&#x2F;&#x2F;h:此处向上有多少个1\nclass Solution &#123;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; h) &#123;\n        int n &#x3D; h.size(), ans &#x3D; 0;\n        h.push_back(-1);\n        &#x2F;&#x2F; 为了算法书写方便，在数组末尾添加高度 -1\n        &#x2F;&#x2F; 这会使得栈中所有数字在最后出栈。\n\n        stack&lt;int&gt; st;\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            while (!st.empty() &amp;&amp; h[i] &lt; h[st.top()]) &#123;\n                int cur &#x3D; st.top();\n                st.pop();\n\n                if (st.empty())\n                    ans &#x3D; max(ans, h[cur] * i);&#x2F;&#x2F;0 ~ i-1\n                else\n                    ans &#x3D; max(ans, h[cur] * (i - st.top() - 1)); &#x2F;&#x2F;!!!\n            &#125;\n            st.push(i);\n        &#125;\n\n        return ans;\n    &#125;\n\n    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        if(matrix.empty() || matrix[0].empty()) return 0;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n\n        vector&lt;vector&lt;int&gt;&gt; h(n, vector&lt;int&gt;(m));\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; m; j++)\n                if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;\n                    if(i) h[i][j] &#x3D; 1 + h[i - 1][j]; &#x2F;&#x2F;DP\n                    else h[i][j] &#x3D; 1;\n                &#125;\n        \n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, largestRectangleArea(h[i]));&#x2F;&#x2F;2D最大矩形面积\n\n        return res; \n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"86-L-lt-x、R-gt-x3D-x-分隔链表-qsort部分-稳定排lhlt\"><a href=\"#86-L-lt-x、R-gt-x3D-x-分隔链表-qsort部分-稳定排lhlt\" class=\"headerlink\" title=\"86. (L&lt;x、R&gt;&#x3D;x)分隔链表  qsort部分 稳定排lhlt\"></a>86. (L&lt;x、R&gt;&#x3D;x)分隔链表  qsort部分 稳定排lhlt</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210412104205417.png\" alt=\"image-20210412104205417\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* partition(ListNode* head, int x) &#123;\n        auto lh &#x3D;new ListNode(-1), rh &#x3D;new ListNode(-1);\n        auto lt &#x3D; lh, rt &#x3D; rh;\n\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next) &#123;\n            if(p-&gt;val &lt; x) lt &#x3D; lt-&gt;next &#x3D; p;\n            else rt &#x3D; rt-&gt;next &#x3D; p;\n        &#125;\n        lt-&gt;next &#x3D; rh-&gt;next;\n        rt-&gt;next &#x3D; NULL;\n\n        return lh-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"—87-扰乱字符串-区间dp\"><a href=\"#—87-扰乱字符串-区间dp\" class=\"headerlink\" title=\"—87.扰乱字符串  区间dp!!!\"></a>—87.扰乱字符串  区间dp!!!</h1><ul>\n<li><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">5. 最长回文子串</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/longest-palindromic-subsequence/\">516. 最长回文子序列</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/burst-balloons/\">312. 戳气球</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/palindrome-removal/\">1246. 删除回文子数组</a>（这个题微软面试问的很多）</li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210412113610571.png\" alt=\"image-20210412113610571\"></p>\n<p>递归 O($5^n$)-&gt;记忆化搜索-&gt;dp O($n^4$)</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;递归 TLE...\nclass Solution &#123;\npublic:\n    bool isScramble(string s1, string s2) &#123;\n        if (s1 &#x3D;&#x3D; s2) return true;\n        string bs1 &#x3D; s1, bs2 &#x3D; s2;\n        sort(bs1.begin(), bs1.end()), sort(bs2.begin(), bs2.end());\n        if (bs1 !&#x3D; bs2) return false;\n        int n &#x3D; s1.size();\n        for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i ++ ) &#123; &#x2F;&#x2F;str.substr(L,len)\n            if (isScramble(s1.substr(0, i), s2.substr(0, i))\n                &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true;\n            if (isScramble(s1.substr(0, i), s2.substr(n - i))\n                &amp;&amp; isScramble(s1.substr(i), s2.substr(0, n - i))) return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\nhttps:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;scramble-string&#x2F;solution&#x2F;miao-dong-de-qu-jian-xing-dpsi-lu-by-sha-yu-la-jia&#x2F;      Java\n\n&#x2F;&#x2F;C++\n#define vt std::vector\nclass Solution &#123;\npublic:\n    bool isScramble(string s, string t) &#123;\n        if (s.length() !&#x3D; t.length()) return false;\n\n        int n &#x3D; s.length();\n        vt&lt;vt&lt;vt&lt;int&gt;&gt;&gt; dp(n, vt&lt;vt&lt;int&gt;&gt;(n, vt&lt;int&gt;(n + 1, 0)));\n\n        for (int i &#x3D; 0; i &lt; n; ++ i)\n            for (int j &#x3D; 0; j &lt; n; ++ j)\n                dp[i][j][1] &#x3D; s[i] &#x3D;&#x3D; t[j];\n\n        for (int k &#x3D; 2; k &lt;&#x3D; n; ++ k)&#123;\n            for (int i &#x3D; 0; i + k &lt;&#x3D; n; ++ i)&#123;\n                for (int j &#x3D; 0; j + k &lt;&#x3D; n; ++ j)&#123;\n                    for (int ck &#x3D; 1; ck &lt; k; ++ ck)&#123;\n                        dp[i][j][k] |&#x3D; (\n                            (dp[i][j][ck] &amp;&amp; dp[i + ck][j + ck][k - ck]) ||\n                            (dp[i][j + k - ck][ck] &amp;&amp; dp[i + ck][j][k - ck])\n                        );\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n\n        return dp[0][0][n];\n    &#125;\n&#125;;\n\n作者：wen-mu-yang\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;scramble-string&#x2F;solution&#x2F;c-killhard-108-qu-jian-dphao-ti-by-wen-m-1mga&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n    \nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;15686&#x2F;   3法\n</code></pre>\n\n\n\n<h1 id=\"88-合并两个有序数组-mergesort-1-2–-gt-1-反遍历不覆盖-k-x3D-n-m-1\"><a href=\"#88-合并两个有序数组-mergesort-1-2–-gt-1-反遍历不覆盖-k-x3D-n-m-1\" class=\"headerlink\" title=\"88.合并两个有序数组  mergesort  1+2–&gt;1 反遍历不覆盖 k&#x3D;n+m-1\"></a>88.合并两个有序数组  mergesort  1+2–&gt;1 反遍历不覆盖 k&#x3D;n+m-1</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;\n        int k &#x3D; n + m - 1;\n        int i &#x3D; m - 1, j &#x3D; n - 1;\n        while(i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0)\n            if(nums1[i] &gt;&#x3D; nums2[j]) nums1[k--] &#x3D; nums1[i--];\n            else nums1[k--] &#x3D; nums2[j--];\n        while(j &gt;&#x3D; 0) nums1[k--] &#x3D; nums2[j--];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"89-格雷编码-轴对称-后补0-x2F-1-前补-i-i-gt-gt-1\"><a href=\"#89-格雷编码-轴对称-后补0-x2F-1-前补-i-i-gt-gt-1\" class=\"headerlink\" title=\"89.格雷编码 轴对称 后补0&#x2F;1     前补:i^i&gt;&gt;1\"></a>89.格雷编码 轴对称 后补0&#x2F;1     前补:i^i&gt;&gt;1</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210412151202153.png\" alt=\"image-20210412151202153\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; grayCode(int n) &#123;\n        vector&lt;int&gt; res(1, 0);\n        while(n--) &#123;\n            for(int i &#x3D; res.size() - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F;后补01\n                res[i] *&#x3D; 2;\n                res.push_back(res[i] + 1);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;*\n格雷编码如何形成。同样以n &#x3D; 2解析。\n公式为 i ^ i&#x2F;2 (i &gt;&gt; 1)\n0 ^ 0 &#x3D; 00 ^ 00 &#x3D; 00 &#x3D; 0 计算(i&#x2F;2): 0&#x2F;2 &#x3D; 0\n1 ^ 0 &#x3D; 01 ^ 00 &#x3D; 01 &#x3D; 1 计算(i&#x2F;2): 1&#x2F;2 &#x3D; 0\n2 ^ 1 &#x3D; 10 ^ 01 &#x3D; 11 &#x3D; 3 计算(i&#x2F;2): 2&#x2F;2 &#x3D; 1\n3 ^ 1 &#x3D; 11 ^ 01 &#x3D; 10 &#x3D; 2 计算(i&#x2F;2): 3&#x2F;2 &#x3D; 1\n*&#x2F;\n&#x2F;&#x2F;前补01\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; grayCode(int n) &#123;\n        vector&lt;int&gt; ans;\n        int powN &#x3D; 1 &lt;&lt; n;\n        for(int i &#x3D; 0; i &lt; powN; ++i) &#x2F;&#x2F;\n            ans.push_back(i^i&gt;&gt;1); &#x2F;&#x2F;\n        return ans;\n    &#125;\n&#125;;\n\n作者：Xiaohu9527\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;gray-code&#x2F;solution&#x2F;c5xing-dai-ma-xiang-xi-jie-xi-dui-xin-sh-xrkw&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"—90-lt-78-子集II-重复-多重背包-hash表-x2F-用-sort-dfs爆搜-放入0-k-u个nums-u\"><a href=\"#—90-lt-78-子集II-重复-多重背包-hash表-x2F-用-sort-dfs爆搜-放入0-k-u个nums-u\" class=\"headerlink\" title=\"—90&lt;-78.子集II 重复 多重背包  hash表&#x2F;(用)sort+dfs爆搜+放入0~k-u个nums[u]\"></a>—90&lt;-78.子集II 重复 多重背包  hash表&#x2F;(用)sort+dfs爆搜+放入0~k-u个nums[u]</h1><p>不能bin枚举，只能递归枚举</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">public:\n\tvector&lt;vector&lt;int&gt;&gt; ans;\n\tvector&lt;int&gt; path;\n\n\tvector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;\n\t\tsort(nums.begin(), nums.end());\n\t\tdfs(0, nums);\n\t\treturn ans;\n\t&#125;\n&#x2F;&#x2F;先枚举每个不同的数，枚举到数x时，我们再求出x的个数k，然后我们枚举在集合中放入0,1,2,…k个x，共k+1种情况。\n\tvoid dfs(int u, vector&lt;int&gt;&amp;nums)\n\t&#123;\n\t\tif (u &#x3D;&#x3D; nums.size())\n\t\t&#123;\n\t\t\tans.push_back(path);\n\t\t\treturn;\n\t\t&#125;\n\t\tint k &#x3D; u;\n\t\twhile (k &lt; nums.size() &amp;&amp; nums[k] &#x3D;&#x3D; nums[u]) k ++ ;\n\t\t&#x2F;*\n\t\tfor (int i &#x3D; 0; i &lt;&#x3D; k - u; i ++ )\n\t\t&#123;\n\t\t\tdfs(k, nums);&#x2F;&#x2F;放0~k-u次\n\t\t\tpath.push_back(nums[u]);\n\t\t&#125;\n\t\t*&#x2F;\n\t\tdfs(k, nums);&#x2F;&#x2F;不放u\n\t\tfor (int i &#x3D; u; i &lt; k; i ++ )&#x2F;&#x2F;放u\n\t\t&#123;\n\t\t\tpath.push_back(nums[i]);\n\t\t\tdfs(k, nums);\n\t\t&#125;\n\t\tpath.erase(path.end() - (k - u), path.end());&#x2F;&#x2F;回溯\n\t&#125;\n&#125;;\n\n\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;16593&#x2F;\n&#x2F;&#x2F;Java\n&#x2F;*先对数组从小到大排序，每个数有选和不选两种情况，若选的话，\n假设上一个数与当前数一致，且上一个数没有选，则当前数一定不能选，否则会产生重复情况。\n时间复杂度 O(2^n) ?????\n*&#x2F;\nclass Solution &#123;\n    static List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    static List&lt;Integer&gt; path &#x3D; new ArrayList&lt;Integer&gt;();\n    static boolean[] st;\n    static void dfs(int[] nums,int u)\n    &#123;\n        if(u &#x3D;&#x3D; nums.length)\n        &#123;\n            ans.add(new ArrayList&lt;Integer&gt;(path));\n            return ;\n        &#125;\n\n        &#x2F;&#x2F;不放\n        dfs(nums,u + 1);\n\n        &#x2F;&#x2F;放\n        if(u &gt; 0 &amp;&amp; nums[u] &#x3D;&#x3D; nums[u - 1] &amp;&amp; !st[u - 1]) return ;\n        st[u] &#x3D; true;\n        path.add(nums[u]);\n        dfs(nums,u + 1);\n        path.remove(path.size() - 1);\n        st[u] &#x3D; false;\n    &#125;\n    \n    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;\n        ans.clear();\n        Arrays.sort(nums);\n        st &#x3D; new boolean[nums.length + 10];\n        dfs(nums,0);\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n\n\n<h1 id=\"91-解码方法-DP\"><a href=\"#91-解码方法-DP\" class=\"headerlink\" title=\"91.解码方法 DP\"></a>91.解码方法 DP</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;12&quot;\n输出：2\n解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210412165019616.png\" alt=\"image-20210412165019616\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int numDecodings(string s) &#123;\n        int n &#x3D; s.size();\n        s &#x3D; &#39; &#39; + s;\n        vector&lt;int&gt; f(n + 1);\n        f[0] &#x3D; 1;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            if(s[i] &gt;&#x3D; &#39;1&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;) f[i] +&#x3D; f[i - 1];\n            if(i &gt; 1) &#123;\n                int t &#x3D; (s[i - 1] - &#39;0&#39;) * 10 + s[i] - &#39;0&#39;;\n                if(t &gt;&#x3D; 10 &amp;&amp; t &lt;&#x3D; 26) f[i] +&#x3D; f[i - 2];\n            &#125;\n        &#125;\n        return f[n];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"92-反转链表II（LR-x3D-1-n-区间）a-b-lt-c-lt-d【206-反转链表】\"><a href=\"#92-反转链表II（LR-x3D-1-n-区间）a-b-lt-c-lt-d【206-反转链表】\" class=\"headerlink\" title=\"92.反转链表II（LR&#x3D;1~n 区间）a b&lt;-c&lt;-d【206.反转链表】\"></a>92.反转链表II（LR&#x3D;1~n 区间）a b&lt;-c&lt;-d【206.反转链表】</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210319151101276.png\" alt=\"image-20210319151101276\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) &#123;\n        if(!head || !head-&gt;next) return head;\n\n        auto dummy &#x3D; new ListNode(-1); &#x2F;&#x2F;虚拟头结点，减少特判\n        dummy-&gt;next &#x3D; head;\n        auto a &#x3D; dummy;\n        for(int i &#x3D; 0; i &lt; left - 1; i++) a &#x3D; a-&gt;next; &#x2F;&#x2F;left-1步\n        auto b &#x3D; a-&gt;next, c &#x3D; b-&gt;next;\n        for(int i &#x3D; 0; i &lt; right - left; i++) &#123;\n            auto d &#x3D; c-&gt;next;\n            c-&gt;next &#x3D; b;\n            b &#x3D; c, c &#x3D; d;\n        &#125;\n        a-&gt;next-&gt;next &#x3D; c;\n        a-&gt;next &#x3D; b;\n        auto res &#x3D; dummy-&gt;next; &#x2F;&#x2F; 工程性：防止内存泄露\n        delete dummy;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"93-复原IP地址-dfs-0255-无前导0-‘-’-u-bit-k-03-过长\"><a href=\"#93-复原IP地址-dfs-0255-无前导0-‘-’-u-bit-k-03-过长\" class=\"headerlink\" title=\"93.复原IP地址 dfs 0255 无前导0  ‘.’ u:bit k:03  过长\"></a>93.复原IP地址 dfs 0<del>255 无前导0  ‘.’ u:bit k:0</del>3  过长</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;93.复原IP地址 dfs\n&#x2F;*\n输入：s &#x3D; &quot;25525511135&quot;\n输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n0~255 无前导0\n\n(暴力搜索) O(C(3,n−1))\n直接暴力搜索出所有合法方案。\n我们直接枚举四个整数的位数，然后判断每个数的范围是否在0到255。\n\n时间复杂度分析：一共 n 个数字，n−1 个数字间隔，相当于从 n−1 个数字间隔中挑3个断点，所以计算量是 O(C(3,n−1))。\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;string&gt; restoreIpAddresses(string s) &#123;\n        dfs(s, 0 , 0, &quot;&quot;);\n        return ans;\n    &#125;\n\n    void dfs(string&amp; s, int u, int k, string path) &#123; &#x2F;&#x2F;u:bit k:0~3\n        if(u &#x3D;&#x3D; s.size()) &#123;\n            if(k &#x3D;&#x3D; 4) &#123;\n                path.pop_back(); &#x2F;&#x2F; 去&#39;.&#39;\n                ans.push_back(path);\n            &#125;\n            return;\n        &#125;\n        if(k &#x3D;&#x3D; 4) return;&#x2F;&#x2F;过长\n        for(int i &#x3D; u, t &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(i &gt; u &amp;&amp; s[u]&#x3D;&#x3D;&#39;0&#39;) break; &#x2F;&#x2F;有前导0\n            t &#x3D; t * 10 + s[i] - &#39;0&#39;;\n            if(t &lt;&#x3D; 255) dfs(s, i + 1, k + 1, path + to_string(t) + &#39;.&#39;);\n            else break;\n        &#125;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;写法2\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;int&gt; path; &#x2F;&#x2F;\n\n    vector&lt;string&gt; restoreIpAddresses(string s) &#123;\n        dfs(0, 0, s);\n        return ans;\n    &#125;\n\n    &#x2F;&#x2F; u表示枚举到的字符串下标，k表示当前截断的IP个数，s表示原字符串\n    void dfs(int u, int k, string &amp;s)\n    &#123;\n        if (u &#x3D;&#x3D; s.size())\n        &#123;\n            if (k &#x3D;&#x3D; 4)\n            &#123;\n                string ip &#x3D; to_string(path[0]);\n                for (int i &#x3D; 1; i &lt; 4; i ++ )\n                    ip +&#x3D; &#39;.&#39; + to_string(path[i]); &#x2F;&#x2F;\n                ans.push_back(ip);\n            &#125;\n            return;\n        &#125;\n        if (k &gt; 4) return;\n\n        unsigned t &#x3D; 0;\n        for (int i &#x3D; u; i &lt; s.size(); i ++ )\n        &#123;\n            t &#x3D; t * 10 + s[i] - &#39;0&#39;;\n            if (t &gt;&#x3D; 0 &amp;&amp; t &lt; 256)\n            &#123;\n                path.push_back(t);\n                dfs(i + 1, k + 1, s);\n                path.pop_back();\n            &#125;\n            if (!t) break; &#x2F;&#x2F;有前导0!!!\n        &#125;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;175&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n\n\n<h1 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94.二叉树的中序遍历\"></a>94.二叉树的中序遍历</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;递归版\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; res;\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        dfs(root);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* root) &#123;\n        if (!root) return;\n        dfs(root-&gt;left);\n        res.push_back(root-&gt;val);\n        dfs(root-&gt;right);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;针对二叉树类型的非递归版\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;TreeNode*&gt; st;\n\n        auto p &#x3D; root;\n\n        while (p || !st.empty()) &#123;\n            while (p) &#123;\n                st.push(p);\n                p &#x3D; p-&gt;left;\n            &#125;\n            p &#x3D; st.top();\n            st.pop();\n            res.push_back(p-&gt;val);\n            p &#x3D; p-&gt;right;\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;*make_pair 标记法\n栈中每个元素存储两个值：TreeNode节点和一个整型的标记。\n标记 &#x3D; 0，表示还没遍历该节点的左子树；\n标记 &#x3D; 1，表示已经遍历完左子树，但还没遍历右子树；\n标记 &#x3D; 2，表示已经遍历完右子树；\n\n然后我们可以根据标记的值，来分别处理各种情况：\n标记 &#x3D; 0，则将该节点的标记改成1，然后将其左儿子压入栈中；\n标记 &#x3D; 1，则说明左子树已经遍历完，将根节点的值插入答案序列中，然后将该节点的标记改成2，并将右儿子压入栈中；\n标记 &#x3D; 2，则说明以该节点为根的子树已经遍历完，直接从栈中弹出即可；\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;pair&lt;TreeNode*, int&gt;&gt;sta;\n        sta.push(make_pair(root, 0));\n        while (!sta.empty())\n        &#123;\n            if (sta.top().first &#x3D;&#x3D; NULL)\n            &#123;\n                sta.pop();\n                continue;\n            &#125;\n            int t &#x3D; sta.top().second;\n            if (t &#x3D;&#x3D; 0)\n            &#123;\n                sta.top().second &#x3D; 1;\n                sta.push(make_pair(sta.top().first-&gt;left, 0));\n            &#125;\n            else if (t &#x3D;&#x3D; 1)\n            &#123;\n                res.push_back(sta.top().first-&gt;val);\n                sta.top().second &#x3D; 2;\n                sta.push(make_pair(sta.top().first-&gt;right, 0));\n            &#125;\n            else sta.pop();\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;176&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n<p>Morris遍历：S&#x3D;O(1)  </p>\n<h1 id=\"95-不同的二叉搜索树-II-dfs-new-root\"><a href=\"#95-不同的二叉搜索树-II-dfs-new-root\" class=\"headerlink\" title=\"95.不同的二叉搜索树 II dfs    new root\"></a>95.不同的二叉搜索树 II dfs    new root</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;\n        if (!n) return vector&lt;TreeNode*&gt;(); &#x2F;&#x2F;&#123;&#125;\n        return dfs(1, n);\n    &#125;\n\n    vector&lt;TreeNode*&gt; dfs(int l, int r) &#123;\n        vector&lt;TreeNode*&gt; res;\n        if (l &gt; r) return &#123;NULL&#125;;\n        \n        for (int i &#x3D; l; i &lt;&#x3D; r; i ++ ) &#123;\n            auto left &#x3D; dfs(l, i - 1), right &#x3D; dfs(i + 1, r);\n            for (auto lc : left)\n                for (auto rc : right) &#123;\n                    auto root &#x3D; new TreeNode(i); &#x2F;&#x2F;每次需要重新new root\n                    root-&gt;left &#x3D; lc, root-&gt;right &#x3D; rc;\n                    res.push_back(root);\n                &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n&#x2F;&#x2F;同样结构的子树123共用的同一段内存\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;177&#x2F;</code></pre>\n\n\n\n<h1 id=\"96-不同的二叉搜索树-求case数-DP-1-j-i\"><a href=\"#96-不同的二叉搜索树-求case数-DP-1-j-i\" class=\"headerlink\" title=\"96.不同的二叉搜索树  求case数 DP [1,(j),i]\"></a>96.不同的二叉搜索树  求case数 DP [1,(j),i]</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;f[n]&#x3D;∑k&#x3D;0~n−1 f[k]∗f[n−1−k]  DP：O(n*n)\n&#x2F;&#x2F;公式Catalan数&#x3D;C(n,2n)&#x2F;(n+1)\nclass Solution &#123;\npublic:\n    int numTrees(int n) &#123;\n        vector&lt;int&gt; f(n + 1);\n        f[0] &#x3D; 1;&#x2F;&#x2F;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F;[1,i]\n        &#123;\n            f[i] &#x3D; 0; &#x2F;&#x2F;\n            for (int j &#x3D; 1; j &lt;&#x3D; i; j ++ ) &#x2F;&#x2F;[1,(j),i]\n                f[i] +&#x3D; f[j - 1] * f[i - j];&#x2F;&#x2F;DP 小-&gt;大 向上递推！\n        &#125;\n        return f[n];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"97-交错字符串-DP\"><a href=\"#97-交错字符串-DP\" class=\"headerlink\" title=\"97. 交错字符串 DP ||\"></a>97. 交错字符串 DP ||</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isInterleave(string s1, string s2, string s3) &#123;\n        int n &#x3D; s1.size(), m &#x3D; s2.size();\n        if(s3.size() !&#x3D; n + m) return false;\n\n        vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1));\n        s1 &#x3D; &#39; &#39; + s1, s2 &#x3D; &#39; &#39; + s2, s3 &#x3D; &#39; &#39; + s3; &#x2F;&#x2F;空串\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++)\n            for(int j &#x3D; 0; j &lt;&#x3D; m; j++)\n                if(!i &amp;&amp; !j) f[i][j] &#x3D; true;&#x2F;&#x2F;\n                else &#123;\n                    if(i &amp;&amp; s1[i] &#x3D;&#x3D; s3[i + j]) f[i][j] &#x3D; f[i - 1][j];\n                    if(j &amp;&amp; s2[j] &#x3D;&#x3D; s3[i + j]) f[i][j] &#x3D; f[i][j] || f[i][j - 1]; &#x2F;&#x2F;!!!\n                &#125;\n        return f[n][m];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"98-验证二叉搜索树-0F-x2F-1T-m-M-x3D-x3D-LNR是否有序\"><a href=\"#98-验证二叉搜索树-0F-x2F-1T-m-M-x3D-x3D-LNR是否有序\" class=\"headerlink\" title=\"98. 验证二叉搜索树{0F&#x2F;1T,m,M} &#x3D;&#x3D; LNR是否有序\"></a>98. 验证二叉搜索树{0F&#x2F;1T,m,M} &#x3D;&#x3D; LNR是否有序</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;98. 验证二叉搜索树(min max) &#x3D;&#x3D; LNR是否有序\n&#x2F;*\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n*&#x2F;\n\n&#x2F;&#x2F;简洁版\nclass Solution &#123;\npublic:\n    bool isValidBST(TreeNode* root) &#123;\n        if (!root) return true;\n        return dfs(root)[0];\n    &#125;\n\n    vector&lt;int&gt; dfs(TreeNode* root) &#123;\n        vector&lt;int&gt; res(&#123;1, root-&gt;val, root-&gt;val&#125;);&#x2F;&#x2F;&#123;0F&#x2F;1T,m,M&#125;\n        if (root-&gt;left) &#123;\n            auto t &#x3D; dfs(root-&gt;left);\n            if (!t[0] || t[2] &gt;&#x3D; root-&gt;val) res[0] &#x3D; 0; &#x2F;&#x2F;0F\n            res[1] &#x3D; min(res[1], t[1]);\n            res[2] &#x3D; max(res[2], t[2]);\n        &#125;\n        if (root-&gt;right) &#123;\n            auto t &#x3D; dfs(root-&gt;right);\n            if (!t[0] || t[1] &lt;&#x3D; root-&gt;val) res[0] &#x3D; 0; &#x2F;&#x2F;0F\n            res[1] &#x3D; min(res[1], t[1]);\n            res[2] &#x3D; max(res[2], t[2]);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;原版\nclass Solution &#123;\npublic:\n    bool isValidBST(TreeNode* root) &#123;\n        if (!root) return true;\n        int maxv, minv;\n        return dfs(root, maxv, minv);\n    &#125;\n\n    bool dfs(TreeNode* root, int &amp;maxv, int &amp;minv)\n    &#123;\n        maxv &#x3D; minv &#x3D; root-&gt;val;\n        if (root-&gt;left)\n        &#123;\n            int nowMaxv, nowMinv;\n            if (!dfs(root-&gt;left, nowMaxv, nowMinv))\n                return false;\n            if (nowMaxv &gt;&#x3D; root-&gt;val)\n                return false;\n            maxv &#x3D; max(maxv, nowMaxv);\n            minv &#x3D; min(minv, nowMinv);\n        &#125;\n        if (root-&gt;right)\n        &#123;\n            int nowMaxv, nowMinv;\n            if (!dfs(root-&gt;right, nowMaxv, nowMinv))\n                return false;\n            if (nowMinv &lt;&#x3D; root-&gt;val)\n                return false;\n            maxv &#x3D; max(maxv, nowMaxv);\n            minv &#x3D; min(minv, nowMinv);\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;180&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n\n\n<h1 id=\"99-恢复二叉搜索树-S-x3D-O-1-：Morris遍历【线索二叉树】-遍历时记录这两个数！swap！\"><a href=\"#99-恢复二叉搜索树-S-x3D-O-1-：Morris遍历【线索二叉树】-遍历时记录这两个数！swap！\" class=\"headerlink\" title=\"99. 恢复二叉搜索树 S&#x3D;O(1)：Morris遍历【线索二叉树】 遍历时记录这两个数！swap！\"></a>99. 恢复二叉搜索树 S&#x3D;O(1)：Morris遍历【线索二叉树】 遍历时记录这两个数！swap！</h1><p>两个节点被错误地交换：遍历时记录这两个数！swap！</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210412215838006.png\" alt=\"image-20210412215838006\"></p>\n<p>要求S&#x3D;O(1)：Morris遍历【线索二叉树】 &lt;–stk非递归</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210412220721238.png\" alt=\"image-20210412220721238\"></p>\n<p><a href=\"https://www.acwing.com/solution/content/181/\">https://www.acwing.com/solution/content/181/</a></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;99. 恢复二叉搜索树\nclass Solution &#123;\npublic:\n\tvoid recoverTree(TreeNode* root) &#123;\n\t\tTreeNode *first &#x3D; NULL, *second, *prep &#x3D; NULL;\n\t\twhile (root) &#123;\n\t\t\tif (!root-&gt;left) &#123; &#x2F;&#x2F;无左子树\n\t\t\t\tif (prep &amp;&amp; prep-&gt;val &gt; root-&gt;val) &#123; &#x2F;&#x2F;遍历cur 记录\n\t\t\t\t\tif (!first) first &#x3D; prep, second &#x3D; root; &#x2F;&#x2F;第一个逆序对\n\t\t\t\t\telse second &#x3D; root;\n\t\t\t\t&#125;\n\t\t\t\tprep &#x3D; root;\n\t\t\t\troot &#x3D; root-&gt;right;\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tauto p &#x3D; root-&gt;left;\n\t\t\t\twhile (p-&gt;right &amp;&amp; p-&gt;right !&#x3D; root) p &#x3D; p-&gt;right; &#x2F;&#x2F;&amp;&amp;...!!!\n\t\t\t\tif (!p-&gt;right) &#123;\n\t\t\t\t\tp-&gt;right &#x3D; root; &#x2F;&#x2F;\n\t\t\t\t\troot &#x3D; root-&gt;left;\n\t\t\t\t&#125;\n\t\t\t\telse &#123;\n\t\t\t\t\tp-&gt;right &#x3D; NULL;\n\t\t\t\t\tif (prep &amp;&amp; prep-&gt;val &gt; root-&gt;val) &#123;\n\t\t\t\t\t\tif (!first) first &#x3D; prep, second &#x3D; root;\n\t\t\t\t\t\telse second &#x3D; root;\n\t\t\t\t\t&#125;\n\t\t\t\t\tprep &#x3D; root;\n\t\t\t\t\troot &#x3D; root-&gt;right;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tswap(first-&gt;val, second-&gt;val);\n\t&#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"100-相同的树-p-amp-amp-q、-p-q-x3D-递归\"><a href=\"#100-相同的树-p-amp-amp-q、-p-q-x3D-递归\" class=\"headerlink\" title=\"100.相同的树 !p &amp;&amp; !q、!p || !q ||!&#x3D; 递归\"></a>100.相同的树 !p &amp;&amp; !q、!p || !q ||!&#x3D; 递归</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) &#123;\n        if(!p &amp;&amp; !q) return true;\n        if(!p || !q || p-&gt;val !&#x3D; q-&gt;val) return false;\n        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"101-对称二叉树-递归\"><a href=\"#101-对称二叉树-递归\" class=\"headerlink\" title=\"101. 对称二叉树 递归\"></a>101. 对称二叉树 递归</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tbool isSymmetric(TreeNode* root) &#123;\n\t\treturn !root || dfs(root-&gt;left, root-&gt;right);\n\t&#125;\n\n\tbool dfs(TreeNode* p, TreeNode* q) &#123;\n\t\tif (!p || !q) return !p &amp;&amp; !q;&#x2F;&#x2F; 【学：if(||) return &amp;&amp; 】\n\t\treturn p-&gt;val &#x3D;&#x3D; q-&gt;val &amp;&amp; dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);\n\t&#125;\n&#x2F;*\tbool dfs(TreeNode* p, TreeNode* q) &#123;\n\t\tif (!p &amp;&amp; !q) return true;\n\t\tif (!p || !q || p-&gt;val !&#x3D; q-&gt;val) return false;\n\t\treturn dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);\n\t&#125;*&#x2F;\n&#125;;\n\n&#x2F;&#x2F;法二：迭代 stack p.LNR&#x3D;&#x3D;q.RNL \nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;182&#x2F;\nclass Solution &#123;\npublic:\n    bool isSymmetric(TreeNode* root) &#123;\n        if (!root) return true;\n        stack&lt;TreeNode*&gt; left, right;\n        TreeNode *lc &#x3D; root-&gt;left;\n        TreeNode *rc &#x3D; root-&gt;right;\n        while(lc || rc || left.size())\n        &#123;\n            while (lc &amp;&amp; rc)\n            &#123;\n                left.push(lc), right.push(rc);\n                lc &#x3D; lc-&gt;left, rc &#x3D; rc-&gt;right;\n            &#125;\n            if (lc || rc) return false;\n            lc &#x3D; left.top(), rc &#x3D; right.top(); &#x2F;&#x2F; -&gt;到top\n            left.pop(), right.pop();\n            if (lc-&gt;val !&#x3D; rc-&gt;val) return false;\n            lc &#x3D; lc-&gt;right, rc &#x3D; rc-&gt;left; &#x2F;&#x2F;NULL-&gt;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"102-二叉树的层序遍历-bfs-q-push-q-front\"><a href=\"#102-二叉树的层序遍历-bfs-q-push-q-front\" class=\"headerlink\" title=\"102.二叉树的层序遍历 bfs q.push  q.front()\"></a>102.二叉树的层序遍历 bfs q.push  q.front()</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;102. 二叉树的层序输出bfs q.front()       to:103 107\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tqueue&lt;TreeNode*&gt; q;\n\t\tif(root) q.push(root);\n\n\t\twhile(q.size()) &#123;\n\t\t\tvector&lt;int&gt; level;\n\t\t\tint len &#x3D; q.size();\n\n\t\t\twhile(len--) &#123; &#x2F;&#x2F; len!&#x3D;\n\t\t\t\tauto t &#x3D; q.front();\n\t\t\t\tq.pop();\n\t\t\t\tlevel.push_back(t-&gt;val);\n\t\t\t\tif(t-&gt;left) q.push(t-&gt;left);\n\t\t\t\tif(t-&gt;right) q.push(t-&gt;right);\n\t\t\t&#125;\n\n\t\t\tres.push_back(level);\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"103-lt-102-二叉树的锯齿形S层次遍历-cnt\"><a href=\"#103-lt-102-二叉树的锯齿形S层次遍历-cnt\" class=\"headerlink\" title=\"103&lt;-102.二叉树的锯齿形S层次遍历 cnt\"></a>103&lt;-102.二叉树的锯齿形S层次遍历 cnt</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;103. 二叉树的锯齿形S层次遍历  from:102\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tqueue&lt;TreeNode*&gt; q;\n\t\tif(root) q.push(root); &#x2F;&#x2F;\n\n\t\tint cnt &#x3D; 0;&#x2F;&#x2F;\n\t\twhile(q.size()) &#123;\n\t\t\tvector&lt;int&gt; level;\n\t\t\tint len &#x3D; q.size();\n\n\t\t\twhile(len--) &#123; &#x2F;&#x2F; 先限定层len!!!\n\t\t\t\tauto t &#x3D; q.front();\n\t\t\t\tq.pop();\n\t\t\t\tlevel.push_back(t-&gt;val);\n\t\t\t\tif(t-&gt;left) q.push(t-&gt;left);\n\t\t\t\tif(t-&gt;right) q.push(t-&gt;right);\n\t\t\t&#125;\n\t\t\tif( ++ cnt % 2 &#x3D;&#x3D; 0) reverse(level.begin(),level.end());&#x2F;&#x2F;\n\t\t\tres.push_back(level);\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n\n\n<h1 id=\"104-二叉树的最大深度-M-x3D-M-L-R-1\"><a href=\"#104-二叉树的最大深度-M-x3D-M-L-R-1\" class=\"headerlink\" title=\"104.二叉树的最大深度 M&#x3D;M(L,R)+1\"></a>104.二叉树的最大深度 M&#x3D;M(L,R)+1</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;104. 二叉树的最大深度     递归  dfs:stack bfs:queue\nclass Solution &#123;\npublic:\n\tint maxDepth(TreeNode* root) &#123;\n\t\tif(!root) return 0;\n\t\treturn max(maxDepth(root-&gt;left),maxDepth(root-&gt;right)) + 1;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"105-从前序与中序遍历序列构造二叉树-剑指18\"><a href=\"#105-从前序与中序遍历序列构造二叉树-剑指18\" class=\"headerlink\" title=\"105.从前序与中序遍历序列构造二叉树    剑指18\"></a>105.从前序与中序遍历序列构造二叉树    剑指18</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210413105022335.png\" alt=\"image-20210413105022335\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tunordered_map&lt;int, int&gt; pos;&#x2F;&#x2F;&#123;val,inorder_pos&#125;   idx_hash表\n\n\tTreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;\n\t\tfor (int i &#x3D; 0; i &lt; inorder.size(); i++) pos[inorder[i]] &#x3D; i;\n\t\treturn dfs(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);\n\t&#125;\n\n\tTreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir) &#123;\n\t\tif(pl &gt; pr) return NULL;\n\t\t\n\t\tauto root &#x3D; new TreeNode(preorder[pl]);\n\t\tint k &#x3D; pos[root-&gt;val];\n\t\troot-&gt;left &#x3D; dfs(preorder, inorder, pl + 1, pl + k - il, il, k - 1);\n\t\troot-&gt;right &#x3D; dfs(preorder, inorder, pl + k - il + 1, pr, k + 1, ir);\n&#x2F;*      \n \t\tint k &#x3D; pos[preorder[pl]] - il;\n\t\troot-&gt;left &#x3D; dfs(preorder, inorder, pl + 1, pl + k, il, il + k - 1);\n\t\troot-&gt;right &#x3D; dfs(preorder, inorder, pl + k + 1, pr, il + k + 1, ir);\n*&#x2F;\n\t\treturn root;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"106-从中序与后序遍历序列构造二叉树\"><a href=\"#106-从中序与后序遍历序列构造二叉树\" class=\"headerlink\" title=\"106.从中序与后序遍历序列构造二叉树\"></a>106.从中序与后序遍历序列构造二叉树</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tunordered_map&lt;int, int&gt; pos;&#x2F;&#x2F;inorder_pos   idx_hash表\n\n\tTreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;\n\t\tfor (int i &#x3D; 0; i &lt; inorder.size(); i++) pos[inorder[i]] &#x3D; i;\n\t\treturn dfs(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);\n\t&#125;\n\n\tTreeNode* dfs(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int il, int ir, int pl, int pr) &#123;\n\t\tif(il &gt; ir) return NULL;\n\t\tauto root &#x3D; new TreeNode(postorder[pr]);\n\t\tint k &#x3D; pos[root-&gt;val];\n\t\t\n\t\troot-&gt;left &#x3D; dfs(inorder, postorder, il, k - 1, pl, pl + k - 1 - il);\n\t\troot-&gt;right &#x3D; dfs(inorder, postorder, k + 1, ir, pl + k - il, pr - 1);\n\n\t\treturn root;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"107-lt-102-二叉树的层次遍历-II-自底向上-reverse-res\"><a href=\"#107-lt-102-二叉树的层次遍历-II-自底向上-reverse-res\" class=\"headerlink\" title=\"107&lt;-102.二叉树的层次遍历 II 自底向上 reverse(res)\"></a>107&lt;-102.二叉树的层次遍历 II 自底向上 reverse(res)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tqueue&lt;TreeNode*&gt; q;\n\t\tif(root) q.push(root);\n\n\t\twhile(q.size()) &#123;\n\t\t\tvector&lt;int&gt; level;\n\t\t\tint len &#x3D; q.size();\n\n\t\t\twhile(len--) &#123; &#x2F;&#x2F; 先限定层len!!!\n\t\t\t\tauto t &#x3D; q.front();\n\t\t\t\tq.pop();\n\t\t\t\tlevel.push_back(t-&gt;val);\n\t\t\t\tif(t-&gt;left) q.push(t-&gt;left);\n\t\t\t\tif(t-&gt;right) q.push(t-&gt;right);\n\t\t\t&#125;\n\t\t\tres.push_back(level);\n\t\t&#125;\n\t\treverse(res.begin(), res.end()); &#x2F;&#x2F;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"108-将有序数组-中序-转换为-高度平衡-二叉搜索树\"><a href=\"#108-将有序数组-中序-转换为-高度平衡-二叉搜索树\" class=\"headerlink\" title=\"108.将有序数组(中序)转换为(高度平衡)二叉搜索树\"></a>108.将有序数组(中序)转换为(高度平衡)二叉搜索树</h1><p>SeqTree AVL</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210413114755347.png\" alt=\"image-20210413114755347\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;196&#x2F;\n每次以中点为根，以左半部分为左子树，右半部分为右子树。先分别递归建立左子树和右子树，然后令根节点的指针分别指向两棵子树。\n该算法得到的BST满足：任意节点的左右子树的所有高度的差不大于1（注意不是最大高度）。\nproof:\n在每一次递归过程中，左半部分的长度最多比右半部分的长度少1，那会不会有这种情况：\n左半部分的高度分别有 m−1,m，右半部分的高度有 m,m+1，则当前节点的高度就是 m,m+1,m+2\n（要加上当前根节点这一层，所以都要加1），则此时树的高度差为2，不平衡。\n实际上这种情况是不可能的：反证，对于左子树，由于存在高度 m−1，所以左半部分最多有 2m−2 个数；\n对于右子树，由于存在高度 m 和 m+1，所以右半部分最少有 2m 个数，此时左右两部分的数的个数最少差2，矛盾。\n*&#x2F;\nclass Solution &#123;\npublic:\n\tTreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;\n\t\treturn build(nums, 0, nums.size() - 1);\n\t&#125;\n\n\tTreeNode *build(vector&lt;int&gt;&amp;nums, int l, int r)\n\t&#123;\n\t\tif (l &gt; r) return 0;\n\t\tint mid &#x3D; (l + r) &gt;&gt; 1; &#x2F;&#x2F;\n\t\tauto root &#x3D; new TreeNode(nums[mid]); &#x2F;&#x2F;\n\t\troot-&gt;left &#x3D; build(nums, l, mid - 1);\n\t\troot-&gt;right &#x3D; build(nums, mid + 1, r);\n\t\treturn root;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"109-有序链表转换-高度平衡-二叉搜索树-取中点O-n-cur-x3D-中点-1-cur-gt-next-x3D-NULL\"><a href=\"#109-有序链表转换-高度平衡-二叉搜索树-取中点O-n-cur-x3D-中点-1-cur-gt-next-x3D-NULL\" class=\"headerlink\" title=\"109.有序链表转换(高度平衡)二叉搜索树 取中点O(n)  cur&#x3D;中点-1   cur-&gt;next &#x3D; NULL;\"></a>109.有序链表转换(高度平衡)二叉搜索树 取中点O(n)  cur&#x3D;中点-1   cur-&gt;next &#x3D; NULL;</h1><p>O(nlogn)</p>\n<p>ceil(b&#x2F;a) &#x3D;&#x3D; floor((b+a-1)&#x2F;a)</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210413120400543.png\" alt=\"image-20210413120400543\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tTreeNode* sortedListToBST(ListNode* head) &#123;\n\t\tif(!head) return NULL;\n\t\tint n &#x3D; 0;\n\t\tfor (auto p &#x3D; head; p; p &#x3D; p-&gt;next) n++;\n\t\tif(n &#x3D;&#x3D; 1) return new TreeNode(head-&gt;val);\n\n\t\tauto cur &#x3D; head;\n\t\tfor (int i &#x3D; 0; i &lt; n &#x2F; 2 - 1; i++) cur &#x3D; cur-&gt;next;&#x2F;&#x2F;cur&#x3D;中点-1\n\t\tauto root &#x3D; new TreeNode(cur-&gt;next-&gt;val);&#x2F;&#x2F;root&#x3D;中点\n\t\troot-&gt;right &#x3D; sortedListToBST(cur-&gt;next-&gt;next);\n        \n\t\tcur-&gt;next &#x3D; NULL;&#x2F;&#x2F;!!!\n\t\troot-&gt;left &#x3D; sortedListToBST(head);\n\t\t\n        return root;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"110-平衡二叉树judge-abs-gt-1-F-递归h-x3D-max-lh-rh-1\"><a href=\"#110-平衡二叉树judge-abs-gt-1-F-递归h-x3D-max-lh-rh-1\" class=\"headerlink\" title=\"110.平衡二叉树judge  abs&gt;1:F   递归h&#x3D;max(lh, rh) + 1\"></a>110.平衡二叉树judge  abs&gt;1:F   递归h&#x3D;max(lh, rh) + 1</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;110. 平衡二叉树    递归h&#x3D;max(lh, rh) + 1   abs(lh-rh)&lt;&#x3D;1\n#include &lt;math.h&gt;\nclass Solution &#123;\npublic:\n\tbool ans;\n\n\tbool isBalanced(TreeNode* root) &#123;\n\t\tans &#x3D; true;\n\t\tdfs(root);\n\t\treturn ans;\n\t&#125;\n\n\tint dfs(TreeNode* root) &#123;\n\t\tif(!root) return 0;\n\t\tint lh &#x3D; dfs(root-&gt;left), rh &#x3D; dfs(root-&gt;right);\n\t\tif(abs(lh - rh) &gt; 1) ans &#x3D; false;&#x2F;&#x2F;\n\t\treturn max(lh, rh) + 1;&#x2F;&#x2F;\n\t&#125;\n\n\t&#x2F;*\n\tbool isBalanced(TreeNode* root) &#123;\n\t\treturn dfs(root)[0];\n\t&#125;\n\n\tvector&lt;int&gt; dfs(TreeNode* root) &#123;\n\t\tif(!root) return &#123;1, 0&#125;; &#x2F;&#x2F; &#123;subTreeIsBalanced&#x3D;T&#x2F;F,height&#125;\n\t\tauto l &#x3D; dfs(root-&gt;left), r &#x3D; dfs(root-&gt;right);\n\t\treturn &#123;l[0] &amp;&amp; r[0] &amp;&amp; abs(l[1] - r[1]) &lt;&#x3D; 1, max(l[1], r[1]) + 1&#125;;\n\t&#125;\n\t*&#x2F;\n&#125;;\n\n&#x2F;&#x2F;Acwing253 普通平衡树\n</code></pre>\n\n\n\n<h1 id=\"111-二叉树的最小深度\"><a href=\"#111-二叉树的最小深度\" class=\"headerlink\" title=\"111.二叉树的最小深度\"></a>111.二叉树的最小深度</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minDepth(TreeNode* root) &#123;\n        if (!root) return 0;\n        int res &#x3D; INT_MAX;\n        if (root-&gt;left) res &#x3D; min(res, minDepth(root-&gt;left) + 1);\n        if (root-&gt;right) res &#x3D; min(res, minDepth(root-&gt;right) + 1);\n        if (res &#x3D;&#x3D; INT_MAX) res &#x3D; 1;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h1 id=\"112-路径总和-tree-存在否-自上而下！\"><a href=\"#112-路径总和-tree-存在否-自上而下！\" class=\"headerlink\" title=\"112.路径总和 tree 存在否 自上而下！\"></a>112.路径总和 tree 存在否 自上而下！</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool hasPathSum(TreeNode* root, int sum) &#123;\n        if(!root) return false;\n        sum -&#x3D; root-&gt;val;\n        if(!root-&gt;left &amp;&amp; !root-&gt;right) return !sum;\n        return root-&gt;left &amp;&amp; hasPathSum(root-&gt;left, sum) || root-&gt;right &amp;&amp; hasPathSum(root-&gt;right, sum);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"113-路径总和II-记录所有路径\"><a href=\"#113-路径总和II-记录所有路径\" class=\"headerlink\" title=\"113.路径总和II 记录所有路径\"></a>113.路径总和II 记录所有路径</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;\n        if(root) dfs(root, sum);\n        return ans;\n    &#125;\n    void dfs(TreeNode* root, int sum) &#123;\n        path.push_back(root-&gt;val);\n        sum -&#x3D; root-&gt;val;\n        if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;\n            if(!sum) ans.push_back(path);\n        &#125; else &#123;\n            if(root-&gt;left) dfs(root-&gt;left, sum);\n            if(root-&gt;right) dfs(root-&gt;right, sum);\n        &#125;\n        path.pop_back();&#x2F;&#x2F;回溯\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"114-二叉树展开为链表-斜向右NLR-左子树右链插入右节点处\"><a href=\"#114-二叉树展开为链表-斜向右NLR-左子树右链插入右节点处\" class=\"headerlink\" title=\"114.二叉树展开为链表 斜向右NLR 左子树右链插入右节点处\"></a>114.二叉树展开为链表 斜向右NLR 左子树右链插入右节点处</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210413203918658.png\" alt=\"image-20210413203918658\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void flatten(TreeNode* root) &#123;\n        TreeNode *now &#x3D; root;\n        while (now) &#123;\n            if (now-&gt;left) &#123;\n                TreeNode *p &#x3D; now-&gt;left;\n                while (p-&gt;right) p &#x3D; p-&gt;right;\n                p-&gt;right &#x3D; now-&gt;right;\n                now-&gt;right &#x3D; now-&gt;left; &#x2F;&#x2F;\n                now-&gt;left &#x3D; NULL;\n            &#125;\n            now &#x3D; now-&gt;right;\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"115-不同的子序列-S有多少个T-DP-≠不能匹-x3D-可以匹-也可以不匹\"><a href=\"#115-不同的子序列-S有多少个T-DP-≠不能匹-x3D-可以匹-也可以不匹\" class=\"headerlink\" title=\"115.不同的子序列 S有多少个T DP ≠不能匹 &#x3D;可以匹,也可以不匹\"></a>115.不同的子序列 S有多少个T DP ≠不能匹 &#x3D;可以匹,也可以不匹</h1><p>DP：O(nm)<br>可以换一种考虑问题的方式：用 S 中的字符，按顺序匹配 T 中的字符，问【S有多少种方式可以匹配完 T 中的所有字符。】</p>\n<p>可以用动态规划来做：<br>f[i][j]表示用 S 的前 i 个字符，能匹配完 T 的前 j 个字符的方案数。 初始化：因为 S 可以从任意一个字符开始匹配，所以 $f[i][0]&#x3D;1,∀i∈[0,len(S)]$。<br>状态转移：</p>\n<p>如果 S[i−1]≠T[j−1]，则 S[i−1] 不能匹配 T[j−1]，所以 $f[i][j]&#x3D;f[i−1][j]$<br>如果 S[i−1]&#x3D;T[j−1]，则 S[i−1] 既可以匹配 T[j−1]，也可以不匹配 T[j−1]，所以 $f[i][j]&#x3D;f[i−1][j]+f[i−1][j−1]$；<br>链接：<a href=\"https://www.acwing.com/solution/content/203/\">https://www.acwing.com/solution/content/203/</a><br><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210413214317522.png\" alt=\"image-20210413214317522\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int numDistinct(string s, string t) &#123;\n        int n &#x3D; s.size(), m &#x3D; t.size();\n        s &#x3D; &#39; &#39; + s, t &#x3D; &#39; &#39; + t;&#x2F;&#x2F;空串\n        &#x2F;&#x2F;防止中间值爆int越界：ULL\n        vector&lt;vector&lt;unsigned long long&gt;&gt; f(n + 1, vector&lt;unsigned long long&gt;(m + 1));\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i ++ ) f[i][0] &#x3D; 1;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) &#123;\n                f[i][j] &#x3D; f[i - 1][j];\n                if (s[i] &#x3D;&#x3D; t[j]) f[i][j] +&#x3D; f[i - 1][j - 1];\n            &#125;\n        return f[n][m];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"116-填充每个节点的下一个右侧节点指针-完美二叉树-满\"><a href=\"#116-填充每个节点的下一个右侧节点指针-完美二叉树-满\" class=\"headerlink\" title=\"116.填充每个节点的下一个右侧节点指针 完美二叉树(满)\"></a>116.填充每个节点的下一个右侧节点指针 完美二叉树(满)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210413220133227.png\" alt=\"image-20210413220133227\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    Node* connect(Node* root) &#123;\n        if (!root) return root;\n        auto last &#x3D; root;\n        while (last-&gt;left) &#123;\n            for (auto p &#x3D; last; p; p &#x3D; p-&gt;next) &#123;\n                p-&gt;left-&gt;next &#x3D; p-&gt;right;\n                if (p-&gt;next) p-&gt;right-&gt;next &#x3D; p-&gt;next-&gt;left;\n                else p-&gt;right-&gt;next &#x3D; NULL;&#x2F;&#x2F;可省\n            &#125;\n            last &#x3D; last-&gt;left; &#x2F;&#x2F;每层first\n        &#125;\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"117-填充每个节点的下一个右侧节点指针II-非完美二叉树-虚拟头结点h-x3D-t-gt-next-x3D-每层first-cur\"><a href=\"#117-填充每个节点的下一个右侧节点指针II-非完美二叉树-虚拟头结点h-x3D-t-gt-next-x3D-每层first-cur\" class=\"headerlink\" title=\"117.填充每个节点的下一个右侧节点指针II 非完美二叉树 虚拟头结点h&#x3D;t -&gt;next&#x3D;每层first:cur\"></a>117.填充每个节点的下一个右侧节点指针II 非完美二叉树 虚拟头结点h&#x3D;t -&gt;next&#x3D;每层first:cur</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;填充它的每个 next 指针，以指向其下一个右侧节点\nclass Solution &#123;\npublic:\n    Node* connect(Node* root) &#123;\n        if(!root) return root;\n        auto cur &#x3D; root;\n        while(cur) &#123;\n            auto head &#x3D; new Node(-1); &#x2F;&#x2F;虚拟头结点h&#x3D;t -&gt;next&#x3D;每层first\n            auto tail &#x3D; head;\n            for(auto p &#x3D; cur; p; p &#x3D; p-&gt;next) &#123; &#x2F;&#x2F;上层p\n                if(p-&gt;left) tail &#x3D; tail-&gt;next &#x3D; p-&gt;left;\n                if(p-&gt;right) tail &#x3D; tail-&gt;next &#x3D; p-&gt;right;\n            &#125;\n            cur &#x3D; head-&gt;next;&#x2F;&#x2F;每层first\n        &#125;\n        return root;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"118-杨辉三角-1-k\"><a href=\"#118-杨辉三角-1-k\" class=\"headerlink\" title=\"118.杨辉三角 1~k\"></a>118.杨辉三角 1~k</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]</code></pre>\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f;\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            vector&lt;int&gt; line(i + 1);&#x2F;&#x2F;0行有1个\n            line[0] &#x3D; line[i] &#x3D; 1;&#x2F;&#x2F;\n            for(int j &#x3D; 1; j &lt; i; j++) \n                line[j] &#x3D; f[i - 1][j - 1] + f[i - 1][j];\n            f.push_back(line);\n        &#125;\n        return f;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"119-杨辉三角II-k-S-x3D-O-k-滚动数组-【2】-amp-1\"><a href=\"#119-杨辉三角II-k-S-x3D-O-k-滚动数组-【2】-amp-1\" class=\"headerlink\" title=\"119.杨辉三角II  k  S&#x3D;O(k) 滚动数组 【2】 &amp;1\"></a>119.杨辉三角II  k  S&#x3D;O(k) 滚动数组 【2】 &amp;1</h1><p> <em>O</em>(<em>k</em>) 空间复杂度:滚动数组</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; getRow(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1));\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            f[i][0] &#x3D; f[i][i] &#x3D; 1;&#x2F;&#x2F;\n            for(int j &#x3D; 1; j &lt; i; j++) \n                f[i][j] &#x3D; f[i - 1][j - 1] + f[i - 1][j];\n        &#125;\n        return f[n];\n    &#125;\n&#125;;\n\n&#x2F;*\nn%2 &#x3D;&#x3D; n&amp;1 \n +-  &gt;  &amp;\n第一维[2] &amp;1 即可\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; getRow(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(n + 1));\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            f[i &amp; 1][0] &#x3D; f[i &amp; 1][i] &#x3D; 1;&#x2F;&#x2F;\n            for(int j &#x3D; 1; j &lt; i; j++) \n                f[i &amp; 1][j] &#x3D; f[i - 1 &amp; 1][j - 1] + f[i - 1 &amp; 1][j];\n        &#125;\n        return f[n &amp; 1];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"120-三角形最小路径和-向上DP\"><a href=\"#120-三角形最小路径和-向上DP\" class=\"headerlink\" title=\"120.三角形最小路径和 向上DP\"></a>120.三角形最小路径和 向上DP</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\nT&#x3D;O(2^(n-1)) DP优化：时间O(n*n) 空间O(1)\n向下要考虑边界特判,故向上递推\nf(i,j)表示从下往上走到位置(i,j)时的最小路径和\nf(i,j)&#x3D;(i,j)+min(f(i+1,j),f(i+1,j+1))\n*&#x2F;\nclass Solution &#123;\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; f) &#123;\n        for(int i &#x3D; f.size() - 2; i &gt;&#x3D; 0; i--)\n            for(int j &#x3D; 0; j &lt;&#x3D; i; j++)\n                f[i][j] +&#x3D; min(f[i + 1][j], f[i + 1][j + 1]);\n        return f[0][0];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"121-买卖股票的最佳时机-max-prices-i-minp\"><a href=\"#121-买卖股票的最佳时机-max-prices-i-minp\" class=\"headerlink\" title=\"121.买卖股票的最佳时机  max(prices[i] - minp)\"></a>121.买卖股票的最佳时机  max(prices[i] - minp)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210414210614859.png\" alt=\"image-20210414210614859\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0, minp &#x3D; INT_MAX; i &lt; prices.size(); i++) &#123;\n            res &#x3D; max(res, prices[i] - minp);\n            minp &#x3D; min(minp, prices[i]);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"122-买卖股票的最佳时机II-多次买卖不重叠-交易拆为单天！-max利-x3D-利日之和-x3D-max-0-prices-i-1-prices-i\"><a href=\"#122-买卖股票的最佳时机II-多次买卖不重叠-交易拆为单天！-max利-x3D-利日之和-x3D-max-0-prices-i-1-prices-i\" class=\"headerlink\" title=\"122.买卖股票的最佳时机II 多次买卖不重叠 交易拆为单天！ max利&#x3D;+利日之和   +&#x3D;max(0, prices[i + 1] - prices[i])\"></a>122.买卖股票的最佳时机II 多次买卖不重叠 交易拆为单天！ max利&#x3D;+利日之和   +&#x3D;max(0, prices[i + 1] - prices[i])</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i + 1 &lt; prices.size(); i++) &#x2F;&#x2F;\n            res +&#x3D; max(0, prices[i + 1] - prices[i]);\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"—123-买卖股票的最佳时机-III-最多2次-前后缀分解\"><a href=\"#—123-买卖股票的最佳时机-III-最多2次-前后缀分解\" class=\"headerlink\" title=\"—123.买卖股票的最佳时机 III 最多2次 前后缀分解\"></a>—123.买卖股票的最佳时机 III 最多2次 前后缀分解</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210414212614234.png\" alt=\"image-20210414212614234\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;123.买卖股票的最佳时机 III 最多2次\n&#x2F;*\nDP：最多k次 更通用\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;219&#x2F;\n遍历一遍数组，求[0,i−1]区间的最大利润f(i)，具体做法是找当前最低价格low，判断是要以low买入当天卖出，还是不动\n从后往前遍历，求[i,n−1]区间的最大利润g(i)，具体做法是找当前最高价格high，判断是要当天买入以high卖出，还是不动\n遍历，求最大利润max(f(i)+g(i))\n\n股票6题汇总:\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;yimingsilence&#x2F;article&#x2F;details&#x2F;79212621\n\n“最多2次”前后缀分解:预处理前后缀 枚举终点\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;211&#x2F;\n*&#x2F;\nclass Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n    \tint n &#x3D; prices.size();\n    \tvector&lt;int&gt; f(n + 2);&#x2F;&#x2F;\n    \tfor(int i &#x3D; 1, minp &#x3D; INT_MAX; i &lt;&#x3D; n; i++) &#123;\n            f[i] &#x3D; max(f[i - 1], prices[i - 1] - minp);&#x2F;&#x2F;i_day卖,不卖\n            minp &#x3D; min(minp, prices[i - 1]);\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; n, maxp &#x3D; 0; i; i--) &#123;\n        \tres &#x3D; max(res, maxp - prices[i - 1] + f[i - 1]);\n        \tmaxp &#x3D; max(maxp, prices[i - 1]);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"124-二叉树中的最大路径和-LC543-树形DP法-枚举LCA为割点-ans-x3D-max-LNR-点val-return-root-max-l-r\"><a href=\"#124-二叉树中的最大路径和-LC543-树形DP法-枚举LCA为割点-ans-x3D-max-LNR-点val-return-root-max-l-r\" class=\"headerlink\" title=\"124.二叉树中的最大路径和[LC543] 树形DP法 枚举LCA为割点 ans&#x3D;max(LNR);点val return root+max(l,r);\"></a>124.二叉树中的最大路径和[LC543] 树形DP法 枚举LCA为割点 ans&#x3D;max(LNR);点val return root+max(l,r);</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int ans;\n    int maxPathSum(TreeNode* root) &#123;\n        ans &#x3D; INT_MIN;\n        dfs(root);\n        return ans;\n    &#125;\n\n    int dfs(TreeNode* root)\n    &#123;\n        if (!root) return 0;\n        int left &#x3D; max(0, dfs(root-&gt;left)), right &#x3D; max(0, dfs(root-&gt;right));&#x2F;&#x2F;&gt;0\n        ans &#x3D; max(ans, left + root-&gt;val + right);\n        return root-&gt;val + max(left, right);&#x2F;&#x2F;子树的顶到底max路径和 只为递归\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;P369 0x63 求树的直径 树形DP法、两次BFS或DFS法\n&#x2F;*\n树的直径是指树的最长简单路。求法: \n两遍BFS:\n先任选一个起点BFS找到最长路的终点，再从终点进行BFS，则第二次BFS找到的最长路即为树的直径；\n原理:\n设起点为u,第一次BFS找到的终点v一定是树的直径的一个端点\n证明:\n1) 如果u 是直径上的点，则v显然是直径的终点(因为如果v不是的话，则必定存在另一个点w使得u到w的距离更长，则于BFS找到了v矛盾)\n2) 如果u不是直径上的点，则u到v必然于树的直径相交(反证),那么交点到v 必然就是直径的后半段了\n所以v一定是直径的一个端点，所以从v进行BFS得到的一定是直径长度\n*&#x2F;</code></pre>\n\n\n\n<h1 id=\"125-验证回文串-双指针-只考虑字母和数字字符，可以忽略字母的大小写。\"><a href=\"#125-验证回文串-双指针-只考虑字母和数字字符，可以忽略字母的大小写。\" class=\"headerlink\" title=\"125.验证回文串 双指针 只考虑字母和数字字符，可以忽略字母的大小写。\"></a>125.验证回文串 双指针 只考虑字母和数字字符，可以忽略字母的大小写。</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool check(char c) &#123;\n        return c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39; || c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39; || c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;;\n    &#125;\n    bool isPalindrome(string s) &#123;\n        for(int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; i++, j--) &#123;\n            while(i &lt; j &amp;&amp; !check(s[i])) i++;\n            while(i &lt; j &amp;&amp; !check(s[j])) j--;\n            if(i &lt; j &amp;&amp; tolower(s[i]) !&#x3D; tolower(s[j])) return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"—126-单词接龙II-01最短路-bfs-dfs-输出方案-S-count-st\"><a href=\"#—126-单词接龙II-01最短路-bfs-dfs-输出方案-S-count-st\" class=\"headerlink\" title=\"—126.单词接龙II 01最短路 bfs+dfs 输出方案 S.count(st)???\"></a>—126.单词接龙II 01最短路 bfs+dfs 输出方案 S.count(st)???</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210415093811857.png\" alt=\"image-20210415093811857\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\nT&#x3D;O(2^(n&#x2F;3)) 至少指数级别\n最短路模型：\n01 bfs\n+ dijkstra\n- SPFA\n\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;217&#x2F;\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; ans;\n    vector&lt;string&gt; path;\n    unordered_set&lt;string&gt; S;\n    unordered_map&lt;string, int&gt; dist;&#x2F;&#x2F;到起点的距离\n\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        for (auto&amp; word: wordList) S.insert(word);\n        queue&lt;string&gt; q;\n        q.push(beginWord);\n        dist[beginWord] &#x3D; 0;\n        while (q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            string r &#x3D; t;\n            for (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n                t &#x3D; r;\n                for (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n                    if (j !&#x3D; r[i]) &#123;\n                        t[i] &#x3D; j;\n                        if (S.count(t) &amp;&amp; dist.count(t) &#x3D;&#x3D; 0) &#123;\n                            dist[t] &#x3D; dist[r] + 1;\n                            if (t &#x3D;&#x3D; endWord) break;\n                            q.push(t);\n                        &#125;\n                    &#125;\n            &#125;\n        &#125;\n\n        if (dist.count(endWord)) &#123;\n            path.push_back(beginWord);\n            dfs(beginWord, endWord);\n        &#125;\n\n        return ans;\n    &#125;\n\n    void dfs(string st, string ed) &#123;&#x2F;&#x2F;正的\n        if (st &#x3D;&#x3D; ed) &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        string r &#x3D; st;\n        for (int i &#x3D; 0; i &lt; st.size(); i ++ ) &#123;\n            st &#x3D; r;\n            for (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n                if (j !&#x3D; r[i]) &#123;\n                    st[i] &#x3D; j;\n                    &#x2F;&#x2F;S.count(st)???\n                    if (S.count(st) &amp;&amp; dist[r] + 1 &#x3D;&#x3D; dist[st]) &#123;&#x2F;&#x2F;start-&gt;r-&gt;st\n                        path.push_back(st);\n                        dfs(st, ed);\n                        path.pop_back();\n                    &#125;\n                &#125;\n        &#125;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;写法2\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; ans;\n    vector&lt;string&gt; path;\n    unordered_set&lt;string&gt; S;\n    unordered_map&lt;string, int&gt; dist;&#x2F;&#x2F;到起点的距离\n    string beginWord;\n\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string _beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        beginWord &#x3D; _beginWord;\n        for (auto&amp; word: wordList) S.insert(word);\n        queue&lt;string&gt; q;\n        q.push(beginWord);\n        dist[beginWord] &#x3D; 0;\n        while (q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            string r &#x3D; t;\n            for (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n                t &#x3D; r;\n                for (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n                    if (j !&#x3D; r[i]) &#123;\n                        t[i] &#x3D; j;\n                        if (S.count(t) &amp;&amp; dist.count(t) &#x3D;&#x3D; 0) &#123;\n                            dist[t] &#x3D; dist[r] + 1;&#x2F;&#x2F;start-&gt;r-&gt;t\n                            if (t &#x3D;&#x3D; endWord) break;\n                            q.push(t);\n                        &#125;\n                    &#125;\n            &#125;\n        &#125;\n\n        if (dist.count(endWord)) &#123;\n            path.push_back(endWord);\n            dfs(endWord);\n        &#125;\n\n        return ans;\n    &#125;\n\n    void dfs(string t) &#123;\n        if (t &#x3D;&#x3D; beginWord) &#123;\n        \treverse(path.begin(),path.end());\n            ans.push_back(path);\n           \treverse(path.begin(),path.end());\n            return;\n        &#125;\n        string r &#x3D; t;\n        for (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n            t &#x3D; r;\n            for (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n                if (j !&#x3D; r[i]) &#123;\n                    t[i] &#x3D; j;\n                    &#x2F;&#x2F;S.count(t)错 因为beginWord不一定在wordList里(上层过滤了)\n                    if (dist.count(t) &amp;&amp; dist[t] + 1 &#x3D;&#x3D; dist[r]) &#123;&#x2F;&#x2F;start&lt;-t&lt;-r\n                        path.push_back(t);\n                        dfs(t);\n                        path.pop_back();\n                    &#125;\n                &#125;\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"127-单词接龙-min-node-step\"><a href=\"#127-单词接龙-min-node-step\" class=\"headerlink\" title=\"127.单词接龙 min_node_step\"></a>127.单词接龙 min_node_step</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n\tint ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n\t\tunordered_set&lt;string&gt; S;\n\t\tfor (auto&amp; word: wordList) S.insert(word);\n\t\tunordered_map&lt;string, int&gt; dist;&#x2F;&#x2F;到起点的距离\n\t\tdist[beginWord] &#x3D; 0;\n\t\tqueue&lt;string&gt; q;\n\t\tq.push(beginWord);\n\t\t\n\t\twhile (q.size()) &#123;\n\t\t\tauto t &#x3D; q.front();\n\t\t\tq.pop();\n\n\t\t\tstring r &#x3D; t;\n\t\t\tfor (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n\t\t\t\tt &#x3D; r;\n\t\t\t\tfor (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n\t\t\t\t\tif (j !&#x3D; r[i]) &#123;\n\t\t\t\t\t\tt[i] &#x3D; j;\n\t\t\t\t\t\tif (S.count(t) &amp;&amp; dist.count(t) &#x3D;&#x3D; 0) &#123;\n\t\t\t\t\t\t\tdist[t] &#x3D; dist[r] + 1;&#x2F;&#x2F;start-&gt;r-&gt;t\n\t\t\t\t\t\t\tif (t &#x3D;&#x3D; endWord) return dist[t] + 1;\n\t\t\t\t\t\t\tq.push(t);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn 0;\n\t&#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"—128-最长连续序列-找出【数字连续的最长】序列-可乱序-不连续-T-x3D-O-n-hash-枚举段首-多次段首去重S-erase-x-max-x-y\"><a href=\"#—128-最长连续序列-找出【数字连续的最长】序列-可乱序-不连续-T-x3D-O-n-hash-枚举段首-多次段首去重S-erase-x-max-x-y\" class=\"headerlink\" title=\"—128.最长连续序列 找出【数字连续的最长】序列(可乱序 不连续) T&#x3D;O(n) hash 枚举段首 多次段首去重S.erase(x);  max[x,y]\"></a>—128.最长连续序列 找出【数字连续的最长】序列(可乱序 不连续) T&#x3D;O(n) hash 枚举段首 多次段首去重S.erase(x);  max[x,y]</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n！！！UF-set：路径压缩+按秩合并&#x3D;每步O(1)\n将数组中数值相邻的元素使用并查集合并，最后看一下哪一个连通块最大【单链表】\n在这里不能按秩合并：O(logn)-&gt;T&#x3D;O(nlogn)\n！！！\n\n最simple：\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;6379&#x2F; 未去重!\n枚举段首 多次段首去重S.erase(x);\n*&#x2F;\nclass Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;int&gt; S;\n        for(auto x: nums) S.insert(x);\n\n        int res &#x3D; 0;\n        for(auto x: nums) &#123;\n            if(S.count(x) &amp;&amp; !S.count(x - 1)) &#123;&#x2F;&#x2F;段首\n                int y &#x3D; x;\n                S.erase(x);&#x2F;&#x2F;&#x3D;&#x3D;去重\n                while(S.count(y + 1)) &#123;\n                    y++;\n                    S.erase(y);&#x2F;&#x2F;\n                &#125;\n                res &#x3D; max(res, y - x + 1);&#x2F;&#x2F;[x,y]\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;*!!!666\nhash表维护区间：yxc\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;222&#x2F;\n\n“tr_left[x-left] &#x3D; max(tr_left[x-left], left+1+right);”为什么要取max呢，\nleft+1+right不就应该是当前以x-left为左端点的序列长度最大值吗\n回复\n所有极大区间两端的点存储的tr_left和tr_right都是整个区间的长度，\n【但区间内的点存储的长度可能比实际值要小。】\n可以试试这个样例，正确答案是5，如果去掉max操作会得到4：\n[-6,8,-5,7,-9,-1,-7,-6,-9,-7,5,7,-1,-8,-8,-2,0]\n因为我们没有删除冗余的小区间，如果合并区间的同时把冗余小区间删除，就没有这个问题了。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; 0;\n        unordered_map&lt;int, int&gt; tr_left, tr_right;&#x2F;&#x2F;[cur]&#x3D;L,R端点的max区间\n        for (auto&amp; x : nums)\n        &#123;\n            int left &#x3D; tr_right[x - 1];\n            int right &#x3D; tr_left[x + 1];\n            tr_left[x - left] &#x3D; max(tr_left[x - left], left + 1 + right);\n            tr_right[x + right] &#x3D; max(tr_right[x + right], left + 1 + right);\n            res &#x3D; max(res, left + 1 + right);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;*\nwzc1995   2018-06-10 14:00  [--X--] 更新的是同一个F，无冗余小区间\n可以只用一个哈希表记录每个数字所能构成的最大长度\n当扫描到一个新数字时，找该数字左右数字的最大长度，合并后，更新该数字和新连续序列左右数字的哈希值。\n如果当前扫描到的数已经在哈希表中了，则直接跳过。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n\n        int res &#x3D; 0;\n        unordered_map&lt;int,int&gt;F;\n        for(auto x:nums)\n        &#123;\n          if(F[x])continue;&#x2F;&#x2F;三个点同时判重\n          F[x]&#x3D;1;&#x2F;&#x2F;标记\n          int left&#x3D;F[x-1];&#x2F;&#x2F;记录左右点包含的点个数\n          int right&#x3D;F[x+1];\n          F[x-left]&#x3D;right+left+1;&#x2F;&#x2F;更新左右边界区间内点的个数\n          F[x+right]&#x3D;right+left+1;\n          res&#x3D;max(res,right+left+1);\n        &#125;\n      return res;\n    &#125;\n\n\n&#125;;&#x2F;&#x2F;根据下面讨论区大佬的观点写的\n\n&#x2F;*\nyxc   2018-06-10 15:05     回复  端点lr 内部跳过了，一个range\n有道理！哈希表中记录每个数为边界的最大长度，则【只有区间边界的数有意义】，【如果遇到内部的数，我们直接跳过。】\n当遍历到 x 时，先求出 x−1 的最大长度，则由于 x 第一次遍历到，所以 x−1 如果存在，\n则一定是某个区间的右端点，同理 x+1 一定是某个区间的左端点。\n所以我们同时开两个哈希表，记录左右两边的哈希值是多余的，仅需一个哈希表即可。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        int maxs &#x3D; 0;\n        unordered_map&lt;int,int&gt; range;\n        for (int x: nums) &#123;\n            int l &#x3D; x;\n            int r &#x3D; x;\n            if (range[x] &gt; 0) continue;\n            l &#x3D; l - range[x - 1];\n            r &#x3D; r + range[x + 1];\n\n            range[l] &#x3D; r - l + 1;\n            range[r] &#x3D; r - l + 1;\n            range[x] &#x3D; max(range[x], 1); &#x2F;&#x2F;  注意这里\n            maxs &#x3D; max(maxs, r - l + 1);\n\n        &#125;\n        return maxs;\n    &#125; \n&#125;;</code></pre>\n\n\n\n<h1 id=\"129-求根节点到叶节点数字之和-路径-1-gt-2-代表数字-12-数字总和-x3D-12-13-x3D-25\"><a href=\"#129-求根节点到叶节点数字之和-路径-1-gt-2-代表数字-12-数字总和-x3D-12-13-x3D-25\" class=\"headerlink\" title=\"129.求根节点到叶节点数字之和 路径 1-&gt;2 代表数字 12 数字总和 &#x3D; 12 + 13 &#x3D; 25\"></a>129.求根节点到叶节点数字之和 路径 1-&gt;2 代表数字 12 数字总和 &#x3D; 12 + 13 &#x3D; 25</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210415152506975.png\" alt=\"image-20210415152506975\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;129.求根节点到叶节点数字之和\n&#x2F;*\n输入：root &#x3D; [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1-&gt;2 代表数字 12\n从根到叶子节点路径 1-&gt;3 代表数字 13\n因此，数字总和 &#x3D; 12 + 13 &#x3D; 25\n*&#x2F;\nclass Solution &#123;\npublic:\n    int ans &#x3D;  0;\n    int sumNumbers(TreeNode* root) &#123;\n        if(root) dfs(root, 0);\n        return ans;\n    &#125;\n\n    void dfs(TreeNode* root, int number) &#123;\n        number &#x3D; number * 10 + root-&gt;val;\n        if(!root-&gt;left &amp;&amp; !root-&gt;right) ans +&#x3D; number;&#x2F;&#x2F;\n        if(root-&gt;left) dfs(root-&gt;left, number);\n        if(root-&gt;right) dfs(root-&gt;right, number);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"130-被围绕的区域-围棋-逆向思维：mark边界O，其余–-gt-X-floodfill-dfs标记连通块\"><a href=\"#130-被围绕的区域-围棋-逆向思维：mark边界O，其余–-gt-X-floodfill-dfs标记连通块\" class=\"headerlink\" title=\"130.被围绕的区域 围棋 逆向思维：mark边界O，其余–&gt;X  floodfill_dfs标记连通块\"></a>130.被围绕的区域 围棋 逆向思维：mark边界O，其余–&gt;X  floodfill_dfs标记连通块</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;130.被围绕的区域 围棋\n&#x2F;&#x2F;floodfill找连通块 dfs不用queue\n&#x2F;&#x2F;逆向思维：mark边界O，其余--&gt;X\nclass Solution &#123;\npublic:\n    int n, m;\n    vector&lt;vector&lt;char&gt;&gt; board;\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n    \n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; _board) &#123;\n        board &#x3D;  _board;\n        n &#x3D; board.size();\n        if(!n) return;\n        m &#x3D; board[0].size();\n\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            if(board[i][0] &#x3D;&#x3D; &#39;O&#39;) dfs(i, 0);\n            if(board[i][m - 1] &#x3D;&#x3D; &#39;O&#39;) dfs(i, m - 1);\n        &#125;\n        \n        for(int i &#x3D; 0; i &lt; m; i++) &#123;\n            if(board[0][i] &#x3D;&#x3D; &#39;O&#39;) dfs(0, i);\n            if(board[n - 1][i] &#x3D;&#x3D; &#39;O&#39;) dfs(n - 1, i);\n        &#125;\n\n        for(int i &#x3D; 0; i &lt; n; i++) \n            for(int j &#x3D; 0; j &lt; m; j++)\n                if(board[i][j] &#x3D;&#x3D; &#39;#&#39;) board[i][j] &#x3D; &#39;O&#39;;&#x2F;&#x2F;recover\n                else board[i][j] &#x3D; &#39;X&#39;;\n\n        _board &#x3D; board;\n    &#125;\n    &#x2F;&#x2F;递归标记连通块\n    void dfs(int x, int y) &#123;\n        board[x][y] &#x3D; &#39;#&#39;;&#x2F;&#x2F;mark\n        for(int i &#x3D; 0; i &lt; 4; i++) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if(a &gt;&#x3D; 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; board[a][b] &#x3D;&#x3D; &#39;O&#39;)\n                dfs(a, b);\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"131-分割回文串-DP递推预处理-爆搜-O-n-2-2-n\"><a href=\"#131-分割回文串-DP递推预处理-爆搜-O-n-2-2-n\" class=\"headerlink\" title=\"131.分割回文串 DP递推预处理+爆搜:O(n^2 + 2^n)\"></a>131.分割回文串 DP递推预处理+爆搜:O(n^2 + 2^n)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210416093754555.png\" alt=\"image-20210416093754555\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;bool&gt;&gt; f;\n    vector&lt;vector&lt;string&gt;&gt; ans;\n    vector&lt;string&gt; path;\n\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;\n        int n &#x3D; s.size();\n        f &#x3D; vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(n));\n        for(int j &#x3D; 0; j &lt; n; j++)\n            for(int i &#x3D; 0; i &lt;&#x3D; j; i++) &#x2F;&#x2F; &lt;&#x3D; j(i())：f拓扑序\n                if(i &#x3D;&#x3D; j) f[i][j] &#x3D; true;\n                else if(s[i] &#x3D;&#x3D; s[j]) &#123;\n                    if(i + 1 &gt; j - 1 || f[i + 1][j - 1]) f[i][j] &#x3D; true;&#x2F;&#x2F;\n                &#125;\n        dfs(s, 0);\n        return ans;\n    &#125;\n    void dfs(string&amp; s, int u) &#123;\n        if(u &#x3D;&#x3D; s.size()) ans.push_back(path);\n        else &#123;\n            for(int i &#x3D; u; i &lt; s.size(); i++)\n                if(f[u][i]) &#123;\n                    path.push_back(s.substr(u, i - u + 1));\n                    dfs(s, i + 1);\n                    path.pop_back();\n                &#125;\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"132-分割回文串-II-DP-min-cut-x3D-min-part-1-if-g-ji-f-i-x3D-min-f-i-f-j-1-1\"><a href=\"#132-分割回文串-II-DP-min-cut-x3D-min-part-1-if-g-ji-f-i-x3D-min-f-i-f-j-1-1\" class=\"headerlink\" title=\"132.分割回文串 II DP min_cut&#x3D;min_part-1 if(g_ji) f[i] &#x3D; min(f[i], f[j - 1] + 1);\"></a>132.分割回文串 II DP min_cut&#x3D;min_part-1 if(g_ji) f[i] &#x3D; min(f[i], f[j - 1] + 1);</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210416100600808.png\" alt=\"image-20210416100600808\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;132.分割回文串 II DP:O(n^2) min_cut&#x3D;min_part-1 if(g[j][i]) f[i] &#x3D; min(f[i], f[j - 1] + 1);\nclass Solution &#123;\npublic:\n    int minCut(string s) &#123;\n        int n &#x3D; s.size();\n        s &#x3D; &#39; &#39; + s;\n        vector&lt;vector&lt;bool&gt;&gt; g(n + 1, vector&lt;bool&gt;(n + 1));\n        vector&lt;int&gt; f(n + 1, INT_MAX);\n\n        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)\n            for(int i &#x3D; 1; i &lt;&#x3D; j; i++)\n                if(i &#x3D;&#x3D; j) g[i][j] &#x3D; true;\n                else if(s[i] &#x3D;&#x3D; s[j])\n                    g[i][j] &#x3D; i + 1 &gt; j - 1 || g[i + 1][j - 1];\n\n        f[0] &#x3D; 0;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            for(int j &#x3D; 1; j &lt;&#x3D; i; j++)\n                if(g[j][i]) f[i] &#x3D; min(f[i], f[j - 1] + 1);&#x2F;&#x2F;\n\n        return f[n] - 1;&#x2F;&#x2F;cut&#x3D;part-1\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"133-克隆图-无相连通图-深克隆-邻接列表-d-gt-neighbors-push-back-hash-ver\"><a href=\"#133-克隆图-无相连通图-深克隆-邻接列表-d-gt-neighbors-push-back-hash-ver\" class=\"headerlink\" title=\"133.克隆图 无相连通图 深克隆 邻接列表              d-&gt;neighbors.push_back(hash[ver]);\"></a>133.克隆图 无相连通图 深克隆 邻接列表              d-&gt;neighbors.push_back(hash[ver]);</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;133.克隆图 无相连通图 深克隆 邻接列表\nclass Solution &#123;\npublic:\n    unordered_map&lt;Node*, Node*&gt; hash;\n\n    Node* cloneGraph(Node* node) &#123;\n        if(!node) return NULL;\n        dfs(node); &#x2F;&#x2F; copy all nodes\n\n        for(auto [s, d]: hash)\n            for(auto ver: s-&gt;neighbors)\n                d-&gt;neighbors.push_back(hash[ver]);&#x2F;&#x2F;copy edges\n\n        return hash[node];\n    &#125;\n\n    void dfs(Node* node) &#123;\n        hash[node] &#x3D; new Node(node-&gt;val);\n\n        for(auto ver: node-&gt;neighbors)\n            if(!hash.count(ver)) dfs(ver);&#x2F;&#x2F;判重\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"—134-加油站-O-n-本质：贪心，基于：枚举-优化-O-n-n-gt-O-n\"><a href=\"#—134-加油站-O-n-本质：贪心，基于：枚举-优化-O-n-n-gt-O-n\" class=\"headerlink\" title=\"—134.加油站 O(n) 本质：贪心，基于：枚举+优化 O(n*n)-&gt;O(n)\"></a>—134.加油站 O(n) 本质：贪心，基于：枚举+优化 O(n*n)-&gt;O(n)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210416112707969.png\" alt=\"image-20210416112707969\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n---Acwing1088旅行问题 单调队列做法O(n) 更通用！\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;content&#x2F;description&#x2F;1090&#x2F;\n\n针对性O(n) 本质：贪心，基于：枚举+优化\n中间有left都走不到j+1，作为起点无油更不可能走到j+1！O(n*n)-&gt;O(n)\n*&#x2F;\nclass Solution &#123;\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;\n        int n &#x3D; gas.size();\n        for(int i &#x3D; 0, j; i &lt; n; ) &#123;&#x2F;&#x2F;枚举起点 i++ -&gt; i +&#x3D; j + 1;\n            int left &#x3D; 0;\n            for(j &#x3D; 0; j &lt; n; j++) &#123;\n                int k &#x3D; (i + j) % n;\n                left +&#x3D; gas[k] - cost[k];\n                if(left &lt; 0) break;\n            &#125;\n            if(j &#x3D;&#x3D; n) return i;\n            i +&#x3D; j + 1;\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"—135-分发糖果-gt-x3D-1-x2F-person-min-sum-记忆化搜索DP-f-x-x3D-max-dp-x-1-1-dp-x-1-1\"><a href=\"#—135-分发糖果-gt-x3D-1-x2F-person-min-sum-记忆化搜索DP-f-x-x3D-max-dp-x-1-1-dp-x-1-1\" class=\"headerlink\" title=\"—135.分发糖果  &gt;&#x3D;1&#x2F;person min_sum 记忆化搜索DP:f[x]&#x3D;max(dp(x-1)+1,dp(x+1)+1)\"></a>—135.分发糖果  &gt;&#x3D;1&#x2F;person min_sum 记忆化搜索DP:f[x]&#x3D;max(dp(x-1)+1,dp(x+1)+1)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;---135.分发糖果  &gt;&#x3D;1&#x2F;person min_sum 记忆化搜索DP:f[x]&#x3D;max(dp(x-1)+1,dp(x+1)+1)\n&#x2F;&#x2F;题解s：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;2505&#x2F;1&#x2F;\n&#x2F;&#x2F;正f反g两次扫描~ max(f,g)\n&#x2F;&#x2F;Acwing901滑雪 2Dhigh-&gt;low:max_step\n&#x2F;&#x2F;https:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;content&#x2F;description&#x2F;903&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; f;\n    vector&lt;int&gt; w;\n    int n;\n\n    int candy(vector&lt;int&gt;&amp; ratings) &#123;\n        n &#x3D; ratings.size();\n        w &#x3D; ratings;\n        f.resize(n, -1);&#x2F;&#x2F;\n\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res +&#x3D; dp(i);\n        return res;\n    &#125;\n    &#x2F;&#x2F;记忆化搜索 O(n)\n    int dp(int x) &#123;\n        if(f[x] !&#x3D; -1) return f[x];\n        f[x] &#x3D; 1;\n        if(x &amp;&amp; w[x - 1] &lt; w[x]) f[x] &#x3D; max(f[x], dp(x - 1) + 1);\n        if(x + 1 &lt; n &amp;&amp; w[x + 1] &lt; w[x]) f[x] &#x3D; max(f[x], dp(x + 1) + 1);\n        return f[x];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"136-只出现一次的数字-其余2次-x-x-x3D-0-0-x-x3D-x-全异或\"><a href=\"#136-只出现一次的数字-其余2次-x-x-x3D-0-0-x-x3D-x-全异或\" class=\"headerlink\" title=\"136.只出现一次的数字 其余2次 x^x&#x3D;0 0^x&#x3D;x 全异或\"></a>136.只出现一次的数字 其余2次 x^x&#x3D;0 0^x&#x3D;x 全异或</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; 0;\n        for(auto x: nums) res ^&#x3D; x;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"—！！！137-gt-260-只出现一次的数字II-其余3次-O-1-DFA有限状态机模型-x2F-若第i位1出现次数为3k-1，则说明答案在第i位是1\"><a href=\"#—！！！137-gt-260-只出现一次的数字II-其余3次-O-1-DFA有限状态机模型-x2F-若第i位1出现次数为3k-1，则说明答案在第i位是1\" class=\"headerlink\" title=\"—！！！137-&gt;260.只出现一次的数字II 其余3次 O(1) DFA有限状态机模型 &#x2F; 若第i位1出现次数为3k+1，则说明答案在第i位是1\"></a>—！！！137-&gt;260.只出现一次的数字II 其余3次 O(1) DFA有限状态机模型 &#x2F; 若第i位1出现次数为3k+1，则说明答案在第i位是1</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210416153406924.png\" alt=\"image-20210416153406924\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/f75d89219ad93c69757b187c64784b4c7a57dce7911884fe82f14073d654d32f-Picture4.png\" alt=\"Picture4.png\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/6ba76dba1ac98ee2bb982e011fdffd1df9a6963f157b2780461dbce453f0ded3-Picture5.png\" alt=\"Picture5.png\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;137.只出现一次的数字II 其余3次 位运算：32b并行\n&#x2F;&#x2F;有限状态机DFA: https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;single-number-ii&#x2F;solution&#x2F;single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891&#x2F;\nclass Solution &#123;\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int two &#x3D; 0, one &#x3D; 0;\n        for(auto x: nums) &#123;\n            one &#x3D; (one ^ x) &amp; ~two;\n            two &#x3D; (two ^ x) &amp; ~one;\n        &#125;\n        return one;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;若第i位1出现次数为3k+1，则说明答案在第i位是1\nclass Solution &#123;\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int ans &#x3D; 0;\n        for(int bit &#x3D; 0;bit &lt; 32;bit ++)\n        &#123;\n            int cnt &#x3D; 0;\n            for(int i &#x3D; 0;i &lt; n;i ++)\n            &#123;\n                if((nums[i] &gt;&gt; bit &amp; 1) &#x3D;&#x3D; 1) cnt ++; \n            &#125;\n            if(cnt % 3 !&#x3D; 0) ans +&#x3D; 1 &lt;&lt; bit;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n\n<p>O(N)</p>\n<p>HashSet py</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Solution:\n    def singleNumber(self, nums):\n        return (3 * sum(set(nums)) - sum(nums)) &#x2F;&#x2F; 2</code></pre>\n\n<p>HashMap py</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from collections import Counter\nclass Solution:\n    def singleNumber(self, nums):\n        hashmap &#x3D; Counter(nums)\n            \n        for k in hashmap.keys():\n            if hashmap[k] &#x3D;&#x3D; 1:\n                return k</code></pre>\n\n\n\n<h1 id=\"138-lt-133-复制带随机指针的链表-“小弟”省hash表-S-x3D-O-1\"><a href=\"#138-lt-133-复制带随机指针的链表-“小弟”省hash表-S-x3D-O-1\" class=\"headerlink\" title=\"138&lt;-133.复制带随机指针的链表 “小弟”省hash表:S&#x3D;O(1)\"></a>138&lt;-133.复制带随机指针的链表 “小弟”省hash表:S&#x3D;O(1)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210416170832852.png\" alt=\"image-20210416170832852\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    Node* copyRandomList(Node* head) &#123;\n        &#x2F;&#x2F;复制一个小弟\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next-&gt;next) &#123;\n            auto q &#x3D; new Node(p-&gt;val);\n            q-&gt;next &#x3D; p-&gt;next;\n            p-&gt;next &#x3D; q;\n        &#125;\n        &#x2F;&#x2F;复制random指针\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next-&gt;next)\n            if(p-&gt;random)\n                p-&gt;next-&gt;random &#x3D; p-&gt;random-&gt;next;\n\n        &#x2F;&#x2F;拆分两个链表\n        auto dummy &#x3D; new Node(-1), cur &#x3D; dummy;\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next) &#123;\n            auto q &#x3D; p-&gt;next;\n            cur &#x3D; cur-&gt;next &#x3D; q;\n            p-&gt;next &#x3D; q-&gt;next;\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"—139-单词拆分-类似132分割回文串II-DP优化-str-hash-f-j-x3D-f-i-amp-amp-s-i-1-j-在hash里出现过\"><a href=\"#—139-单词拆分-类似132分割回文串II-DP优化-str-hash-f-j-x3D-f-i-amp-amp-s-i-1-j-在hash里出现过\" class=\"headerlink\" title=\"—139.单词拆分(类似132分割回文串II) DP优化+str_hash f[j] &#x3D; f[i] &amp;&amp; s[i+1~j]在hash里出现过\"></a>—139.单词拆分(类似132分割回文串II) DP优化+str_hash f[j] &#x3D; f[i] &amp;&amp; s[i+1~j]在hash里出现过</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210416173731215.png\" alt=\"image-20210416173731215\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;类似132分割回文串II DP优化\n&#x2F;*\n《judge str在字典里出现过》\nunordered_set&lt;string&gt; CURD:O(n)\ns.substr  T&#x3D;O(n^3)\n\nT&#x3D;O(n^2) 我们一共有 O(n) 个状态需要计算，每次计算需要枚举 O(n) 个分割点，\n哈希表判断一个字符串是否出现在给定的字符串列表需要 O(1) 的时间。\n优化为O(1)：trie KMP str_hash(Acwing 841)\n*&#x2F;\n&#x2F;&#x2F;正推\nclass Solution &#123;\npublic:\n\tbool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n\t\ttypedef unsigned long long ULL;&#x2F;&#x2F;&#x3D;&#x3D;%2^64\n\t\tunordered_set&lt;ULL&gt; hash;\n\t\tconst int P &#x3D; 131;&#x2F;&#x2F;\n\t\tfor(auto&amp; word: wordDict) &#123;\n\t\t\tULL h &#x3D; 0;\n\t\t\tfor(auto c: word) h &#x3D; h * P + c;\n\t\t\thash.insert(h);\n\t\t&#125;\n\n\t\tint n &#x3D; s.size();\n\t\t&#x2F;&#x2F;f[i]&#x3D;dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[1~i] 是否能被空格拆分成若干个字典中出现的单词。\n\t\tvector&lt;bool&gt; f(n + 1);\n\t\tf[0] &#x3D; true;\n\t\ts &#x3D; &#39; &#39; + s;&#x2F;&#x2F;s[1]开始\n\t\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t\t\tif(f[i]) &#123;&#x2F;&#x2F;f[j] &#x3D; f[i] &amp;&amp; s[i+1~j]在hash里出现过\n\t\t\t\tULL h &#x3D; 0;\n\t\t\t\t&#x2F;&#x2F;s[i+1~j]在hash里出现过 cur_state-&gt;?state\n\t\t\t\tfor(int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\t\t\th &#x3D; h * P + s[j]; &#x2F;&#x2F;s[1]开始\n\t\t\t\t\tif(hash.count(h)) f[j] &#x3D; true;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\treturn f[n];\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;逆推\nclass Solution &#123;\npublic:\n\tbool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n\t\ttypedef unsigned long long ULL;\n\t\tunordered_set&lt;ULL&gt; hash;\n\t\tconst int P &#x3D; 131;&#x2F;&#x2F;\n\t\tfor(auto&amp; word: wordDict) &#123;\n\t\t\tULL h &#x3D; 0;\n\t\t\tfor(auto c: word) h &#x3D; h * P + c;\n\t\t\thash.insert(h);\n\t\t&#125;\n\n\t\tint n &#x3D; s.size();\n\t\t&#x2F;&#x2F;f[i]&#x3D;dp[i] 表示字符串 s[i~n-1] 是否能被空格拆分成若干个字典中出现的单词。\n\t\tvector&lt;bool&gt; f(n + 1);\n\t\tf[n] &#x3D; true;\n\n\t\tfor(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;\n\t\t\tULL h &#x3D; 0;\n\t\t\tfor(int j &#x3D; i; j &lt; n; j++) &#123;\n\t\t\t\th &#x3D; h * P + s[j];\n\t\t\t\tif(hash.count(h) &amp;&amp; f[j + 1]) &#123;\n\t\t\t\t\tf[i] &#x3D; true;&#x2F;&#x2F;f[i] &#x3D; f[j+1] &amp;&amp; s[i~j]出现在hash中\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\treturn f[0];\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"—140-单词拆分II-cases-DP预处理f-dfs递归\"><a href=\"#—140-单词拆分II-cases-DP预处理f-dfs递归\" class=\"headerlink\" title=\"—140.单词拆分II cases:DP预处理f+dfs递归\"></a>—140.单词拆分II cases:DP预处理f+dfs递归</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;逆推\nclass Solution &#123;\npublic:\n\tvector&lt;bool&gt; f;\n\tvector&lt;string&gt; ans;\n\tunordered_set&lt;string&gt; hash;\n\tint n;\n\n\tvector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n\t\tfor(auto word: wordDict) hash.insert(word);&#x2F;&#x2F;瓶颈变为cases:O(2^n),O(n^3)不用优化了\n\n\t\tn &#x3D; s.size();\n\t\tf.resize(n + 1);\n\t\t&#x2F;&#x2F;f[i]&#x3D;dp[i] 表示字符串 s[i~n-1] 是否能被空格拆分成若干个字典中出现的单词。\n\t\tf[n] &#x3D; true;\n\t\t&#x2F;&#x2F;DP预处理f\n\t\tfor(int i &#x3D; n - 1; ~i; i--)\n\t\t\tfor(int j &#x3D; i; j &lt; n; j++)\n\t\t\t\tif(hash.count(s.substr(i, j - i + 1)) &amp;&amp; f[j + 1]) &#123;\n\t\t\t\t\tf[i] &#x3D; true;&#x2F;&#x2F;f[i] &#x3D; s[i~j]出现在hash中 &amp;&amp; f[j+1]\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\tdfs(s, 0, &quot;&quot;);\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(string&amp; s, int u, string path) &#123;\n\t\tif(u &#x3D;&#x3D; n) &#123;\n\t\t\tpath.pop_back();&#x2F;&#x2F;去&#39; &#39;\n\t\t\tans.push_back(path);\n\t\t&#125; else &#123;\n\t\t\tfor(int i &#x3D; u; i &lt; n; i++)\n\t\t\t\tif(hash.count(s.substr(u, i - u + 1)) &amp;&amp; f[i + 1])&#x2F;&#x2F;s[u~i]\n\t\t\t\t\tdfs(s, i + 1, path + s.substr(u, i - u + 1) + &#39; &#39;);\n\t\t&#125;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"141-环形链表-S-x3D-O-1-快慢指针-先next后判空\"><a href=\"#141-环形链表-S-x3D-O-1-快慢指针-先next后判空\" class=\"headerlink\" title=\"141.环形链表 S&#x3D;O(1)快慢指针 先next后判空\"></a>141.环形链表 S&#x3D;O(1)快慢指针 先next后判空</h1><p>不可能有连续环，因为会有分叉即2个next_ptr</p>\n<p>hash表：adr判重</p>\n<p>但要求S&#x3D;O(1)：故使用 ！快慢指针！2步1步[如果有环，保证能遇上不错过] 相遇有环 ！！！先next后判空！！！</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool hasCycle(ListNode *head) &#123;\n        if(!head || !head-&gt;next) return false;\n        auto s &#x3D; head, f &#x3D; head-&gt;next;\n        while(f) &#123;&#x2F;&#x2F;\n            s &#x3D; s-&gt;next, f &#x3D; f-&gt;next;&#x2F;&#x2F;slow+1\n            if(!f) return false;&#x2F;&#x2F;NULL\n            f &#x3D; f-&gt;next;&#x2F;&#x2F;fast+2\n            if(s &#x3D;&#x3D; f) return true;&#x2F;&#x2F;相遇有环\n        &#125;\n        return false;&#x2F;&#x2F;NULL\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"142-环形链表II-环入口-相遇点c-x步-x3D-入口b\"><a href=\"#142-环形链表II-环入口-相遇点c-x步-x3D-入口b\" class=\"headerlink\" title=\"142.环形链表II 环入口 相遇点c+x步&#x3D;入口b\"></a>142.环形链表II 环入口 相遇点c+x步&#x3D;入口b</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210417111844631.png\" alt=\"image-20210417111844631\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;hash表\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        unordered_set&lt;ListNode *&gt; visited;\n        while (head !&#x3D; nullptr) &#123;\n            if (visited.count(head)) &#123;\n                return head;\n            &#125;\n            visited.insert(head);\n            head &#x3D; head-&gt;next;\n        &#125;\n        return nullptr;\n    &#125;\n&#125;;\n\n作者：LeetCode-Solution\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;linked-list-cycle-ii&#x2F;solution&#x2F;huan-xing-lian-biao-ii-by-leetcode-solution&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;相遇点c+x步&#x3D;入口b  f&#x3D;f-&gt;next是因为init时f&#x3D;head-&gt;next; 1+环3 纸上模拟！\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        if(!head || !head-&gt;next) return NULL;\n        auto s &#x3D; head, f &#x3D; head-&gt;next;\n        while(f) &#123;&#x2F;&#x2F;\n            s &#x3D; s-&gt;next, f &#x3D; f-&gt;next;&#x2F;&#x2F;slow+1\n            if(!f) return NULL;\n            f &#x3D; f-&gt;next;&#x2F;&#x2F;fast+2\n            if(s &#x3D;&#x3D; f) &#123;\n                s &#x3D; head, f &#x3D; f-&gt;next;&#x2F;&#x2F;f &#x3D; f-&gt;next是因为init时f&#x3D;head-&gt;next;\n                while(s !&#x3D; f) s &#x3D; s-&gt;next, f &#x3D; f-&gt;next;\n                return s;\n            &#125;\n        &#125;\n        return NULL;\n\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"—143-重排链表-找链表中点-链表逆序-合并链表-T-x3D-O-n-S-x3D-O-1-细节多！\"><a href=\"#—143-重排链表-找链表中点-链表逆序-合并链表-T-x3D-O-n-S-x3D-O-1-细节多！\" class=\"headerlink\" title=\"—143.重排链表 找链表中点!+ 链表逆序 + 合并链表 T&#x3D;O(n) S&#x3D;O(1) 细节多！\"></a>—143.重排链表 找链表中点!+ 链表逆序 + 合并链表 T&#x3D;O(n) S&#x3D;O(1) 细节多！</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;reorder-list&#x2F;solution&#x2F;zhong-pai-lian-biao-by-leetcode-solution&#x2F;\n&#x2F;&#x2F;(1)线性表重建\n&#x2F;&#x2F;(2)寻找链表中点 + 链表逆序 + 合并链表 T&#x3D;O(n) S&#x3D;O(1)\nclass Solution &#123;\npublic:\n    void reorderList(ListNode* head) &#123;\n        if (head &#x3D;&#x3D; nullptr) &#123;\n            return;\n        &#125;\n        ListNode* mid &#x3D; middleNode(head);\n        ListNode* l1 &#x3D; head;\n        ListNode* l2 &#x3D; mid-&gt;next;\n        mid-&gt;next &#x3D; nullptr;\n        l2 &#x3D; reverseList(l2);\n        mergeList(l1, l2);\n    &#125;\n    &#x2F;&#x2F;快慢指针\n    ListNode* middleNode(ListNode* head) &#123;\n        ListNode* slow &#x3D; head;\n        ListNode* fast &#x3D; head;\n        while (fast-&gt;next !&#x3D; nullptr &amp;&amp; fast-&gt;next-&gt;next !&#x3D; nullptr) &#123;\n            slow &#x3D; slow-&gt;next;\n            fast &#x3D; fast-&gt;next-&gt;next;\n        &#125;\n        return slow;\n    &#125;\n\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode* prev &#x3D; nullptr;\n        ListNode* curr &#x3D; head;\n        while (curr !&#x3D; nullptr) &#123;\n            ListNode* nextTemp &#x3D; curr-&gt;next;\n            curr-&gt;next &#x3D; prev;\n            prev &#x3D; curr;\n            curr &#x3D; nextTemp;\n        &#125;\n        return prev;\n    &#125;\n\n    void mergeList(ListNode* l1, ListNode* l2) &#123;\n        ListNode* l1_tmp;\n        ListNode* l2_tmp;\n        while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;\n            l1_tmp &#x3D; l1-&gt;next;\n            l2_tmp &#x3D; l2-&gt;next;\n\n            l1-&gt;next &#x3D; l2;\n            l1 &#x3D; l1_tmp;\n\n            l2-&gt;next &#x3D; l1;\n            l2 &#x3D; l2_tmp;\n        &#125;\n    &#125;\n&#125;;\n\n作者：LeetCode-Solution\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;reorder-list&#x2F;solution&#x2F;zhong-pai-lian-biao-by-leetcode-solution&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;240&#x2F;\nclass Solution &#123;\npublic:\n    void reorderList(ListNode* head) &#123;\n        if(!head) return;\n        int n &#x3D; 0;\n        for (auto p &#x3D; head; p; p &#x3D; p-&gt;next) n ++ ;\n        \n        auto mid &#x3D; head;\n        for (int i &#x3D; 0; i + 1 &lt; (n + 1) &#x2F; 2; i ++ )\n            mid &#x3D; mid-&gt;next;\n        auto a &#x3D; mid, b &#x3D; a-&gt;next;\n\n        while (b) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a, a &#x3D; b, b &#x3D; c;\n        &#125;\n\n        mid-&gt;next &#x3D; 0;\n        while (head &amp;&amp; head !&#x3D; a) &#123;\n            b &#x3D; a-&gt;next;\n            a-&gt;next &#x3D; head-&gt;next;\n            head-&gt;next &#x3D; a;\n            head &#x3D; head-&gt;next-&gt;next;\n            a &#x3D; b;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;直播2\nclass Solution &#123;\npublic:\n    void reorderList(ListNode* head) &#123;\n        if(!head) return;\n        int n &#x3D; 0;\n        for (auto p &#x3D; head; p; p &#x3D; p-&gt;next) n ++ ;\n        \n        auto mid &#x3D; head;\n        for (int i &#x3D; 0; i + 1 &lt; (n + 1) &#x2F; 2; i ++ )\n            mid &#x3D; mid-&gt;next;\n        auto a &#x3D; mid, b &#x3D; a-&gt;next;\n\n        while (b) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a, a &#x3D; b, b &#x3D; c;\n        &#125;\n\n        auto p &#x3D; head, q &#x3D; a;\n        for(int i &#x3D; 0; i &lt; n &#x2F; 2; i++) &#123;\n        \tauto o &#x3D; q-&gt;next;\n        \tq-&gt;next &#x3D; p-&gt;next;\n        \tp-&gt;next &#x3D; q;\n        \tif(n % 2 &#x3D;&#x3D; 0 &amp;&amp; i &#x3D;&#x3D; n &#x2F; 2 - 1) q-&gt;next &#x3D; NULL;&#x2F;&#x2F;偶\n        \tp &#x3D; q-&gt;next, q &#x3D; o;\n        &#125;\n        if(n % 2) p-&gt;next &#x3D; NULL;&#x2F;&#x2F;奇\n    &#125;\n&#125;;\n&#x2F;&#x2F;直播1（备课）：</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210417121416129.png\" alt=\"image-20210417121416129\"></p>\n<h1 id=\"144-二叉树的前序遍历-94-中序\"><a href=\"#144-二叉树的前序遍历-94-中序\" class=\"headerlink\" title=\"144. 二叉树的前序遍历 (94.中序)\"></a>144. 二叉树的前序遍历 (94.中序)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; ans;\n\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;\n        dfs(root);\n        return ans;\n    &#125;\n\n    void dfs(TreeNode* root) &#123;\n        if(!root) return;\n        ans.push_back(root-&gt;val);\n        dfs(root-&gt;left);\n        dfs(root-&gt;right);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;针对二叉树类型的非递归版\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;TreeNode*&gt; st;\n\n        auto p &#x3D; root;\n\n        while (p || !st.empty()) &#123;\n            while (p) &#123;\n            \tres.push_back(p-&gt;val);&#x2F;&#x2F;\n                st.push(p);\n                p &#x3D; p-&gt;left;\n            &#125;\n            p &#x3D; st.top()-&gt;right;\n            st.pop();\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"145-二叉树的后序遍历-LRN-x3D-x3D-NRL-reverse-【转化！】为144题\"><a href=\"#145-二叉树的后序遍历-LRN-x3D-x3D-NRL-reverse-【转化！】为144题\" class=\"headerlink\" title=\"145. 二叉树的后序遍历   LRN&#x3D;&#x3D;NRL+reverse 【转化！】为144题\"></a>145. 二叉树的后序遍历   LRN&#x3D;&#x3D;NRL+reverse 【转化！】为144题</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;针对二叉树类型的非递归版\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;TreeNode*&gt; st;\n\n        auto p &#x3D; root;\n\n        while (p || !st.empty()) &#123;\n            while (p) &#123;\n            \tres.push_back(p-&gt;val);&#x2F;&#x2F;\n                st.push(p);\n                p &#x3D; p-&gt;right;&#x2F;&#x2F;\n            &#125;\n            p &#x3D; st.top()-&gt;left;&#x2F;&#x2F;\n            st.pop();\n        &#125;\n        reverse(res.begin(), res.end());\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"—！！！146-LRU-缓存机制-T-x3D-O-1-remove-insert到L-gt-right-双链表-hash\"><a href=\"#—！！！146-LRU-缓存机制-T-x3D-O-1-remove-insert到L-gt-right-双链表-hash\" class=\"headerlink\" title=\"—！！！146. LRU 缓存机制 T&#x3D;O(1)remove+insert到L-&gt;right:双链表+hash\"></a>—！！！146. LRU 缓存机制 T&#x3D;O(1)remove+insert到L-&gt;right:双链表+hash</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210417154402913.png\" alt=\"image-20210417154402913\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;双链表O(1)remove left! 左边新右边旧\nclass LRUCache &#123;\npublic:\n    struct Node &#123;\n        int key, val;\n        Node *left, *right;\n        Node(int _key, int _val): key(_key), val(_val), left(NULL), right(NULL) &#123;&#125;\n    &#125;*L, *R;\n    unordered_map&lt;int, Node*&gt; hash;&#x2F;&#x2F;\n    int n;\n\n    LRUCache(int capacity) &#123;\n        n &#x3D; capacity;\n        L &#x3D; new Node(-1, -1), R &#x3D; new Node(-1, -1);\n        L-&gt;right &#x3D; R, R-&gt;left &#x3D; L;\n    &#125;\n\n    void remove(Node* p) &#123;\n        p-&gt;right-&gt;left &#x3D; p-&gt;left;\n        p-&gt;left-&gt;right &#x3D; p-&gt;right;\n    &#125;\n\n    void insert(Node* p) &#123;\n        p-&gt;right &#x3D; L-&gt;right;\n        p-&gt;left &#x3D; L;\n        L-&gt;right-&gt;left &#x3D; p;\n        L-&gt;right &#x3D; p;\n    &#125;\n\n    int get(int key) &#123;\n        if(!hash.count(key)) return -1;\n        auto p &#x3D; hash[key];\n        remove(p);\n        insert(p);\n        return p-&gt;val;&#x2F;&#x2F;\n    &#125;\n    \n    void put(int key, int value) &#123;\n        if(hash.count(key)) &#123;\n            auto p &#x3D; hash[key];\n            p-&gt;val &#x3D; value;&#x2F;&#x2F;\n            remove(p);\n            insert(p); \n        &#125; else &#123;\n            if(hash.size() &#x3D;&#x3D; n) &#123;\n                auto p &#x3D; R-&gt;left;\n                remove(p);&#x2F;&#x2F;双链表删\n                hash.erase(p-&gt;key);&#x2F;&#x2F;hash表删\n                delete p;&#x2F;&#x2F;引用删\n            &#125;\n            auto p &#x3D; new Node(key, value);\n            hash[key] &#x3D; p;\n            insert(p);\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"147-对链表进行插入排序-cur-x2F-p-x2F-cur-gt-next-first-gt-p-O-n-2\"><a href=\"#147-对链表进行插入排序-cur-x2F-p-x2F-cur-gt-next-first-gt-p-O-n-2\" class=\"headerlink\" title=\"147.对链表进行插入排序 cur&#x2F;p&#x2F;cur-&gt;next(first &gt;p) O(n^2)\"></a>147.对链表进行插入排序 cur&#x2F;p&#x2F;cur-&gt;next(first &gt;p) O(n^2)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* insertionSortList(ListNode* head) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        for(auto p &#x3D; head; p;) &#123;\n            auto cur &#x3D; dummy, next &#x3D; p-&gt;next;&#x2F;&#x2F;备份next\n            while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &lt;&#x3D; p-&gt;val) cur &#x3D; cur-&gt;next;&#x2F;&#x2F;\n            p-&gt;next &#x3D; cur-&gt;next;\n            cur-&gt;next &#x3D; p;\n            p &#x3D; next;&#x2F;&#x2F;\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"148-排序链表【最难链表题】-T-x3D-O-nlogn-S-x3D-O-1-自底向上归并mergesort-细节多-（23）\"><a href=\"#148-排序链表【最难链表题】-T-x3D-O-nlogn-S-x3D-O-1-自底向上归并mergesort-细节多-（23）\" class=\"headerlink\" title=\"148.排序链表【最难链表题】 T&#x3D;O(nlogn) S&#x3D;O(1):自底向上归并mergesort 细节多 （23）\"></a>148.排序链表【最难链表题】 T&#x3D;O(nlogn) S&#x3D;O(1):自底向上归并mergesort 细节多 （23）</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210417164344519.png\" alt=\"image-20210417164344519\"></p>\n<p>堆排序：数组O(nlogn)，链表不能用堆！！！</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;最适合链表的排序算法是归并排序。基于分治,S&#x3D;O(1)自底向上递推。\n&#x2F;&#x2F;148.排序链表 T&#x3D;O(nlogn) S&#x3D;O(1):自底向上归并mergesort\n&#x2F;&#x2F;堆排序：数组O(nlogn)，链表不能用堆！！！\n&#x2F;&#x2F;最适合链表的排序算法是归并排序。基于分治,S&#x3D;O(1)自底向上递推。\nclass Solution &#123;\npublic:\n    ListNode* sortList(ListNode* head) &#123;\n        &#x2F;&#x2F;很不熟练，利用自底向上的归并思想，每次先归并好其中一小段，之后对两小段之间进行归并\n        int n &#x3D; 0;\n        for(auto p &#x3D; head; p ; p &#x3D; p-&gt;next) n ++;\n\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n\n        for(int i &#x3D; 1; i &lt; n; i *&#x3D; 2 )&#123; &#x2F;&#x2F;每次归并段的长度，每次长度依次为1,2,4,8...n&#x2F;2\n        &#x2F;&#x2F;小于n是因为等于n时说明所有元素均归并完毕，大于n时同理\n            auto cur &#x3D; dummy;\n            for(int j &#x3D; 1; j + i &lt;&#x3D; n; j +&#x3D; 2 * i)&#123;&#x2F;&#x2F;j代表每一段的开始，每次将两段有序段归并为一个大的有序段，故而每次+2i\n            &#x2F;&#x2F;必须保证每段中间序号是小于链表长度的，显然，如果大于表长，就没有元素可以归并了\n                auto p &#x3D; cur-&gt;next,q &#x3D; p;&#x2F;&#x2F;p表示第一段的起始点，q表示第二段的起始点，之后开始归并即可\n                for(int k &#x3D; 0; k &lt; i; k ++) q &#x3D; q-&gt;next;\n                &#x2F;&#x2F;归并排序基本套路\n                &#x2F;&#x2F;x,y用于计数第一段和第二段归并的节点个数，由于当链表长度非2的整数倍时表长会小于i,故而需要加上p &amp;&amp; q的边界判断\n                 int x &#x3D; 0, y &#x3D; 0;\n                 while(x &lt; i &amp;&amp; y &lt; i &amp;&amp; p &amp;&amp; q)&#123;\n                     if(p-&gt;val &lt;&#x3D; q-&gt;val) cur &#x3D; cur-&gt;next &#x3D; p,p &#x3D; p-&gt;next,x ++;\n                     else cur &#x3D; cur-&gt;next &#x3D; q,q &#x3D; q-&gt;next,y++;\n                 &#125;\n                 while(x &lt; i &amp;&amp; p) cur &#x3D; cur-&gt;next &#x3D; p,p &#x3D; p-&gt;next,x ++;\n                 while(y &lt; i &amp;&amp; q) cur &#x3D; cur-&gt;next &#x3D; q,q &#x3D; q-&gt;next,y ++;\n                 cur-&gt;next &#x3D; q; &#x2F;&#x2F;记得把排好序的链表尾链接到下一链表的表头，循环完毕后q为下一链表表头\n            &#125;\n        &#125; \n        return dummy-&gt;next;\n    &#125;\n&#125;;\n</code></pre>\n\n<ol start=\"2\">\n<li>（23题 Java）DP向上 【链表模拟每层merge】（用于148题：排序链表）</li>\n</ol>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210522094037769.png\" alt=\"image-20210522094037769\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210522094121807.png\" alt=\"image-20210522094121807\"></p>\n<h1 id=\"149-直线上最多的点数-枚举中心点-重叠中心点-垂线-LD\"><a href=\"#149-直线上最多的点数-枚举中心点-重叠中心点-垂线-LD\" class=\"headerlink\" title=\"149.直线上最多的点数 枚举中心点 重叠中心点 垂线 LD\"></a>149.直线上最多的点数 枚举中心点 重叠中心点 垂线 LD</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        typedef long double LD;\n\n        int res &#x3D; 0;\n        for(auto&amp; p: points) &#123;&#x2F;&#x2F;枚举中心点\n            int ss &#x3D; 0, vs &#x3D; 0;\n            unordered_map&lt;LD, int&gt; cnt;\n            for(auto&amp; q: points)\n                if(p &#x3D;&#x3D; q) ss ++;&#x2F;&#x2F;重叠中心点\n                else if(p[0] &#x3D;&#x3D; q[0]) vs++;&#x2F;&#x2F;垂线\n                else &#123;\n                    LD k &#x3D; (LD)(q[1] - p[1]) &#x2F; (q[0] - p[0]);\n                    cnt[k]++;\n                &#125;\n            int c &#x3D; vs;\n            for(auto [k, t]: cnt) c &#x3D; max(c, t);\n            res &#x3D; max(res, c + ss);&#x2F;&#x2F;+中心点\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;分数 更精确\nclass Solution &#123;\npublic:\n    int gcd(int x,int y)\n    &#123;\n        if(y &#x3D;&#x3D; 0)\n            return x;\n        return gcd(y,x % y);\n    &#125;\n    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        int n &#x3D; points.size();\n        if(n &lt; 3) return n;\n        int res &#x3D; 1;\n        for(int i &#x3D; 0 ; i &lt; n ; i ++)\n        &#123;\n            int r &#x3D; points[i][0],c &#x3D; points[i][1];\n            unordered_map&lt;string,int&gt; hash;\n            int vertical &#x3D; 0,duplicate &#x3D; 0;\n            for(int j &#x3D; i + 1 ; j &lt; n ; j ++)\n            &#123;\n                if(points[j][0] &#x3D;&#x3D; points[i][0])\n                &#123;\n                    vertical ++;\n                    if(points[j][1] &#x3D;&#x3D; points[i][1])\n                        duplicate ++;\n                &#125;\n            &#125;\n            for(int j &#x3D; i + 1 ; j &lt; n ; j ++)\n            &#123;\n                if(points[j][0] !&#x3D; points[i][0])\n                &#123;\n                    int x &#x3D; points[j][0],y &#x3D; points[j][1],com &#x3D; gcd(y - c,x - r);\n                    string key &#x3D; to_string( (y - c) &#x2F; com) + &quot;&#x2F;&quot; + to_string((x - r) &#x2F; com);\n                    hash[key] ++;\n                &#125;\n            &#125;\n          &#x2F;&#x2F;    需要加上重复的点以及固定点\n            for(auto&amp; it : hash)\n                res &#x3D; max(res,it.second + duplicate + 1);\n          &#x2F;&#x2F;    需要加上固定点\n            res &#x3D; max(res,vertical + 1);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n作者：T-SHLoRk\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;5695&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"150-逆波兰表达式求值-stk-stoi-s-atoi-t-c-str\"><a href=\"#150-逆波兰表达式求值-stk-stoi-s-atoi-t-c-str\" class=\"headerlink\" title=\"150.逆波兰表达式求值 stk stoi(s)   atoi(t.c_str())\"></a>150.逆波兰表达式求值 stk stoi(s)   atoi(t.c_str())</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;\n        stack&lt;int&gt; sta;\n        for (auto &amp;t : tokens)\n            if (t &#x3D;&#x3D; &quot;+&quot; || t &#x3D;&#x3D; &quot;-&quot; || t &#x3D;&#x3D; &quot;*&quot; || t &#x3D;&#x3D; &quot;&#x2F;&quot;)\n            &#123;\n                int b &#x3D; sta.top();\n                sta.pop();\n                int a &#x3D; sta.top();\n                sta.pop();\n                if (t &#x3D;&#x3D; &quot;+&quot;) sta.push(a + b);\n                else if (t &#x3D;&#x3D; &quot;-&quot;) sta.push(a - b);\n                else if (t &#x3D;&#x3D; &quot;*&quot;) sta.push(a * b);\n                else sta.push(a &#x2F; b);\n            &#125;\n            else sta.push(atoi(t.c_str()));&#x2F;&#x2F;\n        return sta.top();\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;写法2\nclass Solution &#123;\npublic:\n\tstack&lt;int&gt; stk;\n\tvoid eval(string s) &#123;\n        int b &#x3D; stk.top();\n        stk.pop();\n        int a &#x3D; stk.top();\n        stk.pop();\n        if (s &#x3D;&#x3D; &quot;+&quot;) stk.push(a + b);\n        else if (s &#x3D;&#x3D; &quot;-&quot;) stk.push(a - b);\n        else if (s &#x3D;&#x3D; &quot;*&quot;) stk.push(a * b);\n        else stk.push(a &#x2F; b);\n    &#125;\n\n    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;\n        unordered_set&lt;string&gt; S&#123;&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;&#x2F;&quot;&#125;;\n        for (auto&amp; s: tokens)\n            if(S.count(s)) eval(s);\n            else stk.push(stoi(s));&#x2F;&#x2F;\n        return stk.top();\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"151-翻转字符串里的单词-翻词-翻串-S-x3D-O-1-原地cover\"><a href=\"#151-翻转字符串里的单词-翻词-翻串-S-x3D-O-1-原地cover\" class=\"headerlink\" title=\"151.翻转字符串里的单词 翻词+翻串 S&#x3D;O(1)原地cover\"></a>151.翻转字符串里的单词 翻词+翻串 S&#x3D;O(1)原地cover</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string reverseWords(string s) &#123;\n        int k &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(s[i] &#x3D;&#x3D; &#39; &#39;) continue;&#x2F;&#x2F;跳过(多个)空格\n            int j &#x3D; i, t &#x3D; k;&#x2F;&#x2F;i~j--原地cover--&gt;k~t\n            while(j &lt; s.size() &amp;&amp; s[j] !&#x3D; &#39; &#39;) s[t++] &#x3D; s[j++];\n            reverse(s.begin() + k, s.begin() + t);&#x2F;&#x2F;1.翻词\n            s[t++] &#x3D; &#39; &#39;;\n            i &#x3D; j, k &#x3D; t;&#x2F;&#x2F;更新起点\n        &#125;\n        if(k) k--;\n        s.erase(s.begin() + k, s.end());&#x2F;&#x2F;删&#39; &#39;+&#39; &#39;\n        reverse(s.begin(), s.end());&#x2F;&#x2F;2.翻串\n        return s;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"152-乘积最大子数组-负-负-x3D-正-T-x3D-O-n-S-x3D-O-1-滚动！M-f-fa-m-g-ga\"><a href=\"#152-乘积最大子数组-负-负-x3D-正-T-x3D-O-n-S-x3D-O-1-滚动！M-f-fa-m-g-ga\" class=\"headerlink\" title=\"152.乘积最大子数组 负*负&#x3D;正 T&#x3D;O(n) S&#x3D;O(1)滚动！M:f-fa m:g-ga\"></a>152.乘积最大子数组 负*负&#x3D;正 T&#x3D;O(n) S&#x3D;O(1)滚动！M:f-fa m:g-ga</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210423145154190.png\" alt=\"image-20210423145154190\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; nums[0];\n        int f &#x3D; nums[0], g &#x3D; nums[0];\n        for(int i &#x3D; 1; i &lt; nums.size(); i++) &#123;\n            int a &#x3D; nums[i], fa &#x3D; f * a, ga &#x3D; g * a;\n            f &#x3D; max(a, max(fa, ga));\n            g &#x3D; min(a, min(fa, ga));\n            res &#x3D; max(res, f);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"153-寻找旋转排序数组中的最小值（33简化-二分一次）\"><a href=\"#153-寻找旋转排序数组中的最小值（33简化-二分一次）\" class=\"headerlink\" title=\"153.寻找旋转排序数组中的最小值（33简化 二分一次）\"></a>153.寻找旋转排序数组中的最小值（33简化 二分一次）</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int findMin(vector&lt;int&gt;&amp; nums) &#123;\n        int l &#x3D; 0, r &#x3D; nums.size() - 1;\n        if(nums[r] &gt;&#x3D; nums[l]) return nums[0];\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if(nums[mid] &lt; nums[0]) r &#x3D; mid;&#x2F;&#x2F;\n            else l &#x3D; mid + 1;\n        &#125;\n        return nums[r];\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"154-寻找旋转排序数组中的最小值II（33-81）有重复：删尾\"><a href=\"#154-寻找旋转排序数组中的最小值II（33-81）有重复：删尾\" class=\"headerlink\" title=\"154.寻找旋转排序数组中的最小值II（33 81）有重复：删尾\"></a>154.寻找旋转排序数组中的最小值II（33 81）有重复：删尾</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int findMin(vector&lt;int&gt;&amp; nums) &#123;\n        int l &#x3D; 0, r &#x3D; nums.size() - 1;\n        while(l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[0]) r--;&#x2F;&#x2F;\n        if(nums[r] &gt;&#x3D; nums[l]) return nums[0];\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if(nums[mid] &lt; nums[0]) r &#x3D; mid;&#x2F;&#x2F;\n            else l &#x3D; mid + 1;\n        &#125;\n        return nums[r];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"155-最小栈\"><a href=\"#155-最小栈\" class=\"headerlink\" title=\"155.最小栈\"></a>155.最小栈</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210423154749666.png\" alt=\"image-20210423154749666\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;155.最小栈 2栈+鸡肋优化\nclass MinStack &#123;\npublic:\n    &#x2F;** initialize your data structure here. *&#x2F;\n    stack&lt;int&gt; stk, f;\n    MinStack() &#123;\n\n    &#125;\n    \n    void push(int x) &#123;\n        stk.push(x);\n        if(f.empty() || f.top() &gt;&#x3D; x) f.push(x);\n    &#125;\n    \n    void pop() &#123;\n        if(stk.top() &lt;&#x3D; f.top()) f.pop();\n        stk.pop();\n    &#125;\n    \n    int top() &#123;\n        return stk.top();\n    &#125;\n    \n    int getMin() &#123;\n        return f.top();\n    &#125;\n&#125;;\n\n\nclass MinStack &#123;\npublic:\n    &#x2F;** initialize your data structure here. *&#x2F;\n    MinStack() &#123;\n    &#125;\n    \n    void push(int x) &#123;\n        if (st.size() &#x3D;&#x3D; 0) &#123;\n            st.push(&#123;x, x&#125;);\n        &#125; else &#123;\n            st.push(&#123;x, min(x, st.top().second)&#125;);\n        &#125;\n    &#125;\n    \n    void pop() &#123;\n        st.pop();\n    &#125;\n    \n    int top() &#123;\n        return st.top().first;\n    &#125;\n    \n    int getMin() &#123;\n        return st.top().second;\n    &#125;\nprivate:\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n&#125;;\n\n作者：fuxuemingzhu\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;min-stack&#x2F;solution&#x2F;zui-yi-dong-yi-ge-zhan-tong-shi-bao-cun-dang-qian-&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;一个栈： https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;6720&#x2F;</code></pre>\n\n\n\n<h1 id=\"156\"><a href=\"#156\" class=\"headerlink\" title=\"156.\"></a>156.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"157\"><a href=\"#157\" class=\"headerlink\" title=\"157.\"></a>157.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"158\"><a href=\"#158\" class=\"headerlink\" title=\"158.\"></a>158.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"159\"><a href=\"#159\" class=\"headerlink\" title=\"159.\"></a>159.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"160-相交链表-交换遍历到相遇-x3D-first交点\"><a href=\"#160-相交链表-交换遍历到相遇-x3D-first交点\" class=\"headerlink\" title=\"160.相交链表 交换遍历到相遇&#x3D;first交点\"></a>160.相交链表 交换遍历到相遇&#x3D;first交点</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210423162747249.png\" alt=\"image-20210423162747249\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        auto p &#x3D; headA, q &#x3D; headB;\n        while(p !&#x3D; q) &#123;\n            p &#x3D; p ? p-&gt;next : headB;&#x2F;&#x2F;\n            q &#x3D; q ? q-&gt;next : headA;\n        &#125;\n        return p;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"Locked！161-One-Edit-Distance-判断它们的编辑距离是否为1。\"><a href=\"#Locked！161-One-Edit-Distance-判断它们的编辑距离是否为1。\" class=\"headerlink\" title=\"Locked！161. One Edit Distance 判断它们的编辑距离是否为1。\"></a>Locked！161. One Edit Distance 判断它们的编辑距离是否为1。</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\nO(n)\n分三种情况考虑：\n1.字符串长度之差大于1，则编辑距离一定大于1，返回false；\n2.字符串长度相等，则有且只有一个字符不同时，才返回true；\n3.字符串长度差1，则只需判断短字符串是否是长字符串的子序列即可：\n 用指针 i 指向短字符串开头(不妨设短字符串是 s，长字符串是 t)，然后扫描长字符串，\n 如果当前字符等于 s[i]，则令 i 加1。如果最终 i 能遍历完 s，则 s 就是 t 的子序列；\n*&#x2F;\nclass Solution &#123;\npublic:\n    bool isOneEditDistance(string s, string t) &#123;\n        if (s.size() &gt; t.size()) swap(s, t);\n        if (s.size() + 1 &lt; t.size()) return false;\n        if (s.size() &#x3D;&#x3D; t.size())\n        &#123;\n            int res &#x3D; 0;\n            for (int i &#x3D; 0; i &lt; s.size(); i ++ ) res +&#x3D; s[i] !&#x3D; t[i];\n            return res &#x3D;&#x3D; 1;\n        &#125;\n        int k &#x3D; 0;\n        for (int i &#x3D; 0; k &lt; s.size() &amp;&amp; i &lt; t.size(); i ++ )\n            if (t[i] &#x3D;&#x3D; s[k])\n                k ++ ;\n        return k &#x3D;&#x3D; s.size();\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;257&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"162-寻找峰值-二分\"><a href=\"#162-寻找峰值-二分\" class=\"headerlink\" title=\"162.寻找峰值 二分\"></a>162.寻找峰值 二分</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210423170208728.png\" alt=\"image-20210423170208728\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210423170148560.png\" alt=\"image-20210423170148560\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;\n        int l &#x3D; 0, r &#x3D; nums.size() - 1;\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if(nums[mid] &gt; nums[mid + 1]) r &#x3D; mid;\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"163\"><a href=\"#163\" class=\"headerlink\" title=\"163.\"></a>163.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"164-sorted-最大间距-T-x3D-S-x3D-O-n-基数排序-分桶法\"><a href=\"#164-sorted-最大间距-T-x3D-S-x3D-O-n-基数排序-分桶法\" class=\"headerlink\" title=\"164.(sorted)最大间距 T&#x3D;S&#x3D;O(n) 基数排序 分桶法\"></a>164.(sorted)最大间距 T&#x3D;S&#x3D;O(n) 基数排序 分桶法</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210423173036521.png\" alt=\"image-20210423173036521\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;maximum-gap&#x2F;solution&#x2F;zui-da-jian-ju-by-leetcode-solution&#x2F;\n\n&#x2F;&#x2F;yxc 分桶法\nclass Solution &#123;\npublic:\n    int maximumGap(vector&lt;int&gt;&amp; nums) &#123;\n        struct Range &#123;\n            int min, max;\n            bool used;&#x2F;&#x2F;该区间有数\n            Range() : min(INT_MAX), max(INT_MIN), used(false)&#123;&#125;\n        &#125;;\n        int n &#x3D; nums.size();\n        int Min &#x3D; INT_MAX, Max &#x3D; INT_MIN;\n        for(auto x: nums) &#123;\n            Min &#x3D; min(Min, x);\n            Max &#x3D; max(Max, x);\n        &#125;\n        if(n &lt; 2 || Max &#x3D;&#x3D; Min) return 0;\n        vector&lt;Range&gt; r(n - 1);&#x2F;&#x2F;\n        int len &#x3D; (Max- Min + n -2) &#x2F; (n - 1);&#x2F;&#x2F;区间数\n        for(auto x: nums) &#123;\n            if(x &#x3D;&#x3D; Min) continue;\n            int k &#x3D; (x - Min - 1) &#x2F; len;&#x2F;&#x2F;1~x k:x所属区间\n            r[k].used &#x3D; true;\n            r[k].min &#x3D; min(r[k].min, x);\n            r[k].max &#x3D; max(r[k].max, x);\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0, last &#x3D; Min; i &lt; n - 1; i++)\n            if(r[i].used) &#123;\n                res &#x3D; max(res, r[i].min - last);\n                last &#x3D; r[i].max;\n            &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"165-比较版本号-3-1-2-gt-3-1-return-1-x2F-1-x2F-0\"><a href=\"#165-比较版本号-3-1-2-gt-3-1-return-1-x2F-1-x2F-0\" class=\"headerlink\" title=\"165.比较版本号 3.1.2 &gt; 3.1  return 1&#x2F;-1&#x2F;0\"></a>165.比较版本号 3.1.2 &gt; 3.1  return 1&#x2F;-1&#x2F;0</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int compareVersion(string v1, string v2) &#123;\n        for(int i &#x3D; 0, j &#x3D; 0; i &lt; v1.size() || j &lt; v2.size();) &#123;\n            int a &#x3D; i, b &#x3D; j;\n            while(a &lt; v1.size() &amp;&amp; v1[a] !&#x3D; &#39;.&#39;) a++;&#x2F;&#x2F;i~a-1\n            while(b &lt; v2.size() &amp;&amp; v2[b] !&#x3D; &#39;.&#39;) b++;&#x2F;&#x2F;j~b-1\n            int x &#x3D; a &#x3D;&#x3D; i ? 0 : stoi(v1.substr(i, a - i));\n            int y &#x3D; b &#x3D;&#x3D; j ? 0 : stoi(v2.substr(j, b - j));\n            if(x &gt; y) return 1;\n            if(x &lt; y) return -1;\n            i &#x3D; a + 1, j &#x3D; b + 1;&#x2F;&#x2F;jump over &#39;.&#39;\n        &#125;\n        return 0;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"166-分数到小数-有限-无限循环-循环节-INT-MIN-x2F-1-x3D-INT-MAX-1-int越界-LL！\"><a href=\"#166-分数到小数-有限-无限循环-循环节-INT-MIN-x2F-1-x3D-INT-MAX-1-int越界-LL！\" class=\"headerlink\" title=\"166.分数到小数(有限+无限循环:(循环节)) INT_MIN&#x2F;-1&#x3D;INT_MAX+1 int越界 LL！\"></a>166.分数到小数(有限+无限循环:(循环节)) INT_MIN&#x2F;-1&#x3D;INT_MAX+1 int越界 LL！</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210423220601687.png\" alt=\"image-20210423220601687\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;166.分数到小数(有限+无限循环:(循环节)) 无限不循环小数：根号 π e(无穷连分数)\n&#x2F;&#x2F;INT_MIN&#x2F;-1&#x3D;INT_MAX+1 int越界 LL！\nclass Solution &#123;\npublic:\n    string fractionToDecimal(int numerator, int denominator) &#123;\n        typedef long long LL;\n        LL x &#x3D; numerator, y &#x3D; denominator;\n        if (x % y &#x3D;&#x3D; 0) return to_string(x &#x2F; y);\n        string res;\n        if((x &lt; 0) ^ (y &lt; 0)) res +&#x3D; &#39;-&#39;;&#x2F;&#x2F;^:2个有1个满足\n        x &#x3D; abs(x), y &#x3D; abs(y);\n        res +&#x3D; to_string(x &#x2F; y) + &#39;.&#39;, x %&#x3D; y;\n        unordered_map&lt;LL, int&gt; hash;\n        while(x) &#123;&#x2F;&#x2F;余数\n            hash[x] &#x3D; res.size();\n            x *&#x3D; 10;\n            res +&#x3D; to_string(x &#x2F; y), x %&#x3D; y;\n            if(hash.count(x)) &#123;\n                res &#x3D; res.substr(0, hash[x]) + &#39;(&#39; + res.substr(hash[x]) + &#39;)&#39;;\n                break;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"167-两数之和-II-输入有序数组\"><a href=\"#167-两数之和-II-输入有序数组\" class=\"headerlink\" title=\"167.两数之和 II - 输入有序数组\"></a>167.两数之和 II - 输入有序数组</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n(双指针扫描) O(n)\n用两个指针 i,j 分别从数组首尾往中间扫描，\n每次将 i 后移一位，然后不断前移 j，直到 numbers[i]+numbers[j]≤target 为止。\n如果 numbers[i]+numbers[j]&#x3D;&#x3D;target，则找到了一组方案。\n\nj不回退：单调性 反证 O(n)\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;\n        for(int i &#x3D; 0, j &#x3D; numbers.size() - 1; i &lt; j; i++) &#123;\n            while(i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target) j--;&#x2F;&#x2F;数组有序！\n            if(i &lt; j &amp;&amp; numbers[i] + numbers[j] &#x3D;&#x3D; target) return &#123;i + 1, j + 1&#125;;&#x2F;&#x2F;idx:1~\n        &#125;\n        return &#123;&#125;;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"168-Excel表列名称-27-gt-AA-k位的26进制数的第几个（同理：12-int2罗马数字）\"><a href=\"#168-Excel表列名称-27-gt-AA-k位的26进制数的第几个（同理：12-int2罗马数字）\" class=\"headerlink\" title=\"168.Excel表列名称  27-&gt;AA k位的26进制数的第几个（同理：12.int2罗马数字）\"></a>168.Excel表列名称  27-&gt;AA k位的26进制数的第几个（同理：12.int2罗马数字）</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425105635974.png\" alt=\"image-20210425105635974\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425105941366.png\" alt=\"image-20210425105941366\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string convertToTitle(int n) &#123;\n        int k &#x3D; 1;&#x2F;&#x2F;位数\n        for(long long p &#x3D; 26; n &gt; p; p *&#x3D; 26) &#123;\n            n -&#x3D; p;&#x2F;&#x2F;个 十 百 千...\n            k++;\n        &#125;\n        n--;&#x2F;&#x2F;0~\n        string res;\n        while(k--) &#123;&#x2F;&#x2F;k位的26进制数的第几个\n            res +&#x3D; n %26 + &#39;A&#39;;\n            n &#x2F;&#x3D; 26;\n        &#125;\n\n        reverse(res.begin(), res.end());\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"！！！169-多数元素-经典-摩尔投票算法-求众数-邓P342\"><a href=\"#！！！169-多数元素-经典-摩尔投票算法-求众数-邓P342\" class=\"headerlink\" title=\"！！！169.多数元素[经典] 摩尔投票算法  求众数 邓P342\"></a>！！！169.多数元素[经典] 摩尔投票算法  求众数 邓P342</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;---169.多数元素[经典！！！] 一半以上的数\n&#x2F;&#x2F;(投票算法) T&#x3D;O(n) S&#x3D;O(1)\nclass Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        int cnt &#x3D; 0, candidate;\n        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            if (!cnt) candidate &#x3D; nums[i];\n            if (candidate &#x3D;&#x3D; nums[i])&#x2F;&#x2F;不是else if,所以上句不用cnt &#x3D; 1;!!!\n                cnt++;\n            else\n                cnt--;\n        &#125;\n        return candidate;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        int r, cnt &#x3D; 0;&#x2F;&#x2F;r：候选 库存\n        for (auto x: nums) &#123;\n            if (!cnt) r &#x3D; x, cnt &#x3D; 1;\n            else if (r &#x3D;&#x3D; x) cnt++;&#x2F;&#x2F;else if!!!\n            else cnt--;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;unordered_map 单次插入和查询的T&#x3D;O(1),故T&#x3D;O(n) S&#x3D;O(n)\nclass Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_map&lt;int, int&gt; hash;\n        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            hash[nums[i]] +&#x3D; 1;\n            if (hash[nums[i]] &gt; nums.size() &#x2F; 2)&#x2F;&#x2F;\n                return nums[i];\n        &#125;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;277&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n\n\n<h1 id=\"170\"><a href=\"#170\" class=\"headerlink\" title=\"170.\"></a>170.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"171-Excel表列序号-反168\"><a href=\"#171-Excel表列序号-反168\" class=\"headerlink\" title=\"171.Excel表列序号(反168)\"></a>171.Excel表列序号(反168)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425145858697.png\" alt=\"image-20210425145858697\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int titleToNumber(string s) &#123;\n        int a &#x3D; 0;&#x2F;&#x2F;26+26^2+26^3\n        for(long long i &#x3D; 0, p &#x3D; 26; i &lt; s.size() - 1; i++, p *&#x3D; 26)\n            a +&#x3D; p;\n        \n        int b &#x3D; 0;&#x2F;&#x2F;4位26进制数的第几个\n        for(auto c: s) b &#x3D; b * 26 + c - &#39;A&#39;;\n        return a + b + 1;&#x2F;&#x2F;序号：1~\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"172-阶乘后的零-经典数论-1-N每个数包含5的个数之和\"><a href=\"#172-阶乘后的零-经典数论-1-N每个数包含5的个数之和\" class=\"headerlink\" title=\"172.阶乘后的零  经典数论  1~N每个数包含5的个数之和\"></a>172.阶乘后的零  经典数论  1~N每个数包含5的个数之和</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425152757522.png\" alt=\"image-20210425152757522\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n蓝书P138阶乘分解   《王道机试指南》里也有\nn!中5的个数(&lt;2的个数)&#x3D;n!中10的个数\n&#x3D;&#x3D; 1~N每个数包含5的个数之和&#x3D;&#x3D;floor(n&#x2F;5)+floor(n&#x2F;5^2)+floor(n&#x2F;5^3)+...\n*&#x2F;\nclass Solution &#123;\npublic:\n    int trailingZeroes(int n) &#123;\n        int res &#x3D; 0;\n        while(n) res +&#x3D; n &#x2F; 5, n &#x2F;&#x3D; 5;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"173\"><a href=\"#173\" class=\"headerlink\" title=\"173.\"></a>173.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"174-地下城游戏-DP-类似62不同路径-63\"><a href=\"#174-地下城游戏-DP-类似62不同路径-63\" class=\"headerlink\" title=\"174.地下城游戏(DP 类似62不同路径 63)\"></a>174.地下城游戏(DP 类似62不同路径 63)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425164653346.png\" alt=\"image-20210425164653346\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425165412254.png\" alt=\"image-20210425165412254\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;259&#x2F;\n算法2：DP O(mn)\n状态表示：问什么设什么 f[i][j]&#x3D;从 (i, j) 成功到达终点，(i, j) 处需要具备的最少健康值。  return f[0][0]\n此题不能直接从正向动态规划的原因是不确定起始点的值，但我们可以发现，到终点之后健康值为 1 一定是最优的。\n可以考虑从终点到起点进行动态规划。\n倒推 (~i) &#x3D;&#x3D; (i!&#x3D;-1)  或 i &gt;&#x3D; 0\n    ~(-1)&#x3D;&#x3D;0  负数以其【正值的补码】形式表达：二进制记录负数&#x3D;绝对值取反加1  -1二进制表示: 00000001-&gt;11111110-&gt;11111111\n    f[i][j]+w[i][j] &gt;&#x3D; 1\n*&#x2F;\nclass Solution &#123;\npublic:\n    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; w) &#123;\n        int n &#x3D; w.size(), m &#x3D; w[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, 1e8));\n\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--)&#x2F;&#x2F;~i\n            for(int j &#x3D; m - 1; j &gt;&#x3D; 0; j--)\n                if(i &#x3D;&#x3D; n- 1 &amp;&amp; j &#x3D;&#x3D; m - 1) f[i][j] &#x3D; max(1, 1 - w[i][j]);&#x2F;&#x2F;f[i][j]+w[i][j] &gt;&#x3D; 1\n                else &#123;\n                    if(i + 1 &lt; n) f[i][j] &#x3D; f[i + 1][j] - w[i][j];\n                    if(j + 1 &lt; m) f[i][j] &#x3D; min(f[i][j], f[i][j + 1] - w[i][j]);\n                    f[i][j] &#x3D; max(1, f[i][j]);&#x2F;&#x2F;\n                &#125;\n        return f[0][0];\n    &#125;\n&#125;;\n\n&#x2F;*\n算法1\n(二分答案 + 动态规划判定) O(mnlogS)\n1.可以看到骑士的起始健康值满足单调性，可以二分这个健康值，找到下界。\n2.二分时，通过动态规划来判定是否可以到达终点。\n3.动态规划的状态表示为 f(i,j) 表示从起点到 (i, j)，所剩下的最大健康值。\n4.初始时 f(0,0)&#x3D;init+dungeon[0][0]，其余为 0。\n5.转移时，若 f(i−1,j)&gt;0，则 f(i,j)&#x3D;max(f(i,j),f(i−1,j)+dungeon[i][j])；若 f(i,j−1)&gt;0，则 f(i,j)&#x3D;max(f(i,j),f(i,j−1))+dungeon[i][j])。\n6.最终判断 f(n, m)\n\n时间复杂度\n二分答案时间复杂度为 O(log⁡S)，S 为答案上限。\n动态规划的状态数为 O(mn)，转移时间为常数，所以每次需要 O(mn) 的时间判定。\n故总时间复杂度为O(mnlog⁡S)。\n\n空间复杂度\n需要额外 O(mn) 的空间存储状态。\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    bool check(int initial, vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;\n        int m &#x3D; dungeon.size(), n &#x3D; dungeon[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(n, 0));\n\n        f[0][0] &#x3D; initial + dungeon[0][0];\n        for (int i &#x3D; 0; i &lt; m; i++)\n            for (int j &#x3D; 0; j &lt; n; j++) &#123;\n                if (i &gt; 0 &amp;&amp; f[i - 1][j] &gt; 0)\n                    f[i][j] &#x3D; max(f[i][j], f[i - 1][j] + dungeon[i][j]);\n\n                if (j &gt; 0 &amp;&amp; f[i][j - 1] &gt; 0)\n                    f[i][j] &#x3D; max(f[i][j], f[i][j - 1] + dungeon[i][j]);\n            &#125;\n\n        return f[m - 1][n - 1] &gt; 0;\n    &#125;\n\n    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;\n        const int INF &#x3D; 1000000000;\n        int l &#x3D; 1, r &#x3D; INF;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (l + r) &gt;&gt; 1;\n            if (check(mid, dungeon)) r &#x3D; mid;\n            else l &#x3D; mid + 1;\n        &#125;\n\n        return l;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;259&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"175\"><a href=\"#175\" class=\"headerlink\" title=\"175.\"></a>175.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"176\"><a href=\"#176\" class=\"headerlink\" title=\"176.\"></a>176.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"177\"><a href=\"#177\" class=\"headerlink\" title=\"177.\"></a>177.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"178\"><a href=\"#178\" class=\"headerlink\" title=\"178.\"></a>178.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"！！！179-最大数-匿名函数重定义sort比较函数a-b-gt-b-a（证明该定义方式可比较：传递性！）-去除前导0，全0留最后一个0\"><a href=\"#！！！179-最大数-匿名函数重定义sort比较函数a-b-gt-b-a（证明该定义方式可比较：传递性！）-去除前导0，全0留最后一个0\" class=\"headerlink\" title=\"！！！179.最大数 匿名函数重定义sort比较函数a + b &gt; b + a（证明该定义方式可比较：传递性！） 去除前导0，全0留最后一个0\"></a>！！！179.最大数 匿名函数重定义sort比较函数a + b &gt; b + a（证明该定义方式可比较：传递性！） 去除前导0，全0留最后一个0</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425174226876.png\" alt=\"image-20210425174226876\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425174550478.png\" alt=\"image-20210425174550478\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425175257240.png\" alt=\"image-20210425175257240\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">重新定义&lt;&#x3D;比较运算符，证明此自定义比较关系可比较！\n什么样的比较关系是能够排序的？全序关系：反对称性&gt;&#x3D;&amp;&amp;&lt;&#x3D; &#x3D;&#x3D;、完全性、传递性【xyz为abc位数】\n    ？还是偏序关系：自反性、反对称性和传递性。 自反性本身也包括了完全性。 所以，全序关系必是偏序关系。\n&#x2F;*\nhttps:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;93757835\n首先，我们将每个整数变成字符串。然后进行排序。\n如果仅按降序排序，有相同的开头数字的时候会出现问题。\n比方说，样例 2 按降序排序得到的数字是 95343303，然而交换 3 和 30 的位置可以得到正确答案 9534330。\n因此，每一对数在排序的比较过程中，我们【比较两种连接顺序】哪一种更好。\n我们可以证明这样的做法是正确的：\n假设（不失一般性），某一对整数 a 和 b，我们的比较结果是 a 应该在 b 前面，这意味着 a ⌢ b &gt; b ⌢ a，其中 ⌢ 表示连接。\n如果排序结果是错的，说明存在一个 c，b 在 c 前面且 c 在 a 的前面。这产生了矛盾，因为 a ⌢ b &gt; b ⌢ a 和 b ⌢ c &gt; c ⌢ b 意味着 a ⌢ c &gt; c ⌢ a。\n换言之，我们的【自定义比较方法保证了传递性，所以这样子排序是对的】。\n\n(贪心，排序) O(nlog⁡n)\n考虑简单的情况，如果只给了两个数字，那么只需要比较两个数字前后的拼接，即可确定顺序。\n扩展到多个数字时，存在偏序关系，即当 A 一定要在 B 前且 B 一定要在 C 前时，A 一定在 C 前。\n所以可以借助这个偏序关系直接对所有数字按照两个数字的情况进行排序。\n注意最后需要【去除前导 0】【特判0】。\n*&#x2F;\nclass Solution &#123;\npublic:\n    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(), nums.end(), [](int x, int y) &#123;\n            string sx &#x3D; to_string(x);\n            string sy &#x3D; to_string(y);\n            return sx + sy &gt; sy + sx;\n        &#125;);\n\n        string ans;\n        for (int i &#x3D; 0; i &lt; nums.size(); i++)\n            ans +&#x3D; to_string(nums[i]);\n\n        for (int i &#x3D; 0; i &lt; ans.length() - 1; i++)\n            if (ans[i] !&#x3D; &#39;0&#39;)\n                return ans.substr(i, ans.length() - i);&#x2F;&#x2F;substr(start,len)\n\n        return ans.substr(ans.length() - 1);&#x2F;&#x2F;0\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;260&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(), nums.end(), [](int x, int y) &#123;\n            string a &#x3D; to_string(x), b &#x3D; to_string(y);\n            return a + b &gt; b + a;\n        &#125;);&#x2F;&#x2F;匿名函数\n\n        string ans;\n        for (auto x: nums) ans +&#x3D; to_string(x);\n        int k &#x3D; 0;\n        while(k + 1 &lt; ans.size() &amp;&amp; ans[k] &#x3D;&#x3D; &#39;0&#39;) k++;&#x2F;&#x2F;去除前导0，全0留最后一个0\n        return ans.substr(k);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"180\"><a href=\"#180\" class=\"headerlink\" title=\"180.\"></a>180.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"181\"><a href=\"#181\" class=\"headerlink\" title=\"181.\"></a>181.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"182\"><a href=\"#182\" class=\"headerlink\" title=\"182.\"></a>182.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"183\"><a href=\"#183\" class=\"headerlink\" title=\"183.\"></a>183.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"184\"><a href=\"#184\" class=\"headerlink\" title=\"184.\"></a>184.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"185\"><a href=\"#185\" class=\"headerlink\" title=\"185.\"></a>185.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"186\"><a href=\"#186\" class=\"headerlink\" title=\"186.\"></a>186.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"187-重复的DNA序列-模拟：长度为10，出现次数超过一次\"><a href=\"#187-重复的DNA序列-模拟：长度为10，出现次数超过一次\" class=\"headerlink\" title=\"187.重复的DNA序列 模拟：长度为10，出现次数超过一次\"></a>187.重复的DNA序列 模拟：长度为10，出现次数超过一次</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;187.重复的DNA序列 找出所有目标子串(长度为10，出现次数超过一次)。\n&#x2F;&#x2F;拓展：目标子串的长度为m:用str_hash T&#x3D;O(mn)-&gt;O(m)\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;\n        unordered_map&lt;string, int&gt; cnt;\n        for(int i &#x3D; 0; i + 10 &lt;&#x3D; s.size(); i++)&#x2F;&#x2F;\n            cnt[s.substr(i, 10)]++;\n        vector&lt;string&gt; res;\n        for(auto [s, c]: cnt)\n            if(c &gt; 1) \n                res.push_back(s);\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"188-买卖股票的最佳时机-IV-困难-k次\"><a href=\"#188-买卖股票的最佳时机-IV-困难-k次\" class=\"headerlink\" title=\"188.买卖股票的最佳时机 IV  困难 k次\"></a>188.买卖股票的最佳时机 IV  困难 k次</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425210947342.png\" alt=\"image-20210425210947342\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;188.买卖股票的最佳时机 IV  困难\nclass Solution &#123;\npublic:\n    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;\n        const int INF &#x3D; 1e8;\n        int n &#x3D; prices.size();\n        if (k &gt; n &#x2F; 2) &#123; &#x2F;&#x2F; 等价于可以交易无限次\n            int res &#x3D; 0;\n            &#x2F;&#x2F; 遍历每个买入点\n            for (int i &#x3D; 0; i + 1 &lt; n; i ++ )\n                if (prices[i + 1] &gt; prices[i]) &#x2F;&#x2F; 如果后一天的价格超过当天的价格\n                    res +&#x3D; prices[i + 1] - prices[i];\n            return res;\n        &#125;\n        &#x2F;&#x2F; 初始时所有状态是负无穷，对f和g都是\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(k + 1, -INF));&#x2F;&#x2F;2 滚动\n        auto g &#x3D; f;\n        int res &#x3D; 0;\n        f[0][0] &#x3D; 0; &#x2F;&#x2F; 唯一的边界，也是状态机唯一的入口\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 0; j &lt;&#x3D; k; j ++ ) &#123;&#x2F;&#x2F;&amp;1\n                f[i][j] &#x3D; max(f[i - 1][j], g[i - 1][j] + prices[i - 1]);\n                &#x2F;&#x2F; g[i][j] &#x3D; max(g[i - 1][j], f[i - 1][j - 1] - prices[i - 1]);\n                g[i][j] &#x3D; g[i - 1][j];\n                if (j) g[i][j] &#x3D; max(g[i][j], f[i - 1][j - 1] - prices[i - 1]);\n                res &#x3D; max(res, f[i][j]);\n            &#125;\n        return res;\n    &#125;\n&#125;;\n\n作者：LauZyHou\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;639467&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;*\n注意\nLeetCode增强了本题的数据，非常卡常。\n于是为了应对新数据，对视频中的代码做了如下优化：\n\n1.将vector换成了数组，大概会快50%。\n2.类似于背包问题优化空间，将原本的滚动二维数组(2)(&amp;1)，直接换成一维数组。\n\nj要从0开始:\nf[i,j]表示已经经过i条边，已完成了j圈；\n当j &#x3D;&#x3D; 0时表示没转过1圈，也就没一直没买入过一次，这种情况是存在的，合法的；\n只有不合法的情况会认为不存在，这种状态会被赋值为正负无穷，就是代码里的-0x3f 这个值。\n*&#x2F;\nint f[10001], g[10001];\n\nclass Solution &#123;\npublic:\n    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;\n        int INF &#x3D; 1e8;\n        int n &#x3D; prices.size();\n        if (k &gt; n &#x2F; 2) &#123;\n            int res &#x3D; 0;\n            for (int i &#x3D; 1; i &lt; n; i ++ )\n                if (prices[i] &gt; prices[i - 1])\n                    res +&#x3D; prices[i] - prices[i - 1];\n            return res;\n        &#125;\n        memset(f, -0x3f, sizeof f);\n        memset(g, -0x3f, sizeof g);\n        f[0] &#x3D; 0;\n        int res &#x3D; 0;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; k; j &gt;&#x3D; 0; j -- ) &#123;&#x2F;&#x2F;\n                g[j] &#x3D; max(g[j], f[j] - prices[i - 1]);&#x2F;&#x2F;\n                if (j) f[j] &#x3D; max(f[j], g[j - 1] + prices[i - 1]);&#x2F;&#x2F;\n            &#125;\n        for (int i &#x3D; 1; i &lt;&#x3D; k; i ++ ) res &#x3D; max(res, f[i]);\n        return res;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;417331&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;另 https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;2551&#x2F;1&#x2F;\n</code></pre>\n\n\n\n<h1 id=\"189-旋转数组-原地\"><a href=\"#189-旋转数组-原地\" class=\"headerlink\" title=\"189.旋转数组 原地\"></a>189.旋转数组 原地</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        k %&#x3D; n;&#x2F;&#x2F;\n        reverse(nums.begin(), nums.end());&#x2F;&#x2F;收尾swap_iter\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"190-颠倒二进制位-位运算-res-x3D-res-lt-lt-1-n-gt-gt-i-amp-1\"><a href=\"#190-颠倒二进制位-位运算-res-x3D-res-lt-lt-1-n-gt-gt-i-amp-1\" class=\"headerlink\" title=\"190.颠倒二进制位 位运算 res &#x3D; (res &lt;&lt; 1) + (n &gt;&gt; i &amp; 1);\"></a>190.颠倒二进制位 位运算 res &#x3D; (res &lt;&lt; 1) + (n &gt;&gt; i &amp; 1);</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;取n的第k位：n&gt;&gt;k&amp;1\nclass Solution &#123;\npublic:\n    uint32_t reverseBits(uint32_t n) &#123;\n        uint32_t res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; 32; i++)\n            res &#x3D; (res &lt;&lt; 1) + (n &gt;&gt; i &amp; 1);&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"191-位1的个数-lowbit-x-x3D-x-amp-x\"><a href=\"#191-位1的个数-lowbit-x-x3D-x-amp-x\" class=\"headerlink\" title=\"191.位1的个数 lowbit(x)&#x3D;x&amp;-x\"></a>191.位1的个数 lowbit(x)&#x3D;x&amp;-x</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210425220124337.png\" alt=\"image-20210425220124337\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;最后一位1：lowbit(x)&#x3D;x&amp;-x&#x3D;x&amp;(~x+1) 树状数组 位运算优化爆搜\nclass Solution &#123;\npublic:\n    uint32_t lowbit(uint32_t x) &#123;\n        return x &amp; -x;\n    &#125;\n    int hammingWeight(uint32_t n) &#123;\n        int cnt &#x3D; 0;\n        while(n) n -&#x3D; lowbit(n), cnt++;\n        return cnt;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"192\"><a href=\"#192\" class=\"headerlink\" title=\"192.\"></a>192.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"193\"><a href=\"#193\" class=\"headerlink\" title=\"193.\"></a>193.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"194\"><a href=\"#194\" class=\"headerlink\" title=\"194.\"></a>194.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"195\"><a href=\"#195\" class=\"headerlink\" title=\"195.\"></a>195.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"196\"><a href=\"#196\" class=\"headerlink\" title=\"196.\"></a>196.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"197\"><a href=\"#197\" class=\"headerlink\" title=\"197.\"></a>197.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"198-打家劫舍-DP-不相邻max\"><a href=\"#198-打家劫舍-DP-不相邻max\" class=\"headerlink\" title=\"198.打家劫舍 DP 不相邻max\"></a>198.打家劫舍 DP 不相邻max</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210429110109813.png\" alt=\"image-20210429110109813\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; f(n + 1), g(n + 1);\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            f[i] &#x3D; g[i - 1] +  nums[i - 1];&#x2F;&#x2F;&#x3D;&#x3D;Wi，nums:0开始\n            g[i] &#x3D; max(f[i - 1], g[i - 1]);\n        &#125;\n        return max(f[n], g[n]);\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"199-二叉树的右视图-BFS\"><a href=\"#199-二叉树的右视图-BFS\" class=\"headerlink\" title=\"199. 二叉树的右视图  BFS\"></a>199. 二叉树的右视图  BFS</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;\n        queue&lt;TreeNode*&gt; q;\n        vector&lt;int&gt; res;\n        if (!root) return res;\n        q.push(root);\n        while (q.size()) &#123;\n            int len &#x3D; q.size();\n            for (int i &#x3D; 0; i &lt; len; i ++ ) &#123;\n                auto t &#x3D; q.front();\n                q.pop();\n                if (t-&gt;left) q.push(t-&gt;left);\n                if (t-&gt;right) q.push(t-&gt;right);\n                if (i &#x3D;&#x3D; len - 1) res.push_back(t-&gt;val);&#x2F;&#x2F;i &#x3D;&#x3D; len - 1\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"200-岛屿数量-floodfill模板题（1的【非斜】连通块数）\"><a href=\"#200-岛屿数量-floodfill模板题（1的【非斜】连通块数）\" class=\"headerlink\" title=\"200.岛屿数量 floodfill模板题（1的【非斜】连通块数）\"></a>200.岛屿数量 floodfill模板题（1的【非斜】连通块数）</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;char&gt;&gt; g;\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;\n        g &#x3D; grid;&#x2F;&#x2F;\n        int cnt &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; g.size(); i ++ )\n            for (int j &#x3D; 0; j &lt; g[i].size(); j ++ )\n                if (g[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;\n                    dfs(i, j);\n                    cnt ++ ;\n                &#125;\n        return cnt;\n    &#125;\n\n    void dfs(int x, int y) &#123;\n        g[x][y] &#x3D; 0;&#x2F;&#x2F;visited\n        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; g.size() &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; g[a].size() &amp;&amp; g[a][b] &#x3D;&#x3D; &#39;1&#39;)\n                dfs(a, b);\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"201-数字范围按位与-xx-公共前缀-xxx00…0\"><a href=\"#201-数字范围按位与-xx-公共前缀-xxx00…0\" class=\"headerlink\" title=\"201. 数字范围按位与    xx(公共前缀)xxx00…0\"></a>201. 数字范围按位与    xx(公共前缀)xxx00…0</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210515220709912.png\" alt=\"image-20210515220709912\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210515220923357.png\" alt=\"image-20210515220923357\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int rangeBitwiseAnd(int m, int n) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;&#x2F;&#x2F;1~2^31 -1\n            if ((m &gt;&gt; i &amp; 1) !&#x3D; (n &gt;&gt; i &amp; 1)) break;\n            if (m &gt;&gt; i &amp; 1) res +&#x3D; 1 &lt;&lt; i;&#x2F;&#x2F;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"202-快乐数（141-环形链表）-1步2步，相遇则有环\"><a href=\"#202-快乐数（141-环形链表）-1步2步，相遇则有环\" class=\"headerlink\" title=\"202.快乐数（141 环形链表） 1步2步，相遇则有环\"></a>202.快乐数（141 环形链表） 1步2步，相遇则有环</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;抽屉原理：0&lt;&#x3D;x&lt;&#x3D;810,&gt;812步，一定入圈\nclass Solution &#123;\npublic:\n    int get(int x) &#123;&#x2F;&#x2F;各位平方和，&lt;810&#x3D;9^2 * 10,唯一：不会分叉\n        int res &#x3D; 0;\n        while (x) &#123;\n            res +&#x3D; (x % 10) * (x % 10);\n            x &#x2F;&#x3D; 10;\n        &#125;\n        return res;\n    &#125;\n\n    bool isHappy(int n) &#123;\n        int fast &#x3D; get(n), slow &#x3D; n;&#x2F;&#x2F;\n        while (fast !&#x3D; slow) &#123;\n            fast &#x3D; get(get(fast));\n            slow &#x3D; get(slow);\n        &#125;\n        return fast &#x3D;&#x3D; 1;&#x2F;&#x2F;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a>203. 移除链表元素</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210517204646222.png\" alt=\"image-20210517204646222\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    ListNode* removeElements(ListNode* head, int val) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n        for(auto p &#x3D; dummy; p; p &#x3D; p-&gt;next) &#123;\n            auto q &#x3D; p-&gt;next;\n            while(q &amp;&amp; q-&gt;val &#x3D;&#x3D; val) q &#x3D; q-&gt;next;\n            p-&gt;next &#x3D; q;\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"204-计数质数-lt-n-线性筛素数O-n-模板题-if-i-primes-j-x3D-x3D-0-break\"><a href=\"#204-计数质数-lt-n-线性筛素数O-n-模板题-if-i-primes-j-x3D-x3D-0-break\" class=\"headerlink\" title=\"204.计数质数(&lt;n)   线性筛素数O(n)模板题      if (i % primes[j] &#x3D;&#x3D; 0) break;\"></a>204.计数质数(&lt;n)   线性筛素数O(n)模板题      if (i % primes[j] &#x3D;&#x3D; 0) break;</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;204.计数质数(&lt;n)   线性筛法模板题\n&#x2F;*\n时间复杂度为O(N^0.75)的解法, 击败99.67%\nhttps:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;count-primes&#x2F;solution&#x2F;shi-jian-fu-za-du-wei-on075de-jie-fa-ji-9qmi6&#x2F;\nProjectEuler题解（更新到100题）\nhttps:&#x2F;&#x2F;github.com&#x2F;cloudzfy&#x2F;euler\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;metaquant&#x2F;article&#x2F;details&#x2F;114299146?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control\n欧拉计划中文题解站\nhttps:&#x2F;&#x2F;pe.metaquant.org&#x2F;index.html\n*&#x2F;\n&#x2F;*\n&#x2F;&#x2F;Acwing868：筛质数     线性筛素数O(n)\n算法流程：\n\n从小到大枚举每个数 i；\n如果 i 没有被标记，将 i 加入质数集合；\n对于每个 i，从小到大枚举已有的质数 primej，将 i∗primej 标记成合数。如果 i 能整除 primej，则直接break。\n下面证明该算法是正确的，且时间复杂度是线性的：\n\n首先，质数一定不是其它质数的倍数，所以质数一定会被找出来。然后我们证明，每个合数一定会被它的最小质因子标记，且只会被它的最小值因子标记，\n从而每个合数只会被标记一次，所以时间复杂度是线性的。\n\n我们先来证明每个合数可以被它的最小质因子标记：\n假设某个合数是 x，它的最小质因子是 p，令i&#x3D;x&#x2F;p，则 i 的所有质因子一定大于等于 p，\n所以当算法的第一层循环枚举到 i后，我们从小到大枚举质数时，i 一定不能整除比 p 小的质数，所以一定可以枚举到质数 p，从而可以把 x&#x3D;i∗p 标记为合数。\n\n然后我们证明每个合数仅会被它的最小质因子标记：\n假设某个合数是 x，它的某个非最小的质因子是 p，令 i&#x3D;x&#x2F;p，则 i 包含 x 的最小质因子，从而 i 存在某个质因子比 p 小。\n所以当算法的第一层循环枚举到 i 时，第二层循环枚举到 i 的最小质因子后会直接break，不会枚举 p，所以 x 一定不会被非最小的质因子标记。\n\n证毕。\n\n时间复杂度分析：每个合数仅会被它的最小质因子标记，所以每个合数只被标记1次，所以时间复杂度是 O(n)。\n\n*&#x2F;\nclass Solution &#123;\npublic:\n    int countPrimes(int n) &#123;\n        vector&lt;int&gt; primes;\n        vector&lt;bool&gt; st(n + 1);\n        for (int i &#x3D; 2; i &lt; n; i ++ )\n        &#123;\n            if (!st[i]) primes.push_back(i);\n            for (int j &#x3D; 0; i * primes[j] &lt; n; j ++ )&#x2F;&#x2F;用最小质因子Pj标记合数(i*Pj) &lt;n\n            &#123;\n                st[i * primes[j]] &#x3D; true;\n                if (i % primes[j] &#x3D;&#x3D; 0) break;&#x2F;&#x2F;枚举到 i 的最小质因子 Pj 后会直接break\n            &#125;\n        &#125;\n        return primes.size();\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;314&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"205-同构字符串-字符替换-单射：一一对应-unordered-map-s-lt-–-gt-t\"><a href=\"#205-同构字符串-字符替换-单射：一一对应-unordered-map-s-lt-–-gt-t\" class=\"headerlink\" title=\"205.同构字符串 字符替换(单射：一一对应) unordered_map:s&lt;–&gt;t\"></a>205.同构字符串 字符替换(单射：一一对应) unordered_map:s&lt;–&gt;t</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    bool isIsomorphic(string s, string t) &#123;\n        &#x2F;&#x2F;if(s.size() !&#x3D; t.size()) return false;\n        unordered_map&lt;char, char&gt; st, ts;\n        for(int i &#x3D; 0; i &lt; s.size(); i++)\n        &#123;\n            int a &#x3D; s[i], b &#x3D; t[i];\n            if(st.count(a) &amp;&amp; st[a] !&#x3D; b) return false;&#x2F;&#x2F;\n            st[a] &#x3D; b;&#x2F;&#x2F;\n            if(ts.count(b) &amp;&amp; ts[b] !&#x3D; a) return false;\n            ts[b] &#x3D; a;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"206-反转链表-gt-92-II迭代-经典\"><a href=\"#206-反转链表-gt-92-II迭代-经典\" class=\"headerlink\" title=\"206.反转链表-&gt;92.II迭代    经典\"></a>206.反转链表-&gt;92.II迭代    经典</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;迭代\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode *prev &#x3D; nullptr;&#x2F;&#x2F;\n        ListNode *cur &#x3D; head;\n        while (cur)\n        &#123;\n            ListNode *next &#x3D; cur-&gt;next;\n            cur-&gt;next &#x3D; prev;\n            prev &#x3D; cur, cur &#x3D; next;\n        &#125;\n        return prev;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;递归\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        if (!head || !head-&gt;next) return head;\n        ListNode *tail &#x3D; reverseList(head-&gt;next);\n        head-&gt;next-&gt;next &#x3D; head;&#x2F;&#x2F;\n        head-&gt;next &#x3D; nullptr;&#x2F;&#x2F;\n        return tail;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"207-课程表-拓扑排序-d-u-x3D-0入队\"><a href=\"#207-课程表-拓扑排序-d-u-x3D-0入队\" class=\"headerlink\" title=\"207.课程表 拓扑排序:d[u]&#x3D;0入队\"></a>207.课程表 拓扑排序:d[u]&#x3D;0入队</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool canFinish(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n        vector&lt;vector&lt;int&gt;&gt; g(n);&#x2F;&#x2F;邻接表：后继节点\n        vector&lt;int&gt; d(n);\n        for(auto&amp; e: edges) &#123;\n            int b &#x3D; e[0], a &#x3D; e[1];\n            g[a].push_back(b);&#x2F;&#x2F;a-&gt;b\n            d[b]++;\n        &#125;\n        queue&lt;int&gt; q;\n        for(int i &#x3D; 0; i &lt; n; i++)\n            if(d[i] &#x3D;&#x3D; 0) q.push(i);\n\n        int cnt &#x3D; 0;\n        while(q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            cnt++;\n            for(auto i : g[t])\n                if(--d[i] &#x3D;&#x3D; 0) q.push(i);\n        &#125;\n        return cnt &#x3D;&#x3D; n;&#x2F;&#x2F;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"208-实现Trie（前缀树）字典树\"><a href=\"#208-实现Trie（前缀树）字典树\" class=\"headerlink\" title=\"208.实现Trie（前缀树）字典树\"></a>208.实现Trie（前缀树）字典树</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Trie &#123;\npublic:\n    struct Node &#123;\n        bool is_end;\n        Node *son[26];\n        Node() &#123;\n            is_end &#x3D; false;\n            for(int i &#x3D; 0; i &lt; 26; i++)\n                son[i] &#x3D; NULL;\n        &#125;\n    &#125;*root;\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    Trie() &#123;\n        root &#x3D; new Node();\n    &#125;\n    \n    &#x2F;** Inserts a word into the trie. *&#x2F;\n    void insert(string word) &#123;\n        auto p &#x3D; root;\n        for(auto c: word) &#123;\n            int u &#x3D; c - &#39;a&#39;;&#x2F;&#x2F;cur_idx\n            if(!p-&gt;son[u]) p-&gt;son[u] &#x3D; new Node();&#x2F;&#x2F;\n            p &#x3D; p-&gt;son[u]; \n        &#125;\n        p-&gt;is_end &#x3D; true;&#x2F;&#x2F;\n    &#125;\n    \n    &#x2F;** Returns if the word is in the trie. *&#x2F;\n    bool search(string word) &#123;\n        auto p &#x3D; root;\n        for(auto c: word) &#123;\n            int u &#x3D; c - &#39;a&#39;;&#x2F;&#x2F;cur_idx\n            if(!p-&gt;son[u]) return false;\n            p &#x3D; p-&gt;son[u]; \n        &#125;\n        return p-&gt;is_end;&#x2F;&#x2F;\n    &#125;\n    \n    &#x2F;** Returns if there is any word in the trie that starts with the given prefix. *&#x2F;\n    bool startsWith(string prefix) &#123;\n        auto p &#x3D; root;\n        for(auto c: prefix) &#123;\n            int u &#x3D; c - &#39;a&#39;;&#x2F;&#x2F;cur_idx\n            if(!p-&gt;son[u]) return false;\n            p &#x3D; p-&gt;son[u]; \n        &#125;\n        return true;&#x2F;&#x2F;\n    &#125;\n&#125;;\n&#x2F;&#x2F;delete words: mark p-&gt;is_end&#x3D;false;\n</code></pre>\n\n\n\n<h1 id=\"209-长度最小的子数组-正整数-gt-x3D-sum-双指针-while-sum-nums-j-gt-x3D-s-sum-x3D-nums-j-x2F-x2F-探地雷-j\"><a href=\"#209-长度最小的子数组-正整数-gt-x3D-sum-双指针-while-sum-nums-j-gt-x3D-s-sum-x3D-nums-j-x2F-x2F-探地雷-j\" class=\"headerlink\" title=\"209.长度最小的子数组(正整数 &gt;&#x3D;sum) 双指针  while(sum - nums[j] &gt;&#x3D; s) sum -&#x3D; nums[j++];&#x2F;&#x2F;探地雷 j\"></a>209.长度最小的子数组(正整数 &gt;&#x3D;sum) 双指针  while(sum - nums[j] &gt;&#x3D; s) sum -&#x3D; nums[j++];&#x2F;&#x2F;探地雷 j</h1><p>单调性证明</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210519100511779.png\" alt=\"image-20210519100511779\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; INT_MAX;\n        for(int i &#x3D; 0, j &#x3D; 0, sum &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            sum +&#x3D; nums[i];&#x2F;&#x2F;i\n            while(sum - nums[j] &gt;&#x3D; s) sum -&#x3D; nums[j++];&#x2F;&#x2F;探地雷 j\n            if(sum &gt;&#x3D; s) res &#x3D; min(res, i - j + 1);&#x2F;&#x2F;res\n        &#125;\n        if(res &#x3D;&#x3D; INT_MAX) res &#x3D; 0;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"210-课程表II-存单case\"><a href=\"#210-课程表II-存单case\" class=\"headerlink\" title=\"210.课程表II 存单case\"></a>210.课程表II 存单case</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; findOrder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n        vector&lt;vector&lt;int&gt;&gt; g(n);&#x2F;&#x2F;邻接表：后继节点\n        vector&lt;int&gt; d(n);\n        for(auto&amp; e: edges) &#123;\n            int b &#x3D; e[0], a &#x3D; e[1];&#x2F;&#x2F;b&lt;-a\n            g[a].push_back(b);&#x2F;&#x2F;a-&gt;b\n            d[b]++;\n        &#125;\n        queue&lt;int&gt; q;\n        for(int i &#x3D; 0; i &lt; n; i++)\n            if(d[i] &#x3D;&#x3D; 0) q.push(i);\n\n        vector&lt;int&gt; res;\n        while(q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            res.push_back(t);\n            for(int i : g[t])\n                if(--d[i] &#x3D;&#x3D; 0) q.push(i);\n        &#125;\n        if(res.size() &lt; n) res &#x3D; &#123;&#125;;&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"211-添加与搜索单词-数据结构设计-正则-不重复-搜Trie-O-nL-lt-lt-26-k\"><a href=\"#211-添加与搜索单词-数据结构设计-正则-不重复-搜Trie-O-nL-lt-lt-26-k\" class=\"headerlink\" title=\"211.添加与搜索单词-数据结构设计 [正则 ]不重复 搜Trie:O(nL) &lt;&lt; 26^k\"></a>211.添加与搜索单词-数据结构设计 [正则 ]不重复 搜Trie:O(nL) &lt;&lt; 26^k</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;211.添加与搜索单词-数据结构设计 [正则 ]不重复 搜Trie:O(nL) &lt;&lt; 26^k\n&#x2F;&#x2F;时间复杂度分析：假设单词的平均长度是 L，总共有 n 个单词。add操作会遍历 L 个节点，\n&#x2F;&#x2F;所以时间复杂度是 O(L)；search操作最坏情况下会遍历所有节点，所以时间复杂度是 O(nL)。\nclass WordDictionary &#123;\npublic:\n    struct Node &#123;\n        bool is_end;\n        Node *son[26];\n        Node() &#123;\n            is_end &#x3D; false;\n            for (int i &#x3D; 0; i &lt; 26; i ++ )\n                son[i] &#x3D; NULL;&#x2F;&#x2F;0\n        &#125;\n    &#125;*root;\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    WordDictionary() &#123;\n        root &#x3D; new Node();\n    &#125;\n\n    &#x2F;** Adds a word into the data structure. *&#x2F;\n    void addWord(string word) &#123;\n        Node *p &#x3D; root;\n        for (char c : word) &#123;\n            int u &#x3D; c - &#39;a&#39;;\n            if (!p-&gt;son[u]) p-&gt;son[u] &#x3D; new Node();\n            p &#x3D; p-&gt;son[u];\n        &#125;\n        p-&gt;is_end &#x3D; true;\n    &#125;\n\n    &#x2F;** Returns if the word is in the data structure. A word could contain the dot character &#39;.&#39; to represent any one letter. *&#x2F;\n    &#x2F;*\n    bool search(string word) &#123;\n        return dfs(root, word, 0);\n    &#125;\n\n    bool dfs(Node* p, string&amp; word, int i) &#123;\n        if (i &#x3D;&#x3D; word.size()) return p-&gt;is_end;\n        if (word[i] !&#x3D; &#39;.&#39;) &#123;\n        \tint u &#x3D; word[i] - &#39;a&#39;;\n        \tif(!p-&gt;son[u]) return false;&#x2F;&#x2F;\n            return dfs(p-&gt;son[u], word, i + 1);&#x2F;&#x2F;\n        &#125; else &#123;\n            for (int j &#x3D; 0; j &lt; 26; j ++ )\n                if (p-&gt;son[j] &amp;&amp; dfs(p-&gt;son[j], word, i + 1))\n                \treturn true;\n                return false;\n        &#125;\n    &#125;\n    *&#x2F;\n    bool search(string word) &#123;\n        return dfs(word, 0, root);\n    &#125;\n\n    bool dfs(string &amp;word, int k, Node *u)\n    &#123;\n        if (k &#x3D;&#x3D; word.size()) return u-&gt;is_end;\n        if (word[k] !&#x3D; &#39;.&#39;)\n        &#123;\n            if (u-&gt;son[word[k] - &#39;a&#39;]) return dfs(word, k + 1, u-&gt;son[word[k] - &#39;a&#39;]);&#x2F;&#x2F;\n        &#125;\n        else\n        &#123;\n            for (int i &#x3D; 0; i &lt; 26; i ++ )\n                if (u-&gt;son[i])\n                &#123;\n                    if (dfs(word, k + 1, u-&gt;son[i])) return true;\n                &#125;\n        &#125;\n        return false;&#x2F;&#x2F;\n    &#125;\n\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"212-单词搜索II-DFS-Trie-words列表-入Trie，存idx用于输出\"><a href=\"#212-单词搜索II-DFS-Trie-words列表-入Trie，存idx用于输出\" class=\"headerlink\" title=\"212.单词搜索II(DFS+Trie)  words列表 入Trie，存idx用于输出\"></a>212.单词搜索II(DFS+Trie)  words列表 入Trie，存idx用于输出</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210519112831877.png\" alt=\"image-20210519112831877\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;212.单词搜索II words列表 入Trie，存idx用于输出\n&#x2F;&#x2F;“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。\nclass Solution &#123;\npublic:\n    struct Node &#123;\n        int id;\n        Node *son[26];\n        Node() &#123;\n            id &#x3D; -1;\n            for (int i &#x3D; 0; i &lt; 26; i ++ ) son[i] &#x3D; NULL;\n        &#125;\n    &#125;*root;\n\n    unordered_set&lt;int&gt; ids;&#x2F;&#x2F;判重\n    vector&lt;vector&lt;char&gt;&gt; g;\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    void insert(string&amp; word, int id) &#123;\n        auto p &#x3D; root;\n        for (auto c: word) &#123;\n            int u &#x3D; c - &#39;a&#39;;\n            if (!p-&gt;son[u]) p-&gt;son[u] &#x3D; new Node();\n            p &#x3D; p-&gt;son[u];\n        &#125;\n        p-&gt;id &#x3D; id;&#x2F;&#x2F;\n    &#125;\n\n    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123;\n        g &#x3D; board;\n        root &#x3D; new Node();\n        for (int i &#x3D; 0; i &lt; words.size(); i ++ ) insert(words[i], i);&#x2F;&#x2F;build Trie\n\n        for (int i &#x3D; 0; i &lt; g.size(); i ++ )\n            for (int j &#x3D; 0; j &lt; g[i].size(); j ++ ) &#123;\n                int u &#x3D; g[i][j] - &#39;a&#39;;\n                if (root-&gt;son[u]) dfs(i, j, root-&gt;son[u]);&#x2F;&#x2F;\n            &#125;\n\n        vector&lt;string&gt; res;\n        for (auto id: ids) res.push_back(words[id]);&#x2F;&#x2F;\n        return res;\n    &#125;\n\n    void dfs(int x, int y, Node* p) &#123;\n        if (p-&gt;id !&#x3D; -1) ids.insert(p-&gt;id);&#x2F;&#x2F;\n        char t &#x3D; g[x][y];\n        g[x][y] &#x3D; &#39;.&#39;;&#x2F;&#x2F;标记\n        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; g.size() &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; g[0].size() &amp;&amp; g[a][b] !&#x3D; &#39;.&#39;) &#123;\n                int u &#x3D; g[a][b] - &#39;a&#39;;\n                if (p-&gt;son[u]) dfs(a, b, p-&gt;son[u]);&#x2F;&#x2F;\n            &#125;\n        &#125;\n        g[x][y] &#x3D; t;&#x2F;&#x2F;恢复\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"213-打家劫舍II（198）-围成一圈\"><a href=\"#213-打家劫舍II（198）-围成一圈\" class=\"headerlink\" title=\"213.打家劫舍II（198） 围成一圈~\"></a>213.打家劫舍II（198） 围成一圈~</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210515212210439.png\" alt=\"image-20210515212210439\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (!n) return 0;\n        if (n &#x3D;&#x3D; 1) return nums[0];&#x2F;&#x2F;如果不特判：g[1] &#x3D; INT_MIN;\n        vector&lt;int&gt; f(n + 1), g(n + 1);\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ ) &#123;&#x2F;&#x2F;不选0号\n            f[i] &#x3D; g[i - 1] + nums[i - 1];&#x2F;&#x2F;nums从0开始\n            g[i] &#x3D; max(f[i - 1], g[i - 1]);\n        &#125;\n        int res &#x3D; max(f[n], g[n]);\n        &#x2F;&#x2F;选0号\n        f[1] &#x3D; nums[0];\n        g[1] &#x3D; INT_MIN;&#x2F;&#x2F;非法状态，负无穷\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ ) &#123;\n            f[i] &#x3D; g[i - 1] + nums[i - 1];\n            g[i] &#x3D; max(f[i - 1], g[i - 1]);\n        &#125;\n\n        return max(res, g[n]);\n    &#125;\n&#125;;\n</code></pre>\n\n<p>另</p>\n<p>???</p>\n<p><img src=\"https://cdn.acwing.com/media/article/image/2020/06/06/32343_c99b97daa7-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.jpg\" alt=\"打家劫舍.jpg\"><strong>根据闫氏DP分析法则中的不重不漏原则，由于情况1和2已经把情况3包含其中，所以我们只需要对情况1和情况2进行分析即可。</strong></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">我们的算法思路是分别从前往后和从后往前进行两次DP，区间分别为1 ~ n - 1 和 n ~ 2\n????????????????????????????\n\nclass Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (nums.empty()) return 0;\n        if (n &#x3D;&#x3D; 1) return nums[0];\n\n        vector&lt;int&gt; f(n + 1, 0), g(n + 1, 0);\n        f[1] &#x3D; nums[0];\n        for (int i &#x3D; 2; i &lt;&#x3D; n - 1; i ++)\n            f[i] &#x3D; max(f[i - 1], f[i - 2] + nums[i - 1]);\n\n        g[n - 1] &#x3D; nums[n - 1];\n        for (int i &#x3D; n - 2; i ; i --)\n            g[i] &#x3D; max(g[i + 1], g[i + 2] + nums[i]);\n\n        return max(f[n -1], g[1]);\n    &#125;\n&#125;;\n\n作者：Roger_3\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;14315&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n\n\n<h1 id=\"214-最短回文串-前面添加字符将其转换-x3D-x3D-find原串max-prefix回文串idx-x3D-x3D-构造串KMP-next-end-难\"><a href=\"#214-最短回文串-前面添加字符将其转换-x3D-x3D-find原串max-prefix回文串idx-x3D-x3D-构造串KMP-next-end-难\" class=\"headerlink\" title=\"214.最短回文串 前面添加字符将其转换 &#x3D;&#x3D;find原串max_prefix回文串idx &#x3D;&#x3D; 构造串KMP_next[end]    难\"></a>214.最短回文串 前面添加字符将其转换 &#x3D;&#x3D;find原串max_prefix回文串idx &#x3D;&#x3D; 构造串KMP_next[end]    难</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210519113949299.png\" alt=\"image-20210519113949299\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;214.最短回文串 前面添加字符将其转换\n&#x2F;&#x2F;&#x3D;&#x3D;find原串max_prefix回文串idx &#x3D;&#x3D; 构造串KMP_next[end]\nclass Solution &#123;\npublic:\n    string shortestPalindrome(string s) &#123;\n        string t(s.rbegin(), s.rend());&#x2F;&#x2F;\n        int n &#x3D; s.size();\n        s &#x3D; &#39; &#39; + s + &#39;#&#39; + t; &#x2F;&#x2F;KMP从1开始\n        vector&lt;int&gt; ne(n * 2 + 2);\n        for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n * 2 + 1; i ++ ) &#123;&#x2F;&#x2F;KMP_next模板！！背！！\n            while (j &amp;&amp; s[i] !&#x3D; s[j + 1]) j &#x3D; ne[j];&#x2F;&#x2F;j: 1开始\n            if (s[i] &#x3D;&#x3D; s[j + 1]) j ++ ;\n            ne[i] &#x3D; j;\n        &#125;\n        int len &#x3D; ne[n * 2 + 1];&#x2F;&#x2F;原串max_prefix回文串idx &#x3D;&#x3D; 构造串KMP_next[end]\n        string left &#x3D; s.substr(1, len), right &#x3D; s.substr(1 + len, n - len);\n        return string(right.rbegin(), right.rend()) + left + right;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"法二code有问题！-—215-数组中的第K个最大元素-BFPRT：快排最坏复杂度降至O-n-medianOfMedians-找居中-pivot！！！\"><a href=\"#法二code有问题！-—215-数组中的第K个最大元素-BFPRT：快排最坏复杂度降至O-n-medianOfMedians-找居中-pivot！！！\" class=\"headerlink\" title=\"!!![法二code有问题！]—215.数组中的第K个最大元素  BFPRT：快排最坏复杂度降至O(n) medianOfMedians 找居中 pivot！！！\"></a>!!![法二code有问题！]—215.数组中的第K个最大元素  BFPRT：快排最坏复杂度降至O(n) medianOfMedians 找居中 pivot！！！</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210522155654601.png\" alt=\"image-20210522155654601\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n拓：topK\nBFPRT O(n)：medianOfMedians 找居中 pivot\n\nhttps:&#x2F;&#x2F;ljt12138.github.io&#x2F;2019&#x2F;12&#x2F;01&#x2F;k-sorter-problem&#x2F;\n邓dsa quickselection 基于快速划分的k选取算法\n\nhttps:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;128524579\n*&#x2F;\n&#x2F;&#x2F;215.数组中的第K个最大元素 快速选择算法Acwing786\n&#x2F;&#x2F;法一\n&#x2F;&#x2F;idea from  https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;acwing&#x2F;content&#x2F;4502&#x2F;\n&#x2F;&#x2F;每次只需要判断[k在左区间还是右区间，一直递归查找k所在区间]\n&#x2F;&#x2F;最后只剩一个数时，只会有数组[k]一个数，返回数组[k]的值就是答案\nclass Solution &#123;\npublic:\n\n    int quick_sort(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123;\n        if (l &#x3D;&#x3D; r) return nums[k];\n        int x &#x3D; nums[l], i &#x3D; l - 1, j &#x3D; r + 1;&#x2F;&#x2F;-1 +1\n        while (i &lt; j) &#123;&#x2F;&#x2F;降序\n            do i ++ ; while (nums[i] &gt; x);&#x2F;&#x2F;&#x3D;&#x3D;  while(nums[++i] &gt; x);\n            do j -- ; while (nums[j] &lt; x);\n            if (i &lt; j) swap(nums[i], nums[j]);\n        &#125;\n        if (k &lt;&#x3D; j) return quick_sort(nums, l, j, k);&#x2F;&#x2F;k &lt;&#x3D; j ！！！\n        else return quick_sort(nums, j + 1, r, k);&#x2F;&#x2F;第k大在R中继续找\n    &#125;\n\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        return quick_sort(nums, 0, nums.size() - 1, k - 1);&#x2F;&#x2F;k从0开始\n    &#125;\n&#125;;\n&#x2F;&#x2F;另 https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;273&#x2F;\n\n\n&#x2F;&#x2F;法二 ？？？[3,2,3,1,2,4,5,5,6] 4--&gt;4  out:5???\n&#x2F;&#x2F;idea from https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;7585&#x2F;\nclass Solution &#123;\npublic:\n\n    int quick_sort(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123;\n        if (l &#x3D;&#x3D; r) return nums[k];\n        int x &#x3D; nums[l], i &#x3D; l - 1, j &#x3D; r + 1;&#x2F;&#x2F;-1 +1\n        while (i &lt; j) &#123;&#x2F;&#x2F;降序\n            do i ++ ; while (nums[i] &gt; x);&#x2F;&#x2F;&#x3D;&#x3D;  while(nums[++i] &gt; x);\n            do j -- ; while (nums[j] &lt; x);\n            if (i &lt; j) swap(nums[i], nums[j]);\n        &#125;\n        &#x2F;*\n        cout &lt;&lt; j;\n        for(auto x: nums)\n            cout &lt;&lt; x &lt;&lt; &#39; &#39;;\n        cout &lt;&lt; endl;\n        *&#x2F;\n        int s1 &#x3D; j - l + 1;\n        if (k &lt;&#x3D; s1) return quick_sort(nums, l, j, k);&#x2F;&#x2F;k &lt;&#x3D; s1 ！！！\n        else return quick_sort(nums, j + 1, r, k - s1);&#x2F;&#x2F;R中第k-s1大\n    &#125;\n\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        return quick_sort(nums, 0, nums.size() - 1, k - 1);&#x2F;&#x2F;k从0开始\n    &#125;\n&#125;;\n\n&#x2F;*\n(分治) 同上\n题解1:分治。\n借用快速排序的思想，第k大等于找第n - k + 1小的数。这里我们以找第k小为例，我们每次取区间头元素作为基准元素pivot，\n然后将区间内所有小于这个数的数字都放在基准元素之前，所有大于这个数的数字都放在基准元素之后。\n如果基准元素左边的数字个数len大于等于k，那么我们就去左边区间找第k小；如果基准元素恰好是第k小的，那么返回基准元素；\n否则我们去右半区间找到第k - len - 1小的元素。\n\n仅进入一侧递归在平均情况下数组长度会减半，故时间复杂度为 n+n&#x2F;2+n&#x2F;4+…+1&#x3D;O(n)n+n&#x2F;2+n&#x2F;4+…+1&#x3D;O(n)。\n*&#x2F;\n&#x2F;&#x2F;24ms\nclass Solution &#123;\npublic:\n    int getKth(vector&lt;int&gt;&amp;nums,int k,int l,int r)\n    &#123;\n        if(l &#x3D;&#x3D; r) return nums[l];\n        int pivot &#x3D; nums[l],i &#x3D; l , j &#x3D; r;\n        while(i &lt; j)\n        &#123;\n            while(i &lt; j &amp;&amp; nums[j] &gt;&#x3D; pivot) j --;\n            while(i &lt; j &amp;&amp; nums[i] &lt;&#x3D; pivot) i ++;\n            if(i &lt; j)\n                swap(nums[i],nums[j]);\n        &#125;\n        swap(nums[i],nums[l]);\n        if(i - l &gt;&#x3D; k) return getKth(nums,k,l, i - 1);&#x2F;&#x2F;\n        else if(i - l + 1 &#x3D;&#x3D; k) return nums[i];\n        else return getKth(nums,k - (i - l  + 1),i + 1,r);&#x2F;&#x2F;\n    &#125;\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        return getKth(nums, nums.size() - k + 1, 0 , nums.size() - 1);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;法三\n&#x2F;&#x2F;当然了，c++提供了nth_element函数，让我们把第k大&#x2F;小的元素（下标从0开始）放在对应的位置上，同时把小于该元素的元素都放在左边，大于该元素的元素都放在右边。\n&#x2F;&#x2F; 4ms\nclass Solution &#123;\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        nth_element(nums.begin(),nums.begin() + k - 1, nums.end(),greater&lt;int&gt;());\n        return nums[k - 1];\n    &#125;\n&#125;;\n\n作者：T-SHLoRk\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;4455&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;法四\n&#x2F;*\n(扫描一遍 维护一个小根堆） O(n∗logk)\n遍历数组，维护一个【大小为K的小根堆】\n为什么是小根堆，【堆顶元素是堆中最小，那么还在堆中的都比它大，没在堆内的都比它小。\n堆中有k个元素，那么他自然就是第K的最大元素了】\n找最大，用小根\n值得注意的是优先队列默认的是大根堆，所以声明的时候注意参数。\n\n时间复杂度 ： 线性扫描 O(n∗logk)\n空间复杂度 ： 额外的小根堆 O(k)\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;  &#x2F;&#x2F;小顶堆\n        for(auto x : nums)\n        &#123;\n            q.push(x);\n            if(q.size() &gt; k) q.pop();\n        &#125;\n        return q.top();\n    &#125;\n&#125;;\n\n作者：jasonlin\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;10789&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n<h1 id=\"—线性查找算法BFPRT小专题\"><a href=\"#—线性查找算法BFPRT小专题\" class=\"headerlink\" title=\"—线性查找算法BFPRT小专题\"></a>—线性查找算法BFPRT小专题</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">https:&#x2F;&#x2F;blog.csdn.net&#x2F;u012469528&#x2F;article&#x2F;details&#x2F;80762068\n&#x2F;**\n* BFPRT算法（前K小数问题）\n*\n* author    刘毅（Limer）\n* date      2017-01-25\n* mode      C++\n*&#x2F;\n \n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n \nint InsertSort(int  array[], int left, int right);                 &#x2F;&#x2F;插入排序，返回中位数下标\nint GetPivotIndex(int  array[], int left, int right);              &#x2F;&#x2F;返回中位数的中位数下标\nint Partition(int array[], int left, int right, int pivot_index);  &#x2F;&#x2F;利用中位数的中位数的下标进行划分，返回分界线下标\nint BFPRT(int array[], int left, int right, const int &amp; k);        &#x2F;&#x2F;求第k小，返回其位置的下标\n \nint main()\n&#123;\n    int k &#x3D; 5;\n    int array[10] &#x3D; &#123; 1,1,2,3,1,5,-1,7,8,-10 &#125;;\n \n    cout &lt;&lt; &quot;原数组：&quot;;\n    for (int i &#x3D; 0; i &lt; 10; i++)\n        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;第&quot; &lt;&lt; k &lt;&lt; &quot;小值为：&quot; &lt;&lt; array[BFPRT(array, 0, 9, k)] &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;变换后的数组：&quot;;\n    for (int i &#x3D; 0; i &lt; 10; i++)\n        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; endl;\n \n    return 0;\n&#125;\n \n&#x2F;* 插入排序，返回中位数下标 *&#x2F;\nint InsertSort(int array[], int left, int right)\n&#123;\n    int temp;\n    int j;\n    for (int i &#x3D; left + 1; i &lt;&#x3D; right; i++)\n    &#123;\n        temp &#x3D; array[i];\n        j &#x3D; i - 1;\n        while (j &gt;&#x3D; left &amp;&amp; array[j] &gt; temp)\n            array[j + 1] &#x3D; array[j--];\n        array[j + 1] &#x3D; temp;\n    &#125;\n \n    return ((right - left) &gt;&gt; 1) + left;\n&#125;\n \n&#x2F;* 返回中位数的中位数下标 *&#x2F;\nint GetPivotIndex(int array[], int left, int right)\n&#123;\n    if (right - left &lt; 5)\n        return InsertSort(array, left, right);\n \n    int sub_right &#x3D; left - 1;\n    for (int i &#x3D; left; i + 4 &lt;&#x3D; right; i +&#x3D; 5)\n    &#123;\n        int index &#x3D; InsertSort(array, i, i + 4);  &#x2F;&#x2F;找到五个元素的中位数的下标\n        swap(array[++sub_right], array[index]);   &#x2F;&#x2F;依次放在左侧\n    &#125;\n \n    return BFPRT(array, left, sub_right, ((sub_right - left + 1) &gt;&gt; 1) + 1);\n&#125;\n \n&#x2F;* 利用中位数的中位数的下标进行划分，返回分界线下标 *&#x2F;\nint Partition(int array[], int left, int right, int pivot_index)\n&#123;\n    swap(array[pivot_index], array[right]);  &#x2F;&#x2F;把基准放置于末尾\n \n    int divide_index &#x3D; left;  &#x2F;&#x2F;跟踪划分的分界线\n    for (int i &#x3D; left; i &lt; right; i++)\n    &#123;\n        if (array[i] &lt; array[right])\n            swap(array[divide_index++], array[i]);  &#x2F;&#x2F;比基准小的都放在左侧\n    &#125;\n \n    swap(array[divide_index], array[right]);  &#x2F;&#x2F;最后把基准换回来\n    return divide_index;\n&#125;\n \nint BFPRT(int array[], int left, int right, const int &amp; k)\n&#123;\n    int pivot_index &#x3D; GetPivotIndex(array, left, right);            &#x2F;&#x2F;得到中位数的中位数下标\n    int divide_index &#x3D; Partition(array, left, right, pivot_index);  &#x2F;&#x2F;进行划分，返回划分边界\n    int num &#x3D; divide_index - left + 1;\n    if (num &#x3D;&#x3D; k)\n        return divide_index;\n    else if (num &gt; k)\n        return BFPRT(array, left, divide_index - 1, k);\n    else\n        return BFPRT(array, divide_index + 1, right, k - num);\n&#125;\n\n\nBFPRT Java代码\nhttps:&#x2F;&#x2F;www.pianshen.com&#x2F;article&#x2F;390013042&#x2F;\n\n\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;5402&#x2F;\n</code></pre>\n\n\n\n<h1 id=\"216-组合总和III\"><a href=\"#216-组合总和III\" class=\"headerlink\" title=\"216.组合总和III\"></a>216.组合总和III</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;T&#x3D;k*C(k,9)\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;\n        dfs(1, n, k);\n        return ans;\n    &#125;\n\n    void dfs(int start, int n, int k) &#123;&#x2F;&#x2F;start~9 防止重复\n        if(!n) &#123;\n            if(!k) ans.push_back(path);\n        &#125; else if(k) &#123;\n            for(int i &#x3D; start; i &lt;&#x3D; 9; i++)&#x2F;&#x2F;\n                if(n &gt;&#x3D; i) &#123;\n                    path.push_back(i);\n                    dfs(i + 1, n - i, k - 1);&#x2F;&#x2F;min\n                    path.pop_back();\n                &#125;\n        &#125; &#x2F;&#x2F; else 不合法\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"217-存在重复元素-unordered-set-count-insert\"><a href=\"#217-存在重复元素-unordered-set-count-insert\" class=\"headerlink\" title=\"217.存在重复元素 unordered_set count insert\"></a>217.存在重复元素 unordered_set count insert</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;217.存在重复元素 unordered_set count insert\nclass Solution &#123;\npublic:\n    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;int&gt; S;\n        for(auto x: nums)\n            if(S.count(x)) return true;\n            else S.insert(x);\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"218-天际线问题-扫描线求轮廓-细节太多\"><a href=\"#218-天际线问题-扫描线求轮廓-细节太多\" class=\"headerlink\" title=\"218.天际线问题 扫描线求轮廓 细节太多\"></a>218.天际线问题 扫描线求轮廓 细节太多</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210523101318038.png\" alt=\"image-20210523101318038\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;2599&#x2F;1&#x2F;\n&#x2F;&#x2F;Acwing247亚特兰蒂斯 扫描线+求面积SegTree\n&#x2F;&#x2F;长条内max高度h，有+h&gt;max(入点)有-h&gt;max(出点)，堆不能删，用multiset，支持排序（java：TreeSet）\n&#x2F;&#x2F;vector&lt;pair&lt;int, int&gt;&gt; points;双关键字排序，&#123;L,-h&#125; &#123;R,h&#125; 保证正确的遍历顺序\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        vector&lt;pair&lt;int, int&gt;&gt; points;\n        multiset&lt;int&gt; heights;  &#x2F;&#x2F; *heights.rbegin()\n        for (auto&amp; b: buildings) &#123;\n            points.push_back(&#123;b[0], -b[2]&#125;);\n            points.push_back(&#123;b[1], b[2]&#125;);\n        &#125;\n        sort(points.begin(), points.end());\n        heights.insert(0);\n        for (auto&amp; p: points) &#123;  &#x2F;&#x2F; 注意+—顺序\n            int x &#x3D; p.first, h &#x3D; abs(p.second);\n            if (p.second &lt; 0) &#123;  &#x2F;&#x2F; 左端点\n                if (h &gt; *heights.rbegin())\n                    res.push_back(&#123;x, h&#125;);\n                heights.insert(h);\n            &#125; else &#123;  &#x2F;&#x2F; 右端点\n                heights.erase(heights.find(h));  &#x2F;&#x2F; 多删一，erase全删！\n                if (h &gt; *heights.rbegin()) \n                    res.push_back(&#123;x, *heights.rbegin()&#125;);\n            &#125;\n        &#125;\n\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"219-存在重复元素-II-间隔-lt-x3D-k-unordered-map-val-idx\"><a href=\"#219-存在重复元素-II-间隔-lt-x3D-k-unordered-map-val-idx\" class=\"headerlink\" title=\"219.存在重复元素 II(间隔&lt;&#x3D;k) unordered_map{val, idx}\"></a>219.存在重复元素 II(间隔&lt;&#x3D;k) unordered_map{val, idx}</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int, int&gt; hash; &#x2F;&#x2F;&#123;val, idx&#125;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            int x &#x3D; nums[i];\n            if (hash.count(x) &amp;&amp; i - hash[x] &lt;&#x3D; k) return true;\n            hash[x] &#x3D; i;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"220-存在重复元素-III-val差-lt-x3D-t-idx差-lt-x3D-k-multiset-S-x2F-x2F-支持重复-1e18-LL哨兵\"><a href=\"#220-存在重复元素-III-val差-lt-x3D-t-idx差-lt-x3D-k-multiset-S-x2F-x2F-支持重复-1e18-LL哨兵\" class=\"headerlink\" title=\"220.存在重复元素 III val差&lt;&#x3D;t, idx差&lt;&#x3D;k  multiset S;&#x2F;&#x2F;支持重复 +-1e18 LL哨兵\"></a>220.存在重复元素 III val差&lt;&#x3D;t, idx差&lt;&#x3D;k  multiset<LL> S;&#x2F;&#x2F;支持重复 +-1e18 LL哨兵</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210523105202920.png\" alt=\"image-20210523105202920\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;\n        typedef long long LL;\n        multiset&lt;LL&gt; S;&#x2F;&#x2F;支持重复 排序\n        S.insert(1e18), S.insert(-1e18);&#x2F;&#x2F;LL哨兵\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            if (i - j &gt; k) S.erase(S.find(nums[j ++ ]));&#x2F;&#x2F;\n            int x &#x3D; nums[i];\n            auto it &#x3D; S.lower_bound(x);&#x2F;&#x2F;&gt;&#x3D;x的min\n            if (*it - x &lt;&#x3D; t) return true;\n            -- it;&#x2F;&#x2F;&lt;x的max\n            if (x - *it &lt;&#x3D; t) return true;\n            S.insert(x);\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"221-最大正方形-全1-DP（85最大矩形）\"><a href=\"#221-最大正方形-全1-DP（85最大矩形）\" class=\"headerlink\" title=\"221. 最大正方形 全1 DP（85最大矩形）\"></a>221. 最大正方形 全1 DP（85最大矩形）</h1><p>反证 推矛盾</p>\n<img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210523113444949.png\" alt=\"image-20210523113444949\" style=\"zoom:200%;\" />\n\n<p>【图片待修复。。。】</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">![13021_4f46573090-leetcode221](C:\\Users\\bxl\\Desktop\\13021_4f46573090-leetcode221.png)？？\n&#x2F;&#x2F;221. 最大正方形 全1 DP（85最大矩形）\nclass Solution &#123;\npublic:\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        if (matrix.empty() || matrix[0].empty()) return 0;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1));\n\n        int res &#x3D; 0;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )\n                if (matrix[i - 1][j - 1] &#x3D;&#x3D; &#39;1&#39;) &#123;\n                    f[i][j] &#x3D; min(f[i - 1][j], min(f[i][j - 1], f[i - 1][j - 1])) + 1;&#x2F;&#x2F;\n                    res &#x3D; max(res, f[i][j]);&#x2F;&#x2F;\n                &#125;\n\n        return res * res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"222-完全二叉树的节点个数-有点小意思-二分O-logn∗logn-递归非均满\"><a href=\"#222-完全二叉树的节点个数-有点小意思-二分O-logn∗logn-递归非均满\" class=\"headerlink\" title=\"222.完全二叉树的节点个数[有点小意思~] 二分O(logn∗logn) 递归非均满\"></a>222.完全二叉树的节点个数[有点小意思~] 二分O(logn∗logn) 递归非均满</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210523115718221.png\" alt=\"image-20210523115718221\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n这道题相当于二分查找最后一层最后一个节点的位置，每次查找的复杂度是O(logn)，一共需要查找O(logn)次，所以复杂度为 O(logn∗logn)。\n最左点最右点深度&#x3D;&#x3D;：满二叉树 2^level - 1\n分界点(last one node) 在L(R)，L(R)非满\nn&#x3D;100w 2500倍增速！！！\n*&#x2F;\nclass Solution &#123;\npublic:\n    int countNodes(TreeNode* root) &#123;\n        if (!root) return 0;\n        auto l &#x3D; root-&gt;left, r &#x3D; root-&gt;right;\n        int x &#x3D; 1, y &#x3D; 1; &#x2F;&#x2F; 向L(R)走的次数\n        while (l) l &#x3D; l-&gt;left, x ++ ;\n        while (r) r &#x3D; r-&gt;right, y ++ ;\n        if (x &#x3D;&#x3D; y) return (1 &lt;&lt; x) - 1;&#x2F;&#x2F;\n        return countNodes(root-&gt;left) + 1 + countNodes(root-&gt;right);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"223-矩形面积-CG-并集-max-0-min-B-D-max-A-C-gt-2D\"><a href=\"#223-矩形面积-CG-并集-max-0-min-B-D-max-A-C-gt-2D\" class=\"headerlink\" title=\"223.矩形面积 CG 并集 max(0, min(B,D)-max(A,C)) -&gt; 2D\"></a>223.矩形面积 CG 并集 max(0, min(B,D)-max(A,C)) -&gt; 2D</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524102756136.png\" alt=\"image-20210524102756136\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524102916062.png\" alt=\"image-20210524102916062\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524102728939.png\" alt=\"image-20210524102728939\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">typedef long long LL;\n\nclass Solution &#123;\npublic:\n    int computeArea(LL A, LL B, LL C, LL D, LL E, LL F, LL G, LL H) &#123;\n        LL X &#x3D; max(0ll, min(C, G) - max(A, E));&#x2F;&#x2F;\n        LL Y &#x3D; max(0ll, min(D, H) - max(B, F));\n        return (C - A) * (D - B) + (G - E) * (H - F) - X * Y;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"224-基本计算器-acw表达式求值-4-num-push-0\"><a href=\"#224-基本计算器-acw表达式求值-4-num-push-0\" class=\"headerlink\" title=\"224.基本计算器 acw表达式求值(4) num.push(0)\"></a>224.基本计算器 acw表达式求值(4) num.push(0)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524104104367.png\" alt=\"image-20210524104104367\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;224.基本计算器 acw表达式求值(4)\n&#x2F;&#x2F;s 由数字、&#39;+&#39;、&#39;-&#39;、&#39;(&#39;、&#39;)&#39;、和 &#39; &#39; 组成\nclass Solution &#123;\npublic:\n    void eval(stack&lt;int&gt;&amp; num, stack&lt;char&gt;&amp; op) &#123;\n        auto b &#x3D; num.top(); num.pop();\n        auto a &#x3D; num.top(); num.pop();\n        auto c &#x3D; op.top(); op.pop();&#x2F;&#x2F;char\n        int r;\n        if (c &#x3D;&#x3D; &#39;+&#39;) r &#x3D; a + b;&#x2F;&#x2F;+-\n        else r &#x3D; a - b;\n        num.push(r);\n    &#125;\n\n    int calculate(string s) &#123;\n        stack&lt;int&gt; num;\n        stack&lt;char&gt; op;\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            auto c &#x3D; s[i];\n            if (c &#x3D;&#x3D; &#39; &#39;) continue;\n            if (isdigit(c)) &#123; &#x2F;&#x2F;\n                int x &#x3D; 0, j &#x3D; i;\n                while (j &lt; s.size() &amp;&amp; isdigit(s[j])) x &#x3D; x * 10 + (s[j ++ ] - &#39;0&#39;);&#x2F;&#x2F;()防溢出\n                i &#x3D; j - 1;&#x2F;&#x2F;j++ [i&#x3D;j-1] i++\n                num.push(x);\n            &#125; else if (c &#x3D;&#x3D; &#39;(&#39;) op.push(c);\n            else if (c &#x3D;&#x3D; &#39;)&#39;) &#123;\n                while (op.top() !&#x3D; &#39;(&#39;) eval(num, op);\n                op.pop();&#x2F;&#x2F;pop&#39;(&#39;\n            &#125; else &#123;\n                if (!i || s[i - 1] &#x3D;&#x3D; &#39;(&#39; || s[i - 1] &#x3D;&#x3D; &#39;+&#39; || s[i - 1] &#x3D;&#x3D; &#39;-&#39;)  &#x2F;&#x2F; 特殊处理符号和正号\n                    num.push(0);&#x2F;&#x2F;!!!!!\n                while (op.size() &amp;&amp; op.top() !&#x3D; &#39;(&#39;) eval(num, op);&#x2F;&#x2F;op.top() !&#x3D; &#39;(&#39;  result\n                op.push(c);&#x2F;&#x2F;push op\n            &#125;\n        &#125;\n        while (op.size()) eval(num, op);&#x2F;&#x2F;op.push(c);\n        return num.top();\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"225-用队列实现栈-2q-gt-1stk\"><a href=\"#225-用队列实现栈-2q-gt-1stk\" class=\"headerlink\" title=\"225.用队列实现栈 2q-&gt;1stk\"></a>225.用队列实现栈 2q-&gt;1stk</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class MyStack &#123;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n\n    queue&lt;int&gt; q, w;\n    MyStack() &#123;\n\n    &#125;\n\n    &#x2F;** Push element x onto stack. *&#x2F;\n    void push(int x) &#123;\n        q.push(x);\n    &#125;\n\n    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;\n    int pop() &#123;\n        while (q.size() &gt; 1) w.push(q.front()), q.pop();\n        int t &#x3D; q.front();\n        q.pop();&#x2F;&#x2F;\n        while (w.size()) q.push(w.front()), w.pop();\n        return t;\n    &#125;\n\n    &#x2F;** Get the top element. *&#x2F;\n    int top() &#123;\n        while (q.size() &gt; 1) w.push(q.front()), q.pop();\n        int t &#x3D; q.front();\n        q.pop();\n        while (w.size()) q.push(w.front()), w.pop();\n        q.push(t);&#x2F;&#x2F;\n        return t;\n    &#125;\n\n    &#x2F;** Returns whether the stack is empty. *&#x2F;\n    bool empty() &#123;\n        return q.empty();\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"226-翻转二叉树-swap-l-r\"><a href=\"#226-翻转二叉树-swap-l-r\" class=\"headerlink\" title=\"226.翻转二叉树 swap(l,r)\"></a>226.翻转二叉树 swap(l,r)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;226.翻转二叉树 swap(l,r)\nclass Solution &#123;\npublic:\n    TreeNode* invertTree(TreeNode* root) &#123;\n        if (!root) return NULL;\n        swap(root-&gt;left, root-&gt;right);&#x2F;&#x2F;\n        invertTree(root-&gt;left);\n        invertTree(root-&gt;right);\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"227-基本计算器-II-模板题-x2F-unordered-map-lt-char-int-gt-pr\"><a href=\"#227-基本计算器-II-模板题-x2F-unordered-map-lt-char-int-gt-pr\" class=\"headerlink\" title=\"227.基本计算器 II  模板题 *&#x2F;  unordered_map&lt;char, int&gt; pr\"></a>227.基本计算器 II  模板题 *&#x2F;  unordered_map&lt;char, int&gt; pr</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;227. 基本计算器 II  模板题\n&#x2F;&#x2F;+-*&#x2F; SPACE,无括号\nclass Solution &#123;\npublic:\n    stack&lt;int&gt; num;\n    stack&lt;char&gt; op;\n\n    void eval() &#123;\n        int b &#x3D; num.top(); num.pop();\n        int a &#x3D; num.top(); num.pop();\n        char c &#x3D; op.top(); op.pop();\n        int r;\n        if (c &#x3D;&#x3D; &#39;+&#39;) r &#x3D; a + b;\n        else if (c &#x3D;&#x3D; &#39;-&#39;) r &#x3D; a - b;\n        else if (c &#x3D;&#x3D; &#39;*&#39;) r &#x3D; a * b;\n        else r &#x3D; a &#x2F; b;\n        num.push(r);\n    &#125;\n\n    int calculate(string s) &#123;\n        unordered_map&lt;char, int&gt; pr;&#x2F;&#x2F;optr_priority\n        pr[&#39;+&#39;] &#x3D; pr[&#39;-&#39;] &#x3D; 1, pr[&#39;*&#39;] &#x3D; pr[&#39;&#x2F;&#39;] &#x3D; 2;\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            char c &#x3D; s[i];\n            if (c &#x3D;&#x3D; &#39; &#39;) continue;\n            if (isdigit(c)) &#123;\n                int x &#x3D; 0, j &#x3D; i;\n                while (j &lt; s.size() &amp;&amp; isdigit(s[j])) x &#x3D; x * 10 + (s[j ++ ] - &#39;0&#39;);\n                num.push(x);\n                i &#x3D; j - 1;\n            &#125; else &#123;\n                while (op.size() &amp;&amp; pr[op.top()] &gt;&#x3D; pr[c]) eval();\n                op.push(c);\n            &#125;\n        &#125;\n        while (op.size()) eval();\n        return num.top();\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"228-汇总区间-连续i-j-双指针\"><a href=\"#228-汇总区间-连续i-j-双指针\" class=\"headerlink\" title=\"228.汇总区间 连续i~j 双指针\"></a>228.汇总区间 连续i~j 双指针</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;228.汇总区间 连续i~j 双指针\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;string&gt; res;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            int j &#x3D; i + 1;\n            while (j &lt; nums.size() &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1] + 1) j ++ ;\n            if (j &#x3D;&#x3D; i + 1) res.push_back(to_string(nums[i]));\n            else res.push_back(to_string(nums[i]) + &quot;-&gt;&quot; + to_string(nums[j - 1]));&#x2F;&#x2F;范围range\n            i &#x3D; j - 1;&#x2F;&#x2F;i ++\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"229-求众数-II-gt-n-x2F-3-169多数元素-n-x2F-2-摩尔投票法n-x2F-k-BM！\"><a href=\"#229-求众数-II-gt-n-x2F-3-169多数元素-n-x2F-2-摩尔投票法n-x2F-k-BM！\" class=\"headerlink\" title=\"229.求众数 II &gt;n&#x2F;3 (169多数元素:n&#x2F;2 摩尔投票法n&#x2F;k BM！)\"></a>229.求众数 II &gt;n&#x2F;3 (169多数元素:n&#x2F;2 摩尔投票法n&#x2F;k BM！)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524120729548.png\" alt=\"image-20210524120729548\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;229.求众数 II (169多数元素:n&#x2F;2 摩尔投票法n&#x2F;k BM！) &gt;n&#x2F;3\n&#x2F;&#x2F;https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;294&#x2F;\n&#x2F;&#x2F;摩尔投票算法(Boyer–Moore majority vote algorithm)又名多数投票算法，通过线性时间和常数空间来查找数组中的多数元素\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        int r1, r2, c1 &#x3D; 0, c2 &#x3D; 0;\n        for (auto x: nums)&#x2F;&#x2F;r12\n            if (c1 &amp;&amp; x &#x3D;&#x3D; r1) c1 ++ ;\n            else if (c2 &amp;&amp; x &#x3D;&#x3D; r2) c2 ++ ;\n            else if (!c1) r1 &#x3D; x, c1 ++ ;\n            else if (!c2) r2 &#x3D; x, c2 ++ ;\n            else c1 --, c2 -- ;\n        c1 &#x3D; 0, c2 &#x3D; 0;\n        for (auto x: nums)&#x2F;&#x2F;c12\n            if (x &#x3D;&#x3D; r1) c1 ++ ;\n            else if (x &#x3D;&#x3D; r2) c2 ++ ;\n\n        vector&lt;int&gt; res;\n        int n &#x3D; nums.size();\n        if (c1 &gt; n &#x2F; 3) res.push_back(r1);&#x2F;&#x2F;judge c12&gt;n&#x2F;3\n        if (c2 &gt; n &#x2F; 3) res.push_back(r2);\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"230-二叉搜索树中第K小的元素\"><a href=\"#230-二叉搜索树中第K小的元素\" class=\"headerlink\" title=\"230.二叉搜索树中第K小的元素\"></a>230.二叉搜索树中第K小的元素</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;230.二叉搜索树中第K小的元素 bool dfs提前返回:O(k) --k&#x3D;&#x3D;0\nclass Solution &#123;\npublic:\n    int k, ans;\n\n    int kthSmallest(TreeNode* root, int _k) &#123;\n        k &#x3D; _k;\n        dfs(root);\n        return ans;\n    &#125;\n\n    bool dfs(TreeNode* root) &#123;\n        if (!root) return false;\n        if (dfs(root-&gt;left)) return true;&#x2F;&#x2F;bool dfs提前返回\n        if ( -- k &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;--k&#x3D;&#x3D;0\n            ans &#x3D; root-&gt;val;\n            return true;\n        &#125;\n        return dfs(root-&gt;right);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;进阶：如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？\n&#x2F;*\n如果该树经常被修改，那么树可能会变成不平衡的，即树高由 O(logn) 变为 O(n)。\n使用Splay树或者Treap等平衡二叉树可以保证树高 h 是 O(log⁡n)级别的，\n如果我们在结点中增加一个cnt属性来记录以该节点为根的子树的节点个数，那么我们就可以在 O(h) 的时间内找到第k大的元素。\n*&#x2F;\nclass Solution &#123;\npublic: \n    int kthSmallest(TreeNode* root, int k) &#123;\n        int num &#x3D; count(root-&gt;left);   \n        if(num &gt;&#x3D; k)&#123;\n            return kthSmallest(root-&gt;left, k);\n        &#125;else if(num + 1 &lt; k)&#123;\n            return kthSmallest(root-&gt;right, k - num - 1);\n        &#125;\n        return root-&gt;val;\n    &#125;\n    \n    int count(TreeNode* root)&#123;\n        if(!root) return 0;\n        return 1 + count(root-&gt;left) + count(root-&gt;right);\n    &#125;\n    &#x2F;&#x2F;实现insert delete函数。。。\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"231-2的幂-n-gt-0-amp-amp-n-amp-n-x3D-x3D-n\"><a href=\"#231-2的幂-n-gt-0-amp-amp-n-amp-n-x3D-x3D-n\" class=\"headerlink\" title=\"231.2的幂 n &gt; 0 &amp;&amp; (n &amp; -n) &#x3D;&#x3D; n;\"></a>231.2的幂 n &gt; 0 &amp;&amp; (n &amp; -n) &#x3D;&#x3D; n;</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isPowerOfTwo(int n) &#123;\n        return n &gt; 0 &amp;&amp; (n &amp; -n) &#x3D;&#x3D; n;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"232-用栈实现队列-225\"><a href=\"#232-用栈实现队列-225\" class=\"headerlink\" title=\"232.用栈实现队列(225)\"></a>232.用栈实现队列(225)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class MyQueue &#123;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    stack&lt;int&gt; a, b;\n    MyQueue() &#123;\n\n    &#125;\n    \n    &#x2F;** Push element x to the back of queue. *&#x2F;\n    void push(int x) &#123;\n        a.push(x);\n    &#125;\n\n    &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;\n    int pop() &#123;\n        while (a.size() &gt; 1) b.push(a.top()), a.pop();\n        int t &#x3D; a.top();\n        a.pop();&#x2F;&#x2F;\n        while (b.size()) a.push(b.top()), b.pop();\n        return t;\n    &#125;\n\n    &#x2F;** Get the front element. *&#x2F;\n    int peek() &#123;\n        while (a.size() &gt; 1) b.push(a.top()), a.pop();\n        int t &#x3D; a.top();\n        while (b.size()) a.push(b.top()), b.pop();\n        return t;\n    &#125;\n\n    &#x2F;** Returns whether the queue is empty. *&#x2F;\n    bool empty() &#123;\n        return a.empty();\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"—-难！-233-数字-1-的个数-分类讨论-L-R-10-p-acw338计数问题-基础课-蓝书DP\"><a href=\"#—-难！-233-数字-1-的个数-分类讨论-L-R-10-p-acw338计数问题-基础课-蓝书DP\" class=\"headerlink\" title=\"—[难！]233.数字 1 的个数 分类讨论 L R 10^p acw338计数问题(基础课)蓝书DP\"></a>—[难！]233.数字 1 的个数 分类讨论 L R 10^p acw338计数问题(基础课)蓝书DP</h1><p>acw338（更通用：数字 x(0~9) 的个数）</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524165625133.png\" alt=\"image-20210524165625133\"></p>\n<p>本题x&#x3D;&#x3D;1 &gt;0</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524171223413.png\" alt=\"image-20210524171223413\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524170612544.png\" alt=\"image-20210524170612544\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210524162230257.png\" alt=\"image-20210524162230257\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int countDigitOne(int n) &#123;\n        if (n &lt;&#x3D; 0) return 0;&#x2F;&#x2F;\n        vector&lt;int&gt; nums;\n        while (n) nums.push_back(n % 10), n &#x2F;&#x3D; 10;\n        reverse(nums.begin(), nums.end());\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            int d &#x3D; nums[i];\n            int left &#x3D; 0, right &#x3D; 0, p &#x3D; 1;\n            for (int j &#x3D; 0; j &lt; i; j ++ ) left &#x3D; left * 10 + nums[j];\n            for (int j &#x3D; i + 1; j &lt; nums.size(); j ++ ) &#123;\n                right &#x3D; right * 10 + nums[j];\n                p &#x3D; p * 10;&#x2F;&#x2F;\n            &#125;\n            if (d &#x3D;&#x3D; 0) res +&#x3D; left * p;\n            else if (d &#x3D;&#x3D; 1) res +&#x3D; left * p + right + 1;\n            else res +&#x3D; (left + 1) * p;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;另：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;280&#x2F;</code></pre>\n\n\n\n<h1 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234.回文链表\"></a>234.回文链表</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;234.回文链表\n&#x2F;&#x2F;reverse 恢复 数数法：n-half half-1\nclass Solution &#123;\npublic:\n    bool isPalindrome(ListNode* head) &#123;\n        int n &#x3D; 0;\n        for (auto p &#x3D; head; p; p &#x3D; p-&gt;next) n ++ ;\n        if (n &lt;&#x3D; 1) return true;\n        int half &#x3D; n &#x2F; 2;\n        auto a &#x3D; head;\n        for (int i &#x3D; 0; i &lt; n - half; i ++ ) a &#x3D; a-&gt;next;\n        auto b &#x3D; a-&gt;next;\n        for (int i &#x3D; 0; i &lt; half - 1; i ++ ) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n\n        auto p &#x3D; head, q &#x3D; a;\n        bool success &#x3D; true;\n        for (int i &#x3D; 0; i &lt; half; i ++ ) &#123;\n            if (p-&gt;val !&#x3D; q-&gt;val) &#123;\n                success &#x3D; false;\n                break;\n            &#125;\n            p &#x3D; p-&gt;next;\n            q &#x3D; q-&gt;next;\n        &#125;\n\n        auto tail &#x3D; a;\n        b &#x3D; a-&gt;next;\n        &#x2F;&#x2F; 将链表恢复原状\n        for (int i &#x3D; 0; i &lt; half - 1; i ++ ) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n\n        tail-&gt;next &#x3D; NULL;\n        return success;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;快慢指针法\n</code></pre>\n\n\n\n<h1 id=\"235-二叉搜索树的最近公共祖先LCA-递归simple-O-h\"><a href=\"#235-二叉搜索树的最近公共祖先LCA-递归simple-O-h\" class=\"headerlink\" title=\"235.二叉搜索树的最近公共祖先LCA 递归simple O(h)\"></a>235.二叉搜索树的最近公共祖先LCA 递归simple O(h)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        if(p-&gt;val &gt; q-&gt;val) swap(p, q);&#x2F;&#x2F;SBT\n        if(p-&gt;val &lt;&#x3D; root-&gt;val &amp;&amp; q-&gt;val &gt;&#x3D; root-&gt;val) return root;\n        if(q-&gt;val &lt;&#x3D; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p , q);\n        else return lowestCommonAncestor(root-&gt;right, p, q);\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"236-二叉树的最近公共祖先-LR都递归-O-n-dfs-第一次找到同时包含pq-state-x3D-x3D-3-的子树\"><a href=\"#236-二叉树的最近公共祖先-LR都递归-O-n-dfs-第一次找到同时包含pq-state-x3D-x3D-3-的子树\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先 LR都递归 O(n) dfs 第一次找到同时包含pq(state &#x3D;&#x3D; 3)的子树\"></a>236. 二叉树的最近公共祖先 LR都递归 O(n) dfs 第一次找到同时包含pq(state &#x3D;&#x3D; 3)的子树</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    TreeNode* ans &#x3D; NULL;\n\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        dfs(root, p, q);\n        return ans;\n    &#125;\n\n    int dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        if(!root) return 0;\n        \n        int state &#x3D; dfs(root-&gt;left, p, q);&#x2F;&#x2F;state&#x3D;[q][p]&#x3D;00&#x2F;01&#x2F;10&#x2F;11\n        if(root &#x3D;&#x3D; p) state |&#x3D; 1;\n        else if(root &#x3D;&#x3D; q) state |&#x3D; 2;\n        state |&#x3D; dfs(root-&gt;right, p, q);\n        \n        if(state &#x3D;&#x3D; 3 &amp;&amp; !ans) ans &#x3D; root;&#x2F;&#x2F;ans第一次赋值\n        return state;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"237-删除链表中的节点：-node-x3D-node-gt-next\"><a href=\"#237-删除链表中的节点：-node-x3D-node-gt-next\" class=\"headerlink\" title=\"237. 删除链表中的节点：*node &#x3D; *node-&gt;next;\"></a>237. 删除链表中的节点：*node &#x3D; *node-&gt;next;</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void deleteNode(ListNode* node) &#123;\n        node-&gt;val &#x3D; node-&gt;next-&gt;val;&#x2F;&#x2F;后继val覆盖\n        node-&gt;next &#x3D; node-&gt;next-&gt;next;&#x2F;&#x2F;删后继\n    &#125;\n&#125;;\n&#x2F;&#x2F;等价写法\nclass Solution &#123;\npublic:\n    void deleteNode(ListNode* node) &#123;\n        *node &#x3D; *node-&gt;next;&#x2F;&#x2F;结构体赋值\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"238-除自身以外数组的乘积-前后缀分解！\"><a href=\"#238-除自身以外数组的乘积-前后缀分解！\" class=\"headerlink\" title=\"238. 除自身以外数组的乘积[前后缀分解！]\"></a>238. 除自身以外数组的乘积[前后缀分解！]</h1><p>常数空间，只能开一个数组Pi：Si&#x3D;S变量累乘  bi&#x3D;&#x3D;Pi*S</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210803163045732.png\" alt=\"image-20210803163045732\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; p(n, 1);&#x2F;&#x2F;vector&lt;int&gt; p(size, init)\n        for(int i &#x3D; 1; i &lt; n; i++) p[i] &#x3D; p[i - 1] * nums[i - 1];&#x2F;&#x2F;p0&#x3D;1 1~n-1\n        for(int i &#x3D; n - 1, s &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;&#x2F;&#x2F;s[n-1]&#x3D;1 n-2~0\n            p[i] *&#x3D; s;\n            s *&#x3D; nums[i];\n        &#125;\n        return p;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"239-滑动窗口最大值-单调队列：在左还低-x3D-被优化掉\"><a href=\"#239-滑动窗口最大值-单调队列：在左还低-x3D-被优化掉\" class=\"headerlink\" title=\"239. 滑动窗口最大值[单调队列：在左还低&#x3D;被优化掉]\"></a>239. 滑动窗口最大值[单调队列：在左还低&#x3D;被优化掉]</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210803170230622.png\" alt=\"image-20210803170230622\"></p>\n<p>左- 右—–+</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;\n        deque&lt;int&gt; q;&#x2F;&#x2F;存idx\n        vector&lt;int&gt; res;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;&#x2F;&#x2F;q[L:i-k+1&gt;&#x3D;0  ~k个~  R:i&gt;&#x3D;k-1]\n            if(q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front();&#x2F;&#x2F;idx: L&gt;front pop\n            while(q.size() &amp;&amp; nums[i] &gt;&#x3D; nums[q.back()]) q.pop_back();&#x2F;&#x2F;val\n            q.push_back(i);\n            if(i &gt;&#x3D; k - 1) res.push_back(nums[q.front()]);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"240-搜索二维矩阵-II-右上角\"><a href=\"#240-搜索二维矩阵-II-右上角\" class=\"headerlink\" title=\"240. 搜索二维矩阵 II 右上角\"></a>240. 搜索二维矩阵 II 右上角</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210803173035152.png\" alt=\"image-20210803173035152\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;\n        if(matrix.empty() || matrix[0].empty()) return false;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        int i &#x3D; 0, j &#x3D; matrix[0].size();\n        while(i &lt; n &amp;&amp; j &gt;&#x3D; 0) &#123;\n            int t &#x3D; matrix[i][j];\n            if(t &#x3D;&#x3D; target) return true;\n            else if(t &lt; target) i++;\n            else j--;\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"24-为运算表达式设计优先级-加括号的所有运算结果-expr-L-R-LR递归dfs-（同LC95）\"><a href=\"#24-为运算表达式设计优先级-加括号的所有运算结果-expr-L-R-LR递归dfs-（同LC95）\" class=\"headerlink\" title=\"24. 为运算表达式设计优先级 加括号的所有运算结果:expr L+-*R LR递归dfs （同LC95）\"></a>24. 为运算表达式设计优先级 加括号的所有运算结果:expr L+-*R LR递归dfs （同LC95）</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;241. 为运算表达式设计优先级 加括号的所有运算结果:expr L+-*R LR递归dfs\n&#x2F;&#x2F;加括号的所有运算结果&#x3D;所有SBT 中缀表达式&#x3D;&#x3D;表达式树 ()&#x3D;子树 SBT子树不同，但中序遍历&#x3D;，结果&#x3D;\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; expr;\n\n    vector&lt;int&gt; diffWaysToCompute(string s) &#123;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(isdigit(s[i])) &#123;\n                int j &#x3D; i, x &#x3D; 0;\n                while(j &lt; s.size() &amp;&amp; isdigit(s[j])) x &#x3D; x * 10 + (s[j++] - &#39;0&#39;);\n                i &#x3D; j - 1; &#x2F;&#x2F; i++\n                expr.push_back(to_string(x));\n            &#125; else expr.push_back(s.substr(i, 1));\n        &#125;\n        return dfs(0, expr.size() - 1);\n    &#125;\n\n    vector&lt;int&gt; dfs(int l, int r) &#123;\n        if(l &#x3D;&#x3D; r) return &#123;stoi(expr[l])&#125;;&#x2F;&#x2F;\n        vector&lt;int&gt; res;\n        for(int i &#x3D; l + 1; i &lt; r; i +&#x3D; 2) &#123;\n            auto left &#x3D; dfs(l, i - 1), right &#x3D; dfs(i + 1, r);\n            for(auto x: left)\n                for(auto y: right) &#123;\n                    int z;\n                    if(expr[i] &#x3D;&#x3D; &quot;+&quot;) z &#x3D; x + y;\n                    else if(expr[i] &#x3D;&#x3D; &quot;-&quot;) z &#x3D; x - y;\n                    else z &#x3D; x * y;\n                    res.push_back(z);\n                &#125;\n        &#125;\n        return res;\n    &#125;  \n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"242-有效的字母异位词-哈希表-str：unicode1个字符-x3D-2个char\"><a href=\"#242-有效的字母异位词-哈希表-str：unicode1个字符-x3D-2个char\" class=\"headerlink\" title=\"242. 有效的字母异位词 哈希表 str：unicode1个字符&#x3D;2个char\"></a>242. 有效的字母异位词 哈希表 str：unicode1个字符&#x3D;2个char</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;红黑树map:有序性 哈希表unordered_map:查找O(1)\nclass Solution &#123;\npublic:\n    bool isAnagram(string s, string t) &#123;\n        unordered_map&lt;char, int&gt; a, b;&#x2F;&#x2F;&#123;pair&#123;,&#125;&#125;\n        for(auto c: s) a[c] ++;&#x2F;&#x2F;cnt\n        for(auto c: t) b[c] ++;\n        return a &#x3D;&#x3D; b;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"243\"><a href=\"#243\" class=\"headerlink\" title=\"243.\"></a>243.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"244\"><a href=\"#244\" class=\"headerlink\" title=\"244.\"></a>244.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"245\"><a href=\"#245\" class=\"headerlink\" title=\"245.\"></a>245.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"246\"><a href=\"#246\" class=\"headerlink\" title=\"246.\"></a>246.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"247\"><a href=\"#247\" class=\"headerlink\" title=\"247.\"></a>247.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"248\"><a href=\"#248\" class=\"headerlink\" title=\"248.\"></a>248.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"249\"><a href=\"#249\" class=\"headerlink\" title=\"249.\"></a>249.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"250\"><a href=\"#250\" class=\"headerlink\" title=\"250.\"></a>250.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"251\"><a href=\"#251\" class=\"headerlink\" title=\"251\"></a>251</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"252\"><a href=\"#252\" class=\"headerlink\" title=\"252.\"></a>252.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"253\"><a href=\"#253\" class=\"headerlink\" title=\"253.\"></a>253.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"254\"><a href=\"#254\" class=\"headerlink\" title=\"254.\"></a>254.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"255\"><a href=\"#255\" class=\"headerlink\" title=\"255.\"></a>255.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"256\"><a href=\"#256\" class=\"headerlink\" title=\"256.\"></a>256.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"257-二叉树的所有路径-dfs\"><a href=\"#257-二叉树的所有路径-dfs\" class=\"headerlink\" title=\"257.二叉树的所有路径 dfs\"></a>257.二叉树的所有路径 dfs</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804100835255.png\" alt=\"image-20210804100835255\"></p>\n<p>完全二叉树</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804101753633.png\" alt=\"image-20210804101753633\"></p>\n<p>要存路径，最坏O($n^2$)</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;257. 二叉树的所有路径 不加&amp;str参：O(n*n) 不知道字符长度，不如vec好写\n&#x2F;&#x2F;存路径，要回溯，最坏O($n^2$)\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;int&gt; path; \n\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;\n        if(root) dfs(root);\n        return ans;\n    &#125;\n\n    void dfs(TreeNode* root) &#123;\n        path.push_back(root-&gt;val);&#x2F;&#x2F;root !&#x3D; NULL\n        if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;\n            string line &#x3D; to_string(path[0]);&#x2F;&#x2F;\n            for(int i &#x3D; 1; i &lt; path.size(); i++)\n                line +&#x3D; &quot;-&gt;&quot; + to_string(path[i]);\n            ans.push_back(line);\n        &#125; else &#123;\n            if(root-&gt;left) dfs(root-&gt;left);&#x2F;&#x2F;\n            if(root-&gt;right) dfs(root-&gt;right);\n        &#125;\n        path.pop_back();&#x2F;&#x2F;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"258-各位相加-直到结果为一位数-小学奥数-同余-10-n-mod9-x3D-1-f-x-9-x3D-x-9\"><a href=\"#258-各位相加-直到结果为一位数-小学奥数-同余-10-n-mod9-x3D-1-f-x-9-x3D-x-9\" class=\"headerlink\" title=\"258.各位相加 直到结果为一位数 小学奥数 同余 (10^n)mod9&#x3D;1 f(x)%9&#x3D;x%9\"></a>258.各位相加 直到结果为一位数 小学奥数 同余 (10^n)mod9&#x3D;1 f(x)%9&#x3D;x%9</h1><p>小学奥数：同余 $(10^n)mod9&#x3D;1$</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804104416271.png\" alt=\"image-20210804104416271\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;258.各位相加 直到结果为一位数。\n&#x2F;&#x2F;不使用循环或者递归【不模拟】，O(1)：小学奥数 同余 (10^n)mod9&#x3D;1\nclass Solution &#123;\npublic:\n    int addDigits(int num) &#123;\n        if(!num) return 0;&#x2F;&#x2F;0 0\n        if(num % 9) return num % 9;&#x2F;&#x2F;num%9&#x3D;1~8 1~8\n        return 9;&#x2F;&#x2F;num%9&#x3D;&#x3D;0 9\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"259\"><a href=\"#259\" class=\"headerlink\" title=\"259.\"></a>259.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"260-只出现一次的数字-III-2次中-2个-1次val\"><a href=\"#260-只出现一次的数字-III-2次中-2个-1次val\" class=\"headerlink\" title=\"260.只出现一次的数字 III  2次中[2个]1次val\"></a>260.只出现一次的数字 III  2次中[2个]1次val</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804105817671.png\" alt=\"image-20210804105817671\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;260.只出现一次的数字 III  2次中[2个]1次val\n&#x2F;&#x2F;2次中1次:^  分类，拆分成之前子问题\n&#x2F;&#x2F;lowbit(x) &#x3D; x&amp;(-x) &#x3D; x&amp;(x^(x-1)) &#x3D; 1 2 4 8 树状数组 状态压缩DP\nclass Solution &#123;\npublic:\n\tint get(vector&lt;int&gt;&amp; nums, int k, int t) &#123;\n\t\tint res &#x3D; 0;\n\t\tfor(auto x: nums)\n\t\t\tif((x &gt;&gt; k &amp; 1) &#x3D;&#x3D; t)&#x2F;&#x2F;第k位是0 1\n\t\t\t\tres ^&#x3D; x;\n\t\treturn res;\n\t&#125;\n\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n    \tint ab &#x3D; 0;\n    \tfor(auto x:nums) ab ^&#x3D; x;\n    \tint k &#x3D; 0;\n    \twhile((ab &gt;&gt; k &amp; 1) &#x3D;&#x3D; 0) k++;&#x2F;&#x2F;a b第k位不同\n        return &#123;get(nums, k, 0), get(nums, k, 1)&#125;;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"261\"><a href=\"#261\" class=\"headerlink\" title=\"261\"></a>261</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"262\"><a href=\"#262\" class=\"headerlink\" title=\"262.\"></a>262.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"263-丑数-只包含质因数-2-3-5-的正整数-把235除干净-x3D-x3D-1\"><a href=\"#263-丑数-只包含质因数-2-3-5-的正整数-把235除干净-x3D-x3D-1\" class=\"headerlink\" title=\"263.丑数  只包含质因数 2 3 5 的正整数 把235除干净&#x3D;&#x3D;1\"></a>263.丑数  只包含质因数 2 3 5 的正整数 把235除干净&#x3D;&#x3D;1</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;263.丑数 只包含质因数 2 3 5 的正整数 把235除干净&#x3D;&#x3D;1\nclass Solution &#123;\npublic:\n    bool isUgly(int n) &#123;\n        if(n &lt;&#x3D; 0) return false;\n        while(n % 2 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 2;\n        while(n % 3 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 3;\n        while(n % 5 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 5;\n        return n &#x3D;&#x3D; 1;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"264-丑数II-nth-多路归并\"><a href=\"#264-丑数II-nth-多路归并\" class=\"headerlink\" title=\"264.丑数II nth 多路归并\"></a>264.丑数II nth 多路归并</h1><p>包含因子2 3 5的所有丑数 并 1</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804120137655.png\" alt=\"image-20210804120137655\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;264.丑数II nth 多路归并\nclass Solution &#123;\npublic:\n    int nthUglyNumber(int n) &#123;\n        vector&lt;int&gt; q(1, 1);\n        for(int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0; q.size() &lt; n;) &#123;\n            int t &#x3D; min(q[i] * 2, min(q[j] * 3, q[k] * 5));&#x2F;&#x2F;嵌套丑数生成\n            q.push_back(t);\n            if(q[i] * 2 &#x3D;&#x3D; t) i ++ ;\n            if(q[j] * 3 &#x3D;&#x3D; t) j ++ ;&#x2F;&#x2F;不能else if,凡是&#x3D;&#x3D;t都要++后移\n            if(q[k] * 5 &#x3D;&#x3D; t) k ++ ;\n        &#125;\n        return q.back();\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"265\"><a href=\"#265\" class=\"headerlink\" title=\"265.\"></a>265.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"266\"><a href=\"#266\" class=\"headerlink\" title=\"266.\"></a>266.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"267\"><a href=\"#267\" class=\"headerlink\" title=\"267.\"></a>267.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"268-缺失数字-0-n-n-n-1-x2F-2-sum\"><a href=\"#268-缺失数字-0-n-n-n-1-x2F-2-sum\" class=\"headerlink\" title=\"268.缺失数字 0~n n(n+1)&#x2F;2-sum\"></a>268.缺失数字 0~n n(n+1)&#x2F;2-sum</h1><p>小学奥数：翻书页，找到撕掉哪一页</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int res &#x3D; n * (n + 1) &#x2F; 2;\n        for(auto x: nums) res -&#x3D; x;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"269\"><a href=\"#269\" class=\"headerlink\" title=\"269.\"></a>269.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"270\"><a href=\"#270\" class=\"headerlink\" title=\"270.\"></a>270.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"271\"><a href=\"#271\" class=\"headerlink\" title=\"271\"></a>271</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"272\"><a href=\"#272\" class=\"headerlink\" title=\"272.\"></a>272.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"273-整数转换英文表示-难模拟\"><a href=\"#273-整数转换英文表示-难模拟\" class=\"headerlink\" title=\"273.整数转换英文表示 难模拟\"></a>273.整数转换英文表示 难模拟</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804121658761.png\" alt=\"image-20210804121658761\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;str_array\n    string num0_19[20] &#x3D; &#123;\n        &quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;,\n        &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;,\n        &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;,\n        &quot;Nineteen&quot;,\n    &#125;;\n    string num20_90[8] &#x3D; &#123;\n        &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;,\n        &quot;Eighty&quot;, &quot;Ninety&quot;,\n    &#125;;\n    string num1000[4] &#x3D; &#123;\n        &quot;Billion &quot;, &quot;Million &quot;, &quot;Thousand &quot;, &quot;&quot;,&#x2F;&#x2F;j++\n    &#125;;\n\n    string get(int x) &#123;  &#x2F;&#x2F; 返回1 ~ 999的英文表示\n        string res;\n        if (x &gt;&#x3D; 100) &#123;\n            res +&#x3D; num0_19[x &#x2F; 100] + &quot; Hundred &quot;;\n            x %&#x3D; 100;\n        &#125;\n        if (x &gt;&#x3D; 20) &#123;\n            res +&#x3D; num20_90[x &#x2F; 10 - 2] + &quot; &quot;;\n            x %&#x3D; 10;\n            if (x) res +&#x3D; num0_19[x] + &#39; &#39;;\n        &#125; else if (x) res +&#x3D; num0_19[x] + &#39; &#39;;&#x2F;&#x2F;else if\n        return res;\n    &#125;\n\n    string numberToWords(int num) &#123;\n        if (!num) return &quot;Zero&quot;;&#x2F;&#x2F;\n        string res;\n        for (int i &#x3D; 1e9, j &#x3D; 0; i &gt;&#x3D; 1; i &#x2F;&#x3D; 1000, j ++ )\n            if (num &gt;&#x3D; i) &#123;\n                res +&#x3D; get(num &#x2F; i) + num1000[j];\n                num %&#x3D; i;\n            &#125;\n        res.pop_back();&#x2F;&#x2F;去&#39; &#39;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"274-H指数-O-nlogn-sort\"><a href=\"#274-H指数-O-nlogn-sort\" class=\"headerlink\" title=\"274.H指数 O(nlogn):sort\"></a>274.H指数 O(nlogn):sort</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804154108982.png\" alt=\"image-20210804154108982\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int hIndex(vector&lt;int&gt;&amp; c) &#123;\n        sort(c.begin(), c.end(), greater&lt;int&gt;());&#x2F;&#x2F;大-&gt;小\n        for(int h &#x3D; c.size(); h; h--)\n            if(c[h - 1] &gt;&#x3D; h) &#x2F;&#x2F;h_max\n                return h;\n        return 0;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"275-H指数II-二分O-logn\"><a href=\"#275-H指数II-二分O-logn\" class=\"headerlink\" title=\"275.H指数II 二分O(logn)\"></a>275.H指数II 二分O(logn)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;从小到大排好序的：在数组中找一个[最大的h]，使得后h个数大于等于h。 ！不能reverse，否则O(n)！\n&#x2F;&#x2F;我们发现：如果h满足，则小于h的数都满足；如果h不满足，则大于h的数都不满足。所以具有二分性质。\n&#x2F;&#x2F;倒数~正数：1~n-1  mid~n-mid\nclass Solution &#123;\npublic:\n    int hIndex(vector&lt;int&gt;&amp; c) &#123;\n        int n &#x3D; c.size();\n        int l &#x3D; 0, r &#x3D; n;\n        while (l &lt; r)\n        &#123;\n            int mid &#x3D; l + r + 1 &gt;&gt; 1;&#x2F;&#x2F;\n            if (c[n - mid] &gt;&#x3D; mid) l &#x3D; mid;&#x2F;&#x2F;h_max [-&gt;\n            else r &#x3D; mid - 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"276\"><a href=\"#276\" class=\"headerlink\" title=\"276.\"></a>276.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"277\"><a href=\"#277\" class=\"headerlink\" title=\"277.\"></a>277.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"278-第一个错误的版本-二分\"><a href=\"#278-第一个错误的版本-二分\" class=\"headerlink\" title=\"278.第一个错误的版本 二分\"></a>278.第一个错误的版本 二分</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int firstBadVersion(int n) &#123;\n        int l &#x3D; 1, r &#x3D; n;\n        while(l &lt; r) &#123;\n            int mid &#x3D; (long long) l + r &gt;&gt; 1;&#x2F;&#x2F;防溢出\n            &#x2F;&#x2F;int mid &#x3D; l + (r - l) &#x2F; 2;\n            if(isBadVersion(mid)) r &#x3D; mid;&#x2F;&#x2F;min&lt;-]\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"279-完全平方数-n最少拆成几个…之和\"><a href=\"#279-完全平方数-n最少拆成几个…之和\" class=\"headerlink\" title=\"279.完全平方数  n最少拆成几个…之和\"></a>279.完全平方数  n最少拆成几个…之和</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804204221504.png\" alt=\"image-20210804204221504\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;300&#x2F;\n&#x2F;&#x2F;完全背包DP BFS:O(n√n)\n&#x2F;*\n(动态规划) O(n√n)\n设 f(i) 表示通过平方数组成 i 所需要完全平方数的最少数量。\n初始时，f(0)&#x3D;0，其余待定。\n转移时，对于一个 i，枚举 j，f(i)&#x3D;min(f(i−j∗j)+1)，其中 1≤j≤√i。\n最终答案为 f(n)。\n时间复杂度\n实际复杂度为 S&#x3D;∑i&#x3D;1~n √i，通过积分近似上界，得到 S&#x3D;O(n√n)。\n空间复杂度\n需要额外 O(n) 的空间存储状态。\nC++ 代码\n*&#x2F;\nclass Solution &#123;\npublic:\n    int numSquares(int n) &#123;\n        vector&lt;int&gt; f(n + 1, n);\n        f[0] &#x3D; 0;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            for (int j &#x3D; 1; j * j &lt;&#x3D; i; j++)&#x2F;&#x2F;\n                f[i] &#x3D; min(f[i], f[i - j * j] + 1);&#x2F;&#x2F;\n\n        return f[n];\n    &#125;\n&#125;;\n\n&#x2F;*\n(数学) O(√n+logn)\n根据 拉格朗日四平方和定理[每个正整数均可表示为4个整数的平方和]，可以得知答案必定为 1, 2, 3, 4 中的一个。\n其次根据 勒让德三平方和定理，可以得知 n 能写成 3 个数的平方和,当且仅当，n!&#x3D;4^a*(8b+7)。\n然后可以根据以上定理和枚举，判断出答案是否为 1, 2, 3，若都不是则答案为 4。\n时间复杂度\n判断平方数的时间复杂度为 $O(1)，枚举答案为 2 的时间复杂度为O(√n)，判断答案是否为 4 的时间复杂度为 O(log⁡n)，故总时间复杂度为 O(n√+logn)。\nC++ 代码\n*&#x2F;\nclass Solution &#123;\npublic:\n    int numSquares(int n) &#123;\n        if ((int)sqrt(n) * (int)sqrt(n) &#x3D;&#x3D; n)\n            return 1;\n        int t &#x3D; n;\n        while ((t &amp; 3) &#x3D;&#x3D; 0) t &gt;&gt;&#x3D; 2;&#x2F;&#x2F;t是4的倍数\n        if (((t - 7) &amp; 7) &#x3D;&#x3D; 0)&#x2F;&#x2F;t-7是8的倍数\n            return 4;\n\n        for (int i &#x3D; 1; i * i &lt;&#x3D; n; i++)\n            if ((int)(sqrt(n - i * i)) * (int)(sqrt(n - i * i)) &#x3D;&#x3D; n - i * i)\n                return 2;\n\n        return 3;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;300&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    bool  check(int x) &#123;\n        int r &#x3D; sqrt(x);\n        return r * r &#x3D;&#x3D; x;\n    &#125;\n\n    int numSquares(int n) &#123;\n        if(check(n)) return 1;\n\n        for(int a &#x3D; 1; a &lt;&#x3D; n &#x2F; a; a++)\n            if(check(n - a * a)) return 2;\n\n        while(n % 4 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 4;\n        if(n % 8 !&#x3D; 7) return 3;\n        return 4;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"280\"><a href=\"#280\" class=\"headerlink\" title=\"280.\"></a>280.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"281\"><a href=\"#281\" class=\"headerlink\" title=\"281\"></a>281</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"282-给表达式添加运算符-类似24点游戏-卡常-a-b×-递归\"><a href=\"#282-给表达式添加运算符-类似24点游戏-卡常-a-b×-递归\" class=\"headerlink\" title=\"282.给表达式添加运算符 类似24点游戏 卡常 a+b×()递归\"></a>282.给表达式添加运算符 类似24点游戏 卡常 a+b×()递归</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804212803155.png\" alt=\"image-20210804212803155\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;282. 给表达式添加运算符 类似24点游戏\n&#x2F;&#x2F;线段树维护两段性的代数结构？？？\n&#x2F;&#x2F;+-*用代数结构优化爆搜，省掉stk，全局数组原地改不用str 递归 代数结构封闭性：经典a+b*_\n&#x2F;*\n(DFS) O(n*4^n)\n基本思路是暴力枚举所有表达式方案:\n\n每两个数字之间可以不填任何字符，也可以填加减乘，所以每个间隔有4种方案，直接暴力枚举所有方案即可。\n本题的难点在于常数优化，如果实现方式不好，那么本题就很容易超时。总结下来一共两点：\n\n如果先[暴搜出所有表达式的形式]，然后再用[表达式求值的模板]去求解，那么会超时；\n记录方案时如果[每次复制整个数组]，那么会超时；\n为了能尽量优化常数，我们在[递归过程中尽量不要使用栈来维护表达式]。本题中我们维护如下不变式：\n\na+b×()，其中括号中的数是我们枚举的下一个数；\n然后分类讨论下一个运算符，其中 c 是我们枚举的括号中的数：\n\n下一个运算符是加号，那么 a+b×(c)+()&#x3D;(a+b×c)+1×();\n下一个运算符是减号，那么 a+b×(c)−()&#x3D;(a+b×c)+(−1)×();\n下一个运算符是乘号，那么 a+b×(c)×()&#x3D;a+(b×c)×();\n为了方便，我们在表达式【最后统一添加一个加号，那么最终不变式就会变成 a+1×()，所以 a 就是我们枚举的表达式的值，判断一下和target是否相等即可。】\n\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;332&#x2F;\n*&#x2F;\ntypedef long long LL;\n\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    string path;\n\n    vector&lt;string&gt; addOperators(string num, int target) &#123;\n        path.resize(100);&#x2F;&#x2F;O(n*4^n) n&lt;50\n        dfs(num, 0, 0, 0, 1, target);&#x2F;&#x2F;u:cur_idx pathLen a b: a+b*_\n        return ans;\n    &#125;\n\n    void dfs(string&amp; num, int u, int len, LL a, LL b, LL target) &#123;\n        if (u &#x3D;&#x3D; num.size()) &#123;\n            if (a &#x3D;&#x3D; target) &#123;\n                ans.push_back(path.substr(0, len - 1));&#x2F;&#x2F;[a]+ 去+号\n            &#125;\n        &#125; else &#123;\n            LL c &#x3D; 0;&#x2F;&#x2F;c:cur_num\n            for (int i &#x3D; u; i &lt; num.size(); i ++ ) &#123;\n                c &#x3D; c * 10 + num[i] - &#39;0&#39;;\n                path[len ++ ] &#x3D; num[i];\n                &#x2F;&#x2F;+  [a]last+\n                path[len] &#x3D; &#39;+&#39;;\n                dfs(num, i + 1, len + 1, a + b * c, 1, target);\n                \n                if (i + 1 &lt; num.size()) &#123;&#x2F;&#x2F;not last one\n                    &#x2F;&#x2F;-\n                    path[len] &#x3D; &#39;-&#39;;\n                    dfs(num, i + 1, len + 1, a + b * c, -1, target);\n                    &#x2F;&#x2F;*\n                    path[len] &#x3D; &#39;*&#39;;\n                    dfs(num, i + 1, len + 1, a, b * c, target);\n                &#125;\n                if (num[u] &#x3D;&#x3D; &#39;0&#39;) break;\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n</code></pre>\n\n\n\n<h1 id=\"283-移动零-至末尾\"><a href=\"#283-移动零-至末尾\" class=\"headerlink\" title=\"283.移动零 至末尾\"></a>283.移动零 至末尾</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;\n        int k &#x3D; 0;\n        for(auto x: nums) \n            if (x)\n                nums[k++] &#x3D; x;\n        while(k &lt; nums.size()) nums[k++] &#x3D; 0;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"284-顶端迭代器-封装-手动增加一个类似展台的缓存cur\"><a href=\"#284-顶端迭代器-封装-手动增加一个类似展台的缓存cur\" class=\"headerlink\" title=\"284.顶端迭代器 封装 手动增加一个类似展台的缓存cur\"></a>284.顶端迭代器 封装 手动增加一个类似展台的缓存cur</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n * Below is the interface for Iterator, which is already defined for you.\n * **DO NOT** modify the interface for Iterator.\n *\n *  class Iterator &#123;\n *\t\tstruct Data;\n * \t\tData* data;\n *  public:\n *\t\tIterator(const vector&lt;int&gt;&amp; nums);\n * \t\tIterator(const Iterator&amp; iter);\n *\n * \t\t&#x2F;&#x2F; Returns the next element in the iteration.\n *\t\tint next();\n *\n *\t\t&#x2F;&#x2F; Returns true if the iteration has more elements.\n *\t\tbool hasNext() const;\n *\t&#125;;\n *&#x2F;\n\nclass PeekingIterator : public Iterator &#123;\npublic:\n    int cur;\n    bool has_next;\n\n\tPeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123;\n\t    &#x2F;&#x2F; Initialize any member here.\n\t    &#x2F;&#x2F; **DO NOT** save a copy of nums and manipulate it directly.\n\t    &#x2F;&#x2F; You should only use the Iterator interface methods.\n        has_next &#x3D; Iterator::hasNext();\n        if(has_next) cur &#x3D; Iterator::next();\n\t&#125;\n\t\n    &#x2F;&#x2F; Returns the next element in the iteration without advancing the iterator.\n\tint peek() &#123;\n        return cur;\n\t&#125;\n\t\n\t&#x2F;&#x2F; hasNext() and next() should behave the same as in the Iterator interface.\n\t&#x2F;&#x2F; Override them if needed.\n\tint next() &#123;\n\t    int t &#x3D; cur;\n        has_next &#x3D; Iterator::hasNext();\n        if(has_next) cur &#x3D; Iterator::next();\n        return t;\n\t&#125;\n\t\n\tbool hasNext() const &#123;\n        return has_next;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"285\"><a href=\"#285\" class=\"headerlink\" title=\"285.\"></a>285.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"286\"><a href=\"#286\" class=\"headerlink\" title=\"286.\"></a>286.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"287-寻找重复数-转化到LC142环的入口\"><a href=\"#287-寻找重复数-转化到LC142环的入口\" class=\"headerlink\" title=\"287.寻找重复数 转化到LC142环的入口\"></a>287.寻找重复数 转化到LC142环的入口</h1><p>【n+1个数在1~n之间】可利用其转化！！！，有一个重复数</p>\n<p>acwing14剑指offer 不同：多个重复返回任意一个【二分】  也可用此法</p>\n<p>桶排序会修改数组</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805085717198.png\" alt=\"image-20210805085717198\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        int a &#x3D; 0, b &#x3D; 0;\n        while(true) &#123;\n            a &#x3D; nums[a];\n            b &#x3D; nums[nums[b]];&#x2F;&#x2F;\n            if(a &#x3D;&#x3D; b) &#123;\n                a &#x3D; 0;\n                while(a !&#x3D; b) &#123;\n                    a &#x3D; nums[a];\n                    b &#x3D; nums[b];\n                &#125;\n                return a;\n            &#125;\n        &#125;\n        return -1;&#x2F;&#x2F;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"288\"><a href=\"#288\" class=\"headerlink\" title=\"288.\"></a>288.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"289-生命游戏-原地-32bit-int技巧\"><a href=\"#289-生命游戏-原地-32bit-int技巧\" class=\"headerlink\" title=\"289.生命游戏 原地 32bit int技巧\"></a>289.生命游戏 原地 32bit int技巧</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805095421728.png\" alt=\"image-20210805095421728\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;289.生命游戏 原地 __位技巧\nclass Solution &#123;\npublic:\n    void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;\n        if(board.empty() || board[0].empty()) return;\n        int n &#x3D; board.size(), m &#x3D; board[0].size();\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; m; j++) &#123;\n                int live &#x3D; 0;\n                for(int x &#x3D; max(0, i - 1); x &lt;&#x3D; min(n - 1, i + 1); x++)\n                    for(int y &#x3D; max(0, j - 1); y &lt;&#x3D; min(m - 1, j + 1); y++)\n                        if((x !&#x3D; i || y !&#x3D; j) &amp;&amp; (board[x][y] &amp; 1))&#x2F;&#x2F;跳过ij中心点\n                            live++;\n                int cur &#x3D; board[i][j] &amp; 1, next;\n                if (cur) &#123;\n                    if(live &lt; 2 || live &gt; 3) next &#x3D; 0;\n                    else next &#x3D; 1;\n                &#125; else &#123;\n                    if(live &#x3D;&#x3D; 3) next &#x3D; 1;\n                    else next &#x3D; 0;\n                &#125;\n                board[i][j] |&#x3D; next &lt;&lt; 1;\n            &#125;\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; m; j++)\n                board[i][j] &gt;&gt;&#x3D; 1;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"290-单词规律-双射：满射-A-x3D-B-单射B-gt-A-唯一-映射A-gt-B-唯一\"><a href=\"#290-单词规律-双射：满射-A-x3D-B-单射B-gt-A-唯一-映射A-gt-B-唯一\" class=\"headerlink\" title=\"290.单词规律  双射：满射|A|&#x3D;|B| 单射B-&gt;A(唯一) 映射A-&gt;B(唯一)\"></a>290.单词规律  双射：满射|A|&#x3D;|B| 单射B-&gt;A(唯一) 映射A-&gt;B(唯一)</h1><p>满射：|A|&#x3D;|B|</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805102843397.png\" alt=\"image-20210805102843397\"></p>\n<p>B只有一个A</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805102939403.png\" alt=\"image-20210805102939403\"></p>\n<p>是映射，是单值函数，x对应一个y    A只有一个B</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;290.单词规律 双射：满射|A|&#x3D;|B| 单射B-&gt;A(唯一) 映射A-&gt;B(唯一)\nclass Solution &#123;\npublic:\n    bool wordPattern(string pattern, string s) &#123;\n        vector&lt;string&gt; words;\n        stringstream ssin(s);&#x2F;&#x2F;\n        string word;\n        while(ssin &gt;&gt; word) words.push_back(word);\n        if(pattern.size() !&#x3D; words.size()) return false;\n        unordered_map&lt;char, string&gt; pw;\n        unordered_map&lt;string, char&gt; wp;\n        for(int i &#x3D; 0; i &lt; pattern.size(); i++) &#123;\n            auto a &#x3D; pattern[i];\n            auto b &#x3D; words[i];\n            if(pw.count(a) &amp;&amp; pw[a] !&#x3D; b) return false;&#x2F;&#x2F;\n            pw[a] &#x3D; b;\n            if(wp.count(b) &amp;&amp; wp[b] !&#x3D; a) return false;\n            wp[b] &#x3D; a;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"291\"><a href=\"#291\" class=\"headerlink\" title=\"291\"></a>291</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"292-Nim游戏-小学数奥\"><a href=\"#292-Nim游戏-小学数奥\" class=\"headerlink\" title=\"292.Nim游戏 小学数奥\"></a>292.Nim游戏 小学数奥</h1><ul>\n<li>你作为先手。</li>\n<li>每一回合，轮到的人拿掉 1 - 3 块石头。</li>\n<li>拿掉最后一块石头的人就是获胜者。</li>\n<li>best policy:</li>\n<li>n%4!&#x3D;0,我拿x&#x3D;n%4,Ta面对(n-x)%4&#x3D;&#x3D;0必败，我必胜</li>\n<li>同理n%4&#x3D;&#x3D;0，Ta必胜</li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805124901947.png\" alt=\"image-20210805124901947\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool canWinNim(int n) &#123;\n        return n%4;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"293\"><a href=\"#293\" class=\"headerlink\" title=\"293.\"></a>293.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"294\"><a href=\"#294\" class=\"headerlink\" title=\"294.\"></a>294.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"295-数据流的-中位数-动态维护median：对顶堆\"><a href=\"#295-数据流的-中位数-动态维护median：对顶堆\" class=\"headerlink\" title=\"295.数据流的[中位数] 动态维护median：对顶堆\"></a>295.数据流的[中位数] 动态维护median：对顶堆</h1><p>动态维护有序序列：平衡树 set map</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805130222515.png\" alt=\"image-20210805130222515\"></p>\n<p>n奇down多一个，多两个就上下移堆顶  t&lt;&#x3D;x入down</p>\n<p>插入O(logn) 查询O(1)</p>\n<p>100个桶 统计次数O(100)&gt;O(logn) 省空间！</p>\n<p>用对顶堆维护桶：O(log100)？？？？？how？？？？？？</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class MedianFinder &#123;\npublic:\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;&#x2F;&#x2F;小根堆\n    priority_queue&lt;int&gt; down;\n\n    &#x2F;** initialize your data structure here. *&#x2F;\n    MedianFinder() &#123;\n\n    &#125;\n\n    void addNum(int num) &#123;\n        if (down.empty() || num &lt;&#x3D; down.top()) &#123;&#x2F;&#x2F;down空 || t&lt;&#x3D;x\n            down.push(num);\n            if (down.size() &gt; up.size() + 1) &#123;&#x2F;&#x2F;down多2\n                up.push(down.top());\n                down.pop();\n            &#125;\n        &#125; else &#123;\n            up.push(num);\n            if (up.size() &gt; down.size()) &#123;&#x2F;&#x2F;up多1\n                down.push(up.top());\n                up.pop();\n            &#125;\n        &#125;\n    &#125;\n\n    double findMedian() &#123;\n        if ((down.size() + up.size()) % 2) return down.top();\n        return (down.top() + up.top()) &#x2F; 2.0;&#x2F;&#x2F; !!!&#x2F;2.0!!!\n    &#125;\n&#125;;\n\n\n&#x2F;**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder* obj &#x3D; new MedianFinder();\n * obj-&gt;addNum(num);\n * double param_2 &#x3D; obj-&gt;findMedian();\n *&#x2F;</code></pre>\n\n\n\n<h1 id=\"296\"><a href=\"#296\" class=\"headerlink\" title=\"296.\"></a>296.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"297-二叉树的序列化与反序列化\"><a href=\"#297-二叉树的序列化与反序列化\" class=\"headerlink\" title=\"297.二叉树的序列化与反序列化\"></a>297.二叉树的序列化与反序列化</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Codec &#123;\npublic:\n    string path;\n\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    string serialize(TreeNode* root) &#123;\n        dfs_s(root);\n        return path;\n    &#125;\n\n    void dfs_s(TreeNode* root) &#123;\n        if(!root) path +&#x3D; &quot;#,&quot;;\n        else &#123;\n            path +&#x3D; to_string(root-&gt;val) + &#39;,&#39;;\n            dfs_s(root-&gt;left);\n            dfs_s(root-&gt;right);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) &#123;\n        int u &#x3D; 0;\n        return dfs_d(data, u);\n    &#125;\n\n    TreeNode* dfs_d(string&amp; data, int&amp; u) &#123;\n        if(data[u] &#x3D;&#x3D; &#39;#&#39;) &#123;\n            u +&#x3D; 2;\n            return NULL;\n        &#125; else &#123;\n            int k &#x3D; u;\n            while(data[u] !&#x3D; &#39;,&#39;) u++;\n            auto root &#x3D; new TreeNode(stoi(data.substr(k, u - k)));&#x2F;&#x2F;\n            u++;&#x2F;&#x2F;跳过,号\n            root-&gt;left &#x3D; dfs_d(data, u);\n            root-&gt;right &#x3D; dfs_d(data, u);\n            return root;\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"298\"><a href=\"#298\" class=\"headerlink\" title=\"298.\"></a>298.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"299-猜数字游戏\"><a href=\"#299-猜数字游戏\" class=\"headerlink\" title=\"299.猜数字游戏\"></a>299.猜数字游戏</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805164406245.png\" alt=\"image-20210805164406245\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string getHint(string secret, string guess) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        for(auto c: secret) hash[c]++;\n        int tot &#x3D; 0;\n        for(auto c: guess)\n            if(hash[c]) &#123;&#x2F;&#x2F;\n                tot++;\n                hash[c]--;\n            &#125;\n\n        int bulls &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; secret.size(); i++)\n            if(secret[i] &#x3D;&#x3D; guess[i]) \n                bulls ++;\n        return to_string(bulls) + &quot;A&quot; + to_string(tot - bulls) + &quot;B&quot;;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"！！！300-最长递增子序列-不连续-LIS-DP-二分-贪心-难！\"><a href=\"#！！！300-最长递增子序列-不连续-LIS-DP-二分-贪心-难！\" class=\"headerlink\" title=\"！！！300.最长递增子序列 不连续 LIS:DP 二分 贪心 难！\"></a>！！！300.最长递增子序列 不连续 LIS:DP 二分 贪心 难！</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805172146043.png\" alt=\"image-20210805172146043\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;300.最长递增子序列 不连续\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;15256&#x2F;\n&#x2F;&#x2F; DP O(n*n)\nclass Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; f(n);\n        for(int i &#x3D; 0; i &lt; n; i++)\n        &#123;\n            f[i] &#x3D; 1;  &#x2F;&#x2F; 只有a[i]一个数\n            for(int j &#x3D; 0; j &lt; i; j++)\n                if(nums[j] &lt; nums[i])\n                    f[i] &#x3D; max(f[i], f[j] + 1);\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, f[i]);  &#x2F;&#x2F; 枚举所有的f[i]，取最大值\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;287&#x2F;\n&#x2F;&#x2F;（动态规划 贪心 二分查找）O(nlogn)\nclass Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; q;\n        for (auto x: nums) &#123;\n            if (q.empty() || x &gt; q.back()) q.push_back(x);\n            else &#123;\n                if (x &lt;&#x3D; q[0]) q[0] &#x3D; x;&#x2F;&#x2F;\n                else &#123;&#x2F;&#x2F; 找到&lt;x的最后一个元素-&gt;r\n                    int l &#x3D; 0, r &#x3D; q.size() - 1;\n                    while (l &lt; r) &#123;\n                        int mid &#x3D; l + r + 1 &gt;&gt; 1;\n                        if (q[mid] &lt; x) l &#x3D; mid;&#x2F;&#x2F;[-&gt;\n                        else r &#x3D; mid - 1;\n                    &#125;\n                    q[r + 1] &#x3D; x;&#x2F;&#x2F;更新下一个为x\n                &#125;\n            &#125;\n        &#125;\n        return q.size();\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"301-删除无效的括号-最少删-所有结果-难-递归回溯剪枝-O-n-2-n\"><a href=\"#301-删除无效的括号-最少删-所有结果-难-递归回溯剪枝-O-n-2-n\" class=\"headerlink\" title=\"-301. 删除无效的括号 最少删 所有结果 难! 递归回溯剪枝 O(n*2^n)\"></a>-301. 删除无效的括号 最少删 所有结果 难! 递归回溯剪枝 O(n*2^n)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;301.删除无效的括号 最少删 所有结果 难 递归回溯剪枝 O(n*2^n)\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;3852&#x2F;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;470996&#x2F;\nclass Solution &#123;\npublic:\n\tvector&lt;string&gt; ans;\n\n\tvector&lt;string&gt; removeInvalidParentheses(string s) &#123;\n\t\tint l &#x3D; 0, r &#x3D; 0;&#x2F;&#x2F;要删除多少(和)\n\t\tfor (auto x: s)\n\t\t\tif (x &#x3D;&#x3D; &#39;(&#39;) l ++ ;\n\t\t\telse if (x &#x3D;&#x3D; &#39;)&#39;) &#123;\n\t\t\t\tif (l &#x3D;&#x3D; 0) r ++ ;\n\t\t\t\telse l -- ;&#x2F;&#x2F;抵消一个&#39;(&#39;\n\t\t\t&#125;\n\n\t\tdfs(s, 0, &quot;&quot;, 0, l, r);\n\t\treturn ans;\n\t&#125;\n\t&#x2F;&#x2F;cnt&#x3D;l-r 还要删几个lr\n\tvoid dfs(string&amp; s, int u, string path, int cnt, int l, int r) &#123;\n\t\tif (u &#x3D;&#x3D; s.size()) &#123;\n\t\t\tif (!cnt) ans.push_back(path);&#x2F;&#x2F;l&#x3D;r\n\t\t\treturn;\n\t\t&#125;\n\n\t\tif (s[u] !&#x3D; &#39;(&#39; &amp;&amp; s[u] !&#x3D; &#39;)&#39;) dfs(s, u + 1, path + s[u], cnt, l, r);&#x2F;&#x2F;&#39;a&#39;加入\n\t\telse if (s[u] &#x3D;&#x3D; &#39;(&#39;) &#123;\n\t\t\tint k &#x3D; u;\n\t\t\twhile (k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; &#39;(&#39;) k ++ ;\n\t\t\t&#x2F;&#x2F;枚举 删掉连续k-u~0个&#39;(&#39;\t[u,k)\n\t\t\tl -&#x3D; k - u;\n\t\t\tfor (int i &#x3D; k - u; i &gt;&#x3D; 0; i -- ) &#123;\n\t\t\t\tif (l &gt;&#x3D; 0) dfs(s, k, path, cnt, l, r);\n\t\t\t\tpath +&#x3D; &#39;(&#39;;&#x2F;&#x2F;枚举少删一个&#39;(&#39;\n\t\t\t\tcnt ++, l ++ ;\n\t\t\t&#125;\n\t\t&#125; else if (s[u] &#x3D;&#x3D; &#39;)&#39;) &#123;\n\t\t\tint k &#x3D; u;\n\t\t\twhile (k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; &#39;)&#39;) k ++ ;\n\t\t\tr -&#x3D; k - u;\n\t\t\tfor (int i &#x3D; k - u; i &gt;&#x3D; 0; i -- ) &#123;\n\t\t\t\tif (cnt &gt;&#x3D; 0 &amp;&amp; r &gt;&#x3D; 0) dfs(s, k, path, cnt, l, r);&#x2F;&#x2F;cnt-- &gt;&#x3D;0\n\t\t\t\tpath +&#x3D; &#39;)&#39;;\n\t\t\t\tcnt --, r ++ ;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"302\"><a href=\"#302\" class=\"headerlink\" title=\"302.\"></a>302.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<p>&#x2F;&#x2F; 【基础课基础算法 前缀和与差分 的 1D2D前缀和：S从1开始！不处理边界！】 复习！<br>&#x2F;&#x2F; <a href=\"https://www.acwing.com/activity/content/punch_the_clock/11/\">https://www.acwing.com/activity/content/punch_the_clock/11/</a></p>\n<h1 id=\"303-区域和检索-数组不可变-1D前缀和\"><a href=\"#303-区域和检索-数组不可变-1D前缀和\" class=\"headerlink\" title=\"303.区域和检索-数组不可变 1D前缀和\"></a>303.区域和检索-数组不可变 1D前缀和</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class NumArray &#123;\npublic:\n    vector&lt;int&gt; s;&#x2F;&#x2F;前缀和 1开始 S(lr)&#x3D;S(r)-S(l-1)\n\n    NumArray(vector&lt;int&gt;&amp; nums) &#123;\n        s.resize(nums.size() + 1);&#x2F;&#x2F;0 1~n,多一个\n        for(int i &#x3D; 1; i &lt;&#x3D; nums.size(); i++) s[i] &#x3D; s[i - 1] + nums[i - 1];&#x2F;&#x2F;nums.size()\n    &#125;\n    \n    int sumRange(int l, int r) &#123;\n        ++l, ++r;&#x2F;&#x2F;\n        return s[r] - s[l - 1];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"304-二维区域和检索-矩阵不可变\"><a href=\"#304-二维区域和检索-矩阵不可变\" class=\"headerlink\" title=\"304.二维区域和检索 - 矩阵不可变\"></a>304.二维区域和检索 - 矩阵不可变</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210805204542290.png\" alt=\"image-20210805204542290\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class NumMatrix &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; s;\n\n    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if(matrix.empty() || matrix[0].empty()) return;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        s &#x3D; vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(m + 1));&#x2F;&#x2F;\n        for(int i &#x3D; 1; i &lt;&#x3D; matrix.size(); i++)\n            for(int j &#x3D; 1; j &lt;&#x3D; matrix[0].size(); j++)\n                 s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + matrix[i- 1][j - 1];\n    &#125;\n    \n    int sumRegion(int x1, int y1, int x2, int y2) &#123;\n        ++x1, ++y1, ++x2, ++y2;&#x2F;&#x2F;\n        return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"305\"><a href=\"#305\" class=\"headerlink\" title=\"305.\"></a>305.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<p>&#x2F;&#x2F; <a href=\"https://www.acwing.com/activity/content/punch_the_clock/11/\">https://www.acwing.com/activity/content/punch_the_clock/11/</a><br>&#x2F;&#x2F; 复习：acwing791.高精度加法</p>\n<h1 id=\"306-累加数-judge-未分割的fib-枚举串长xyz-abc-高精度加法列竖式\"><a href=\"#306-累加数-judge-未分割的fib-枚举串长xyz-abc-高精度加法列竖式\" class=\"headerlink\" title=\"306.累加数 judge:未分割的fib 枚举串长xyz abc+高精度加法列竖式\"></a>306.累加数 judge:未分割的fib 枚举串长xyz abc+高精度加法列竖式</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210806091651382.png\" alt=\"image-20210806091651382\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string add(string x, string y) &#123;&#x2F;&#x2F;高精度加法模板 列竖式\n        vector&lt;int&gt; A, B, C;\n        for(int i &#x3D; x.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(x[i] - &#39;0&#39;);\n        for(int i &#x3D; y.size() - 1; i &gt;&#x3D; 0; i --) B.push_back(y[i] - &#39;0&#39;);\n        for(int i &#x3D; 0, t &#x3D; 0; i &lt; A.size() || i &lt; B.size() || t; i++) &#123;&#x2F;&#x2F;低位到高位\n            if(i &lt; A.size()) t +&#x3D; A[i];\n            if(i &lt; B.size()) t +&#x3D; B[i];\n            C.push_back(t % 10);\n            t &#x2F;&#x3D; 10;\n        &#125;\n        string z;\n        for(int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i--) z +&#x3D; to_string(C[i]);&#x2F;&#x2F;int2str\n        return z;\n    &#125;\n\n    bool isAdditiveNumber(string num) &#123;\n        for(int i &#x3D; 0; i &lt; num.size(); i++)\n            for(int j &#x3D; i + 1; j + 1 &lt; num.size(); j++) &#123;&#x2F;&#x2F;\n                int a &#x3D; -1, b &#x3D; i, c &#x3D; j;\n                while(true) &#123;\n                    if(b - a &gt; 1 &amp;&amp; num[a + 1] &#x3D;&#x3D; &#39;0&#39; || c - b &gt; 1 &amp;&amp; num[b + 1] &#x3D;&#x3D; &#39;0&#39;) break;&#x2F;&#x2F;有前导0\n                    auto x &#x3D; num.substr(a + 1, b - a), y &#x3D; num.substr(b + 1, c - b);\n                    auto z &#x3D; add(x, y);\n                    if(num.substr(c + 1, z.size()) !&#x3D; z) break;&#x2F;&#x2F;第三个数不匹配\n                    a &#x3D; b, b &#x3D; c, c +&#x3D; z.size();\n                    if(c + 1 &#x3D;&#x3D; num.size()) return true;\n                &#125;\n            &#125;\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"307-区域和检索-数组可修改-树状数组\"><a href=\"#307-区域和检索-数组可修改-树状数组\" class=\"headerlink\" title=\"307.区域和检索-数组可修改 树状数组\"></a>307.区域和检索-数组可修改 树状数组</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;307.区域和检索-数组可修改\n&#x2F;&#x2F; 树状数组【优先】:区间查询[&lt;-前缀和]+单点修改[增加-&gt;] 见蓝书0x42 P202\n\n&#x2F;&#x2F;线段树常数大，代码多。所以一般能用树状数组就不用线段树。\n&#x2F;&#x2F; 线段树：区间查询求和RMQ+单点修改&#x2F;增加 区间修改：延迟标记\n&#x2F;&#x2F; 区间反转：splay平衡树\nclass NumArray &#123;\npublic:\n\tint n;\n\tvector&lt;int&gt; tr, nums;\n\n\tint lowbit(int x) &#123;\n\t\treturn x &amp; -x;\n\t&#125;\n\n\tint query(int x) &#123;&#x2F;&#x2F;x&#x3D;idx\n\t\tint res &#x3D; 0;\n\t\tfor(int i &#x3D; x; i; i -&#x3D; lowbit(i)) res +&#x3D; tr[i];&#x2F;&#x2F;前缀和\n\t\treturn res;\n\t&#125;\n\n\tvoid add(int x, int v) &#123;\n\t\tfor(int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) tr[i] +&#x3D; v;\n\t&#125;\n\n\tNumArray(vector&lt;int&gt;&amp; _nums) &#123;\n\t\tnums &#x3D; _nums;\n\t\tn &#x3D; nums.size();\n\t\ttr.resize(n + 1);&#x2F;&#x2F;1~n\n\t\t&#x2F;&#x2F;init tr\n\t\t&#x2F;&#x2F;O(nlogn)\n\t\t&#x2F;&#x2F; for(int i &#x3D; 0; i &lt; n; i++) add(i + 1, nums[i]);\n\t\t&#x2F;&#x2F;O(n) 没必要！\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\t\ttr[i] &#x3D; nums[i - 1];\n\t\t\tfor(int j &#x3D; i - 1; j &gt; i - lowbit(i); j -&#x3D; lowbit(j))&#x2F;&#x2F;左兄弟\n\t\t\t\ttr[i] +&#x3D; tr[j];\n\t\t&#125;\n\t&#125;\n\t\n\tvoid update(int i, int val) &#123;\n\t\tadd(i + 1, val - nums[i]);\n\t\tnums[i] &#x3D; val;\n\t&#125;\n\t\n\tint sumRange(int l, int r) &#123;\n\t\treturn query(r + 1) - query(l);\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"308\"><a href=\"#308\" class=\"headerlink\" title=\"308.\"></a>308.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"309-最佳买卖股票时机含冷冻期-画状态机DP\"><a href=\"#309-最佳买卖股票时机含冷冻期-画状态机DP\" class=\"headerlink\" title=\"309.最佳买卖股票时机含冷冻期 画状态机DP\"></a>309.最佳买卖股票时机含冷冻期 画状态机DP</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210807084830771.png\" alt=\"image-20210807084830771\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        if(prices.empty()) return 0;\n        int n &#x3D; prices.size(), INF &#x3D; 1e8;\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(3, -INF));&#x2F;&#x2F;n*3 [0 1 2] \n        f[0][1] &#x3D; -prices[0], f[0][0] &#x3D; 0;\n        for(int i &#x3D; 1; i &lt; n; i++) &#123;\n            f[i][0] &#x3D; max(f[i - 1][0], f[i - 1][2]);\n            f[i][1] &#x3D; max(f[i - 1][0] - prices[i], f[i - 1][1]);&#x2F;&#x2F;-Pi!!!\n            f[i][2] &#x3D; f[i - 1][1] + prices[i];\n        &#125;\n        return max(f[n - 1][0], max(f[n - 1][1], f[n - 1][2]));\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"310-最小高度树-minHeight的所有根-树形DP-O-n\"><a href=\"#310-最小高度树-minHeight的所有根-树形DP-O-n\" class=\"headerlink\" title=\"310.最小高度树 minHeight的所有根 树形DP O(n)\"></a>310.最小高度树 minHeight的所有根 树形DP O(n)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210807100016091.png\" alt=\"image-20210807100016091\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 树形DP：比贪心法更通用\n&#x2F;&#x2F; 向上向下算都有\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; g;\n    vector&lt;int&gt; d1, d2, p1, p2, up;\n\n    void dfs1(int u, int father) &#123;\n        for(int x: g[u]) &#123;\n            if(x &#x3D;&#x3D; father) continue;\n            dfs1(x, u);&#x2F;&#x2F;down向上递推\n            int d &#x3D; d1[x] + 1;\n            if(d &gt;&#x3D; d1[u]) &#123;\n                d2[u] &#x3D; d1[u], d1[u] &#x3D; d; \n                p2[u] &#x3D; p1[u], p1[u] &#x3D; x;\n            &#125; else if(d &gt; d2[u]) &#123;\n                d2[u] &#x3D; d;\n                p2[u] &#x3D; x;\n            &#125;\n        &#125;\n    &#125;\n\n    void dfs2(int u, int father) &#123;\n        for(int x: g[u]) &#123;\n            if(x &#x3D;&#x3D; father) continue;\n            if(p1[u] &#x3D;&#x3D; x) up[x] &#x3D; max(up[u], d2[u]) + 1;\n            else up[x] &#x3D; max(up[u], d1[u]) + 1;\n            dfs2(x, u);&#x2F;&#x2F;up向下递推\n        &#125;\n    &#125;\n\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n        g.resize(n);\n        d1 &#x3D; d2 &#x3D; p1 &#x3D; p2 &#x3D; up &#x3D; vector&lt;int&gt;(n);\n        &#x2F;&#x2F;无向图&#x2F;无根树 init 邻接表\n        for(auto&amp; e: edges) &#123;\n            int a &#x3D; e[0], b &#x3D; e[1];\n            g[a].push_back(b), g[b].push_back(a);\n        &#125;\n        dfs1(0, -1);&#x2F;&#x2F;cur, father\n        dfs2(0, -1);\n        \n        int mind &#x3D; n + 1;\n        for(int i &#x3D; 0; i &lt; n; i++) mind &#x3D; min(mind, max(up[i], d1[i]));\n        vector&lt;int&gt; res;\n        for(int i &#x3D; 0; i &lt; n; i++)\n            if(max(up[i], d1[i]) &#x3D;&#x3D; mind)\n                res.push_back(i);\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;344&#x2F;\n&#x2F;&#x2F; (贪心删点) O(n)\n&#x2F;&#x2F; 从叶子结点开始，每一轮删除所有叶子结点。\n&#x2F;&#x2F; 删除后，会出现新的叶子结点，此时再删除。\n&#x2F;&#x2F; 重复以上过程直到剩余 1 个或 2 个结点，此时这 1 个或 2 个结点就是答案。\nclass Solution &#123;\npublic:\n\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n        if (n &#x3D;&#x3D; 1)\n            return vector&lt;int&gt;&#123;0&#125;;\n\n        vector&lt;vector&lt;int&gt;&gt; tree(n);\n        vector&lt;int&gt; deg(n, 0);\n        for (auto &amp;e : edges) &#123;\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n            deg[e[0]]++;\n            deg[e[1]]++;\n        &#125;\n\n        vector&lt;int&gt; res;\n        for (int i &#x3D; 0; i &lt; n; i++)\n            if (deg[i] &#x3D;&#x3D; 1)\n                res.push_back(i);\n\n        while (n &gt; 2) &#123;\n            vector&lt;int&gt; next_res;\n            for (auto &amp;u : res) &#123;\n                n--;\n                for (auto &amp;v : tree[u]) &#123;\n                    deg[v]--;\n                    if (deg[v] &#x3D;&#x3D; 1)\n                        next_res.push_back(v);\n                &#125;\n            &#125;\n            res &#x3D; next_res;\n        &#125;\n\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"311\"><a href=\"#311\" class=\"headerlink\" title=\"311.\"></a>311.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"312-戳气球-区间DP-i-j为哨兵\"><a href=\"#312-戳气球-区间DP-i-j为哨兵\" class=\"headerlink\" title=\"312.戳气球 区间DP i,j为哨兵\"></a>312.戳气球 区间DP i,j为哨兵</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210807103850439.png\" alt=\"image-20210807103850439\"></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 500</code> 1.25*$10^8$ &#x2F; 3 &#x3D; 4000w+   (i,k,j)三元组</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;312.戳气球 区间DP i,j为哨兵\nclass Solution &#123;\npublic:\n    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; a(n + 2, 1);&#x2F;&#x2F;a在nums左右端点各补1\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i] &#x3D; nums[i - 1];\n        vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2));&#x2F;&#x2F;\n        for(int len &#x3D; 3; len &lt;&#x3D; n + 2; len++)&#x2F;&#x2F;3\n            for(int i &#x3D; 0; i + len - 1 &lt;&#x3D; n + 1; i++) &#123;\n                int j &#x3D; i + len - 1;&#x2F;&#x2F;\n                for(int k &#x3D; i + 1; k &lt; j; k++)\n                    f[i][j] &#x3D; max(f[i][j], f[i][k] + f[k][j] + a[i] * a[k] * a[j]);\n            &#125;\n        return f[0][n + 1];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"313-超级丑数-LC264-丑数II-2-3-5-gt-p-k-nth-快速insert-快速求min：堆！-O-nlogk-lt-10-7-太晕了…\"><a href=\"#313-超级丑数-LC264-丑数II-2-3-5-gt-p-k-nth-快速insert-快速求min：堆！-O-nlogk-lt-10-7-太晕了…\" class=\"headerlink\" title=\"313.超级丑数 LC264.丑数II[2 3 5]-&gt;p[k] nth   快速insert 快速求min：堆！ O(nlogk)&lt;10^7 太晕了…\"></a>313.超级丑数 LC264.丑数II[2 3 5]-&gt;p[k] nth   快速insert 快速求min：堆！ O(nlogk)&lt;10^7 太晕了…</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210804120137655.png\" alt=\"image-20210804120137655\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;313.超级丑数 LC264.丑数II[2 3 5]-&gt;p[k] nth\n&#x2F;&#x2F;快速insert 快速求min：堆！ O(nlogk)&lt;10^7  容斥原理会TLE\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;471111&#x2F;\nclass Solution &#123;\npublic:\n    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123;\n        typedef pair&lt;int, int&gt; PII;\n        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n        for (int x: primes) heap.push(&#123;x, 0&#125;);&#x2F;&#x2F;&#123;Pi, i&#125;\n        vector&lt;int&gt; q(n);&#x2F;&#x2F;结果序列0~n-1\n        q[0] &#x3D; 1;\n        for (int i &#x3D; 1; i &lt; n;) &#123;\n            auto t &#x3D; heap.top(); heap.pop();\n            if (t.first !&#x3D; q[i - 1]) q[i ++ ] &#x3D; t.first;&#x2F;&#x2F;q去重\n            int idx &#x3D; t.second, p &#x3D; t.first &#x2F; q[idx];&#x2F;&#x2F;p!!!\n            heap.push(&#123;p * q[idx + 1], idx + 1&#125;);&#x2F;&#x2F; t.first&#x2F;qi*q(i+1) 晕...\n        &#125;\n        return q[n - 1];\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;更清晰\nclass Solution &#123;\npublic:\n    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123;\n        #define PI pair&lt;int, int&gt;\n\n        int k &#x3D; primes.size();\n        vector&lt;int&gt; res(n), idx(k, 0);\n        priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt;&gt; heap;\n\n        res[0] &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; k; i++)\n            heap.push(make_pair(primes[i], i));\n\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            int mi &#x3D; heap.top().first;\n            res[i] &#x3D; mi;\n\n            while (heap.top().first &#x3D;&#x3D; mi) &#123;&#x2F;&#x2F;while &#x3D;&#x3D; 去重\n                int p &#x3D; heap.top().second;\n                heap.pop();\n                idx[p]++;&#x2F;&#x2F;对Primes[p]右移&quot;倍数&quot;\n\n                if (1ll * res[idx[p]] * primes[p] &lt;&#x3D; INT_MAX)\n                    heap.push(make_pair(res[idx[p]] * primes[p], p));&#x2F;&#x2F;3*2 2*3 insert\n            &#125;\n        &#125;\n\n        return res[n - 1];\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;16606&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"314\"><a href=\"#314\" class=\"headerlink\" title=\"314.\"></a>314.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"315-计算右侧小于当前元素的个数-树状数组tr-in-x3D-cnt-O-nlogn\"><a href=\"#315-计算右侧小于当前元素的个数-树状数组tr-in-x3D-cnt-O-nlogn\" class=\"headerlink\" title=\"315.计算右侧小于当前元素的个数  树状数组tr[in]&#x3D;cnt O(nlogn)\"></a>315.计算右侧小于当前元素的个数  树状数组tr[in]&#x3D;cnt O(nlogn)</h1><p>idx：值域  val：cnt</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210807132528216.png\" alt=\"image-20210807132528216\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210807132425388.png\" alt=\"image-20210807132425388\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210807132820845.png\" alt=\"image-20210807132820845\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int n &#x3D; 20001;\n    vector&lt;int&gt; tr;\n\n    int lowbit(int x) &#123;\n        return x &amp; -x;\n    &#125;\n\n    int query(int x) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; x; i; i -&#x3D; lowbit(i)) res +&#x3D; tr[i];\n        return res;\n    &#125;\n\n    void add(int x, int v) &#123;\n        for(int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) tr[i] +&#x3D; v;\n    &#125;\n\n    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;\n        tr.resize(n + 1);&#x2F;&#x2F;tr[in] &#x3D; cnt\n        vector&lt;int&gt; res(nums.size());\n        for(int i &#x3D; nums.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n            int x &#x3D; nums[i] + 10001;&#x2F;&#x2F;0 1~20001\n            res[i] &#x3D; query(x - 1);\n            add(x, 1);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"316-x3D-1081-去除重复字母-得min字典序-贪心栈O-n-string-stk-in-stk-last-大-后面还有-非空就删stk-back\"><a href=\"#316-x3D-1081-去除重复字母-得min字典序-贪心栈O-n-string-stk-in-stk-last-大-后面还有-非空就删stk-back\" class=\"headerlink\" title=\"316[&#x3D;1081].去除重复字母 得min字典序 贪心栈O(n) string stk in_stk last 大 后面还有 非空就删stk.back()\"></a>316[&#x3D;1081].去除重复字母 得min字典序 贪心栈O(n) string stk in_stk last 大 后面还有 非空就删stk.back()</h1><p>贪心：</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210809200505196.png\" alt=\"image-20210809200505196\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string removeDuplicateLetters(string s) &#123;\n        string stk;\n        unordered_map&lt;char, bool&gt; ins;&#x2F;&#x2F;s[i]在结果stk里存在否 in_stk\n        unordered_map&lt;char, int&gt; last;&#x2F;&#x2F;s中last pos\n        for(int i &#x3D; 0; i &lt; s.size(); i++) last[s[i]]  &#x3D; i;&#x2F;&#x2F;后覆盖前\n\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(ins[s[i]]) continue;&#x2F;&#x2F;去重\n            while(stk.size() &amp;&amp; stk.back() &gt; s[i] &amp;&amp; last[stk.back()] &gt; i) &#123;&#x2F;&#x2F;大 后面还有 非空就删\n                ins[stk.back()] &#x3D; false;\n                stk.pop_back();\n            &#125;\n            stk +&#x3D; s[i];\n            ins[s[i]] &#x3D; true;\n        &#125;\n        return stk;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"317\"><a href=\"#317\" class=\"headerlink\" title=\"317.\"></a>317.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"318-最大单词长度乘积-不含公共字母-26-state-amp-x3D-x3D-0\"><a href=\"#318-最大单词长度乘积-不含公共字母-26-state-amp-x3D-x3D-0\" class=\"headerlink\" title=\"318.最大单词长度乘积 不含公共字母: 26 state &amp;&#x3D;&#x3D;0\"></a>318.最大单词长度乘积 不含公共字母: 26 state &amp;&#x3D;&#x3D;0</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210809204612686.png\" alt=\"image-20210809204612686\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;318.最大单词长度乘积 不含公共字母: 26 state &amp;&#x3D;&#x3D;0\n&#x2F;&#x2F; (暴力枚举) O(max(n*n,nL))\n&#x2F;&#x2F; 预处理出每个单词的二进制数字表示，二进制表示一共有 26 位，如果该单词含有字母 a，则第 0 位为 1，依次类推。\n&#x2F;&#x2F; 暴力枚举单词对，[如果两个单词的 按位与(&amp;) 为 0，则这两个单词可以被选择]，求长度的乘积和最大值作比较即可。\n\n&#x2F;&#x2F;集合元素很多：用哈希表unordered_map bitset\nclass Solution &#123;\npublic:\n    int maxProduct(vector&lt;string&gt;&amp; words) &#123;\n        vector&lt;int&gt; state;\n        \n        for(auto word: words) &#123;\n            int s &#x3D; 0;\n            for(auto c: word)\n                s |&#x3D; 1 &lt;&lt; (c - &#39;a&#39;);\n            state.push_back(s);\n        &#125;\n        \n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; words.size(); i++)\n            for(int j &#x3D; i + 1; j &lt; words.size(); j++)&#x2F;&#x2F;\n                if((state[i] &amp; state[j]) &#x3D;&#x3D; 0)\n                    res &#x3D; max(res, (int)(words[i].size() * words[j].size()));\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"319-灯泡开关-小数论：i的倍数按一下-第n次几个亮-sqrt-n-个平方数-idx亮-x3D-按【奇数】次-x3D-因子个数为【奇数】-lt-x3D-gt-完全平方数-1-3-9\"><a href=\"#319-灯泡开关-小数论：i的倍数按一下-第n次几个亮-sqrt-n-个平方数-idx亮-x3D-按【奇数】次-x3D-因子个数为【奇数】-lt-x3D-gt-完全平方数-1-3-9\" class=\"headerlink\" title=\"319.灯泡开关 小数论：i的倍数按一下 第n次几个亮(sqrt(n)个平方数)  idx亮&#x3D;按【奇数】次&#x3D;因子个数为【奇数】&lt;&#x3D;&gt;完全平方数 1 [3] 9\"></a>319.灯泡开关 小数论：i的倍数按一下 第n次几个亮(sqrt(n)个平方数)  idx亮&#x3D;按【奇数】次&#x3D;因子个数为【奇数】&lt;&#x3D;&gt;完全平方数 1 [3] 9</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210809205454630.png\" alt=\"image-20210809205454630\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;319.灯泡开关 小数论：i的倍数按一下 第n次几个亮(sqrt(n)个平方数) \n&#x2F;&#x2F; idx亮&#x3D;按【奇数】次&#x3D;因子个数为【奇数】&lt;&#x3D;&gt;完全平方数 1 [3] 9\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;346&#x2F;\nclass Solution &#123;\npublic:\n    int bulbSwitch(int n) &#123;\n        return sqrt(n);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"320\"><a href=\"#320\" class=\"headerlink\" title=\"320.\"></a>320.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"！321-拼接最大数-保序-max字典序【类似318】-贪心合并-先选大的：证明方法1087\"><a href=\"#！321-拼接最大数-保序-max字典序【类似318】-贪心合并-先选大的：证明方法1087\" class=\"headerlink\" title=\"！321.拼接最大数 保序 max字典序【类似318】 贪心合并 先选大的：证明方法1087\"></a>！321.拼接最大数 保序 max字典序【类似318】 贪心合并 先选大的：证明方法1087</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210809231108988.png\" alt=\"image-20210809231108988\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;321.拼接最大数 保序 max字典序\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;create-maximum-number&#x2F;solution&#x2F;pin-jie-zui-da-shu-by-leetcode-solution&#x2F;\n&#x2F;&#x2F;官方 单调栈\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;create-maximum-number&#x2F;solution&#x2F;c-dong-gui-tan-xin-dan-diao-zhan-by-_dc-qr4o&#x2F;\n&#x2F;&#x2F; 贪心算法合并两个最大子序列，参考【1754.构造字典序最大的合并字符串。】\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;largest-merge-of-two-strings&#x2F;solution&#x2F;c-shuang-zhi-zhen-bian-li-zui-you-xuan-z-g2dx&#x2F;\n\n&#x2F;*\n解题思路\n首先看完题目，知道所求为最大字典序\n如此以来，我们每次都要最优的选择字符，可以使用双指针表示现在取到哪个字符\n选择判断如下：\n两个字符串都没拿完\n如果两个开头字符不一致，选择更大的加入结果\n如果两个的开头字符一致，需要向后查找，选择后续中更大的哪个\n举例说明上述情况并验证正确性：\nca、cb：开头c相等，后续b&gt;a,选择第二个c取走（其实这种情况无所谓，因为b比c小，下一次还是拿c）\nca、cd：开头c相等，后续d&gt;a，【选择第二个c取走，保证后续d可以先取】，更大字典序\ncd、ce：同理，选择第二c\ncabc、cabce：【长度不等，匹配到一个字符串匹配完也没分出胜负，这时候需要取更长】的那条，这是因为【后续可能会出现更大的，比如这个例子中的e，但是没有发现】\n有一个字符串拿完了，直接拼接另一个字符串的剩余结果即可\n这题思路不难，但是考验自己的严谨性，希望都能自己实现\n*&#x2F;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;347&#x2F;\n&#x2F;&#x2F; (贪心) O(n3)\n&#x2F;&#x2F; 第3步，也用贪心来做，每次要选择将哪个数列的开头插入结果数列。我们比较两个数列的字典序，【优先从字典序大的数列中选】。\n&#x2F;&#x2F; 考察思路 和 证明为什么该做法正确！【选择第二个c取走，保证后续d可以先取】【长度不等，匹配到一个字符串匹配完也没分出胜负，这时候需要取更长】\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;\n        int n &#x3D; nums1.size(), m &#x3D; nums2.size();\n        vector&lt;int&gt; res(k, INT_MIN);\n        for (int i &#x3D; max(0, k - m); i &lt;&#x3D; min(k, n); i ++ ) &#123;&#x2F;&#x2F;2 m&lt;k:1 最少选k-m&gt;0个\n            vector&lt;int&gt; N &#x3D; maxArray(nums1, i);\n            vector&lt;int&gt; M &#x3D; maxArray(nums2, k - i);\n            vector&lt;int&gt; temp &#x3D; merge(N, M);\n            res &#x3D; max(res, temp);\n        &#125;\n        return res;\n    &#125;\n\n    vector&lt;int&gt; merge(vector&lt;int&gt;&amp; N, vector&lt;int&gt;&amp; M) &#123;\n        vector&lt;int&gt; res;\n        while (N.size() &amp;&amp; M.size())\n            if (N &gt; M)\n                res.push_back(N[0]), N.erase(N.begin());\n            else\n                res.push_back(M[0]), M.erase(M.begin());\n        while (N.size()) res.push_back(N[0]), N.erase(N.begin());\n        while (M.size()) res.push_back(M[0]), M.erase(M.begin());\n        return res;\n    &#125;\n\n    vector&lt;int&gt; maxArray(vector&lt;int&gt;&amp; nums, int k) &#123;&#x2F;&#x2F;nums中选k个 最大字典序\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; res(k);\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ ) &#123;\n        \tint x &#x3D; nums[i];\n            while (j &amp;&amp; res[j - 1] &lt; x &amp;&amp; j + n - i &gt; k) j -- ;&#x2F;&#x2F;j+n-i&gt;k 有资本去删\n            if (j &lt; k) res[j ++ ] &#x3D; x;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"322-零钱兑换-acw3完全背包-体积v-价值1\"><a href=\"#322-零钱兑换-acw3完全背包-体积v-价值1\" class=\"headerlink\" title=\"322.零钱兑换 acw3完全背包 体积v 价值1\"></a>322.零钱兑换 acw3完全背包 体积v 价值1</h1><p>面额&#x3D;体积 求最少个数，个数&#x3D;价值</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810092615475.png\" alt=\"image-20210810092615475\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;322.零钱兑换 acw3完全背包 体积v 价值1\n&#x2F;&#x2F; 装满背包最少需要多少价值的物品？\n&#x2F;&#x2F; 状态表示： f[j] 表示凑出 j 体积的钱，最少需要多少价值。\nclass Solution &#123;\npublic:\n\n    int INF &#x3D; 1000000000;\n\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;\n        vector&lt;int&gt; f(amount + 1, INF);\n        f[0] &#x3D; 0;\n        for (auto v: coins)\n            for (int j &#x3D; v; j &lt;&#x3D; amount; j ++ )\n                f[j] &#x3D; min(f[j], f[j - v] + 1);&#x2F;&#x2F;完全背包\n        if (f[amount] &#x3D;&#x3D; INF) f[amount] &#x3D; -1;\n        return f[amount];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"323\"><a href=\"#323\" class=\"headerlink\" title=\"323.\"></a>323.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"324-摆动排序II-nth-element-LC75三数排序-A-i\"><a href=\"#324-摆动排序II-nth-element-LC75三数排序-A-i\" class=\"headerlink\" title=\"324.摆动排序II nth_element LC75三数排序 A(i)\"></a>324.摆动排序II nth_element LC75三数排序 A(i)</h1><p>Tn&#x3D;O(n) Sn&#x3D;O(logn)</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810095858098.png\" alt=\"image-20210810095858098\"></p>\n<p>快速选择算法：acw786第k个数</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810103232426.png\" alt=\"image-20210810103232426\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810103830529.png\" alt=\"image-20210810103830529\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;++ &gt;-- | &gt;&#x3D; &lt;&#x3D; swap | &lt;&#x3D; &gt;&#x3D;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810100916043.png\" alt=\"image-20210810100916043\"></p>\n<p>三数排序LC75 荷兰国旗 三指针 cnt+覆盖</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810100614210.png\" alt=\"image-20210810100614210\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210330225227198.png\" alt=\"image-20210330225227198\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void wiggleSort(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        auto midptr &#x3D; nums.begin() + n &#x2F; 2;\n        nth_element(nums.begin(), midptr, nums.end());&#x2F;&#x2F;快速选择算法 找中位数\n        int mid &#x3D; *midptr;\n\n        #define A(i) nums[(i * 2 + 1) % (n | 1)] &#x2F;&#x2F;\n        &#x2F;&#x2F;三数排序\n        for (int i &#x3D; 0, j &#x3D; 0, k &#x3D; n - 1; i &lt;&#x3D; k;) &#123;&#x2F;&#x2F;ji k i&gt;k结束\n            if (A(i) &gt; mid) swap(A(i ++ ), A(j ++ ));&#x2F;&#x2F;0 1\n            else if (A(i) &lt; mid) swap(A(i), A(k -- ));&#x2F;&#x2F;2 i不动\n            else i ++ ;\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"325\"><a href=\"#325\" class=\"headerlink\" title=\"325.\"></a>325.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"326-3的幂-n-3-19-x3D-1162261467-计算器\"><a href=\"#326-3的幂-n-3-19-x3D-1162261467-计算器\" class=\"headerlink\" title=\"326.3的幂 n|3^19&#x3D;1162261467 计算器\"></a>326.3的幂 n|3^19&#x3D;1162261467 计算器</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;\n        return n &gt; 0 &amp;&amp; 1162261467 % n &#x3D;&#x3D; 0;&#x2F;&#x2F;n|3^19&#x3D;1162261467 计算器\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;解法1：循环\nclass Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;\n        if(n&#x3D;&#x3D;1) return true;\n        long m&#x3D;1;\n        while(m&lt;n)\n        &#123;\n            m*&#x3D;3;\n            if(m&#x3D;&#x3D;n)\n                return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n&#x2F;&#x2F;解法2：递归\nclass Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;\n        if(n&#x3D;&#x3D;1) return true;\n        else if(n&#x3D;&#x3D;0) return false;\n        else return isPowerOfThree(n &#x2F; 3) &amp;&amp; n % 3 &#x3D;&#x3D; 0;&#x2F;&#x2F;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"！327-区间和的个数-前缀和-离散化-树状数组\"><a href=\"#！327-区间和的个数-前缀和-离散化-树状数组\" class=\"headerlink\" title=\"！327.区间和的个数 前缀和 离散化+树状数组\"></a>！327.区间和的个数 前缀和 离散化+树状数组</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810111034327.png\" alt=\"image-20210810111034327\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;327.区间和的个数 前缀和 离散化+树状数组\n&#x2F;&#x2F; 手写平衡树 set不行：快速求在区间[]内的个数\n&#x2F;&#x2F; 保序离散化[hash表不行]+树状数组&#x3D;山寨版平衡树 O(nlogn)\n&#x2F;*\n所求为si - upper ~ s1 - lower这个范围内满足的区间个数\n这个区间个数利用树状数组快速求除，即f(s1 - lower) - f(s1 - upper -1)\n所以树状树组中维护的是 前缀和的个数\n前缀和也有0的情况， 所以需要加入到树状数组 即 add(get(0), 1);\n因为对所有前缀和进行了离散化， 0属于前缀和，因此也需要离散化。\n*&#x2F;\ntypedef long long LL;\n\nclass Solution &#123;\npublic:\n    int m;&#x2F;&#x2F;tr_len\n    vector&lt;int&gt; tr;&#x2F;&#x2F;存&lt;&#x3D;x的前缀和的个数:f\n    vector&lt;LL&gt; numbers;&#x2F;&#x2F;离散化\n\n    int get(LL x) &#123;&#x2F;&#x2F;lower_bound：&gt;&#x3D;x的第一个idx+1\n        return lower_bound(numbers.begin(), numbers.end(), x) - numbers.begin() + 1;\n    &#125;\n\n    int lowbit(int x) &#123;\n        return x &amp; -x;\n    &#125;\n\n    void add(int x, int v) &#123;\n        for (int i &#x3D; x; i &lt;&#x3D; m; i +&#x3D; lowbit(i)) tr[i] +&#x3D; v;\n    &#125;\n\n    int query(int x) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; x; i; i -&#x3D; lowbit(i)) res +&#x3D; tr[i];\n        return res;\n    &#125;\n\n    int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;LL&gt; s(n + 1);\n        numbers.push_back(0);&#x2F;&#x2F;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;\n            s[i] &#x3D; s[i - 1] + nums[i - 1];\n            numbers.push_back(s[i]);\n            numbers.push_back(s[i] - lower);\n            numbers.push_back(s[i] - upper - 1);\n        &#125;\n        sort(numbers.begin(), numbers.end());\n        numbers.erase(unique(numbers.begin(), numbers.end()), numbers.end());&#x2F;&#x2F;重复置end后\n        \n        m &#x3D; numbers.size();\n        tr.resize(m + 1);&#x2F;&#x2F;1~\n\n        int res &#x3D; 0;\n        add(get(0), 1);&#x2F;&#x2F;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;\n            res +&#x3D; query(get(s[i] - lower)) - query(get(s[i] - upper - 1));\n            add(get(s[i]), 1);\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;477194&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F; AcWing802 离散化复习！\nint find(int x)\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)&#x2F;&#x2F;&gt;&#x3D;x的第一个位置\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1;&#x2F;&#x2F;1~n\n&#125;\n\nvector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a)\n&#123;\n    int j &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; a.size(); i ++ )\n        if (!i || a[i] !&#x3D; a[i - 1])\n            a[j ++ ] &#x3D; a[i];\n    &#x2F;&#x2F; a[0] ~ a[j - 1] 所有a中不重复的数\n\n    return a.begin() + j;\n&#125;\n\n&#x2F;&#x2F;?待看ing\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;5007&#x2F;\n&#x2F;*\n算法2\n(分治) O(nlogn)\n我们采取分治的思想。首先求出前缀和数组（包括开头的 0）sum，在这个数组上采用分治算法：每次将数组平均分为两部分，递归处理左右两部分内部的答案，然后将左右两部分内部从小到大排序，最后归并跨越左右两部分的答案。\n接下来讨论如何求跨越两部分的答案：假设左右两部分已经从小到大排好序，我们设 i 为右部分的某个位置，对于每个 i，都有一个在左部分连续的区间 [j, k]， 对应着合法答案的区间，即 sum[i] - sum[j], sum[i] - sum[j + 1], ..., sum[i] - sum[k] 都是在 [lower, upper] 中。随着 i 向右移动，这个区间也会整体向右移动。这给我们提供了滑动窗口的思想，我们实时维护这个窗口，可以在均摊 O(1) 的时间内找到每个 i 对应的区间。\n然后利用归并排序的思想将当前区间排序。\n时间复杂度\n时间和归并排序一样，每一层内部的时间复杂度为 O(n)，共 O(log⁡n) 层，故总时间复杂度为 O(nlog⁡n)。\n空间复杂度\n归并排序需要线性的额外空间。\nC++ 代码\n*&#x2F; \n#define LL long long\n\nclass Solution &#123;\npublic:\n    int ans;\n\n    void solve(vector&lt;LL&gt;&amp; sum, int l, int r, int lower, int upper) &#123;\n        if (l &#x3D;&#x3D; r)\n            return;\n\n        int mid &#x3D; (l + r) &gt;&gt; 1;\n        solve(sum, l, mid, lower, upper);\n        solve(sum, mid + 1, r, lower, upper);\n\n        for (int i &#x3D; mid + 1, j &#x3D; l, k &#x3D; l; i &lt;&#x3D; r; i++) &#123;\n            while (j &lt;&#x3D; mid &amp;&amp; sum[i] - sum[j] &gt; upper) j++;\n            while (k &lt;&#x3D; mid &amp;&amp; sum[i] - sum[k] &gt;&#x3D; lower) k++;\n            ans +&#x3D; k - j;\n        &#125;\n\n        vector&lt;LL&gt; cpy(r - l + 1);\n        int cnt &#x3D; 0;\n\n        int i &#x3D; l, j &#x3D; mid + 1;\n        while (i &lt;&#x3D; mid || j &lt;&#x3D; r) &#123;\n            if (i &#x3D;&#x3D; mid + 1) cpy[cnt++] &#x3D; sum[j++];\n            else if (j &#x3D;&#x3D; r + 1) cpy[cnt++] &#x3D; sum[i++];\n            else &#123;\n                if (sum[i] &lt; sum[j]) cpy[cnt++] &#x3D; sum[i++];\n                else cpy[cnt++] &#x3D; sum[j++];\n            &#125;\n        &#125;\n        for (int i &#x3D; l; i &lt;&#x3D; r; i++) sum[i] &#x3D; cpy[i - l];\n    &#125;\n\n    int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;LL&gt; sum(n + 1);\n        sum[0] &#x3D; 0;\n\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            sum[i] &#x3D; sum[i - 1] + nums[i - 1];\n\n        ans &#x3D; 0;\n        solve(sum, 0, n, lower, upper);\n\n        return ans;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"328-奇偶链表oh-ot-eh-et-p\"><a href=\"#328-奇偶链表oh-ot-eh-et-p\" class=\"headerlink\" title=\"328. 奇偶链表oh ot eh et p\"></a>328. 奇偶链表oh ot eh et p</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;328.奇偶链表oh ot eh et\nclass Solution &#123;\npublic:\n    ListNode* oddEvenList(ListNode* head) &#123;\n        if(!head || !head-&gt;next) return head;\n        auto oh &#x3D; head, ot &#x3D; oh;\n        auto eh &#x3D; head-&gt;next, et &#x3D; eh;\n        for(auto p &#x3D; head-&gt;next-&gt;next; p;) &#123;\n            ot &#x3D; ot-&gt;next &#x3D; p;&#x2F;&#x2F;\n            p &#x3D; p-&gt;next;\n            if (p) &#123;\n                et &#x3D; et-&gt;next &#x3D; p;\n                p &#x3D; p-&gt;next;\n            &#125;\n        &#125;\n        ot-&gt;next &#x3D; eh;\n        et-&gt;next &#x3D; NULL;\n        return oh;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"329-矩阵中的最长递增路径-poj滑雪-DP的记忆化搜索写法-dfs按拓扑序来算\"><a href=\"#329-矩阵中的最长递增路径-poj滑雪-DP的记忆化搜索写法-dfs按拓扑序来算\" class=\"headerlink\" title=\"329. 矩阵中的最长递增路径 poj滑雪 DP的记忆化搜索写法 dfs按拓扑序来算\"></a>329. 矩阵中的最长递增路径 poj滑雪 DP的记忆化搜索写法 dfs按拓扑序来算</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810162531754.png\" alt=\"image-20210810162531754\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;记忆化搜索的思想是对于每个状态，只要搜索一次以后，记录下这个状态的最优值，以后在需要用到这个状态就不必要搜索了，因为无后效性，最优永远都不变。\nclass Solution &#123;\npublic:\n    int n, m;\n    vector&lt;vector&lt;int&gt;&gt; f, w;\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    int dp(int x, int y) &#123;&#x2F;&#x2F;xy为起点的最长距离v\n        auto&amp; v &#x3D; f[x][y];\n        if (v !&#x3D; -1) return v;&#x2F;&#x2F;记忆化搜索\n        v &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; w[x][y] &lt; w[a][b])&#x2F;&#x2F;\n                v &#x3D; max(v, dp(a, b) + 1);&#x2F;&#x2F;\n        &#125;\n        return v;\n    &#125;\n\n    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if (matrix.empty() || matrix[0].empty()) return 0;\n        w &#x3D; matrix;\n        n &#x3D; w.size(), m &#x3D; w[0].size();\n        f &#x3D; vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m, -1));&#x2F;&#x2F;-1\n\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            for (int j &#x3D; 0; j &lt; m; j ++ )\n                res &#x3D; max(res, dp(i, j));\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"330-按要求补齐数组-分类-贪心\"><a href=\"#330-按要求补齐数组-分类-贪心\" class=\"headerlink\" title=\"330.按要求补齐数组 分类+贪心\"></a>330.按要求补齐数组 分类+贪心</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210810171043375.png\" alt=\"image-20210810171043375\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;330.按要求补齐数组 分类+贪心\nclass Solution &#123;\npublic:\n    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;\n        long long x &#x3D; 1;\n        int i &#x3D; 0, res &#x3D; 0;\n        while (x &lt;&#x3D; n) &#123;&#x2F;&#x2F;[0,x)\n            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; x) x +&#x3D; nums[i ++ ];&#x2F;&#x2F;\n            else &#123;\n                x +&#x3D; x;&#x2F;&#x2F;补充x\n                res ++ ;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"331-验证二叉树的前序序列化-唯一\"><a href=\"#331-验证二叉树的前序序列化-唯一\" class=\"headerlink\" title=\"331. 验证二叉树的前序序列化 #唯一\"></a>331. 验证二叉树的前序序列化 #唯一</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;331.验证二叉树的前序序列化\n&#x2F;&#x2F; 如果递归还没结束但数组已经遍历完，或者递归结束但数组还没遍历完，则说明给定的序列不是一个合法的前序遍历。\nclass Solution &#123;\npublic:\n    bool ans &#x3D; true;\n    bool isValidSerialization(string preorder) &#123;\n        preorder +&#x3D; &#39;,&#39;;&#x2F;&#x2F;\n        int u &#x3D; 0;\n        dfs(preorder, u);\n        return ans &amp;&amp; u &#x3D;&#x3D; preorder.size();&#x2F;&#x2F;在该结束的时候没结束\n    &#125;\n\n    void dfs(string &amp;preorder, int &amp;u)\n    &#123;\n        if (u &#x3D;&#x3D; preorder.size())&#x2F;&#x2F;在不该结束的时候结束了\n        &#123;\n            ans &#x3D; false;\n            return;\n        &#125;\n        if (preorder[u] &#x3D;&#x3D; &#39;#&#39;)\n        &#123;\n            u +&#x3D; 2;\n            return;\n        &#125;\n        while (preorder[u] !&#x3D; &#39;,&#39;) u ++ ; u ++ ;\n        dfs(preorder, u);\n        dfs(preorder, u);&#x2F;&#x2F;右子树\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;357&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n    \n    \nclass Solution &#123;\npublic:\n    int k;\n    string s;\n\n    bool isValidSerialization(string _s) &#123;\n        k &#x3D; 0;\n        s &#x3D; _s + &#39;,&#39;;&#x2F;&#x2F;\n        if (!dfs()) return false;\n        return k &#x3D;&#x3D; s.size();\n    &#125;\n\n    bool dfs() &#123;\n    \t&#x2F;&#x2F; 递归下去一定是这个点有东西，如果发现应该有东西但是字符串没有了那就不合法\n        if (k &#x3D;&#x3D; s.size()) return false;\n        if (s[k] &#x3D;&#x3D; &#39;#&#39;) return k +&#x3D; 2, true;\n        while (s[k] !&#x3D; &#39;,&#39;) k ++ ;\n        k ++ ;\n        &#x2F;&#x2F; 再依次遍历左子树和右子树\n        return dfs() &amp;&amp; dfs();\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;481298&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;法2 Java\nclass Solution &#123;\n    public boolean isValidSerialization(String preorder) &#123;\n        if (preorder &#x3D;&#x3D; null || preorder.length() &#x3D;&#x3D; 0) return false;\n        String[] chrs &#x3D; preorder.split(&quot;,&quot;);\n        int cnt &#x3D; 1;&#x2F;&#x2F;root多1\n        &#x2F;&#x2F; 一棵树总是以 # 封口，看出口数和封口数是否相等\n        &#x2F;&#x2F; 【根节点有两个出口】【每多个非空节点则会多一个出口，每个空节点为一个封口】\n        for (String chr : chrs) &#123;\n            if (cnt &#x3D;&#x3D; 0) return false;&#x2F;&#x2F;&gt;0,提前结束！\n            cnt +&#x3D; chr.equals(&quot;#&quot;) ? -1 : 1;&#x2F;&#x2F;\n        &#125;\n        return cnt &#x3D;&#x3D; 0;\n    &#125;\n&#125;\n\n作者：我要番茄锅\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;475450&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n\n\n\n\n<h1 id=\"332-重新安排行程-有向图求字典序最小的欧拉路径-蓝书P409-multiset平衡树-erase-回溯-入模拟ans栈\"><a href=\"#332-重新安排行程-有向图求字典序最小的欧拉路径-蓝书P409-multiset平衡树-erase-回溯-入模拟ans栈\" class=\"headerlink\" title=\"332.重新安排行程 有向图求字典序最小的欧拉路径 蓝书P409 multiset平衡树 erase 回溯 入模拟ans栈\"></a>332.重新安排行程 有向图求字典序最小的欧拉路径 蓝书P409 multiset平衡树 erase 回溯 入模拟ans栈</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;复习：提高课 欧拉路径 同acw1124骑马修栅栏\n&#x2F;&#x2F;332.重新安排行程 有向图求字典序最小的欧拉路径 蓝书P409\nclass Solution &#123;\npublic:\n    unordered_map&lt;string, multiset&lt;string&gt;&gt; g;\n    vector&lt;string&gt; ans;\n\n    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;\n        for(auto&amp; e: tickets) g[e[0]].insert(e[1]);\n        dfs(&quot;JFK&quot;);&#x2F;&#x2F;回溯push 栈逆序\n        reverse(ans.begin(), ans.end());\n        return ans;\n    &#125;\n\n    void dfs(string u) &#123;\n        while(g[u].size()) &#123;\n            auto ver &#x3D; *g[u].begin();&#x2F;&#x2F;multiset平衡树 第一个元素就是min\n            g[u].erase(g[u].begin());&#x2F;&#x2F;erase &#x3D;&#x3D; 自动跳过visited head[x]\n            dfs(ver);\n        &#125;\n        ans.push_back(u);&#x2F;&#x2F;回溯 入模拟ans栈\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"333\"><a href=\"#333\" class=\"headerlink\" title=\"333.\"></a>333.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"334-递增的三元子序列-300-二分LIS简化版-len-gt-x3D-3即可\"><a href=\"#334-递增的三元子序列-300-二分LIS简化版-len-gt-x3D-3即可\" class=\"headerlink\" title=\"334.递增的三元子序列 300.二分LIS简化版 len&gt;&#x3D;3即可\"></a>334.递增的三元子序列 300.二分LIS简化版 len&gt;&#x3D;3即可</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210811105317952.png\" alt=\"image-20210811105317952\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;334.递增的三元子序列 300.二分LIS简化版 len&gt;&#x3D;3即可\n&#x2F;&#x2F; O(n) O(1)\nclass Solution &#123;\npublic:\n    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt;q(2, INT_MAX);\n        for(auto a: nums) &#123;\n            int k &#x3D; 2;\n            while(k &gt; 0 &amp;&amp; q[k - 1] &gt;&#x3D; a) k -- ;&#x2F;&#x2F;k:first &gt;&#x3D;a q递增\n            if(k &#x3D;&#x3D; 2) return true;&#x2F;&#x2F;len&gt;&#x3D;3\n            q[k] &#x3D; a;&#x2F;&#x2F;q[k]：k+1长LIS末尾min值\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"335-路径交叉-模拟分类特判\"><a href=\"#335-路径交叉-模拟分类特判\" class=\"headerlink\" title=\"335.路径交叉 模拟分类特判\"></a>335.路径交叉 模拟分类特判</h1><p>向内卷&#x3D;&#x3D;第一类</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210811113408333.png\" alt=\"image-20210811113408333\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isSelfCrossing(vector&lt;int&gt;&amp; x) &#123;\n        int n &#x3D; x.size();\n        if(n &lt;&#x3D; 3) return false;\n        for(int i &#x3D; 3; i &lt; n; i++) &#123;\n            if(x[i - 1] &lt;&#x3D; x[i - 3] &amp;&amp; x[i] &gt;&#x3D; x[i - 2]) return true;\n            if(i &gt;&#x3D; 4 &amp;&amp; x[i - 3] &#x3D;&#x3D; x[i - 1] &amp;&amp; x[i] + x[i - 4] &gt;&#x3D;  x[i - 2]) return true;\n            if(i &gt;&#x3D; 5 &amp;&amp; x[i - 3] &gt;&#x3D; x[i - 1] &amp;&amp; x[i - 1] + x[i - 5] &gt;&#x3D; x[i - 3] &amp;&amp; x[i - 2] &gt;&#x3D; x[i - 4] &amp;&amp; x[i] + x[i - 4] &gt;&#x3D; x[i - 2]) \n                return true;&#x2F;&#x2F;x[i - 3] &gt;&#x3D; x[i - 1] 才有i交的可能，而不是i-3&gt;i-5!!!i-2&gt;&#x3D;i-4 向外扩\n        &#125;\n        return false;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"336-回文对-O-nL-2-hash-x-x3D-i-gt-x3D-lt-check\"><a href=\"#336-回文对-O-nL-2-hash-x-x3D-i-gt-x3D-lt-check\" class=\"headerlink\" title=\"336.回文对 O(nL^2) hash[x]&#x3D;i &gt;&#x3D; &lt; check\"></a>336.回文对 O(nL^2) hash[x]&#x3D;i &gt;&#x3D; &lt; check</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210811120753555.png\" alt=\"image-20210811120753555\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;336.回文对\n&#x2F;&#x2F;给定一组互不相同的单词，找出所有不同的索引对(i,j)：两词拼成回文串\nclass Solution &#123;\npublic:\n    bool check(string&amp; s) &#123;&#x2F;&#x2F;首尾双指针\n        for (int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; i ++, j -- )\n            if (s[i] !&#x3D; s[j])\n                return false;\n        return true;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) &#123;\n        unordered_map&lt;string, int&gt; hash;\n        for (int i &#x3D; 0; i &lt; words.size(); i ++ ) &#123;\n            auto w &#x3D; words[i];\n            reverse(w.begin(), w.end());\n            hash[w] &#x3D; i;&#x2F;&#x2F;idx\n        &#125;\n\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (int i &#x3D; 0; i &lt; words.size(); i ++ ) &#123;\n            auto w &#x3D; words[i];\n            for (int j &#x3D; 0; j &lt;&#x3D; w.size(); j ++ ) &#123;&#x2F;&#x2F;枚举分界点\n                auto left &#x3D; w.substr(0, j), right &#x3D; w.substr(j);\n                if (check(right) &amp;&amp; hash.count(left) &amp;&amp; hash[left] !&#x3D; i) &#x2F;&#x2F;i!&#x3D;j ij串长相等 只在情况一中算 避免重复！\n                \tres.push_back(&#123;i, hash[left]&#125;);&#x2F;&#x2F;&gt;&#x3D;\n                if (check(left) &amp;&amp; hash.count(right) &amp;&amp; hash[right] !&#x3D; i &amp;&amp; w.size() !&#x3D; words[hash[right]].size())\n                    res.push_back(&#123;hash[right], i&#125;);&#x2F;&#x2F;&lt;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"337-打家劫舍III-相隔max-树形DP：局部递归-不选-选\"><a href=\"#337-打家劫舍III-相隔max-树形DP：局部递归-不选-选\" class=\"headerlink\" title=\"337.打家劫舍III 相隔max 树形DP：局部递归{不选, 选}\"></a>337.打家劫舍III 相隔max 树形DP：局部递归{不选, 选}</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210811171728003.png\" alt=\"image-20210811171728003\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;337.打家劫舍III 相隔max 树形DP：局部递归\n&#x2F;&#x2F; 扩展多叉：基础课树形DP acw285.没有上司的舞会\n&#x2F;&#x2F; 310.最小高度树 有上有下 换根DP 难\nclass Solution &#123;\npublic:\n    int rob(TreeNode* root) &#123;\n        auto f &#x3D; dfs(root);\n        return max(f[0], f[1]);\n    &#125;\n\n    vector&lt;int&gt; dfs(TreeNode* u) &#123;\n        if(!u) return &#123;0, 0&#125;;\n        auto x &#x3D; dfs(u-&gt;left), y &#x3D; dfs(u-&gt;right);\n        return &#123;max(x[0], x[1]) + max(y[0], y[1]), x[0] + y[0] + u-&gt;val&#125;;&#x2F;&#x2F;&#123;不选, 选&#125;\n    &#125;\n&#125;;\n\n\n</code></pre>\n\n\n\n<h1 id=\"338-比特位计数-前n-bin-cnt1-f-i-x3D-f-i-gt-gt-1-i-amp-1-x2F-x2F-递推\"><a href=\"#338-比特位计数-前n-bin-cnt1-f-i-x3D-f-i-gt-gt-1-i-amp-1-x2F-x2F-递推\" class=\"headerlink\" title=\"338.比特位计数 前n_bin_cnt1[] f[i] &#x3D; f[i &gt;&gt; 1] + (i &amp; 1);&#x2F;&#x2F;递推\"></a>338.比特位计数 前n_bin_cnt1[] f[i] &#x3D; f[i &gt;&gt; 1] + (i &amp; 1);&#x2F;&#x2F;递推</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countBits(int n) &#123;\n        vector&lt;int&gt; f(n + 1);\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            f[i] &#x3D; f[i &gt;&gt; 1] + (i &amp; 1);&#x2F;&#x2F;递推\n        return f;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"339\"><a href=\"#339\" class=\"headerlink\" title=\"339.\"></a>339.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"340\"><a href=\"#340\" class=\"headerlink\" title=\"340.\"></a>340.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n\n\n<h1 id=\"341-扁平化嵌套列表迭代器-递归dfs、stk-jump-设计\"><a href=\"#341-扁平化嵌套列表迭代器-递归dfs、stk-jump-设计\" class=\"headerlink\" title=\"341.扁平化嵌套列表迭代器 递归dfs、stk jump 设计\"></a>341.扁平化嵌套列表迭代器 递归dfs、stk jump 设计</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210811182250761.png\" alt=\"image-20210811182250761\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;341.扁平化嵌套列表迭代器 stk 设计\n&#x2F;&#x2F;递归版dfs\nclass NestedIterator &#123;\npublic:\n    vector&lt;int&gt; q;\n    int k;\n\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;\n        k &#x3D; 0;\n        for(auto&amp; l: nestedList) dfs(l);&#x2F;&#x2F;\n    &#125;\n\n    void dfs(NestedInteger&amp; l) &#123;\n       if(l.isInteger()) q.push_back(l.getInteger());\n       else &#123;\n            for(auto&amp; x: l.getList())\n                dfs(x);\n       &#125;\n    &#125;\n    \n    int next() &#123;\n        return q[k++];\n    &#125;\n    \n    bool hasNext() &#123;\n        return k &lt; q.size();\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;转非递归版 易错，用处不大了 Linux默认栈空间1M调大至mem空间即可，且系统stk更快\nclass NestedIterator &#123;\npublic:\n    struct Node &#123;\n        vector&lt;NestedInteger&gt; l;\n        int k;\n    &#125;;\n    stack&lt;Node&gt; stk;\n\n    void jump() &#123;&#x2F;&#x2F;跳到下一个int\n        while(stk.size()) &#123;\n            auto t &#x3D; stk.top();\n            if(t.k &#x3D;&#x3D; t.l.size()) &#123;&#x2F;&#x2F;\n                stk.pop();\n                continue;\n            &#125;\n            if(t.l[t.k].isInteger()) break;\n            stk.pop();&#x2F;&#x2F;删cur\n            stk.push(&#123;t.l, t.k + 1&#125;);&#x2F;&#x2F;内部k&#x3D;&#x3D;l.size() pop,先存下k+1\n            stk.push(&#123;t.l[t.k].getList(), 0&#125;);\n        &#125;\n    &#125;\n\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;\n        stk.push(&#123;nestedList, 0&#125;);\n        jump();\n    &#125;\n    \n    int next() &#123;\n        auto t &#x3D; stk.top();\n        stk.pop();\n        stk.push(&#123;t.l, t.k + 1&#125;);\n        jump();\n        return t.l[t.k].getInteger();\n    &#125;\n    \n    bool hasNext() &#123;\n        return stk.size();\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"342-4的幂-gt-0-平方数-只含因子2\"><a href=\"#342-4的幂-gt-0-平方数-只含因子2\" class=\"headerlink\" title=\"342.4的幂 &gt;0 平方数 只含因子2\"></a>342.4的幂 &gt;0 平方数 只含因子2</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210811174131981.png\" alt=\"image-20210811174131981\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isPowerOfFour(int n) &#123;\n        if(n &lt;&#x3D; 0) return false;&#x2F;&#x2F;&gt;0\n        int r &#x3D; sqrt(n);\n        if(r * r !&#x3D; n) return false;&#x2F;&#x2F;平方数\n        return (1 &lt;&lt; 30) % n &#x3D;&#x3D; 0;&#x2F;&#x2F;只含因子2\n        &#x2F;&#x2F; return (n &amp; -n) &#x3D;&#x3D; n;&#x2F;&#x2F;2的幂\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"343-整数拆分-小学数奥-求最大乘积-证明！-尽量分成3和2-lt-x3D-2个2-n-gt-x3D-5-先满足3\"><a href=\"#343-整数拆分-小学数奥-求最大乘积-证明！-尽量分成3和2-lt-x3D-2个2-n-gt-x3D-5-先满足3\" class=\"headerlink\" title=\"343.整数拆分 小学数奥:求最大乘积 证明！ 尽量分成3和2 &lt;&#x3D;2个2(n&gt;&#x3D;5 先满足3)\"></a>343.整数拆分 小学数奥:求最大乘积 证明！ 尽量分成3和2 &lt;&#x3D;2个2(n&gt;&#x3D;5 先满足3)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210811204742464.png\" alt=\"image-20210811204742464\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int integerBreak(int n) &#123;\n        if(n &lt;&#x3D; 3) return 1 * (n - 1);&#x2F;&#x2F;至少分成两个\n        int p &#x3D; 1;&#x2F;&#x2F;product\n        while(n &gt;&#x3D; 5) n -&#x3D; 3, p *&#x3D; 3;&#x2F;&#x2F;先满足3\n        return p * n;&#x2F;&#x2F;2 3 4&#x3D;2*2\n\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"344-反转字符串-双指针swap\"><a href=\"#344-反转字符串-双指针swap\" class=\"headerlink\" title=\"344.反转字符串 双指针swap\"></a>344.反转字符串 双指针swap</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void reverseString(vector&lt;char&gt;&amp; s) &#123;\n        for(int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; i++, j--)\n            swap(s[i], s[j]);\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"345-反转字符串中的元音字母-s-find-tolower-c-x3D-1\"><a href=\"#345-反转字符串中的元音字母-s-find-tolower-c-x3D-1\" class=\"headerlink\" title=\"345.反转字符串中的元音字母 s.find(tolower(c)) !&#x3D; -1\"></a>345.反转字符串中的元音字母 s.find(tolower(c)) !&#x3D; -1</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string s &#x3D; &quot;aeiou&quot;;\n    bool check(char c) &#123;\n        return s.find(tolower(c)) !&#x3D; -1;\n    &#125;\n\n    string reverseVowels(string s) &#123;\n        for(int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; i++, j--) &#123;\n            while(i &lt; j &amp;&amp; !check(s[i])) i++;\n            while(i &lt; j &amp;&amp; !check(s[j])) j--;\n            swap(s[i], s[j]);\n        &#125;\n        return s;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"346\"><a href=\"#346\" class=\"headerlink\" title=\"346.\"></a>346.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"347-前-K-个高频元素-计数排序\"><a href=\"#347-前-K-个高频元素-计数排序\" class=\"headerlink\" title=\"347.前 K 个高频元素 计数排序\"></a>347.前 K 个高频元素 计数排序</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210811214215046.png\" alt=\"image-20210811214215046\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;347.前K个高频元素\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int, int&gt; cnt;\n        for(auto x: nums) cnt[x]++;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; s(n + 1);\n        for(auto [x, c]: cnt) s[c] ++;&#x2F;&#x2F;cnt&#x3D;c的元素个数\n        int i &#x3D; n, t &#x3D; 0;\n        while(t &lt; k) t +&#x3D; s[i -- ];&#x2F;&#x2F;freq前k 定i\n        vector&lt;int&gt; res;\n        for(auto [x, c]: cnt)\n            if(c &gt; i)\n                res.push_back(x);\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"348\"><a href=\"#348\" class=\"headerlink\" title=\"348.\"></a>348.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"349-两个数组的交集-unordered-set-erase\"><a href=\"#349-两个数组的交集-unordered-set-erase\" class=\"headerlink\" title=\"349.两个数组的交集 unordered_set erase\"></a>349.两个数组的交集 unordered_set erase</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        unordered_set&lt;int&gt; S;&#x2F;&#x2F;去重\n        for(auto x: nums1) S.insert(x);\n        vector&lt;int&gt; res;\n        for(auto x: nums2) \n            if(S.count(x)) &#123;\n                res.push_back(x);\n                S.erase(x);&#x2F;&#x2F;永久消失！\n            &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"350-两个数组的交集II-unordered-multiset-S-erase-S-find-x\"><a href=\"#350-两个数组的交集II-unordered-multiset-S-erase-S-find-x\" class=\"headerlink\" title=\"350.两个数组的交集II unordered_multiset S.erase(S.find(x))\"></a>350.两个数组的交集II unordered_multiset S.erase(S.find(x))</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        unordered_multiset&lt;int&gt; S;&#x2F;&#x2F;不去重\n        for(auto x: nums1) S.insert(x);\n        vector&lt;int&gt; res;\n        for(auto x: nums2) \n            if(S.count(x)) &#123;\n                res.push_back(x);\n                S.erase(S.find(x));&#x2F;&#x2F;只删一个迭代器\n            &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"351\"><a href=\"#351\" class=\"headerlink\" title=\"351\"></a>351</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"352-将数据流变为多个不相交区间\"><a href=\"#352-将数据流变为多个不相交区间\" class=\"headerlink\" title=\"352.将数据流变为多个不相交区间\"></a>352.将数据流变为多个不相交区间</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812090635644.png\" alt=\"image-20210812090635644\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; addNum多: upper_bound&gt; lower_bound&gt;&#x3D;[返回迭代器！-&gt;！ 不存在则返回end] 排序的set+- O(logn) \n&#x2F;&#x2F; getIntervals少: O(n)遍历\ntypedef long long LL;\nconst LL INF &#x3D; 1e18;\ntypedef pair&lt;LL, LL&gt; PLL;\n\n#define x first\n#define y second\n\nclass SummaryRanges &#123;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    set&lt;PLL&gt; S;&#x2F;&#x2F;存区间&#123;x, y&#125;\n    \n    SummaryRanges() &#123;\n        S.insert(&#123;-INF, -INF&#125;), S.insert(&#123;INF, INF&#125;);&#x2F;&#x2F;哨兵\n    &#125;\n    \n    void addNum(int x) &#123;\n        auto r &#x3D; S.upper_bound(&#123;x, INT_MAX&#125;);&#x2F;&#x2F;L&gt;x_first &#123;x,INT_MIN&#125;&lt;&#123;x, x&#125;会错误的判断成功 判小一个！\n        auto l &#x3D; r;&#x2F;&#x2F;返回迭代器！\n        --l;\n        if(l-&gt;y &gt;&#x3D; x) return;\n        if(l-&gt;y &#x3D;&#x3D; x - 1 &amp;&amp; r-&gt;x &#x3D;&#x3D; x + 1) &#123;\n            S.insert(&#123;l-&gt;x, r-&gt;y&#125;);\n            S.erase(l), S.erase(r);\n        &#125; else if(l-&gt;y &#x3D;&#x3D; x - 1) &#123;\n            S.insert(&#123;l-&gt;x, x&#125;);\n            S.erase(l);\n        &#125; else if(r-&gt;x &#x3D;&#x3D; x + 1) &#123;\n            S.insert(&#123;x, r-&gt;y&#125;);\n            S.erase(r);\n        &#125; else &#123;\n            S.insert(&#123;x, x&#125;);\n        &#125;\n    &#125;\n    \n    vector&lt;vector&lt;int&gt;&gt; getIntervals() &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for(auto&amp; p: S)\n            if(p.x !&#x3D; -INF &amp;&amp; p.x !&#x3D; INF)\n                res.push_back(&#123;(int)p.x, (int)p.y&#125;);&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;373&#x2F;\n&#x2F;&#x2F; (平衡树) addNum: O(logn), getIntervals: O(n)\n&#x2F;&#x2F; 我们用 map&lt;int,int&gt; L, R 来动态维护所有区间，假设有个区间是[x, y]，则L[y] &#x3D; x并且R[x] &#x3D; y。\nclass SummaryRanges &#123;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    map&lt;int,int&gt;L, R;\n    SummaryRanges() &#123;\n\n    &#125;\n\n    void addNum(int val) &#123;\n        if (R.size())\n        &#123;\n            auto it &#x3D; R.upper_bound(val);\n            if (it !&#x3D; R.begin())\n            &#123;\n                -- it;\n                if (it-&gt;second &gt;&#x3D; val) return;\n            &#125;\n        &#125;\n        int right &#x3D; R.count(val + 1), left &#x3D; L.count(val - 1);&#x2F;&#x2F;\n        if (left &amp;&amp; right)\n        &#123;\n            R[L[val - 1]] &#x3D; R[val + 1];&#x2F;&#x2F;\n            L[R[val + 1]] &#x3D; L[val - 1];\n            R.erase(val + 1), L.erase(val - 1);\n        &#125;\n        else if (right)\n        &#123;\n            L[R[val + 1]] &#x3D; val;\n            R[val] &#x3D; R[val + 1];\n            R.erase(val + 1);\n        &#125;\n        else if (left)\n        &#123;\n            R[L[val - 1]] &#x3D; val;\n            L[val] &#x3D; L[val - 1];\n            L.erase(val - 1);\n        &#125;\n        else\n        &#123;\n            R[val] &#x3D; val;\n            L[val] &#x3D; val;\n        &#125;\n    &#125;\n    \n    vector&lt;vector&lt;int&gt;&gt; getIntervals() &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (auto &amp;p : R) res.push_back(&#123;(int)p.first, (int)p.second&#125;);\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"353\"><a href=\"#353\" class=\"headerlink\" title=\"353.\"></a>353.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"354-俄罗斯套娃信封问题-LIS-DP\"><a href=\"#354-俄罗斯套娃信封问题-LIS-DP\" class=\"headerlink\" title=\"354.俄罗斯套娃信封问题 LIS DP\"></a>354.俄罗斯套娃信封问题 LIS DP</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812102812131.png\" alt=\"image-20210812102812131\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; w) &#123;\n        int n &#x3D; w.size();\n        sort(w.begin(), w.end());&#x2F;&#x2F;\n        vector&lt;int&gt; f(n);\n        &#x2F;&#x2F;LIS DP\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            f[i] &#x3D; 1;&#x2F;&#x2F;\n            for(int j &#x3D; 0; j &lt; i; j++)\n                if(w[j][0] &lt; w[i][0] &amp;&amp; w[j][1] &lt; w[i][1])&#x2F;&#x2F;\n                    f[i] &#x3D; max(f[i], f[j] + 1);\n            res &#x3D; max(res, f[i]);\n        &#125;\n        return res;\n    &#125;  \n&#125;;</code></pre>\n\n\n\n<h1 id=\"—355-设计推特\"><a href=\"#—355-设计推特\" class=\"headerlink\" title=\"—355.设计推特\"></a>—355.设计推特</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812103658380.png\" alt=\"image-20210812103658380\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;355.设计推特\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;487669&#x2F;\n&#x2F;*\ntweets:map(userID, vec&#123;ts, tweetID&#125;)\nfollows:map(userID, set_[userID])\nheap:vec(ts, tweetID, ptr_idx, userID) &#x2F;&#x2F;ts大根堆\n*&#x2F;\ntypedef pair&lt;int, int&gt; PII;\n\n#define x first\n#define y second\n\nclass Twitter &#123;\npublic:\n\t&#x2F;** Initialize your data structure here. *&#x2F;\n\tunordered_map&lt;int, vector&lt;PII&gt;&gt; tweets;\n\tunordered_map&lt;int, unordered_set&lt;int&gt;&gt; follows;\n\tint ts;\n\n\tTwitter() &#123;\n\t\tts &#x3D; 0;\n\t&#125;\n\n\t&#x2F;** Compose a new tweet. *&#x2F;\n\tvoid postTweet(int userId, int tweetId) &#123;\n\t\ttweets[userId].push_back(&#123;ts++, tweetId&#125;);&#x2F;&#x2F;tweets:map(userID, vec&#123;ts, tweetID&#125;)\n\t&#125;\n\n\t&#x2F;** Retrieve the 10 most recent tweet ids in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. *&#x2F;\n\tvector&lt;int&gt; getNewsFeed(int u) &#123;\n\t\tpriority_queue&lt;vector&lt;int&gt;&gt; heap;\n\t\tfollows[u].insert(u);&#x2F;&#x2F;\n\t\tfor (auto user: follows[u]) &#123;\n\t\t\tauto &amp;ts &#x3D; tweets[user];&#x2F;&#x2F;\n\t\t\tif (ts.size()) &#123;\n\t\t\t\tint i &#x3D; ts.size() - 1;&#x2F;&#x2F;\n\t\t\t\theap.push(&#123;ts[i].x, ts[i].y, i, user&#125;);&#x2F;&#x2F;heap:vec(ts, tweetID, ptr_idx, userID)\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tvector&lt;int&gt; res;\n\t\tfor (int i &#x3D; 0; i &lt; 10 &amp;&amp; heap.size(); i ++ ) &#123;\n\t\t\tauto t &#x3D; heap.top();\n\t\t\theap.pop();\n\t\t\tres.push_back(t[1]);&#x2F;&#x2F;tID\n\t\t\tint j &#x3D; t[2];\n\t\t\tif (j) &#123;\n\t\t\t\tj -- ;&#x2F;&#x2F;idx\n\t\t\t\tint user &#x3D; t[3];\n\t\t\t\tauto&amp; ts &#x3D; tweets[user];\n\t\t\t\theap.push(&#123;ts[j].x, ts[j].y, j, user&#125;);&#x2F;&#x2F;keep 10\n\t\t\t&#125;\n\t\t&#125;\n\n\t\treturn res;\n\t&#125;\n\n\t&#x2F;** Follower follows a followee. If the operation is invalid, it should be a no-op. *&#x2F;\n\tvoid follow(int x, int y) &#123;\n\t\tfollows[x].insert(y);&#x2F;&#x2F;follows:map(userID, set_[userID])\n\t&#125;\n\n\t&#x2F;** Follower unfollows a followee. If the operation is invalid, it should be a no-op. *&#x2F;\n\tvoid unfollow(int x, int y) &#123;\n\t\tfollows[x].erase(y);\n\t&#125;\n&#125;;\n\n\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;394&#x2F;\nclass Twitter &#123;\npublic:\n\t&#x2F;** Initialize your data structure here. *&#x2F;\n\tunordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; posts;\n\tunordered_map&lt;int, unordered_set&lt;int&gt;&gt; follows;\n\tint id &#x3D; 0;\n\tTwitter() &#123;\n\t&#125;\n\n\t&#x2F;** Compose a new tweet. *&#x2F;\n\tvoid postTweet(int userId, int tweetId) &#123;\n\t\tposts[userId].push_back(make_pair(id ++, tweetId));\n\t&#125;\n\n\t&#x2F;** Retrieve the 10 most recent tweet ids in the user&#39;s news feed. \n\tEach item in the news feed must be posted by users who the user followed or by the user herself. \n\tTweets must be ordered from most recent to least recent. *&#x2F;\n\tvector&lt;int&gt; getNewsFeed(int userId) &#123;\n\t\tvector&lt;pair&lt;int,int&gt;&gt; ps;\n\t\tfor (auto x : posts[userId]) ps.push_back(x);&#x2F;&#x2F;too much data???\n\t\tfor (auto follow : follows[userId])\n\t\t\tfor (auto x : posts[follow])\n\t\t\t\tps.push_back(x);&#x2F;&#x2F;\n\t\tsort(ps.rbegin(), ps.rend());&#x2F;&#x2F;ts倒排\n\t\tvector&lt;int&gt; res;\n\t\tfor (int i &#x3D; 0; i &lt; 10 &amp;&amp; i &lt; ps.size(); i ++ )\n\t\t\tres.push_back(ps[i].second);&#x2F;&#x2F;postID\n\t\treturn res;\n\t&#125;\n\n\t&#x2F;** Follower follows a followee. If the operation is invalid, it should be a no-op. *&#x2F;\n\tvoid follow(int followerId, int followeeId) &#123;\n\t\tif (followerId !&#x3D; followeeId)\n\t\t\tfollows[followerId].insert(followeeId);\n\t&#125;\n\n\t&#x2F;** Follower unfollows a followee. If the operation is invalid, it should be a no-op. *&#x2F;\n\tvoid unfollow(int followerId, int followeeId) &#123;\n\t\tfollows[followerId].erase(followeeId);\n\t&#125;\n&#125;;\n\n\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;grandyang.com&#x2F;leetcode&#x2F;355&#x2F;\nclass Twitter &#123;\npublic:\n\tTwitter() &#123;\n\t\ttime &#x3D; 0;\n\t&#125;\n\n\tvoid postTweet(int userId, int tweetId) &#123;\n\t\tfollow(userId, userId);&#x2F;&#x2F;\n\t\ttweets[userId].insert(&#123;time++, tweetId&#125;);\n\t&#125;\n\n\tvector&lt;int&gt; getNewsFeed(int userId) &#123;\n\t\tvector&lt;int&gt; res;\n\t\tmap&lt;int, int&gt; top10;\n\t\tfor (auto id : friends[userId]) &#123;\n\t\t\tfor (auto a : tweets[id]) &#123;\n\t\t\t\ttop10.insert(&#123;a.first, a.second&#125;);\n\t\t\t\tif (top10.size() &gt; 10) top10.erase(top10.begin());&#x2F;&#x2F;!!!\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor (auto a : top10) &#123;\n\t\t\tres.insert(res.begin(), a.second);&#x2F;&#x2F;tID\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n\t\n&#x2F;*\n\tvector&lt;int&gt; getNewsFeed(int userId) &#123;\n\t\tvector&lt;int&gt; res;\n\t\tpriority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q; &#x2F;&#x2F; ts升序队列，小顶堆\n\t\tfor (auto id : friends[userId]) &#123;\n\t\t\tfor (auto a : tweets[id]) &#123;\n\t\t\t\tif (q.size() &gt; 0 &amp;&amp; q.top().first &gt; a.first &amp;&amp; q.size() &gt; 10) break; &#x2F;&#x2F; a_ts is older\n\t\t\t\tq.push(a);\n\t\t\t\tif (q.size() &gt; 10) q.pop();&#x2F;&#x2F;\n\t\t\t&#125;\n\t\t&#125;\n\t\twhile (!q.empty()) &#123;\n\t\t\tres.insert(res.begin(), q.top().second);\n\t\t\tq.pop();\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n*&#x2F;\n\t\n\tvoid follow(int followerId, int followeeId) &#123;\n\t\tfriends[followerId].insert(followeeId);\n\t&#125;\n\n\tvoid unfollow(int followerId, int followeeId) &#123;\n\t\tif (followerId !&#x3D; followeeId) &#123;\n\t\t\tfriends[followerId].erase(followeeId);\n\t\t&#125;\n\t&#125;\n\nprivate:\n\tint time;\n\tunordered_map&lt;int, unordered_set&lt;int&gt;&gt; friends;\n\tunordered_map&lt;int, map&lt;int, int&gt;&gt; tweets;\n&#125;;\n\n</code></pre>\n\n\n\n<h1 id=\"356\"><a href=\"#356\" class=\"headerlink\" title=\"356.\"></a>356.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"357-计算各个位数不同的数字个数-n-lt-x3D-10-9-9-8…\"><a href=\"#357-计算各个位数不同的数字个数-n-lt-x3D-10-9-9-8…\" class=\"headerlink\" title=\"357.计算各个位数不同的数字个数 n&lt;&#x3D;10 9*9*8…\"></a>357.计算各个位数不同的数字个数 n&lt;&#x3D;10 9*9*8…</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812105614746.png\" alt=\"image-20210812105614746\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int countNumbersWithUniqueDigits(int n) &#123;\n        n &#x3D; min(n, 10);&#x2F;&#x2F;n&gt;10无意义\n        if(!n) return 1;\n        vector&lt;int&gt; f(n + 1);&#x2F;&#x2F;满足要求的n位数个数\n        f[1] &#x3D; 9;\n        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)\n            f[i] &#x3D; f[i - 1] * (11 - i);&#x2F;&#x2F;f2&#x3D;f1*9 9*9*8*7...\n\n        int res &#x3D; 1;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) res +&#x3D; f[i];\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"358\"><a href=\"#358\" class=\"headerlink\" title=\"358.\"></a>358.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"359\"><a href=\"#359\" class=\"headerlink\" title=\"359.\"></a>359.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"360\"><a href=\"#360\" class=\"headerlink\" title=\"360.\"></a>360.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n\n\n<h1 id=\"361\"><a href=\"#361\" class=\"headerlink\" title=\"361.\"></a>361.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"362\"><a href=\"#362\" class=\"headerlink\" title=\"362.\"></a>362.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"363-矩形区域不超过-K-的最大数值和-n-gt-m\"><a href=\"#363-矩形区域不超过-K-的最大数值和-n-gt-m\" class=\"headerlink\" title=\"363.矩形区域不超过 K 的最大数值和 n&gt;m\"></a>363.矩形区域不超过 K 的最大数值和 n&gt;m</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812113928988.png\" alt=\"image-20210812113928988\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; s;\n\n    int get(int x1, int y1, int x2, int y2) &#123;&#x2F;&#x2F;2D子矩阵和\n        return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];\n    &#125;\n\n    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; w, int K) &#123;&#x2F;&#x2F;\n        int n &#x3D; w.size(), m &#x3D; w[0].size();\n        s &#x3D; vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(m + 1));\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )&#x2F;&#x2F;2D_S\n                s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1];\n\n        int res &#x3D; INT_MIN;\n        for (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n            for (int j &#x3D; i; j &lt;&#x3D; m; j ++ ) &#123;&#x2F;&#x2F;枚举左右边界\n                set&lt;int&gt; S;&#x2F;&#x2F;n长 纵向前缀和 O(m*m*nlogn)\n                S.insert(0);&#x2F;&#x2F;S0\n                for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ ) &#123;&#x2F;&#x2F;枚举下边界\n                    int si &#x3D; get(1, i, k, j);\n                    auto it &#x3D; S.lower_bound(si - K);&#x2F;&#x2F;&gt;&#x3D; min 二分找上边界\n                    if (it !&#x3D; S.end()) res &#x3D; max(res, si - *it);&#x2F;&#x2F;&lt;&#x3D;k的max子矩阵和 \n                    S.insert(si);\n                &#125;\n            &#125;\n\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"364\"><a href=\"#364\" class=\"headerlink\" title=\"364.\"></a>364.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"365-水壶问题-裴蜀定理-gcd-a-b-c\"><a href=\"#365-水壶问题-裴蜀定理-gcd-a-b-c\" class=\"headerlink\" title=\"365.水壶问题 裴蜀定理 gcd(a,b)|c\"></a>365.水壶问题 裴蜀定理 gcd(a,b)|c</h1><p>法一：(a,b)爆搜 看能否搜到c</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812123148621.png\" alt=\"image-20210812123148621\"></p>\n<p>两杯子不可能同时既不空也不满，故可看作一个整体，只有四种op：+a-a+b-b</p>\n<p>因为半满非最优解！</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812123822706.png\" alt=\"image-20210812123822706\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812171913336.png\" alt=\"image-20210812171913336\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;365.水壶问题 [直到装满或者倒空 一或两个来盛放:c&lt;&#x3D;a+b] (数学) gcd:O(logn)\n&#x2F;&#x2F; 水壶倒水的操作类似于辗转相减，所以能得到的最小粒度就是最大公约数 g。\n&#x2F;&#x2F; a，b和c分别除以g，此时满足a和b互质。很容易发现，【两个互质的数字可以凑出任意小于等于a+b的数字。】\n&#x2F;&#x2F; 裴蜀[贝祖Bezout]定理：对任意整数a,b,存在一对整数x,y,使ax+by&#x3D;c &lt;&#x3D;&gt; gcd(a,b)|c\n&#x2F;&#x2F; 扩展欧几里得算法，专门用来求解 ax+by&#x3D;gcd(a,b) 的整数解的 进而求乘法逆元\nclass Solution &#123;\npublic:\n    int gcd(int a, int b) &#123;&#x2F;&#x2F;辗转相除法\n        return b ? gcd(b, a % b) : a;\n    &#125;\n\n    bool canMeasureWater(int a, int b, int c) &#123;\n        if(c &gt; a + b) return false;&#x2F;&#x2F;不可能\n        return !c || c % gcd(a, b) &#x3D;&#x3D; 0;&#x2F;&#x2F;裴蜀定理\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;17&#x2F;\n&#x2F;&#x2F;扩展版：【今日头条2018暑期实习在线笔试题解】题目5 顺带求op次数\n&#x2F;&#x2F; 某个电容（无所谓哪一个）中的电量值等于c: c&lt;&#x3D;a || c&lt;&#x3D;b\n&#x2F;&#x2F; 一满一空\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\n&#x2F;&#x2F;模板一 只要递归求出x1, y1就能求出x, y。\nLL gcd(LL a, LL b, LL &amp;x, LL &amp;y)&#x2F;&#x2F;\n&#123;\n    if (b &#x3D;&#x3D; 0)\n    &#123;\n        x &#x3D; 1, y &#x3D; 0;\n        return a;\n    &#125;\n    &#x2F;&#x2F;x &#x3D; y1, y &#x3D; x1 - ⌊a &#x2F; b⌋ * y1\n    LL q &#x3D; gcd(b, a % b, y, x);&#x2F;&#x2F;x&#x3D;y1 y&#x3D;x1\n    y -&#x3D; a &#x2F; b * x;&#x2F;&#x2F;y -&#x3D; a &#x2F; b * [x&#x3D;y1]\n    return q;\n&#125;\n\nint main()\n&#123;\n    int T;\n    cin &gt;&gt; T;\n    while (T--)\n    &#123;\n        LL a, b, c, x, y;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        int d &#x3D; gcd(a, b, x, y);\n        if (c &gt; a &amp;&amp; c &gt; b || c % d)&#x2F;&#x2F;\n        &#123;\n            cout &lt;&lt; 0 &lt;&lt; endl;\n            continue;\n        &#125;\n        if (c &#x3D;&#x3D; a || c &#x3D;&#x3D; b)\n        &#123;\n            cout &lt;&lt; 1 &lt;&lt; endl;\n            continue;\n        &#125;\n        if (y &gt; 0) swap(x, y), swap(a, b);\n        LL a2 &#x3D; a &#x2F; d, b2 &#x3D; b &#x2F; d;\n        x *&#x3D; c &#x2F; d, y *&#x3D; c &#x2F; d;\n        LL k &#x3D; x &#x2F; b2;&#x2F;&#x2F;k???\n        x -&#x3D; k * b2, y +&#x3D; k * a2;\n        LL res;&#x2F;&#x2F;x&gt;y\n        if (c &gt; a) res &#x3D; 2 * (x - y);\n        else res &#x3D; 2 * (x - y - 1);\n        x -&#x3D; b2, y +&#x3D; a2;&#x2F;&#x2F;x&lt;y\n        if (c &gt; b) res &#x3D; min(res, 2 * (y - x));\n        else res &#x3D; min(res, 2 * (y - x - 1));\n        cout &lt;&lt; res &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;17&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;蓝书P154 另一模板 bx*(a%b)y&#x3D;&#x3D;a*y+b*(x-⌊a&#x2F;b⌋*y)\nLL gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123;&#x2F;&#x2F;&amp;\n    if (!b) &#123;\n        x &#x3D; 1, y &#x3D; 0;\n        return a;\n    &#125;\n    LL d &#x3D; gcd(b, a % b, x, y);\n    LL z &#x3D; x; x &#x3D; y; y &#x3D; z - a &#x2F; b * y;&#x2F;&#x2F;\n    return d;\n&#125;</code></pre>\n\n\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/114568325\">https://zhuanlan.zhihu.com/p/114568325</a></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812185507284.png\" alt=\"image-20210812185507284\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812185607261.png\" alt=\"image-20210812185607261\"></p>\n<p><a href=\"https://oi-wiki.org/math/number-theory/inverse/\">https://oi-wiki.org/math/number-theory/inverse/</a></p>\n<p>求乘法逆元&#x3D;&#x3D;exgcd</p>\n<h1 id=\"https-www-acwing-com-blog-content-17\"><a href=\"#https-www-acwing-com-blog-content-17\" class=\"headerlink\" title=\"https://www.acwing.com/blog/content/17/\"></a><a href=\"https://www.acwing.com/blog/content/17/\">https://www.acwing.com/blog/content/17/</a></h1><h1 id=\"366\"><a href=\"#366\" class=\"headerlink\" title=\"366.\"></a>366.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"367-有效的完全平方数-不能sqrt-二分-lt-x3D-sqrt-n-的max\"><a href=\"#367-有效的完全平方数-不能sqrt-二分-lt-x3D-sqrt-n-的max\" class=\"headerlink\" title=\"367.有效的完全平方数 不能sqrt 二分 &lt;&#x3D;sqrt(n)的max\"></a>367.有效的完全平方数 不能sqrt 二分 &lt;&#x3D;sqrt(n)的max</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812220403235.png\" alt=\"image-20210812220403235\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    typedef long long LL;\n    bool isPerfectSquare(int num) &#123;\n       int l &#x3D; 1 ,r &#x3D; num;\n       while (l &lt; r) &#123;\n           int mid &#x3D; l + 1ll + r &gt;&gt; 1;\n           if (mid &lt;&#x3D; num &#x2F; mid) l &#x3D; mid;&#x2F;&#x2F;&lt;&#x3D;sqrt(n)的max\n           else r &#x3D; mid - 1;\n       &#125; \n       return l * l &#x3D;&#x3D; num;\n\n    &#125;\n&#125;;\n\n\nclass Solution &#123;\npublic:\n    typedef long long LL;\n    bool isPerfectSquare(int num) &#123;\n       LL l &#x3D; 0 ,r &#x3D; num;\n       while (l &lt; r) &#123;\n           LL mid &#x3D; l + r + 1ll &gt;&gt; 1;\n           if (mid * mid &lt;&#x3D; num) l &#x3D; mid;\n           else r &#x3D; mid - 1;\n       &#125; \n       return l * l &#x3D;&#x3D; num;\n\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"368-最大整除子集-DP-类似LIS-if-nums-i-nums-j-x3D-x3D-0-f-i-x3D-max-f-i-f-j-1-反向递推出答案\"><a href=\"#368-最大整除子集-DP-类似LIS-if-nums-i-nums-j-x3D-x3D-0-f-i-x3D-max-f-i-f-j-1-反向递推出答案\" class=\"headerlink\" title=\"368.最大整除子集 DP 类似LIS if (nums[i] % nums[j] &#x3D;&#x3D; 0) f[i] &#x3D; max(f[i], f[j] + 1); 反向递推出答案\"></a>368.最大整除子集 DP 类似LIS if (nums[i] % nums[j] &#x3D;&#x3D; 0) f[i] &#x3D; max(f[i], f[j] + 1); 反向递推出答案</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210812222411562.png\" alt=\"image-20210812222411562\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;368.最大整除子集\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123;\n\t\tsort(nums.begin(), nums.end());\n\t\tint n &#x3D; nums.size();\n\t\tvector&lt;int&gt; f(n);\n\t\t\n\t\tint k &#x3D; 0;  &#x2F;&#x2F; 记录f最大时的下标，即f[k]最大\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tf[i] &#x3D; 1;\n\t\t\tfor (int j &#x3D; i - 1; j &gt;&#x3D; 0; j--)\n\t\t\t\tif (nums[i] % nums[j] &#x3D;&#x3D; 0)\n\t\t\t\t\tf[i] &#x3D; max(f[i], f[j] + 1);\n\t\t\tif (f[k] &lt; f[i]) k &#x3D; i;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 反向递推出答案\n\t\tvector&lt;int&gt; res;\n\t\twhile (true) &#123;\n\t\t\tres.push_back(nums[k]);\n\t\t\tif(f[k] &#x3D;&#x3D; 1) break;\n\t\t\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\t\t\tif (nums[k] % nums[i] &#x3D;&#x3D; 0 &amp;&amp; f[k] &#x3D;&#x3D; f[i] + 1) &#123;\n\t\t\t\t\tk &#x3D; i;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;*\n\t\tvector&lt;int&gt; res(1, nums[k]);\n\t\twhile (f[k] &gt; 1) &#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\t\t\tif (nums[k] % nums[i] &#x3D;&#x3D; 0 &amp;&amp; f[k] &#x3D;&#x3D; f[i] + 1) &#123;\n\t\t\t\t\tres.push_back(nums[i]);\n\t\t\t\t\tk &#x3D; i;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t&#125;\n\t\t*&#x2F;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"369\"><a href=\"#369\" class=\"headerlink\" title=\"369.\"></a>369.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"370\"><a href=\"#370\" class=\"headerlink\" title=\"370.\"></a>370.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"371-两整数之和-不用-不进位加法-进位-a-amp-b-lt-lt-1-unsigned-getSum-sum-carry\"><a href=\"#371-两整数之和-不用-不进位加法-进位-a-amp-b-lt-lt-1-unsigned-getSum-sum-carry\" class=\"headerlink\" title=\"371.两整数之和 不用+- ^:不进位加法 进位:(a&amp;b)&lt;&lt;1 (unsigned) getSum(sum, carry);\"></a>371.两整数之和 不用+- ^:不进位加法 进位:(a&amp;b)&lt;&lt;1 (unsigned) getSum(sum, carry);</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int getSum(int a, int b) &#123;\n        if(!b) return a;\n        int sum &#x3D; a ^ b, carry &#x3D; (unsigned)(a &amp; b) &lt;&lt; 1;&#x2F;&#x2F;unsigned溢出不报错\n        return getSum(sum, carry);&#x2F;&#x2F;转化param_ab int最多32次 carry&#x3D;0&amp;b&#x3D;0 ret a;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"372-超级次方-快速幂-b从低到高的二进制拆分-qmi-superPow-a-b-10-qmi-a-k-p\"><a href=\"#372-超级次方-快速幂-b从低到高的二进制拆分-qmi-superPow-a-b-10-qmi-a-k-p\" class=\"headerlink\" title=\"372. 超级次方 快速幂:b从低到高的二进制拆分 qmi(superPow(a, b), 10) * qmi(a, k) % p;\"></a>372. 超级次方 快速幂:b从低到高的二进制拆分 qmi(superPow(a, b), 10) * qmi(a, k) % p;</h1><p>qmi模板: $o(logk)$ 的时间求出$a^k%p$</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210813100934665.png\" alt=\"image-20210813100934665\"></p>\n<p>变换转化子问题 递归</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210813101401314.png\" alt=\"image-20210813101401314\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    const int p &#x3D; 1337;\n\n    int qmi(int a, int b) &#123;\n        a %&#x3D; p;\n        int res &#x3D; 1;\n        while (b) &#123;&#x2F;&#x2F;b的二进制拆分 低到高\n            if (b &amp; 1) res &#x3D; res * a % p;\n            a &#x3D; a * a % p;\n            b &gt;&gt;&#x3D; 1;\n        &#125;\n        return res;\n    &#125;\n\n    int superPow(int a, vector&lt;int&gt;&amp; b) &#123;&#x2F;&#x2F;b数组\n        if (b.empty()) return 1;\n        int k &#x3D; b.back();&#x2F;&#x2F;last_digit\n        b.pop_back();\n        return qmi(superPow(a, b), 10) * qmi(a, k) % p;&#x2F;&#x2F;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"373-查找和最小的K对数字-多路归并-类似丑数\"><a href=\"#373-查找和最小的K对数字-多路归并-类似丑数\" class=\"headerlink\" title=\"373.查找和最小的K对数字 多路归并 类似丑数\"></a>373.查找和最小的K对数字 多路归并 类似丑数</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210813122612051.png\" alt=\"image-20210813122612051\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">typedef vector&lt;int&gt; VI;\n\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b, int k) &#123;&#x2F;&#x2F;多路归并\n        if (a.empty() || b.empty()) return &#123;&#125;;\n        int n &#x3D; a.size(), m &#x3D; b.size();\n        priority_queue&lt;VI, vector&lt;VI&gt;, greater&lt;VI&gt;&gt; heap;&#x2F;&#x2F;小根堆\n        for (int i &#x3D; 0; i &lt; m; i ++ ) heap.push(&#123;b[i] + a[0], 0, i&#125;);&#x2F;&#x2F;第一列入堆\n        vector&lt;VI&gt; res;\n        while (k -- &amp;&amp; heap.size()) &#123;\n            auto t &#x3D; heap.top();\n            heap.pop();\n            res.push_back(&#123;a[t[1]], b[t[2]]&#125;);\n            if (t[1] + 1 &lt; n)\n                heap.push(&#123;a[t[1] + 1] + b[t[2]], t[1] + 1, t[2]&#125;);&#x2F;&#x2F;-&gt;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"374-猜数字大小-二分模板\"><a href=\"#374-猜数字大小-二分模板\" class=\"headerlink\" title=\"374.猜数字大小 二分模板\"></a>374.猜数字大小 二分模板</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;374.猜数字大小 二分模板\nclass Solution &#123;\npublic:\n    int guessNumber(int n) &#123;\n        int l &#x3D; 1, r &#x3D; n;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (long long)l + r &gt;&gt; 1;\n            if (guess(mid) &lt;&#x3D; 0) r &#x3D; mid;&#x2F;&#x2F;-1 0 1 &lt;&#x3D;num的max &#x3D;&#x3D;\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"！375-猜数字大小II-代价guess-至少需要拥有多少现金才能确保你能猜到-【区间DP】-min-lt-—f-i-j-所有可能的目标值在-i-j-及所有可能猜法-worst的min\"><a href=\"#！375-猜数字大小II-代价guess-至少需要拥有多少现金才能确保你能猜到-【区间DP】-min-lt-—f-i-j-所有可能的目标值在-i-j-及所有可能猜法-worst的min\" class=\"headerlink\" title=\"！375.猜数字大小II 代价guess 至少需要拥有多少现金才能确保你能猜到 【区间DP】 min&lt;—f[i,j]:所有可能的目标值在[i,j]及所有可能猜法 worst的min\"></a>！375.猜数字大小II 代价guess 至少需要拥有多少现金才能确保你能猜到 【区间DP】 min&lt;—f[i,j]:所有可能的目标值在[i,j]及所有可能猜法 worst的min</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814092732688.png\" alt=\"image-20210814092732688\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int getMoneyAmount(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2));&#x2F;&#x2F;0~n+1\n        for (int len &#x3D; 2; len &lt;&#x3D; n; len ++ )\n            for (int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i ++ ) &#123;\n                int j &#x3D; i + len - 1;\n                f[i][j] &#x3D; INT_MAX;\n                for (int k &#x3D; i; k &lt;&#x3D; j; k ++ )\n                    f[i][j] &#x3D; min(f[i][j], max(f[i][k - 1], f[k + 1][j]) + k);\n            &#125;\n        return f[1][n];\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;区间DP模板写法\nfor (int len &#x3D; 2; len &lt;&#x3D; n; len ++ )\n    for (int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i ++ ) &#123;\n        int j &#x3D; i + len - 1;\n        \n    &#125;</code></pre>\n\n\n\n<h1 id=\"【贪心-DP-O-n-极值点】376-摆动序列-最长子序列的长度-贪心O-n-只取极值点、DPO-n-dp-up-i-dp-down-i\"><a href=\"#【贪心-DP-O-n-极值点】376-摆动序列-最长子序列的长度-贪心O-n-只取极值点、DPO-n-dp-up-i-dp-down-i\" class=\"headerlink\" title=\"【贪心 DP O(n)极值点】376.摆动序列 最长子序列的长度 贪心O(n)只取极值点、DPO(n) dp_up[i] dp_down[i]\"></a>【贪心 DP O(n)极值点】376.摆动序列 最长子序列的长度 贪心O(n)只取极值点、DPO(n) dp_up[i] dp_down[i]</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;376.摆动序列 最长子序列的长度 贪心O(n)只取波峰波谷极值点\n&#x2F;&#x2F; 中间有多少波峰波谷就有多少局部极值 max! 端点必选！\nclass Solution &#123;\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\n        if (nums.size() &lt;&#x3D; 2) return nums.size();\n        int res &#x3D; 2;&#x2F;&#x2F;\n        for (int i &#x3D; 1; i + 1 &lt; nums.size(); i ++ ) &#123;\n            int a &#x3D; nums[i - 1], b &#x3D; nums[i], c &#x3D; nums[i + 1];\n            if (b &gt; a &amp;&amp; b &gt; c || b &lt; a &amp;&amp; b &lt; c) res ++ ;&#x2F;&#x2F;极值点\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;DP O(n) dp_up[i] dp_down[i]\nclass Solution &#123;\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n        if (nums.empty())   return 0;\n        int n &#x3D; nums.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (2, 1));\n\n        dp[0][1] &#x3D; dp[0][0] &#x3D; 1;\n        for (int i &#x3D; 1; i&lt;n; i++)&#123;\n            dp[i][0] &#x3D; dp[i-1][0];&#x2F;&#x2F;&#x3D;&#x3D;\n            dp[i][1] &#x3D; dp[i-1][1];&#x2F;&#x2F;\n            if (nums[i] &gt; nums[i-1])\n                dp[i][1] &#x3D; max(dp[i][1], dp[i-1][0] + 1);\n            else if (nums[i] &lt; nums[i-1])\n                dp[i][0] &#x3D; max(dp[i][0], dp[i-1][1] + 1);\n        &#125;\n        return max(dp[n-1][0], dp[n-1][1]);\n    &#125;\n&#125;;\n\n作者：T-SHLoRk\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;4912&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n</code></pre>\n\n\n\n<h1 id=\"377-组合总和Ⅳ-DP-i≥nums-j-f-i-x3D-f-i−nums-j\"><a href=\"#377-组合总和Ⅳ-DP-i≥nums-j-f-i-x3D-f-i−nums-j\" class=\"headerlink\" title=\"377.组合总和Ⅳ DP i≥nums[j]: f(i)+&#x3D;f(i−nums[j])\"></a>377.组合总和Ⅳ DP i≥nums[j]: f(i)+&#x3D;f(i−nums[j])</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814110205819.png\" alt=\"image-20210814110205819\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;377.组合总和Ⅳ\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;5005&#x2F;\n&#x2F;&#x2F; DP O(mn):状态数为 m 个，每次转移需要 n 次循环\n&#x2F;&#x2F; 枚举最后一个j 不重不漏 带顺序\n&#x2F;&#x2F; 设 f(i) 表示组成和为 i 的方案数。\n&#x2F;&#x2F; 初始时，f(0)&#x3D;1 其余为 0。\n&#x2F;&#x2F; 转移时，先枚举 i 然后枚举每个数字 nums[j]，如果 i≥nums[j]，令 f(i)+&#x3D;f(i−nums[j])。\n&#x2F;&#x2F; 最终答案为f(target)。\n\n&#x2F;&#x2F; 注意：\n&#x2F;&#x2F; bag:有限制的组合最优化问题 求M m 数量\n&#x2F;&#x2F; 此题和完全背包的区别，背包问题的状态表示是f(i,j)表示前i个物体，组成的重量为j，经过优化变成了一维。\n&#x2F;&#x2F; 【如果此题用完全背包解答，则会将顺序不同的序列算作相同的组合。】\n&#x2F;&#x2F; 此题在求解过程中整数会出现溢出，但由于答案在 32 位整数范围内，所以我们只需要在计算过程中模 INT_MAX 即可避免溢出）\n&#x2F;&#x2F; 进阶：\n&#x2F;&#x2F; 如果数组中存在负数，则有可能有无穷多个答案。\n&#x2F;&#x2F; 可以添加负数个数的限制。\nclass Solution &#123;\npublic:\n    int combinationSum4(vector&lt;int&gt;&amp; nums, int m) &#123;\n        vector&lt;unsigned&gt; f(m + 1);&#x2F;&#x2F;\n        f[0] &#x3D; 1;&#x2F;&#x2F;1种：空集\n        for(int i &#x3D; 1; i &lt;&#x3D; m; i++)\n            for(auto j: nums)\n                if(i &gt;&#x3D; j)\n                    f[i] +&#x3D; f[i - j];&#x2F;&#x2F;枚举最后一个j不重不漏 带顺序\n        return f[m];\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; dfs:可以按顺序从小到大枚举，如果无法满足 target 可以提前剪枝。但这样需要注意最后答案统计的是无序的情况，变为有序需要使用组合数学，对每种情况乘上各数字出现次数的阶乘\n\tint res;\n    vector&lt;int&gt; cur;      &#x2F;&#x2F; 当前组合\n    int curSum;             &#x2F;&#x2F; 当前组合的求和\n    map&lt;int, int&gt; dict;   &#x2F;&#x2F; 记忆化结构\n    void dfs(vector&lt;int&gt; nums, int tar) &#123;\n        if (curSum &#x3D;&#x3D; tar) &#123;\n            res ++;\n            return;\n        &#125;\n        if (curSum &gt; tar) &#123;\n            return;\n        &#125;\n        if (dict.find(tar - curSum) !&#x3D; dict.end()) &#123;\n            res +&#x3D; dict[tar - curSum] ;\n            return;\n        &#125;\n        int a &#x3D; res;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++) &#123;\n            cur.push_back(nums[i]);\n            curSum +&#x3D; nums[i];\n            dfs(nums, tar);\n            curSum -&#x3D; nums[i];\n            cur.pop_back();\n        &#125;\n        dict[tar - curSum] &#x3D; res - a;\n    &#125;\n\n&#x2F;&#x2F; 记忆化搜索就是DP: 思想是一样的，只是两种不同的实现方式。\n&#x2F;&#x2F; 在不确定转移顺序（保证转移没有环）的情况下，可以采用记忆化搜索\n&#x2F;&#x2F; 在确定转移顺序且需要注重效率的情况下，可以采用递推DP\n\n&#x2F;&#x2F; 这个题dp递推式与完全背包相同，但完全背包问题可以交换两层循环的顺序，这个题中两层循环的顺序却不能交换\n&#x2F;&#x2F; （交换后就是LC518的答案了）\n</code></pre>\n\n\n\n<h1 id=\"378-有序矩阵中第K小的元素-值域二分：向下向左-O-nlogL-L为值域-lt-x3D-mid的个数-gt-x3D-k-的min\"><a href=\"#378-有序矩阵中第K小的元素-值域二分：向下向左-O-nlogL-L为值域-lt-x3D-mid的个数-gt-x3D-k-的min\" class=\"headerlink\" title=\"378.有序矩阵中第K小的元素 值域二分：向下向左 O(nlogL) L为值域 &lt;&#x3D;mid的个数&gt;&#x3D;k 的min\"></a>378.有序矩阵中第K小的元素 值域二分：向下向左 O(nlogL) L为值域 &lt;&#x3D;mid的个数&gt;&#x3D;k 的min</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814112134797.png\" alt=\"image-20210814112134797\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814112007389.png\" alt=\"image-20210814112007389\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;378.有序矩阵中第K小的元素 &lt;&#x3D;mid的个数&gt;&#x3D;k 的min\n&#x2F;&#x2F;多路归并:维护一个K个元素的大顶堆，那么堆顶元素就是第K小的数 没有利用行有序和列有序的性质O(klogn)&lt;&#x3D;O(n*n*logK)\n&#x2F;&#x2F;二分搜索的题型分为两种，一种是索引二分(在有序数组中二分查找)，一种是值域二分（可行解在一个区间内查找，判断这个解是否成立）。这题就是经典的值域二分问题可以解的问题\n&#x2F;&#x2F;向下向左 O(nlogL) L为值域\nclass Solution &#123;\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;\n        int l&#x3D; INT_MIN, r &#x3D; INT_MAX;\n        while(l &lt; r) &#123;\n            int mid &#x3D; (long long) l + r &gt;&gt; 1;\n            int j &#x3D; matrix[0].size() - 1, cnt &#x3D; 0;&#x2F;&#x2F;&lt;&#x3D;mid的个数\n            for(int i &#x3D; 0; i &lt; matrix.size(); i++) &#123;&#x2F;&#x2F;O(n)\n                while(j &gt;&#x3D; 0 &amp;&amp; matrix[i][j] &gt; mid) j--;\n                cnt +&#x3D; j + 1;&#x2F;&#x2F;0~j\n            &#125;\n            if(cnt &gt;&#x3D; k) r &#x3D; mid;&#x2F;&#x2F;\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"379\"><a href=\"#379\" class=\"headerlink\" title=\"379.\"></a>379.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"380-常数时间插入、删除和获取随机元素-随机索引-数组-hash-val-x3D-idx-O-1-swap到最后-pop-back\"><a href=\"#380-常数时间插入、删除和获取随机元素-随机索引-数组-hash-val-x3D-idx-O-1-swap到最后-pop-back\" class=\"headerlink\" title=\"380.常数时间插入、删除和获取随机元素 随机索引:数组 hash[val]&#x3D;idx O(1)-:swap到最后 pop_back\"></a>380.常数时间插入、删除和获取随机元素 随机索引:数组 hash[val]&#x3D;idx O(1)-:swap到最后 pop_back</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814114707705.png\" alt=\"image-20210814114707705\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;380.常数时间插入、删除和获取随机元素\n&#x2F;&#x2F;O(1)+-hash表map&#123;val,idx&#125; 随机索引：数组 swap到最后 pop_back\nclass RandomizedSet &#123;\npublic:\n    unordered_map&lt;int, int&gt; hash;\n    vector&lt;int&gt; nums;\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    RandomizedSet() &#123;\n\n    &#125;\n    \n    &#x2F;** Inserts a value to the set. Returns true if the set did not already contain the specified element. *&#x2F;\n    bool insert(int x) &#123;\n        if(hash.count(x) &#x3D;&#x3D; 0) &#123;\n            nums.push_back(x);\n            hash[x] &#x3D; nums.size() - 1;&#x2F;&#x2F;\n            return true;\n        &#125;\n        return false;\n    &#125;\n    \n    &#x2F;** Removes a value from the set. Returns true if the set contained the specified element. *&#x2F;\n    bool remove(int x) &#123;\n        if(hash.count(x)) &#123;\n            int y &#x3D; nums.back();\n            int px &#x3D; hash[x], py &#x3D; hash[y];\n            swap(nums[px], nums[py]);\n            swap(hash[x], hash[y]);\n            nums.pop_back();\n            hash.erase(x);\n            return true;\n        &#125;\n        return false;\n    &#125;\n    \n    &#x2F;** Get a random element from the set. *&#x2F;\n    int getRandom() &#123;\n        return nums[rand() % nums.size()];&#x2F;&#x2F;rand()\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"381-O-1-时间插入、删除和获取随机元素-允许重复-嵌套map-set\"><a href=\"#381-O-1-时间插入、删除和获取随机元素-允许重复-嵌套map-set\" class=\"headerlink\" title=\"381.O(1) 时间插入、删除和获取随机元素 - 允许重复 嵌套map(set)\"></a>381.O(1) 时间插入、删除和获取随机元素 - 允许重复 嵌套map(set)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814121655571.png\" alt=\"image-20210814121655571\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class RandomizedCollection &#123;\npublic:\n    unordered_map&lt;int, unordered_set&lt;int&gt;&gt; hash;\n    vector&lt;int&gt; nums;\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    RandomizedCollection() &#123;\n\n    &#125;\n\n    &#x2F;** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. *&#x2F;\n    bool insert(int x) &#123;\n        bool res &#x3D; hash[x].empty();\n        nums.push_back(x);\n        hash[x].insert(nums.size() - 1);\n        return res;\n    &#125;\n\n    &#x2F;** Removes a value from the collection. Returns true if the collection contained the specified element. *&#x2F;\n    bool remove(int x) &#123;\n        if (hash[x].size()) &#123;\n            int px &#x3D; *hash[x].begin(), py &#x3D; nums.size() - 1;\n            int y &#x3D; nums.back();\n            swap(nums[px], nums[py]);\n            hash[x].erase(px), hash[x].insert(py);\n            hash[y].erase(py), hash[y].insert(px);\n            nums.pop_back();\n            hash[x].erase(py);\n            return true;\n        &#125;\n        return false;\n    &#125;\n\n    &#x2F;** Get a random element from the collection. *&#x2F;\n    int getRandom() &#123;\n        return nums[rand() % nums.size()];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"382-链表随机节点-S-x3D-O-1-n大且未知-抽奖场景-蓄水池抽样algo\"><a href=\"#382-链表随机节点-S-x3D-O-1-n大且未知-抽奖场景-蓄水池抽样algo\" class=\"headerlink\" title=\"382.链表随机节点 S&#x3D;O(1) n大且未知 抽奖场景 蓄水池抽样algo!!!\"></a>382.链表随机节点 S&#x3D;O(1) n大且未知 抽奖场景 蓄水池抽样algo!!!</h1><p>调和数列</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814123940729.png\" alt=\"image-20210814123940729\"></p>\n<p>k最终被选上且没被换下来的概率&#x3D;1&#x2F;n</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;382.链表随机节点 S&#x3D;O(1) n大且未知 抽奖场景 蓄水池抽样algo\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;14526&#x2F;\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;7a9ea6ece2af\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;shilinnpu&#x2F;p&#x2F;7810662.html\nclass Solution &#123;\npublic:\n    ListNode* h;\n\n    &#x2F;** @param head The linked list&#39;s head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. *&#x2F;\n    Solution(ListNode* head) &#123;\n        h &#x3D; head;\n    &#125;\n    \n    &#x2F;** Returns a random node&#39;s value. *&#x2F;\n    int getRandom() &#123;\n        int c &#x3D; -1, n &#x3D; 0;\n        for(auto p &#x3D; h; p; p &#x3D; p-&gt;next) &#123;\n            n++;\n            if(rand() % n &#x3D;&#x3D; 0) c &#x3D; p-&gt;val;&#x2F;&#x2F; 1&#x2F;n\n        &#125;\n        return c;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"383-赎金信-char-cntA-lt-x3D-B-b-a–-爽题\"><a href=\"#383-赎金信-char-cntA-lt-x3D-B-b-a–-爽题\" class=\"headerlink\" title=\"383.赎金信 char_cntA&lt;&#x3D;B b++ a– 爽题\"></a>383.赎金信 char_cntA&lt;&#x3D;B b++ a– 爽题</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool canConstruct(string a, string b) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        for(auto c: b) hash[c]++;\n        for(auto c: a) &#123;\n            if(!hash[c]) return false;\n            else hash[c]--;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"384-打乱数组-1-x2F-n-乘法原理-swap-cur-之后-洗牌算法-382\"><a href=\"#384-打乱数组-1-x2F-n-乘法原理-swap-cur-之后-洗牌算法-382\" class=\"headerlink\" title=\"384.打乱数组 1&#x2F;n! 乘法原理 swap(cur,之后) 洗牌算法(382)\"></a>384.打乱数组 1&#x2F;n! 乘法原理 swap(cur,之后) 洗牌算法(382)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814154729865.png\" alt=\"image-20210814154729865\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; a;\n    \n    Solution(vector&lt;int&gt;&amp; nums) &#123;\n        a &#x3D; nums;\n    &#125;\n    \n    &#x2F;** Resets the array to its original configuration and return it. *&#x2F;\n    vector&lt;int&gt; reset() &#123;\n        return a;\n    &#125;\n    \n    &#x2F;** Returns a random shuffling of the array. *&#x2F;\n    vector&lt;int&gt; shuffle() &#123;\n        auto b &#x3D; a;\n        int n &#x3D; a.size();\n        for(int i &#x3D; 0; i &lt; n; i++)\n            swap(b[i], b[i + rand() % (n - i)]);&#x2F;&#x2F;\n        return b;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"385-迷你语法分析器-dfs-LC341的逆op-arr-gt-NestedInteger-num\"><a href=\"#385-迷你语法分析器-dfs-LC341的逆op-arr-gt-NestedInteger-num\" class=\"headerlink\" title=\"385.迷你语法分析器 dfs LC341的逆op:arr-&gt;NestedInteger [num,] ,\"></a>385.迷你语法分析器 dfs LC341的逆op:arr-&gt;NestedInteger [num,] ,</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814160456312.png\" alt=\"image-20210814160456312\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;385.迷你语法分析器 dfs LC341的逆op:arr-&gt;NestedInteger [num,] ,\nclass Solution &#123;\npublic:\n    NestedInteger deserialize(string s) &#123;\n        int u &#x3D; 0;\n        return dfs(s, u);\n    &#125;\n\n    NestedInteger dfs(string&amp; s, int&amp; u) &#123;\n        NestedInteger res;\n        if (s[u] &#x3D;&#x3D; &#39;[&#39;) &#123;\n            u ++ ;  &#x2F;&#x2F; 跳过左括号\n            while (s[u] !&#x3D; &#39;]&#39;) res.add(dfs(s, u));&#x2F;&#x2F;!!!\n            u ++ ;  &#x2F;&#x2F; 跳过右括号\n            if (u &lt; s.size() &amp;&amp; s[u] &#x3D;&#x3D; &#39;,&#39;) u ++ ;  &#x2F;&#x2F; 跳过逗号!!!\n        &#125; else &#123;\n            int k &#x3D; u;\n            while (k &lt; s.size() &amp;&amp; s[k] !&#x3D; &#39;,&#39; &amp;&amp; s[k] !&#x3D; &#39;]&#39;) k ++ ;\n            res.setInteger(stoi(s.substr(u, k - u)));\n            if (k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; &#39;,&#39;) k ++ ;  &#x2F;&#x2F; 跳过逗号\n            u &#x3D; k;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"386-字典序排数-1n的字典序-Trie-枚举首位-递归子树09\"><a href=\"#386-字典序排数-1n的字典序-Trie-枚举首位-递归子树09\" class=\"headerlink\" title=\"386.字典序排数 1n的字典序 Trie 枚举首位+递归子树09\"></a>386.字典序排数 1<del>n的字典序 Trie 枚举首位+递归子树0</del>9</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;386.字典序排数 1~n的字典序 Trie 枚举首位+递归子树0~9\n&#x2F;&#x2F; toStr sort O(logn*nlogn)\n&#x2F;&#x2F; Trie类似桶排序 O(nlogn)\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; res;\n\n    vector&lt;int&gt; lexicalOrder(int n) &#123;\n        for (int i &#x3D; 1 ; i &lt;&#x3D; 9 ; i ++) dfs(i, n);&#x2F;&#x2F;枚举首位\n        return res;\n    &#125;\n\n    void dfs(int now, int n) &#123;\n        if (now &gt; n) return;&#x2F;&#x2F;剪枝\n        res.push_back(now);\n        for (int i &#x3D; 0; i &lt;&#x3D; 9; i++)&#x2F;&#x2F;递归子树0~9\n            dfs(now * 10 + i, n);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"387-字符串中的第一个唯一字符-hash\"><a href=\"#387-字符串中的第一个唯一字符-hash\" class=\"headerlink\" title=\"387.字符串中的第一个唯一字符 hash\"></a>387.字符串中的第一个唯一字符 hash</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    int firstUniqChar(string s) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        for(auto c: s) hash[c]++;\n        for(int i &#x3D; 0; i&lt; s.size(); i++)\n            if(hash[s[i]] &#x3D;&#x3D; 1)\n                return i;\n        return -1;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"388-文件的最长绝对路径-str处理细节-stk维护最长路径每层串长\"><a href=\"#388-文件的最长绝对路径-str处理细节-stk维护最长路径每层串长\" class=\"headerlink\" title=\"388.文件的最长绝对路径 str处理细节 stk维护最长路径每层串长\"></a>388.文件的最长绝对路径 str处理细节 stk维护最长路径每层串长</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814170829479.png\" alt=\"image-20210814170829479\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;388.文件的最长绝对路径 str处理细节 stk维护最长路径每层串长\nclass Solution &#123;\npublic:\n    int lengthLongestPath(string input) &#123;\n        stack&lt;int&gt; stk;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0, sum &#x3D; 0; i &lt; input.size(); i ++ ) &#123;&#x2F;&#x2F;跳过&#39;\\n&#39;\n            int k &#x3D; 0;\n            while (i &lt; input.size() &amp;&amp; input[i] &#x3D;&#x3D; &#39;\\t&#39;) i ++ , k ++ ;&#x2F;&#x2F;层数\n            while (stk.size() &gt; k) sum -&#x3D; stk.top(), stk.pop();&#x2F;&#x2F;回溯了\n            int j &#x3D; i;\n            while (j &lt; input.size() &amp;&amp; input[j] !&#x3D; &#39;\\n&#39;) j ++ ;&#x2F;&#x2F;\n            int len &#x3D; j - i;\n            stk.push(len), sum +&#x3D; len;\n            if (input.substr(i, len).find(&#39;.&#39;) !&#x3D; -1)\n                res &#x3D; max(res, sum + (int)stk.size() - 1);&#x2F;&#x2F;补stk.size()-1个&#39;&#x2F;&#39;\n            i &#x3D; j;&#x2F;&#x2F;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"389-找不同-打乱找多一个-【better】全-找2中的1-S-x3D-O-1-或者cnt-–余下的那个-a-b-cnt\"><a href=\"#389-找不同-打乱找多一个-【better】全-找2中的1-S-x3D-O-1-或者cnt-–余下的那个-a-b-cnt\" class=\"headerlink\" title=\"389.找不同 打乱找多一个:【better】全^ 找2中的1 S&#x3D;O(1)  或者cnt++–余下的那个 [a,b]:cnt\"></a>389.找不同 打乱找多一个:【better】全^ 找2中的1 S&#x3D;O(1)  或者cnt++–余下的那个 [a,b]:cnt</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;389.找不同 打乱找多一个：【better】全^ 找2中的1 S&#x3D;O(1)  或者cnt++--余下的那个 [a,b]:cnt\nclass Solution &#123;\npublic:\n    char findTheDifference(string s, string t) &#123;\n        int x &#x3D; 0;\n        for(auto c: s) x ^&#x3D; c;\n        for(auto c: t) x ^&#x3D; c;\n        return x;&#x2F;&#x2F;找2中的1\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;cnt++--余下的那个 [a,b]:cnt\nclass Solution &#123;\npublic:\n    char findTheDifference(string s, string t) &#123;\n        unordered_map&lt;char, int&gt; cnt;\n        for(auto c: t) cnt[c]++;\n        for(auto c: s) cnt[c]--;\n        for(auto [a, b]: cnt)\n            if(b) return a;\n        return -1;\n    &#125;\n&#125;;\n\n</code></pre>\n\n\n\n<h1 id=\"390-消除游戏-S型约瑟夫-f-n-x3D-2-g-n-x2F-2-g-n-x3D-n-1-f-n\"><a href=\"#390-消除游戏-S型约瑟夫-f-n-x3D-2-g-n-x2F-2-g-n-x3D-n-1-f-n\" class=\"headerlink\" title=\"390.消除游戏 S型约瑟夫 f[n]&#x3D;2*g[n&#x2F;2] g[n]&#x3D;n+1-f[n]\"></a>390.消除游戏 S型约瑟夫 f[n]&#x3D;2*g[n&#x2F;2] g[n]&#x3D;n+1-f[n]</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814180236889.png\" alt=\"image-20210814180236889\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814180612297.png\" alt=\"image-20210814180612297\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;390.消除游戏 S型约瑟夫 DP Acwing1455.招聘\n&#x2F;&#x2F; 假设初始数组是[1,2,3,4,5,6]，最终剩下来的数字是f(6)，经过第一轮从左到右遍历后剩下来的是[2,4,6]，恰好是2 * [1,2,3]，\n&#x2F;&#x2F; 这时我们从[1,2,3]右侧开始遍历，最终剩下来的是b(3)，我们可以发现f(6)&#x3D;2∗b(3)。如果初始数组长度为奇数也可以得到一样的结果。【转化！】\nclass Solution &#123;\npublic:\n    int lastRemaining(int n) &#123;&#x2F;&#x2F;计算方法中向更小的n推迭代式 不动点定理~\n        return n &#x3D;&#x3D; 1 ? 1 : 2 * (n &#x2F; 2 + 1 - lastRemaining(n &#x2F; 2));\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"391-完美矩形-1次4个-3次0个-总面积-x3D-x3D-没意义\"><a href=\"#391-完美矩形-1次4个-3次0个-总面积-x3D-x3D-没意义\" class=\"headerlink\" title=\"391.完美矩形 1次4个 3次0个 总面积&#x3D;&#x3D; 没意义\"></a>391.完美矩形 1次4个 3次0个 总面积&#x3D;&#x3D; 没意义</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814183943838.png\" alt=\"image-20210814183943838\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;391.完美矩形\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;731117&#x2F;\nclass Solution &#123;\npublic:\n    bool isRectangleCover(vector&lt;vector&lt;int&gt;&gt;&amp; r) &#123;\n        map&lt;pair&lt;int, int&gt;, int&gt; cnt;\n        typedef long long LL;\n        LL sum &#x3D; 0;\n        for (auto x: r) &#123;\n            LL a &#x3D; x[0], b &#x3D; x[1], c &#x3D; x[2], d &#x3D; x[3];\n            ++ cnt[&#123;a, b&#125;], ++ cnt[&#123;a, d&#125;];\n            ++ cnt[&#123;c, b&#125;], ++ cnt[&#123;c, d&#125;];\n            sum +&#x3D; (c - a) * (d - b);\n        &#125;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (auto&amp; [x, y]: cnt)\n            if (y &#x3D;&#x3D; 1) res.push_back(&#123;x.first, x.second&#125;);\n            else if (y &#x3D;&#x3D; 3) return false;\n            else if (y &gt; 4) return false;\n        if (res.size() !&#x3D; 4) return false;\n        sort(res.begin(), res.end());\n        return sum &#x3D;&#x3D; (LL)(res[3][0] - res[0][0]) * (res[3][1] - res[0][1]);\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"392-判断子序列-双指针\"><a href=\"#392-判断子序列-双指针\" class=\"headerlink\" title=\"392.判断子序列 双指针\"></a>392.判断子序列 双指针</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;392.判断子序列 双指针\nclass Solution &#123;\npublic:\n    bool isSubsequence(string s, string t) &#123;\n        int k &#x3D; 0;\n        for(auto c: t)\n            if(k &lt; s.size() &amp;&amp; c &#x3D;&#x3D; s[k])\n                k++;\n        return k &#x3D;&#x3D; s.size();\n    &#125;\n&#125;;\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;1772&#x2F;</code></pre>\n\n\n\n<h1 id=\"393-UTF-8编码验证-str\"><a href=\"#393-UTF-8编码验证-str\" class=\"headerlink\" title=\"393.UTF-8编码验证 str\"></a>393.UTF-8编码验证 str</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;393.UTF-8编码验证\nclass Solution &#123;\npublic:\n    int get(int x, int k) &#123;\n        return x &gt;&gt; k &amp; 1;\n    &#125;\n\n    bool validUtf8(vector&lt;int&gt;&amp; data) &#123;\n        for (int i &#x3D; 0; i &lt; data.size(); i ++ ) &#123;&#x2F;&#x2F;处理每一段\n            if (!get(data[i], 7)) continue;&#x2F;&#x2F;0xxxxxxx\n            int k &#x3D; 0;\n            while (k &lt;&#x3D; 4 &amp;&amp; get(data[i], 7 - k)) k ++ ;&#x2F;&#x2F;1110xxxx\n            if (k &#x3D;&#x3D; 1 || k &gt; 4) return false;&#x2F;&#x2F;k&#x3D;2 3 4个1\n            for (int j &#x3D; 1; j &lt;&#x3D; k - 1; j ++ ) &#123;\n                int t &#x3D; i + j;\n                if (t &gt;&#x3D; data.size()) return false;\n                if (!(get(data[t], 7) &amp;&amp; !get(data[t], 6))) return false;&#x2F;&#x2F;!10xxxxxx\n            &#125;\n            i +&#x3D; k - 1;&#x2F;&#x2F;\n        &#125;\n        return true;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"394-字符串解码-递归游程解码\"><a href=\"#394-字符串解码-递归游程解码\" class=\"headerlink\" title=\"394.字符串解码 递归游程解码\"></a>394.字符串解码 递归游程解码</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;394.字符串解码 递归游程解码\nclass Solution &#123;\npublic:\n    string decodeString(string s) &#123;\n        int u &#x3D; 0;\n        return dfs(s, u);\n    &#125;\n\n    string dfs(string&amp; s, int&amp; u) &#123;\n        string res;\n        while (u &lt; s.size() &amp;&amp; s[u] !&#x3D; &#39;]&#39;) &#123;\n            if (s[u] &gt;&#x3D; &#39;a&#39; &amp;&amp; s[u] &lt;&#x3D; &#39;z&#39; || s[u] &gt;&#x3D; &#39;A&#39; &amp;&amp; s[u] &lt;&#x3D; &#39;Z&#39;) res +&#x3D; s[u ++ ];&#x2F;&#x2F;u++\n            else if (s[u] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[u] &lt;&#x3D; &#39;9&#39;) &#123;\n                int k &#x3D; u;\n                while (s[k] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[k] &lt;&#x3D; &#39;9&#39;) k ++ ;\n                int x &#x3D; stoi(s.substr(u, k - u));&#x2F;&#x2F;x次\n                u &#x3D; k + 1;&#x2F;&#x2F;u跳过[\n                string y &#x3D; dfs(s, u);\n                u ++ ; &#x2F;&#x2F; u过滤掉右括号]\n                while (x -- ) res +&#x3D; y;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"395-至少有K个重复字符的最长子串-构造单调性-难！\"><a href=\"#395-至少有K个重复字符的最长子串-构造单调性-难！\" class=\"headerlink\" title=\"395.至少有K个重复字符的最长子串 构造单调性 难！\"></a>395.至少有K个重复字符的最长子串 构造单调性 难！</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814211137133.png\" alt=\"image-20210814211137133\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;构造单调性 难！\nclass Solution &#123;\npublic:\n    int K;\n    unordered_map&lt;char, int&gt; cnt;\n    &#x2F;&#x2F;[j,i]区间内 x:不同字符数 y:满足&gt;&#x3D;K要求的不同字符数 O(1)维护\n    void add(char c, int&amp; x, int&amp; y) &#123;\n        if (!cnt[c]) x ++ ;\n        cnt[c] ++ ;\n        if (cnt[c] &#x3D;&#x3D; K) y ++ ;\n    &#125;\n\n    void del(char c, int&amp; x, int&amp; y) &#123;\n        if (cnt[c] &#x3D;&#x3D; K) y -- ;\n        cnt[c] -- ;\n        if (!cnt[c]) x -- ;\n    &#125;\n\n    int longestSubstring(string s, int _K) &#123;\n        K &#x3D; _K;\n        int res &#x3D; 0;\n        for (int k &#x3D; 1; k &lt;&#x3D; 26; k ++ ) &#123;&#x2F;&#x2F;枚举区间中最多包含的不同字符数k x&lt;&#x3D;k O(26*n)\n            cnt.clear();&#x2F;&#x2F;\n            for (int i &#x3D; 0, j &#x3D; 0, x &#x3D; 0, y &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n                add(s[i], x, y);\n                while (x &gt; k) del(s[j ++ ], x, y);&#x2F;&#x2F;x&lt;&#x3D;k\n                if (x &#x3D;&#x3D; y) res &#x3D; max(res, i - j + 1);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"396-旋转函数-错位相减-找规律-O-n-O-1-s\"><a href=\"#396-旋转函数-错位相减-找规律-O-n-O-1-s\" class=\"headerlink\" title=\"396.旋转函数 错位相减 找规律 O(n)+O(1)s\"></a>396.旋转函数 错位相减 找规律 O(n)+O(1)s</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814214751748.png\" alt=\"image-20210814214751748\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814214010374.png\" alt=\"image-20210814214010374\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxRotateFunction(vector&lt;int&gt;&amp; A) &#123;\n        typedef long long LL;\n        LL sum &#x3D; 0, cur &#x3D; 0;\n        for (auto c: A) sum +&#x3D; c;\n        int n &#x3D; A.size();\n        for (int i &#x3D; 0; i &lt; n; i ++ ) cur +&#x3D; i * A[i];\n        LL res &#x3D; cur;\n        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- ) &#123;\n            cur +&#x3D; sum - (LL)n * A[i];\n            res &#x3D; max(res, cur);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"397-整数替换-直接模拟-记忆化搜索-无效状态多-LL-O-sqrt-n\"><a href=\"#397-整数替换-直接模拟-记忆化搜索-无效状态多-LL-O-sqrt-n\" class=\"headerlink\" title=\"397.整数替换 直接模拟+记忆化搜索(无效状态多) LL O(sqrt(n))\"></a>397.整数替换 直接模拟+记忆化搜索(无效状态多) LL O(sqrt(n))</h1><p>分支多，但搜到的不同数字种数少 为保证不重复搜索，加入备忘录memo dp： O(sqrt(n))</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210814220958680.png\" alt=\"image-20210814220958680\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 类似LC周赛：吃橘子 实际没那么大！\n&#x2F;&#x2F;397.整数替换 直接模拟+记忆化搜索 LL O(sqrt(n))\n&#x2F;&#x2F; 分支多，但搜到的不同数字种数少 为保证不重复搜索，加入备忘录memo dp： O(sqrt(n))\ntypedef long long LL;\n\nclass Solution &#123;\npublic:\n    unordered_map&lt;LL, int&gt; dp;&#x2F;&#x2F;记忆化搜索\n\n    int integerReplacement(int n) &#123;\n        return f(n);\n    &#125;\n\n    int f(LL n) &#123;\n        if (dp.count(n)) return dp[n];&#x2F;&#x2F;\n        if (n &#x3D;&#x3D; 1) return 0;\n        if (n % 2 &#x3D;&#x3D; 0) return dp[n] &#x3D; f(n &#x2F; 2) + 1;\n        return dp[n] &#x3D; min(f(n + 1), f(n - 1)) + 1;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"398-随机数索引-map-lt-int-vector-gt\"><a href=\"#398-随机数索引-map-lt-int-vector-gt\" class=\"headerlink\" title=\"398.随机数索引 map&lt;int,vector&gt;\"></a>398.随机数索引 map&lt;int,vector&gt;</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    unordered_map&lt;int, vector&lt;int&gt;&gt; hash;\n\n    Solution(vector&lt;int&gt;&amp; nums) &#123;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)\n            hash[nums[i]].push_back(i);\n    &#125;\n    \n    int pick(int target) &#123;\n        return hash[target][rand() % hash[target].size()];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"399-除法求值-多源最短路Floyd-ij-x3D-ik-kj-路径唯一不求min\"><a href=\"#399-除法求值-多源最短路Floyd-ij-x3D-ik-kj-路径唯一不求min\" class=\"headerlink\" title=\"399.除法求值 多源最短路Floyd ij&#x3D;ik*kj 路径唯一不求min\"></a>399.除法求值 多源最短路Floyd ij&#x3D;ik*kj 路径唯一不求min</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;蓝书P358 多源最短路 Floyd min(不经过k，经过k) DP\nclass Solution &#123;\npublic:\n    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123;\n        unordered_set&lt;string&gt; vers;\n        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; d;\n        for(int i &#x3D; 0; i &lt; equations.size(); i++) &#123;\n            auto a &#x3D; equations[i][0], b &#x3D; equations[i][1];\n            auto c &#x3D; values[i];\n            d[a][b] &#x3D; c, d[b][a] &#x3D; 1 &#x2F; c;\n            vers.insert(a), vers.insert(b);\n        &#125;\n\n        for(auto k: vers)\n            for(auto i: vers)\n                for(auto j: vers)\n                    if(d[i][k] &amp;&amp; d[k][j])\n                        d[i][j] &#x3D; d[i][k] * d[k][j];\n        \n        vector&lt;double&gt; res;\n        for(auto q: queries) &#123;\n            auto a &#x3D; q[0], b &#x3D; q[1];\n            if(d[a][b]) res.push_back(d[a][b]);\n            else res.push_back(-1);\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;3989&#x2F;</code></pre>\n\n\n\n<h1 id=\"400-第N位数字-1-串中nth-ceil-n-x2F-k-x3D-floor-n-k-1-x2F-k\"><a href=\"#400-第N位数字-1-串中nth-ceil-n-x2F-k-x3D-floor-n-k-1-x2F-k\" class=\"headerlink\" title=\"400.第N位数字 1~串中nth ceil(n&#x2F;k)&#x3D;floor((n+k-1)&#x2F;k)\"></a>400.第N位数字 1~串中nth ceil(n&#x2F;k)&#x3D;floor((n+k-1)&#x2F;k)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210815103309210.png\" alt=\"image-20210815103309210\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int findNthDigit(int n) &#123;\n        long long k &#x3D; 1, t &#x3D; 9, s &#x3D; 1;&#x2F;&#x2F;k位数 cnt first\n        while (n &gt; k * t) &#123;\n            n -&#x3D; k * t;&#x2F;&#x2F;!\n            k ++, t *&#x3D; 10, s *&#x3D; 10;&#x2F;&#x2F;len：1*9 2*90 3*900\n        &#125;\n        s +&#x3D; (n + k - 1) &#x2F; k - 1;&#x2F;&#x2F;k位数的第几个数\n        n &#x3D; n % k ? n % k : k;&#x2F;&#x2F;该数中的第几位!\n        return to_string(s)[n - 1] - &#39;0&#39;;&#x2F;&#x2F;itos\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"401-二进制手表-n个亮的所有可能时间-bin-cnt-n个1-sprintf-str-“-d-02d”-a-b\"><a href=\"#401-二进制手表-n个亮的所有可能时间-bin-cnt-n个1-sprintf-str-“-d-02d”-a-b\" class=\"headerlink\" title=\"401.二进制手表 n个亮的所有可能时间 bin_cnt_n个1 sprintf(str, “%d:%02d”, a, b);\"></a>401.二进制手表 n个亮的所有可能时间 bin_cnt_n个1 sprintf(str, “%d:%02d”, a, b);</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;401.二进制手表 n个亮的所有可能时间 bin_cnt_n个1\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; readBinaryWatch(int num) &#123;\n        vector&lt;string&gt; res;\n        char str[10];\n        for(int i &#x3D; 0; i &lt; 1 &lt;&lt; 10; i++) &#123;&#x2F;&#x2F;2^10\n            int cnt &#x3D; 0;\n            for(int j &#x3D; 0; j &lt; 10; j++)\n                if(i &gt;&gt; j &amp; 1)\n                    cnt++;\n            if(cnt &#x3D;&#x3D; num) &#123;\n                int a &#x3D; i &gt;&gt; 6, b &#x3D; i &amp; 63;&#x2F;&#x2F;高4 低6\n                if(a &lt; 12 &amp;&amp; b &lt; 60) &#123;\n                    sprintf(str, &quot;%d:%02d&quot;, a, b);&#x2F;&#x2F;\n                    res.push_back(str);\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"402-移掉K位数字-余下min-0-去前导0-经典贪心O-n-x3D-不删-单调栈res-back-gt-x删pop\"><a href=\"#402-移掉K位数字-余下min-0-去前导0-经典贪心O-n-x3D-不删-单调栈res-back-gt-x删pop\" class=\"headerlink\" title=\"!!!402.移掉K位数字 余下min 0,去前导0 经典贪心O(n):&#x3D;不删 单调栈res.back()&gt;x删pop\"></a>!!!402.移掉K位数字 余下min 0,去前导0 经典贪心O(n):&#x3D;不删 单调栈res.back()&gt;x删pop</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210815111158953.png\" alt=\"image-20210815111158953\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;402.移掉K位数字 余下min 去前导0 贪心O(n) &#x3D;不删\n&#x2F;&#x2F;&#x3D;，不删：把选择机会留给后面 if(提前)删，之后不能选择不删，且后面删是递归往前不断地删! 不够K位去尾得min\n&#x2F;&#x2F; DP：不能确定不同集合哪种更优，故搜M m n。 贪心：总有局部最优（需证明全局最优）。\nstring removeKdigits(string num, int k) &#123;\n\tk &#x3D; min(k, (int)num.size());\n    string res;\n    for(auto x : num) &#123;&#x2F;&#x2F;单调栈\n        while(res.size() &gt; 0 &amp;&amp; res.back() &gt; x &amp;&amp; k &gt; 0) &#123;&#x2F;&#x2F;&gt;删\n            res.pop_back();\n            k --;\n        &#125;\n        res.push_back(x);\n    &#125;\n    while(k -- ) res.pop_back();&#x2F;&#x2F;去尾\n    int n &#x3D; res.size(),i &#x3D; 0;\n    while(i &lt; n &amp;&amp; res[i] &#x3D;&#x3D; &#39;0&#39;) \n        i ++;\n    return n - i &#x3D;&#x3D; 0 ? &quot;0&quot; : res.substr(i, n - i);&#x2F;&#x2F;特判0 去前导0\n&#125;\n</code></pre>\n\n\n\n<h1 id=\"403-青蛙过河O-n-n-记忆化搜索-seq-DP-dp-从x走y步-f-hash-stone-idx\"><a href=\"#403-青蛙过河O-n-n-记忆化搜索-seq-DP-dp-从x走y步-f-hash-stone-idx\" class=\"headerlink\" title=\"!!!403.青蛙过河O(n*n) 记忆化搜索 seq_DP dp(从x走y步) f hash(stone,idx)\"></a>!!!403.青蛙过河O(n*n) 记忆化搜索 seq_DP dp(从x走y步) f hash(stone,idx)</h1><p>&#x2F;&#x2F; <a href=\"https://www.acwing.com/activity/content/problem/content/2802/\">https://www.acwing.com/activity/content/problem/content/2802/</a></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;403.青蛙过河 [y-1,y+1]步-&gt;x-&gt;y步\n&#x2F;&#x2F;O(n*n) 记忆化搜索 seq_DP dp() f[][] hash(stone,idx)\n&#x2F;&#x2F; if状态定义很多但很少被用到(无效状态很多)，记忆化搜索(func_call)就很快：只搜用到的。状态都被用到了就直接循环。\n\nconst int N &#x3D; 2010;\n\nint f[N][N];\n\nclass Solution &#123;\npublic:\n    unordered_map&lt;int, int&gt; hash;\n    vector&lt;int&gt; stones;\n\n    int dp(int x, int y) &#123;&#x2F;&#x2F;从x走y步：1 0  dp是函数 f是2D数组\n        if (f[x][y] !&#x3D; -1) return f[x][y];&#x2F;&#x2F;记忆化\n        f[x][y] &#x3D; 0;\n        for (int l &#x3D; max(1, y - 1); l &lt;&#x3D; y + 1; l ++ ) &#123;&#x2F;&#x2F;枚举l步到x\n            int z &#x3D; stones[x] - l;\n            if (hash.count(z)) &#123;\n                int p &#x3D; hash[z];\n                if (dp(p, l)) &#123;\n                    f[x][y] &#x3D; 1;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return f[x][y];\n    &#125;\n\n    bool canCross(vector&lt;int&gt;&amp; _stones) &#123;\n        stones &#x3D; _stones;\n        int n &#x3D; stones.size();\n        for (int i &#x3D; 0; i &lt; n; i ++ ) hash[stones[i]] &#x3D; i;&#x2F;&#x2F;(stones, idx)\n        memset(f, -1, sizeof f);\n        f[0][1] &#x3D; 1;&#x2F;&#x2F;T\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            if (dp(n - 1, i)) return true;&#x2F;&#x2F; ||\n        return false;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;迭代版本 Java\nclass Solution &#123;\n    public boolean canCross(int[] stones) &#123;\n        int n &#x3D; stones.length;\n        &#x2F;&#x2F;f[i,j]表示 i 这个下标的石头跳 j 步是否合法；\n        &#x2F;&#x2F;由于第一次跳 1 步，第二次最多跳 2 步，那么第 n - 1最多跳 n - 1步\n        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;\n            if (stones[i + 1] - stones[i] &gt; i + 1) return false;\n        &#125;\n        boolean[][] f &#x3D; new boolean[n][n + 1];\n        f[0][1] &#x3D; true;\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            for (int j &#x3D; 0; j &lt; i; j++) &#123;\n                int k &#x3D; stones[i] - stones[j];\n                if (k &gt; i) continue;\n                f[i][k] &#x3D; f[j][k - 1] || f[j][k] || f[j][k + 1];\n                if (i &#x3D;&#x3D; n - 1 &amp;&amp; f[i][k]) return true;\n            &#125;\n        &#125;\n        return false;\n\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h1 id=\"404-左叶子之和-dfs\"><a href=\"#404-左叶子之和-dfs\" class=\"headerlink\" title=\"404.左叶子之和 dfs\"></a>404.左叶子之和 dfs</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int res &#x3D; 0;\n\n    int sumOfLeftLeaves(TreeNode* root) &#123;\n        dfs(root);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* root) &#123;\n        if(!root) return;\n        if(root-&gt;left)\n            if(!root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)\n                res +&#x3D; root-&gt;left-&gt;val;\n        dfs(root-&gt;left);\n        dfs(root-&gt;right);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"405-数字转换为十六进制数-有符号整数int-gt-gt-x3D-会报错-amp-0xf\"><a href=\"#405-数字转换为十六进制数-有符号整数int-gt-gt-x3D-会报错-amp-0xf\" class=\"headerlink\" title=\"405.数字转换为十六进制数 有符号整数int&gt;&gt;&#x3D;会报错 &amp;0xf\"></a>405.数字转换为十六进制数 有符号整数int&gt;&gt;&#x3D;会报错 &amp;0xf</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;405.数字转换为十六进制数\nclass Solution &#123;\npublic:\n    string toHex(unsigned int num) &#123;&#x2F;&#x2F;有符号整数int&gt;&gt;&#x3D;会报错\n        if(!num) return &quot;0&quot;;\n        string res, nums &#x3D; &quot;0123456789abcdef&quot;;\n        while(num) &#123;\n            res +&#x3D; nums[num &amp; 0xf];\n            num &gt;&gt;&#x3D; 4;\n        &#125;\n        reverse(res.begin(), res.end());\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"406-据身高重建队列-贪心-h-k-left-gt-x3D-h-cnt-二分-树状数组-O-n∗logn∗logn\"><a href=\"#406-据身高重建队列-贪心-h-k-left-gt-x3D-h-cnt-二分-树状数组-O-n∗logn∗logn\" class=\"headerlink\" title=\"!!!406.据身高重建队列 贪心 h,k:left&gt;&#x3D;h_cnt (二分+树状数组) O(n∗logn∗logn)\"></a>!!!406.据身高重建队列 贪心 h,k:left&gt;&#x3D;h_cnt (二分+树状数组) O(n∗logn∗logn)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210815151332990.png\" alt=\"image-20210815151332990\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;406.根据身高重建队列 贪心 h,k:left&gt;&#x3D;h_cnt\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;9970&#x2F; 分支少 法3也可！\n&#x2F;&#x2F; (二分+树状数组) O(n∗logn∗logn)\nclass Solution &#123;\npublic:\n    int n;\n    vector&lt;int&gt; tr;\n\n    int lowbit(int x) &#123;\n        return x &amp; -x;\n    &#125;\n\n    void add(int x, int v) &#123;\n        for (int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) tr[i] +&#x3D; v;\n    &#125;\n\n    int query(int x) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; x; i; i -&#x3D; lowbit(i)) res +&#x3D; tr[i];\n        return res;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;\n        n &#x3D; people.size();\n        tr.resize(n + 1);&#x2F;&#x2F;tr:1~\n\n        sort(people.begin(), people.end(), [](vector&lt;int&gt;a, vector&lt;int&gt;b) &#123;\n            if (a[0] !&#x3D; b[0]) return a[0] &lt; b[0];\n            return a[1] &gt; b[1];\n        &#125;);&#x2F;&#x2F;\n\n        vector&lt;vector&lt;int&gt;&gt; res(n);\n        for (auto p: people) &#123;\n            int h &#x3D; p[0], k &#x3D; p[1];\n            int l &#x3D; 1, r &#x3D; n;\n            while (l &lt; r) &#123;\n                int mid &#x3D; l + r &gt;&gt; 1;\n                if (mid - query(mid) &gt;&#x3D; k + 1) r &#x3D; mid;&#x2F;&#x2F;k+1个空位]\n                else l &#x3D; mid + 1;\n            &#125;\n            res[r - 1] &#x3D; p;&#x2F;&#x2F;res:0~\n            add(r, 1);&#x2F;&#x2F;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;2610&#x2F; 反过来sort O(n*n)\n&#x2F;&#x2F; 先按身高从大到小排序，身高一样则按照k排序：身高大或k小意味着限制条件少，应该被优先考虑。\n&#x2F;&#x2F; 依次插入元素：由上一点，先进入res的元素不会被后进入的元素影响，因此每一次插入只需要考虑自己。它应该插到res的第b位，从而实现0到b-1的数字都比它大。\nclass Solution &#123;\npublic:\n\n  vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;\n    auto cmp &#x3D; [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123;\n            return a[0] &gt; b[0] || (a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1]);\n        &#125;;\n    sort(people.begin(), people.end(), cmp);\n    vector&lt;vector&lt;int&gt;&gt; res;\n    for(auto p:people) res.insert(res.begin()+p[1],p);&#x2F;&#x2F;\n    return res;\n  &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"【】算法思路是目的，ds-is-步骤实现-x2F-优化tools，切忌本末倒置！\"><a href=\"#【】算法思路是目的，ds-is-步骤实现-x2F-优化tools，切忌本末倒置！\" class=\"headerlink\" title=\"【】算法思路是目的，ds is 步骤实现&#x2F;优化tools，切忌本末倒置！\"></a>【】算法思路是目的，ds is 步骤实现&#x2F;优化tools，切忌本末倒置！</h1><h1 id=\"【】思路到代码：清楚定义每个状态的含义、怎么求值、求的顺序、why按此顺序算是对的-环环相扣！\"><a href=\"#【】思路到代码：清楚定义每个状态的含义、怎么求值、求的顺序、why按此顺序算是对的-环环相扣！\" class=\"headerlink\" title=\"【】思路到代码：清楚定义每个状态的含义、怎么求值、求的顺序、why按此顺序算是对的 环环相扣！\"></a>【】思路到代码：清楚定义每个状态的含义、怎么求值、求的顺序、why按此顺序算是对的 环环相扣！</h1><h1 id=\"407-接雨水II-LC42的2D版-init边界f-x3D-h入小跟堆-cur最终f-x3D-max-cur真实h-t-min最终f-gt-x3D-决定了递增的搜索顺序\"><a href=\"#407-接雨水II-LC42的2D版-init边界f-x3D-h入小跟堆-cur最终f-x3D-max-cur真实h-t-min最终f-gt-x3D-决定了递增的搜索顺序\" class=\"headerlink\" title=\"!!!407.接雨水II LC42的2D版 init边界f&#x3D;h入小跟堆 cur最终f&#x3D;max(cur真实h,t_min最终f) &gt;&#x3D; 决定了递增的搜索顺序\"></a>!!!407.接雨水II LC42的2D版 init边界f&#x3D;h入小跟堆 cur最终f&#x3D;max(cur真实h,t_min最终f) &gt;&#x3D; 决定了递增的搜索顺序</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210815173023736.png\" alt=\"image-20210815173023736\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;407.接雨水II LC42的2D版\n&#x2F;&#x2F; 算法思路是目的，ds is 步骤实现&#x2F;优化tools，切忌本末倒置！\n&#x2F;&#x2F; 思路到代码：清楚定义每个状态的含义、怎么求值、求的顺序、why按此顺序算是对的 环环相扣！\n&#x2F;&#x2F; 堆：acw592.雨\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;737240&#x2F;\n&#x2F;&#x2F; 状态转移有环，非拓扑图：init边界f&#x3D;h入堆 从min开始搜...\n&#x2F;&#x2F; Dijkstra:第一次出堆是真实值 本题入堆时就是真实值了 证明思路类似\nclass Solution &#123;\npublic:\n    struct Cell &#123;\n        int h, x, y;\n        bool operator &lt; (const Cell&amp; t) const &#123;\n            return h &gt; t.h;&#x2F;&#x2F;小根堆\n        &#125;\n    &#125;;\n\n    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; h) &#123; \n        if (h.empty() || h[0].empty()) return 0;\n        int n &#x3D; h.size(), m &#x3D; h[0].size();\n        priority_queue&lt;Cell&gt; heap;&#x2F;&#x2F;\n        vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m));&#x2F;&#x2F;vis\n        &#x2F;&#x2F;边界入堆f&#x3D;h st\n        for (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n            st[i][0] &#x3D; st[i][m - 1] &#x3D; true;\n            heap.push(&#123;h[i][0], i, 0&#125;);\n            heap.push(&#123;h[i][m - 1], i, m - 1&#125;);\n        &#125;\n        for (int i &#x3D; 1; i + 1 &lt; m; i ++ ) &#123;\n            st[0][i] &#x3D; st[n - 1][i] &#x3D; true;\n            heap.push(&#123;h[0][i], 0, i&#125;);\n            heap.push(&#123;h[n - 1][i], n - 1, i&#125;);\n        &#125;\n\n        int res &#x3D; 0;\n        int dx[] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[] &#x3D; &#123;0, 1, 0, -1&#125;;\n        while (heap.size()) &#123;\n            auto t &#x3D; heap.top();&#x2F;&#x2F;接完水高度最小的一个\n            heap.pop();\n            res +&#x3D; t.h - h[t.x][t.y];&#x2F;&#x2F;t_min 最终-真实&#x3D;高度差\n\n            for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n                int x &#x3D; t.x + dx[i], y &#x3D; t.y + dy[i];\n                if (x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; !st[x][y]) &#123;&#x2F;&#x2F;!st\n                    heap.push(&#123;max(h[x][y], t.h), x, y&#125;);&#x2F;&#x2F;cur最终f&#x3D;max(cur真实h,t_min最终f) &gt;&#x3D; 决定了递增的搜索顺序\n                    st[x][y] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n</code></pre>\n\n\n\n<h1 id=\"408\"><a href=\"#408\" class=\"headerlink\" title=\"408.\"></a>408.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"409-最长回文串-能构造的-k-x2F-2-2\"><a href=\"#409-最长回文串-能构造的-k-x2F-2-2\" class=\"headerlink\" title=\"409.最长回文串 能构造的~ k&#x2F;2*2\"></a>409.最长回文串 能构造的~ k&#x2F;2*2</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;409.最长回文串 能构造的~ k&#x2F;2*2\nclass Solution &#123;\npublic:\n    int longestPalindrome(string s) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        for (auto c: s) hash[c] ++ ;\n        int res &#x3D; 0;\n        for (auto [a, k]: hash) res +&#x3D; k &#x2F; 2 * 2;&#x2F;&#x2F;\n        if (res &lt; s.size()) res ++ ;&#x2F;&#x2F;1个的 取一个放中间\n        return res;\n    &#125;\n&#125;;\n\n</code></pre>\n\n\n\n<h1 id=\"410-分割数组的最大值-最小化m段和的max-out-经典二分-lt-贪心-尽量放check-cnt-lt-x3D-m\"><a href=\"#410-分割数组的最大值-最小化m段和的max-out-经典二分-lt-贪心-尽量放check-cnt-lt-x3D-m\" class=\"headerlink\" title=\"!!!410.分割数组的最大值 最小化m段和的max_out 经典二分[&lt;-]+贪心[尽量放check:cnt&lt;&#x3D;m]\"></a>!!!410.分割数组的最大值 最小化m段和的max_out 经典二分[&lt;-]+贪心[尽量放check:cnt&lt;&#x3D;m]</h1><p>贪心解：每段&gt;&#x3D;mid能放则放</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210815183018636.png\" alt=\"image-20210815183018636\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;410.分割数组的最大值 最小化m段和的max_out 经典二分+贪心\n&#x2F;&#x2F; 证明贪心解正确的方法：贪心解&gt;&#x3D;(显然) 且 &lt;&#x3D;(调整法&lt;-转化)best解\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;最少分cnt段-&gt;贪心解：每段&gt;&#x3D;mid能放则放\n    bool check(vector&lt;int&gt;&amp; nums, int m, int mid) &#123;\n        int sum &#x3D; 0, cnt &#x3D; 0;&#x2F;&#x2F;该段和sum 段数cnt\n        for (auto x: nums) &#123;\n            if (x &gt; mid) return false;&#x2F;&#x2F;!!!\n            if (sum + x &gt; mid) &#123;&#x2F;&#x2F;入新段\n                cnt ++ ;\n                sum &#x3D; x;\n            &#125; else &#123;\n                sum +&#x3D; x;&#x2F;&#x2F;\n            &#125;\n        &#125;\n        if (sum) cnt ++ ;&#x2F;&#x2F;\n        return cnt &lt;&#x3D; m;&#x2F;&#x2F;就一定能再分割成m段\n    &#125;\n\n    int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123;\n        int l &#x3D; 0, r &#x3D; INT_MAX;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (long long)l + r &gt;&gt; 1;\n            if (check(nums, m, mid)) r &#x3D; mid;&#x2F;&#x2F;check&#x3D;&#x3D;T:每段都&lt;&#x3D;mid[max段长min化 &lt;-]时,(段数增加)最少能分成m段\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"411\"><a href=\"#411\" class=\"headerlink\" title=\"411.\"></a>411.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"412-Fizz-Buzz-小模拟\"><a href=\"#412-Fizz-Buzz-小模拟\" class=\"headerlink\" title=\"412.Fizz Buzz 小模拟\"></a>412.Fizz Buzz 小模拟</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;412.Fizz Buzz 小模拟\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; fizzBuzz(int n) &#123;\n        vector&lt;string&gt; res;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            if(i % 3 &#x3D;&#x3D; 0 &amp;&amp; i % 5 &#x3D;&#x3D; 0) res.push_back(&quot;FizzBuzz&quot;);\n            else if(i % 3 &#x3D;&#x3D; 0) res.push_back(&quot;Fizz&quot;);\n            else if(i % 5 &#x3D;&#x3D; 0) res.push_back(&quot;Buzz&quot;);\n            else res.push_back(to_string(i));\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"413-等差数列划分-lt-求差分-值相等的-L-1-R-len-gt-x3D-2的子区间数-k-k-1-x2F-2\"><a href=\"#413-等差数列划分-lt-求差分-值相等的-L-1-R-len-gt-x3D-2的子区间数-k-k-1-x2F-2\" class=\"headerlink\" title=\"413.等差数列划分 &lt;-求差分 值相等的[L+1~R]len&gt;&#x3D;2的子区间数 k*(k-1)&#x2F;2\"></a>413.等差数列划分 &lt;-求差分 值相等的[L+1~R]len&gt;&#x3D;2的子区间数 k*(k-1)&#x2F;2</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210816092433526.png\" alt=\"image-20210816092433526\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;413.等差数列划分 &lt;-求差分 值相等的[L+1~R]len&gt;&#x3D;2的子区间数 k*(k-1)&#x2F;2\nclass Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        for (int i &#x3D; A.size() - 1; i &gt; 0; i -- ) A[i] -&#x3D; A[i - 1];&#x2F;&#x2F;\n        int res &#x3D; 0;\n        for (int i &#x3D; 1; i &lt; A.size(); i ++ ) &#123;\n            int j &#x3D; i;\n            while (j &lt; A.size() &amp;&amp; A[j] &#x3D;&#x3D; A[i]) j ++ ;\n            int k &#x3D; j - i;\n            res +&#x3D; k * (k - 1) &#x2F; 2;&#x2F;&#x2F;k&#x3D;1 0个;k&#x3D;2(len&#x3D;3) 1个\n            i &#x3D; j - 1;&#x2F;&#x2F;i++\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"414-第三大的数-讲过-分类讨论-s-abc中不同的数\"><a href=\"#414-第三大的数-讲过-分类讨论-s-abc中不同的数\" class=\"headerlink\" title=\"414.第三大的数 讲过 分类讨论 s:abc中不同的数\"></a>414.第三大的数 讲过 分类讨论 s:abc中不同的数</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;414.第三大的数\nclass Solution &#123;\npublic:\n    int thirdMax(vector&lt;int&gt;&amp; nums) &#123;\n        long long INF &#x3D; 1e10, a &#x3D; -INF, b &#x3D; -INF, c &#x3D; -INF, s &#x3D; 0;\n        for (auto x: nums) &#123;\n            if (x &gt; a) s ++, c &#x3D; b, b &#x3D; a, a &#x3D; x;\n            else if (x &lt; a &amp;&amp; x &gt; b) s ++, c &#x3D; b, b &#x3D; x;\n            else if (x &lt; b &amp;&amp; x &gt; c) s ++, c &#x3D; x;\n        &#125;\n        if (s &lt; 3) return a;&#x2F;&#x2F;s:abc中不同的数\n        return c;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"415-字符串相加-高精度加法模板-i-lt-A-size-i-lt-B-size-t-进位\"><a href=\"#415-字符串相加-高精度加法模板-i-lt-A-size-i-lt-B-size-t-进位\" class=\"headerlink\" title=\"415.字符串相加 高精度加法模板 i&lt;A.size()||i&lt;B.size()||t 进位\"></a>415.字符串相加 高精度加法模板 i&lt;A.size()||i&lt;B.size()||t 进位</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;&#x2F;&#x2F;高精度加法模板\n        vector&lt;int&gt; C;\n        for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size() || i &lt; B.size() || t; i ++ ) &#123;\n            if (i &lt; A.size()) t +&#x3D; A[i];&#x2F;&#x2F;t:进位\n            if (i &lt; B.size()) t +&#x3D; B[i];\n            C.push_back(t % 10);\n            t &#x2F;&#x3D; 10;\n        &#125;\n        return C;\n    &#125;\n\n    string addStrings(string a, string b) &#123;\n        vector&lt;int&gt; A, B;\n        for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i -- ) A.push_back(a[i] - &#39;0&#39;);\n        for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i -- ) B.push_back(b[i] - &#39;0&#39;);\n        auto C &#x3D; add(A, B);\n        string c;\n        for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i -- ) c +&#x3D; to_string(C[i]);\n        return c;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"416-分割等和子集-01bag模板-逆序-f-j-x3D-f-j-x-x2F-x2F-bool\"><a href=\"#416-分割等和子集-01bag模板-逆序-f-j-x3D-f-j-x-x2F-x2F-bool\" class=\"headerlink\" title=\"416.分割等和子集 01bag模板 逆序 f[j] |&#x3D; f[j - x];&#x2F;&#x2F;bool\"></a>416.分割等和子集 01bag模板 逆序 f[j] |&#x3D; f[j - x];&#x2F;&#x2F;bool</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210816100604705.png\" alt=\"image-20210816100604705\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;416.分割等和子集 01bag模板 逆序\n&#x2F;&#x2F; 正常数组写法：dp[i][j]表示考虑前i个数字，是否存在子数组和为j。转移方程为\n&#x2F;&#x2F; dp[i][j] &#x3D; dp[i-1][j] | dp[i-1][j-nums[i]]（即不选第i个数字或者选第i个数字）\nclass Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size(), m &#x3D; 0;\n        for (auto x: nums) m +&#x3D; x;\n        if (m % 2) return false;\n        m &#x2F;&#x3D; 2;&#x2F;&#x2F;2分子集和\n        vector&lt;int&gt; f(m + 1);\n        f[0] &#x3D; 1;\n        for (auto x: nums)\n            for (int j &#x3D; m; j &gt;&#x3D; x; j -- )\n                f[j] |&#x3D; f[j - x];&#x2F;&#x2F;bool\n        return f[m];\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; bitset写法：代码的等价变形 O(nm&#x2F;64)\nclass Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        bitset&lt;10001&gt; f;&#x2F;&#x2F; sum&#x2F;2 &lt;&#x3D; 1w\n        f[0] &#x3D; 1;\n        int sum &#x3D; 0;\n        for (auto x: nums) &#123;\n            f |&#x3D; f &lt;&lt; x;\n            sum +&#x3D; x;\n        &#125;\n        if (sum % 2) return false;\n        return f[sum &#x2F; 2];\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;6416&#x2F;\n&#x2F;&#x2F; 在DP中由于每次都需要遍历1到target(target &#x3D; sum(nums) &#x2F; 2)，当数组元素很大的时候dp的速度就会很慢。\n&#x2F;&#x2F; 有些时候在dp数组里，大部分dp[i][j]都是0，dp数组很稀疏。\n\n&#x2F;&#x2F; dp[i][j]实际上是为了记录考虑前i个数字时，j是否能够通过子数组求和得到，\n&#x2F;&#x2F; 因此可以考虑用sum_set记录能够通过子数组求和得到的数字，每次扩充sum_set\n&#x2F;&#x2F; （即把原来sum_set里的每个元素都加上nums[i]，类似于dp里选取nums[i]这个元素的过程)，最后判断target是否在sum_set里即可。\n&#x2F;&#x2F;python3代码：\nclass Solution:\n    def canPartition(self, nums: List[int]) -&gt; bool:\n        s &#x3D; sum(nums) \n        if s % 2 !&#x3D; 0:\n            return False\n        target &#x3D; s &#x2F; 2\n        sum_set &#x3D; set([0]) # 初始的sum_set\n        for i in range(0, len(nums)):\n            to_add &#x3D; set() # 加上nums[i]，新增的子数组和\n            for ele in sum_set:\n                to_add.add(ele + nums[i])\n            sum_set |&#x3D; to_add # 扩充sum_set\n            if target in sum_set:\n                return True\n        return False\n\n        </code></pre>\n\n\n\n<h1 id=\"417-太平洋大西洋水流问题-floodfill-b-x2F-dfs-if-st-amp-t-return-1-2-x3D-3\"><a href=\"#417-太平洋大西洋水流问题-floodfill-b-x2F-dfs-if-st-amp-t-return-1-2-x3D-3\" class=\"headerlink\" title=\"417.太平洋大西洋水流问题 floodfill b&#x2F;dfs if(st&amp;t)return; 1|2&#x3D;3\"></a>417.太平洋大西洋水流问题 floodfill b&#x2F;dfs if(st&amp;t)return; 1|2&#x3D;3</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;太平洋大西洋水流问题 floodfill b&#x2F;dfs if(st[x][y]&amp;t)return;\nclass Solution &#123;\npublic:\n    int n, m;\n    vector&lt;vector&lt;int&gt;&gt; w;\n    vector&lt;vector&lt;int&gt;&gt; st;\n\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    void dfs(int x, int y, int t) &#123;\n        if (st[x][y] &amp; t) return; &#x2F;&#x2F;1&amp;1&#x3D;2&amp;2&#x3D;1返回visited 1&amp;2&#x3D;2&amp;1&#x3D;0继续|&#x3D;3 !!!\n        st[x][y] |&#x3D; t; &#x2F;&#x2F;01 10 11\n        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; w[a][b] &gt;&#x3D; w[x][y])&#x2F;&#x2F;&gt;&#x3D;\n                dfs(a, b, t);\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        w &#x3D; matrix;\n        if (w.empty() || w[0].empty()) return &#123;&#125;;\n        n &#x3D; w.size(), m &#x3D; w[0].size();\n        st &#x3D; vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m));\n\n        for (int i &#x3D; 0; i &lt; n; i ++ ) dfs(i, 0, 1); &#x2F;&#x2F;4边界从低到高搜 1 2 3\n        for (int i &#x3D; 0; i &lt; m; i ++ ) dfs(0, i, 1);\n        for (int i &#x3D; 0; i &lt; n; i ++ ) dfs(i, m - 1, 2);\n        for (int i &#x3D; 0; i &lt; m; i ++ ) dfs(n - 1, i, 2);\n\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            for (int j &#x3D; 0; j &lt; m; j ++ )\n                if (st[i][j] &#x3D;&#x3D; 3) &#x2F;&#x2F;\n                    res.push_back(&#123;i, j&#125;);\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"418\"><a href=\"#418\" class=\"headerlink\" title=\"418.\"></a>418.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"419-甲板上的战舰-不相邻长条数-cnt左上角\"><a href=\"#419-甲板上的战舰-不相邻长条数-cnt左上角\" class=\"headerlink\" title=\"419.甲板上的战舰 不相邻长条数 cnt左上角\"></a>419.甲板上的战舰 不相邻长条数 cnt左上角</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;419.甲板上的战舰 可扩展为：求连通块数 并查集\nclass Solution &#123;\npublic:\n    int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        int res &#x3D; 0;&#x2F;&#x2F;不相邻长条数 cnt左上角\n        for (int i &#x3D; 0; i &lt; board.size(); i ++ )\n            for (int j &#x3D; 0; j &lt; board[i].size(); j ++ ) &#123;\n                if (i &gt; 0 &amp;&amp; board[i - 1][j] &#x3D;&#x3D; &#39;X&#39;) continue;\n                if (j &gt; 0 &amp;&amp; board[i][j - 1] &#x3D;&#x3D; &#39;X&#39;) continue;\n                if (board[i][j] &#x3D;&#x3D; &#39;X&#39;) res ++ ;\n            &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"420-强密码检验器-str-to强min-step-改-分类讨论-dirty没意思-超繁琐…\"><a href=\"#420-强密码检验器-str-to强min-step-改-分类讨论-dirty没意思-超繁琐…\" class=\"headerlink\" title=\"420.强密码检验器 str to强min_step:+-改 分类讨论 dirty没意思 超繁琐…\"></a>420.强密码检验器 str to强min_step:+-改 分类讨论 dirty没意思 超繁琐…</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210816131337510.png\" alt=\"image-20210816131337510\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;420.强密码检验器 str to强min_step:+-改 分类讨论 dirty没意思\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;738243&#x2F;\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;25738&#x2F;\nclass Solution &#123;\npublic:\n    int strongPasswordChecker(string s) &#123;\n        int a &#x3D; 0, b &#x3D; 0, c &#x3D; 0, n &#x3D; s.size(), k &#x3D; 0;&#x2F;&#x2F;0 a A数 k种字符\n        for (auto x: s) &#123;\n            if (x &gt;&#x3D; &#39;0&#39; &amp;&amp; x &lt;&#x3D; &#39;9&#39;) a &#x3D; 1;\n            else if (x &gt;&#x3D; &#39;a&#39; &amp;&amp; x &lt;&#x3D; &#39;z&#39;) b &#x3D; 1;\n            else if (x &gt;&#x3D; &#39;A&#39; &amp;&amp; x &lt;&#x3D; &#39;Z&#39;) c &#x3D; 1;\n        &#125;\n        k &#x3D; a + b + c; &#x2F;&#x2F;包含3类字符中的k类\n        if (n &lt; 6) return max(6 - n, 3 - k);&#x2F;&#x2F;【1】+ 分类讨论总结...\n        else &#123;\n            int p &#x3D; 0, del &#x3D; n - 20, res &#x3D; del;&#x2F;&#x2F;del&#x3D;n-20 需要删到&lt;&#x3D;20\n            int d[3] &#x3D; &#123;0&#125;;\n            for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;&#x2F;&#x2F;[&#x3D;&#x3D;]段长s\n                int j &#x3D; i;\n                while (j &lt; s.size() &amp;&amp; s[j] &#x3D;&#x3D; s[i]) j ++ ;\n                int s &#x3D; j - i;\n                i &#x3D; j - 1;\n                p +&#x3D; s &#x2F; 3; &#x2F;&#x2F;修改S&#x2F;3次\n                if (s &gt;&#x3D; 3) d[s % 3] ++ ;\n            &#125;\n            if (n &lt;&#x3D; 20) return max(p, 3 - k);&#x2F;&#x2F;【2】改+同时 有重叠\n            if (d[0] &amp;&amp; del &gt; 0) &#123; &#x2F;&#x2F;3*x -1 转化到第三类:最赚\n                int t &#x3D; min(d[0], del);\n                del -&#x3D; t;&#x2F;&#x2F;-\n                p -&#x3D; t;&#x2F;&#x2F;改\n            &#125;\n            if (d[1] &amp;&amp; del &gt; 0) &#123; &#x2F;&#x2F;3*x+1 -2\n                int t &#x3D; min(d[1] * 2, del);\n                del -&#x3D; t;\n                p -&#x3D; t &#x2F; 2;\n            &#125;\n            if (p &amp;&amp; del &gt; 0) &#123;\n                int t &#x3D; min(p * 3, del);\n                p -&#x3D; t &#x2F; 3; &#x2F;&#x2F;第三类-3个,p-&#x3D;1\n            &#125;\n            return res + max(p, 3 - k);&#x2F;&#x2F;【3】- 边改边+同时做\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;25738&#x2F;\n&#x2F;&#x2F; 贪心 堆 O(nlogn)</code></pre>\n\n\n\n<h1 id=\"421-数组中两个数的最大异或值-Trie例题\"><a href=\"#421-数组中两个数的最大异或值-Trie例题\" class=\"headerlink\" title=\"421.数组中两个数的最大异或值 Trie例题\"></a>421.数组中两个数的最大异或值 Trie例题</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;421.数组中两个数的最大异或值\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; s;\n\n    void insert(int x) &#123;\n        int p &#x3D; 0;\n        for (int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;\n            int u &#x3D; x &gt;&gt; i &amp; 1;\n            if (!s[p][u]) s[p][u] &#x3D; s.size(), s.push_back(&#123;0, 0&#125;);&#x2F;&#x2F;++tot\n            p &#x3D; s[p][u];\n        &#125;\n    &#125;\n\n    int query(int x) &#123;\n        int p &#x3D; 0, res &#x3D; 0;\n        for (int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;\n            int u &#x3D; x &gt;&gt; i &amp; 1;\n            if (s[p][!u]) p &#x3D; s[p][!u], res |&#x3D; 1 &lt;&lt; i;&#x2F;&#x2F;不同：该位为1\n            else p &#x3D; s[p][u]; &#x2F;&#x2F;没!u再选u &#x3D;&#x3D; 0\n        &#125;\n        return res;&#x2F;&#x2F;就是^结果！\n    &#125;\n&#x2F;*\n    int query(int x) &#123;\n        int p &#x3D; 0, res &#x3D; 0;\n        for (int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;\n            int u &#x3D; x &gt;&gt; i &amp; 1;\n            if (s[p][!u]) p &#x3D; s[p][!u], res &#x3D; (res &lt;&lt; 1) + !u;\n            else p &#x3D; s[p][u], res &#x3D; (res &lt;&lt; 1) + u; &#x2F;&#x2F;没!u再选u\n        &#125;\n        return res ^ x;\n    &#125;\n*&#x2F;\n    \n    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;\n        s.push_back(&#123;0, 0&#125;);\n        int res &#x3D; 0;\n        for (auto x: nums) &#123;\n            res &#x3D; max(res, query(x));\n            insert(x);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;549&#x2F;\n&#x2F;*\n假设当前节点是 p，我们用一个long long变量来存储当前边的哈希值。\n哈希函数可以随意发挥，只要保证冲突的概率很小即可。这里我使用了一种[完全不会冲突的哈希函数：?????]\nlong long变量的低32位存储p点到根节点的路径所表示的二进制数，第32位存储当前边是0还是1, 从第33位开始，表示节点p的高度。\n例如，假设p点到根节点的前缀是(101)2&#x3D;5，当前边是1，p在Trie树中的高度是27，则当前边的哈希值是：\n5+1∗2^32+27∗2^33\n*&#x2F;\nclass Solution &#123;\npublic:\n    typedef long long LL;\n\n    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;LL&gt; edge;\n        int res &#x3D; 0;\n        for (auto &amp;x : nums)\n        &#123;\n            LL pre &#x3D; 0, pre_op &#x3D; 0;\n            int xorr &#x3D; 0;\n            for (int i &#x3D; 30; i &gt;&#x3D; 0; i--)\n            &#123;\n                int next &#x3D; x &gt;&gt; i &amp; 1;\n                edge.insert(pre + next * (1LL &lt;&lt; 32) + i * (1LL &lt;&lt; 33));\n                if (edge.count(pre_op + !next * (1LL &lt;&lt; 32) + i * (1LL &lt;&lt; 33)))\n                &#123;\n                    xorr &#x3D; xorr * 2 + 1;&#x2F;&#x2F;走1\n                    pre_op &#x3D; pre_op * 2 + !next;\n                &#125;\n                else\n                &#123;\n                    xorr &lt;&lt;&#x3D; 1;&#x2F;&#x2F;走0\n                    pre_op &#x3D; pre_op * 2 + next;\n                &#125;\n                pre &#x3D; pre * 2 + next;&#x2F;&#x2F;更新前缀\n            &#125;\n            res &#x3D; max(res, xorr);&#x2F;&#x2F;xorr\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"422\"><a href=\"#422\" class=\"headerlink\" title=\"422.\"></a>422.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"423-从英文中重建数字\"><a href=\"#423-从英文中重建数字\" class=\"headerlink\" title=\"423.从英文中重建数字\"></a>423.从英文中重建数字</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;423.从英文中重建数字\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;22477&#x2F;\nclass Solution &#123;\npublic:\n    string originalDigits(string s) &#123;\n        string name[] &#x3D; &#123;\n            &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;,\n            &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;\n        &#125;;\n        int ord[] &#x3D; &#123;0, 8, 3, 2, 6, 4, 5, 1, 7, 9&#125;;\n        unordered_map&lt;char, int&gt; cnt;\n        for (auto c: s) cnt[c] ++ ;\n        string res;\n        for (int x: ord) &#123;\n            while (true) &#123;&#x2F;&#x2F;处理多(未知)个相同 while true break;\n                bool flag &#x3D; true;\n                for (auto c: name[x])\n                    if (!cnt[c]) &#123;\n                        flag &#x3D; false;\n                        break;\n                    &#125;\n                if (flag) &#123;\n                    res +&#x3D; to_string(x);\n                    for (auto c: name[x]) cnt[c] -- ;&#x2F;&#x2F;zerozero 00\n                &#125;\n                else break;&#x2F;&#x2F;\n            &#125;\n        &#125;\n        sort(res.begin(), res.end());\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"424-替换后的最长重复字符\"><a href=\"#424-替换后的最长重复字符\" class=\"headerlink\" title=\"424.替换后的最长重复字符\"></a>424.替换后的最长重复字符</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;424.替换后的最长重复字符\nclass Solution &#123;\npublic:\n\tint characterReplacement(string s, int k) &#123;\n\t\tint res &#x3D; 0;\n\t\tfor (char c &#x3D; &#39;A&#39;; c &lt;&#x3D; &#39;Z&#39;; c ++ ) &#123;\n\t\t\tfor (int i &#x3D; 0, j &#x3D; 0, cnt &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n\t\t\t\tif (s[i] &#x3D;&#x3D; c) cnt ++ ;&#x2F;&#x2F;A~Z搜一遍O(26n)，而不选择[j,i]中MaxCnt字母(会变)的cnt(会变) 无法证明单调性，不严谨！\n\t\t\t\twhile (i - j + 1 - cnt &gt; k) &#123;&#x2F;&#x2F;可最多替换k次\n\t\t\t\t\tif (s[j] &#x3D;&#x3D; c) cnt -- ;\n\t\t\t\t\tj ++ ;\n\t\t\t\t&#125;\n\t\t\t\tres &#x3D; max(res, i - j + 1);\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"425\"><a href=\"#425\" class=\"headerlink\" title=\"425.\"></a>425.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"426\"><a href=\"#426\" class=\"headerlink\" title=\"426.\"></a>426.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n<h1 id=\"427-建立四叉树\"><a href=\"#427-建立四叉树\" class=\"headerlink\" title=\"427.建立四叉树\"></a>427.建立四叉树</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210817092349439.png\" alt=\"image-20210817092349439\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;427.建立四叉树\n&#x2F;&#x2F; Node(bool _val, bool _isLeaf)\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; s;\n    \n    Node* construct(vector&lt;vector&lt;int&gt;&gt;&amp; w) &#123;\n        int n &#x3D; w.size();\n        s &#x3D; vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(n + 1));\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n                s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1];\n        return dfs(1, 1, n, n);\n    &#125;\n\n    Node* dfs(int x1, int y1, int x2, int y2) &#123;\n        int n &#x3D; x2 - x1 + 1;\n        int sum &#x3D; s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1];&#x2F;&#x2F;2D子矩阵和\n        if (sum &#x3D;&#x3D; 0 || sum &#x3D;&#x3D; n * n) return new Node(!!sum, true);&#x2F;&#x2F;1 0\n        auto node &#x3D; new Node(0, false);&#x2F;&#x2F;内部节点val随意\n        int m &#x3D; n &#x2F; 2;&#x2F;&#x2F;4分\n        node-&gt;topLeft &#x3D; dfs(x1, y1, x1 + m - 1, y1 + m - 1);\n        node-&gt;topRight &#x3D; dfs(x1, y1 + m, x1 + m - 1, y2);\n        node-&gt;bottomLeft &#x3D; dfs(x1 + m, y1, x2, y1 + m - 1);\n        node-&gt;bottomRight &#x3D; dfs(x1 + m, y1 + m, x2, y2);\n        return node;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"428\"><a href=\"#428\" class=\"headerlink\" title=\"428.\"></a>428.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"429-N叉树的层序遍历-bfs\"><a href=\"#429-N叉树的层序遍历-bfs\" class=\"headerlink\" title=\"429.N叉树的层序遍历 bfs\"></a>429.N叉树的层序遍历 bfs</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;429.N叉树的层序遍历 bfs\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        if (!root) return res;\n        queue&lt;Node*&gt; q;\n        q.push(root);\n        while (q.size()) &#123;\n            int len &#x3D; q.size();&#x2F;&#x2F;\n            vector&lt;int&gt; line;\n            while (len -- ) &#123;\n                auto t &#x3D; q.front();\n                q.pop();\n                line.push_back(t-&gt;val);\n                for (auto c: t-&gt;children) q.push(c);&#x2F;&#x2F;\n            &#125;\n            res.push_back(line);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"430-扁平化多级双向链表-递归插入子节点\"><a href=\"#430-扁平化多级双向链表-递归插入子节点\" class=\"headerlink\" title=\"430.扁平化多级双向链表 递归插入子节点\"></a>430.扁平化多级双向链表 递归插入子节点</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210817101711318.png\" alt=\"image-20210817101711318\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;430.扁平化多级双向链表 递归插入子节点\n&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    Node* prev;\n    Node* next;\n    Node* child;\n&#125;;\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    Node* flatten(Node* head) &#123;\n        auto res &#x3D; dfs(head);&#x2F;&#x2F;&#123;head,tail&#125;\n        return res[0];\n    &#125;\n\n    vector&lt;Node*&gt; dfs(Node* head) &#123;\n        if(!head) return &#123;NULL, NULL&#125;;\n        auto cur &#x3D; head, tail &#x3D; head;\n        while(cur) &#123;\n            tail &#x3D; cur;&#x2F;&#x2F;last非空\n            if(cur-&gt;child) &#123;\n                auto t &#x3D; dfs(cur-&gt;child);\n                cur-&gt;child &#x3D; NULL;&#x2F;&#x2F;!\n                t[1]-&gt;next &#x3D; cur-&gt;next;&#x2F;&#x2F;NULL\n                if(cur-&gt;next) cur-&gt;next-&gt;prev &#x3D; t[1];\n                cur-&gt;next &#x3D; t[0];\n                t[0]-&gt;prev &#x3D; cur;\n                cur &#x3D; t[1]-&gt;next;\n                tail &#x3D; t[1];&#x2F;&#x2F;last非空：cur-&gt;next &#x3D;&#x3D; NULL\n            &#125; else &#123;\n                cur &#x3D; cur-&gt;next;\n            &#125;\n        &#125;\n        return &#123;head, tail&#125;;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"431\"><a href=\"#431\" class=\"headerlink\" title=\"431.\"></a>431.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"432-全O-1-的数据结构-mM-unordered-map-双向有序链表h-t-细节超多！\"><a href=\"#432-全O-1-的数据结构-mM-unordered-map-双向有序链表h-t-细节超多！\" class=\"headerlink\" title=\"432.全O(1)的数据结构 (+-mM)unordered_map+双向有序链表h t 细节超多！\"></a>432.全O(1)的数据结构 (+-mM)unordered_map+双向有序链表h t 细节超多！</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210817105905949.png\" alt=\"image-20210817105905949\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;432.全O(1)的数据结构 (+-mM)unordered_map+双向有序链表h t\nclass AllOne &#123;\npublic:\n    struct Node &#123;\n        Node *left, *right;\n        int val;&#x2F;&#x2F;cnt\n        unordered_set&lt;string&gt; S;\n\n        Node (int _val) &#123;\n            val &#x3D; _val;\n            left &#x3D; right &#x3D; NULL;\n        &#125;\n    &#125;*left, *right;\n    unordered_map&lt;string, Node*&gt; hash;&#x2F;&#x2F;关联Node\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    AllOne() &#123;\n        left &#x3D; new Node(INT_MIN), right &#x3D; new Node(INT_MAX);&#x2F;&#x2F;边界+-INF\n        left-&gt;right &#x3D; right, right-&gt;left &#x3D; left;\n    &#125;\n\n    Node* add_to_right(Node* node, string key, int val) &#123;\n        if (node-&gt;right-&gt;val &#x3D;&#x3D; val) node-&gt;right-&gt;S.insert(key);&#x2F;&#x2F;val节点存在\n        else &#123;\n            auto t &#x3D; new Node(val);\n            t-&gt;S.insert(key);\n            t-&gt;right &#x3D; node-&gt;right, node-&gt;right-&gt;left &#x3D; t;\n            node-&gt;right &#x3D; t, t-&gt;left &#x3D; node;\n        &#125;\n        return node-&gt;right;\n    &#125;\n\n    Node* add_to_left(Node* node, string key, int val) &#123;\n        if (node-&gt;left-&gt;val &#x3D;&#x3D; val) node-&gt;left-&gt;S.insert(key);\n        else &#123;\n            auto t &#x3D; new Node(val);\n            t-&gt;S.insert(key);\n            t-&gt;left &#x3D; node-&gt;left, node-&gt;left-&gt;right &#x3D; t;\n            node-&gt;left &#x3D; t, t-&gt;right &#x3D; node;\n        &#125;\n        return node-&gt;left;\n    &#125;\n\n    void remove(Node* node) &#123;\n        node-&gt;left-&gt;right &#x3D; node-&gt;right;\n        node-&gt;right-&gt;left &#x3D; node-&gt;left;\n        delete node;&#x2F;&#x2F;双链表-\n    &#125;\n\n    &#x2F;** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. *&#x2F;\n    void inc(string key) &#123;\n        if (hash.count(key) &#x3D;&#x3D; 0) hash[key] &#x3D; add_to_right(left, key, 1);&#x2F;&#x2F;左边界\n        else &#123;\n            auto t &#x3D; hash[key];\n            t-&gt;S.erase(key);&#x2F;&#x2F;-+空删\n            hash[key] &#x3D; add_to_right(t, key, t-&gt;val + 1);\n            if (t-&gt;S.empty()) remove(t);\n        &#125;\n    &#125;\n\n    &#x2F;** Decrements an existing key by 1. If Key&#39;s value is 1, remove it from the data structure. *&#x2F;\n    void dec(string key) &#123;\n        if (hash.count(key) &#x3D;&#x3D; 0) return;\n        auto t &#x3D; hash[key];\n        t-&gt;S.erase(key);\n        if (t-&gt;val &gt; 1) &#123;\n            hash[key] &#x3D; add_to_left(t, key, t-&gt;val - 1);\n        &#125; else &#123;\n            hash.erase(key);&#x2F;&#x2F;cnt&#x3D;0 !!!!!\n        &#125;\n        if (t-&gt;S.empty()) remove(t);\n    &#125;\n\n    &#x2F;** Returns one of the keys with maximal value. *&#x2F;\n    string getMaxKey() &#123;\n        if (right-&gt;left !&#x3D; left) return *right-&gt;left-&gt;S.begin();\n        return &quot;&quot;;\n    &#125;\n\n    &#x2F;** Returns one of the keys with Minimal value. *&#x2F;\n    string getMinKey() &#123;\n        if (left-&gt;right !&#x3D; right) return *left-&gt;right-&gt;S.begin();\n        return &quot;&quot;;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your AllOne object will be instantiated and called as such:\n * AllOne* obj &#x3D; new AllOne();\n * obj-&gt;inc(key);\n * obj-&gt;dec(key);\n * string param_3 &#x3D; obj-&gt;getMaxKey();\n * string param_4 &#x3D; obj-&gt;getMinKey();\n *&#x2F;</code></pre>\n\n\n\n<h1 id=\"433-最小基因变化-最短路-宽搜bfs\"><a href=\"#433-最小基因变化-最短路-宽搜bfs\" class=\"headerlink\" title=\"433.最小基因变化 最短路 宽搜bfs\"></a>433.最小基因变化 最短路 宽搜bfs</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;433.最小基因变化\nclass Solution &#123;\npublic:\n    int minMutation(string start, string end, vector&lt;string&gt;&amp; bank) &#123;\n        unordered_set&lt;string&gt; S;\n        for (auto&amp; s: bank) S.insert(s);\n        unordered_map&lt;string, int&gt; dist;&#x2F;&#x2F;最短路 宽搜bfs\n        queue&lt;string&gt; q;\n        q.push(start);\n        dist[start] &#x3D; 0;&#x2F;&#x2F;\n        char chrs[4] &#x3D; &#123;&#39;A&#39;, &#39;T&#39;, &#39;C&#39;, &#39;G&#39;&#125;;\n\n        while (q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            for (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n                auto s &#x3D; t;\n                for (char c: chrs) &#123;\n                    s[i] &#x3D; c;\n                    if (S.count(s) &amp;&amp; dist.count(s) &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;合法且unvisited\n                        dist[s] &#x3D; dist[t] + 1;\n                        if (s &#x3D;&#x3D; end) return dist[s];\n                        q.push(s);&#x2F;&#x2F;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"434-字符串中的单词数-爽题\"><a href=\"#434-字符串中的单词数-爽题\" class=\"headerlink\" title=\"434.字符串中的单词数 爽题\"></a>434.字符串中的单词数 爽题</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;434.字符串中的单词数 爽题\nclass Solution &#123;\npublic:\n    int countSegments(string s) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            if (s[i] &#x3D;&#x3D; &#39; &#39;) continue;\n            int j &#x3D; i + 1;\n            while (j &lt; s.size() &amp;&amp; s[j] !&#x3D; &#39; &#39;) j ++ ;\n            res ++ ;\n\t\t\ti &#x3D; j - 1; &#x2F;&#x2F;或i &#x3D; j; s[j]&#x3D;&#x3D;&#39; &#39;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"435-无重叠区间-MaxCnt-经典贪心-按Rsort-能选就选\"><a href=\"#435-无重叠区间-MaxCnt-经典贪心-按Rsort-能选就选\" class=\"headerlink\" title=\"435.无重叠区间 MaxCnt 经典贪心 按Rsort 能选就选\"></a>435.无重叠区间 MaxCnt 经典贪心 按Rsort 能选就选</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210817120733014.png\" alt=\"image-20210817120733014\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;435.无重叠区间 MaxCnt 经典贪心 按Rsort 能选就选\n&#x2F;&#x2F; 去min_cnt使不重叠&#x3D;&#x3D;不重叠max_cnt(对偶问题):贪心\nclass Solution &#123;\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; q) &#123;\n        if(q.size() &lt; 2) return 0;\n        sort(q.begin(), q.end(), [](const vector&lt;int&gt;&amp;a,const vector&lt;int&gt;&amp;b) &#123;&#x2F;&#x2F;\n            return a[1] &#x3D;&#x3D; b[1] ? a[0] &gt; b[0] : a[1] &lt; b[1];\n        &#125;);\n        if (q.empty()) return 0;\n        int res &#x3D; 1, r &#x3D; q[0][1], n &#x3D; q.size();\n        for (int i &#x3D; 1; i &lt; n; i ++ )\n            if (q[i][0] &gt;&#x3D; r) &#123;\n                res ++;\n                r &#x3D; q[i][1];\n            &#125;\n        return q.size() - res;&#x2F;&#x2F;min_del\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;acw908 &#x3D;&#x3D;&gt; acw905.区间选点:min_vers_cover_substr【&#x3D;LC453】按Rsort 遇不覆盖段选cur_best:R(cover之后段可能最大)\n&#x2F;&#x2F;贪心适用于单峰函数</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210817124001763.png\" alt=\"image-20210817124001763\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210817124103266.png\" alt=\"image-20210817124103266\"></p>\n<h1 id=\"436-寻找右区间-lr数值最lower-bound-sort二分O-nlogn-acw830-单调栈-左max-idx最近-不同-l-r-i\"><a href=\"#436-寻找右区间-lr数值最lower-bound-sort二分O-nlogn-acw830-单调栈-左max-idx最近-不同-l-r-i\" class=\"headerlink\" title=\"436.寻找右区间[lr数值最lower_bound]sort二分O(nlogn) acw830.单调栈[左max idx最近]!不同! {l,r,i}\"></a>436.寻找右区间[lr数值最lower_bound]sort二分O(nlogn) acw830.单调栈[左max idx最近]!不同! {l,r,i}</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;对于每个区间 i，二分查找区间 j，满足 start_j &gt;&#x3D; end_i 且 start_j 最小。\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findRightInterval(vector&lt;vector&lt;int&gt;&gt;&amp; q) &#123;\n        int n &#x3D; q.size();\n        for (int i &#x3D; 0; i &lt; n; i ++ ) q[i].push_back(i);&#x2F;&#x2F;&#123;l,r,i&#125;\n        sort(q.begin(), q.end());\n        vector&lt;int&gt; res(n, -1);&#x2F;&#x2F;无:-1\n        for (auto&amp; x: q) &#123;\n            int l &#x3D; 0, r &#x3D; n - 1;\n            while (l &lt; r) &#123;\n                int mid &#x3D; l + r &gt;&gt; 1;\n                if (q[mid][0] &gt;&#x3D; x[1]) r &#x3D; mid;&#x2F;&#x2F;\n                else l &#x3D; mid + 1;\n            &#125;\n            if (q[r][0] &gt;&#x3D; x[1]) res[x[2]] &#x3D; q[r][2];&#x2F;&#x2F;存区间idx\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;find-right-interval&#x2F;solution&#x2F;yong-mapyou-xian-cheng-de-er-fen-lower_b-jq7q&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findRightInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;\n        map&lt;int,int&gt;left2index;&#x2F;&#x2F;sorted\n        for(int i&#x3D;0;i&lt;intervals.size();i++)&#123;\n            left2index[intervals[i][0]]&#x3D;i;\n        &#125;\n        vector&lt;int&gt;ans;\n        for(auto vec:intervals)&#123;\n            auto it&#x3D;left2index.lower_bound(vec[1]);&#x2F;&#x2F;&gt;&#x3D;r\n            if(it&#x3D;&#x3D;left2index.end())ans.push_back(-1);\n            else ans.push_back((*it).second);&#x2F;&#x2F;idx\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"？437-路径总和III-O-n-晕-：why只回溯cnt？？？区间和-x3D-sum-cnt-Si-T\"><a href=\"#？437-路径总和III-O-n-晕-：why只回溯cnt？？？区间和-x3D-sum-cnt-Si-T\" class=\"headerlink\" title=\"？437.路径总和III O(n)晕~：why只回溯cnt？？？区间和&#x3D;sum cnt[Si-T]\"></a>？437.路径总和III O(n)晕~：why只回溯cnt？？？区间和&#x3D;sum cnt[Si-T]</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210829173751509.png\" alt=\"image-20210829173751509\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    unordered_map&lt;int, int&gt; cnt;&#x2F;&#x2F;&#123;前缀和, cnt&#125;\n    int res &#x3D; 0;\n\n    int pathSum(TreeNode* root, int sum) &#123;&#x2F;&#x2F;区间和sum\n        cnt[0] ++ ;&#x2F;&#x2F;S0&#x3D;0 哨兵\n        dfs(root, sum, 0);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* root, int sum, int cur) &#123;&#x2F;&#x2F;cur:不包括root-&gt;val\n        if (!root) return;\n        cur +&#x3D; root-&gt;val;&#x2F;&#x2F;更新cur&#x3D;前缀和Si\n        res +&#x3D; cnt[cur - sum];&#x2F;&#x2F;cnt[Si-T]\n        cnt[cur] ++ ;&#x2F;&#x2F;更新cnt\n        dfs(root-&gt;left, sum, cur), dfs(root-&gt;right, sum, cur);&#x2F;&#x2F;起点不root了\n        cnt[cur] -- ;&#x2F;&#x2F;回溯\n    &#125;\n&#125;;\n\n\n\nclass Solution &#123;\npublic:\n    int res;\n    int s;\n    int pathSum(TreeNode* root, int sum) &#123;\n        if (!root) return 0;\n        s &#x3D; sum;\n        dfs(root, 0)&#x2F;&#x2F;\n        if (root -&gt; left) pathSum(root -&gt; left, sum); &#x2F;&#x2F;不一定是从根节点开始\n        if (root -&gt; right) pathSum(root -&gt; right, sum);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* u, int sum)\n    &#123;\n        sum +&#x3D; u -&gt; val;\n        if (s &#x3D;&#x3D; sum) res ++; &#x2F;&#x2F;路径不一定是叶节点结束\n        if (!u -&gt; left &amp;&amp; !u -&gt; right) return;\n        if (u -&gt; left) dfs(u -&gt; left, sum);\n        if (u -&gt; right) dfs(u -&gt; right, sum);\n    &#125;\n&#125;;\n\n作者：Roger_3\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;14333&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n\n\n<h1 id=\"438-找到字符串中所有字母异位词-O-n-双指针-m长滑动窗口cnt-c-x3D-x3D-的c达satisfy种即可-合二为一-x3D-0即可-cnt-s-j-x2F-x2F-cnt少一个s\"><a href=\"#438-找到字符串中所有字母异位词-O-n-双指针-m长滑动窗口cnt-c-x3D-x3D-的c达satisfy种即可-合二为一-x3D-0即可-cnt-s-j-x2F-x2F-cnt少一个s\" class=\"headerlink\" title=\"438.找到字符串中所有字母异位词 O(n)双指针:m长滑动窗口cnt[c]&#x3D;&#x3D;的c达satisfy种即可(合二为一:+-&#x3D;0即可) cnt[s[j++]]++;&#x2F;&#x2F;cnt少一个s-\"></a>438.找到字符串中所有字母异位词 O(n)双指针:m长滑动窗口cnt[c]&#x3D;&#x3D;的c达satisfy种即可(合二为一:+-&#x3D;0即可) cnt[s[j++]]++;&#x2F;&#x2F;cnt少一个s-</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;438.找到字符串中所有字母异位词 O(n)双指针:m长滑动窗口cnt[c]&#x3D;&#x3D;的c达satisfy种即可(合二为一:+-&#x3D;0即可)\n&#x2F;&#x2F; [类似LC3:不重最长子串]\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findAnagrams(string s, string p) &#123;\n        unordered_map&lt;char, int&gt; cnt;\n        for (auto c: p) cnt[c] ++ ;&#x2F;&#x2F;p+\n        vector&lt;int&gt; res;\n        int tot &#x3D; cnt.size();\n        for (int i &#x3D; 0, j &#x3D; 0, satisfy &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            if ( -- cnt[s[i]] &#x3D;&#x3D; 0) satisfy ++ ;\n            while (i - j + 1 &gt; p.size()) &#123; &#x2F;&#x2F;j++\n                if (cnt[s[j]] &#x3D;&#x3D; 0) satisfy -- ;\n                cnt[s[j ++ ]] ++ ;&#x2F;&#x2F;cnt少一个s-\n            &#125;\n            if (satisfy &#x3D;&#x3D; tot) res.push_back(j);&#x2F;&#x2F;idx_j\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"439\"><a href=\"#439\" class=\"headerlink\" title=\"439.\"></a>439.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"440-字典序的第K小数字-数位统计-数奥-难，需要很仔细-分类讨论-f-prefix-n-1-n中前缀为prefix的个数\"><a href=\"#440-字典序的第K小数字-数位统计-数奥-难，需要很仔细-分类讨论-f-prefix-n-1-n中前缀为prefix的个数\" class=\"headerlink\" title=\"440.字典序的第K小数字 数位统计 数奥:难，需要很仔细 分类讨论 f(prefix, n):1~n中前缀为prefix的个数\"></a>440.字典序的第K小数字 数位统计 数奥:难，需要很仔细 分类讨论 f(prefix, n):1~n中前缀为prefix的个数</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210829191339227.png\" alt=\"image-20210829191339227\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;440.字典序的第K小数字 数位统计 数奥\nclass Solution &#123;\npublic:\n    int f(int prefix, int n) &#123;\n        long long p &#x3D; 1;\n        auto A &#x3D; to_string(n), B &#x3D; to_string(prefix);\n        int dt &#x3D; A.size() - B.size();\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; dt; i ++ ) &#123; &#x2F;&#x2F;dt&gt;0 B比A短\n            res +&#x3D; p;\n            p *&#x3D; 10; &#x2F;&#x2F;最后一次p&#x3D;&#x3D;10^(a-b)\n        &#125;\n        A &#x3D; A.substr(0, B.size());\n        if (A &#x3D;&#x3D; B) res +&#x3D; n - prefix * p + 1; &#x2F;&#x2F;&lt;\n        else if (A &gt; B) res +&#x3D; p; &#x2F;&#x2F;随意\n        return res; &#x2F;&#x2F;BA等长,A&lt;B: res&#x3D;0\n    &#125;\n\n    int findKthNumber(int n, int k) &#123;\n        int prefix &#x3D; 1;\n        while (k &gt; 1) &#123;\n            int cnt &#x3D; f(prefix, n); &#x2F;&#x2F;f:1~n中前缀为prefix的个数\n            if (k &gt; cnt) &#123;\n                k -&#x3D; cnt;\n                prefix ++ ; &#x2F;&#x2F;换前缀\n            &#125; else &#123;\n                k -- ; &#x2F;&#x2F;当前前缀下的第k个 当前占一位\n                prefix *&#x3D; 10; &#x2F;&#x2F;定该前缀的下一位\n            &#125;\n        &#125;\n        return prefix;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"441-排列硬币-一元二次方程\"><a href=\"#441-排列硬币-一元二次方程\" class=\"headerlink\" title=\"441.排列硬币 一元二次方程\"></a>441.排列硬币 一元二次方程</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;441.排列硬币 一元二次方程\nclass Solution &#123;\npublic:\n    int arrangeCoins(int n) &#123;\n        return (-1 + sqrt(1 + 8.0 * n)) &#x2F; 2;&#x2F;&#x2F; k(k+1)&#x2F;2 &lt;&#x3D; n 求k_max k&gt;0\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"442-数组中重复的数据-T-x3D-O-n-1中原地找2次的数s-【奇技淫巧】把idx当做cnt-1-x3D-就记录-LC448\"><a href=\"#442-数组中重复的数据-T-x3D-O-n-1中原地找2次的数s-【奇技淫巧】把idx当做cnt-1-x3D-就记录-LC448\" class=\"headerlink\" title=\"442.数组中重复的数据 T&#x3D;O(n) 1中原地找2次的数s:【奇技淫巧】把idx当做cnt *(-1)&#x3D;+就记录[LC448]\"></a>442.数组中重复的数据 T&#x3D;O(n) 1中原地找2次的数s:【奇技淫巧】把idx当做cnt *(-1)&#x3D;+就记录[LC448]</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210830173055868.png\" alt=\"image-20210830173055868\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; res;\n        for (auto x: nums) &#123;\n            int p &#x3D; abs(x) - 1;&#x2F;&#x2F;0~n-1\n            nums[p] *&#x3D; -1;\n            if (nums[p] &gt; 0) res.push_back(abs(x));&#x2F;&#x2F;原地 奇技淫巧\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"443-压缩字符串-游程-直接覆盖-len无1-按位拿出k-t：O-1\"><a href=\"#443-压缩字符串-游程-直接覆盖-len无1-按位拿出k-t：O-1\" class=\"headerlink\" title=\"443.压缩字符串 游程 直接覆盖 len无1 按位拿出k~t：O(1)\"></a>443.压缩字符串 游程 直接覆盖 len无1 按位拿出k~t：O(1)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;443.压缩字符串 游程 直接覆盖\nclass Solution &#123;\npublic:\n    int compress(vector&lt;char&gt;&amp; s) &#123;\n        int k &#x3D; 0;&#x2F;&#x2F;ans_idx\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            int j &#x3D; i + 1;\n            while (j &lt; s.size() &amp;&amp; s[j] &#x3D;&#x3D; s[i]) j ++ ;\n            int len &#x3D; j - i;\n            s[k ++ ] &#x3D; s[i];&#x2F;&#x2F;ch\n            &#x2F;&#x2F;无1 按位拿出k~t：O(1)  to_string(len):S&#x3D;O(logn)&#x3D;3 也可以~\n            if (len &gt; 1) &#123;\n                int t &#x3D; k;\n                while (len) &#123;\n                    s[t ++ ] &#x3D; &#39;0&#39; + len % 10;\n                    len &#x2F;&#x3D; 10;\n                &#125;\n                reverse(s.begin() + k, s.begin() + t);\n                k &#x3D; t;\n            &#125;\n            i &#x3D; j - 1;\n        &#125;\n        return k;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"444\"><a href=\"#444\" class=\"headerlink\" title=\"444.\"></a>444.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"445-两数相加II-反转链表-高精度加法-头插\"><a href=\"#445-两数相加II-反转链表-高精度加法-头插\" class=\"headerlink\" title=\"445.两数相加II 反转链表+高精度加法 头插\"></a>445.两数相加II 反转链表+高精度加法 头插</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;445.两数相加II\nclass Solution &#123;\npublic:\n\t&#x2F;&#x2F; 翻转链表\n    ListNode* reverse(ListNode* head) &#123;\n        auto a &#x3D; head, b &#x3D; head-&gt;next;\n        while (b) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n        head-&gt;next &#x3D; NULL;&#x2F;&#x2F;\n        return a;\n    &#125;\n\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n        l1 &#x3D; reverse(l1), l2 &#x3D; reverse(l2);\n        auto head &#x3D; new ListNode(-1);&#x2F;&#x2F;答案链表头插\n        &#x2F;&#x2F; 高精度加法\n        int t &#x3D; 0;&#x2F;&#x2F;进位\n        while (l1 || l2 || t) &#123;\n            if (l1) t +&#x3D; l1-&gt;val, l1 &#x3D; l1-&gt;next;\n            if (l2) t +&#x3D; l2-&gt;val, l2 &#x3D; l2-&gt;next;\n            auto cur &#x3D; new ListNode(t % 10);\n            t &#x2F;&#x3D; 10;\n            cur-&gt;next &#x3D; head-&gt;next;&#x2F;&#x2F;\n            head-&gt;next &#x3D; cur;\n        &#125;\n        return head-&gt;next;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;reverse*3\nclass Solution &#123;\npublic:\n\t&#x2F;&#x2F; 翻转链表\n    ListNode* reverse(ListNode* head) &#123;\n        auto a &#x3D; head, b &#x3D; head-&gt;next;\n        while (b) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n        head-&gt;next &#x3D; NULL;&#x2F;&#x2F;\n        return a;\n    &#125;\n\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n        l1 &#x3D; reverse(l1), l2 &#x3D; reverse(l2);\n        auto dummy &#x3D; new ListNode(-1), cur &#x3D; dummy;\n        &#x2F;&#x2F; 高精度加法\n        int t &#x3D; 0;\n        while (l1 || l2 || t) &#123;\n            if (l1) t +&#x3D; l1-&gt;val, l1 &#x3D; l1-&gt;next;\n            if (l2) t +&#x3D; l2-&gt;val, l2 &#x3D; l2-&gt;next;\n            cur &#x3D; cur-&gt;next &#x3D; new ListNode(t % 10);&#x2F;&#x2F;\n            t &#x2F;&#x3D; 10;\n        &#125;\n        return reverse(dummy-&gt;next);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"446-等差数列划分II-子序列-cnt-DP-O-n-n\"><a href=\"#446-等差数列划分II-子序列-cnt-DP-O-n-n\" class=\"headerlink\" title=\"446.等差数列划分II-子序列 cnt DP O(n*n)\"></a>446.等差数列划分II-子序列 cnt DP O(n*n)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831110410705.png\" alt=\"image-20210831110410705\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;446.等差数列划分II-子序列 cnt DP O(n*n)\n&#x2F;*\n设 f(i,d) 表示以 i 为结尾的差值为 d 的子序列的个数（包括长度为 2 的）。\n初始时 f(i,d) 都是 0。转移时，枚举 0≤j&lt;i，令 d&#x3D;A[i]−A[j]，则 f(i,d)+&#x3D;f(j,d)+1\n[(&gt;&#x3D;2) +&#x3D; (&gt;&#x3D;3) + (aj,ai)]，这个的意思是以 j 结尾的子序列都可以接到 A[i] 上，A[i], A[j] 也算 1 个。\n最终答案为 ∑i∑df(i,d)\n数值大，但个数不多：hash表\n*&#x2F;\nclass Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; a) &#123;\n        typedef long long LL;\n        int n &#x3D; a.size();\n        vector&lt;unordered_map&lt;LL, int&gt;&gt; f(n);&#x2F;&#x2F;常数大\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            for (int k &#x3D; 0; k &lt; i; k ++ ) &#123;\n                LL j &#x3D; (LL)a[i] - a[k];\n                &#x2F;&#x2F; res +&#x3D; f[k][j];&#x2F;&#x2F;查找两次~\n                &#x2F;&#x2F; f[i][j] +&#x3D; f[k][j] + 1\n                auto it &#x3D; f[k].find(j);&#x2F;&#x2F;f[k][j]存在 只找一次！\n                int t &#x3D; 0;\n                if (it !&#x3D; f[k].end()) &#123;\n                    t &#x3D; it-&gt;second;\n                    res +&#x3D; t;&#x2F;&#x2F;(&gt;&#x3D;3)\n                &#125;\n                f[i][j] +&#x3D; t + 1;&#x2F;&#x2F;f[i][j]+&#x3D;f[k][j]+1\n            &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"447-回旋镖的数量-ijk-ij-x3D-ik-cnt-与i距离dist的点数-sigma-P-C-2-不同jk总数\"><a href=\"#447-回旋镖的数量-ijk-ij-x3D-ik-cnt-与i距离dist的点数-sigma-P-C-2-不同jk总数\" class=\"headerlink\" title=\"447.回旋镖的数量 ijk ij&#x3D;ik cnt:与i距离dist的点数 sigma_P(C,2) 不同jk总数\"></a>447.回旋镖的数量 ijk ij&#x3D;ik cnt:与i距离dist的点数 sigma_P(C,2) 不同jk总数</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831110855397.png\" alt=\"image-20210831110855397\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;447.回旋镖的数量 ijk ij&#x3D;ik cnt\nclass Solution &#123;\npublic:\n    int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; p) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; p.size(); i ++ ) &#123;\n            unordered_map&lt;int, int&gt; cnt;&#x2F;&#x2F;&#123;dist,cnt&#125;：与i距离dist的点数\n            for (int j &#x3D; 0; j &lt; p.size(); j ++ )\n                if (i !&#x3D; j) &#123;&#x2F;&#x2F;\n                    int dx &#x3D; p[i][0] - p[j][0];\n                    int dy &#x3D; p[i][1] - p[j][1];\n                    int dist &#x3D; dx * dx + dy * dy;&#x2F;&#x2F;sqrt有精度问题\n                    cnt[dist] ++ ;\n                &#125;\n            for (auto [d, c]: cnt) res +&#x3D; c * (c - 1);&#x2F;&#x2F;sigma_P(C,2) 不同jk总数\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"448-找到所有数组中消失的数字-nums-0-n-1-to-不管！原地vis-思想同LC442\"><a href=\"#448-找到所有数组中消失的数字-nums-0-n-1-to-不管！原地vis-思想同LC442\" class=\"headerlink\" title=\"448.找到所有数组中消失的数字 nums[0~n-1] +to- -不管！原地vis 思想同LC442\"></a>448.找到所有数组中消失的数字 nums[0~n-1] +to- -不管！原地vis 思想同LC442</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;\n        for (auto x: nums) &#123;\n            x &#x3D; abs(x);&#x2F;&#x2F;-:abs\n            if (nums[x - 1] &gt; 0) nums[x - 1] *&#x3D; -1;&#x2F;&#x2F;nums[0~n-1] +to- -不管！vis\n        &#125;\n        vector&lt;int&gt; res;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ )\n            if (nums[i] &gt; 0)\n                res.push_back(i + 1);&#x2F;&#x2F;1~n\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"449-序列化和反序列化二叉-搜索-树-d-vec-ssin-子树范围-lt-gt-x3D-也能过：说明v唯一\"><a href=\"#449-序列化和反序列化二叉-搜索-树-d-vec-ssin-子树范围-lt-gt-x3D-也能过：说明v唯一\" class=\"headerlink\" title=\"449.序列化和反序列化二叉[搜索]树  d:vec ssin 子树范围 &lt; &gt;&#x3D;也能过：说明v唯一\"></a>449.序列化和反序列化二叉[搜索]树  d:vec ssin 子树范围 &lt; &gt;&#x3D;也能过：说明v唯一</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;449.序列化和反序列化二叉[搜索]树 \n&#x2F;&#x2F; 不要使用类成员&#x2F;全局&#x2F;静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。\n&#x2F;&#x2F; d:vec ssin 子树范围 &lt; &gt;&#x3D;也能过：说明v唯一\nclass Codec &#123;\npublic:\n\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    string serialize(TreeNode* root) &#123;\n        string res;\n        dfs_s(root, res);\n        return res;\n    &#125;\n\n    void dfs_s(TreeNode* root, string&amp; res) &#123;\n        if (!root) return;\n        res +&#x3D; to_string(root-&gt;val) + &#39; &#39;;\n        dfs_s(root-&gt;left, res), dfs_s(root-&gt;right, res);\n    &#125;\n\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    TreeNode* deserialize(string str) &#123;\n        vector&lt;int&gt; data;&#x2F;&#x2F;\n        stringstream ssin(str);&#x2F;&#x2F;\n        int x, u &#x3D; 0;\n        while (ssin &gt;&gt; x) data.push_back(x);\n        return dfs_d(data, u, INT_MIN, INT_MAX);&#x2F;&#x2F;子树范围\n    &#125;\n\n    TreeNode* dfs_d(vector&lt;int&gt;&amp; data, int&amp; u, int minv, int maxv) &#123;\n        if (u &#x3D;&#x3D; data.size() || data[u] &lt; minv || data[u] &gt; maxv) return NULL;\n        auto root &#x3D; new TreeNode(data[u ++ ]);\n        root-&gt;left &#x3D; dfs_d(data, u, minv, root-&gt;val);&#x2F;&#x2F;&lt;&#x3D;\n        root-&gt;right &#x3D; dfs_d(data, u, root-&gt;val + 1, maxv);&#x2F;&#x2F;&gt;\n        return root;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"450-删除二叉搜索树中的节点-经典ds-O-h-x3D-logn-amp-root-后继p覆盖root，删p\"><a href=\"#450-删除二叉搜索树中的节点-经典ds-O-h-x3D-logn-amp-root-后继p覆盖root，删p\" class=\"headerlink\" title=\"450.删除二叉搜索树中的节点 经典ds O(h&#x3D;logn) &amp;root 后继p覆盖root，删p\"></a>450.删除二叉搜索树中的节点 经典ds O(h&#x3D;logn) &amp;root 后继p覆盖root，删p</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831120933842.png\" alt=\"image-20210831120933842\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;450.删除二叉搜索树中的节点 经典ds O(h&#x3D;logn) &amp;root 后继p覆盖root，删p\nclass Solution &#123;\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) &#123;\n        del(root, key);\n        return root;&#x2F;&#x2F;&amp;root\n    &#125;\n\n    void del(TreeNode* &amp;root, int key) &#123;\n        if (!root) return;\n        if (key &#x3D;&#x3D; root-&gt;val) &#123;\n            if (!root-&gt;left &amp;&amp; !root-&gt;right) root &#x3D; NULL;  &#x2F;&#x2F; 叶节点 &amp;更灵活：不分父的lr auto\n            else if (!root-&gt;left) root &#x3D; root-&gt;right;  &#x2F;&#x2F; 只有右儿子\n            else if (!root-&gt;right) root &#x3D; root-&gt;left;  &#x2F;&#x2F; 只有左儿子\n            else &#123;  &#x2F;&#x2F; 左右儿子都有\n                auto p &#x3D; root-&gt;right;\n                while (p-&gt;left) p &#x3D; p-&gt;left;  &#x2F;&#x2F; 找后继\n                root-&gt;val &#x3D; p-&gt;val;&#x2F;&#x2F;p覆盖root，删p\n                del(root-&gt;right, p-&gt;val);\n            &#125;\n        &#125;\n        else if (key &lt; root-&gt;val) del(root-&gt;left, key);\n        else del(root-&gt;right, key);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"451-根据字符出现频率排序-双关键字排序：cnt-gt-ASCII字典序-lt-amp\"><a href=\"#451-根据字符出现频率排序-双关键字排序：cnt-gt-ASCII字典序-lt-amp\" class=\"headerlink\" title=\"451.根据字符出现频率排序 双关键字排序：cnt&gt;,ASCII字典序&lt;  [&amp;]\"></a>451.根据字符出现频率排序 双关键字排序：cnt&gt;,ASCII字典序&lt;  [&amp;]</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string frequencySort(string s) &#123;\n        unordered_map&lt;char, int&gt; cnt;\n        for (auto c: s) cnt[c] ++ ;\n        &#x2F;&#x2F;双关键字排序：cnt&gt;,ASCII字典序&lt;  [&amp;](char a, char b)\n        sort(s.begin(), s.end(), [&amp;](char a, char b) &#123;\n            if (cnt[a] !&#x3D; cnt[b]) return cnt[a] &gt; cnt[b];\n            return a &lt; b;\n        &#125;);\n        return s;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"452-用最少数量的箭引爆气球-acw905区间选点-R排-不覆盖段选R-覆盖最多-lt-gt-LC435-区间贪心\"><a href=\"#452-用最少数量的箭引爆气球-acw905区间选点-R排-不覆盖段选R-覆盖最多-lt-gt-LC435-区间贪心\" class=\"headerlink\" title=\"452.用最少数量的箭引爆气球 acw905区间选点 R排,不覆盖段选R(覆盖最多)  &lt;-&gt;LC435 区间贪心\"></a>452.用最少数量的箭引爆气球 acw905区间选点 R排,不覆盖段选R(覆盖最多)  &lt;-&gt;LC435 区间贪心</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831161841320.png\" alt=\"image-20210831161841320\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        if (points.empty()) return 0;\n        sort(points.begin(), points.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;\n            return a[1] &lt; b[1];&#x2F;&#x2F;R sort\n        &#125;);\n        int res &#x3D; 1, r &#x3D; points[0][1];\n        for (int i &#x3D; 1; i &lt; points.size(); i ++ )\n            if (points[i][0] &gt; r) &#123;\n                res ++ ;\n                r &#x3D; points[i][1];&#x2F;&#x2F;不覆盖段选R\n            &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"453-最小移动次数使数组元素相等-n-1个-1-x3D-x3D-1个-1-cnt-x3D-tot-n-min-x-accumulate-min-element\"><a href=\"#453-最小移动次数使数组元素相等-n-1个-1-x3D-x3D-1个-1-cnt-x3D-tot-n-min-x-accumulate-min-element\" class=\"headerlink\" title=\"453.最小移动次数使数组元素相等 n-1个+1&#x3D;&#x3D;1个-1 cnt&#x3D;tot-n*min_x accumulate min_element\"></a>453.最小移动次数使数组元素相等 n-1个+1&#x3D;&#x3D;1个-1 cnt&#x3D;tot-n*min_x accumulate min_element</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;453.最小移动次数使数组元素相等 n-1个+1&#x3D;&#x3D;1个-1 cnt&#x3D;tot-n*min_x\n&#x2F;&#x2F; STL:accumulate min_element\nclass Solution &#123;\npublic:\n    int minMoves(vector&lt;int&gt;&amp; nums) &#123;\n        return accumulate(nums.begin(), nums.end(), 0) \n            - nums.size() * *min_element(nums.begin(), nums.end());\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    int minMoves(vector&lt;int&gt;&amp; nums) &#123;\n        int minv &#x3D; INT_MAX;\n        for (auto x: nums) minv &#x3D; min(minv, x);\n        int res &#x3D; 0;\n        for (auto x: nums) res +&#x3D; x - minv;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"454-四数相加II-O-n-n-空间换时间cnt-c-d-res-x3D-cnt-a-b\"><a href=\"#454-四数相加II-O-n-n-空间换时间cnt-c-d-res-x3D-cnt-a-b\" class=\"headerlink\" title=\"454.四数相加II O(n*n) 空间换时间cnt[c+d]++; res+&#x3D;cnt[-(a+b)];\"></a>454.四数相加II O(n*n) 空间换时间cnt[c+d]++; res+&#x3D;cnt[-(a+b)];</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831180702043.png\" alt=\"image-20210831180702043\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;454.四数相加II O(n*n) 空间换时间cnt[c+d]++ res+&#x3D;cnt[-(a+b)];\nclass Solution &#123;\npublic:\n    int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;\n        unordered_map&lt;int, int&gt; cnt;\n        for (auto c: C)\n            for (auto d: D)\n                cnt[c + d] ++ ;\n        int res &#x3D; 0;\n        for (auto a: A)\n            for (auto b: B)\n                res +&#x3D; cnt[-(a + b)];\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"455-分发饼干-贪心-O-nlogn-sort-Greedy解：min-gi、Si单调、Si为-gt-x3D-gi的first\"><a href=\"#455-分发饼干-贪心-O-nlogn-sort-Greedy解：min-gi、Si单调、Si为-gt-x3D-gi的first\" class=\"headerlink\" title=\"455.分发饼干 贪心 O(nlogn) sort+Greedy解：min_gi、Si单调、Si为&gt;&#x3D;gi的first\"></a>455.分发饼干 贪心 O(nlogn) sort+Greedy解：min_gi、Si单调、Si为&gt;&#x3D;gi的first</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831182237392.png\" alt=\"image-20210831182237392\"></p>\n<p>1&lt;2&lt;3 2&lt;3&lt;4 可以swap为单调</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831183000663.png\" alt=\"image-20210831183000663\"></p>\n<p>Greedy解：Si为&gt;&#x3D;gi的first </p>\n<p>第一个与G解不同的Best解B1可前移为G1，不影响后面的解！以此类推~  G&#x3D;B！！！</p>\n<p>逐步缩小解集范围！</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;455.分发饼干 贪心 O(nlogn) sort+Greedy解：min_gi、Si单调、Si为&gt;&#x3D;gi的first\n&#x2F;&#x2F; 二分图最大匹配：匈牙利算法模板O(nm) \nclass Solution &#123;\npublic:\n    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int res &#x3D; 0;\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; g.size(); i ++ ) &#123;\n            while (j &lt; s.size() &amp;&amp; s[j] &lt; g[i]) j ++ ;&#x2F;&#x2F;\n            if (j &lt; s.size()) &#123;\n                res ++ ;\n                j ++ ;\n            &#125;\n            else break;&#x2F;&#x2F;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int ans &#x3D; 0;\n\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; g.size() &amp;&amp; j &lt; s.size(); j++)\n            if (s[j] &gt;&#x3D; g[i]) &#123;\n                ans++;\n                i++;\n            &#125;\n\n        return ans;\n    &#125;\n&#125;;\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;375&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"？？？456-132模式-单调栈O-n-难-单调栈顶维护的是3，max-k-right-维护的是2，枚举的是nums-i-“1”【Knuth所提出来的-stack-sortable-permutation】\"><a href=\"#？？？456-132模式-单调栈O-n-难-单调栈顶维护的是3，max-k-right-维护的是2，枚举的是nums-i-“1”【Knuth所提出来的-stack-sortable-permutation】\" class=\"headerlink\" title=\"？？？456.132模式 单调栈O(n) 难 单调栈顶维护的是3，max_k(right)维护的是2，枚举的是nums[i] “1”【Knuth所提出来的 stack-sortable permutation】\"></a>？？？456.132模式 单调栈O(n) 难 单调栈顶维护的是3，max_k(right)维护的是2，枚举的是nums[i] “1”【Knuth所提出来的 stack-sortable permutation】</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831193615478.png\" alt=\"image-20210831193615478\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210831194407918.png\" alt=\"image-20210831194407918\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;???？？？456.132模式 单调栈O(n)\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;132-pattern&#x2F;solution&#x2F;132mo-shi-by-leetcode-solution-ye89&#x2F;\n&#x2F;*\n单调栈维护的是3，max_k(right)维护的是2，枚举的是nums[i] &quot;1&quot;，\nmax_k来源于单调栈，所以其索引一定大于栈顶的元素，但其值一定小于栈顶元素，故栈顶元素就是3，\n即找到了对“32”。 \n于是当出现nums[i] &lt; max_k时，即找到了&quot;12&quot;，这个时候一定会有3个元素的，\n而栈顶3必定大于2，故也大于1，即满足“132”\n*&#x2F;\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;6595&#x2F;\n&#x2F;*\n这个问题与Knuth所提出来的 stack-sortable permutation 类似，\n即判断一个数组是否可以只用一个栈来进行排序，当且仅当它不包含231模式。\n而将本问题中的数组逆序，寻找132模式就变成了寻找231模式，也即判断数组是否可以仅用一个栈来进行排序。\n*&#x2F;\n&#x2F;&#x2F; https:&#x2F;&#x2F;en.jinzhao.wiki&#x2F;wiki&#x2F;Stack-sortable_permutation\nclass Solution &#123;\npublic:\n    bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;\n        stack&lt;int&gt; stk;\n        int right &#x3D; INT_MIN;&#x2F;&#x2F;max_Ak\n        for (int i &#x3D; nums.size() - 1; i &gt;&#x3D; 0; i -- ) &#123;\n            if (nums[i] &lt; right) return true;&#x2F;&#x2F;枚举到了1：满足要求\n            while (stk.size() &amp;&amp; nums[i] &gt; stk.top()) &#123;&#x2F;&#x2F;栈顶&lt;Ai\n                right &#x3D; max(right, stk.top());&#x2F;&#x2F;更新right 2\n                stk.pop();&#x2F;&#x2F;删栈顶 (top 3刚好&gt;2 &#x3D;&#x3D; 2是max_Ak)\n            &#125;\n            stk.push(nums[i]);&#x2F;&#x2F;Ai入栈\n        &#125;\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"457-环形数组循环-路径标记寻环-O-n-快慢指针寻环\"><a href=\"#457-环形数组循环-路径标记寻环-O-n-快慢指针寻环\" class=\"headerlink\" title=\"457.环形数组循环 (路径标记寻环) O(n) (快慢指针寻环)\"></a>457.环形数组循环 (路径标记寻环) O(n) (快慢指针寻环)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901001002315.png\" alt=\"image-20210901001002315\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;457.环形数组循环 (路径标记寻环) O(n) (快慢指针寻环)\nclass Solution &#123;\npublic:\n    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size(), Base &#x3D; 10000;\n        for (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n            if (nums[i] &gt;&#x3D; Base) continue;&#x2F;&#x2F;vis\n            int k &#x3D; i, S &#x3D; Base + i, t &#x3D; nums[k] &gt; 0;&#x2F;&#x2F;mark:S 符号:t\n            int last &#x3D; -1;\n            do &#123;\n                int p &#x3D; ((k + nums[k]) % n + n) % n;&#x2F;&#x2F;k-&gt;跳到p\n                last &#x3D; nums[k], nums[k] &#x3D; S;\n                k &#x3D; p;\n            &#125; while (k !&#x3D; i &amp;&amp; nums[k] &lt; Base &amp;&amp; (t ^ (nums[k] &gt; 0)) &#x3D;&#x3D; 0);&#x2F;&#x2F;unvis 符号&#x3D;&#x3D;\n            if (last % n &amp;&amp; nums[k] &#x3D;&#x3D; S) return true;&#x2F;&#x2F;last%n!&#x3D;0：len&gt;1的环\n        &#125;\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"458-可怜的小猪-m-min后有毒死一轮-P-min内check-n中哪桶毒所需min-x头猪-x3D-数学O-logn\"><a href=\"#458-可怜的小猪-m-min后有毒死一轮-P-min内check-n中哪桶毒所需min-x头猪-x3D-数学O-logn\" class=\"headerlink\" title=\"458.可怜的小猪 m_min后有毒死一轮 P_min内check n中哪桶毒所需min_x头猪&#x3D;? 数学O(logn)\"></a>458.可怜的小猪 m_min后有毒死一轮 P_min内check n中哪桶毒所需min_x头猪&#x3D;? 数学O(logn)</h1><p>&#x2F;&#x2F; 状态数(k+1)^x&gt;&#x3D;n x&gt;&#x3D;ceil(log(n)&#x2F;log(k+1))</p>\n<p>条件：</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901092019929.png\" alt=\"image-20210901092019929\"></p>\n<p>方案：</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901093646185.png\" alt=\"image-20210901093646185\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;458.可怜的小猪 m_min后有毒死一轮 P_min内check n中哪桶毒所需min_x头猪&#x3D;?\n&#x2F;&#x2F; 状态数(k+1)^x&gt;&#x3D;n x&gt;&#x3D;ceil(log(n)&#x2F;log(k+1))  方案：x位的k+1进制数-&gt;10进制数&#x3D;哪桶毒\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;131&#x2F;\nclass Solution &#123;\npublic:\n    int poorPigs(int n, int minutesToDie, int minutesToTest) &#123;\n        int k &#x3D; minutesToTest &#x2F; minutesToDie;&#x2F;&#x2F;轮数k&#x3D;P&#x2F;m\n        return ceil(log(n) &#x2F; log(k + 1));&#x2F;&#x2F;x&gt;&#x3D;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"459-重复的子字符串-蓝书P73-74-min-t-x3D-n-KMP-next-n-min-t-n\"><a href=\"#459-重复的子字符串-蓝书P73-74-min-t-x3D-n-KMP-next-n-min-t-n\" class=\"headerlink\" title=\"459.重复的子字符串 蓝书P73~74 min_t&#x3D;n-KMP_next[n] min_t|n\"></a>459.重复的子字符串 蓝书P73~74 min_t&#x3D;n-KMP_next[n] min_t|n</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901095121639.png\" alt=\"image-20210901095121639\"></p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901095911528.png\" alt=\"image-20210901095911528\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;459.重复的子字符串 蓝书P73~74 min_t&#x3D;n-KMP_next[n] min_t|n\n&#x2F;&#x2F; 结论1：min周期：n-KMP_next[n](min_t可以不|n)\n&#x2F;&#x2F; 结论2：min_t是所有周期的公约数(故min_t|n，否则无周期)\n&#x2F;&#x2F; 证明见：https:&#x2F;&#x2F;www.acwing.com&#x2F;video&#x2F;1861&#x2F;\nclass Solution &#123;\npublic:\n    bool repeatedSubstringPattern(string s) &#123;\n        int n &#x3D; s.size();\n        s &#x3D; &#39; &#39; + s;&#x2F;&#x2F;next 背！\n        vector&lt;int&gt; next(n + 1);\n        for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#123;\n            while (j &amp;&amp; s[i] !&#x3D; s[j + 1]) j &#x3D; next[j];\n            if (s[i] &#x3D;&#x3D; s[j + 1]) j ++ ;\n            next[i] &#x3D; j;\n        &#125;\n        int t &#x3D; n - next[n];\n        return t &lt; n &amp;&amp; n % t &#x3D;&#x3D; 0; &#x2F;&#x2F; min_t&lt;n &amp;&amp; min_t|n\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"460-LFU缓存-设计-难-扩146-LRU-双链表嵌套-list-RW-O-1-hash-block-x2F-node-cnt-key-erase-size\"><a href=\"#460-LFU缓存-设计-难-扩146-LRU-双链表嵌套-list-RW-O-1-hash-block-x2F-node-cnt-key-erase-size\" class=\"headerlink\" title=\"460.LFU缓存 设计 难 扩146.LRU 双链表嵌套:list RW_O(1):hash_block&#x2F;node:cnt [key] erase size\"></a>460.LFU缓存 设计 难 扩146.LRU 双链表嵌套:list RW_O(1):hash_block&#x2F;node:cnt [key] erase size</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901105451293.png\" alt=\"image-20210901105451293\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;460.LFU缓存 扩146.LRU 双链表嵌套:list RW_O(1):hash_block&#x2F;node:cnt [key] erase size\nclass LFUCache &#123;\npublic:\n    struct Node &#123;\n        Node *left, *right;\n        int key, val;\n        Node(int _key, int _val) &#123;\n            key &#x3D; _key, val &#x3D; _val;\n            left &#x3D; right &#x3D; NULL;\n        &#125;\n    &#125;;\n    struct Block &#123;\n        Block *left, *right;\n        Node *head, *tail;&#x2F;&#x2F;哨兵\n        int cnt;\n        Block(int _cnt) &#123;\n            cnt &#x3D; _cnt;\n            left &#x3D; right &#x3D; NULL;\n            head &#x3D; new Node(-1, -1), tail &#x3D; new Node(-1, -1);\n            head-&gt;right &#x3D; tail, tail-&gt;left &#x3D; head;\n        &#125;\n        ~Block() &#123;&#x2F;&#x2F;~块内双链表\n            delete head;\n            delete tail;\n        &#125;\n        void insert(Node* p) &#123;\n            p-&gt;right &#x3D; head-&gt;right;\n            head-&gt;right-&gt;left &#x3D; p;\n            p-&gt;left &#x3D; head;\n            head-&gt;right &#x3D; p;\n        &#125;\n        void remove(Node* p) &#123;\n            p-&gt;left-&gt;right &#x3D; p-&gt;right;\n            p-&gt;right-&gt;left &#x3D; p-&gt;left;\n        &#125;\n        bool empty() &#123;\n            return head-&gt;right &#x3D;&#x3D; tail;\n        &#125;\n    &#125;*head, *tail;\n    int n;\n    unordered_map&lt;int, Block*&gt; hash_block;\n    unordered_map&lt;int, Node*&gt; hash_node;\n\n    void insert(Block* p) &#123;  &#x2F;&#x2F; 在p的右侧插入新块，cnt是p-&gt;cnt + 1\n        auto cur &#x3D; new Block(p-&gt;cnt + 1);\n        cur-&gt;right &#x3D; p-&gt;right;\n        p-&gt;right-&gt;left &#x3D; cur;\n        p-&gt;right &#x3D; cur;\n        cur-&gt;left &#x3D; p;\n    &#125;\n\n    void remove(Block* p) &#123;\n        p-&gt;left-&gt;right &#x3D; p-&gt;right;\n        p-&gt;right-&gt;left &#x3D; p-&gt;left;\n        delete p;&#x2F;&#x2F;~Block\n    &#125;\n\n    LFUCache(int capacity) &#123;\n        n &#x3D; capacity;\n        head &#x3D; new Block(0), tail &#x3D; new Block(INT_MAX);&#x2F;&#x2F;\n        head-&gt;right &#x3D; tail, tail-&gt;left &#x3D; head;\n    &#125;\n\n    int get(int key) &#123;\n        if (hash_block.count(key) &#x3D;&#x3D; 0) return -1;\n        auto block &#x3D; hash_block[key];\n        auto node &#x3D; hash_node[key];\n        &#x2F;&#x2F;cnt+1: -++(更新block)-\n        block-&gt;remove(node);\n        if (block-&gt;right-&gt;cnt !&#x3D; block-&gt;cnt + 1) insert(block);\n        block-&gt;right-&gt;insert(node);\n        hash_block[key] &#x3D; block-&gt;right;\n        if (block-&gt;empty()) remove(block);\n        return node-&gt;val;\n    &#125;\n\n    void put(int key, int value) &#123;\n        if (!n) return;&#x2F;&#x2F;边界\n        if (hash_block.count(key)) &#123;&#x2F;&#x2F;有\n            hash_node[key]-&gt;val &#x3D; value;&#x2F;&#x2F;put_value\n            get(key);&#x2F;&#x2F;cnt+1\n        &#125; else &#123;\n            if (hash_block.size() &#x3D;&#x3D; n) &#123;&#x2F;&#x2F;满了，要先删头block尾node\n                auto p &#x3D; head-&gt;right-&gt;tail-&gt;left;\n                head-&gt;right-&gt;remove(p);\n                if (head-&gt;right-&gt;empty()) remove(head-&gt;right);&#x2F;&#x2F;块空 删\n                hash_block.erase(p-&gt;key);\n                hash_node.erase(p-&gt;key);\n                delete p;\n            &#125;\n            &#x2F;&#x2F;无 cnt1头块insert\n            auto p &#x3D; new Node(key, value);\n            if (head-&gt;right-&gt;cnt &gt; 1) insert(head);\n            head-&gt;right-&gt;insert(p);\n            hash_block[key] &#x3D; head-&gt;right;\n            hash_node[key] &#x3D; p;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;Java: https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;8960&#x2F;\n</code></pre>\n\n\n\n<h1 id=\"461-汉明距离-bin不同的位数：\"><a href=\"#461-汉明距离-bin不同的位数：\" class=\"headerlink\" title=\"461.汉明距离 bin不同的位数：^\"></a>461.汉明距离 bin不同的位数：^</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;461.汉明距离 bin不同的位数：^\nclass Solution &#123;\npublic:\n    int hammingDistance(int x, int y) &#123;\n        int res &#x3D; 0;\n        while (x || y) &#123;\n            res +&#x3D; (x &amp; 1) ^ (y &amp; 1);&#x2F;&#x2F;bin不同的位数\n            x &gt;&gt;&#x3D; 1, y &gt;&gt;&#x3D; 1;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"462-最少移动次数使数组元素相等II-选1-1或-1-LC453-x3D-x3D-acw104-货仓选址：求sigma中位数dist！\"><a href=\"#462-最少移动次数使数组元素相等II-选1-1或-1-LC453-x3D-x3D-acw104-货仓选址：求sigma中位数dist！\" class=\"headerlink\" title=\"462.最少移动次数使数组元素相等II 选1+1或-1[LC453] &#x3D;&#x3D;acw104.货仓选址：求sigma中位数dist！\"></a>462.最少移动次数使数组元素相等II 选1+1或-1[LC453] &#x3D;&#x3D;acw104.货仓选址：求sigma中位数dist！</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901113858150.png\" alt=\"image-20210901113858150\"></p>\n<p>sort 预处理前缀和 min(L+R)</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901114211085.png\" alt=\"image-20210901114211085\"></p>\n<p>acw104.货仓选址 绝对值不等式： 证明是中位数！</p>\n<p>证明见：</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/solution/czhong-wei-shu-jian-dan-zheng-ming-by-ke-a2v9/\">https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/solution/czhong-wei-shu-jian-dan-zheng-ming-by-ke-a2v9/</a></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;462.最少移动次数使数组元素相等II 选1+1或-1[LC453] &#x3D;&#x3D;acw104.货仓选址：求sigma中位数dist！\n&#x2F;&#x2F;绝对值不等式||a|-|b||≤|a±b|≤|a|+|b|  sort、res +&#x3D; abs(x - nums[n &#x2F; 2]);\n&#x2F;&#x2F; 证明见：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;minimum-moves-to-equal-array-elements-ii&#x2F;solution&#x2F;czhong-wei-shu-jian-dan-zheng-ming-by-ke-a2v9&#x2F;\nclass Solution &#123;\npublic:\n    int minMoves2(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        sort(nums.begin(), nums.end());&#x2F;&#x2F;\n        int res &#x3D; 0;\n        for (auto x: nums)\n            res +&#x3D; abs(x - nums[n &#x2F; 2]);&#x2F;&#x2F;\n        &#x2F;&#x2F; for (int i &#x3D; 0; i &lt; n; i ++ )\n        &#x2F;&#x2F;     res +&#x3D; abs(nums[i] - nums[i &#x2F; 2]);&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n&#x2F;&#x2F;快选：选一半递归 LC215 O(n)找K大\n</code></pre>\n\n\n\n<h1 id=\"463-岛屿的周长-不用floodfill-x3D-x3D-1循环judge即可：出界-10交界\"><a href=\"#463-岛屿的周长-不用floodfill-x3D-x3D-1循环judge即可：出界-10交界\" class=\"headerlink\" title=\"463.岛屿的周长 不用floodfill &#x3D;&#x3D;1循环judge即可：出界 10交界\"></a>463.岛屿的周长 不用floodfill &#x3D;&#x3D;1循环judge即可：出界 10交界</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;463.岛屿的周长 不用floodfill &#x3D;&#x3D;1循环judge即可：出界 10交界\nclass Solution &#123;\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; grid.size(); i ++ )\n            for (int j &#x3D; 0; j &lt; grid[i].size(); j ++ )\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;\n                    for (int k &#x3D; 0; k &lt; 4; k ++ ) &#123;\n                        int x &#x3D; i + dx[k], y &#x3D; j + dy[k];\n                        if (x &lt; 0 || x &gt;&#x3D; grid.size() || y &lt; 0 || y &gt;&#x3D; grid[0].size())\n                            res ++ ;&#x2F;&#x2F;出界\n                        else if (grid[x][y] &#x3D;&#x3D; 0) res ++ ;&#x2F;&#x2F;10交界\n                    &#125;\n                &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"464-我能赢吗-博弈论-1-n不重选-first-gt-x3D-m-win-sum-i-1-gt-x3D-m-x2F-x2F-当前局wo先胜-dp-x-1-lt-lt-i-x2F-x2F-下一局面必败-wo胜-记忆化搜索\"><a href=\"#464-我能赢吗-博弈论-1-n不重选-first-gt-x3D-m-win-sum-i-1-gt-x3D-m-x2F-x2F-当前局wo先胜-dp-x-1-lt-lt-i-x2F-x2F-下一局面必败-wo胜-记忆化搜索\" class=\"headerlink\" title=\"464.我能赢吗 博弈论 1~n不重选 first&gt;&#x3D;m_win sum + i + 1 &gt;&#x3D; m&#x2F;&#x2F;当前局wo先胜\t!dp(x + (1 &lt;&lt; i))&#x2F;&#x2F;下一局面必败,wo胜 记忆化搜索\"></a>464.我能赢吗 博弈论 1~n不重选 first&gt;&#x3D;m_win sum + i + 1 &gt;&#x3D; m&#x2F;&#x2F;当前局wo先胜\t!dp(x + (1 &lt;&lt; i))&#x2F;&#x2F;下一局面必败,wo胜 记忆化搜索</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;464.我能赢吗 博弈论 1~n不重选 first&gt;&#x3D;m_win\n&#x2F;&#x2F; [存在某种行动，使得行动后对面面临必败局面]，则优先采取该行动。同时，这样的局面被称为[必胜]。\n&#x2F;&#x2F; sum + i + 1 &gt;&#x3D; m&#x2F;&#x2F;当前局wo先胜\t!dp(x + (1 &lt;&lt; i))&#x2F;&#x2F;下一局面必败,wo胜\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; f;\n\tint n, m;\n\n\tint dp(int x) &#123;\n\t\tif (f[x] !&#x3D; -1) return f[x];&#x2F;&#x2F;记忆化搜索\n\t\tint sum &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\t\tif (x &gt;&gt; i &amp; 1)\n\t\t\t\tsum +&#x3D; i + 1;&#x2F;&#x2F;sum&#x3D;state 第0位表示1是否被选过\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n\t\t\tif (x &gt;&gt; i &amp; 1) continue;&#x2F;&#x2F;\n\t\t\tif (sum + i + 1 &gt;&#x3D; m) return f[x] &#x3D; 1;&#x2F;&#x2F;当前局wo先胜\n\t\t\tif (!dp(x + (1 &lt;&lt; i))) return f[x] &#x3D; 1;&#x2F;&#x2F;下一局面必败,wo胜\n\t\t&#125;\n\t\treturn f[x] &#x3D; 0;\n\t&#125;\n\n\tbool canIWin(int _n, int _m) &#123;\n\t\tn &#x3D; _n, m &#x3D; _m;\n\t\tif (n * (n + 1) &#x2F; 2 &lt; m) return false;&#x2F;&#x2F;\n\t\tf.resize(1 &lt;&lt; n, -1);&#x2F;&#x2F;n&lt;20\n\t\treturn dp(0);\n\t&#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"465\"><a href=\"#465\" class=\"headerlink\" title=\"465.\"></a>465.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"466-统计重复个数-码力值难！\"><a href=\"#466-统计重复个数-码力值难！\" class=\"headerlink\" title=\"466.统计重复个数 码力值难！\"></a>466.统计重复个数 码力值难！</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901162019604.png\" alt=\"image-20210901162019604\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;466.统计重复个数 码力值难！\nclass Solution &#123;\npublic:\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) &#123;\n        &#x2F;&#x2F; 存一下匹配完每个s1之后是匹配了s2的第几个字符\n        &#x2F;&#x2F; 这里不对s2.size()取模，是为了能计算一共匹配到了s2的哪个位置\n        vector&lt;int&gt; cnt;&#x2F;&#x2F;s2 cnt[i]&#x3D;k\n        &#x2F;&#x2F; 哈希表快速判断余数有没有出现过\n        unordered_map&lt;int, int&gt; hash;&#x2F;&#x2F;s1 hash[k]&#x3D;i\n        &#x2F;&#x2F; i枚举匹配每个s1，k是在s2里转的指针\n        for (int i &#x3D; 0, k &#x3D; 0; i &lt; n1; i ++ ) &#123;\n            &#x2F;&#x2F; j枚举s1的每个字符\n            for (int j &#x3D; 0; j &lt; s1.size(); j ++ )\n                if (s1[j] &#x3D;&#x3D; s2[k % s2.size()]) &#x2F;&#x2F; 如果匹配上了\n                     k ++ ; &#x2F;&#x2F; 在s2里匹配的指针就往后走!!!\n            cnt.push_back(k); &#x2F;&#x2F; 每次匹配完一个s1，就把s2的指针位置k存下来!!!\n            &#x2F;&#x2F; 如果余数k对应的指针位置之前已经出现过了，就说明出现循环节了\n            if (hash.count(k % s2.size())) &#123;\n                &#x2F;&#x2F; 计算一下循环节里一共有多少个s1，也就是当前和上次是第几个s1之间的差\n                int a &#x3D; i - hash[k % s2.size()];\n                &#x2F;&#x2F; 计算一下循环节里能匹配多少个s2中的字符\n                int b &#x3D; k - cnt[hash[k % s2.size()]];\n                &#x2F;&#x2F; 还剩多少个循环节&#x3D;后面剩下的s1的个数&#x2F;循环节里的s1的个数\n                &#x2F;&#x2F; 剩下的循环节个数还要乘以每个循环节能匹配的s2中的字符数，就是剩下的循环节能匹配s2中的字符数\n                int res &#x3D; (n1 - i - 1) &#x2F; a * b;&#x2F;&#x2F;-1：单独处理最后不完整的循环节\n                &#x2F;&#x2F; 还要把最后不完整的循环节模拟一遍，找出它能匹配多少字符\n                &#x2F;&#x2F; 先遍历不完整循环节的s1个数\n                for (int u &#x3D; 0; u &lt; (n1 - i - 1) % a; u ++ )\n                    &#x2F;&#x2F; 再遍历每个s1\n                    for (int j &#x3D; 0; j &lt; s1.size(); j ++ )\n                        &#x2F;&#x2F; 如果能和s2当前位置匹配\n                        if (s1[j] &#x3D;&#x3D; s2[k % s2.size()])\n                            k ++ ;\n                res +&#x3D; k; &#x2F;&#x2F; 答案加上k，这里k既包含循环节出现之前匹配的字符，也包含最后的不完整的循环节\n                &#x2F;&#x2F; 返回的是匹配的字符数 除以 s2长度 除以n2，也就是能匹配的大S2的数量\n                return res &#x2F; s2.size() &#x2F; n2;\n            &#125;\n            &#x2F;&#x2F; 如果没有出现循环节，标记s2的余数位置k对应的是循环节的第几个s1!!!\n            &#x2F;&#x2F; 这里也是要取余，不然没法判断出现循环节（判断是s2的同一位置）\n            hash[k % s2.size()] &#x3D; i;\n        &#125;\n        &#x2F;&#x2F; 没有出现循环节\n        &#x2F;&#x2F; 如果一个字符都匹配不了，那么cnt是空的，直接返回0\n        if (cnt.empty()) return 0;\n        &#x2F;&#x2F; 返回最后匹配了s2多少个字符，除以s2的长度就是匹配了多少个s2\n        &#x2F;&#x2F; 再除以n2就是匹配了多少个大S2\n        return cnt.back() &#x2F; s2.size() &#x2F; n2;\n    &#125;\n&#125;;\n\n作者：LauZyHou\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;745466&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<h1 id=\"467-环绕字符串中唯一的子字符串-双指针-相连-i-j-以p-i-为起点的连续子串maxLen求和\"><a href=\"#467-环绕字符串中唯一的子字符串-双指针-相连-i-j-以p-i-为起点的连续子串maxLen求和\" class=\"headerlink\" title=\"467.环绕字符串中唯一的子字符串 双指针 相连[i,j) 以p[i]为起点的连续子串maxLen求和\"></a>467.环绕字符串中唯一的子字符串 双指针 相连[i,j) 以p[i]为起点的连续子串maxLen求和</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901165547869.png\" alt=\"image-20210901165547869\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;467.环绕字符串中唯一的子字符串 双指针 相连[i,j) 以p[i]为起点的连续子串maxLen求和\n&#x2F;*\n题目要求去重，观察到子串可以根据开头字母进行分类，最多有 26 个字母，所以最多有 26 类。\n如果我们能得到每个字母开头所能得到子串的最大长度，那么该字母开头贡献的答案子串个数就是这个最大长度。\n所以在第一步拆分的过程中，每拆分出一段 pi，就对 pi 子串中，统计每个字母开头到 pi 末尾的长度，和之前记录的长度取最大值。\n*&#x2F;\n&#x2F;&#x2F;不判重：每段长k 子串数k*(k+1)&#x2F;2\n&#x2F;&#x2F;判重“连续子串”：看 起点、maxlen&#x3D;个数\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;651359&#x2F;\nclass Solution &#123;\npublic:\n    int findSubstringInWraproundString(string p) &#123;\n        unordered_map&lt;char, int&gt; cnt;\n        for (int i &#x3D; 0; i &lt; p.size();) &#123;\n            int j &#x3D; i + 1;\n            while (j &lt; p.size() &amp;&amp; (p[j] - p[j - 1] &#x3D;&#x3D; 1 || p[j] &#x3D;&#x3D; &#39;a&#39; &amp;&amp; p[j - 1] &#x3D;&#x3D; &#39;z&#39;)) j ++ ;&#x2F;&#x2F;相连[i,j)\n            while (i &lt; j) cnt[p[i]] &#x3D; max(cnt[p[i]], j - i), i ++ ;&#x2F;&#x2F;cnt：以p[i]为起点的连续子串maxLen\n        &#125;\n        int res &#x3D; 0;\n        for (auto [a, b]: cnt) res +&#x3D; b;&#x2F;&#x2F;cnt求和\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"468-验证IP地址-模拟-对称简洁函数编码-4-6-split-4-6-check\"><a href=\"#468-验证IP地址-模拟-对称简洁函数编码-4-6-split-4-6-check\" class=\"headerlink\" title=\"468.验证IP地址 模拟 对称简洁函数编码 .4:6 split 4 6 check\"></a>468.验证IP地址 模拟 对称简洁函数编码 .4:6 split 4 6 check</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;468.验证IP地址 模拟 对称简洁函数编码 .4:6\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; split(string ip, char t) &#123;\n        vector&lt;string&gt; items;\n        for (int i &#x3D; 0; i &lt; ip.size(); i ++ ) &#123;\n            int j &#x3D; i;\n            string item;\n            while (ip[j] !&#x3D; t) item +&#x3D; ip[j ++ ];\n            i &#x3D; j;\n            items.push_back(item);\n        &#125;\n        return items;\n    &#125;\n\n    string check_ipv4(string ip) &#123;\n        auto items &#x3D; split(ip + &#39;.&#39;, &#39;.&#39;);&#x2F;&#x2F;+ &#39;.&#39;\n        if (items.size() !&#x3D; 4) return &quot;Neither&quot;;&#x2F;&#x2F;4个\n        for (auto item: items) &#123;&#x2F;&#x2F;str\n            if (item.empty() || item.size() &gt; 3) return &quot;Neither&quot;;&#x2F;&#x2F;0~&quot;255&quot;\n            if (item.size() &gt; 1 &amp;&amp; item[0] &#x3D;&#x3D; &#39;0&#39;) return &quot;Neither&quot;;&#x2F;&#x2F;不可有前导0\n            for (auto c: item)\n                if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) return &quot;Neither&quot;;&#x2F;&#x2F;非数字\n            int t &#x3D; stoi(item);&#x2F;&#x2F;int\n            if (t &gt; 255) return &quot;Neither&quot;;&#x2F;&#x2F;0~&lt;&#x3D;255\n        &#125;\n        return &quot;IPv4&quot;;\n    &#125;\n\n    bool check(char c) &#123;&#x2F;&#x2F;16进制\n        if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) return true;\n        if (c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;f&#39;) return true;\n        if (c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;F&#39;) return true;\n        return false;\n    &#125;\n\n    string check_ipv6(string ip) &#123;\n        auto items &#x3D; split(ip + &#39;:&#39;, &#39;:&#39;);\n        if (items.size() !&#x3D; 8) return &quot;Neither&quot;;&#x2F;&#x2F;8个\n        for (auto item: items) &#123;\n            if (item.empty() || item.size() &gt; 4) return &quot;Neither&quot;;&#x2F;&#x2F;0db8\n            for (auto c: item)\n                if (!check(c)) return &quot;Neither&quot;;\n        &#125;\n        return &quot;IPv6&quot;;\n    &#125;\n\n    string validIPAddress(string ip) &#123;\n        if (ip.find(&#39;.&#39;) !&#x3D; -1 &amp;&amp; ip.find(&#39;:&#39;) !&#x3D; -1) return &quot;Neither&quot;;\n        if (ip.find(&#39;.&#39;) !&#x3D; -1) return check_ipv4(ip);\n        if (ip.find(&#39;:&#39;) !&#x3D; -1) return check_ipv6(ip);\n        return &quot;Neither&quot;;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"469\"><a href=\"#469\" class=\"headerlink\" title=\"469.\"></a>469.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"470-用Rand7-实现Rand10-0-6-7-1-7-gt-40回炉-10\"><a href=\"#470-用Rand7-实现Rand10-0-6-7-1-7-gt-40回炉-10\" class=\"headerlink\" title=\"470.用Rand7()实现Rand10() (0~6)*7+(1~7) &gt;40回炉 %10\"></a>470.用Rand7()实现Rand10() (0~6)*7+(1~7) &gt;40回炉 %10</h1><p>保留概率40&#x2F;49  期望轮数49&#x2F;40  期望次数49*2&#x2F;40&#x3D;49&#x2F;20</p>\n<p>进阶：rand7() 调用次数的 <a href=\"https://en.wikipedia.org/wiki/Expected_value\">期望值</a> 是多少 ? 49&#x2F;20</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901174236718.png\" alt=\"image-20210901174236718\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;470.用Rand7()实现Rand10() (0~6)*7+(1~7) &gt;40回炉 %10\n&#x2F;&#x2F; 两次7就是49，就超过10了，然后把10的整数40以内的数保留下来，按模就知道随机到了哪个数。\n&#x2F;&#x2F; 保留概率40&#x2F;49  期望轮数49&#x2F;40  期望次数49*2&#x2F;40&#x3D;49&#x2F;20\n&#x2F;&#x2F; 进阶：rand7() 调用次数的 [期望值](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expected_value) 是多少 ? 49&#x2F;20\nclass Solution &#123;\npublic:\n    int rand10() &#123;\n        &#x2F;&#x2F; 调用两次rand7生成1-49之间的数\n        int t &#x3D; (rand7() - 1) * 7 + rand7(); &#x2F;&#x2F; 1到49 随机区间里的随机 (0~6)*7+(1~7)\n        &#x2F;&#x2F; 只有1到40保留下来\n        if (t &gt; 40) return rand10();&#x2F;&#x2F;回炉重造~\n        int m &#x3D; t % 10;&#x2F;&#x2F;%10等概率\n        return m &#x3D;&#x3D; 0 ? 10 : m;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n\n\n<h1 id=\"471\"><a href=\"#471\" class=\"headerlink\" title=\"471.\"></a>471.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n\n\n<h1 id=\"TLE？472-连接词-hash-DP-O-n-3-m-向后转移-f-i-lt-0-continue-f-n-gt-1-return-true-acw841-str-hash可优化至O-n-n-m\"><a href=\"#TLE？472-连接词-hash-DP-O-n-3-m-向后转移-f-i-lt-0-continue-f-n-gt-1-return-true-acw841-str-hash可优化至O-n-n-m\" class=\"headerlink\" title=\"TLE？472.连接词 hash+DP:O(n^3*m) 向后转移 f[i]&lt;0 continue; f[n]&gt;1 return true;  acw841.str_hash可优化至O(n*n*m)\"></a>TLE？472.连接词 hash+DP:O(n^3*m) 向后转移 f[i]&lt;0 continue; f[n]&gt;1 return true;  acw841.str_hash可优化至O(n*n*m)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901182707013.png\" alt=\"image-20210901182707013\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;TLE...\nclass Solution &#123;\npublic:\n    unordered_set&lt;string&gt; hash;&#x2F;&#x2F;O(1)判断存在\n\n    bool check(string&amp; word) &#123;&#x2F;&#x2F;是连接词\n        int n &#x3D; word.size();\n        vector&lt;int&gt; f(n + 1, INT_MIN);&#x2F;&#x2F;f[i]:前i个字符最多可拆words\n        f[0] &#x3D; 0;&#x2F;&#x2F;空串由0个字符串组成\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#123;\n            if (f[i] &lt; 0) continue;&#x2F;&#x2F;剪枝1\n            for (int j &#x3D; n - i; j; j -- ) &#123;&#x2F;&#x2F;j逆序：让2尽早剪枝掉\n                if (hash.count(word.substr(i, j))) &#123;\n                    f[i + j] &#x3D; max(f[i + j], f[i] + 1);&#x2F;&#x2F;\n                    if (f[n] &gt; 1) return true;&#x2F;&#x2F;剪枝2：前n个字符最多可拆&gt;1words\n                &#125;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n\n    vector&lt;string&gt; findAllConcatenatedWordsInADict(vector&lt;string&gt;&amp; words) &#123;\n        for (auto&amp; word: words) hash.insert(word);\n        vector&lt;string&gt; res;\n        for (auto&amp; word: words)\n            if (check(word))\n                res.push_back(word);\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"473-火柴拼正方形-LC698-经典dfs剪枝：拼4根等长-扩展：提高课-搜索-acw167-木棒：拼m根等长-蓝书P104！！！-从大到小sort-3根true-失败：回溯st-某条边上的第一根-x2F-最后一根-false-nums-sorted跳过等长\"><a href=\"#473-火柴拼正方形-LC698-经典dfs剪枝：拼4根等长-扩展：提高课-搜索-acw167-木棒：拼m根等长-蓝书P104！！！-从大到小sort-3根true-失败：回溯st-某条边上的第一根-x2F-最后一根-false-nums-sorted跳过等长\" class=\"headerlink\" title=\"473.火柴拼正方形[LC698] 经典dfs剪枝：拼4根等长 扩展：提高课_搜索_acw167.木棒：拼m根等长 蓝书P104！！！ 从大到小sort 3根true 失败：回溯st  某条边上的第一根&#x2F;最后一根 false nums_sorted跳过等长\"></a>473.火柴拼正方形[LC698] 经典dfs剪枝：拼4根等长 扩展：提高课_搜索_acw167.木棒：拼m根等长 蓝书P104！！！ 从大到小sort 3根true 失败：回溯st  某条边上的第一根&#x2F;最后一根 false nums_sorted跳过等长</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210901185500692.png\" alt=\"image-20210901185500692\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;473.火柴拼正方形 经典dfs剪枝：拼4根等长 扩展：提高课_搜索_acw167.木棒：拼m根等长 蓝书P104！！！\n&#x2F;*\n非常经典的dfs剪枝例题\n\n1.从大到小枚举\n2.每条边内部，要求火柴编号递增，也就是按照给定的顺序去枚举\n3.如果当前放某根火柴失败了（也就是在某条边上加了某个火柴之后，剩余的火柴没法凑出目标情况）\n3.1 要跳过相等长度的火柴，因为继续使用相等长度的火柴代替这个火柴的效果也是一模一样的\n3.2 如果失败的时候，是放的某条边上的第一根火柴就失败了，则直接剪掉当前分支\n3.3 如果失败的时候，是放的某条边上的最后一根火柴失败的，也直接剪掉当前分支\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; nums;\n    vector&lt;bool&gt; st;\n    int sum;\n\n    bool dfs(int start, int cur, int cnt) &#123;&#x2F;&#x2F;起点:控制边内部火柴编号递增 cur已拼长 已拼好几根\n        if (cnt &#x3D;&#x3D; 3) return true;&#x2F;&#x2F;3根即可！\n        if (cur &#x3D;&#x3D; sum) return dfs(0, 0, cnt + 1);\n        for (int i &#x3D; start; i &lt; nums.size(); i ++ ) &#123;\n            if (st[i]) continue;&#x2F;&#x2F;\n            if (cur + nums[i] &lt;&#x3D; sum) &#123;\n                st[i] &#x3D; true;\n                if (dfs(i + 1, cur + nums[i], cnt)) return true;&#x2F;&#x2F;枚举+i后\n                st[i] &#x3D; false;&#x2F;&#x2F;回溯\n            &#125;\n            if (!cur || cur + nums[i] &#x3D;&#x3D; sum) return false;&#x2F;&#x2F;3.2 3.3\n            while (i + 1 &lt; nums.size() &amp;&amp; nums[i + 1] &#x3D;&#x3D; nums[i])&#x2F;&#x2F;3.1 nums_sorted 跳过等长\n                i ++ ;\n        &#125;\n        return false;\n    &#125;\n\n    bool makesquare(vector&lt;int&gt;&amp; _nums) &#123;\n        nums &#x3D; _nums;\n        if (nums.empty()) return false;\n        st.resize(nums.size());\n        sum &#x3D; 0;\n        for (auto x: nums) sum +&#x3D; x;\n        if (sum % 4) return false;\n        sum &#x2F;&#x3D; 4;&#x2F;&#x2F;4根等长&#x3D;sum\n        sort(nums.begin(), nums.end(), greater&lt;int&gt;());&#x2F;&#x2F;从大到小\n        return dfs(0, 0, 0);\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"474-一和零-最多m0n1的最大子集size-选择问题本质上-x3D-背包-acw8-二维费用的背包问题-01背包-物品只能用一次-逆序-f-i-1-j-vi-k-mi-wi-maxCnt-wi-x3D-1\"><a href=\"#474-一和零-最多m0n1的最大子集size-选择问题本质上-x3D-背包-acw8-二维费用的背包问题-01背包-物品只能用一次-逆序-f-i-1-j-vi-k-mi-wi-maxCnt-wi-x3D-1\" class=\"headerlink\" title=\"474.一和零 最多m0n1的最大子集size [选择问题本质上&#x3D;背包] acw8.二维费用的背包问题 01背包:物品只能用一次 逆序  f[i-1,j-vi,k-mi]+wi maxCnt:wi&#x3D;1\"></a>474.一和零 最多m0n1的最大子集size [选择问题本质上&#x3D;背包] acw8.二维费用的背包问题 01背包:物品只能用一次 逆序  f[i-1,j-vi,k-mi]+wi maxCnt:wi&#x3D;1</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210902092210998.png\" alt=\"image-20210902092210998\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;474.一和零 最多m0n1的最大子集size [选择问题本质上&#x3D;背包] acw8.二维费用的背包问题\nclass Solution &#123;\npublic:\n    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1));\n        for (auto&amp; str: strs) &#123;\n            int a &#x3D; 0, b &#x3D; 0;\n            for (auto c: str)\n                if (c &#x3D;&#x3D; &#39;0&#39;) a ++ ;\n                else b ++ ;\n            for (int i &#x3D; m; i &gt;&#x3D; a; i -- )&#x2F;&#x2F;01背包:物品只能用一次 逆序\n                for (int j &#x3D; n; j &gt;&#x3D; b; j -- )\n                    f[i][j] &#x3D; max(f[i][j], f[i - a][j - b] + 1);&#x2F;&#x2F;f[i-1,j-vi,k-mi]+wi maxCnt:wi&#x3D;1\n        &#125;\n        return f[m][n];\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"475-供暖器-都能供上的min供暖半径-x3D-O-nlogn-二分-双指针：单调性-房子右移区间右移-j-能覆盖当前房子的最左侧区间-check-都能覆盖到\"><a href=\"#475-供暖器-都能供上的min供暖半径-x3D-O-nlogn-二分-双指针：单调性-房子右移区间右移-j-能覆盖当前房子的最左侧区间-check-都能覆盖到\" class=\"headerlink\" title=\"475.供暖器 都能供上的min供暖半径(&#x3D;) O(nlogn)二分+双指针：单调性[房子右移区间右移] j:能覆盖当前房子的最左侧区间 check:都能覆盖到\"></a>475.供暖器 都能供上的min供暖半径(&#x3D;) O(nlogn)二分+双指针：单调性[房子右移区间右移] j:能覆盖当前房子的最左侧区间 check:都能覆盖到</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210902102933499.png\" alt=\"image-20210902102933499\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;475.供暖器 都能供上的min供暖半径(&#x3D;) O(nlogn)二分+双指针：单调性[房子右移区间右移] j:能覆盖当前房子的最左侧区间\nclass Solution &#123;\npublic:\n    bool check(int mid, vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; houses.size(); i ++ ) &#123;\n            while (j &lt; heaters.size() &amp;&amp; abs(heaters[j] - houses[i]) &gt; mid)\n                j ++ ;&#x2F;&#x2F;j:能覆盖当前房子的最左侧区间\n            if (j &gt;&#x3D; heaters.size()) return false;&#x2F;&#x2F;house[i]覆盖不到\n        &#125;\n        return true;&#x2F;&#x2F;都能覆盖到\n    &#125;\n\n    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n        int l &#x3D; 0, r &#x3D; INT_MAX;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (long long)l + r &gt;&gt; 1;\n            if (check(mid, houses, heaters)) r &#x3D; mid;&#x2F;&#x2F;min_r\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"476-数字的补数-低cnt位-amp-cnt个全1-取反-cnt-x3D-31会溢出int\"><a href=\"#476-数字的补数-低cnt位-amp-cnt个全1-取反-cnt-x3D-31会溢出int\" class=\"headerlink\" title=\"476.数字的补数 低cnt位[&amp;cnt个全1]取反 cnt&#x3D;31会溢出int\"></a>476.数字的补数 低cnt位[&amp;cnt个全1]取反 cnt&#x3D;31会溢出int</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;476.数字的补数\nclass Solution &#123;\npublic:\n    int findComplement(int num) &#123;\n        if (!num) return 1;\n        int cnt &#x3D; 0;\n        for (int x &#x3D; num; x; x &gt;&gt;&#x3D; 1) cnt ++ ;&#x2F;&#x2F;位数\n        return ~num &amp; ((1ll &lt;&lt; cnt) - 1);&#x2F;&#x2F;低cnt位[&amp;cnt个全1]取反 cnt&#x3D;31会溢出int\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"477-汉明距离总和-按位统计-乘法原理：bin第i位-x3D-0cnt-第i位-x3D-1cnt-O-31n\"><a href=\"#477-汉明距离总和-按位统计-乘法原理：bin第i位-x3D-0cnt-第i位-x3D-1cnt-O-31n\" class=\"headerlink\" title=\"477.汉明距离总和 按位统计 乘法原理：bin第i位&#x3D;0cnt * 第i位&#x3D;1cnt O(31n)\"></a>477.汉明距离总和 按位统计 乘法原理：bin第i位&#x3D;0cnt * 第i位&#x3D;1cnt O(31n)</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210902105159000.png\" alt=\"image-20210902105159000\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt;&#x3D; 30; i ++ ) &#123;\n            int x &#x3D; 0, y &#x3D; 0;\n            for (auto c: nums)\n                if (c &gt;&gt; i &amp; 1) y ++ ;\n                else x ++ ;\n            res +&#x3D; x * y;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"478-在圆内随机生成点-框内采-1-1-圆外回炉、极坐标直接采sqrt-r-2-0-1-M-PI-1-0-、-double\"><a href=\"#478-在圆内随机生成点-框内采-1-1-圆外回炉、极坐标直接采sqrt-r-2-0-1-M-PI-1-0-、-double\" class=\"headerlink\" title=\"478.在圆内随机生成点 框内采(-1,1)圆外回炉、极坐标直接采sqrt(r^2 * (0,1)) M_PI  1.0*、(double)\"></a>478.在圆内随机生成点 框内采(-1,1)圆外回炉、极坐标直接采sqrt(r^2 * (0,1)) M_PI  1.0*、(double)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;478.在圆内随机生成点 等概率\n&#x2F;&#x2F; 外切框内圆外:回炉重采样 期望次数：4&#x2F;pi rand()&#x2F;RAND_MAX&#x3D;(0,1) 标准位移(-1,1)\nclass Solution &#123;\npublic:\n    double r, x, y;\n\n    Solution(double radius, double x_center, double y_center) &#123;\n        r &#x3D; radius, x &#x3D; x_center, y &#x3D; y_center;\n    &#125;\n\n    vector&lt;double&gt; randPoint() &#123;\n        double a &#x3D; (double)rand() &#x2F; RAND_MAX * 2 - 1;&#x2F;&#x2F;(-1,1) 或 1.0 *\n        double b &#x3D; (double)rand() &#x2F; RAND_MAX * 2 - 1;\n        if (a * a + b * b &gt; 1) return randPoint();&#x2F;&#x2F;圆外回炉\n        return &#123;x + r * a, y + r * b&#125;;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;23141&#x2F;\n&#x2F;&#x2F;法二：极坐标圆内直接采样\n&#x2F;&#x2F; r&#x3D;1&#x2F;2 面积&#x3D;pi&#x2F;4 与圆心的距离是二维的，需要在 [0, r^2] 内采样然后开方，才能保证是均匀分布。\n&#x2F;&#x2F; 角度直接在 [0, 2 * pi] 内采样就可以。 M_PI！！！\nclass Solution &#123;\nprivate:\n    double r, x, y;\n\npublic:\n    Solution(double radius, double x_center, double y_center) &#123;\n        r &#x3D; radius, x &#x3D; x_center, y &#x3D; y_center;\n    &#125;\n\n    vector&lt;double&gt; randPoint() &#123;\n        double cr &#x3D; r * sqrt(1.0 * rand() &#x2F; RAND_MAX);&#x2F;&#x2F;sqrt(r^2 * (0,1))\n        double angle &#x3D; 2 * M_PI * rand() &#x2F; RAND_MAX;\n        double cx &#x3D; x + cr * cos(angle), cy &#x3D; y + cr * sin(angle);\n        return &#123;cx, cy&#125;;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"479-最大回文数乘积-n位数的-3-3-x3D-9-从大到小枚举回文结果”i-reverse-i”-stoll-枚举较大n位数a-gt-x3D-b-a-a-gt-x3D-ab-x3D-num-for-j-j-gt-x3D-num-num-j-x3D-x3D-0\"><a href=\"#479-最大回文数乘积-n位数的-3-3-x3D-9-从大到小枚举回文结果”i-reverse-i”-stoll-枚举较大n位数a-gt-x3D-b-a-a-gt-x3D-ab-x3D-num-for-j-j-gt-x3D-num-num-j-x3D-x3D-0\" class=\"headerlink\" title=\"479.最大回文数乘积(n位数的) 3*3&#x3D;9 从大到小枚举回文结果”i+reverse_i” stoll 枚举较大n位数a&gt;&#x3D;b a*a&gt;&#x3D;[ab&#x3D;num] for(j*j &gt;&#x3D; num)num%j &#x3D;&#x3D; 0\"></a>479.最大回文数乘积(n位数的) 3*3&#x3D;9 从大到小枚举回文结果”i+reverse_i” stoll 枚举较大n位数a&gt;&#x3D;b a*a&gt;&#x3D;[ab&#x3D;num] for(j*j &gt;&#x3D; num)num%j &#x3D;&#x3D; 0</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;479.最大回文数乘积\n&#x2F;&#x2F; 如果都不大于回文数，除完之后的另一个数一定是比自己大的，那种情况要么已经枚举过了，要么就是另一个数已经不是n位数了。\n&#x2F;&#x2F; n&#x3D;1时候，只有3∗3&#x3D;9。n&#x3D;2到n&#x3D;8的时候，2n位数里一定是有答案的。\nclass Solution &#123;\npublic:\n    int largestPalindrome(int n) &#123;\n        typedef long long LL;\n        if (n &#x3D;&#x3D; 1) return 9;&#x2F;&#x2F;9~&gt;4平方都不是回文数 3*3&#x3D;9 1*9&#x3D;9 i*11&#x3D;&quot;ii&quot;错\n        int maxv &#x3D; pow(10, n) - 1;&#x2F;&#x2F;n个9\n        for (int i &#x3D; maxv; ;i -- ) &#123;&#x2F;&#x2F;从大到小枚举回文结果&quot;i+reverse_i&quot;\n            auto a &#x3D; to_string(i);\n            auto b &#x3D; a;\n            reverse(b.begin(), b.end());\n            auto num &#x3D; stoll(a + b);&#x2F;&#x2F;str-&gt;ll 回文结果num\n            for (LL j &#x3D; maxv; j * j &gt;&#x3D; num; j -- )&#x2F;&#x2F;枚举较大n位数a&gt;&#x3D;b a*a&gt;&#x3D;[ab&#x3D;num] 99*99&lt;9999 &lt;9889 &lt;9779...&gt;&#x3D;9009进loop\n                if (num % j &#x3D;&#x3D; 0)&#x2F;&#x2F; 9009&#x2F;99&#x3D;91\n                    return num % 1337;\n        &#125;\n        return 0;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"480-滑动窗口中位数-动态中位数-O-nlogn-对顶堆-multiset-任意-rbTree-init-get-滑动-x-y调整为r多1-gt-lt-get-median\"><a href=\"#480-滑动窗口中位数-动态中位数-O-nlogn-对顶堆-multiset-任意-rbTree-init-get-滑动-x-y调整为r多1-gt-lt-get-median\" class=\"headerlink\" title=\"480.滑动窗口中位数 +-动态中位数 O(nlogn)对顶堆 multiset:-任意(rbTree) init get 滑动:+x-y调整为r多1-&gt;&lt;- get_median\"></a>480.滑动窗口中位数 +-动态中位数 O(nlogn)对顶堆 multiset:-任意(rbTree) init get 滑动:+x-y调整为r多1-&gt;&lt;- get_median</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;480.滑动窗口中位数 +-动态中位数 O(nlogn)对顶堆 multiset:-任意(rbTree)\nclass Solution &#123;\npublic:\n\tint k;\n\tmultiset&lt;int&gt; left, right;\n\n\tdouble get_medium() &#123;\n\t\tif (k % 2) return *right.begin();\n\t\treturn ((double)*left.rbegin() + *right.begin()) &#x2F; 2;\n\t&#125;\n\n\tvector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int _k) &#123;\n\t\tk &#x3D; _k;\n\t\t&#x2F;&#x2F;init\n\t\tfor (int i &#x3D; 0; i &lt; k; i ++ ) right.insert(nums[i]);\n\t\tfor (int i &#x3D; 0; i &lt; k &#x2F; 2; i ++ ) &#123;&#x2F;&#x2F;r多一\n\t\t\tleft.insert(*right.begin());\n\t\t\tright.erase(right.begin());\n\t\t&#125;\n\t\tvector&lt;double&gt; res;\n\t\tres.push_back(get_medium());&#x2F;&#x2F;get\n\t\tfor (int i &#x3D; k; i &lt; nums.size(); i ++ ) &#123;\n\t\t\tint x &#x3D; nums[i], y &#x3D; nums[i - k];&#x2F;&#x2F;+x-y\n\t\t\tif (x &gt;&#x3D; *right.begin()) right.insert(x);&#x2F;&#x2F;+\n\t\t\telse left.insert(x);\n\t\t\tif (y &gt;&#x3D; *right.begin()) right.erase(right.find(y));&#x2F;&#x2F;- find(y)只删一个y\n\t\t\telse left.erase(left.find(y));\n\t\t\t&#x2F;&#x2F;调整为r多1\n\t\t\twhile (left.size() &gt; right.size()) &#123;&#x2F;&#x2F;l&gt;r:l-&gt;r\n\t\t\t\tright.insert(*left.rbegin());\n\t\t\t\tleft.erase(left.find(*left.rbegin()));&#x2F;&#x2F;\n\t\t\t&#125;\n\t\t\twhile (right.size() &gt; left.size() + 1) &#123;&#x2F;&#x2F;r&gt;l+1:l&lt;-r\n\t\t\t\tleft.insert(*right.begin());\n\t\t\t\tright.erase(right.begin());\n\t\t\t&#125;\n\t\t\tres.push_back(get_medium());&#x2F;&#x2F;get\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"481-神奇的字符串-cnt串-x3D-原串-求前n位cnt1-模拟-k-x3D-3-k-x3D-1、2交替-s-x3D-s-i-个k\"><a href=\"#481-神奇的字符串-cnt串-x3D-原串-求前n位cnt1-模拟-k-x3D-3-k-x3D-1、2交替-s-x3D-s-i-个k\" class=\"headerlink\" title=\"481.神奇的字符串 cnt串&#x3D;原串 求前n位cnt1 模拟: k&#x3D;3-k&#x3D;1、2交替 s+&#x3D;s[i]个k\"></a>481.神奇的字符串 cnt串&#x3D;原串 求前n位cnt1 模拟: k&#x3D;3-k&#x3D;1、2交替 s+&#x3D;s[i]个k</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int magicalString(int n) &#123;\n        string s &#x3D; &quot;122&quot;;\n        for(int i &#x3D; 2, k &#x3D; 1;s.size() &lt; n; i++, k &#x3D; 3 - k) &#123;&#x2F;&#x2F;k&#x3D;3-k 1、2交替\n            for(int j &#x3D; 0; j &lt; s[i] - &#39;0&#39;; j++)&#x2F;&#x2F;s[i]个k\n                s +&#x3D; to_string(k);\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res +&#x3D; s[i] &#x3D;&#x3D; &#39;1&#39;;&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"482-密钥格式化-‘-‘K个一隔-余数在前-if有！-toupper-模拟-先去’-‘-if-res-size-res-x3D-’-‘-x2F-x2F-没余数-res空-不加前导’-‘\"><a href=\"#482-密钥格式化-‘-‘K个一隔-余数在前-if有！-toupper-模拟-先去’-‘-if-res-size-res-x3D-’-‘-x2F-x2F-没余数-res空-不加前导’-‘\" class=\"headerlink\" title=\"482.密钥格式化 ‘-‘K个一隔 余数在前[if有！] toupper 模拟:先去’-‘ if(res.size())res+&#x3D;’-‘;&#x2F;&#x2F;没余数 res空 不加前导’-‘!\"></a>482.密钥格式化 ‘-‘K个一隔 余数在前[if有！] toupper 模拟:先去’-‘ if(res.size())res+&#x3D;’-‘;&#x2F;&#x2F;没余数 res空 不加前导’-‘!</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string licenseKeyFormatting(string S, int K) &#123;\n        string s;\n        for (auto c: S)\n            if (c !&#x3D; &#39;-&#39;)\n                s +&#x3D; c;\n        string res;\n        for (int i &#x3D; 0; i &lt; s.size() % K; i ++ ) res +&#x3D; toupper(s[i]);&#x2F;&#x2F;if %K&gt;0:有余数\n        for (int i &#x3D; s.size() % K; i &lt; s.size();) &#123;\n            if (res.size()) res +&#x3D; &#39;-&#39;;&#x2F;&#x2F;8%4&#x3D;&#x3D;0没余数 res空 不加前导&#39;-&#39;!!!\n            for (int j &#x3D; 0; j &lt; K; j ++ )\n                res +&#x3D; toupper(s[i ++ ]);&#x2F;&#x2F;res才不空 才加前导&#39;-&#39;!!!\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"483-最小好进制-k-gt-x3D-2-全1-二分-gt-数学夹逼-stoll-pow-1-0-x2F-枚举k进制数位数t-t-x3D-log2-n-1-t-gt-x3D-3-0t次-k-1-x3D-k进制t位全1-x3D-r-x3D-x3D-n-特判：t-x3D-2时k-x3D-n-1-因为-n-1-1-x3D-n\"><a href=\"#483-最小好进制-k-gt-x3D-2-全1-二分-gt-数学夹逼-stoll-pow-1-0-x2F-枚举k进制数位数t-t-x3D-log2-n-1-t-gt-x3D-3-0t次-k-1-x3D-k进制t位全1-x3D-r-x3D-x3D-n-特判：t-x3D-2时k-x3D-n-1-因为-n-1-1-x3D-n\" class=\"headerlink\" title=\"483.最小好进制 k&gt;&#x3D;2 全1 二分-&gt;数学夹逼 stoll pow 1.0&#x2F; 枚举k进制数位数t:t&#x3D;log2(n)+1;t &gt;&#x3D; 3   0t次*k+1&#x3D;k进制t位全1&#x3D;r&#x3D;&#x3D;n 特判：t&#x3D;2时k&#x3D;n-1 因为(n-1)+1&#x3D;n\"></a>483.最小好进制 k&gt;&#x3D;2 全1 二分-&gt;数学夹逼 stoll pow 1.0&#x2F; 枚举k进制数位数t:t&#x3D;log2(n)+1;t &gt;&#x3D; 3   0t次*k+1&#x3D;k进制t位全1&#x3D;r&#x3D;&#x3D;n 特判：t&#x3D;2时k&#x3D;n-1 因为(n-1)+1&#x3D;n</h1><p>原数n、进制k&lt;&#x3D;10^18    位数t&lt;&#x3D;60</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210902183301956.png\" alt=\"image-20210902183301956\"></p>\n<p>pow 取整数部分k 回代验证</p>\n<p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210902190520599.png\" alt=\"image-20210902190520599\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;483.最小好进制 k&gt;&#x3D;2 全1 数学夹逼 枚举k进制数位数t\n&#x2F;&#x2F; 原数n、进制k&lt;&#x3D;10^18    位数t&lt;&#x3D;60\n&#x2F;&#x2F; pow 取整数部分 k回代验证\nclass Solution &#123;\npublic:\n    string smallestGoodBase(string number) &#123;\n        typedef long long LL;\n        LL n &#x3D; stoll(number);\n        for (int t &#x3D; log2(n) + 1; t &gt;&#x3D; 3; t -- ) &#123;&#x2F;&#x2F;t &gt;&#x3D; 3\n            LL k &#x3D; pow(n, 1.0 &#x2F; (t - 1));\n            LL r &#x3D; 0;\n            for (int i &#x3D; 0; i &lt; t; i ++ ) r &#x3D; r * k + 1;&#x2F;&#x2F;秦九韶算法：0t次*k+1&#x3D;k进制t位全1\n            if (r &#x3D;&#x3D; n) return to_string(k);\n        &#125;\n        return to_string(n - 1);&#x2F;&#x2F;特判：t&#x3D;2时k&#x3D;n-1 因为(n-1)+1&#x3D;n\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; 同acw628.美丽的数 二分做法\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;2283&#x2F;\n#include &lt;iostream&gt;\nusing namespace std;\ntypedef long long LL;\n\nint check(LL n, LL b, int i)\n&#123;\n    LL res &#x3D; 0;\n    for (int k &#x3D; 0; k &lt; i; k++)\n    &#123;\n        if (res &gt; (n - 1) &#x2F; b) return 1; &#x2F;&#x2F;使用除法，防止数据溢出, res * b + 1会溢出\n        res &#x3D; res * b + 1;\n    &#125;\n    if (res &#x3D;&#x3D; n) return 0;\n\n    return -1;\n&#125;\n\nint main()\n&#123;\n   int T;\n   cin &gt;&gt; T;\n\n   &#x2F;&#x2F;整数n能不能用某一个进制b表示成连续i个1的形式\n   &#x2F;&#x2F;从大到小枚举i\n   &#x2F;&#x2F;二分出进制b，满足进制数大于b的进制表示下，n小于连续i个1，小于b的进制n大于连续i个1表示的数\n   &#x2F;&#x2F;最终答案就是n等于连续i个1表示的数\n   for (int t &#x3D; 1; t &lt;&#x3D; T; t++)\n   &#123;\n        LL n;\n        cin &gt;&gt; n;\n\n        for (int i &#x3D; 63; i &gt; 0; i--) &#x2F;&#x2F;二分枚举\n        &#123;\n            LL l &#x3D; 2, r &#x3D; n;\n            while (l &lt; r)\n            &#123;\n                LL mid &#x3D; (l + r) &#x2F; 2;\n                if (check(n, mid, i) &gt;&#x3D; 0) r &#x3D; mid;\n                else l &#x3D; mid + 1;\n            &#125;\n            if (check(n, l, i) &#x3D;&#x3D; 0) &#x2F;&#x2F;整数n可以在l进制下表示i位1.\n            &#123;\n                printf(&quot;Case #%d: %lld\\n&quot;, t, l);\n                break;\n            &#125;\n        &#125;\n   &#125;\n\n    return 0;\n&#125;\n</code></pre>\n\n\n\n<h1 id=\"484\"><a href=\"#484\" class=\"headerlink\" title=\"484.\"></a>484.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"485-最大连续1的个数-easy双指针\"><a href=\"#485-最大连续1的个数-easy双指针\" class=\"headerlink\" title=\"485.最大连续1的个数 easy双指针\"></a>485.最大连续1的个数 easy双指针</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;485.最大连续1的个数 easy双指针\nclass Solution &#123;\npublic:\n    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            if (nums[i] &#x3D;&#x3D; 0) continue;&#x2F;&#x2F;\n            int j &#x3D; i + 1;\n            while (j &lt; nums.size() &amp;&amp; nums[j] &#x3D;&#x3D; 1) j ++ ;\n            res &#x3D; max(res, j - i);\n            i &#x3D; j;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"486-预测赢家-博弈论-区间DP：循环注意枚举顺序len-i-j-x3D-i-len-1-、记忆化搜索-首尾取-wo先手胜否-f-i-j-余-i-j-wo-ta分数的max差值-f-i-j-x3D-max-f-i-1-j-ai-f-i-j-1-aj-len-x3D-x3D-1-f-ij-x3D-nums-i-return-f-0-n-1-gt-x3D-0\"><a href=\"#486-预测赢家-博弈论-区间DP：循环注意枚举顺序len-i-j-x3D-i-len-1-、记忆化搜索-首尾取-wo先手胜否-f-i-j-余-i-j-wo-ta分数的max差值-f-i-j-x3D-max-f-i-1-j-ai-f-i-j-1-aj-len-x3D-x3D-1-f-ij-x3D-nums-i-return-f-0-n-1-gt-x3D-0\" class=\"headerlink\" title=\"486.预测赢家 博弈论[区间DP：循环注意枚举顺序len i(j&#x3D;i+len-1)、记忆化搜索] 首尾取 wo先手胜否 f(i,j):余(i,j) wo-ta分数的max差值 f(i,j)&#x3D;max(-f(i+1,j)+ai,-f(i,j-1)+aj)  len&#x3D;&#x3D;1:f[ij]&#x3D;nums[i]  return f[0,n-1]&gt;&#x3D;0;\"></a>486.预测赢家 博弈论[区间DP：循环注意枚举顺序len i(j&#x3D;i+len-1)、记忆化搜索] 首尾取 wo先手胜否 f(i,j):余(i,j) wo-ta分数的max差值 f(i,j)&#x3D;max(-f(i+1,j)+ai,-f(i,j-1)+aj)  len&#x3D;&#x3D;1:f[ij]&#x3D;nums[i]  return f[0,n-1]&gt;&#x3D;0;</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210902193924883.png\" alt=\"image-20210902193924883\"></p>\n<p>状态数O(n*n) 转移O(1)</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;486.预测赢家 博弈论[区间DP：循环注意枚举顺序！、记忆化搜索] 首尾取 wo先手胜否\n&#x2F;&#x2F; f(i,j):余(i,j)时wo-ta分数的max差值 f(i,j)&#x3D;max(-f(i+1,j)+ai,-f(i,j-1)+aj)\nclass Solution &#123;\npublic:\n    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(n));\n        for (int len &#x3D; 1; len &lt;&#x3D; n; len ++ ) &#123;&#x2F;&#x2F;len i(j&#x3D;i+len-1)\n            for (int i &#x3D; 0; i + len - 1 &lt; n; i ++ ) &#123;\n                int j &#x3D; i + len - 1;\n                if (len &#x3D;&#x3D; 1) f[i][j] &#x3D; nums[i];&#x2F;&#x2F;\n                else &#123;\n                    f[i][j] &#x3D; max(nums[i] - f[i + 1][j], nums[j] - f[i][j - 1]);\n                &#125;\n            &#125;\n        &#125;\n        return f[0][n - 1] &gt;&#x3D; 0;&#x2F;&#x2F;从小到大递推：分数max差值&gt;&#x3D;0 先手胜\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"487\"><a href=\"#487\" class=\"headerlink\" title=\"487.\"></a>487.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"—488-祖玛游戏-爆搜-剪枝-难-code2…ing\"><a href=\"#—488-祖玛游戏-爆搜-剪枝-难-code2…ing\" class=\"headerlink\" title=\"—488.祖玛游戏 爆搜+剪枝 难 code2…ing\"></a>—488.祖玛游戏 爆搜+剪枝 难 code2…ing</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;488.祖玛游戏\n&#x2F;&#x2F;yxc保证对+优化版：dfs(,get()) f[+&#39; &#39;+hand] ans&#x3D;min &gt;&#x3D;ans 启发式估价函数\nclass Solution &#123;\npublic:\n    unordered_map&lt;string, int&gt; f;&#x2F;&#x2F;到某状态的min_step\n    unordered_map&lt;char, int&gt; cnt;&#x2F;&#x2F;手里的每种球数\n    int ans &#x3D; 6;\n\n    int findMinStep(string board, string hand) &#123;\n        for (auto c: hand) cnt[c] ++ ;\n        f[board] &#x3D; 0;\n        dfs(board, get());\n        if (ans &#x3D;&#x3D; 6) ans &#x3D; -1;&#x2F;&#x2F;ans&lt;&#x3D;5\n        return ans;\n    &#125;\n\n    string clean_up(string s) &#123;&#x2F;&#x2F;不停消连续段\n        bool is_changed &#x3D; true;\n        while (is_changed) &#123;\n            is_changed &#x3D; false;\n            for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n                int j &#x3D; i + 1;\n                while (j &lt; s.size() &amp;&amp; s[j] &#x3D;&#x3D; s[i]) j ++ ;\n                if (j - i &gt;&#x3D; 3) &#123;&#x2F;&#x2F;\n                    s &#x3D; s.substr(0, i) + s.substr(j);\n                    is_changed &#x3D; true;&#x2F;&#x2F;消了才true继续,否则false结束[不停消]\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return s;\n    &#125;\n\n    string get() &#123;\n        string res;\n        for (auto [x, c]: cnt) res +&#x3D; to_string(c);\n        return res;\n    &#125;\n\n    int h(string board) &#123;  &#x2F;&#x2F; +IDA*启发式搜索：至少还需要多少次操作[估价函数]\n        sort(board.begin(), board.end());\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; board.size();) &#123;\n            int j &#x3D; i + 1;\n            while (j &lt; board.size() &amp;&amp; board[j] &#x3D;&#x3D; board[i]) j ++ ;\n            if (j - i + cnt[board[i]] &lt; 3) return 6;&#x2F;&#x2F;无连续 6无解\n            if (j - i &lt;&#x3D; 2) res +&#x3D; 3 - (j - i);&#x2F;&#x2F;必须从手里拿球:至少还需要3-(j-i)步\n            i &#x3D; j;\n        &#125;\n        return res;\n    &#125;\n\n    void dfs(string board, string hand) &#123;\n        if (f[board + &#39; &#39; + hand] + h(board) &gt;&#x3D; ans) return;&#x2F;&#x2F;不能更新min_ans\n        for (auto [x, c]: cnt) &#123;\n            if (c) &#123;\n                -- cnt[x];&#x2F;&#x2F;\n                for (int i &#x3D; 0; i &lt;&#x3D; board.size(); i ++ ) &#123;\n                    auto r &#x3D; clean_up(board.substr(0, i) + x + board.substr(i));&#x2F;&#x2F;插入pos i\n                    auto s &#x3D; r + &#39; &#39; + get();&#x2F;&#x2F;+inhand球数集合\n                    if (f.count(s) &#x3D;&#x3D; 0 || f[s] &gt; f[board + &#39; &#39; + hand] + 1) &#123;\n                        f[s] &#x3D; f[board + &#39; &#39; + hand] + 1;\n                        if (r.empty()) ans &#x3D; min(ans, f[s]);&#x2F;&#x2F;\n                        dfs(r, get());\n                    &#125;\n                &#125;\n                ++ cnt[x];\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;快！\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zuma-game&#x2F;solution&#x2F;zu-ma-you-xi-by-617076674&#x2F;\nclass Solution &#123;\npublic:\n    int res &#x3D; INT_MAX;\n    int findMinStep(string board, string hand) &#123;\n        int cnt[26] &#x3D; &#123;0&#125;;\n        for (char color : hand) &#123;\n            cnt[color - &#39;A&#39;]++;\n        &#125;\n        backTracking(board, cnt, 0);\n        return res &#x3D;&#x3D; INT_MAX ? -1 : res; \n    &#125;\n\n    void backTracking(string &amp;board, int *cnt, int step) &#123;\n        if (step &gt;&#x3D; res) &#123;\n            return;\n        &#125;\n        if (board.empty()) &#123;\n            res &#x3D; min(res, step);\n            return;\n        &#125;\n        &#x2F;&#x2F; 效仿下面的函数removeBalls\n        for (int slow &#x3D; 0, fast &#x3D; 0; fast &lt;&#x3D; board.size(); fast++) &#123;\n            if (fast &lt; board.size() &amp;&amp; board[slow] &#x3D;&#x3D; board[fast]) &#123;\n                continue;\n            &#125;\n            int need &#x3D; 3 - (fast - slow); &#x2F;&#x2F; 在两个连续相同球之后(或者单个球)需要插入的球数\n            if (cnt[board[slow] - &#39;A&#39;] &gt;&#x3D; need) &#123; \n                &#x2F;&#x2F; 删除[slow, fast)段的字符串（str.substr(str.size()) 返回的是空串）\n                string newBoard &#x3D; board.substr(0, slow) + board.substr(fast);\n                removeBalls(newBoard);\n                cnt[board[slow] - &#39;A&#39;] -&#x3D; need;\n                backTracking(newBoard, cnt, step + need);\n                cnt[board[slow] - &#39;A&#39;] +&#x3D; need;\n            &#125;\n            &#x2F;&#x2F; 在两个连续相同球之间插入不同的球\n            if (need &#x3D;&#x3D; 1) &#123;\n                for (char color : &#123;&#39;R&#39;, &#39;Y&#39;, &#39;B&#39;, &#39;G&#39;, &#39;W&#39;&#125;) &#123;\n                    if (color &#x3D;&#x3D; board[slow] || cnt[color - &#39;A&#39;] &#x3D;&#x3D; 0) continue;\n                    string newBoard &#x3D; board;\n                    newBoard.insert(newBoard.begin() + slow + 1, color);\n                    cnt[color - &#39;A&#39;]--;\n                    backTracking(newBoard, cnt, step + 1);\n                    cnt[color - &#39;A&#39;]++;\n                &#125;\n            &#125;\n            slow &#x3D; fast;\n        &#125;\n    &#125;\n\n    void removeBalls(string &amp;board) &#123; \n        for (int slow &#x3D; 0, fast &#x3D; 0; fast &lt;&#x3D; board.size(); fast++) &#123;\n            if (fast &lt; board.size() &amp;&amp; board[slow] &#x3D;&#x3D; board[fast]) &#123;\n                continue;\n            &#125; \n            if (fast - slow &gt;&#x3D; 3) &#123; &#x2F;&#x2F; 删除[slow, fast)段的字符串\n                board.erase(slow, fast - slow);\n                fast &#x3D; 0; &#x2F;&#x2F; 回到字符串开头\n            &#125; \n            slow &#x3D; fast;\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"489\"><a href=\"#489\" class=\"headerlink\" title=\"489.\"></a>489.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"490\"><a href=\"#490\" class=\"headerlink\" title=\"490.\"></a>490.</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\"></code></pre>\n\n\n\n<h1 id=\"491-递增子序列-所有方案：爆搜-判重：枚举当前序列下一个数从哪一个位置开始选-unordered-set-count-insert\"><a href=\"#491-递增子序列-所有方案：爆搜-判重：枚举当前序列下一个数从哪一个位置开始选-unordered-set-count-insert\" class=\"headerlink\" title=\"491.递增子序列 所有方案：爆搜 判重：枚举当前序列下一个数从哪一个位置开始选 unordered_set count insert\"></a>491.递增子序列 所有方案：爆搜 判重：枚举当前序列下一个数从哪一个位置开始选 unordered_set count insert</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 题目要求返回所有方案，那只能直接爆搜。\n&#x2F;&#x2F; 因为这道题目要判重，所以如果直接判断每个数选不选的情况是比较难做的。这里的做法是枚举当前序列下一个数从哪一个位置开始选。\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; ans;\n\tvector&lt;int&gt; path;\n\n\tvector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;\n\t\tdfs(nums, 0);\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(vector&lt;int&gt;&amp; nums, int start) &#123; &#x2F;&#x2F; start表示当前序列下一个数从哪一个位置开始选\n\t\t&#x2F;&#x2F; 这种方式在每个位置都要加答案一下\n\t\tif (path.size() &gt;&#x3D; 2) ans.push_back(path);\n\t\t&#x2F;&#x2F; 如果已经到头了就直接返回\n\t\tif (start &#x3D;&#x3D; nums.size()) return;\n\t\t&#x2F;&#x2F; 枚举一下下一个数是哪个数\n\t\t&#x2F;&#x2F; 判重，在每一层里面开一个哈希表，记录这一层已经尝试过的数字，后面就不用再尝试了\n\t\tunordered_set&lt;int&gt; S;\n\t\tfor (int i &#x3D; start; i &lt; nums.size(); i ++ ) &#123;\n\t\t\tif (path.empty() || path.back() &lt;&#x3D; nums[i]) &#123;\n\t\t\t\tif (S.count(nums[i])) continue;&#x2F;&#x2F;判重:后4可换为前4 已遍历过\n\t\t\t\tS.insert(nums[i]);&#x2F;&#x2F;\n\t\t\t\tpath.push_back(nums[i]);\n\t\t\t\tdfs(nums, i + 1);\n\t\t\t\tpath.pop_back();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n&#x2F;*\n\tvoid dfs(vector&lt;int&gt;&amp; nums, int u) &#123; &#x2F;&#x2F; u:当前位 枚举每一位选不选(不判重！)\n\t\tif(u &#x3D;&#x3D; nums.size()) &#123;\n\t\t\tif (path.size() &gt;&#x3D; 2) ans.push_back(path);\n\t\t\treturn;\n\t\t&#125;\n\t\tdfs(nums, u + 1);&#x2F;&#x2F;cur不选\n\t\tif (path.empty() || path.back() &lt;&#x3D; nums[u]) &#123;&#x2F;&#x2F;能选:单增\n\t\t\tpath.push_back(nums[u]);\n\t\t\tdfs(nums, u + 1);\n\t\t\tpath.pop_back();&#x2F;&#x2F;\n\t\t&#125;\n\t&#125;\n*&#x2F;\n\n&#125;;</code></pre>\n\n\n\n\n\n<h1 id=\"492-构造矩形-L-gt-x3D-W-暴力枚举-O-√n\"><a href=\"#492-构造矩形-L-gt-x3D-W-暴力枚举-O-√n\" class=\"headerlink\" title=\"492.构造矩形 L&gt;&#x3D;W 暴力枚举 O(√n)\"></a>492.构造矩形 L&gt;&#x3D;W 暴力枚举 O(√n)</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;492.构造矩形 暴力枚举 O(√n)\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; constructRectangle(int area) &#123;\n        for (int w &#x3D; sqrt(area); w &gt;&#x3D; 1; w--)&#x2F;&#x2F;w*w&lt;&#x3D;w*L&#x3D;&#x3D;n w&lt;&#x3D;√n\n            if (area % w &#x3D;&#x3D; 0)\n                return &#123;area &#x2F; w, w&#125;;&#x2F;&#x2F;L&gt;&#x3D;W\n\n        return &#123;area, 1&#125;;&#x2F;&#x2F;area是质数\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"493-翻转对-ai-gt-2-aj逆序对cnt-离散化-树状数组-归并排序-分治-递归-ij跨lr-j-mid-1-选小的归并-w-0…覆盖原数组n-l…\"><a href=\"#493-翻转对-ai-gt-2-aj逆序对cnt-离散化-树状数组-归并排序-分治-递归-ij跨lr-j-mid-1-选小的归并-w-0…覆盖原数组n-l…\" class=\"headerlink\" title=\"493.翻转对 ai&gt;2*aj逆序对cnt 离散化+树状数组 !!!归并排序[分治]: 递归 ij跨lr j-(mid+1) 选小的归并 w[0…覆盖原数组n[l…\"></a>493.翻转对 ai&gt;2*aj逆序对cnt 离散化+树状数组 !!!归并排序[分治]: 递归 ij跨lr j-(mid+1) 选小的归并 w[0…覆盖原数组n[l…</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; w;\n\n    int reversePairs(vector&lt;int&gt;&amp; nums) &#123;\n        return merge_sort(nums, 0, nums.size() - 1);\n    &#125;\n\n    int merge_sort(vector&lt;int&gt;&amp; nums, int l, int r) &#123;\n        if (l &gt;&#x3D; r) return 0;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        int res &#x3D; merge_sort(nums, l, mid) + merge_sort(nums, mid + 1, r);&#x2F;&#x2F;递归\n        for (int i &#x3D; l, j &#x3D; mid + 1; i &lt;&#x3D; mid; i ++ ) &#123;&#x2F;&#x2F;ij跨lr\n            while (j &lt;&#x3D; r &amp;&amp; nums[j] * 2ll &lt; nums[i]) j ++ ;\n            res +&#x3D; j - (mid + 1);&#x2F;&#x2F;“逆序对”数\n        &#125;\n        &#x2F;&#x2F;归并排序 选小的归并\n        w.clear();\n        int i &#x3D; l, j &#x3D; mid + 1;\n        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n            if (nums[i] &lt;&#x3D; nums[j]) w.push_back(nums[i ++ ]);\n            else w.push_back(nums[j ++ ]);\n        while (i &lt;&#x3D; mid) w.push_back(nums[i ++ ]);\n        while (j &lt;&#x3D; r) w.push_back(nums[j ++ ]);\n        &#x2F;&#x2F;w[0...覆盖原数组n[l...\n        for (i &#x3D; l, j &#x3D; 0; j &lt; w.size(); i ++, j ++ ) nums[i] &#x3D; w[j];\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n\n\n\n<h1 id=\"494-目标和-号case数-标准DP：f-x3D-前i个总和j的case数-S-x3D-1k-1k-offset-x3D-1k-a-i-1\"><a href=\"#494-目标和-号case数-标准DP：f-x3D-前i个总和j的case数-S-x3D-1k-1k-offset-x3D-1k-a-i-1\" class=\"headerlink\" title=\"494.目标和 +-号case数 标准DP：f&#x3D;前i个总和j的case数 S&#x3D;[-1k,1k] offset&#x3D;1k a[i-1]\"></a>494.目标和 +-号case数 标准DP：f&#x3D;前i个总和j的case数 S&#x3D;[-1k,1k] offset&#x3D;1k a[i-1]</h1><p><img src=\"http://cache.itzy8.top/Leetcode1-500/image-20210904151015386.png\" alt=\"image-20210904151015386\"></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;494.目标和 +-号case数 标准DP：S&#x3D;[-1k,1k] offset&#x3D;1k a[i-1]\nclass Solution &#123;\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; a, int S) &#123;\n        if (S &lt; -1000 || S &gt; 1000) return 0;\n        int n &#x3D; a.size(), Offset &#x3D; 1000;&#x2F;&#x2F;\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2001));\n        f[0][Offset] &#x3D; 1;&#x2F;&#x2F;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; -1000; j &lt;&#x3D; 1000; j ++ ) &#123;\n                if (j - a[i - 1] &gt;&#x3D; -1000)&#x2F;&#x2F;正\n                    f[i][j + Offset] +&#x3D; f[i - 1][j - a[i - 1] + Offset];\n                if (j + a[i - 1] &lt;&#x3D; 1000)&#x2F;&#x2F;负\n                    f[i][j + Offset] +&#x3D; f[i - 1][j + a[i - 1] + Offset];\n            &#125;\n        return f[n][S + Offset];\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"495-提莫攻击-小模拟-总中毒时间-x3D-min-攻击间隔，中毒持续时间-最后一次持续\"><a href=\"#495-提莫攻击-小模拟-总中毒时间-x3D-min-攻击间隔，中毒持续时间-最后一次持续\" class=\"headerlink\" title=\"495.提莫攻击 小模拟 总中毒时间+&#x3D;min(攻击间隔，中毒持续时间)+最后一次持续\"></a>495.提莫攻击 小模拟 总中毒时间+&#x3D;min(攻击间隔，中毒持续时间)+最后一次持续</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int findPoisonedDuration(vector&lt;int&gt;&amp; w, int d) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 1; i &lt; w.size(); i ++ ) res +&#x3D; min(w[i] - w[i - 1], d);&#x2F;&#x2F;min(攻击间隔，持续时间)\n        if (w.size()) res +&#x3D; d;&#x2F;&#x2F;最后一次持续\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"496-下一个更大元素I-1中num在2中pos-右边first-gt-lt-q-升-模板acw830-单调栈\"><a href=\"#496-下一个更大元素I-1中num在2中pos-右边first-gt-lt-q-升-模板acw830-单调栈\" class=\"headerlink\" title=\"496.下一个更大元素I 1中num在2中pos 右边first&gt;[] &lt;-q[升 模板acw830.单调栈\"></a>496.下一个更大元素I 1中num在2中pos 右边first&gt;[] &lt;-q[升 模板acw830.单调栈</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;496.下一个更大元素I 1中num在2中pos 右边first&gt;[] &lt;-q[升 模板acw830.单调栈\n&#x2F;*\n单调栈：\n左边区间第一个比它小的数，第一个比它大的数\n确定这个元素是否是区间最值\n右边区间第一个大于它的值\n到 右边区间第一个大于它的值 的距离\n确定以该元素为最值的最长区间\n*&#x2F;\n&#x2F;&#x2F; 单调队列队首维护区间最值\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        stack&lt;int&gt; stk;\n        vector&lt;int&gt; q(nums2.size());\n        for (int i &#x3D; nums2.size() - 1; i &gt;&#x3D; 0; i -- ) &#123;&#x2F;&#x2F;&lt;- q[升\n            int x &#x3D; nums2[i];\n            while (stk.size() &amp;&amp; x &gt;&#x3D; stk.top()) stk.pop();\n            if (stk.empty()) q[i] &#x3D; -1;&#x2F;&#x2F;\n            else q[i] &#x3D; stk.top();&#x2F;&#x2F;q[i]&#x3D;右first&gt;nums2[i]的x值\n            stk.push(x);\n        &#125;\n\n        unordered_map&lt;int, int&gt; hash;&#x2F;&#x2F;num,pos\n        for (int i &#x3D; 0; i &lt; nums2.size(); i ++ )\n            hash[nums2[i]] &#x3D; i;\n        vector&lt;int&gt; res;\n        for (auto x: nums1)\n            res.push_back(q[hash[x]]);&#x2F;&#x2F;1中num在2中pos 右边first&gt;[]\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"497-非重叠矩形中的随机点-包括v-e-概率与面积成正比-线段长-x3D-S-前缀和预处理O-n-随机-1-back-k二分O-logn-到矩形-lt-x3D-r-1-随机x-y-x-x3D-t0-0-dx-1\"><a href=\"#497-非重叠矩形中的随机点-包括v-e-概率与面积成正比-线段长-x3D-S-前缀和预处理O-n-随机-1-back-k二分O-logn-到矩形-lt-x3D-r-1-随机x-y-x-x3D-t0-0-dx-1\" class=\"headerlink\" title=\"497.非重叠矩形中的随机点 [包括v,e] 概率与面积成正比: 线段长&#x3D;S 前缀和预处理O(n) 随机[1~back]k二分O(logn)到矩形&lt;&#x3D;r-1] 随机x y x&#x3D;t0+[0,dx-1]\"></a>497.非重叠矩形中的随机点 [包括v,e] 概率与面积成正比: 线段长&#x3D;S 前缀和预处理O(n) 随机[1~back]k二分O(logn)到矩形&lt;&#x3D;r-1] 随机x y x&#x3D;t0+[0,dx-1]</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;497.非重叠矩形中的随机点 [包括v,e] 概率与面积成正比\n&#x2F;&#x2F; 线段长&#x3D;S 前缀和预处理O(n) 随机[1~back]k二分O(logn)到矩形&lt;&#x3D;r-1] 随机x y\nclass Solution &#123;\npublic:\n    int n;\n    vector&lt;vector&lt;int&gt;&gt; rects;\n    vector&lt;int&gt; s;\n\n    Solution(vector&lt;vector&lt;int&gt;&gt;&amp; _rects) &#123;&#x2F;&#x2F;init\n        rects &#x3D; _rects;\n        n &#x3D; rects.size();\n        s.push_back(0);&#x2F;&#x2F;前缀和1~\n        for (auto&amp; r: rects) &#123;\n            int dx &#x3D; r[2] - r[0] + 1;\n            int dy &#x3D; r[3] - r[1] + 1;\n            s.push_back(s.back() + dx * dy);&#x2F;&#x2F;线段尾idx：S前缀和\n        &#125;\n    &#125;\n\n    vector&lt;int&gt; pick() &#123;\n        int k &#x3D; rand() % s.back() + 1;&#x2F;&#x2F;[1~back]k\n        int l &#x3D; 1, r &#x3D; n;\n        while (l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if (s[mid] &gt;&#x3D; k) r &#x3D; mid;&#x2F;&#x2F;前mid个矩形S 二分到k所在矩形 &lt;&#x3D;r-1]&lt;-\n            else l &#x3D; mid + 1;\n        &#125;\n        auto&amp; t &#x3D; rects[r - 1];&#x2F;&#x2F;\n        int dx &#x3D; t[2] - t[0] + 1;\n        int dy &#x3D; t[3] - t[1] + 1;\n        return &#123;rand() % dx + t[0], rand() % dy + t[1]&#125;;&#x2F;&#x2F;x&#x3D;t0+[0,dx-1]\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"498-对角线遍历-Z字模拟O-nm-按照每个对角线坐标的和枚举-“上-右边”条斜线i-x3D-行j-列-上-行–-n-1-n-m-2-i-x3D-1-m-i\"><a href=\"#498-对角线遍历-Z字模拟O-nm-按照每个对角线坐标的和枚举-“上-右边”条斜线i-x3D-行j-列-上-行–-n-1-n-m-2-i-x3D-1-m-i\" class=\"headerlink\" title=\"498.对角线遍历 Z字模拟O(nm) 按照每个对角线坐标的和枚举 “上+右边”条斜线i&#x3D;行j+列 上 行– n-1-(n+m-2-i)&#x3D;1-m+i\"></a>498.对角线遍历 Z字模拟O(nm) 按照每个对角线坐标的和枚举 “上+右边”条斜线i&#x3D;行j+列 上 行– n-1-(n+m-2-i)&#x3D;1-m+i</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;498.对角线遍历 Z字模拟O(nm) 按照每个对角线坐标的和i&#x3D;行+列枚举\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; w) &#123;\n        vector&lt;int&gt; res;\n        if (w.empty() || w[0].empty()) return res;\n        int n &#x3D; w.size(), m &#x3D; w[0].size();\n        for (int i &#x3D; 0; i &lt; n + m - 1; i ++ ) &#123;&#x2F;&#x2F;上+右边 条斜线i&#x3D;行+列\n            if (i % 2 &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;上 行--\n                for (int j &#x3D; min(i, n - 1); j &gt;&#x3D; max(0, 1 - m + i); j -- )&#x2F;&#x2F;n-1-(n+m-2-i)&#x3D;1-m+i\n                    res.push_back(w[j][i - j]);&#x2F;&#x2F;行j+列&#x3D;i\n            &#125; else &#123;&#x2F;&#x2F;下 行++\n                for (int j &#x3D; max(0, 1 - m + i); j &lt;&#x3D; min(i, n - 1); j ++ )\n                    res.push_back(w[j][i - j]);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h1 id=\"499\"><a href=\"#499\" class=\"headerlink\" title=\"499.\"></a>499.</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"></code></pre>\n\n\n\n<h1 id=\"500-键盘行-同行打出words-模拟-ch-line-S-insert-hash-tolower-c-sz-x3D-x3D-1\"><a href=\"#500-键盘行-同行打出words-模拟-ch-line-S-insert-hash-tolower-c-sz-x3D-x3D-1\" class=\"headerlink\" title=\"500.键盘行 同行打出words[] 模拟 ch,line S.insert(hash[tolower(c)]) sz&#x3D;&#x3D;1\"></a>500.键盘行 同行打出words[] 模拟 ch,line S.insert(hash[tolower(c)]) sz&#x3D;&#x3D;1</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;500.键盘行 同行打出words[] 模拟 ch,line S.insert(hash[tolower(c)]) sz&#x3D;&#x3D;1\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123;\n        string line[3] &#x3D; &#123;\n            &quot;qwertyuiop&quot;,\n            &quot;asdfghjkl&quot;,\n            &quot;zxcvbnm&quot;\n        &#125;;\n        unordered_map&lt;char, int&gt; hash;&#x2F;&#x2F; ch,line\n        for (int i &#x3D; 0; i &lt; 3; i ++ )\n            for (auto&amp; c: line[i])\n                hash[c] &#x3D; i;\n\n        vector&lt;string&gt; res;\n        for (auto&amp; word: words) &#123;\n            set&lt;int&gt; S;&#x2F;&#x2F;word lines集合\n            for (auto c: word) S.insert(hash[tolower(c)]);&#x2F;&#x2F;tolower\n            if (S.size() &#x3D;&#x3D; 1) res.push_back(word);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n","text":"1.两数之和 找sum的2个idx:2sum (枚举Si,find之前是否存在target-Si [hash表 O(1)search])平衡树：map O(logn) –&gt; hash表：unordered_map O(1):target-Si hash[val] &#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"447k","symbolsTime":"6:46"},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E6%89%BEsum%E7%9A%842%E4%B8%AAidx-2sum-%E6%9E%9A%E4%B8%BESi-find%E4%B9%8B%E5%89%8D%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8target-Si-hash%E8%A1%A8-O-1-search\"><span class=\"toc-text\">1.两数之和 找sum的2个idx:2sum (枚举Si,find之前是否存在target-Si [hash表 O(1)search])</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E7%AB%96%E5%BC%8F%E5%8A%A0%E6%B3%95%EF%BC%88%E9%93%BE%E8%A1%A8-%E4%B8%AA%E5%8D%81%E7%99%BE-%E7%A7%A6%E4%B9%9D%E9%9F%B6%EF%BC%89\"><span class=\"toc-text\">2.两数相加 竖式加法（链表-个十百 秦九韶）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF-%E8%BF%9E%E7%BB%AD-%E5%AD%90%E4%B8%B2-%E5%8F%8C%E6%8C%87%E9%92%88-hash%E8%A1%A8\"><span class=\"toc-text\">3 无重复字符的最长(连续)子串:双指针+hash表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-%E5%A5%97%EF%BC%88%E6%89%BEK-th%EF%BC%89\"><span class=\"toc-text\">4. 寻找两个正序数组的中位数 套（找K-th）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E6%9E%9A%E4%B8%BE%E4%B8%AD%E7%82%B9i%EF%BC%8C%E6%9B%B4%E6%96%B0max-res-O-n-n\"><span class=\"toc-text\">5. 最长回文子串 (枚举中点i，更新max_res: O(n*n))</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2-%E6%89%BE%E8%A7%84%E5%BE%8B\"><span class=\"toc-text\">6. Z字形变换(找规律)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-%E7%A7%A6%E4%B9%9D%E9%9F%B6res-x3D-res-10-x-10-x-x2F-x3D-10\"><span class=\"toc-text\">7.整数反转(秦九韶res &#x3D; res * 10 + x % 10; x &#x2F;&#x3D; 10;)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8-atoi\"><span class=\"toc-text\">8.atoi</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9-%E5%9B%9E%E6%96%87%E6%95%B0-to-string-if-x-lt-0-x-amp-amp-x-10-x3D-x3D-0-return-false-if-s-x3D-x3D-x-s-x3D-x3D-x-x2F-10-return-true\"><span class=\"toc-text\">9.回文数(to_string,if (x &lt; 0 || x &amp;&amp; x % 10 &#x3D;&#x3D; 0) return false; if (s &#x3D;&#x3D; x || s &#x3D;&#x3D; x &#x2F; 10) return true;)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10-DP%EF%BC%9A-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D-%E2%80%9C-%E2%80%9D%E4%BD%9C%E4%B8%BA%E6%95%B4%E4%BD%93\"><span class=\"toc-text\">10.DP：.*正则匹配 “-*”作为整体</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E7%A7%BB%E5%8A%A8%E8%BE%83%E7%9F%AD%E8%BE%B9%EF%BC%8C%E5%88%A4%E6%96%AD%E9%9D%A2%E7%A7%AF%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%AF%E8%83%BD%E5%A2%9E%E5%A4%A7\"><span class=\"toc-text\">11.盛最多水的容器(移动较短边，判断面积是否有可能增大)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#12-int2%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">12. int2罗马数字</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%972int-hash-lt-gt\"><span class=\"toc-text\">13. 罗马数字2int hash+ [&lt;-,&gt;+]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#14-LCP-for-auto-amp-str-strs-%E8%83%BD%E5%8C%B9%E9%85%8D%E4%B8%8A%E6%89%8D%E6%8E%A5c\"><span class=\"toc-text\">14. LCP [for(auto&amp; str : strs)  能匹配上才接c]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#15-18-3sum-sort-dedup-min-3sum-gt-x3D-0-if-x3D-x3D-0-x2F-%E5%8F%8C%E6%8C%87%E9%92%88\"><span class=\"toc-text\">15[~18]. 3sum (sort+dedup+min(3sum&gt;&#x3D;0) + if&#x3D;&#x3D;0 &#x2F; 双指针)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">16. 最接近的三数之和</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#17-2-abc-9%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-%E7%88%86%E6%90%9Cdfs\"><span class=\"toc-text\">17. 2(abc)~9字母组合     爆搜dfs</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#18-4sum-lt-%E2%80%93-3sum-0%E2%80%93-gt-target\"><span class=\"toc-text\">18. 4sum &lt;– 3sum , 0–&gt;target</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">19. 删除链表的倒数第 N 个节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-stk\"><span class=\"toc-text\">20.有效的括号 stk</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-2%E8%B7%AF%E5%BD%92%E5%B9%B6\"><span class=\"toc-text\">21. 合并两个有序链表 2路归并</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#22-%E7%94%9F%E6%88%90n%E4%B8%AA%E5%90%88%E6%B3%95-seq-%E9%80%92%E5%BD%92\"><span class=\"toc-text\">22.生成n个合法()seq  递归</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%81%EF%BC%81%EF%BC%8123-K%E8%B7%AF%E5%BD%92%E5%B9%B6-heap-%EF%BC%88148%EF%BC%89\"><span class=\"toc-text\">！！！23. K路归并  heap  （148）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-pab\"><span class=\"toc-text\">24. 两两交换链表中的节点 pab</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#25-lt-24-K-swap\"><span class=\"toc-text\">25.&lt;-24  K_swap</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%E5%8E%9F%E5%9C%B0%E8%A6%86%E7%9B%96\"><span class=\"toc-text\">26. 删除排序数组中的重复项：双指针原地覆盖</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#27-lt-26-val%E5%8E%BB%E9%87%8D\"><span class=\"toc-text\">27.&lt;-26   val去重</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#28-%E5%AE%9E%E7%8E%B0-strStr-%E8%A3%B8KMP\"><span class=\"toc-text\">28. 实现 strStr()    裸KMP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-only-qmi%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%92%E5%88%86\"><span class=\"toc-text\">29. 两数相除(only+-  qmi二进制划分)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89-%E7%AD%89%E9%95%BF-%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2-%E5%88%86%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2-hash%E8%A1%A8-tot-wd-%E5%90%8CLC76\"><span class=\"toc-text\">30.串联所有[等长]单词的子串(分组+滑动窗口 2*hash表:tot wd 同LC76~)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#31-nextPermutation-13-542-gt-14-235\"><span class=\"toc-text\">31. nextPermutation 13,542-&gt;14,235</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-%E5%88%86%E6%AE%B5%E5%90%88%E6%B3%95stk-x2F-cnt-x2F-DP\"><span class=\"toc-text\">32. 最长有效括号 分段合法stk&#x2F;cnt&#x2F;DP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84H-%E4%BA%8C%E5%88%86l-x3D-mid-%E2%80%94-gt-1-%E4%B8%A4%E6%AE%B5%E6%80%A7-gt-x3D-nums-0-1%E6%AE%B5%E6%BB%A1%E8%B6%B3-2%E6%AE%B5%E4%B8%8D%E6%BB%A1%E8%B6%B3\"><span class=\"toc-text\">33.搜索旋转排序数组H (二分l &#x3D; mid;—-&gt;+1 两段性:&gt;&#x3D; nums[0] 1段满足 2段不满足)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AEM-gt-%E4%BA%8C%E5%88%86-lt-%E4%BA%8C%E5%88%86-gt-x3D-x2F-lt-x3D-target\"><span class=\"toc-text\">34.在排序数组中查找元素的第一个和最后一个位置M(-&gt;二分&lt;-二分   &gt;&#x3D;&#x2F;&lt;&#x3D;target)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#35-%E6%90%9C%E7%B4%A2%E3%80%90%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%E3%80%91E-gt-x3D-target%E7%9A%84min-first-lt-%E4%BA%8C%E5%88%86-r-x3D-size\"><span class=\"toc-text\">35. 搜索【插入位置】E(&gt;&#x3D; target的min(first)  &lt;-二分  r&#x3D;size)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%E5%88%A4%E6%96%AD%E8%A1%8C-x2F-%E5%88%97-x2F-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E4%B8%8D%E5%90%8C-%E6%A8%A1%E6%8B%9F%E9%A2%98-bool-st-9-ij-x2F-ji-x2F-ij-xy\"><span class=\"toc-text\">36.有效的数独 判断行&#x2F;列&#x2F;九宫格不同 ( 模拟题 bool st[9];      ij &#x2F; ji &#x2F; ij+xy)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#37-%E8%A7%A3%E6%95%B0%E7%8B%AC-r-c-cell-dfs-%E5%9B%9E%E6%BA%AF\"><span class=\"toc-text\">37.解数独 (r c  cell dfs 回溯)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97-%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E9%A1%B9%E9%83%BD%E6%98%AF%E5%AF%B9%E5%89%8D%E4%B8%80%E9%A1%B9%E7%9A%84%E6%8F%8F%E8%BF%B0%E3%80%82-cnt-num-%E5%8F%8C%E6%8C%87%E9%92%88-j-k\"><span class=\"toc-text\">38.外观数列(序列中的每一项都是对前一项的描述。 cnt+num) 双指针[j,k)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E9%80%92%E5%BD%92-%E6%97%A0%E9%99%90%E5%88%B6%E9%87%8D%E5%A4%8D%E8%A2%AB%E9%80%89\"><span class=\"toc-text\">39.组合总和(递归   无限制重复被选)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-%E4%B8%AA%E6%95%B0%E9%99%90%E5%88%B6cnt-%E6%9C%89%E9%87%8D%E5%A4%8D%EF%BC%8Csort\"><span class=\"toc-text\">40.组合总和II +个数限制cnt(有重复，sort)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-unordered-set\"><span class=\"toc-text\">41. 缺失的第一个正数  unordered_set</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-%E5%8D%95%E8%B0%83%E6%A0%88%E5%8F%98%E5%BD%A2-%E9%9A%BE\"><span class=\"toc-text\">42. 接雨水(单调栈变形 难)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98-str%E7%AB%96%E5%BC%8F%E4%B9%98-x2F-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A8%A1%E6%9D%BF-C-i-j-x3D-A-i-B-j-%E7%BB%9F%E4%B8%80%E8%BF%9B%E4%BD%8D-%E5%8E%BB%E9%A6%960\"><span class=\"toc-text\">43 字符串相乘(str竖式乘&#x2F;高精度乘法的基本模板)     C[i + j] +&#x3D; A[i] * B[j];  统一进位 去首0</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%9444-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D-10-%E7%AE%80%E5%8C%96%E7%89%88-DP-%E5%8D%95%E7%8B%AC%E5%8C%B9%E4%B8%80%E5%88%87\"><span class=\"toc-text\">—44.通配符匹配(10.简化版)DP *单独匹一切</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%8C%96%E9%80%86DP-last-%E6%9C%80%E6%97%A9%E7%9A%84%E5%8F%AF%E4%BB%A5%E4%B8%80%E6%AD%A5%E5%88%B0%E8%BE%BE-i-%E7%9A%84%E4%BD%8D%E7%BD%AE-%E9%9A%8F%E7%9D%80-i-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E\"><span class=\"toc-text\">45.跳跃游戏 II  贪心(优化逆DP) last:最早的可以一步到达 i 的位置, 随着 i 单调递增</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#46-%E5%85%A8%E6%8E%92%E5%88%97\"><span class=\"toc-text\">46.全排列</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#47-%E5%85%A8%E6%8E%92%E5%88%97II%EF%BC%88%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%EF%BC%89\"><span class=\"toc-text\">47. 全排列II（有重复数字）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F\"><span class=\"toc-text\">48.旋转图像</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-sort%E6%AD%A3%E5%BA%8F%E5%81%9Ahash%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">49.字母异位词分组(sort正序做hash索引)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#50-Pow-x-n-qmi%E6%A8%A1%E6%9D%BF-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E5%88%86\"><span class=\"toc-text\">50.Pow(x, n) qmi模板  二进制拆分</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#51-N%E7%9A%87%E5%90%8E%EF%BC%9Acase-col-i-dg-u-i-n-udg-u-i-O-n-n\"><span class=\"toc-text\">51.N皇后：case  col[i] dg[u - i + n] udg[u + i]  O(n*n!)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#52-N%E7%9A%87%E5%90%8EII-case%E6%95%B0-if-u-x3D-x3D-n-return-1-res-x3D-dfs-u-1-O-n\"><span class=\"toc-text\">52.N皇后II   case数   if(u &#x3D;&#x3D; n) return 1;  res +&#x3D; dfs(u + 1);  O(n!)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94-why-yxc%E7%89%88%E5%88%86%E6%B2%BB%E6%98%AFO-n-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-DP%EF%BC%9Af-i-x3D-max-nums-i-nums-i-f-i-1-%E3%80%81-%E5%88%86%E6%B2%BB%EF%BC%9A-lt-%E2%80%93mid%E2%80%93-gt-lmax-%E5%8C%BA%E9%97%B4%E5%89%8D%E4%B8%80%E5%8D%8A%E7%9A%84%E6%9C%80%E5%A4%A7%E5%90%8E%E7%BC%80%E5%92%8C-rmax-%E5%8C%BA%E9%97%B4%E5%90%8E%E4%B8%80%E5%8D%8A%E7%9A%84%E6%9C%80%E5%A4%A7%E5%89%8D%E7%BC%80%E5%92%8C\"><span class=\"toc-text\">—[why? yxc版分治是O(n)?] 53.最大子序和  DP：f[i] &#x3D; max(nums[i], nums[i] + f[i-1])、 分治：&lt;–mid–&gt; lmax:区间前一半的最大后缀和  rmax:区间后一半的最大前缀和</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">54. 螺旋矩阵</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-%E8%83%BD%E5%90%A6%E8%B7%B3%E5%88%B0%EF%BC%8845-II-%E5%88%B0%E6%9C%80%E5%90%8Emin-steps%EF%BC%89\"><span class=\"toc-text\">55. 跳跃游戏:能否跳到（45 II:到最后min steps）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4\"><span class=\"toc-text\">56.合并区间</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4-%E6%A8%A1%E6%8B%9F\"><span class=\"toc-text\">57.插入区间 模拟</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6-stringstream%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88\"><span class=\"toc-text\">58.最后一个单词的长度(stringstream、双指针)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II-%E5%90%8C54\"><span class=\"toc-text\">59. 螺旋矩阵 II 同54</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97-if-fact-lt-k-k-x3D-fact\"><span class=\"toc-text\">60. 第k个排列   if(fact &lt; k) k -&#x3D; fact;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8-rotateRight-k-k-x3D-n-tail-p\"><span class=\"toc-text\">61.旋转链表:rotateRight_k       k %&#x3D; n;  tail  p</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#62-64-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-m-n-%E5%B7%A6%E4%B8%8A-gt-%E5%8F%B3%E4%B8%8B\"><span class=\"toc-text\">62.[-64]不同路径    m*n 左上-&gt;右下</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II-%E9%BB%98%E8%AE%A4f-%E6%9C%89%E9%9A%9C%E7%A2%8D%E7%89%A91-x3D-0\"><span class=\"toc-text\">63.不同路径II  默认f[有障碍物1]&#x3D;0</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-weight-%E7%AE%97min\"><span class=\"toc-text\">64.最小路径和  +weight 算min</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#65-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97-bool-s2f-%E6%A8%A1%E6%8B%9F-e-NeN-e-e\"><span class=\"toc-text\">65.有效数字     bool:s2f 模拟 +- .e NeN e. e+-</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#66-array-%E5%8A%A0%E4%B8%80-reverse-%E8%BF%9B%E4%BD%8Dt\"><span class=\"toc-text\">66.(array)加一  reverse 进位t</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C-reverse-t-%E5%90%8C66\"><span class=\"toc-text\">67.二进制求和 reverse t 同66</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#68-%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90\"><span class=\"toc-text\">68.文本左右对齐</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-sqrt-floor-%E4%BA%8C%E5%88%86%E6%89%BE-max-y-2-lt-x3D-x\"><span class=\"toc-text\">69.x 的平方根 sqrt+floor  二分找 max_y^2 &lt;&#x3D; x</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-%E6%AF%8F%E6%AC%A1%E4%BD%A0%E5%8F%AF%E4%BB%A5%E7%88%AC1%E6%88%962%E4%B8%AA%E5%8F%B0%E9%98%B6-fib-0-x3D-1-fib-1-x3D-1-fib-2-x3D-2-%E6%BB%9A%E5%8A%A8abc-while-%E2%80%93n-x2F-x2F-loop-n-1\"><span class=\"toc-text\">70.爬楼梯 每次你可以爬1或2个台阶 fib(0)&#x3D;1 fib(1)&#x3D;1 fib(2)&#x3D;2 滚动abc while(–n) { &#x2F;&#x2F; loop:n-1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84-%E6%A8%A1%E6%8B%9Fstk%E6%93%8D%E4%BD%9C-back-string-res-pop-back-x3D-clear\"><span class=\"toc-text\">71 简化路径 模拟stk操作  back() string res.pop_back(); +&#x3D; clear</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BBa-gt-b-steps-DP-%E4%B8%89%E7%B1%BB\"><span class=\"toc-text\">72.编辑距离a-&gt;b_steps  DP 三类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6%EF%BC%9A%E5%8E%9F%E5%9C%B0-0%E5%B0%B1%E5%88%B7\"><span class=\"toc-text\">73.矩阵置零：原地  0就刷</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-1D%E4%BA%8C%E5%88%86-%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2-mid-x2F-m-mid-m\"><span class=\"toc-text\">74. 搜索二维矩阵 1D二分+坐标变换(mid&#x2F;m,mid%m)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98-00111222-cnt-ijk\"><span class=\"toc-text\">75.颜色分类 荷兰国旗问题 00111222 cnt ijk</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%9F76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-%E5%8F%8C%E6%8C%87%E9%92%88-2-hash%E8%A1%A8-%E5%90%8CLC30\"><span class=\"toc-text\">？76.最小覆盖子串(双指针 2*hash表 同LC30~)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#77-%E7%BB%84%E5%90%88-%E6%9E%9A%E4%B8%BEn%E5%8F%96k%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%A1%88-%E7%88%86%E6%90%9C\"><span class=\"toc-text\">77.组合  枚举n取k的所有方案 爆搜</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#78-%E5%AD%90%E9%9B%86-%E4%B8%8D%E9%87%8D%E5%A4%8Dnums%E7%9A%84%E5%B9%82%E9%9B%86-n%E4%BD%8D01bin%E8%A1%A8%E7%A4%BAcase-1%E5%B0%B1%E9%80%89\"><span class=\"toc-text\">78.子集  不重复nums的幂集 n位01bin表示case 1就选</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-%E7%88%86%E6%90%9C%E8%B5%B7%E7%82%B9-4%E6%96%B9%E5%90%91-%E4%B8%8D%E5%9B%9E%E5%A4%B4%E2%80%99-%E2%80%99%E5%9B%9E%E6%BA%AF\"><span class=\"toc-text\">79.单词搜索  爆搜起点+4方向 不回头’.’回溯</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II-LC16-x3D-x3D-%E6%9C%80%E5%A4%9A%E4%BF%9D%E7%95%992%E4%B8%AA-k-lt-2-nums-k-1-x3D-x-nums-k-2-x3D-x\"><span class=\"toc-text\">80. 删除排序数组中的重复项 II (LC16)  &#x3D;&#x3D;最多保留2个 (k &lt; 2 || nums[k - 1] !&#x3D; x || nums[k - 2] !&#x3D; x)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II-33-%E6%9C%89%E9%87%8D%E5%A4%8D-%E4%BA%8C%E5%88%86-while-R-gt-x3D-0-amp-amp-nums-R-x3D-x3D-nums-0-R%E2%80%93-x2F-x2F-%E4%BF%9D%E6%8C%81%E4%B8%A4%E6%AE%B5%E6%80%A7\"><span class=\"toc-text\">81.搜索旋转排序数组 II(33)有重复    二分  while(R &gt;&#x3D; 0 &amp;&amp; nums[R] &#x3D;&#x3D; nums[0]) R–; &#x2F;&#x2F;保持两段性</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II-83%E5%8D%87%E5%BA%8F-%E5%88%A0%E5%AE%8C-%E5%8F%8C%E6%8C%87%E9%92%88\"><span class=\"toc-text\">82.删除排序链表中的重复元素 II 83升序 删完 双指针</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-82%E5%8D%87%E5%BA%8F-%E7%95%99%E4%B8%80%E4%B8%AA\"><span class=\"toc-text\">83.删除排序链表中的重复元素 82升序 留一个</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-%E5%8D%95%E8%B0%83%E6%A0%88-heights-cur-i-st-top-1\"><span class=\"toc-text\">84.柱状图中最大的矩形 单调栈 heights[cur] * (i - st.top() - 1)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#85-%E5%85%A81%E7%9A%84-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2-%E7%9A%84%E9%9D%A2%E7%A7%AF-84-gt-2D-DP\"><span class=\"toc-text\">85.(全1的)最大矩形(的面积) 84-&gt;2D+DP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#86-L-lt-x%E3%80%81R-gt-x3D-x-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8-qsort%E9%83%A8%E5%88%86-%E7%A8%B3%E5%AE%9A%E6%8E%92lhlt\"><span class=\"toc-text\">86. (L&lt;x、R&gt;&#x3D;x)分隔链表  qsort部分 稳定排lhlt</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%9487-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8C%BA%E9%97%B4dp\"><span class=\"toc-text\">—87.扰乱字符串  区间dp!!!</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-mergesort-1-2%E2%80%93-gt-1-%E5%8F%8D%E9%81%8D%E5%8E%86%E4%B8%8D%E8%A6%86%E7%9B%96-k-x3D-n-m-1\"><span class=\"toc-text\">88.合并两个有序数组  mergesort  1+2–&gt;1 反遍历不覆盖 k&#x3D;n+m-1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#89-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81-%E8%BD%B4%E5%AF%B9%E7%A7%B0-%E5%90%8E%E8%A1%A50-x2F-1-%E5%89%8D%E8%A1%A5-i-i-gt-gt-1\"><span class=\"toc-text\">89.格雷编码 轴对称 后补0&#x2F;1     前补:i^i&gt;&gt;1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%9490-lt-78-%E5%AD%90%E9%9B%86II-%E9%87%8D%E5%A4%8D-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85-hash%E8%A1%A8-x2F-%E7%94%A8-sort-dfs%E7%88%86%E6%90%9C-%E6%94%BE%E5%85%A50-k-u%E4%B8%AAnums-u\"><span class=\"toc-text\">—90&lt;-78.子集II 重复 多重背包  hash表&#x2F;(用)sort+dfs爆搜+放入0~k-u个nums[u]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95-DP\"><span class=\"toc-text\">91.解码方法 DP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II%EF%BC%88LR-x3D-1-n-%E5%8C%BA%E9%97%B4%EF%BC%89a-b-lt-c-lt-d%E3%80%90206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%91\"><span class=\"toc-text\">92.反转链表II（LR&#x3D;1~n 区间）a b&lt;-c&lt;-d【206.反转链表】</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-dfs-0255-%E6%97%A0%E5%89%8D%E5%AF%BC0-%E2%80%98-%E2%80%99-u-bit-k-03-%E8%BF%87%E9%95%BF\"><span class=\"toc-text\">93.复原IP地址 dfs 0255 无前导0  ‘.’ u:bit k:03  过长</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">94.二叉树的中序遍历</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II-dfs-new-root\"><span class=\"toc-text\">95.不同的二叉搜索树 II dfs    new root</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E6%B1%82case%E6%95%B0-DP-1-j-i\"><span class=\"toc-text\">96.不同的二叉搜索树  求case数 DP [1,(j),i]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2-DP\"><span class=\"toc-text\">97. 交错字符串 DP ||</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-0F-x2F-1T-m-M-x3D-x3D-LNR%E6%98%AF%E5%90%A6%E6%9C%89%E5%BA%8F\"><span class=\"toc-text\">98. 验证二叉搜索树{0F&#x2F;1T,m,M} &#x3D;&#x3D; LNR是否有序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-S-x3D-O-1-%EF%BC%9AMorris%E9%81%8D%E5%8E%86%E3%80%90%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91-%E9%81%8D%E5%8E%86%E6%97%B6%E8%AE%B0%E5%BD%95%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%81swap%EF%BC%81\"><span class=\"toc-text\">99. 恢复二叉搜索树 S&#x3D;O(1)：Morris遍历【线索二叉树】 遍历时记录这两个数！swap！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91-p-amp-amp-q%E3%80%81-p-q-x3D-%E9%80%92%E5%BD%92\"><span class=\"toc-text\">100.相同的树 !p &amp;&amp; !q、!p || !q ||!&#x3D; 递归</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%80%92%E5%BD%92\"><span class=\"toc-text\">101. 对称二叉树 递归</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-bfs-q-push-q-front\"><span class=\"toc-text\">102.二叉树的层序遍历 bfs q.push  q.front()</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#103-lt-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2S%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-cnt\"><span class=\"toc-text\">103&lt;-102.二叉树的锯齿形S层次遍历 cnt</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-M-x3D-M-L-R-1\"><span class=\"toc-text\">104.二叉树的最大深度 M&#x3D;M(L,R)+1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%89%91%E6%8C%8718\"><span class=\"toc-text\">105.从前序与中序遍历序列构造二叉树    剑指18</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">106.从中序与后序遍历序列构造二叉树</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#107-lt-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A-reverse-res\"><span class=\"toc-text\">107&lt;-102.二叉树的层次遍历 II 自底向上 reverse(res)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-%E4%B8%AD%E5%BA%8F-%E8%BD%AC%E6%8D%A2%E4%B8%BA-%E9%AB%98%E5%BA%A6%E5%B9%B3%E8%A1%A1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\"><span class=\"toc-text\">108.将有序数组(中序)转换为(高度平衡)二叉搜索树</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2-%E9%AB%98%E5%BA%A6%E5%B9%B3%E8%A1%A1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E5%8F%96%E4%B8%AD%E7%82%B9O-n-cur-x3D-%E4%B8%AD%E7%82%B9-1-cur-gt-next-x3D-NULL\"><span class=\"toc-text\">109.有序链表转换(高度平衡)二叉搜索树 取中点O(n)  cur&#x3D;中点-1   cur-&gt;next &#x3D; NULL;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91judge-abs-gt-1-F-%E9%80%92%E5%BD%92h-x3D-max-lh-rh-1\"><span class=\"toc-text\">110.平衡二叉树judge  abs&gt;1:F   递归h&#x3D;max(lh, rh) + 1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6\"><span class=\"toc-text\">111.二叉树的最小深度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-tree-%E5%AD%98%E5%9C%A8%E5%90%A6-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%EF%BC%81\"><span class=\"toc-text\">112.路径总和 tree 存在否 自上而下！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII-%E8%AE%B0%E5%BD%95%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">113.路径总和II 记录所有路径</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-%E6%96%9C%E5%90%91%E5%8F%B3NLR-%E5%B7%A6%E5%AD%90%E6%A0%91%E5%8F%B3%E9%93%BE%E6%8F%92%E5%85%A5%E5%8F%B3%E8%8A%82%E7%82%B9%E5%A4%84\"><span class=\"toc-text\">114.二叉树展开为链表 斜向右NLR 左子树右链插入右节点处</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-S%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AAT-DP-%E2%89%A0%E4%B8%8D%E8%83%BD%E5%8C%B9-x3D-%E5%8F%AF%E4%BB%A5%E5%8C%B9-%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8C%B9\"><span class=\"toc-text\">115.不同的子序列 S有多少个T DP ≠不能匹 &#x3D;可以匹,也可以不匹</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%BB%A1\"><span class=\"toc-text\">116.填充每个节点的下一个右侧节点指针 完美二叉树(满)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II-%E9%9D%9E%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9h-x3D-t-gt-next-x3D-%E6%AF%8F%E5%B1%82first-cur\"><span class=\"toc-text\">117.填充每个节点的下一个右侧节点指针II 非完美二叉树 虚拟头结点h&#x3D;t -&gt;next&#x3D;每层first:cur</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-1-k\"><span class=\"toc-text\">118.杨辉三角 1~k</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II-k-S-x3D-O-k-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-%E3%80%902%E3%80%91-amp-1\"><span class=\"toc-text\">119.杨辉三角II  k  S&#x3D;O(k) 滚动数组 【2】 &amp;1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E5%90%91%E4%B8%8ADP\"><span class=\"toc-text\">120.三角形最小路径和 向上DP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-max-prices-i-minp\"><span class=\"toc-text\">121.买卖股票的最佳时机  max(prices[i] - minp)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII-%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E4%B8%8D%E9%87%8D%E5%8F%A0-%E4%BA%A4%E6%98%93%E6%8B%86%E4%B8%BA%E5%8D%95%E5%A4%A9%EF%BC%81-max%E5%88%A9-x3D-%E5%88%A9%E6%97%A5%E4%B9%8B%E5%92%8C-x3D-max-0-prices-i-1-prices-i\"><span class=\"toc-text\">122.买卖股票的最佳时机II 多次买卖不重叠 交易拆为单天！ max利&#x3D;+利日之和   +&#x3D;max(0, prices[i + 1] - prices[i])</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III-%E6%9C%80%E5%A4%9A2%E6%AC%A1-%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3\"><span class=\"toc-text\">—123.买卖股票的最佳时机 III 最多2次 前后缀分解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-LC543-%E6%A0%91%E5%BD%A2DP%E6%B3%95-%E6%9E%9A%E4%B8%BELCA%E4%B8%BA%E5%89%B2%E7%82%B9-ans-x3D-max-LNR-%E7%82%B9val-return-root-max-l-r\"><span class=\"toc-text\">124.二叉树中的最大路径和[LC543] 树形DP法 枚举LCA为割点 ans&#x3D;max(LNR);点val return root+max(l,r);</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%8F%8C%E6%8C%87%E9%92%88-%E5%8F%AA%E8%80%83%E8%99%91%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BF%BD%E7%95%A5%E5%AD%97%E6%AF%8D%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E3%80%82\"><span class=\"toc-text\">125.验证回文串 双指针 只考虑字母和数字字符，可以忽略字母的大小写。</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99II-01%E6%9C%80%E7%9F%AD%E8%B7%AF-bfs-dfs-%E8%BE%93%E5%87%BA%E6%96%B9%E6%A1%88-S-count-st\"><span class=\"toc-text\">—126.单词接龙II 01最短路 bfs+dfs 输出方案 S.count(st)???</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-min-node-step\"><span class=\"toc-text\">127.单词接龙 min_node_step</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-%E6%89%BE%E5%87%BA%E3%80%90%E6%95%B0%E5%AD%97%E8%BF%9E%E7%BB%AD%E7%9A%84%E6%9C%80%E9%95%BF%E3%80%91%E5%BA%8F%E5%88%97-%E5%8F%AF%E4%B9%B1%E5%BA%8F-%E4%B8%8D%E8%BF%9E%E7%BB%AD-T-x3D-O-n-hash-%E6%9E%9A%E4%B8%BE%E6%AE%B5%E9%A6%96-%E5%A4%9A%E6%AC%A1%E6%AE%B5%E9%A6%96%E5%8E%BB%E9%87%8DS-erase-x-max-x-y\"><span class=\"toc-text\">—128.最长连续序列 找出【数字连续的最长】序列(可乱序 不连续) T&#x3D;O(n) hash 枚举段首 多次段首去重S.erase(x);  max[x,y]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#129-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C-%E8%B7%AF%E5%BE%84-1-gt-2-%E4%BB%A3%E8%A1%A8%E6%95%B0%E5%AD%97-12-%E6%95%B0%E5%AD%97%E6%80%BB%E5%92%8C-x3D-12-13-x3D-25\"><span class=\"toc-text\">129.求根节点到叶节点数字之和 路径 1-&gt;2 代表数字 12 数字总和 &#x3D; 12 + 13 &#x3D; 25</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F-%E5%9B%B4%E6%A3%8B-%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%EF%BC%9Amark%E8%BE%B9%E7%95%8CO%EF%BC%8C%E5%85%B6%E4%BD%99%E2%80%93-gt-X-floodfill-dfs%E6%A0%87%E8%AE%B0%E8%BF%9E%E9%80%9A%E5%9D%97\"><span class=\"toc-text\">130.被围绕的区域 围棋 逆向思维：mark边界O，其余–&gt;X  floodfill_dfs标记连通块</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-DP%E9%80%92%E6%8E%A8%E9%A2%84%E5%A4%84%E7%90%86-%E7%88%86%E6%90%9C-O-n-2-2-n\"><span class=\"toc-text\">131.分割回文串 DP递推预处理+爆搜:O(n^2 + 2^n)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#132-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-II-DP-min-cut-x3D-min-part-1-if-g-ji-f-i-x3D-min-f-i-f-j-1-1\"><span class=\"toc-text\">132.分割回文串 II DP min_cut&#x3D;min_part-1 if(g_ji) f[i] &#x3D; min(f[i], f[j - 1] + 1);</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#133-%E5%85%8B%E9%9A%86%E5%9B%BE-%E6%97%A0%E7%9B%B8%E8%BF%9E%E9%80%9A%E5%9B%BE-%E6%B7%B1%E5%85%8B%E9%9A%86-%E9%82%BB%E6%8E%A5%E5%88%97%E8%A1%A8-d-gt-neighbors-push-back-hash-ver\"><span class=\"toc-text\">133.克隆图 无相连通图 深克隆 邻接列表              d-&gt;neighbors.push_back(hash[ver]);</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94134-%E5%8A%A0%E6%B2%B9%E7%AB%99-O-n-%E6%9C%AC%E8%B4%A8%EF%BC%9A%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%9F%BA%E4%BA%8E%EF%BC%9A%E6%9E%9A%E4%B8%BE-%E4%BC%98%E5%8C%96-O-n-n-gt-O-n\"><span class=\"toc-text\">—134.加油站 O(n) 本质：贪心，基于：枚举+优化 O(n*n)-&gt;O(n)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-gt-x3D-1-x2F-person-min-sum-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2DP-f-x-x3D-max-dp-x-1-1-dp-x-1-1\"><span class=\"toc-text\">—135.分发糖果  &gt;&#x3D;1&#x2F;person min_sum 记忆化搜索DP:f[x]&#x3D;max(dp(x-1)+1,dp(x+1)+1)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-%E5%85%B6%E4%BD%992%E6%AC%A1-x-x-x3D-0-0-x-x3D-x-%E5%85%A8%E5%BC%82%E6%88%96\"><span class=\"toc-text\">136.只出现一次的数字 其余2次 x^x&#x3D;0 0^x&#x3D;x 全异或</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94%EF%BC%81%EF%BC%81%EF%BC%81137-gt-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II-%E5%85%B6%E4%BD%993%E6%AC%A1-O-1-DFA%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B-x2F-%E8%8B%A5%E7%AC%ACi%E4%BD%8D1%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E4%B8%BA3k-1%EF%BC%8C%E5%88%99%E8%AF%B4%E6%98%8E%E7%AD%94%E6%A1%88%E5%9C%A8%E7%AC%ACi%E4%BD%8D%E6%98%AF1\"><span class=\"toc-text\">—！！！137-&gt;260.只出现一次的数字II 其余3次 O(1) DFA有限状态机模型 &#x2F; 若第i位1出现次数为3k+1，则说明答案在第i位是1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#138-lt-133-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8-%E2%80%9C%E5%B0%8F%E5%BC%9F%E2%80%9D%E7%9C%81hash%E8%A1%A8-S-x3D-O-1\"><span class=\"toc-text\">138&lt;-133.复制带随机指针的链表 “小弟”省hash表:S&#x3D;O(1)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-%E7%B1%BB%E4%BC%BC132%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2II-DP%E4%BC%98%E5%8C%96-str-hash-f-j-x3D-f-i-amp-amp-s-i-1-j-%E5%9C%A8hash%E9%87%8C%E5%87%BA%E7%8E%B0%E8%BF%87\"><span class=\"toc-text\">—139.单词拆分(类似132分割回文串II) DP优化+str_hash f[j] &#x3D; f[i] &amp;&amp; s[i+1~j]在hash里出现过</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II-cases-DP%E9%A2%84%E5%A4%84%E7%90%86f-dfs%E9%80%92%E5%BD%92\"><span class=\"toc-text\">—140.单词拆分II cases:DP预处理f+dfs递归</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-S-x3D-O-1-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-%E5%85%88next%E5%90%8E%E5%88%A4%E7%A9%BA\"><span class=\"toc-text\">141.环形链表 S&#x3D;O(1)快慢指针 先next后判空</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-%E7%8E%AF%E5%85%A5%E5%8F%A3-%E7%9B%B8%E9%81%87%E7%82%B9c-x%E6%AD%A5-x3D-%E5%85%A5%E5%8F%A3b\"><span class=\"toc-text\">142.环形链表II 环入口 相遇点c+x步&#x3D;入口b</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%82%B9-%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F-%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8-T-x3D-O-n-S-x3D-O-1-%E7%BB%86%E8%8A%82%E5%A4%9A%EF%BC%81\"><span class=\"toc-text\">—143.重排链表 找链表中点!+ 链表逆序 + 合并链表 T&#x3D;O(n) S&#x3D;O(1) 细节多！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-94-%E4%B8%AD%E5%BA%8F\"><span class=\"toc-text\">144. 二叉树的前序遍历 (94.中序)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-LRN-x3D-x3D-NRL-reverse-%E3%80%90%E8%BD%AC%E5%8C%96%EF%BC%81%E3%80%91%E4%B8%BA144%E9%A2%98\"><span class=\"toc-text\">145. 二叉树的后序遍历   LRN&#x3D;&#x3D;NRL+reverse 【转化！】为144题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94%EF%BC%81%EF%BC%81%EF%BC%81146-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-T-x3D-O-1-remove-insert%E5%88%B0L-gt-right-%E5%8F%8C%E9%93%BE%E8%A1%A8-hash\"><span class=\"toc-text\">—！！！146. LRU 缓存机制 T&#x3D;O(1)remove+insert到L-&gt;right:双链表+hash</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-cur-x2F-p-x2F-cur-gt-next-first-gt-p-O-n-2\"><span class=\"toc-text\">147.对链表进行插入排序 cur&#x2F;p&#x2F;cur-&gt;next(first &gt;p) O(n^2)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E3%80%90%E6%9C%80%E9%9A%BE%E9%93%BE%E8%A1%A8%E9%A2%98%E3%80%91-T-x3D-O-nlogn-S-x3D-O-1-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%BD%92%E5%B9%B6mergesort-%E7%BB%86%E8%8A%82%E5%A4%9A-%EF%BC%8823%EF%BC%89\"><span class=\"toc-text\">148.排序链表【最难链表题】 T&#x3D;O(nlogn) S&#x3D;O(1):自底向上归并mergesort 细节多 （23）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0-%E6%9E%9A%E4%B8%BE%E4%B8%AD%E5%BF%83%E7%82%B9-%E9%87%8D%E5%8F%A0%E4%B8%AD%E5%BF%83%E7%82%B9-%E5%9E%82%E7%BA%BF-LD\"><span class=\"toc-text\">149.直线上最多的点数 枚举中心点 重叠中心点 垂线 LD</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-stk-stoi-s-atoi-t-c-str\"><span class=\"toc-text\">150.逆波兰表达式求值 stk stoi(s)   atoi(t.c_str())</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D-%E7%BF%BB%E8%AF%8D-%E7%BF%BB%E4%B8%B2-S-x3D-O-1-%E5%8E%9F%E5%9C%B0cover\"><span class=\"toc-text\">151.翻转字符串里的单词 翻词+翻串 S&#x3D;O(1)原地cover</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-%E8%B4%9F-%E8%B4%9F-x3D-%E6%AD%A3-T-x3D-O-n-S-x3D-O-1-%E6%BB%9A%E5%8A%A8%EF%BC%81M-f-fa-m-g-ga\"><span class=\"toc-text\">152.乘积最大子数组 负*负&#x3D;正 T&#x3D;O(n) S&#x3D;O(1)滚动！M:f-fa m:g-ga</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%8833%E7%AE%80%E5%8C%96-%E4%BA%8C%E5%88%86%E4%B8%80%E6%AC%A1%EF%BC%89\"><span class=\"toc-text\">153.寻找旋转排序数组中的最小值（33简化 二分一次）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII%EF%BC%8833-81%EF%BC%89%E6%9C%89%E9%87%8D%E5%A4%8D%EF%BC%9A%E5%88%A0%E5%B0%BE\"><span class=\"toc-text\">154.寻找旋转排序数组中的最小值II（33 81）有重复：删尾</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#155-%E6%9C%80%E5%B0%8F%E6%A0%88\"><span class=\"toc-text\">155.最小栈</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#156\"><span class=\"toc-text\">156.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#157\"><span class=\"toc-text\">157.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#158\"><span class=\"toc-text\">158.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#159\"><span class=\"toc-text\">159.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-%E4%BA%A4%E6%8D%A2%E9%81%8D%E5%8E%86%E5%88%B0%E7%9B%B8%E9%81%87-x3D-first%E4%BA%A4%E7%82%B9\"><span class=\"toc-text\">160.相交链表 交换遍历到相遇&#x3D;first交点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Locked%EF%BC%81161-One-Edit-Distance-%E5%88%A4%E6%96%AD%E5%AE%83%E4%BB%AC%E7%9A%84%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E6%98%AF%E5%90%A6%E4%B8%BA1%E3%80%82\"><span class=\"toc-text\">Locked！161. One Edit Distance 判断它们的编辑距离是否为1。</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">162.寻找峰值 二分</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#163\"><span class=\"toc-text\">163.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#164-sorted-%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D-T-x3D-S-x3D-O-n-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%88%86%E6%A1%B6%E6%B3%95\"><span class=\"toc-text\">164.(sorted)最大间距 T&#x3D;S&#x3D;O(n) 基数排序 分桶法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7-3-1-2-gt-3-1-return-1-x2F-1-x2F-0\"><span class=\"toc-text\">165.比较版本号 3.1.2 &gt; 3.1  return 1&#x2F;-1&#x2F;0</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0-%E6%9C%89%E9%99%90-%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF-%E5%BE%AA%E7%8E%AF%E8%8A%82-INT-MIN-x2F-1-x3D-INT-MAX-1-int%E8%B6%8A%E7%95%8C-LL%EF%BC%81\"><span class=\"toc-text\">166.分数到小数(有限+无限循环:(循环节)) INT_MIN&#x2F;-1&#x3D;INT_MAX+1 int越界 LL！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">167.两数之和 II - 输入有序数组</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0-27-gt-AA-k%E4%BD%8D%E7%9A%8426%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E7%AC%AC%E5%87%A0%E4%B8%AA%EF%BC%88%E5%90%8C%E7%90%86%EF%BC%9A12-int2%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%EF%BC%89\"><span class=\"toc-text\">168.Excel表列名称  27-&gt;AA k位的26进制数的第几个（同理：12.int2罗马数字）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%81%EF%BC%81%EF%BC%81169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-%E7%BB%8F%E5%85%B8-%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95-%E6%B1%82%E4%BC%97%E6%95%B0-%E9%82%93P342\"><span class=\"toc-text\">！！！169.多数元素[经典] 摩尔投票算法  求众数 邓P342</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#170\"><span class=\"toc-text\">170.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#171-Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7-%E5%8F%8D168\"><span class=\"toc-text\">171.Excel表列序号(反168)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6-%E7%BB%8F%E5%85%B8%E6%95%B0%E8%AE%BA-1-N%E6%AF%8F%E4%B8%AA%E6%95%B0%E5%8C%85%E5%90%AB5%E7%9A%84%E4%B8%AA%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">172.阶乘后的零  经典数论  1~N每个数包含5的个数之和</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#173\"><span class=\"toc-text\">173.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-DP-%E7%B1%BB%E4%BC%BC62%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-63\"><span class=\"toc-text\">174.地下城游戏(DP 类似62不同路径 63)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#175\"><span class=\"toc-text\">175.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#176\"><span class=\"toc-text\">176.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#177\"><span class=\"toc-text\">177.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#178\"><span class=\"toc-text\">178.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%81%EF%BC%81%EF%BC%81179-%E6%9C%80%E5%A4%A7%E6%95%B0-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E9%87%8D%E5%AE%9A%E4%B9%89sort%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0a-b-gt-b-a%EF%BC%88%E8%AF%81%E6%98%8E%E8%AF%A5%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%8F%AF%E6%AF%94%E8%BE%83%EF%BC%9A%E4%BC%A0%E9%80%92%E6%80%A7%EF%BC%81%EF%BC%89-%E5%8E%BB%E9%99%A4%E5%89%8D%E5%AF%BC0%EF%BC%8C%E5%85%A80%E7%95%99%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA0\"><span class=\"toc-text\">！！！179.最大数 匿名函数重定义sort比较函数a + b &gt; b + a（证明该定义方式可比较：传递性！） 去除前导0，全0留最后一个0</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#180\"><span class=\"toc-text\">180.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#181\"><span class=\"toc-text\">181.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#182\"><span class=\"toc-text\">182.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#183\"><span class=\"toc-text\">183.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#184\"><span class=\"toc-text\">184.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#185\"><span class=\"toc-text\">185.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#186\"><span class=\"toc-text\">186.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97-%E6%A8%A1%E6%8B%9F%EF%BC%9A%E9%95%BF%E5%BA%A6%E4%B8%BA10%EF%BC%8C%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E6%AC%A1\"><span class=\"toc-text\">187.重复的DNA序列 模拟：长度为10，出现次数超过一次</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV-%E5%9B%B0%E9%9A%BE-k%E6%AC%A1\"><span class=\"toc-text\">188.买卖股票的最佳时机 IV  困难 k次</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84-%E5%8E%9F%E5%9C%B0\"><span class=\"toc-text\">189.旋转数组 原地</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D-%E4%BD%8D%E8%BF%90%E7%AE%97-res-x3D-res-lt-lt-1-n-gt-gt-i-amp-1\"><span class=\"toc-text\">190.颠倒二进制位 位运算 res &#x3D; (res &lt;&lt; 1) + (n &gt;&gt; i &amp; 1);</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0-lowbit-x-x3D-x-amp-x\"><span class=\"toc-text\">191.位1的个数 lowbit(x)&#x3D;x&amp;-x</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#192\"><span class=\"toc-text\">192.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#193\"><span class=\"toc-text\">193.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#194\"><span class=\"toc-text\">194.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#195\"><span class=\"toc-text\">195.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#196\"><span class=\"toc-text\">196.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#197\"><span class=\"toc-text\">197.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-DP-%E4%B8%8D%E7%9B%B8%E9%82%BBmax\"><span class=\"toc-text\">198.打家劫舍 DP 不相邻max</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-BFS\"><span class=\"toc-text\">199. 二叉树的右视图  BFS</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-floodfill%E6%A8%A1%E6%9D%BF%E9%A2%98%EF%BC%881%E7%9A%84%E3%80%90%E9%9D%9E%E6%96%9C%E3%80%91%E8%BF%9E%E9%80%9A%E5%9D%97%E6%95%B0%EF%BC%89\"><span class=\"toc-text\">200.岛屿数量 floodfill模板题（1的【非斜】连通块数）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E-xx-%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-xxx00%E2%80%A60\"><span class=\"toc-text\">201. 数字范围按位与    xx(公共前缀)xxx00…0</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#202-%E5%BF%AB%E4%B9%90%E6%95%B0%EF%BC%88141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%89-1%E6%AD%A52%E6%AD%A5%EF%BC%8C%E7%9B%B8%E9%81%87%E5%88%99%E6%9C%89%E7%8E%AF\"><span class=\"toc-text\">202.快乐数（141 环形链表） 1步2步，相遇则有环</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">203. 移除链表元素</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0-lt-n-%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0O-n-%E6%A8%A1%E6%9D%BF%E9%A2%98-if-i-primes-j-x3D-x3D-0-break\"><span class=\"toc-text\">204.计数质数(&lt;n)   线性筛素数O(n)模板题      if (i % primes[j] &#x3D;&#x3D; 0) break;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2-%E5%8D%95%E5%B0%84%EF%BC%9A%E4%B8%80%E4%B8%80%E5%AF%B9%E5%BA%94-unordered-map-s-lt-%E2%80%93-gt-t\"><span class=\"toc-text\">205.同构字符串 字符替换(单射：一一对应) unordered_map:s&lt;–&gt;t</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-gt-92-II%E8%BF%AD%E4%BB%A3-%E7%BB%8F%E5%85%B8\"><span class=\"toc-text\">206.反转链表-&gt;92.II迭代    经典</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-d-u-x3D-0%E5%85%A5%E9%98%9F\"><span class=\"toc-text\">207.课程表 拓扑排序:d[u]&#x3D;0入队</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#208-%E5%AE%9E%E7%8E%B0Trie%EF%BC%88%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%89%E5%AD%97%E5%85%B8%E6%A0%91\"><span class=\"toc-text\">208.实现Trie（前缀树）字典树</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-%E6%AD%A3%E6%95%B4%E6%95%B0-gt-x3D-sum-%E5%8F%8C%E6%8C%87%E9%92%88-while-sum-nums-j-gt-x3D-s-sum-x3D-nums-j-x2F-x2F-%E6%8E%A2%E5%9C%B0%E9%9B%B7-j\"><span class=\"toc-text\">209.长度最小的子数组(正整数 &gt;&#x3D;sum) 双指针  while(sum - nums[j] &gt;&#x3D; s) sum -&#x3D; nums[j++];&#x2F;&#x2F;探地雷 j</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#210-%E8%AF%BE%E7%A8%8B%E8%A1%A8II-%E5%AD%98%E5%8D%95case\"><span class=\"toc-text\">210.课程表II 存单case</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-%E6%AD%A3%E5%88%99-%E4%B8%8D%E9%87%8D%E5%A4%8D-%E6%90%9CTrie-O-nL-lt-lt-26-k\"><span class=\"toc-text\">211.添加与搜索单词-数据结构设计 [正则 ]不重复 搜Trie:O(nL) &lt;&lt; 26^k</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II-DFS-Trie-words%E5%88%97%E8%A1%A8-%E5%85%A5Trie%EF%BC%8C%E5%AD%98idx%E7%94%A8%E4%BA%8E%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">212.单词搜索II(DFS+Trie)  words列表 入Trie，存idx用于输出</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII%EF%BC%88198%EF%BC%89-%E5%9B%B4%E6%88%90%E4%B8%80%E5%9C%88\"><span class=\"toc-text\">213.打家劫舍II（198） 围成一圈~</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#214-%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%89%8D%E9%9D%A2%E6%B7%BB%E5%8A%A0%E5%AD%97%E7%AC%A6%E5%B0%86%E5%85%B6%E8%BD%AC%E6%8D%A2-x3D-x3D-find%E5%8E%9F%E4%B8%B2max-prefix%E5%9B%9E%E6%96%87%E4%B8%B2idx-x3D-x3D-%E6%9E%84%E9%80%A0%E4%B8%B2KMP-next-end-%E9%9A%BE\"><span class=\"toc-text\">214.最短回文串 前面添加字符将其转换 &#x3D;&#x3D;find原串max_prefix回文串idx &#x3D;&#x3D; 构造串KMP_next[end]    难</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%95%E4%BA%8Ccode%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%81-%E2%80%94215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-BFPRT%EF%BC%9A%E5%BF%AB%E6%8E%92%E6%9C%80%E5%9D%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%99%8D%E8%87%B3O-n-medianOfMedians-%E6%89%BE%E5%B1%85%E4%B8%AD-pivot%EF%BC%81%EF%BC%81%EF%BC%81\"><span class=\"toc-text\">!!![法二code有问题！]—215.数组中的第K个最大元素  BFPRT：快排最坏复杂度降至O(n) medianOfMedians 找居中 pivot！！！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95BFPRT%E5%B0%8F%E4%B8%93%E9%A2%98\"><span class=\"toc-text\">—线性查找算法BFPRT小专题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII\"><span class=\"toc-text\">216.组合总和III</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-unordered-set-count-insert\"><span class=\"toc-text\">217.存在重复元素 unordered_set count insert</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#218-%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98-%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%B1%82%E8%BD%AE%E5%BB%93-%E7%BB%86%E8%8A%82%E5%A4%AA%E5%A4%9A\"><span class=\"toc-text\">218.天际线问题 扫描线求轮廓 细节太多</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II-%E9%97%B4%E9%9A%94-lt-x3D-k-unordered-map-val-idx\"><span class=\"toc-text\">219.存在重复元素 II(间隔&lt;&#x3D;k) unordered_map{val, idx}</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III-val%E5%B7%AE-lt-x3D-t-idx%E5%B7%AE-lt-x3D-k-multiset-S-x2F-x2F-%E6%94%AF%E6%8C%81%E9%87%8D%E5%A4%8D-1e18-LL%E5%93%A8%E5%85%B5\"><span class=\"toc-text\">220.存在重复元素 III val差&lt;&#x3D;t, idx差&lt;&#x3D;k  multiset S;&#x2F;&#x2F;支持重复 +-1e18 LL哨兵</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2-%E5%85%A81-DP%EF%BC%8885%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%EF%BC%89\"><span class=\"toc-text\">221. 最大正方形 全1 DP（85最大矩形）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-%E6%9C%89%E7%82%B9%E5%B0%8F%E6%84%8F%E6%80%9D-%E4%BA%8C%E5%88%86O-logn%E2%88%97logn-%E9%80%92%E5%BD%92%E9%9D%9E%E5%9D%87%E6%BB%A1\"><span class=\"toc-text\">222.完全二叉树的节点个数[有点小意思~] 二分O(logn∗logn) 递归非均满</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-CG-%E5%B9%B6%E9%9B%86-max-0-min-B-D-max-A-C-gt-2D\"><span class=\"toc-text\">223.矩形面积 CG 并集 max(0, min(B,D)-max(A,C)) -&gt; 2D</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-acw%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-4-num-push-0\"><span class=\"toc-text\">224.基本计算器 acw表达式求值(4) num.push(0)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-2q-gt-1stk\"><span class=\"toc-text\">225.用队列实现栈 2q-&gt;1stk</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-swap-l-r\"><span class=\"toc-text\">226.翻转二叉树 swap(l,r)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II-%E6%A8%A1%E6%9D%BF%E9%A2%98-x2F-unordered-map-lt-char-int-gt-pr\"><span class=\"toc-text\">227.基本计算器 II  模板题 *&#x2F;  unordered_map&lt;char, int&gt; pr</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4-%E8%BF%9E%E7%BB%ADi-j-%E5%8F%8C%E6%8C%87%E9%92%88\"><span class=\"toc-text\">228.汇总区间 连续i~j 双指针</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#229-%E6%B1%82%E4%BC%97%E6%95%B0-II-gt-n-x2F-3-169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-n-x2F-2-%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95n-x2F-k-BM%EF%BC%81\"><span class=\"toc-text\">229.求众数 II &gt;n&#x2F;3 (169多数元素:n&#x2F;2 摩尔投票法n&#x2F;k BM！)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">230.二叉搜索树中第K小的元素</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#231-2%E7%9A%84%E5%B9%82-n-gt-0-amp-amp-n-amp-n-x3D-x3D-n\"><span class=\"toc-text\">231.2的幂 n &gt; 0 &amp;&amp; (n &amp; -n) &#x3D;&#x3D; n;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-225\"><span class=\"toc-text\">232.用栈实现队列(225)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94-%E9%9A%BE%EF%BC%81-233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA-L-R-10-p-acw338%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98-%E5%9F%BA%E7%A1%80%E8%AF%BE-%E8%93%9D%E4%B9%A6DP\"><span class=\"toc-text\">—[难！]233.数字 1 的个数 分类讨论 L R 10^p acw338计数问题(基础课)蓝书DP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">234.回文链表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA-%E9%80%92%E5%BD%92simple-O-h\"><span class=\"toc-text\">235.二叉搜索树的最近公共祖先LCA 递归simple O(h)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LR%E9%83%BD%E9%80%92%E5%BD%92-O-n-dfs-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%BE%E5%88%B0%E5%90%8C%E6%97%B6%E5%8C%85%E5%90%ABpq-state-x3D-x3D-3-%E7%9A%84%E5%AD%90%E6%A0%91\"><span class=\"toc-text\">236. 二叉树的最近公共祖先 LR都递归 O(n) dfs 第一次找到同时包含pq(state &#x3D;&#x3D; 3)的子树</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9A-node-x3D-node-gt-next\"><span class=\"toc-text\">237. 删除链表中的节点：*node &#x3D; *node-&gt;next;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF-%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3%EF%BC%81\"><span class=\"toc-text\">238. 除自身以外数组的乘积[前后缀分解！]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%9A%E5%9C%A8%E5%B7%A6%E8%BF%98%E4%BD%8E-x3D-%E8%A2%AB%E4%BC%98%E5%8C%96%E6%8E%89\"><span class=\"toc-text\">239. 滑动窗口最大值[单调队列：在左还低&#x3D;被优化掉]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II-%E5%8F%B3%E4%B8%8A%E8%A7%92\"><span class=\"toc-text\">240. 搜索二维矩阵 II 右上角</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#24-%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7-%E5%8A%A0%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%89%80%E6%9C%89%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C-expr-L-R-LR%E9%80%92%E5%BD%92dfs-%EF%BC%88%E5%90%8CLC95%EF%BC%89\"><span class=\"toc-text\">24. 为运算表达式设计优先级 加括号的所有运算结果:expr L+-*R LR递归dfs （同LC95）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-%E5%93%88%E5%B8%8C%E8%A1%A8-str%EF%BC%9Aunicode1%E4%B8%AA%E5%AD%97%E7%AC%A6-x3D-2%E4%B8%AAchar\"><span class=\"toc-text\">242. 有效的字母异位词 哈希表 str：unicode1个字符&#x3D;2个char</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#243\"><span class=\"toc-text\">243.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#244\"><span class=\"toc-text\">244.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#245\"><span class=\"toc-text\">245.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#246\"><span class=\"toc-text\">246.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#247\"><span class=\"toc-text\">247.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#248\"><span class=\"toc-text\">248.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#249\"><span class=\"toc-text\">249.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#250\"><span class=\"toc-text\">250.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#251\"><span class=\"toc-text\">251</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#252\"><span class=\"toc-text\">252.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#253\"><span class=\"toc-text\">253.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#254\"><span class=\"toc-text\">254.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#255\"><span class=\"toc-text\">255.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#256\"><span class=\"toc-text\">256.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-dfs\"><span class=\"toc-text\">257.二叉树的所有路径 dfs</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0-%E7%9B%B4%E5%88%B0%E7%BB%93%E6%9E%9C%E4%B8%BA%E4%B8%80%E4%BD%8D%E6%95%B0-%E5%B0%8F%E5%AD%A6%E5%A5%A5%E6%95%B0-%E5%90%8C%E4%BD%99-10-n-mod9-x3D-1-f-x-9-x3D-x-9\"><span class=\"toc-text\">258.各位相加 直到结果为一位数 小学奥数 同余 (10^n)mod9&#x3D;1 f(x)%9&#x3D;x%9</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#259\"><span class=\"toc-text\">259.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-III-2%E6%AC%A1%E4%B8%AD-2%E4%B8%AA-1%E6%AC%A1val\"><span class=\"toc-text\">260.只出现一次的数字 III  2次中[2个]1次val</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#261\"><span class=\"toc-text\">261</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#262\"><span class=\"toc-text\">262.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#263-%E4%B8%91%E6%95%B0-%E5%8F%AA%E5%8C%85%E5%90%AB%E8%B4%A8%E5%9B%A0%E6%95%B0-2-3-5-%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0-%E6%8A%8A235%E9%99%A4%E5%B9%B2%E5%87%80-x3D-x3D-1\"><span class=\"toc-text\">263.丑数  只包含质因数 2 3 5 的正整数 把235除干净&#x3D;&#x3D;1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#264-%E4%B8%91%E6%95%B0II-nth-%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6\"><span class=\"toc-text\">264.丑数II nth 多路归并</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#265\"><span class=\"toc-text\">265.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#266\"><span class=\"toc-text\">266.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#267\"><span class=\"toc-text\">267.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97-0-n-n-n-1-x2F-2-sum\"><span class=\"toc-text\">268.缺失数字 0~n n(n+1)&#x2F;2-sum</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#269\"><span class=\"toc-text\">269.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#270\"><span class=\"toc-text\">270.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#271\"><span class=\"toc-text\">271</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#272\"><span class=\"toc-text\">272.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#273-%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E8%8B%B1%E6%96%87%E8%A1%A8%E7%A4%BA-%E9%9A%BE%E6%A8%A1%E6%8B%9F\"><span class=\"toc-text\">273.整数转换英文表示 难模拟</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#274-H%E6%8C%87%E6%95%B0-O-nlogn-sort\"><span class=\"toc-text\">274.H指数 O(nlogn):sort</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#275-H%E6%8C%87%E6%95%B0II-%E4%BA%8C%E5%88%86O-logn\"><span class=\"toc-text\">275.H指数II 二分O(logn)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#276\"><span class=\"toc-text\">276.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#277\"><span class=\"toc-text\">277.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC-%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">278.第一个错误的版本 二分</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-n%E6%9C%80%E5%B0%91%E6%8B%86%E6%88%90%E5%87%A0%E4%B8%AA%E2%80%A6%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">279.完全平方数  n最少拆成几个…之和</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#280\"><span class=\"toc-text\">280.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#281\"><span class=\"toc-text\">281</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#282-%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%B1%BB%E4%BC%BC24%E7%82%B9%E6%B8%B8%E6%88%8F-%E5%8D%A1%E5%B8%B8-a-b%C3%97-%E9%80%92%E5%BD%92\"><span class=\"toc-text\">282.给表达式添加运算符 类似24点游戏 卡常 a+b×()递归</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6-%E8%87%B3%E6%9C%AB%E5%B0%BE\"><span class=\"toc-text\">283.移动零 至末尾</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#284-%E9%A1%B6%E7%AB%AF%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%B0%81%E8%A3%85-%E6%89%8B%E5%8A%A8%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%E5%B1%95%E5%8F%B0%E7%9A%84%E7%BC%93%E5%AD%98cur\"><span class=\"toc-text\">284.顶端迭代器 封装 手动增加一个类似展台的缓存cur</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#285\"><span class=\"toc-text\">285.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#286\"><span class=\"toc-text\">286.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-%E8%BD%AC%E5%8C%96%E5%88%B0LC142%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3\"><span class=\"toc-text\">287.寻找重复数 转化到LC142环的入口</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#288\"><span class=\"toc-text\">288.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F-%E5%8E%9F%E5%9C%B0-32bit-int%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">289.生命游戏 原地 32bit int技巧</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B-%E5%8F%8C%E5%B0%84%EF%BC%9A%E6%BB%A1%E5%B0%84-A-x3D-B-%E5%8D%95%E5%B0%84B-gt-A-%E5%94%AF%E4%B8%80-%E6%98%A0%E5%B0%84A-gt-B-%E5%94%AF%E4%B8%80\"><span class=\"toc-text\">290.单词规律  双射：满射|A|&#x3D;|B| 单射B-&gt;A(唯一) 映射A-&gt;B(唯一)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#291\"><span class=\"toc-text\">291</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#292-Nim%E6%B8%B8%E6%88%8F-%E5%B0%8F%E5%AD%A6%E6%95%B0%E5%A5%A5\"><span class=\"toc-text\">292.Nim游戏 小学数奥</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#293\"><span class=\"toc-text\">293.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#294\"><span class=\"toc-text\">294.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84-%E4%B8%AD%E4%BD%8D%E6%95%B0-%E5%8A%A8%E6%80%81%E7%BB%B4%E6%8A%A4median%EF%BC%9A%E5%AF%B9%E9%A1%B6%E5%A0%86\"><span class=\"toc-text\">295.数据流的[中位数] 动态维护median：对顶堆</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#296\"><span class=\"toc-text\">296.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">297.二叉树的序列化与反序列化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#298\"><span class=\"toc-text\">298.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#299-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F\"><span class=\"toc-text\">299.猜数字游戏</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%81%EF%BC%81%EF%BC%81300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-%E4%B8%8D%E8%BF%9E%E7%BB%AD-LIS-DP-%E4%BA%8C%E5%88%86-%E8%B4%AA%E5%BF%83-%E9%9A%BE%EF%BC%81\"><span class=\"toc-text\">！！！300.最长递增子序列 不连续 LIS:DP 二分 贪心 难！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E6%9C%80%E5%B0%91%E5%88%A0-%E6%89%80%E6%9C%89%E7%BB%93%E6%9E%9C-%E9%9A%BE-%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E5%89%AA%E6%9E%9D-O-n-2-n\"><span class=\"toc-text\">-301. 删除无效的括号 最少删 所有结果 难! 递归回溯剪枝 O(n*2^n)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#302\"><span class=\"toc-text\">302.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98-1D%E5%89%8D%E7%BC%80%E5%92%8C\"><span class=\"toc-text\">303.区域和检索-数组不可变 1D前缀和</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98\"><span class=\"toc-text\">304.二维区域和检索 - 矩阵不可变</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#305\"><span class=\"toc-text\">305.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#306-%E7%B4%AF%E5%8A%A0%E6%95%B0-judge-%E6%9C%AA%E5%88%86%E5%89%B2%E7%9A%84fib-%E6%9E%9A%E4%B8%BE%E4%B8%B2%E9%95%BFxyz-abc-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%E5%88%97%E7%AB%96%E5%BC%8F\"><span class=\"toc-text\">306.累加数 judge:未分割的fib 枚举串长xyz abc+高精度加法列竖式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">307.区域和检索-数组可修改 树状数组</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#308\"><span class=\"toc-text\">308.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F-%E7%94%BB%E7%8A%B6%E6%80%81%E6%9C%BADP\"><span class=\"toc-text\">309.最佳买卖股票时机含冷冻期 画状态机DP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91-minHeight%E7%9A%84%E6%89%80%E6%9C%89%E6%A0%B9-%E6%A0%91%E5%BD%A2DP-O-n\"><span class=\"toc-text\">310.最小高度树 minHeight的所有根 树形DP O(n)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#311\"><span class=\"toc-text\">311.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#312-%E6%88%B3%E6%B0%94%E7%90%83-%E5%8C%BA%E9%97%B4DP-i-j%E4%B8%BA%E5%93%A8%E5%85%B5\"><span class=\"toc-text\">312.戳气球 区间DP i,j为哨兵</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0-LC264-%E4%B8%91%E6%95%B0II-2-3-5-gt-p-k-nth-%E5%BF%AB%E9%80%9Finsert-%E5%BF%AB%E9%80%9F%E6%B1%82min%EF%BC%9A%E5%A0%86%EF%BC%81-O-nlogk-lt-10-7-%E5%A4%AA%E6%99%95%E4%BA%86%E2%80%A6\"><span class=\"toc-text\">313.超级丑数 LC264.丑数II[2 3 5]-&gt;p[k] nth   快速insert 快速求min：堆！ O(nlogk)&lt;10^7 太晕了…</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#314\"><span class=\"toc-text\">314.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84tr-in-x3D-cnt-O-nlogn\"><span class=\"toc-text\">315.计算右侧小于当前元素的个数  树状数组tr[in]&#x3D;cnt O(nlogn)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#316-x3D-1081-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D-%E5%BE%97min%E5%AD%97%E5%85%B8%E5%BA%8F-%E8%B4%AA%E5%BF%83%E6%A0%88O-n-string-stk-in-stk-last-%E5%A4%A7-%E5%90%8E%E9%9D%A2%E8%BF%98%E6%9C%89-%E9%9D%9E%E7%A9%BA%E5%B0%B1%E5%88%A0stk-back\"><span class=\"toc-text\">316[&#x3D;1081].去除重复字母 得min字典序 贪心栈O(n) string stk in_stk last 大 后面还有 非空就删stk.back()</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#317\"><span class=\"toc-text\">317.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#318-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF-%E4%B8%8D%E5%90%AB%E5%85%AC%E5%85%B1%E5%AD%97%E6%AF%8D-26-state-amp-x3D-x3D-0\"><span class=\"toc-text\">318.最大单词长度乘积 不含公共字母: 26 state &amp;&#x3D;&#x3D;0</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#319-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-%E5%B0%8F%E6%95%B0%E8%AE%BA%EF%BC%9Ai%E7%9A%84%E5%80%8D%E6%95%B0%E6%8C%89%E4%B8%80%E4%B8%8B-%E7%AC%ACn%E6%AC%A1%E5%87%A0%E4%B8%AA%E4%BA%AE-sqrt-n-%E4%B8%AA%E5%B9%B3%E6%96%B9%E6%95%B0-idx%E4%BA%AE-x3D-%E6%8C%89%E3%80%90%E5%A5%87%E6%95%B0%E3%80%91%E6%AC%A1-x3D-%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0%E4%B8%BA%E3%80%90%E5%A5%87%E6%95%B0%E3%80%91-lt-x3D-gt-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-1-3-9\"><span class=\"toc-text\">319.灯泡开关 小数论：i的倍数按一下 第n次几个亮(sqrt(n)个平方数)  idx亮&#x3D;按【奇数】次&#x3D;因子个数为【奇数】&lt;&#x3D;&gt;完全平方数 1 [3] 9</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#320\"><span class=\"toc-text\">320.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%81321-%E6%8B%BC%E6%8E%A5%E6%9C%80%E5%A4%A7%E6%95%B0-%E4%BF%9D%E5%BA%8F-max%E5%AD%97%E5%85%B8%E5%BA%8F%E3%80%90%E7%B1%BB%E4%BC%BC318%E3%80%91-%E8%B4%AA%E5%BF%83%E5%90%88%E5%B9%B6-%E5%85%88%E9%80%89%E5%A4%A7%E7%9A%84%EF%BC%9A%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%951087\"><span class=\"toc-text\">！321.拼接最大数 保序 max字典序【类似318】 贪心合并 先选大的：证明方法1087</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-acw3%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-%E4%BD%93%E7%A7%AFv-%E4%BB%B7%E5%80%BC1\"><span class=\"toc-text\">322.零钱兑换 acw3完全背包 体积v 价值1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#323\"><span class=\"toc-text\">323.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#324-%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8FII-nth-element-LC75%E4%B8%89%E6%95%B0%E6%8E%92%E5%BA%8F-A-i\"><span class=\"toc-text\">324.摆动排序II nth_element LC75三数排序 A(i)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#325\"><span class=\"toc-text\">325.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#326-3%E7%9A%84%E5%B9%82-n-3-19-x3D-1162261467-%E8%AE%A1%E7%AE%97%E5%99%A8\"><span class=\"toc-text\">326.3的幂 n|3^19&#x3D;1162261467 计算器</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%81327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0-%E5%89%8D%E7%BC%80%E5%92%8C-%E7%A6%BB%E6%95%A3%E5%8C%96-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">！327.区间和的个数 前缀和 离散化+树状数组</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8oh-ot-eh-et-p\"><span class=\"toc-text\">328. 奇偶链表oh ot eh et p</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#329-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84-poj%E6%BB%91%E9%9B%AA-DP%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%86%99%E6%B3%95-dfs%E6%8C%89%E6%8B%93%E6%89%91%E5%BA%8F%E6%9D%A5%E7%AE%97\"><span class=\"toc-text\">329. 矩阵中的最长递增路径 poj滑雪 DP的记忆化搜索写法 dfs按拓扑序来算</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84-%E5%88%86%E7%B1%BB-%E8%B4%AA%E5%BF%83\"><span class=\"toc-text\">330.按要求补齐数组 分类+贪心</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96-%E5%94%AF%E4%B8%80\"><span class=\"toc-text\">331. 验证二叉树的前序序列化 #唯一</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B-%E6%9C%89%E5%90%91%E5%9B%BE%E6%B1%82%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84-%E8%93%9D%E4%B9%A6P409-multiset%E5%B9%B3%E8%A1%A1%E6%A0%91-erase-%E5%9B%9E%E6%BA%AF-%E5%85%A5%E6%A8%A1%E6%8B%9Fans%E6%A0%88\"><span class=\"toc-text\">332.重新安排行程 有向图求字典序最小的欧拉路径 蓝书P409 multiset平衡树 erase 回溯 入模拟ans栈</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#333\"><span class=\"toc-text\">333.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#334-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97-300-%E4%BA%8C%E5%88%86LIS%E7%AE%80%E5%8C%96%E7%89%88-len-gt-x3D-3%E5%8D%B3%E5%8F%AF\"><span class=\"toc-text\">334.递增的三元子序列 300.二分LIS简化版 len&gt;&#x3D;3即可</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#335-%E8%B7%AF%E5%BE%84%E4%BA%A4%E5%8F%89-%E6%A8%A1%E6%8B%9F%E5%88%86%E7%B1%BB%E7%89%B9%E5%88%A4\"><span class=\"toc-text\">335.路径交叉 模拟分类特判</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#336-%E5%9B%9E%E6%96%87%E5%AF%B9-O-nL-2-hash-x-x3D-i-gt-x3D-lt-check\"><span class=\"toc-text\">336.回文对 O(nL^2) hash[x]&#x3D;i &gt;&#x3D; &lt; check</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII-%E7%9B%B8%E9%9A%94max-%E6%A0%91%E5%BD%A2DP%EF%BC%9A%E5%B1%80%E9%83%A8%E9%80%92%E5%BD%92-%E4%B8%8D%E9%80%89-%E9%80%89\"><span class=\"toc-text\">337.打家劫舍III 相隔max 树形DP：局部递归{不选, 选}</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0-%E5%89%8Dn-bin-cnt1-f-i-x3D-f-i-gt-gt-1-i-amp-1-x2F-x2F-%E9%80%92%E6%8E%A8\"><span class=\"toc-text\">338.比特位计数 前n_bin_cnt1[] f[i] &#x3D; f[i &gt;&gt; 1] + (i &amp; 1);&#x2F;&#x2F;递推</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#339\"><span class=\"toc-text\">339.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#340\"><span class=\"toc-text\">340.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8-%E9%80%92%E5%BD%92dfs%E3%80%81stk-jump-%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">341.扁平化嵌套列表迭代器 递归dfs、stk jump 设计</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#342-4%E7%9A%84%E5%B9%82-gt-0-%E5%B9%B3%E6%96%B9%E6%95%B0-%E5%8F%AA%E5%90%AB%E5%9B%A0%E5%AD%902\"><span class=\"toc-text\">342.4的幂 &gt;0 平方数 只含因子2</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86-%E5%B0%8F%E5%AD%A6%E6%95%B0%E5%A5%A5-%E6%B1%82%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF-%E8%AF%81%E6%98%8E%EF%BC%81-%E5%B0%BD%E9%87%8F%E5%88%86%E6%88%903%E5%92%8C2-lt-x3D-2%E4%B8%AA2-n-gt-x3D-5-%E5%85%88%E6%BB%A1%E8%B6%B33\"><span class=\"toc-text\">343.整数拆分 小学数奥:求最大乘积 证明！ 尽量分成3和2 &lt;&#x3D;2个2(n&gt;&#x3D;5 先满足3)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8F%8C%E6%8C%87%E9%92%88swap\"><span class=\"toc-text\">344.反转字符串 双指针swap</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D-s-find-tolower-c-x3D-1\"><span class=\"toc-text\">345.反转字符串中的元音字母 s.find(tolower(c)) !&#x3D; -1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#346\"><span class=\"toc-text\">346.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">347.前 K 个高频元素 计数排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#348\"><span class=\"toc-text\">348.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-unordered-set-erase\"><span class=\"toc-text\">349.两个数组的交集 unordered_set erase</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-unordered-multiset-S-erase-S-find-x\"><span class=\"toc-text\">350.两个数组的交集II unordered_multiset S.erase(S.find(x))</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#351\"><span class=\"toc-text\">351</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#352-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%98%E4%B8%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4\"><span class=\"toc-text\">352.将数据流变为多个不相交区间</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#353\"><span class=\"toc-text\">353.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98-LIS-DP\"><span class=\"toc-text\">354.俄罗斯套娃信封问题 LIS DP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94355-%E8%AE%BE%E8%AE%A1%E6%8E%A8%E7%89%B9\"><span class=\"toc-text\">—355.设计推特</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#356\"><span class=\"toc-text\">356.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#357-%E8%AE%A1%E7%AE%97%E5%90%84%E4%B8%AA%E4%BD%8D%E6%95%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0-n-lt-x3D-10-9-9-8%E2%80%A6\"><span class=\"toc-text\">357.计算各个位数不同的数字个数 n&lt;&#x3D;10 9*9*8…</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#358\"><span class=\"toc-text\">358.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#359\"><span class=\"toc-text\">359.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#360\"><span class=\"toc-text\">360.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#361\"><span class=\"toc-text\">361.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#362\"><span class=\"toc-text\">362.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#363-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-K-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C-n-gt-m\"><span class=\"toc-text\">363.矩形区域不超过 K 的最大数值和 n&gt;m</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#364\"><span class=\"toc-text\">364.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98-%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86-gcd-a-b-c\"><span class=\"toc-text\">365.水壶问题 裴蜀定理 gcd(a,b)|c</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#https-www-acwing-com-blog-content-17\"><span class=\"toc-text\">https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;17&#x2F;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#366\"><span class=\"toc-text\">366.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-%E4%B8%8D%E8%83%BDsqrt-%E4%BA%8C%E5%88%86-lt-x3D-sqrt-n-%E7%9A%84max\"><span class=\"toc-text\">367.有效的完全平方数 不能sqrt 二分 &lt;&#x3D;sqrt(n)的max</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86-DP-%E7%B1%BB%E4%BC%BCLIS-if-nums-i-nums-j-x3D-x3D-0-f-i-x3D-max-f-i-f-j-1-%E5%8F%8D%E5%90%91%E9%80%92%E6%8E%A8%E5%87%BA%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">368.最大整除子集 DP 类似LIS if (nums[i] % nums[j] &#x3D;&#x3D; 0) f[i] &#x3D; max(f[i], f[j] + 1); 反向递推出答案</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#369\"><span class=\"toc-text\">369.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#370\"><span class=\"toc-text\">370.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C-%E4%B8%8D%E7%94%A8-%E4%B8%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95-%E8%BF%9B%E4%BD%8D-a-amp-b-lt-lt-1-unsigned-getSum-sum-carry\"><span class=\"toc-text\">371.两整数之和 不用+- ^:不进位加法 进位:(a&amp;b)&lt;&lt;1 (unsigned) getSum(sum, carry);</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#372-%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9-%E5%BF%AB%E9%80%9F%E5%B9%82-b%E4%BB%8E%E4%BD%8E%E5%88%B0%E9%AB%98%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E5%88%86-qmi-superPow-a-b-10-qmi-a-k-p\"><span class=\"toc-text\">372. 超级次方 快速幂:b从低到高的二进制拆分 qmi(superPow(a, b), 10) * qmi(a, k) % p;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#373-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84K%E5%AF%B9%E6%95%B0%E5%AD%97-%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6-%E7%B1%BB%E4%BC%BC%E4%B8%91%E6%95%B0\"><span class=\"toc-text\">373.查找和最小的K对数字 多路归并 类似丑数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F-%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">374.猜数字大小 二分模板</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%81375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII-%E4%BB%A3%E4%BB%B7guess-%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E6%8B%A5%E6%9C%89%E5%A4%9A%E5%B0%91%E7%8E%B0%E9%87%91%E6%89%8D%E8%83%BD%E7%A1%AE%E4%BF%9D%E4%BD%A0%E8%83%BD%E7%8C%9C%E5%88%B0-%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91-min-lt-%E2%80%94f-i-j-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E7%9B%AE%E6%A0%87%E5%80%BC%E5%9C%A8-i-j-%E5%8F%8A%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%8C%9C%E6%B3%95-worst%E7%9A%84min\"><span class=\"toc-text\">！375.猜数字大小II 代价guess 至少需要拥有多少现金才能确保你能猜到 【区间DP】 min&lt;—f[i,j]:所有可能的目标值在[i,j]及所有可能猜法 worst的min</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%90%E8%B4%AA%E5%BF%83-DP-O-n-%E6%9E%81%E5%80%BC%E7%82%B9%E3%80%91376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97-%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6-%E8%B4%AA%E5%BF%83O-n-%E5%8F%AA%E5%8F%96%E6%9E%81%E5%80%BC%E7%82%B9%E3%80%81DPO-n-dp-up-i-dp-down-i\"><span class=\"toc-text\">【贪心 DP O(n)极值点】376.摆动序列 最长子序列的长度 贪心O(n)只取极值点、DPO(n) dp_up[i] dp_down[i]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3-DP-i%E2%89%A5nums-j-f-i-x3D-f-i%E2%88%92nums-j\"><span class=\"toc-text\">377.组合总和Ⅳ DP i≥nums[j]: f(i)+&#x3D;f(i−nums[j])</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-%E5%80%BC%E5%9F%9F%E4%BA%8C%E5%88%86%EF%BC%9A%E5%90%91%E4%B8%8B%E5%90%91%E5%B7%A6-O-nlogL-L%E4%B8%BA%E5%80%BC%E5%9F%9F-lt-x3D-mid%E7%9A%84%E4%B8%AA%E6%95%B0-gt-x3D-k-%E7%9A%84min\"><span class=\"toc-text\">378.有序矩阵中第K小的元素 值域二分：向下向左 O(nlogL) L为值域 &lt;&#x3D;mid的个数&gt;&#x3D;k 的min</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#379\"><span class=\"toc-text\">379.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#380-%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-%E9%9A%8F%E6%9C%BA%E7%B4%A2%E5%BC%95-%E6%95%B0%E7%BB%84-hash-val-x3D-idx-O-1-swap%E5%88%B0%E6%9C%80%E5%90%8E-pop-back\"><span class=\"toc-text\">380.常数时间插入、删除和获取随机元素 随机索引:数组 hash[val]&#x3D;idx O(1)-:swap到最后 pop_back</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#381-O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D-%E5%B5%8C%E5%A5%97map-set\"><span class=\"toc-text\">381.O(1) 时间插入、删除和获取随机元素 - 允许重复 嵌套map(set)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#382-%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9-S-x3D-O-1-n%E5%A4%A7%E4%B8%94%E6%9C%AA%E7%9F%A5-%E6%8A%BD%E5%A5%96%E5%9C%BA%E6%99%AF-%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7algo\"><span class=\"toc-text\">382.链表随机节点 S&#x3D;O(1) n大且未知 抽奖场景 蓄水池抽样algo!!!</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#383-%E8%B5%8E%E9%87%91%E4%BF%A1-char-cntA-lt-x3D-B-b-a%E2%80%93-%E7%88%BD%E9%A2%98\"><span class=\"toc-text\">383.赎金信 char_cntA&lt;&#x3D;B b++ a– 爽题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#384-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84-1-x2F-n-%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86-swap-cur-%E4%B9%8B%E5%90%8E-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95-382\"><span class=\"toc-text\">384.打乱数组 1&#x2F;n! 乘法原理 swap(cur,之后) 洗牌算法(382)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#385-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8-dfs-LC341%E7%9A%84%E9%80%86op-arr-gt-NestedInteger-num\"><span class=\"toc-text\">385.迷你语法分析器 dfs LC341的逆op:arr-&gt;NestedInteger [num,] ,</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#386-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0-1n%E7%9A%84%E5%AD%97%E5%85%B8%E5%BA%8F-Trie-%E6%9E%9A%E4%B8%BE%E9%A6%96%E4%BD%8D-%E9%80%92%E5%BD%92%E5%AD%90%E6%A0%9109\"><span class=\"toc-text\">386.字典序排数 1n的字典序 Trie 枚举首位+递归子树09</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6-hash\"><span class=\"toc-text\">387.字符串中的第一个唯一字符 hash</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#388-%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84-str%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82-stk%E7%BB%B4%E6%8A%A4%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E6%AF%8F%E5%B1%82%E4%B8%B2%E9%95%BF\"><span class=\"toc-text\">388.文件的最长绝对路径 str处理细节 stk维护最长路径每层串长</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#389-%E6%89%BE%E4%B8%8D%E5%90%8C-%E6%89%93%E4%B9%B1%E6%89%BE%E5%A4%9A%E4%B8%80%E4%B8%AA-%E3%80%90better%E3%80%91%E5%85%A8-%E6%89%BE2%E4%B8%AD%E7%9A%841-S-x3D-O-1-%E6%88%96%E8%80%85cnt-%E2%80%93%E4%BD%99%E4%B8%8B%E7%9A%84%E9%82%A3%E4%B8%AA-a-b-cnt\"><span class=\"toc-text\">389.找不同 打乱找多一个:【better】全^ 找2中的1 S&#x3D;O(1)  或者cnt++–余下的那个 [a,b]:cnt</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#390-%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F-S%E5%9E%8B%E7%BA%A6%E7%91%9F%E5%A4%AB-f-n-x3D-2-g-n-x2F-2-g-n-x3D-n-1-f-n\"><span class=\"toc-text\">390.消除游戏 S型约瑟夫 f[n]&#x3D;2*g[n&#x2F;2] g[n]&#x3D;n+1-f[n]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#391-%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2-1%E6%AC%A14%E4%B8%AA-3%E6%AC%A10%E4%B8%AA-%E6%80%BB%E9%9D%A2%E7%A7%AF-x3D-x3D-%E6%B2%A1%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">391.完美矩形 1次4个 3次0个 总面积&#x3D;&#x3D; 没意义</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-%E5%8F%8C%E6%8C%87%E9%92%88\"><span class=\"toc-text\">392.判断子序列 双指针</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#393-UTF-8%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81-str\"><span class=\"toc-text\">393.UTF-8编码验证 str</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-%E9%80%92%E5%BD%92%E6%B8%B8%E7%A8%8B%E8%A7%A3%E7%A0%81\"><span class=\"toc-text\">394.字符串解码 递归游程解码</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#395-%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E6%9E%84%E9%80%A0%E5%8D%95%E8%B0%83%E6%80%A7-%E9%9A%BE%EF%BC%81\"><span class=\"toc-text\">395.至少有K个重复字符的最长子串 构造单调性 难！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#396-%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0-%E9%94%99%E4%BD%8D%E7%9B%B8%E5%87%8F-%E6%89%BE%E8%A7%84%E5%BE%8B-O-n-O-1-s\"><span class=\"toc-text\">396.旋转函数 错位相减 找规律 O(n)+O(1)s</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#397-%E6%95%B4%E6%95%B0%E6%9B%BF%E6%8D%A2-%E7%9B%B4%E6%8E%A5%E6%A8%A1%E6%8B%9F-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E6%97%A0%E6%95%88%E7%8A%B6%E6%80%81%E5%A4%9A-LL-O-sqrt-n\"><span class=\"toc-text\">397.整数替换 直接模拟+记忆化搜索(无效状态多) LL O(sqrt(n))</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#398-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95-map-lt-int-vector-gt\"><span class=\"toc-text\">398.随机数索引 map&lt;int,vector&gt;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC-%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AFFloyd-ij-x3D-ik-kj-%E8%B7%AF%E5%BE%84%E5%94%AF%E4%B8%80%E4%B8%8D%E6%B1%82min\"><span class=\"toc-text\">399.除法求值 多源最短路Floyd ij&#x3D;ik*kj 路径唯一不求min</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#400-%E7%AC%ACN%E4%BD%8D%E6%95%B0%E5%AD%97-1-%E4%B8%B2%E4%B8%ADnth-ceil-n-x2F-k-x3D-floor-n-k-1-x2F-k\"><span class=\"toc-text\">400.第N位数字 1~串中nth ceil(n&#x2F;k)&#x3D;floor((n+k-1)&#x2F;k)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8-n%E4%B8%AA%E4%BA%AE%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%97%B6%E9%97%B4-bin-cnt-n%E4%B8%AA1-sprintf-str-%E2%80%9C-d-02d%E2%80%9D-a-b\"><span class=\"toc-text\">401.二进制手表 n个亮的所有可能时间 bin_cnt_n个1 sprintf(str, “%d:%02d”, a, b);</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97-%E4%BD%99%E4%B8%8Bmin-0-%E5%8E%BB%E5%89%8D%E5%AF%BC0-%E7%BB%8F%E5%85%B8%E8%B4%AA%E5%BF%83O-n-x3D-%E4%B8%8D%E5%88%A0-%E5%8D%95%E8%B0%83%E6%A0%88res-back-gt-x%E5%88%A0pop\"><span class=\"toc-text\">!!!402.移掉K位数字 余下min 0,去前导0 经典贪心O(n):&#x3D;不删 单调栈res.back()&gt;x删pop</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#403-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3O-n-n-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-seq-DP-dp-%E4%BB%8Ex%E8%B5%B0y%E6%AD%A5-f-hash-stone-idx\"><span class=\"toc-text\">!!!403.青蛙过河O(n*n) 记忆化搜索 seq_DP dp(从x走y步) f hash(stone,idx)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C-dfs\"><span class=\"toc-text\">404.左叶子之和 dfs</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#405-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0int-gt-gt-x3D-%E4%BC%9A%E6%8A%A5%E9%94%99-amp-0xf\"><span class=\"toc-text\">405.数字转换为十六进制数 有符号整数int&gt;&gt;&#x3D;会报错 &amp;0xf</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#406-%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97-%E8%B4%AA%E5%BF%83-h-k-left-gt-x3D-h-cnt-%E4%BA%8C%E5%88%86-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-O-n%E2%88%97logn%E2%88%97logn\"><span class=\"toc-text\">!!!406.据身高重建队列 贪心 h,k:left&gt;&#x3D;h_cnt (二分+树状数组) O(n∗logn∗logn)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%90%E3%80%91%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E6%98%AF%E7%9B%AE%E7%9A%84%EF%BC%8Cds-is-%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0-x2F-%E4%BC%98%E5%8C%96tools%EF%BC%8C%E5%88%87%E5%BF%8C%E6%9C%AC%E6%9C%AB%E5%80%92%E7%BD%AE%EF%BC%81\"><span class=\"toc-text\">【】算法思路是目的，ds is 步骤实现&#x2F;优化tools，切忌本末倒置！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%90%E3%80%91%E6%80%9D%E8%B7%AF%E5%88%B0%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%B8%85%E6%A5%9A%E5%AE%9A%E4%B9%89%E6%AF%8F%E4%B8%AA%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%81%E6%80%8E%E4%B9%88%E6%B1%82%E5%80%BC%E3%80%81%E6%B1%82%E7%9A%84%E9%A1%BA%E5%BA%8F%E3%80%81why%E6%8C%89%E6%AD%A4%E9%A1%BA%E5%BA%8F%E7%AE%97%E6%98%AF%E5%AF%B9%E7%9A%84-%E7%8E%AF%E7%8E%AF%E7%9B%B8%E6%89%A3%EF%BC%81\"><span class=\"toc-text\">【】思路到代码：清楚定义每个状态的含义、怎么求值、求的顺序、why按此顺序算是对的 环环相扣！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#407-%E6%8E%A5%E9%9B%A8%E6%B0%B4II-LC42%E7%9A%842D%E7%89%88-init%E8%BE%B9%E7%95%8Cf-x3D-h%E5%85%A5%E5%B0%8F%E8%B7%9F%E5%A0%86-cur%E6%9C%80%E7%BB%88f-x3D-max-cur%E7%9C%9F%E5%AE%9Eh-t-min%E6%9C%80%E7%BB%88f-gt-x3D-%E5%86%B3%E5%AE%9A%E4%BA%86%E9%80%92%E5%A2%9E%E7%9A%84%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">!!!407.接雨水II LC42的2D版 init边界f&#x3D;h入小跟堆 cur最终f&#x3D;max(cur真实h,t_min最终f) &gt;&#x3D; 决定了递增的搜索顺序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#408\"><span class=\"toc-text\">408.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2-%E8%83%BD%E6%9E%84%E9%80%A0%E7%9A%84-k-x2F-2-2\"><span class=\"toc-text\">409.最长回文串 能构造的~ k&#x2F;2*2</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC-%E6%9C%80%E5%B0%8F%E5%8C%96m%E6%AE%B5%E5%92%8C%E7%9A%84max-out-%E7%BB%8F%E5%85%B8%E4%BA%8C%E5%88%86-lt-%E8%B4%AA%E5%BF%83-%E5%B0%BD%E9%87%8F%E6%94%BEcheck-cnt-lt-x3D-m\"><span class=\"toc-text\">!!!410.分割数组的最大值 最小化m段和的max_out 经典二分[&lt;-]+贪心[尽量放check:cnt&lt;&#x3D;m]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#411\"><span class=\"toc-text\">411.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#412-Fizz-Buzz-%E5%B0%8F%E6%A8%A1%E6%8B%9F\"><span class=\"toc-text\">412.Fizz Buzz 小模拟</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86-lt-%E6%B1%82%E5%B7%AE%E5%88%86-%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84-L-1-R-len-gt-x3D-2%E7%9A%84%E5%AD%90%E5%8C%BA%E9%97%B4%E6%95%B0-k-k-1-x2F-2\"><span class=\"toc-text\">413.等差数列划分 &lt;-求差分 值相等的[L+1~R]len&gt;&#x3D;2的子区间数 k*(k-1)&#x2F;2</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0-%E8%AE%B2%E8%BF%87-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA-s-abc%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0\"><span class=\"toc-text\">414.第三大的数 讲过 分类讨论 s:abc中不同的数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%E6%A8%A1%E6%9D%BF-i-lt-A-size-i-lt-B-size-t-%E8%BF%9B%E4%BD%8D\"><span class=\"toc-text\">415.字符串相加 高精度加法模板 i&lt;A.size()||i&lt;B.size()||t 进位</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-01bag%E6%A8%A1%E6%9D%BF-%E9%80%86%E5%BA%8F-f-j-x3D-f-j-x-x2F-x2F-bool\"><span class=\"toc-text\">416.分割等和子集 01bag模板 逆序 f[j] |&#x3D; f[j - x];&#x2F;&#x2F;bool</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98-floodfill-b-x2F-dfs-if-st-amp-t-return-1-2-x3D-3\"><span class=\"toc-text\">417.太平洋大西洋水流问题 floodfill b&#x2F;dfs if(st&amp;t)return; 1|2&#x3D;3</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#418\"><span class=\"toc-text\">418.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#419-%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0-%E4%B8%8D%E7%9B%B8%E9%82%BB%E9%95%BF%E6%9D%A1%E6%95%B0-cnt%E5%B7%A6%E4%B8%8A%E8%A7%92\"><span class=\"toc-text\">419.甲板上的战舰 不相邻长条数 cnt左上角</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#420-%E5%BC%BA%E5%AF%86%E7%A0%81%E6%A3%80%E9%AA%8C%E5%99%A8-str-to%E5%BC%BAmin-step-%E6%94%B9-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA-dirty%E6%B2%A1%E6%84%8F%E6%80%9D-%E8%B6%85%E7%B9%81%E7%90%90%E2%80%A6\"><span class=\"toc-text\">420.强密码检验器 str to强min_step:+-改 分类讨论 dirty没意思 超繁琐…</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#421-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC-Trie%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">421.数组中两个数的最大异或值 Trie例题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#422\"><span class=\"toc-text\">422.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#423-%E4%BB%8E%E8%8B%B1%E6%96%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">423.从英文中重建数字</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6\"><span class=\"toc-text\">424.替换后的最长重复字符</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#425\"><span class=\"toc-text\">425.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#426\"><span class=\"toc-text\">426.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#427-%E5%BB%BA%E7%AB%8B%E5%9B%9B%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">427.建立四叉树</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#428\"><span class=\"toc-text\">428.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-bfs\"><span class=\"toc-text\">429.N叉树的层序遍历 bfs</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92%E6%8F%92%E5%85%A5%E5%AD%90%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">430.扁平化多级双向链表 递归插入子节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#431\"><span class=\"toc-text\">431.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#432-%E5%85%A8O-1-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-mM-unordered-map-%E5%8F%8C%E5%90%91%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8h-t-%E7%BB%86%E8%8A%82%E8%B6%85%E5%A4%9A%EF%BC%81\"><span class=\"toc-text\">432.全O(1)的数据结构 (+-mM)unordered_map+双向有序链表h t 细节超多！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#433-%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96-%E6%9C%80%E7%9F%AD%E8%B7%AF-%E5%AE%BD%E6%90%9Cbfs\"><span class=\"toc-text\">433.最小基因变化 最短路 宽搜bfs</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0-%E7%88%BD%E9%A2%98\"><span class=\"toc-text\">434.字符串中的单词数 爽题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-MaxCnt-%E7%BB%8F%E5%85%B8%E8%B4%AA%E5%BF%83-%E6%8C%89Rsort-%E8%83%BD%E9%80%89%E5%B0%B1%E9%80%89\"><span class=\"toc-text\">435.无重叠区间 MaxCnt 经典贪心 按Rsort 能选就选</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#436-%E5%AF%BB%E6%89%BE%E5%8F%B3%E5%8C%BA%E9%97%B4-lr%E6%95%B0%E5%80%BC%E6%9C%80lower-bound-sort%E4%BA%8C%E5%88%86O-nlogn-acw830-%E5%8D%95%E8%B0%83%E6%A0%88-%E5%B7%A6max-idx%E6%9C%80%E8%BF%91-%E4%B8%8D%E5%90%8C-l-r-i\"><span class=\"toc-text\">436.寻找右区间[lr数值最lower_bound]sort二分O(nlogn) acw830.单调栈[左max idx最近]!不同! {l,r,i}</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%9F437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII-O-n-%E6%99%95-%EF%BC%9Awhy%E5%8F%AA%E5%9B%9E%E6%BA%AFcnt%EF%BC%9F%EF%BC%9F%EF%BC%9F%E5%8C%BA%E9%97%B4%E5%92%8C-x3D-sum-cnt-Si-T\"><span class=\"toc-text\">？437.路径总和III O(n)晕~：why只回溯cnt？？？区间和&#x3D;sum cnt[Si-T]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-O-n-%E5%8F%8C%E6%8C%87%E9%92%88-m%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3cnt-c-x3D-x3D-%E7%9A%84c%E8%BE%BEsatisfy%E7%A7%8D%E5%8D%B3%E5%8F%AF-%E5%90%88%E4%BA%8C%E4%B8%BA%E4%B8%80-x3D-0%E5%8D%B3%E5%8F%AF-cnt-s-j-x2F-x2F-cnt%E5%B0%91%E4%B8%80%E4%B8%AAs\"><span class=\"toc-text\">438.找到字符串中所有字母异位词 O(n)双指针:m长滑动窗口cnt[c]&#x3D;&#x3D;的c达satisfy种即可(合二为一:+-&#x3D;0即可) cnt[s[j++]]++;&#x2F;&#x2F;cnt少一个s-</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#439\"><span class=\"toc-text\">439.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-%E6%95%B0%E5%A5%A5-%E9%9A%BE%EF%BC%8C%E9%9C%80%E8%A6%81%E5%BE%88%E4%BB%94%E7%BB%86-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA-f-prefix-n-1-n%E4%B8%AD%E5%89%8D%E7%BC%80%E4%B8%BAprefix%E7%9A%84%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">440.字典序的第K小数字 数位统计 数奥:难，需要很仔细 分类讨论 f(prefix, n):1~n中前缀为prefix的个数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81-%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">441.排列硬币 一元二次方程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE-T-x3D-O-n-1%E4%B8%AD%E5%8E%9F%E5%9C%B0%E6%89%BE2%E6%AC%A1%E7%9A%84%E6%95%B0s-%E3%80%90%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E3%80%91%E6%8A%8Aidx%E5%BD%93%E5%81%9Acnt-1-x3D-%E5%B0%B1%E8%AE%B0%E5%BD%95-LC448\"><span class=\"toc-text\">442.数组中重复的数据 T&#x3D;O(n) 1中原地找2次的数s:【奇技淫巧】把idx当做cnt *(-1)&#x3D;+就记录[LC448]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%B8%B8%E7%A8%8B-%E7%9B%B4%E6%8E%A5%E8%A6%86%E7%9B%96-len%E6%97%A01-%E6%8C%89%E4%BD%8D%E6%8B%BF%E5%87%BAk-t%EF%BC%9AO-1\"><span class=\"toc-text\">443.压缩字符串 游程 直接覆盖 len无1 按位拿出k~t：O(1)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#444\"><span class=\"toc-text\">444.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95-%E5%A4%B4%E6%8F%92\"><span class=\"toc-text\">445.两数相加II 反转链表+高精度加法 头插</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#446-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86II-%E5%AD%90%E5%BA%8F%E5%88%97-cnt-DP-O-n-n\"><span class=\"toc-text\">446.等差数列划分II-子序列 cnt DP O(n*n)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F-ijk-ij-x3D-ik-cnt-%E4%B8%8Ei%E8%B7%9D%E7%A6%BBdist%E7%9A%84%E7%82%B9%E6%95%B0-sigma-P-C-2-%E4%B8%8D%E5%90%8Cjk%E6%80%BB%E6%95%B0\"><span class=\"toc-text\">447.回旋镖的数量 ijk ij&#x3D;ik cnt:与i距离dist的点数 sigma_P(C,2) 不同jk总数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-nums-0-n-1-to-%E4%B8%8D%E7%AE%A1%EF%BC%81%E5%8E%9F%E5%9C%B0vis-%E6%80%9D%E6%83%B3%E5%90%8CLC442\"><span class=\"toc-text\">448.找到所有数组中消失的数字 nums[0~n-1] +to- -不管！原地vis 思想同LC442</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#449-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89-%E6%90%9C%E7%B4%A2-%E6%A0%91-d-vec-ssin-%E5%AD%90%E6%A0%91%E8%8C%83%E5%9B%B4-lt-gt-x3D-%E4%B9%9F%E8%83%BD%E8%BF%87%EF%BC%9A%E8%AF%B4%E6%98%8Ev%E5%94%AF%E4%B8%80\"><span class=\"toc-text\">449.序列化和反序列化二叉[搜索]树  d:vec ssin 子树范围 &lt; &gt;&#x3D;也能过：说明v唯一</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E7%BB%8F%E5%85%B8ds-O-h-x3D-logn-amp-root-%E5%90%8E%E7%BB%A7p%E8%A6%86%E7%9B%96root%EF%BC%8C%E5%88%A0p\"><span class=\"toc-text\">450.删除二叉搜索树中的节点 经典ds O(h&#x3D;logn) &amp;root 后继p覆盖root，删p</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F-%E5%8F%8C%E5%85%B3%E9%94%AE%E5%AD%97%E6%8E%92%E5%BA%8F%EF%BC%9Acnt-gt-ASCII%E5%AD%97%E5%85%B8%E5%BA%8F-lt-amp\"><span class=\"toc-text\">451.根据字符出现频率排序 双关键字排序：cnt&gt;,ASCII字典序&lt;  [&amp;]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-acw905%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9-R%E6%8E%92-%E4%B8%8D%E8%A6%86%E7%9B%96%E6%AE%B5%E9%80%89R-%E8%A6%86%E7%9B%96%E6%9C%80%E5%A4%9A-lt-gt-LC435-%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83\"><span class=\"toc-text\">452.用最少数量的箭引爆气球 acw905区间选点 R排,不覆盖段选R(覆盖最多)  &lt;-&gt;LC435 区间贪心</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#453-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89-n-1%E4%B8%AA-1-x3D-x3D-1%E4%B8%AA-1-cnt-x3D-tot-n-min-x-accumulate-min-element\"><span class=\"toc-text\">453.最小移动次数使数组元素相等 n-1个+1&#x3D;&#x3D;1个-1 cnt&#x3D;tot-n*min_x accumulate min_element</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II-O-n-n-%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4cnt-c-d-res-x3D-cnt-a-b\"><span class=\"toc-text\">454.四数相加II O(n*n) 空间换时间cnt[c+d]++; res+&#x3D;cnt[-(a+b)];</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2-%E8%B4%AA%E5%BF%83-O-nlogn-sort-Greedy%E8%A7%A3%EF%BC%9Amin-gi%E3%80%81Si%E5%8D%95%E8%B0%83%E3%80%81Si%E4%B8%BA-gt-x3D-gi%E7%9A%84first\"><span class=\"toc-text\">455.分发饼干 贪心 O(nlogn) sort+Greedy解：min_gi、Si单调、Si为&gt;&#x3D;gi的first</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%BC%9F%EF%BC%9F%EF%BC%9F456-132%E6%A8%A1%E5%BC%8F-%E5%8D%95%E8%B0%83%E6%A0%88O-n-%E9%9A%BE-%E5%8D%95%E8%B0%83%E6%A0%88%E9%A1%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%98%AF3%EF%BC%8Cmax-k-right-%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%98%AF2%EF%BC%8C%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%98%AFnums-i-%E2%80%9C1%E2%80%9D%E3%80%90Knuth%E6%89%80%E6%8F%90%E5%87%BA%E6%9D%A5%E7%9A%84-stack-sortable-permutation%E3%80%91\"><span class=\"toc-text\">？？？456.132模式 单调栈O(n) 难 单调栈顶维护的是3，max_k(right)维护的是2，枚举的是nums[i] “1”【Knuth所提出来的 stack-sortable permutation】</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#457-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF-%E8%B7%AF%E5%BE%84%E6%A0%87%E8%AE%B0%E5%AF%BB%E7%8E%AF-O-n-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%AF%BB%E7%8E%AF\"><span class=\"toc-text\">457.环形数组循环 (路径标记寻环) O(n) (快慢指针寻环)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#458-%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA-m-min%E5%90%8E%E6%9C%89%E6%AF%92%E6%AD%BB%E4%B8%80%E8%BD%AE-P-min%E5%86%85check-n%E4%B8%AD%E5%93%AA%E6%A1%B6%E6%AF%92%E6%89%80%E9%9C%80min-x%E5%A4%B4%E7%8C%AA-x3D-%E6%95%B0%E5%AD%A6O-logn\"><span class=\"toc-text\">458.可怜的小猪 m_min后有毒死一轮 P_min内check n中哪桶毒所需min_x头猪&#x3D;? 数学O(logn)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%93%9D%E4%B9%A6P73-74-min-t-x3D-n-KMP-next-n-min-t-n\"><span class=\"toc-text\">459.重复的子字符串 蓝书P73~74 min_t&#x3D;n-KMP_next[n] min_t|n</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#460-LFU%E7%BC%93%E5%AD%98-%E8%AE%BE%E8%AE%A1-%E9%9A%BE-%E6%89%A9146-LRU-%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%B5%8C%E5%A5%97-list-RW-O-1-hash-block-x2F-node-cnt-key-erase-size\"><span class=\"toc-text\">460.LFU缓存 设计 难 扩146.LRU 双链表嵌套:list RW_O(1):hash_block&#x2F;node:cnt [key] erase size</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB-bin%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BD%8D%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">461.汉明距离 bin不同的位数：^</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#462-%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89II-%E9%80%891-1%E6%88%96-1-LC453-x3D-x3D-acw104-%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80%EF%BC%9A%E6%B1%82sigma%E4%B8%AD%E4%BD%8D%E6%95%B0dist%EF%BC%81\"><span class=\"toc-text\">462.最少移动次数使数组元素相等II 选1+1或-1[LC453] &#x3D;&#x3D;acw104.货仓选址：求sigma中位数dist！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF-%E4%B8%8D%E7%94%A8floodfill-x3D-x3D-1%E5%BE%AA%E7%8E%AFjudge%E5%8D%B3%E5%8F%AF%EF%BC%9A%E5%87%BA%E7%95%8C-10%E4%BA%A4%E7%95%8C\"><span class=\"toc-text\">463.岛屿的周长 不用floodfill &#x3D;&#x3D;1循环judge即可：出界 10交界</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97-%E5%8D%9A%E5%BC%88%E8%AE%BA-1-n%E4%B8%8D%E9%87%8D%E9%80%89-first-gt-x3D-m-win-sum-i-1-gt-x3D-m-x2F-x2F-%E5%BD%93%E5%89%8D%E5%B1%80wo%E5%85%88%E8%83%9C-dp-x-1-lt-lt-i-x2F-x2F-%E4%B8%8B%E4%B8%80%E5%B1%80%E9%9D%A2%E5%BF%85%E8%B4%A5-wo%E8%83%9C-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">464.我能赢吗 博弈论 1~n不重选 first&gt;&#x3D;m_win sum + i + 1 &gt;&#x3D; m&#x2F;&#x2F;当前局wo先胜\t!dp(x + (1 &lt;&lt; i))&#x2F;&#x2F;下一局面必败,wo胜 记忆化搜索</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#465\"><span class=\"toc-text\">465.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#466-%E7%BB%9F%E8%AE%A1%E9%87%8D%E5%A4%8D%E4%B8%AA%E6%95%B0-%E7%A0%81%E5%8A%9B%E5%80%BC%E9%9A%BE%EF%BC%81\"><span class=\"toc-text\">466.统计重复个数 码力值难！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#467-%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8F%8C%E6%8C%87%E9%92%88-%E7%9B%B8%E8%BF%9E-i-j-%E4%BB%A5p-i-%E4%B8%BA%E8%B5%B7%E7%82%B9%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2maxLen%E6%B1%82%E5%92%8C\"><span class=\"toc-text\">467.环绕字符串中唯一的子字符串 双指针 相连[i,j) 以p[i]为起点的连续子串maxLen求和</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#468-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80-%E6%A8%A1%E6%8B%9F-%E5%AF%B9%E7%A7%B0%E7%AE%80%E6%B4%81%E5%87%BD%E6%95%B0%E7%BC%96%E7%A0%81-4-6-split-4-6-check\"><span class=\"toc-text\">468.验证IP地址 模拟 对称简洁函数编码 .4:6 split 4 6 check</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#469\"><span class=\"toc-text\">469.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#470-%E7%94%A8Rand7-%E5%AE%9E%E7%8E%B0Rand10-0-6-7-1-7-gt-40%E5%9B%9E%E7%82%89-10\"><span class=\"toc-text\">470.用Rand7()实现Rand10() (0~6)*7+(1~7) &gt;40回炉 %10</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#471\"><span class=\"toc-text\">471.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TLE%EF%BC%9F472-%E8%BF%9E%E6%8E%A5%E8%AF%8D-hash-DP-O-n-3-m-%E5%90%91%E5%90%8E%E8%BD%AC%E7%A7%BB-f-i-lt-0-continue-f-n-gt-1-return-true-acw841-str-hash%E5%8F%AF%E4%BC%98%E5%8C%96%E8%87%B3O-n-n-m\"><span class=\"toc-text\">TLE？472.连接词 hash+DP:O(n^3*m) 向后转移 f[i]&lt;0 continue; f[n]&gt;1 return true;  acw841.str_hash可优化至O(n*n*m)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#473-%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2-LC698-%E7%BB%8F%E5%85%B8dfs%E5%89%AA%E6%9E%9D%EF%BC%9A%E6%8B%BC4%E6%A0%B9%E7%AD%89%E9%95%BF-%E6%89%A9%E5%B1%95%EF%BC%9A%E6%8F%90%E9%AB%98%E8%AF%BE-%E6%90%9C%E7%B4%A2-acw167-%E6%9C%A8%E6%A3%92%EF%BC%9A%E6%8B%BCm%E6%A0%B9%E7%AD%89%E9%95%BF-%E8%93%9D%E4%B9%A6P104%EF%BC%81%EF%BC%81%EF%BC%81-%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8Fsort-3%E6%A0%B9true-%E5%A4%B1%E8%B4%A5%EF%BC%9A%E5%9B%9E%E6%BA%AFst-%E6%9F%90%E6%9D%A1%E8%BE%B9%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E6%A0%B9-x2F-%E6%9C%80%E5%90%8E%E4%B8%80%E6%A0%B9-false-nums-sorted%E8%B7%B3%E8%BF%87%E7%AD%89%E9%95%BF\"><span class=\"toc-text\">473.火柴拼正方形[LC698] 经典dfs剪枝：拼4根等长 扩展：提高课_搜索_acw167.木棒：拼m根等长 蓝书P104！！！ 从大到小sort 3根true 失败：回溯st  某条边上的第一根&#x2F;最后一根 false nums_sorted跳过等长</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#474-%E4%B8%80%E5%92%8C%E9%9B%B6-%E6%9C%80%E5%A4%9Am0n1%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E9%9B%86size-%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8%E4%B8%8A-x3D-%E8%83%8C%E5%8C%85-acw8-%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-01%E8%83%8C%E5%8C%85-%E7%89%A9%E5%93%81%E5%8F%AA%E8%83%BD%E7%94%A8%E4%B8%80%E6%AC%A1-%E9%80%86%E5%BA%8F-f-i-1-j-vi-k-mi-wi-maxCnt-wi-x3D-1\"><span class=\"toc-text\">474.一和零 最多m0n1的最大子集size [选择问题本质上&#x3D;背包] acw8.二维费用的背包问题 01背包:物品只能用一次 逆序  f[i-1,j-vi,k-mi]+wi maxCnt:wi&#x3D;1</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#475-%E4%BE%9B%E6%9A%96%E5%99%A8-%E9%83%BD%E8%83%BD%E4%BE%9B%E4%B8%8A%E7%9A%84min%E4%BE%9B%E6%9A%96%E5%8D%8A%E5%BE%84-x3D-O-nlogn-%E4%BA%8C%E5%88%86-%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E5%8D%95%E8%B0%83%E6%80%A7-%E6%88%BF%E5%AD%90%E5%8F%B3%E7%A7%BB%E5%8C%BA%E9%97%B4%E5%8F%B3%E7%A7%BB-j-%E8%83%BD%E8%A6%86%E7%9B%96%E5%BD%93%E5%89%8D%E6%88%BF%E5%AD%90%E7%9A%84%E6%9C%80%E5%B7%A6%E4%BE%A7%E5%8C%BA%E9%97%B4-check-%E9%83%BD%E8%83%BD%E8%A6%86%E7%9B%96%E5%88%B0\"><span class=\"toc-text\">475.供暖器 都能供上的min供暖半径(&#x3D;) O(nlogn)二分+双指针：单调性[房子右移区间右移] j:能覆盖当前房子的最左侧区间 check:都能覆盖到</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0-%E4%BD%8Ecnt%E4%BD%8D-amp-cnt%E4%B8%AA%E5%85%A81-%E5%8F%96%E5%8F%8D-cnt-x3D-31%E4%BC%9A%E6%BA%A2%E5%87%BAint\"><span class=\"toc-text\">476.数字的补数 低cnt位[&amp;cnt个全1]取反 cnt&#x3D;31会溢出int</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C-%E6%8C%89%E4%BD%8D%E7%BB%9F%E8%AE%A1-%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86%EF%BC%9Abin%E7%AC%ACi%E4%BD%8D-x3D-0cnt-%E7%AC%ACi%E4%BD%8D-x3D-1cnt-O-31n\"><span class=\"toc-text\">477.汉明距离总和 按位统计 乘法原理：bin第i位&#x3D;0cnt * 第i位&#x3D;1cnt O(31n)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#478-%E5%9C%A8%E5%9C%86%E5%86%85%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%82%B9-%E6%A1%86%E5%86%85%E9%87%87-1-1-%E5%9C%86%E5%A4%96%E5%9B%9E%E7%82%89%E3%80%81%E6%9E%81%E5%9D%90%E6%A0%87%E7%9B%B4%E6%8E%A5%E9%87%87sqrt-r-2-0-1-M-PI-1-0-%E3%80%81-double\"><span class=\"toc-text\">478.在圆内随机生成点 框内采(-1,1)圆外回炉、极坐标直接采sqrt(r^2 * (0,1)) M_PI  1.0*、(double)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#479-%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E6%95%B0%E4%B9%98%E7%A7%AF-n%E4%BD%8D%E6%95%B0%E7%9A%84-3-3-x3D-9-%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8F%E6%9E%9A%E4%B8%BE%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%9C%E2%80%9Di-reverse-i%E2%80%9D-stoll-%E6%9E%9A%E4%B8%BE%E8%BE%83%E5%A4%A7n%E4%BD%8D%E6%95%B0a-gt-x3D-b-a-a-gt-x3D-ab-x3D-num-for-j-j-gt-x3D-num-num-j-x3D-x3D-0\"><span class=\"toc-text\">479.最大回文数乘积(n位数的) 3*3&#x3D;9 从大到小枚举回文结果”i+reverse_i” stoll 枚举较大n位数a&gt;&#x3D;b a*a&gt;&#x3D;[ab&#x3D;num] for(j*j &gt;&#x3D; num)num%j &#x3D;&#x3D; 0</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#480-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0-%E5%8A%A8%E6%80%81%E4%B8%AD%E4%BD%8D%E6%95%B0-O-nlogn-%E5%AF%B9%E9%A1%B6%E5%A0%86-multiset-%E4%BB%BB%E6%84%8F-rbTree-init-get-%E6%BB%91%E5%8A%A8-x-y%E8%B0%83%E6%95%B4%E4%B8%BAr%E5%A4%9A1-gt-lt-get-median\"><span class=\"toc-text\">480.滑动窗口中位数 +-动态中位数 O(nlogn)对顶堆 multiset:-任意(rbTree) init get 滑动:+x-y调整为r多1-&gt;&lt;- get_median</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#481-%E7%A5%9E%E5%A5%87%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-cnt%E4%B8%B2-x3D-%E5%8E%9F%E4%B8%B2-%E6%B1%82%E5%89%8Dn%E4%BD%8Dcnt1-%E6%A8%A1%E6%8B%9F-k-x3D-3-k-x3D-1%E3%80%812%E4%BA%A4%E6%9B%BF-s-x3D-s-i-%E4%B8%AAk\"><span class=\"toc-text\">481.神奇的字符串 cnt串&#x3D;原串 求前n位cnt1 模拟: k&#x3D;3-k&#x3D;1、2交替 s+&#x3D;s[i]个k</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#482-%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%E5%8C%96-%E2%80%98-%E2%80%98K%E4%B8%AA%E4%B8%80%E9%9A%94-%E4%BD%99%E6%95%B0%E5%9C%A8%E5%89%8D-if%E6%9C%89%EF%BC%81-toupper-%E6%A8%A1%E6%8B%9F-%E5%85%88%E5%8E%BB%E2%80%99-%E2%80%98-if-res-size-res-x3D-%E2%80%99-%E2%80%98-x2F-x2F-%E6%B2%A1%E4%BD%99%E6%95%B0-res%E7%A9%BA-%E4%B8%8D%E5%8A%A0%E5%89%8D%E5%AF%BC%E2%80%99-%E2%80%98\"><span class=\"toc-text\">482.密钥格式化 ‘-‘K个一隔 余数在前[if有！] toupper 模拟:先去’-‘ if(res.size())res+&#x3D;’-‘;&#x2F;&#x2F;没余数 res空 不加前导’-‘!</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#483-%E6%9C%80%E5%B0%8F%E5%A5%BD%E8%BF%9B%E5%88%B6-k-gt-x3D-2-%E5%85%A81-%E4%BA%8C%E5%88%86-gt-%E6%95%B0%E5%AD%A6%E5%A4%B9%E9%80%BC-stoll-pow-1-0-x2F-%E6%9E%9A%E4%B8%BEk%E8%BF%9B%E5%88%B6%E6%95%B0%E4%BD%8D%E6%95%B0t-t-x3D-log2-n-1-t-gt-x3D-3-0t%E6%AC%A1-k-1-x3D-k%E8%BF%9B%E5%88%B6t%E4%BD%8D%E5%85%A81-x3D-r-x3D-x3D-n-%E7%89%B9%E5%88%A4%EF%BC%9At-x3D-2%E6%97%B6k-x3D-n-1-%E5%9B%A0%E4%B8%BA-n-1-1-x3D-n\"><span class=\"toc-text\">483.最小好进制 k&gt;&#x3D;2 全1 二分-&gt;数学夹逼 stoll pow 1.0&#x2F; 枚举k进制数位数t:t&#x3D;log2(n)+1;t &gt;&#x3D; 3   0t次*k+1&#x3D;k进制t位全1&#x3D;r&#x3D;&#x3D;n 特判：t&#x3D;2时k&#x3D;n-1 因为(n-1)+1&#x3D;n</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#484\"><span class=\"toc-text\">484.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-easy%E5%8F%8C%E6%8C%87%E9%92%88\"><span class=\"toc-text\">485.最大连续1的个数 easy双指针</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6-%E5%8D%9A%E5%BC%88%E8%AE%BA-%E5%8C%BA%E9%97%B4DP%EF%BC%9A%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E6%9E%9A%E4%B8%BE%E9%A1%BA%E5%BA%8Flen-i-j-x3D-i-len-1-%E3%80%81%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E9%A6%96%E5%B0%BE%E5%8F%96-wo%E5%85%88%E6%89%8B%E8%83%9C%E5%90%A6-f-i-j-%E4%BD%99-i-j-wo-ta%E5%88%86%E6%95%B0%E7%9A%84max%E5%B7%AE%E5%80%BC-f-i-j-x3D-max-f-i-1-j-ai-f-i-j-1-aj-len-x3D-x3D-1-f-ij-x3D-nums-i-return-f-0-n-1-gt-x3D-0\"><span class=\"toc-text\">486.预测赢家 博弈论[区间DP：循环注意枚举顺序len i(j&#x3D;i+len-1)、记忆化搜索] 首尾取 wo先手胜否 f(i,j):余(i,j) wo-ta分数的max差值 f(i,j)&#x3D;max(-f(i+1,j)+ai,-f(i,j-1)+aj)  len&#x3D;&#x3D;1:f[ij]&#x3D;nums[i]  return f[0,n-1]&gt;&#x3D;0;</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#487\"><span class=\"toc-text\">487.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%94488-%E7%A5%96%E7%8E%9B%E6%B8%B8%E6%88%8F-%E7%88%86%E6%90%9C-%E5%89%AA%E6%9E%9D-%E9%9A%BE-code2%E2%80%A6ing\"><span class=\"toc-text\">—488.祖玛游戏 爆搜+剪枝 难 code2…ing</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#489\"><span class=\"toc-text\">489.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#490\"><span class=\"toc-text\">490.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-%E6%89%80%E6%9C%89%E6%96%B9%E6%A1%88%EF%BC%9A%E7%88%86%E6%90%9C-%E5%88%A4%E9%87%8D%EF%BC%9A%E6%9E%9A%E4%B8%BE%E5%BD%93%E5%89%8D%E5%BA%8F%E5%88%97%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%B0%E4%BB%8E%E5%93%AA%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B%E9%80%89-unordered-set-count-insert\"><span class=\"toc-text\">491.递增子序列 所有方案：爆搜 判重：枚举当前序列下一个数从哪一个位置开始选 unordered_set count insert</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2-L-gt-x3D-W-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE-O-%E2%88%9An\"><span class=\"toc-text\">492.构造矩形 L&gt;&#x3D;W 暴力枚举 O(√n)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#493-%E7%BF%BB%E8%BD%AC%E5%AF%B9-ai-gt-2-aj%E9%80%86%E5%BA%8F%E5%AF%B9cnt-%E7%A6%BB%E6%95%A3%E5%8C%96-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E5%88%86%E6%B2%BB-%E9%80%92%E5%BD%92-ij%E8%B7%A8lr-j-mid-1-%E9%80%89%E5%B0%8F%E7%9A%84%E5%BD%92%E5%B9%B6-w-0%E2%80%A6%E8%A6%86%E7%9B%96%E5%8E%9F%E6%95%B0%E7%BB%84n-l%E2%80%A6\"><span class=\"toc-text\">493.翻转对 ai&gt;2*aj逆序对cnt 离散化+树状数组 !!!归并排序[分治]: 递归 ij跨lr j-(mid+1) 选小的归并 w[0…覆盖原数组n[l…</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#494-%E7%9B%AE%E6%A0%87%E5%92%8C-%E5%8F%B7case%E6%95%B0-%E6%A0%87%E5%87%86DP%EF%BC%9Af-x3D-%E5%89%8Di%E4%B8%AA%E6%80%BB%E5%92%8Cj%E7%9A%84case%E6%95%B0-S-x3D-1k-1k-offset-x3D-1k-a-i-1\"><span class=\"toc-text\">494.目标和 +-号case数 标准DP：f&#x3D;前i个总和j的case数 S&#x3D;[-1k,1k] offset&#x3D;1k a[i-1]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#495-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB-%E5%B0%8F%E6%A8%A1%E6%8B%9F-%E6%80%BB%E4%B8%AD%E6%AF%92%E6%97%B6%E9%97%B4-x3D-min-%E6%94%BB%E5%87%BB%E9%97%B4%E9%9A%94%EF%BC%8C%E4%B8%AD%E6%AF%92%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8C%81%E7%BB%AD\"><span class=\"toc-text\">495.提莫攻击 小模拟 总中毒时间+&#x3D;min(攻击间隔，中毒持续时间)+最后一次持续</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I-1%E4%B8%ADnum%E5%9C%A82%E4%B8%ADpos-%E5%8F%B3%E8%BE%B9first-gt-lt-q-%E5%8D%87-%E6%A8%A1%E6%9D%BFacw830-%E5%8D%95%E8%B0%83%E6%A0%88\"><span class=\"toc-text\">496.下一个更大元素I 1中num在2中pos 右边first&gt;[] &lt;-q[升 模板acw830.单调栈</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#497-%E9%9D%9E%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%82%B9-%E5%8C%85%E6%8B%ACv-e-%E6%A6%82%E7%8E%87%E4%B8%8E%E9%9D%A2%E7%A7%AF%E6%88%90%E6%AD%A3%E6%AF%94-%E7%BA%BF%E6%AE%B5%E9%95%BF-x3D-S-%E5%89%8D%E7%BC%80%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86O-n-%E9%9A%8F%E6%9C%BA-1-back-k%E4%BA%8C%E5%88%86O-logn-%E5%88%B0%E7%9F%A9%E5%BD%A2-lt-x3D-r-1-%E9%9A%8F%E6%9C%BAx-y-x-x3D-t0-0-dx-1\"><span class=\"toc-text\">497.非重叠矩形中的随机点 [包括v,e] 概率与面积成正比: 线段长&#x3D;S 前缀和预处理O(n) 随机[1~back]k二分O(logn)到矩形&lt;&#x3D;r-1] 随机x y x&#x3D;t0+[0,dx-1]</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86-Z%E5%AD%97%E6%A8%A1%E6%8B%9FO-nm-%E6%8C%89%E7%85%A7%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%9D%90%E6%A0%87%E7%9A%84%E5%92%8C%E6%9E%9A%E4%B8%BE-%E2%80%9C%E4%B8%8A-%E5%8F%B3%E8%BE%B9%E2%80%9D%E6%9D%A1%E6%96%9C%E7%BA%BFi-x3D-%E8%A1%8Cj-%E5%88%97-%E4%B8%8A-%E8%A1%8C%E2%80%93-n-1-n-m-2-i-x3D-1-m-i\"><span class=\"toc-text\">498.对角线遍历 Z字模拟O(nm) 按照每个对角线坐标的和枚举 “上+右边”条斜线i&#x3D;行j+列 上 行– n-1-(n+m-2-i)&#x3D;1-m+i</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#499\"><span class=\"toc-text\">499.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#500-%E9%94%AE%E7%9B%98%E8%A1%8C-%E5%90%8C%E8%A1%8C%E6%89%93%E5%87%BAwords-%E6%A8%A1%E6%8B%9F-ch-line-S-insert-hash-tolower-c-sz-x3D-x3D-1\"><span class=\"toc-text\">500.键盘行 同行打出words[] 模拟 ch,line S.insert(hash[tolower(c)]) sz&#x3D;&#x3D;1</span></a></li></ol>","author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"TiKV学习","uid":"b4b469edf0864513cb59986e5c3c8faf","slug":"TiKV学习","date":"2021-12-17T03:10:40.000Z","updated":"2022-08-22T07:58:37.485Z","comments":true,"path":"api/articles/TiKV学习.json","keywords":null,"cover":"http://p7.qhimg.com/bdm/960_593_0/t0126965e612a7835ac.jpg","text":"[TOC] 开源 $ git config –global http.sslBackend “openssl” $ git config –global http.sslCAInfo “D:&#x2F;Software&#x2F;Program Files&#x2F;Git&#x...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"分布式存储引擎TiKV","slug":"分布式存储引擎TiKV","count":1,"path":"api/categories/分布式存储引擎TiKV.json"}],"tags":[{"name":"TiKV","slug":"TiKV","count":1,"path":"api/tags/TiKV.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"SpringBoot2[atguigu-sb2-bxl]","uid":"4f5f8b1adeea7120197c416f19615115","slug":"SpringBoot2","date":"2021-06-16T14:11:41.000Z","updated":"2022-08-22T07:59:52.697Z","comments":true,"path":"api/articles/SpringBoot2.json","keywords":null,"cover":"http://p4.qhimg.com/bdm/480_296_0/t01c2e33bb9aaef0a72.jpg","text":"[TOC] idea：ctrl+alt+v 快速引进变量，自动补全函数返回值 &#x3D;&#x3D;win+shift+s&#x3D;&#x3D;：windows截屏工具快捷键！！！ 第一季：SpringBoot2核心技术-基础入门01、背景Faas：函数式服务 Serverl...","link":"","photos":[],"count_time":{"symbolsCount":"177k","symbolsTime":"2:41"},"categories":[{"name":"SpringBoot2","slug":"SpringBoot2","count":1,"path":"api/categories/SpringBoot2.json"}],"tags":[{"name":"SpringBoot2","slug":"SpringBoot2","count":1,"path":"api/tags/SpringBoot2.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}