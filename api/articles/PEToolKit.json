{"title":"PEToolKit","uid":"a1e4caef696c9dadabec86ca767b0052","slug":"PEToolKit","date":"2020-08-14T15:41:26.000Z","updated":"2022-08-22T07:52:21.331Z","comments":true,"path":"api/articles/PEToolKit.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/960_593_0/t016c300191cf22c2f0.jpg","content":"<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;PE课后作业参考代码（含测试代码）\n&#x2F;&#x2F;https:&#x2F;&#x2F;blog.csdn.net&#x2F;Kwansy&#x2F;article&#x2F;details&#x2F;106234264\n\n#include &quot;headers.h&quot;\n\n&#x2F;&#x2F; 读取PE文件到内存中，返回读取的字节数；读取失败返回0\nDWORD ReadPEFile(LPCSTR lpszFile, LPVOID *pFileBuffer)\n&#123;\n\tFILE *pFile &#x3D; NULL;\n\tDWORD dwFileSize &#x3D; 0;\n\tpFile &#x3D; fopen(lpszFile, &quot;rb&quot;);\n\tif (pFile &#x3D;&#x3D; NULL) \n\t&#123;\n\t\tprintf(&quot;打开文件失败\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\tfseek(pFile, 0, SEEK_END);\n\tdwFileSize &#x3D; ftell(pFile);\n\tfseek(pFile, 0, SEEK_SET);\n\t*pFileBuffer &#x3D; malloc(dwFileSize);\n\tif (*pFileBuffer &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\tfclose(pFile);\n\t\treturn 0;\n\t&#125;\t\n\tDWORD dwRead &#x3D; fread(*pFileBuffer, 1, dwFileSize, pFile);\n\tfclose(pFile);\n\tif (dwRead !&#x3D; dwFileSize)\n\t&#123;\n\t\tprintf(&quot;文件大小 &#x3D; %d\\t实际写入内存字节 &#x3D; %d\\t写入失败\\n&quot;, dwFileSize, dwRead);\n\t\treturn 0;\n\t&#125;\n\tif (!IsPEFile(*pFileBuffer, dwRead))\n\t&#123;\n\t\tprintf(&quot;不是有效的PE文件\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\treturn dwRead;\n&#125;\n\n&#x2F;&#x2F; 验证是否PE文件\nBOOL IsPEFile(LPVOID pFileBuffer, DWORD dwSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tif (*((PWORD)pDosHeader) !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\tprintf(&quot;不是有效的MZ标志\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\tif (pNTHeader-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\tprintf(&quot;不是有效的PE标记\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\n\treturn TRUE;\n&#125;\n\n&#x2F;&#x2F; 打印PE头信息\nVOID PrintNTHeaders(LPCSTR lpszFile)\n&#123;\n\tLPVOID pFileBuffer &#x3D; NULL;\n\tDWORD dwFileSize &#x3D; ReadPEFile(lpszFile, &amp;pFileBuffer);\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\t\n\tif (dwFileSize &#x3D;&#x3D; 0)\n\t&#123;\n\t\tprintf(&quot;读取文件失败\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\t&#x2F;&#x2F;打印DOS头\n\tputs(&quot;----DOS HEADER----&quot;);\n\tprintf(&quot;e_magic &#x3D; %x\\n&quot;, pDosHeader-&gt;e_magic);\n\tprintf(&quot;e_lfanew &#x3D; %x\\n&quot;, pDosHeader-&gt;e_lfanew);\t\n\t&#x2F;&#x2F;打印NT头\t\n\tprintf(&quot;----标准PE头----\\n&quot;);\n\tprintf(&quot;Machine &#x3D; %x\\n&quot;, pPEHeader-&gt;Machine);\n\tprintf(&quot;NumberOfSections &#x3D; %x\\n&quot;, pPEHeader-&gt;NumberOfSections);\n\tprintf(&quot;TimeDateStamp &#x3D; %x\\n&quot;, pPEHeader-&gt;TimeDateStamp);\n\tprintf(&quot;PointerToSymbolTable &#x3D; %x\\n&quot;, pPEHeader-&gt;PointerToSymbolTable);\n\tprintf(&quot;NumberOfSymbols &#x3D; %x\\n&quot;, pPEHeader-&gt;NumberOfSymbols);\n\tprintf(&quot;SizeOfOptionalHeader &#x3D; %x\\n&quot;, pPEHeader-&gt;SizeOfOptionalHeader);\n\tprintf(&quot;Characteristics &#x3D; %x\\n&quot;, pPEHeader-&gt;Characteristics);\n\t&#x2F;&#x2F;可选PE头\t\n\tprintf(&quot;----可选PE头----\\n&quot;);\n\tprintf(&quot;Magic &#x3D; %x\\n&quot;, pOptionHeader-&gt;Magic);\n\tprintf(&quot;MajorLinkerVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MajorLinkerVersion);\n\tprintf(&quot;MinorLinkerVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MinorLinkerVersion);\n\tprintf(&quot;SizeOfCode &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfCode);\n\tprintf(&quot;SizeOfInitializedData &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfInitializedData);\n\tprintf(&quot;SizeOfUninitializedData &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfUninitializedData);\n\tprintf(&quot;AddressOfEntryPoint &#x3D; %x\\n&quot;, pOptionHeader-&gt;AddressOfEntryPoint);\n\tprintf(&quot;BaseOfCode &#x3D; %x\\n&quot;, pOptionHeader-&gt;BaseOfCode);\n\tprintf(&quot;BaseOfData &#x3D; %x\\n&quot;, pOptionHeader-&gt;BaseOfData);\n\tprintf(&quot;ImageBase &#x3D; %x\\n&quot;, pOptionHeader-&gt;ImageBase);\n\tprintf(&quot;SectionAlignment &#x3D; %x\\n&quot;, pOptionHeader-&gt;SectionAlignment);\n\tprintf(&quot;FileAlignment &#x3D; %x\\n&quot;, pOptionHeader-&gt;FileAlignment);\n\tprintf(&quot;MajorOperatingSystemVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MajorOperatingSystemVersion);\n\tprintf(&quot;MinorOperatingSystemVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MinorOperatingSystemVersion);\n\tprintf(&quot;MajorImageVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MajorImageVersion);\n\tprintf(&quot;MinorImageVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MinorImageVersion);\n\tprintf(&quot;MajorSubsystemVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MajorSubsystemVersion);\n\tprintf(&quot;MinorSubsystemVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MinorSubsystemVersion);\n\tprintf(&quot;Win32VersionValue &#x3D; %x\\n&quot;, pOptionHeader-&gt;Win32VersionValue);\n\tprintf(&quot;SizeOfImage &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfImage);\n\tprintf(&quot;SizeOfHeaders &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfHeaders);\n\tprintf(&quot;CheckSum &#x3D; %x\\n&quot;, pOptionHeader-&gt;CheckSum);\n\tprintf(&quot;Subsystem &#x3D; %x\\n&quot;, pOptionHeader-&gt;Subsystem);\n\tprintf(&quot;DllCharacteristics &#x3D; %x\\n&quot;, pOptionHeader-&gt;DllCharacteristics);\n\tprintf(&quot;SizeOfStackReserve &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfStackReserve);\n\tprintf(&quot;SizeOfStackCommit &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfStackCommit);\n\tprintf(&quot;SizeOfHeapReserve &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfHeapReserve);\n\tprintf(&quot;SizeOfHeapCommit &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfHeapCommit);\n\tprintf(&quot;LoaderFlags &#x3D; %x\\n&quot;, pOptionHeader-&gt;LoaderFlags);\n\tprintf(&quot;NumberOfRvaAndSizes &#x3D; %x\\n&quot;, pOptionHeader-&gt;NumberOfRvaAndSizes);\n\t&#x2F;&#x2F;打印节表\t\n\tchar sectionName[9];\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tmemset(sectionName, 0, 9);\n\t\tmemcpy(sectionName, pSectionHeader-&gt;Name, 8);\n\t\tprintf(&quot;----节表: [%s]----\\n&quot;, sectionName);\n\t\tprintf(&quot;VirtualSize &#x3D; %x\\n&quot;, pSectionHeader-&gt;Misc.VirtualSize);\n\t\tprintf(&quot;VirtualAddress &#x3D; %x\\n&quot;, pSectionHeader-&gt;VirtualAddress);\n\t\tprintf(&quot;SizeOfRawData &#x3D; %x\\n&quot;, pSectionHeader-&gt;SizeOfRawData);\n\t\tprintf(&quot;PointerToRawData &#x3D; %x\\n&quot;, pSectionHeader-&gt;PointerToRawData);\n\t\tprintf(&quot;Characteristics &#x3D; %x\\n&quot;, pSectionHeader-&gt;Characteristics);\n\t\tpSectionHeader++;\n\t&#125;\n\t&#x2F;&#x2F;释放内存\n\tfree(pFileBuffer);\n&#125;\n\n&#x2F;&#x2F; 将 FileBuffer 拉伸成 ImageBuffer 并写入到新的缓冲区\n&#x2F;&#x2F; 返回 ImageBuffer 的大小；失败返回0\nDWORD CopyFileBufferToImageBuffer(LPVOID pFileBuffer, LPVOID *pImageBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t*pImageBuffer &#x3D; malloc(pOptionHeader-&gt;SizeOfImage);\n\tif (*pImageBuffer &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\tmemset(*pImageBuffer, 0, pOptionHeader-&gt;SizeOfImage);\n\t&#x2F;&#x2F; 复制DOS头+PE头+可选PE头+节表+文件对齐\n\tmemcpy(*pImageBuffer, pFileBuffer, pOptionHeader-&gt;SizeOfHeaders);\n\t&#x2F;&#x2F; 遍历节表，复制所有节\t\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tmemcpy((LPVOID)((DWORD)(*pImageBuffer) + pSectionHeader[i].VirtualAddress), \\\n\t\t\t(LPVOID)((DWORD)pFileBuffer + pSectionHeader[i].PointerToRawData), \\\n\t\t\tpSectionHeader[i].SizeOfRawData);\n\t&#125;\n\treturn pOptionHeader-&gt;SizeOfImage;\n&#125;\n\n&#x2F;&#x2F; 将 ImageBuffer 变成文件对齐的 FileBuffer 写入新的缓冲区\n&#x2F;&#x2F; 返回复制的大小，失败返回0\nDWORD CopyImageBufferToFileBuffer(LPVOID pImageBuffer, LPVOID *pNewBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pImageBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\t&#x2F;&#x2F; 最后一个节表\n\tPIMAGE_SECTION_HEADER pLastSectionHeader &#x3D; pSectionHeader + pPEHeader-&gt;NumberOfSections - 1;\n\t&#x2F;&#x2F; 计算要复制的字节\n\t&#x2F;&#x2F; 这一步有BUG，当最后一个节后面还有数据时（多见于控制台程序），丢失数据  ????????????？？？？？？？？???????????\n\tDWORD dwFileBufferSize &#x3D; pLastSectionHeader-&gt;PointerToRawData + pLastSectionHeader-&gt;SizeOfRawData;\n\t*pNewBuffer &#x3D; malloc(dwFileBufferSize);\t\n\tif (*pNewBuffer &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\tmemset(*pNewBuffer, 0, dwFileBufferSize);\n\t&#x2F;&#x2F; 复制DOS头+PE头+可选PE头+节表+文件对齐\n\tmemcpy(*pNewBuffer, pImageBuffer, pOptionHeader-&gt;SizeOfHeaders);\n\t&#x2F;&#x2F; 遍历节表，复制文件对齐后的节\t\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tmemcpy((LPVOID)((DWORD)(*pNewBuffer) + pSectionHeader[i].PointerToRawData), \\\n\t\t\t(LPVOID)((DWORD)pImageBuffer + pSectionHeader[i].VirtualAddress), \\\n\t\t\tpSectionHeader[i].SizeOfRawData);\n\t&#125;\n\treturn dwFileBufferSize;\n&#125;\n\n&#x2F;&#x2F; 内存数据写入文件\nBOOL MemoryToFile(LPVOID pMemBuffer, DWORD dwSize, LPCSTR lpszFile)\n&#123;\n\tFILE *fp &#x3D; NULL;\n\tfp &#x3D; fopen(lpszFile, &quot;wb+&quot;);\n\tif (fp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;打开文件失败\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\tDWORD dwWritten &#x3D; fwrite(pMemBuffer, 1, dwSize, fp);\n\tif (dwWritten !&#x3D; dwSize)\n\t&#123;\n\t\tprintf(&quot;写入了 %d 字节，不等于 %d\\n&quot;, dwWritten, dwSize);\n\t\tfclose(fp);\n\t\treturn FALSE;\n\t&#125;\n\tfclose(fp);\n\treturn TRUE;\n&#125;\n\n&#x2F;&#x2F; 向代码节添加MessageBox代码\n&#x2F;&#x2F; 向代码节添加代码不需要担心内存对齐后大小发生变化\n&#x2F;&#x2F; 默认第一个节是代码节，但是这样判断不一定准确，应该遍历节表，根据属性找代码节\nBOOL AddCodeToCodeSec(LPCSTR lpszFile, LPCSTR lpszOutFile)\n&#123;\n\tBYTE shellcode[] &#x3D;\n\t&#123;\n\t\t0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, &#x2F;&#x2F; push 0 push 0 push 0 push 0\n\t\t0xE8, 0x00, 0x00, 0x00, 0x00,\t\t\t\t\t&#x2F;&#x2F; call MessageBoxA\n\t\t0xE9, 0x00, 0x00, 0x00, 0x00\t\t\t\t\t&#x2F;&#x2F; jmp OEP\n\t&#125;;\n\tDWORD dwShellCodeSize &#x3D; 18;\n\tDWORD dwCodeRva &#x3D; 0; &#x2F;&#x2F; 插入的位置RVA\n\tLPVOID pFileBuffer &#x3D; NULL;\n\tLPVOID pImageBuffer &#x3D; NULL;\n\tLPVOID pNewBuffer &#x3D; NULL;\n\t\n\tDWORD dwFileBufferSize &#x3D; 0;\n\tDWORD dwImageBufferSize &#x3D; 0;\n\tDWORD dwNewBufferSize &#x3D; 0;\n\t&#x2F;&#x2F; 读取PE到内存中\n\tif ((dwFileBufferSize &#x3D; ReadPEFile(lpszFile, &amp;pFileBuffer)) &#x3D;&#x3D; 0)\n\t&#123;\n\t\tprintf(&quot;读取失败\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\t&#x2F;&#x2F; 拉伸成内存映像\n\tdwImageBufferSize &#x3D; CopyFileBufferToImageBuffer(pFileBuffer, &amp;pImageBuffer);\n\tif (0 &#x3D;&#x3D; dwImageBufferSize)\n\t&#123;\n\t\tfree(pFileBuffer);\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pImageBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tDWORD dwCodeSecIndex &#x3D; -1;\n\t&#x2F;&#x2F; 遍历节表，找到代码节\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tif ((pSectionHeader[i].Characteristics &amp; 0x60000020) &#x3D;&#x3D; 0x60000020)\n\t\t&#123;\n\t\t\tdwCodeSecIndex &#x3D; i;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif (dwCodeSecIndex &#x3D;&#x3D; -1)\n\t&#123;\n\t\tprintf(&quot;找不到代码节\\n&quot;);\n\t\tfree(pFileBuffer);\n\t\tfree(pImageBuffer);\n\t\treturn FALSE;\n\t&#125;\n\n\t&#x2F;&#x2F; 计算插入点RVA\n\tdwCodeRva &#x3D; pSectionHeader[dwCodeSecIndex].VirtualAddress + pSectionHeader[dwCodeSecIndex].Misc.VirtualSize;\n\t&#x2F;&#x2F; 是否有足够的空间插入代码，要考虑到代码节是最后一个节的情况\n\tif (dwCodeSecIndex + 1 &#x3D;&#x3D; pPEHeader-&gt;NumberOfSections)\n\t&#123;\n\t\tif (dwCodeRva + dwShellCodeSize &gt; pOptionHeader-&gt;SizeOfImage)\n\t\t&#123;\n\t\t\tprintf(&quot;代码节没有足够的空间插入代码\\n&quot;);\n\t\t\tfree(pFileBuffer);\n\t\t\tfree(pImageBuffer);\n\t\t\treturn FALSE;\n\t\t&#125;\n\t&#125;\n\telse\n\t&#123;\n\t\tDWORD dwUnuseSize &#x3D; pSectionHeader[dwCodeSecIndex + 1].VirtualAddress - \\\n\t\t\tpSectionHeader[dwCodeSecIndex].VirtualAddress - pSectionHeader[dwCodeSecIndex].Misc.VirtualSize;\n\t\tif (dwUnuseSize &lt; dwShellCodeSize)\n\t\t&#123;\n\t\t\tprintf(&quot;代码节没有足够的空间插入代码\\n&quot;);\n\t\t\tfree(pFileBuffer);\n\t\t\tfree(pImageBuffer);\n\t\t\treturn FALSE;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 代码插入点偏移 &#x3D; VA + VSIZE\n\tdwCodeRva &#x3D; pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;Misc.VirtualSize;\n\t&#x2F;&#x2F; 代码插入\n\tmemcpy((LPVOID)((DWORD)pImageBuffer + dwCodeRva), shellcode, dwShellCodeSize);\n\t&#x2F;&#x2F; 修正地址\n\tDWORD MsgBoxAddr &#x3D; (DWORD)&amp;MessageBoxA; &#x2F;&#x2F; 获取MessageBox的地址\n\tDWORD hardCodeAddr &#x3D; MsgBoxAddr - (pOptionHeader-&gt;ImageBase + dwCodeRva + 13);\n\tmemcpy((LPVOID)((DWORD)pImageBuffer + dwCodeRva + 9), &amp;hardCodeAddr, 4);\n\thardCodeAddr &#x3D; pOptionHeader-&gt;ImageBase + pOptionHeader-&gt;AddressOfEntryPoint \\\n\t- (pOptionHeader-&gt;ImageBase + dwCodeRva + 18);\n\tmemcpy((LPVOID)((DWORD)pImageBuffer + dwCodeRva + 14), &amp;hardCodeAddr, 4);\n\t&#x2F;&#x2F; 修改入口点\n\tpOptionHeader-&gt;AddressOfEntryPoint &#x3D; dwCodeRva;\n\t&#x2F;&#x2F; 转成文件对齐\n\tdwNewBufferSize &#x3D; CopyImageBufferToFileBuffer(pImageBuffer, &amp;pNewBuffer);\n\tif (dwNewBufferSize !&#x3D; dwFileBufferSize)\n\t&#123;\n\t\tprintf(&quot;可能丢失数据\\n&quot;);\n\t&#125;\n\tMemoryToFile(pNewBuffer, dwNewBufferSize, lpszOutFile);\n\tfree(pFileBuffer);\n\tfree(pImageBuffer);\n\tfree(pNewBuffer);\n\tprintf(&quot;插入代码成功\\n&quot;);\n\treturn TRUE;\n&#125;\n\n&#x2F;&#x2F; 计算对齐的函数，如偏移为900，对齐为1000h，返回1000h\nDWORD Align(DWORD dwOffset, DWORD dwAlign)\n&#123;\n\t&#x2F;&#x2F; 如果偏移小于对齐，向上取整\n\tif (dwOffset &lt;&#x3D; dwAlign) return dwAlign;\n\t&#x2F;&#x2F; 如果偏移大于对齐且不能除尽，向上取整\n\tif (dwOffset % dwAlign)\n\t&#123;\n\t\treturn (dwOffset &#x2F; dwAlign + 1) * dwAlign;\n\t&#125;\n\t&#x2F;&#x2F; 如果能除尽，直接返回offset\n\treturn dwOffset;\n&#125;\n\n&#x2F;&#x2F; RVA 转 FOA\nDWORD RvaToFoa(LPVOID pFileBuffer, DWORD dwRva)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pFileBuffer + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t&#x2F;&#x2F; RVA在文件头中或者文件对齐&#x3D;&#x3D;内存对齐时，RVA&#x3D;&#x3D;FOA  错！第一句是对的，第二句是错的\n\tif (dwRva &lt; pOptionHeader-&gt;SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\n\t&#x2F;&#x2F; 遍历节表，确定偏移属于哪一个节\t\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tif (dwRva &gt;&#x3D; pSectionHeader[i].VirtualAddress &amp;&amp; \\\n\t\t\tdwRva &lt; pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize)\n\t\t&#123;\n\t\t\tint offset &#x3D; dwRva - pSectionHeader[i].VirtualAddress;\n\t\t\treturn pSectionHeader[i].PointerToRawData + offset;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;找不到RVA %x 对应的 FOA，转换失败\\n&quot;, dwRva);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; FOA 转 RVA\nDWORD FoaToRva(LPVOID pFileBuffer, DWORD dwFoa)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pFileBuffer + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\t&#x2F;&#x2F; RVA在文件头中或者文件对齐&#x3D;&#x3D;内存对齐时，RVA&#x3D;&#x3D;FOA  错！第一句是对的，第二句是错的\n\tif (dwFoa &lt; pOptionHeader-&gt;SizeOfHeaders)\n\t&#123;\n\t\treturn dwFoa;\n\t&#125;\n\t\n\t&#x2F;&#x2F; 遍历节表，确定偏移属于哪一个节\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tif (dwFoa &gt;&#x3D; pSectionHeader[i].PointerToRawData &amp;&amp; \\\n\t\t\tdwFoa &lt; pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData)\n\t\t&#123;\n\t\t\tint offset &#x3D; dwFoa - pSectionHeader[i].PointerToRawData;\n\t\t\treturn pSectionHeader[i].VirtualAddress + offset;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;找不到FOA %x 对应的 RVA，转换失败\\n&quot;, dwFoa);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 移动NT头和节表到DOS STUB，该函数在新增节时节表空间不足的情况下调用；返回地址减小值\nDWORD MoveNTHeaderAndSectionHeadersToDosStub(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tLPVOID pDst &#x3D; (LPVOID)((DWORD)pDosHeader + sizeof(IMAGE_DOS_HEADER)); &#x2F;&#x2F; NT头插入点\n\tDWORD dwRet &#x3D; (DWORD)pNTHeader - (DWORD)pDst; &#x2F;&#x2F; 返回地址减小的值\n\tDWORD dwSize &#x3D; 4 + sizeof(IMAGE_FILE_HEADER) + pPEHeader-&gt;SizeOfOptionalHeader +\\\n\t\tsizeof(IMAGE_SECTION_HEADER) * pPEHeader-&gt;NumberOfSections; &#x2F;&#x2F; 移动的字节数\n\tLPVOID pSrc &#x3D; malloc(dwSize);\n\tif (pSrc &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\tmemcpy(pSrc, (LPVOID)pNTHeader, dwSize); &#x2F;&#x2F; 保存要复制的数据\n\tmemset((LPVOID)pNTHeader, 0, dwSize); &#x2F;&#x2F; 清空原数据\n\tmemcpy(pDst, pSrc, dwSize); &#x2F;&#x2F; 移动数据\n\tfree(pSrc);\n\tpDosHeader-&gt;e_lfanew &#x3D; sizeof(IMAGE_DOS_HEADER); &#x2F;&#x2F; 更新 e_lfanew\n\n\treturn dwRet;\n&#125;\n\n&#x2F;&#x2F; 新增一个大小为 newSectionSize 的代码节\n&#x2F;&#x2F; dwFileBufferSize 是原来的文件大小\n&#x2F;&#x2F; 返回新缓冲区的大小，失败返回0\nDWORD AddCodeSection(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwFileBufferSize, DWORD dwNewSectionSize)\n&#123;\n\t&#x2F;&#x2F; 复制一份 pFileBuffer，不要修改原来的数据\n\tLPVOID pFileBuffer2 &#x3D; malloc(dwFileBufferSize);\n\tmemcpy(pFileBuffer2, pFileBuffer, dwFileBufferSize);\n\tpFileBuffer &#x3D; pFileBuffer2;\n\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPWORD pNumberOfSections &#x3D; &amp;(pPEHeader-&gt;NumberOfSections); &#x2F;&#x2F; 节的数量\n\tPIMAGE_SECTION_HEADER pLastSectionHeader &#x3D; pSectionHeader + *pNumberOfSections - 1; &#x2F;&#x2F; 最后一个节表\n\tPIMAGE_SECTION_HEADER pNewSectionHeader &#x3D; pSectionHeader + *pNumberOfSections; &#x2F;&#x2F; 新节表插入点\n\tDWORD newFileBufferSize &#x3D; 0; &#x2F;&#x2F; 新文件的大小\n\n\t&#x2F;&#x2F; 判断最后一个节表后面是否有空闲的80字节\n\tif (80 &gt; (DWORD)pFileBuffer + pOptionHeader-&gt;SizeOfHeaders - (DWORD)pNewSectionHeader)\n\t&#123;\n\t\tprintf(&quot;没有足够的80字节插入新节表\\n&quot;);\n\t\tfree(pFileBuffer2);\n\t\treturn 0;\n\t&#125;\n\n\t&#x2F;&#x2F; 判断空闲的80字节是否全为0，如果不是，则把整个NT头往上挪覆盖dos stub以空出空间插入节表\n\tfor (int i &#x3D; 0; i &lt; 80; i++)\n\t&#123;\n\t\tif (((PBYTE)pNewSectionHeader)[i] !&#x3D; 0)\n\t\t&#123;\t\t\t\n\t\t\tDWORD dwRet &#x3D; MoveNTHeaderAndSectionHeadersToDosStub(pFileBuffer);\n\t\t\tprintf(&quot;节表空间不足，NT头和节表向低地址移动了 %d 字节\\n&quot;, dwRet);\n\t\t\tif (dwRet &lt; 80)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;移动后仍没有足够的80字节空间插入新节表\\n&quot;);\n\t\t\t\tfree(pFileBuffer2);\n\t\t\t\treturn 0;\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F; 更新指针\n\t\t\tpNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\t\t\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\t\t\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\t\t\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\t\tpNumberOfSections &#x3D; &amp;(pPEHeader-&gt;NumberOfSections); &#x2F;&#x2F; 节的数量\n\t\t\tpLastSectionHeader &#x3D; pSectionHeader + *pNumberOfSections - 1; &#x2F;&#x2F; 最后一个节表\n\t\t\tpNewSectionHeader &#x3D; pSectionHeader + *pNumberOfSections; &#x2F;&#x2F; 新节表插入点\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 定义一个 IMAGE_SECTION_HEADER 结构，计算里面的属性\n\tIMAGE_SECTION_HEADER newSectionHeader;\n\tmemcpy(newSectionHeader.Name, &quot;.newsec&quot;, 8);\n\tnewSectionHeader.Misc.VirtualSize &#x3D; Align(dwNewSectionSize, pOptionHeader-&gt;SectionAlignment);\n\tnewSectionHeader.VirtualAddress &#x3D; pLastSectionHeader-&gt;VirtualAddress + \\\n\t\tAlign(pLastSectionHeader-&gt;Misc.VirtualSize, pOptionHeader-&gt;SectionAlignment);\t\n\tnewSectionHeader.SizeOfRawData &#x3D; Align(dwNewSectionSize, pOptionHeader-&gt;FileAlignment);\n\tnewSectionHeader.PointerToRawData &#x3D; pLastSectionHeader-&gt;PointerToRawData + pLastSectionHeader-&gt;SizeOfRawData;\n\tnewSectionHeader.PointerToRelocations &#x3D; 0;\n\tnewSectionHeader.PointerToLinenumbers &#x3D; 0;\n\tnewSectionHeader.NumberOfRelocations &#x3D; 0;\n\tnewSectionHeader.NumberOfLinenumbers &#x3D; 0;\n\tnewSectionHeader.Characteristics &#x3D; 0x60000020;\n\n\t&#x2F;&#x2F; pNewFileBuffer 分配内存，把 pFileBuffer 复制过去，后面的修改都在 pNewFileBuffer 进行\n\t*pNewFileBuffer &#x3D; malloc(dwFileBufferSize + newSectionHeader.SizeOfRawData);\n\tmemcpy(*pNewFileBuffer, pFileBuffer, dwFileBufferSize);\n\tmemset((LPVOID)((DWORD)*pNewFileBuffer + dwFileBufferSize), 0, newSectionHeader.SizeOfRawData); &#x2F;&#x2F; 新增节数据清0\n\n\t&#x2F;&#x2F; 更新指针，指向新内存\t\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\tpNumberOfSections &#x3D; &amp;(pPEHeader-&gt;NumberOfSections);\n\tpLastSectionHeader &#x3D; pSectionHeader + *pNumberOfSections - 1;\n\tpNewSectionHeader &#x3D; pSectionHeader + *pNumberOfSections;\n\n\t&#x2F;&#x2F; 节的数量+1，SizeOfImage是内存中拉伸后的大小\n\t*pNumberOfSections +&#x3D; 1;\t\n\tpOptionHeader-&gt;SizeOfImage +&#x3D; Align(newSectionHeader.Misc.VirtualSize, pOptionHeader-&gt;SectionAlignment);\n\n\t&#x2F;&#x2F; 拷贝 newSectionHeader\n\tmemcpy(pNewSectionHeader, &amp;newSectionHeader, sizeof(newSectionHeader));\n\n\t&#x2F;&#x2F;printf(&quot;插入成功\\n&quot;);\n\tfree(pFileBuffer2);\n\treturn dwFileBufferSize + newSectionHeader.SizeOfRawData;\n&#125;\n\n&#x2F;&#x2F; 扩大最后一个节\n&#x2F;&#x2F; 返回新文件的大小，失败返回0\nDWORD ExpandLastSection(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwOldSize, DWORD dwExpandSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tDWORD dwVirtualSizeExpand &#x3D; Align(dwExpandSize, pOptionHeader-&gt;SectionAlignment);\n\tDWORD dwRawDataExpand &#x3D; Align(dwExpandSize, pOptionHeader-&gt;FileAlignment);\n\t\n\t*pNewFileBuffer &#x3D; malloc(dwOldSize + dwRawDataExpand);\n\tmemcpy(*pNewFileBuffer, pFileBuffer, dwOldSize);\n\tmemset((LPVOID)((DWORD)(*pNewFileBuffer) + dwOldSize), 0, dwRawDataExpand);\n\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpNTHeader &#x3D; (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + (DWORD)*pNewFileBuffer);\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pNTHeader + 0x18);\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t&#x2F;&#x2F; 修改新内存的属性\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].Misc.VirtualSize +&#x3D; dwVirtualSizeExpand;\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].SizeOfRawData +&#x3D; dwRawDataExpand;\n\tpOptionHeader-&gt;SizeOfImage +&#x3D; dwVirtualSizeExpand;\n\n\treturn dwOldSize + dwRawDataExpand;\n&#125;\n\n&#x2F;&#x2F; 合并所有节\nBOOL MergeSection(LPVOID pImageBuffer, LPVOID *pNewImageBuffer, DWORD dwImageSize)\n&#123;\n\t*pNewImageBuffer &#x3D; malloc(dwImageSize);\n\tif (*pNewImageBuffer &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\tmemcpy(*pNewImageBuffer, pImageBuffer, dwImageSize);\n\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewImageBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\tPIMAGE_SECTION_HEADER pLastSectionHeader &#x3D; pSectionHeader + pPEHeader-&gt;NumberOfSections - 1;\n\n\t&#x2F;&#x2F; 修改第一个节的范围以覆盖其他所有节\n\tpSectionHeader-&gt;SizeOfRawData &#x3D; pSectionHeader-&gt;Misc.VirtualSize &#x3D; \\\n\t\tpOptionHeader-&gt;SizeOfImage - pSectionHeader-&gt;VirtualAddress;\n\tpSectionHeader-&gt;SizeOfRawData &#x3D; Align(pSectionHeader-&gt;SizeOfRawData, pOptionHeader-&gt;FileAlignment);\n\n\t&#x2F;&#x2F; 属性包含所有节的属性\n\tfor (int i &#x3D; 1; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tpSectionHeader[0].Characteristics |&#x3D; pSectionHeader[i].Characteristics;\n\t&#125;\n\t\n\t&#x2F;&#x2F; 清空其他节表的数据，这步是为了合并节后新增节方便\n\tmemset(pSectionHeader + 1, 0, sizeof(IMAGE_SECTION_HEADER) * (pPEHeader-&gt;NumberOfSections - 1));\n\n\t&#x2F;&#x2F; 节的数量 &#x3D; 1\n\tpPEHeader-&gt;NumberOfSections &#x3D; 1;\n\n\treturn TRUE;\n&#125;\n\n&#x2F;&#x2F; 打印数据目录\nDWORD TestPrintDataDirectory(LPCSTR lpszFile)\n&#123;\n\tLPVOID pFileBuffer &#x3D; NULL;\n\tReadPEFile(lpszFile, &amp;pFileBuffer);\n\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tLPCSTR data[16] &#x3D;\n\t&#123;\n\t\t&quot;导出表&quot;,\n\t\t&quot;导入表&quot;,\n\t\t&quot;资源表&quot;,\n\t\t&quot;异常信息表&quot;,\n\t\t&quot;安全证书表&quot;,\n\t\t&quot;重定位表&quot;,\n\t\t&quot;调试信息表&quot;,\n\t\t&quot;版权表&quot;,\n\t\t&quot;全局指针表&quot;,\n\t\t&quot;TLS表&quot;,\n\t\t&quot;加载配置表&quot;,\n\t\t&quot;绑定导入表&quot;,\n\t\t&quot;IAT表&quot;,\n\t\t&quot;延迟导入表&quot;,\n\t\t&quot;COM信息表&quot;,\n\t\t&quot;保留&quot;\n\t&#125;;\n\n\tfor (int i &#x3D; 0; i &lt; 16; i++)\n\t&#123;\n\t\tputs(data[i]);\n\t\tprintf(&quot;VirtualAddress &#x3D; %x\\n&quot;, (pOptionHeader-&gt;DataDirectory)[i].VirtualAddress);\n\t\tprintf(&quot;Size &#x3D; %x\\n&quot;, (pOptionHeader-&gt;DataDirectory)[i].Size);\n\t\tputs(&quot;-------------------------&quot;);\n\t&#125;\n\tfree(pFileBuffer);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 打印导出表\nVOID PrintExportTable(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_EXPORT_DIRECTORY pExportDirectory &#x3D; \\\n\t\t(PIMAGE_EXPORT_DIRECTORY)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\tprintf(&quot;Base &#x3D; %x\\n&quot;, pExportDirectory-&gt;Base);\n\tprintf(&quot;NumberOfFunctions &#x3D; %x\\n&quot;, pExportDirectory-&gt;NumberOfFunctions);\n\tprintf(&quot;NumberOfNames &#x3D; %x\\n&quot;, pExportDirectory-&gt;NumberOfNames);\n\n\tprintf(&quot;----AddressOfFunctions----\\n&quot;);\n\tPDWORD AddressOfFunctions &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfFunctions));\n\tint i;\n\tfor (i &#x3D; 0; i &lt; (int)pExportDirectory-&gt;NumberOfFunctions; i++)\n\t&#123;\n\t\tprintf(&quot;AddressOfFunctions[%d] &#x3D; %x\\n&quot;, i, AddressOfFunctions[i]);\n\n\t\t&#x2F;&#x2F; 测试：调用导出序号为12的Plus函数，VC6可以这样调用，VS不行，要VirtualAlloc一块可执行内存\n\t\t&#x2F;&#x2F;if (i + pExportDirectory-&gt;Base &#x3D;&#x3D; 12)\n\t\t&#x2F;&#x2F;&#123;\n\t\t&#x2F;&#x2F;\tint (*Plus)(int x, int y) &#x3D; (int (*)(int x, int y))((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, AddressOfFunctions[i]));\n\t\t&#x2F;&#x2F;\tprintf(&quot;2+3&#x3D;%d\\n&quot;, Plus(2, 3));\n\t\t&#x2F;&#x2F;&#125;\n\t&#125;\n\n\tprintf(&quot;----AddressOfNames &amp; AddressOfNameOridinals----\\n&quot;);\n\tPDWORD AddressOfNames &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNames));\n\tPWORD AddressOfNameOridinals &#x3D; (PWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNameOrdinals));\n\t\n\tfor (i &#x3D; 0; i &lt; (int)pExportDirectory-&gt;NumberOfNames; i++)\n\t&#123;\n\t\tprintf(&quot;AddressOfNames[%d] &#x3D; %s, AddressOfOrdinals[%d] &#x3D; %d\\n&quot;,\n\t\t\ti, (char *)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, AddressOfNames[i])), i, AddressOfNameOridinals[i]);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 根据函数名返回函数入口点RVA\nDWORD GetFunctionAddrByName(LPVOID pFileBuffer, LPCSTR lpszFunc)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_EXPORT_DIRECTORY pExportDirectory &#x3D; \\\n\t\t(PIMAGE_EXPORT_DIRECTORY)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\n\tPDWORD AddressOfFunctions &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfFunctions));\n\tPDWORD AddressOfNames &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNames));\n\tPWORD AddressOfNameOridinals &#x3D; (PWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNameOrdinals));\n\tint i;\n\tfor (i &#x3D; 0; i &lt; (int)pExportDirectory-&gt;NumberOfNames; i++)\n\t&#123;\n\t\tif (!strcmp((char *)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, AddressOfNames[i])), lpszFunc))\n\t\t&#123;\n\t\t\treturn AddressOfFunctions[AddressOfNameOridinals[i]];\n\t\t&#125;\n\t&#125;\n\n\treturn NULL;\n&#125;\n\n&#x2F;&#x2F; 根据导出序号返回函数入口点RVA\nDWORD GetFunctionAddrByOrdinals(LPVOID pFileBuffer, DWORD dwOrdinal)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_EXPORT_DIRECTORY pExportDirectory &#x3D; \\\n\t\t(PIMAGE_EXPORT_DIRECTORY)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\n\tPDWORD AddressOfFunctions &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfFunctions));\n\tPDWORD AddressOfNames &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNames));\n\tPWORD AddressOfNameOridinals &#x3D; (PWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNameOrdinals));\n\n\treturn AddressOfFunctions[dwOrdinal - pExportDirectory-&gt;Base];\n&#125;\n\n&#x2F;&#x2F; 打印重定位表\nVOID PrintRelocationTable(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_BASE_RELOCATION pBaseRelocation &#x3D; \\\n\t\t(PIMAGE_BASE_RELOCATION)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[5].VirtualAddress));\n\n\twhile (pBaseRelocation-&gt;VirtualAddress || pBaseRelocation-&gt;SizeOfBlock)\n\t&#123;\n\t\tputs(&quot;-------------------------------------&quot;);\n\t\tprintf(&quot;VirtualAddress &#x3D; %08x\\n&quot;, pBaseRelocation-&gt;VirtualAddress);\n\t\tprintf(&quot;SizeOfBlock &#x3D; %08x\\n&quot;, pBaseRelocation-&gt;SizeOfBlock);\n\t\tPWORD pwAddr &#x3D; (PWORD)((DWORD)pBaseRelocation + 8);&#x2F;&#x2F;ptr指向的地址作为DWORD +8B\n\t\tint n &#x3D; (pBaseRelocation-&gt;SizeOfBlock - 8) &#x2F; 2;\n\t\tprintf(&quot;要修改的地址个数 &#x3D; %d\\n&quot;, n);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123; \n\t\t\tWORD wProp &#x3D; (0xF000 &amp; pwAddr[i]) &gt;&gt; 12;\n\t\t\tWORD wAddr &#x3D; 0x0FFF &amp; pwAddr[i];\n\t\t\tprintf(&quot;[%d]：RVA &#x3D; %08x\\t属性 &#x3D; %d\\n&quot;, i + 1, pBaseRelocation-&gt;VirtualAddress + wAddr, wProp);\n\t\t&#125;\n\t\tpBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pBaseRelocation + pBaseRelocation-&gt;SizeOfBlock);\t\t\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 移动导出表到新增节，返回新缓冲区的大小\nDWORD MoveExportTableToNewSection(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwFileBufferSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_EXPORT_DIRECTORY pExportTable &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\tPDWORD pAddressOfFunctions &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportTable-&gt;AddressOfFunctions));\n\tPWORD pAddressOfNameOrdinals &#x3D; (PWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportTable-&gt;AddressOfNameOrdinals));\n\tPDWORD pAddressOfNames &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportTable-&gt;AddressOfNames));\n\n\t&#x2F;&#x2F; 计算新增节的大小\n\t&#x2F;&#x2F; &#x3D; NumberOfFunctions * 4 + NumberOfNames * (2 + 4) + 所有函数名的字节 + sizeof(_IMAGE_EXPORT_DIRECTORY)\n\t&#x2F;&#x2F; 然后文件对齐\n\tDWORD dwNewSectionSize &#x3D; 0;\n\tdwNewSectionSize +&#x3D; pExportTable-&gt;NumberOfFunctions * 4; &#x2F;&#x2F; AddressOfFunctions 的空间\n\tdwNewSectionSize +&#x3D; pExportTable-&gt;NumberOfNames * (2 + 4); &#x2F;&#x2F; AddressOfNames + AddressOfNameOrdinals 的空间\n\tsize_t i &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; pExportTable-&gt;NumberOfNames; i++)\n\t&#123;\t\t\n\t\tLPCSTR lpszFuncName &#x3D; (LPCSTR)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pAddressOfNames[i]));\n\t\tdwNewSectionSize +&#x3D; strlen(lpszFuncName) + 1;\n\t&#125;\n\tdwNewSectionSize +&#x3D; sizeof(_IMAGE_EXPORT_DIRECTORY);\n\tdwNewSectionSize &#x3D; Align(dwNewSectionSize, pOptionHeader-&gt;FileAlignment);\n\t&#x2F;&#x2F;printf(&quot;新增节的大小 &#x3D; %x\\n&quot;, dwNewSectionSize);\n\n\tDWORD dwNewBufferSize &#x3D; AddCodeSection(pFileBuffer, pNewFileBuffer, dwFileBufferSize, dwNewSectionSize);\n\t\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t&#x2F;&#x2F; 修改新增节属性为可读、含已初始化数据\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].Characteristics &#x3D; 0x40000040;\n\n\tpExportTable &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)*pNewFileBuffer + \\\n\t\tRvaToFoa(*pNewFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\n\tpAddressOfFunctions &#x3D; (PDWORD)((DWORD)*pNewFileBuffer + RvaToFoa(*pNewFileBuffer, pExportTable-&gt;AddressOfFunctions));\n\tpAddressOfNameOrdinals &#x3D; (PWORD)((DWORD)*pNewFileBuffer + RvaToFoa(*pNewFileBuffer, pExportTable-&gt;AddressOfNameOrdinals));\n\tpAddressOfNames &#x3D; (PDWORD)((DWORD)*pNewFileBuffer + RvaToFoa(*pNewFileBuffer, pExportTable-&gt;AddressOfNames));\n\t\n\t&#x2F;&#x2F; 把3张子表拷贝到新节，更新指针\n\tLPVOID pInsert &#x3D; (LPVOID)((DWORD)*pNewFileBuffer + pSectionHeader[pPEHeader-&gt;NumberOfSections - 1].PointerToRawData);\n\tmemcpy(pInsert, pAddressOfFunctions, 4 * pExportTable-&gt;NumberOfFunctions);\n\tpAddressOfFunctions &#x3D; (PDWORD)pInsert;\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + 4 * pExportTable-&gt;NumberOfFunctions);\n\tmemcpy(pInsert, pAddressOfNameOrdinals, 2 * pExportTable-&gt;NumberOfNames);\n\tpAddressOfNameOrdinals &#x3D; (PWORD)pInsert;\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + 2 * pExportTable-&gt;NumberOfNames);\n\tmemcpy(pInsert, pAddressOfNames, 4 * pExportTable-&gt;NumberOfNames);\n\tpAddressOfNames &#x3D; (PDWORD)pInsert;\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + 4 * pExportTable-&gt;NumberOfNames);\n\t&#x2F;&#x2F; 拷贝函数名\n\tfor (i &#x3D; 0; i &lt; pExportTable-&gt;NumberOfNames; i++)\n\t&#123;\n\t\tLPCSTR lpszFuncName &#x3D; (LPCSTR)((DWORD)*pNewFileBuffer + RvaToFoa(*pNewFileBuffer, pAddressOfNames[i]));\n\t\tmemcpy(pInsert, lpszFuncName, strlen(lpszFuncName) + 1);&#x2F;&#x2F;FOA!!!!!!!!\n\t\t&#x2F;&#x2F; 更新函数名的RVA地址\n\t\tpAddressOfNames[i] &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pInsert - (DWORD)*pNewFileBuffer);&#x2F;&#x2F;RVA!!!!!!!\n\t\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + strlen(lpszFuncName) + 1);\n\t&#125;\n\t&#x2F;&#x2F; 拷贝导出表\n\tmemcpy(pInsert, pExportTable, sizeof(_IMAGE_EXPORT_DIRECTORY));\n\tpExportTable &#x3D; (PIMAGE_EXPORT_DIRECTORY)pInsert;\n\tpExportTable-&gt;AddressOfFunctions &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pAddressOfFunctions - (DWORD)*pNewFileBuffer);\n\tpExportTable-&gt;AddressOfNameOrdinals &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pAddressOfNameOrdinals - (DWORD)*pNewFileBuffer);\n\tpExportTable-&gt;AddressOfNames &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pAddressOfNames - (DWORD)*pNewFileBuffer);\n\t\n\t&#x2F;&#x2F; 修改目录项，指向新的导出表\n\tpOptionHeader-&gt;DataDirectory[0].VirtualAddress &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pExportTable - (DWORD)*pNewFileBuffer);\n\t\t\n\treturn dwNewBufferSize;\n&#125;\n\n&#x2F;&#x2F; 移动重定位表到新增节，返回新缓冲区的大小\nDWORD MoveRelocationTableToNewSection(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwFileBufferSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPIMAGE_BASE_RELOCATION pRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[5].VirtualAddress));\n\n\t&#x2F;&#x2F;size_t i &#x3D; 0;\n\tDWORD dwRelocationTableSize &#x3D; 0;\n\twhile (pRelocationTable-&gt;VirtualAddress || pRelocationTable-&gt;SizeOfBlock)\n\t&#123;\n\t\tdwRelocationTableSize +&#x3D; pRelocationTable-&gt;SizeOfBlock;\n\t\t&#x2F;&#x2F;printf(&quot;%x\\n&quot;, (pRelocationTable-&gt;SizeOfBlock - 8) &#x2F; 2 );\n\t\tpRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pRelocationTable + pRelocationTable-&gt;SizeOfBlock);\n\t&#125;\n\t\n\tDWORD dwNewBufferSize &#x3D; AddCodeSection(pFileBuffer, pNewFileBuffer, dwFileBufferSize, \\\n\t\tAlign(dwRelocationTableSize, pOptionHeader-&gt;FileAlignment));\n\t\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\t&#x2F;&#x2F; 修改新增节属性为可读、含已初始化数据\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].Characteristics &#x3D; 0x40000040;\n\t&#x2F;&#x2F; 指针指向重定位表\n\tpRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)*pNewFileBuffer + \\\n\t\tRvaToFoa(*pNewFileBuffer, pOptionHeader-&gt;DataDirectory[5].VirtualAddress));\n\t&#x2F;&#x2F; 定义插入点为新增节的起始地址\n\tLPVOID pInsert &#x3D; (LPVOID)((DWORD)*pNewFileBuffer + pSectionHeader[pPEHeader-&gt;NumberOfSections - 1].PointerToRawData);\n\t&#x2F;&#x2F; 拷贝重定位表\n\tmemcpy(pInsert, (LPVOID)pRelocationTable, dwRelocationTableSize);\n\t&#x2F;&#x2F; 更新目录项，指向新的重定位表\n\tpOptionHeader-&gt;DataDirectory[5].VirtualAddress &#x3D; FoaToRva(*pNewFileBuffer, \\\n\t\t(DWORD)pInsert - (DWORD)*pNewFileBuffer);\n\t\n\treturn dwNewBufferSize;\n&#125;\n\n&#x2F;&#x2F; 修改 ImageBase 并修复重定位表\nVOID SetImageBase(LPVOID pFileBuffer, DWORD dwNewImageBase)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPIMAGE_BASE_RELOCATION pRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[5].VirtualAddress));\t\n\tDWORD dwImageBaseDelta &#x3D; dwNewImageBase - pOptionHeader-&gt;ImageBase; &#x2F;&#x2F; 新旧ImageBase 的差值\t\n\t\n\t&#x2F;&#x2F; 【重定位表的 VirtualAddress + 低12位偏移 &#x3D; RVA】8000+23&#x3D;8023！！！！！！！！！！！！！！！！！！！\n\t&#x2F;&#x2F; RVA + ImageBase 这个内存里存储了一个“指针”\n\t&#x2F;&#x2F; 要修改的是这个“指针”的值，要让这个“指针”加上两个ImageBase的差值\n\t&#x2F;&#x2F;Rva2Foa2FileAddr\t\t写死的地址+&#x3D;delta\n\twhile (pRelocationTable-&gt;VirtualAddress || pRelocationTable-&gt;SizeOfBlock)\n\t&#123;\t\t\n\t\tsize_t n &#x3D; (pRelocationTable-&gt;SizeOfBlock - 8) &#x2F; 2; &#x2F;&#x2F; 可能需要修改的地址数量（高4位&#x3D;&#x3D;0011才要修改）\n\t\tPWORD pOffset &#x3D; (PWORD)((DWORD)pRelocationTable + 8); &#x2F;&#x2F; 2字节偏移的数组\n\t\tfor (size_t i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 高4位等于0011才需要重定位\n\t\t\tif ((pOffset[i] &amp; 0xF000) &#x3D;&#x3D; 0x3000)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F; 计算需要重定位的数据的RVA地址\n\t\t\t\tDWORD dwRva &#x3D; pRelocationTable-&gt;VirtualAddress + (pOffset[i] &amp; 0x0FFF);\n\t\t\t\t&#x2F;&#x2F; 计算在文件中的偏移\n\t\t\t\tDWORD dwFoa &#x3D; RvaToFoa(pFileBuffer, dwRva);\n\t\t\t\t&#x2F;&#x2F; 计算在文件中的地址\n\t\t\t\tPDWORD pData &#x3D; (PDWORD)((DWORD)pFileBuffer + dwFoa);\n\t\t\t\t&#x2F;&#x2F; 重定位，即修正写死的地址\n\t\t\t\t*pData +&#x3D; dwImageBaseDelta;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\tpRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pRelocationTable + pRelocationTable-&gt;SizeOfBlock);\n\t&#125;\n\t&#x2F;&#x2F; 修改 ImageBase\n\tpOptionHeader-&gt;ImageBase &#x3D; dwNewImageBase;\n&#125;\n\n&#x2F;&#x2F; 打印导入表\nVOID PrintImportTable(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[1].VirtualAddress));\n\n\t&#x2F;&#x2F; 严格来说应该是 sizeof(IMAGE_IMPORT_DESCRIPTOR) 个字节为0表示结束\n\twhile (pImportTable-&gt;OriginalFirstThunk || pImportTable-&gt;FirstThunk)\n\t&#123;\n\t\t&#x2F;&#x2F; 打印模块名\n\t\tprintf(&quot;%s\\n&quot;, (LPCSTR)(RvaToFoa(pFileBuffer, pImportTable-&gt;Name) + (DWORD)pFileBuffer));\n\t\t&#x2F;&#x2F; 遍历INT表(import name table)\n\t\tprintf(&quot;--------------OriginalFirstThunkRVA:%x--%x\\n&quot;, pImportTable-&gt;OriginalFirstThunk,*pImportTable-&gt;OriginalFirstThunk);\n\t\tPIMAGE_THUNK_DATA32 pThunkData &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pFileBuffer + \\\n\t\t\tRvaToFoa(pFileBuffer, pImportTable-&gt;OriginalFirstThunk));\n\t\twhile (*((PDWORD)pThunkData) !&#x3D; 0)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; IMAGE_THUNK_DATA32 是一个4字节数据\n\t\t\t&#x2F;&#x2F; 如果最高位是1，那么除去最高位就是导出序号\n\t\t\t&#x2F;&#x2F; 如果最高位是0，那么这个值是RVA 指向 IMAGE_IMPORT_BY_NAME\n\t\t\tif ((*((PDWORD)pThunkData) &amp; 0x80000000) &#x3D;&#x3D; 0x80000000)&#x2F;&#x2F;IMAGE_ORDINAL_FLAG32 &#x3D;&#x3D; 0x80000000\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;按序号导入 Ordinal:%04x\\n&quot;, (*((PDWORD)pThunkData) &amp; 0x7FFFFFFF));\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tPIMAGE_IMPORT_BY_NAME pIBN &#x3D; (PIMAGE_IMPORT_BY_NAME)(RvaToFoa(pFileBuffer, *((PDWORD)pThunkData)) + \\\n\t\t\t\t\t(DWORD)pFileBuffer);\n\t\t\t\t\n\t\t\t\tprintf(&quot;按名字导入 Hint:%04x Name:%s\\n&quot;, pIBN-&gt;Hint, pIBN-&gt;Name);\n\t\t\t&#125;\n\t\t\tpThunkData++;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 遍历IAT表(import address table)\n\t\tprintf(&quot;--------------FirstThunkRVA:%x--%x\\n&quot;, pImportTable-&gt;FirstThunk,*pImportTable-&gt;FirstThunk);\n\t\tpThunkData &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pFileBuffer + \\\n\t\t\tRvaToFoa(pFileBuffer, pImportTable-&gt;FirstThunk));\n\t\twhile (*((PDWORD)pThunkData) !&#x3D; 0)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; IMAGE_THUNK_DATA32 是一个4字节数据\n\t\t\t&#x2F;&#x2F; 如果最高位是1，那么除去最高位就是导出序号\n\t\t\t&#x2F;&#x2F; 如果最高位是0，那么这个值是RVA 指向 IMAGE_IMPORT_BY_NAME\n\t\t\tif ((*((PDWORD)pThunkData) &amp; 0x80000000) &#x3D;&#x3D; 0x80000000)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;按序号导入 Ordinal:%04x\\n&quot;, (*((PDWORD)pThunkData) &amp; 0x7FFFFFFF));\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tPIMAGE_IMPORT_BY_NAME pIBN &#x3D; (PIMAGE_IMPORT_BY_NAME)(RvaToFoa(pFileBuffer, *((PDWORD)pThunkData)) + \\\n\t\t\t\t\t(DWORD)pFileBuffer);\n\t\t\t\t\n\t\t\t\tprintf(&quot;按名字导入 Hint:%04x Name:%s\\n&quot;, pIBN-&gt;Hint, pIBN-&gt;Name);\n\t\t\t&#125;\n\t\t\tpThunkData++;\n\t\t&#125;\n\t\tpImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pImportTable + sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 打印绑定导入表\nVOID PrintBoundImportTable(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t&#x2F;&#x2F; 判断方式\n\t&#x2F;*if (NULL &#x3D;&#x3D; pOptionHeader-&gt;DataDirectory[11].VirtualAddress)\n\t&#123;\n\t\tprintf(&quot;该程序绑定导入表为空\\n&quot;);\n\t\treturn;\n\t&#125;*&#x2F;\n\n\t&#x2F;&#x2F; 判断方式二\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[1].VirtualAddress));\n\tif (pImportTable-&gt;TimeDateStamp &#x3D;&#x3D; 0)&#x2F;&#x2F;\n\t&#123;\n\t\tprintf(&quot;该程序没有绑定导入\\n&quot;);\n\t\treturn;\n\t&#125;\n\t\n\tPIMAGE_BOUND_IMPORT_DESCRIPTOR pBoundImportTable &#x3D; (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[11].VirtualAddress));\n\tPIMAGE_BOUND_IMPORT_DESCRIPTOR pFirstBoundImportTable &#x3D; pBoundImportTable;\n\t\n\twhile (pBoundImportTable-&gt;TimeDateStamp || pBoundImportTable-&gt;OffsetModuleName || pBoundImportTable-&gt;NumberOfModuleForwarderRefs)\n\t&#123;\n\t\t&#x2F;&#x2F; 打印模块名、时间戳、依赖模块数量\n\t\tputs(&quot;-------------------------------------------&quot;);\n\t\tprintf(&quot;%s\\n&quot;, (LPCSTR) ((DWORD)pFirstBoundImportTable + pBoundImportTable-&gt;OffsetModuleName));&#x2F;&#x2F;\n\t\tprintf(&quot;TimeDateStamp:%x\\n&quot;, pBoundImportTable-&gt;TimeDateStamp);\n\t\tprintf(&quot;NumberOfModuleForwarderRefs:%d\\n&quot;, pBoundImportTable-&gt;NumberOfModuleForwarderRefs);\n\t\t&#x2F;&#x2F; 遍历依赖模块\n\t\tputs(&quot;------------------Refs---------------------&quot;);\n\t\tPIMAGE_BOUND_FORWARDER_REF pBFR &#x3D; (PIMAGE_BOUND_FORWARDER_REF)((DWORD)pBoundImportTable + \\\n\t\t\tsizeof(IMAGE_BOUND_IMPORT_DESCRIPTOR));\n\t\tfor (int i &#x3D; 0; i &lt; pBoundImportTable-&gt;NumberOfModuleForwarderRefs; i++)\n\t\t&#123;\n\t\t\tprintf(&quot;\\t%s\\n&quot;, (LPCSTR)((DWORD)pFirstBoundImportTable + pBFR[i].OffsetModuleName));&#x2F;&#x2F;\n\t\t\tprintf(&quot;\\tTimeDateStamp:%x\\n&quot;, pBFR[i].TimeDateStamp);\n\t\t&#125;\n\t\tpBoundImportTable &#x3D; (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((DWORD)pBoundImportTable + \\\n\t\t\tsizeof(IMAGE_BOUND_IMPORT_DESCRIPTOR) + \\\n\t\t\tpBoundImportTable-&gt;NumberOfModuleForwarderRefs * sizeof(IMAGE_BOUND_FORWARDER_REF));\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 导入表注入demo，通过修改导入表，将 InjectDll.dll 添加到导入表\n&#x2F;&#x2F; DLL只有一个导出函数 ExportFunction，保证至少有一个导出函数DLL才会被加载\n&#x2F;&#x2F; DLL的主函数在加载和分离时会弹窗\nDWORD ImportTableInjectDemo(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwFileSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[1].VirtualAddress));\n\n\t&#x2F;&#x2F; 计算新增节的大小\n\t&#x2F;&#x2F; 新增节存储的内容有：\n\t&#x2F;&#x2F;原来的所有导入表，[新导入表name O F(RVA)] 0，新INT 0, 一个_IMAGE_IMPORT_BY_NAME 0, func_name，新IAT，&quot;模块名.DLL&quot;\n\t&#x2F;&#x2F; 上述容器按0为结束标记的，也要包含结束标记\n\tDWORD dwNewSectionSize &#x3D; 0;\n\tDWORD dwNumberOfDll &#x3D; 0;\n\twhile (pImportTable-&gt;OriginalFirstThunk || pImportTable-&gt;FirstThunk)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;%s\\n&quot;, (LPCSTR)(RvaToFoa(pFileBuffer, pImportTable-&gt;Name) + (DWORD)pFileBuffer));\n\t\tdwNumberOfDll++;\n\t\tpImportTable++;\n\t&#125;\n\tdwNewSectionSize +&#x3D; (dwNumberOfDll + 2) * sizeof(IMAGE_IMPORT_DESCRIPTOR); &#x2F;&#x2F; 原有的和新添加的导入表，以及结束标记\n\tdwNewSectionSize +&#x3D; 16; &#x2F;&#x2F; 这里包括一个INT,一个IAT和两个结束标记\n\tdwNewSectionSize +&#x3D; strlen(&quot;InjectDll.dll&quot;) + 1; &#x2F;&#x2F; 模块名\n\tdwNewSectionSize +&#x3D; 2 + strlen(&quot;ExportFunction&quot;) + 1; &#x2F;&#x2F; _IMAGE_IMPORT_BY_NAME，包括Hint和函数名\n\tDWORD dwNewFileSize &#x3D; AddCodeSection(pFileBuffer, pNewFileBuffer, dwFileSize, dwNewSectionSize);\n\t\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\tpImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)*pNewFileBuffer + \\\n\t\tRvaToFoa(*pNewFileBuffer, pOptionHeader-&gt;DataDirectory[1].VirtualAddress));\n\n\t&#x2F;&#x2F; 设置新增节属性\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].Characteristics &#x3D; 0xC0000040; &#x2F;&#x2F; 可读写，含已初始化数据\n\n\t&#x2F;&#x2F; 定义指针指向新增节首字节\n\tLPVOID pNewSec &#x3D; (LPVOID)((DWORD)*pNewFileBuffer + pSectionHeader[pPEHeader-&gt;NumberOfSections - 1].PointerToRawData);\n\tLPVOID pInsert &#x3D; pNewSec;\n\t&#x2F;&#x2F; 复制原有的导入表\n\tmemcpy(pInsert, pImportTable, dwNumberOfDll * sizeof(IMAGE_IMPORT_DESCRIPTOR));\t\n\t&#x2F;&#x2F; 设置新导入表的时间戳，ForwarderChain\n\tpImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pInsert + dwNumberOfDll * sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\tpImportTable-&gt;TimeDateStamp &#x3D; 0; &#x2F;&#x2F; 表示不使用绑定导入\n\tpImportTable-&gt;ForwarderChain &#x3D; -1;\n\t&#x2F;&#x2F; 设置导入表结束标记\n\tpInsert &#x3D; (LPVOID)((DWORD)pImportTable + sizeof(IMAGE_IMPORT_DESCRIPTOR)); &#x2F;&#x2F; 指向结束标记\n\tmemset(pInsert, 0, sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\t&#x2F;&#x2F; 指定INT表插入点\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + sizeof(IMAGE_IMPORT_DESCRIPTOR)); &#x2F;&#x2F; 现在指向INT表\n\tPIMAGE_THUNK_DATA pINT &#x3D; (PIMAGE_THUNK_DATA)pInsert; &#x2F;&#x2F; 定义指向INT表的指针\n\t&#x2F;&#x2F; 设置INT结束标志\n\tmemset(pINT + 1, 0, sizeof(IMAGE_THUNK_DATA));\n\t&#x2F;&#x2F; 设置 IMPORT_BY_NAME，INT表和IAT表共同指向这块内存\n\tPIMAGE_IMPORT_BY_NAME pImportByName &#x3D; (PIMAGE_IMPORT_BY_NAME)((DWORD)pINT + 8); &#x2F;&#x2F; IMPORT_BY_NAME插入点\n\tpImportByName-&gt;Hint &#x3D; 0; &#x2F;&#x2F; 设置没有用的导出序号\n\tstrcpy((char*)(pImportByName-&gt;Name), &quot;ExportFunction&quot;); &#x2F;&#x2F; 设置函数名\n\t&#x2F;&#x2F; INT表的[值]是 IMPORT_BY_NAME 的[RVA]\n\t*((PDWORD)pINT) &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pImportByName - (DWORD)*pNewFileBuffer); &#x2F;&#x2F; 设置INT的值\n\t&#x2F;&#x2F; 设置IAT表\n\tpInsert &#x3D; (LPVOID)((DWORD)pImportByName + 2 + strlen(&quot;ExportFunction&quot;) + 1); &#x2F;&#x2F; 指向IAT表\n\tPIMAGE_THUNK_DATA  pIAT &#x3D; (PIMAGE_THUNK_DATA)pInsert; &#x2F;&#x2F; IAT插入点\n\tmemcpy(pIAT, pINT, 8);\n\t&#x2F;&#x2F; 分配模块名的内存，并完成导入表剩余属性的赋值\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + 8);\n\tstrcpy((char *)pInsert, &quot;InjectDll.dll&quot;);\n\t&#x2F;&#x2F; 设置导入表属性\n\tpImportTable-&gt;OriginalFirstThunk &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pINT - (DWORD)*pNewFileBuffer);\n\tpImportTable-&gt;FirstThunk &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pIAT - (DWORD)*pNewFileBuffer);\n\tpImportTable-&gt;Name &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pInsert - (DWORD)*pNewFileBuffer);\n\t&#x2F;&#x2F; 更新目录项中导入表的位置\n\tpOptionHeader-&gt;DataDirectory[1].VirtualAddress &#x3D; FoaToRva(*pNewFileBuffer, ((DWORD)pNewSec - (DWORD)*pNewFileBuffer));\n\treturn dwNewFileSize;\n&#125;\n\n&#x2F;&#x2F; 打印资源表\nVOID PrintResourceTable(LPVOID pFileBuffer)\n&#123;\n\t&#x2F;&#x2F;资源的类型\n\tPCHAR lpszResType[17] &#x3D; &#123; &quot;未定义&quot;, &quot;光标&quot;, &quot;位图&quot;, &quot;图标&quot;, &quot;菜单&quot;,\n\t\t&quot;对话框&quot;, &quot;字符串&quot;,&quot;字体目录&quot;, &quot;字体&quot;,\n\t\t&quot;加速键&quot;, &quot;非格式化资源&quot;, &quot;消息列表&quot;, &quot;光标组&quot;,\n\t\t&quot;未定义&quot;, &quot;图标组&quot;,&quot;未定义&quot;, &quot;版本信息&quot; &#125;;\n\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t&#x2F;&#x2F; 定义第一层的指针和长度\n\tPIMAGE_RESOURCE_DIRECTORY pResDir1 &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[2].VirtualAddress));\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry1 &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pResDir1 + \\\n\t\tsizeof(IMAGE_RESOURCE_DIRECTORY));\n\tint dwNumberOfResDirEntry1 &#x3D; pResDir1-&gt;NumberOfNamedEntries + pResDir1-&gt;NumberOfIdEntries;\n\tprintf(&quot;资源类型数量: %d\\n&quot;, dwNumberOfResDirEntry1);\n\t&#x2F;&#x2F; 遍历第一层：类型\n\tfor (int i &#x3D; 0; i &lt; dwNumberOfResDirEntry1; i++)\n\t&#123;\n\t\t&#x2F;&#x2F; 如果高位是1，低31位是指针，指向一个Unicode字符串\n\t\tif (pResDirEntry1[i].NameIsString &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tPIMAGE_RESOURCE_DIR_STRING_U uString &#x3D; \n\t\t\t\t(PIMAGE_RESOURCE_DIR_STRING_U)((DWORD)pResDir1 + (pResDirEntry1[i].NameOffset &amp; 0x7FFFFFFF));\n\t\t\tWCHAR *pName &#x3D; (WCHAR *)malloc(2 * (uString-&gt;Length + 1));\n\t\t\tmemset(pName, 0, 2 * (uString-&gt;Length + 1));\n\t\t\tmemcpy(pName, uString-&gt;NameString, 2 * uString-&gt;Length);\n\t\t\twprintf(L&quot;ID:  - 资源类型: \\&quot;%s\\&quot;\\n&quot;, pName);\n\t\t\tfree(pName);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 如果最高位是0，则这是一个序号，是预定义的16种资源之一\n\t\telse\n\t\t&#123;\n\t\t\tif (pResDirEntry1[i].Id &lt;&#x3D; 16)\n\t\t\t\tprintf(&quot;ID: %2d 资源类型: %s\\n&quot;, pResDirEntry1[i].Id, lpszResType[pResDirEntry1[i].Id]);\n\t\t\telse\n\t\t\t\tprintf(&quot;ID: %2d 资源类型: 未定义\\n&quot;, pResDirEntry1[i].Id);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 定义第二层的指针和长度\n\t\tPIMAGE_RESOURCE_DIRECTORY pResDir2 &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)pResDir1 + \\\n\t\t\t(pResDirEntry1[i].OffsetToData &amp; 0x7FFFFFFF));\n\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry2 &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pResDir2 + \\\n\t\t\tsizeof(IMAGE_RESOURCE_DIRECTORY));\n\t\tint dwNumberOfResDirEntry2 &#x3D; pResDir2-&gt;NumberOfNamedEntries + pResDir2-&gt;NumberOfIdEntries;\n\t\t&#x2F;&#x2F; 遍历第二层：编号\n\t\t&#x2F;&#x2F;printf(&quot;第二层项数: %d\\n&quot;, dwNumberOfNumber);\n\t\tfor (int j &#x3D; 0; j &lt; dwNumberOfResDirEntry2; j++)\n\t\t&#123;\n\t\t\tif (pResDirEntry2[j].NameIsString &#x3D;&#x3D; 1)\n\t\t\t&#123;\n\t\t\t\tPIMAGE_RESOURCE_DIR_STRING_U uString &#x3D; \n\t\t\t\t\t(PIMAGE_RESOURCE_DIR_STRING_U)((DWORD)pResDir1 + (pResDirEntry2[j].NameOffset &amp; 0x7FFFFFFF));\n\t\t\t\tWCHAR *pName &#x3D; (WCHAR *)malloc(2 * (uString-&gt;Length + 1));\n\t\t\t\tmemset(pName, 0, 2 * (uString-&gt;Length + 1));\n\t\t\t\tmemcpy(pName, uString-&gt;NameString, 2 * uString-&gt;Length);\n\t\t\t\twprintf(L&quot;\\tName: \\&quot;%s\\&quot;\\n&quot;, pName);\n\t\t\t\tfree(pName);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;\\tID: %d\\n&quot;, pResDirEntry2[j].Id);\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F; 定义第三层的指针和长度\n\t\t\tPIMAGE_RESOURCE_DIRECTORY pResDir3 &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)pResDir1 + \\\n\t\t\t\t(pResDirEntry2[j].OffsetToData &amp; 0x7FFFFFFF));\n\t\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry3 &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pResDir3 + \\\n\t\t\t\tsizeof(IMAGE_RESOURCE_DIRECTORY));\n\t\t\tint dwNumberOfResDirEntry3 &#x3D; pResDir3-&gt;NumberOfNamedEntries + pResDir3-&gt;NumberOfIdEntries;\n\t\t\t&#x2F;&#x2F; 遍历第三层：代码页\n\t\t\t&#x2F;&#x2F; 大多数情况下一个资源的代码页只定义一种，但不是绝对，因此第三层也要循环遍历\n\t\t\t&#x2F;&#x2F;printf(&quot;\\t\\t%d\\n&quot;, dwNumberOfResDirEntry3); &#x2F;&#x2F; 真有不是1的\n\t\t\tfor (int k &#x3D; 0; k &lt; dwNumberOfResDirEntry3; k++)\n\t\t\t&#123;\n\t\t\t\tif (pResDirEntry3[k].Name &amp; 0x80000000)\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;\\t非标准代码页\\n&quot;);\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;\\t代码页: %d\\n&quot;, pResDirEntry3[k].Id &amp; 0x7FFF);\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; 资源数据项，通过这个结构可以找到资源的RVA，以及大小\n\t\t\t\tPIMAGE_RESOURCE_DATA_ENTRY pDataEntry &#x3D; (PIMAGE_RESOURCE_DATA_ENTRY)((DWORD)pResDir1 + \\\n\t\t\t\t\tpResDirEntry3[k].OffsetToData);\n\t\t\t\tprintf(&quot;\\tRVA: %x\\tSIZE: %x\\n&quot;, pDataEntry-&gt;OffsetToData, pDataEntry-&gt;Size);\n\t\t\t&#125;\n\t\t\tprintf(&quot;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n</code></pre>\n\n","text":"&#x2F;&#x2F;PE课后作业参考代码（含测试代码） &#x2F;&#x2F;https:&#x2F;&#x2F;blog.csdn.net&#x2F;Kwansy&#x2F;article&#x2F;details&#x2F;106234264 #include &quo...","link":"","photos":[],"count_time":{"symbolsCount":"60k","symbolsTime":"54 mins."},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"}],"toc":"","author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Win32","uid":"02fb78d957647a82a5e9777a15428562","slug":"Win32","date":"2020-08-20T05:41:47.000Z","updated":"2022-08-22T08:01:23.487Z","comments":true,"path":"api/articles/Win32.json","keywords":null,"cover":"http://p6.qhimg.com/bdm/960_593_0/t011cb371b497218f8d.jpg","text":"Win32&#x2F;* 对于字符串，ASCII 中使用 char 来定义，而 Unicode 中使用 wchar_t 来定义，并且需要添加前缀L。 那么在 windows.h 头文件中（或者是它包含的其他头文件）就这样来处理： #ifdef UNICODE typedef wc...","link":"","photos":[],"count_time":{"symbolsCount":"75k","symbolsTime":"1:08"},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}