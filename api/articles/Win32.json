{"title":"Win32","uid":"02fb78d957647a82a5e9777a15428562","slug":"Win32","date":"2020-08-20T05:41:47.000Z","updated":"2022-08-22T08:01:23.487Z","comments":true,"path":"api/articles/Win32.json","keywords":null,"cover":"http://p6.qhimg.com/bdm/960_593_0/t011cb371b497218f8d.jpg","content":"<h1 id=\"Win32\"><a href=\"#Win32\" class=\"headerlink\" title=\"Win32\"></a>Win32</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;*\n对于字符串，ASCII 中使用 char 来定义，而 Unicode 中使用 wchar_t 来定义，并且需要添加前缀L。\n那么在 windows.h 头文件中（或者是它包含的其他头文件）就这样来处理：\n#ifdef UNICODE\ntypedef wchar_t TCHAR;\n#define TEXT(quote) L##quote\n#else\ntypedef char TCHAR\n#define TEXT(quote) quote\n#endif\n我们在源码中可以这样来使用：\nTCHAR str[] &#x3D; TEXT(&quot;C语言中文网&quot;);\n如果是Unicode版，也就是定义了UNICODE宏，那么上面的语句等价于：\nwchar_t str[] &#x3D; L&quot;C语言中文网&quot;;\n如果是ASCII，也就是没有定义UNICODE宏，那么等价于：\nchar str[] &#x3D; &quot;C语言中文网&quot;;\n\n\n用UTF-8就有复杂点.因为此时程序是把一个字节一个字节的来读取,\n然后再根据字节中开头的bit标志来识别是该把1个还是两个或三个字节做为一个单元来处理.\n\n0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元.\n\n这是约定的规则.你用UTF-8来表示时必须遵守这样的规则.\n我们知道UTF-16不需要用啥字符来做标志,所以两字节也就是2的16次能表示65536个字符.\n\n而UTF-8由于里面有额外的标志信息,\n一个字节只能表示2的7次方128个字符,两个字节只能表示2的11次方2048个字符.而三个字节能表示2的16次方,65536个字符.\n\n由于&quot;汉&quot;的编码27721大于2048了所有两个字节还不够,只能用三个字节来表示.\n所有要用1110xxxx 10xxxxxx 10xxxxxx这种格式.把27721对应的二进制从左到右填充XXX符号\n(实际上不一定从左到右,也可以从右到左,Big-Endian就是从左到右,Little-Endian是从右到左.)\n\n由上面我们可以看出UTF-8在局部的字节错误（丢失、增加、改变）不会导致连锁性的错误，\n因为 UTF-8 的字符边界很容易检测出来，所以容错性较高。\n\nUnicode版本2\n所有编码对应的开头标志\nEF BB BF　　　 UTF-8\nFE FF　　　　　UTF-16&#x2F;UCS-2, little endian\nFF FE　　　　　UTF-16&#x2F;UCS-2, big endian\nFF FE 00 00　　UTF-32&#x2F;UCS-4, little endian.\n00 00 FE FF　　UTF-32&#x2F;UCS-4, big-endian.\n\nTCHAR cht[] &#x3D; TEXT(&quot;中国&quot;);\nPTSTR pszTChar &#x3D; TEXT(&quot;china&quot;);\nMessageBox(0,TEXT(&quot;根据项目字符集决定&quot;),TEXT(&quot;标题&quot;),MB_OK);\n\nint _tmain(int argc, TCHAR *argv[])\n\nmain(),wmain是WINDOWS的控制台程序（32BIT）或DOS程序（16BIT）.\nWinMain(),wWinMain()是WINDOWS的GUI程序.\n*&#x2F;\n\n\n\n\n#include &quot;Tools.h&quot;\n\nHINSTANCE hAppInstance;\n\nvoid CreateButton(HWND hwnd)\t\t\n&#123;\t\t\n\tHWND hwndPushButton;\t\n\tHWND hwndCheckBox;\t\n\tHWND hwndRadio;\t\n\n\thwndPushButton &#x3D; CreateWindow ( \t\n\t\tTEXT(&quot;button&quot;),\t\t&#x2F;&#x2F;1\n\t\tTEXT(&quot;普通按钮&quot;),\n\t\t&#x2F;&#x2F;WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,\n\t\tWS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,\n\t\t10, 10,\n\t\t80, 20,\n\t\thwnd, \n\t\t(HMENU)1001,\t\t&#x2F;&#x2F;2 子窗口编号\n\t\thAppInstance, \n\t\tNULL);\n\n\t&#x2F;&#x2F;获取button的WNDCLASS\n\tTCHAR szBuffer[0x20];\n\tGetClassName(hwndPushButton,szBuffer,0x20);&#x2F;&#x2F;in out bufferSize\n\n\tWNDCLASS wc;\n\tGetClassInfo(hAppInstance,szBuffer,&amp;wc);&#x2F;&#x2F;ImageBase in out\n\tOutputDebugStringF(&quot;--&gt;%s\\n&quot;,wc.lpszClassName);\n\tOutputDebugStringF(&quot;--&gt;%x\\n&quot;,wc.lpfnWndProc);\n\n\n\n\thwndCheckBox &#x3D; CreateWindow ( \t\n\t\tTEXT(&quot;button&quot;), \n\t\tTEXT(&quot;复选框&quot;),\n\t\t&#x2F;&#x2F;WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX,\n\t\tWS_CHILD | WS_VISIBLE | BS_CHECKBOX |BS_AUTOCHECKBOX ,\n\t\t10, 40,\n\t\t80, 20,\n\t\thwnd, \n\t\t(HMENU)1002,\n\t\thAppInstance, \n\t\tNULL);\n\n\thwndRadio &#x3D; CreateWindow ( \t\n\t\tTEXT(&quot;button&quot;), \n\t\tTEXT(&quot;单选按钮&quot;),\n\t\t&#x2F;&#x2F;WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON | BS_AUTORADIOBUTTON,\n\t\tWS_CHILD | WS_VISIBLE | BS_RADIOBUTTON  ,\n\t\t10, 70,\n\t\t80, 20,\n\t\thwnd, \n\t\t(HMENU)1003,\n\t\thAppInstance, \n\t\tNULL);\n&#125; \t\t\n\n\n\n\n\n\nLRESULT CALLBACK WindowProc(  \t\t\t\t\t\t\t\n\tIN  HWND hwnd,  \n\tIN  UINT uMsg,  \n\tIN  WPARAM wParam,  \n\tIN  LPARAM lParam  \n\t);\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\thAppInstance &#x3D; hInstance;\n\t&#x2F;&#x2F;窗口的类名\t\t\t\t\t\t\n\tTCHAR className[] &#x3D; &quot;My First Window&quot;; \t\t\t\t\t\t\n\t\n\t&#x2F;&#x2F;OutputDebugStringF(&quot;%s\\n&quot;, lpCmdLine);\n\t\n\t&#x2F;&#x2F; 创建窗口类的对象 \t\t\t\t\t\t\n\tWNDCLASS wndclass &#x3D; &#123;0&#125;;\t\t\t\t\t\t&#x2F;&#x2F;一定要先将所有值赋值!!!!!!!  &#x3D;&#123;0&#125;\n\twndclass.hbrBackground &#x3D; (HBRUSH)COLOR_MENU;\t&#x2F;&#x2F;窗口的背景色\n\twndclass.lpfnWndProc &#x3D; WindowProc;\t\t\t\t&#x2F;&#x2F;窗口过程函数\n\twndclass.lpszClassName &#x3D; className;\t\t\t\t&#x2F;&#x2F;窗口类的名字\n\twndclass.hInstance &#x3D; hInstance;\t\t\t\t\t&#x2F;&#x2F;定义窗口类的应用程序的实例句柄\n\t\n\t&#x2F;&#x2F;步骤5：注册窗口类\t\t\t\t\t\t\t\t\t\t\t\n\tRegisterClass(&amp;wndclass);  \t\t\t\t\t\n\n\t&#x2F;&#x2F;步骤6：创建窗口\t\t\t\t\t\n\n\t&#x2F;&#x2F; 创建窗口  \t\t\t\t\t\n\tHWND hwnd &#x3D; CreateWindow(  \t\t\t\t\t\n\t\tclassName,\t\t\t\t\t\t\t&#x2F;&#x2F;类名\n\t\tTEXT(&quot;我的第一个窗口&quot;),\t\t\t\t&#x2F;&#x2F;窗口标题\n\t\tWS_OVERLAPPEDWINDOW,\t\t\t\t&#x2F;&#x2F;窗口外观样式 \n\t\t10,\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;相对于父窗口的X坐标\n\t\t10,\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;相对于父窗口的Y坐标\n\t\t600,\t\t\t\t\t\t\t\t&#x2F;&#x2F;窗口的宽度  \n\t\t300,\t\t\t\t\t\t\t\t&#x2F;&#x2F;窗口的高度  \n\t\tNULL,\t\t\t\t\t\t\t\t&#x2F;&#x2F;父窗口句柄，为NULL  \n\t\tNULL,\t\t\t\t\t\t\t\t&#x2F;&#x2F;菜单句柄，为NULL  \n\t\thInstance,\t\t\t\t\t\t\t&#x2F;&#x2F;当前应用程序的句柄  \n\t\tNULL);\t\t\t\t\t\t\t\t&#x2F;&#x2F;附加数据一般为NULL\n\n\tif(hwnd &#x3D;&#x3D; NULL)\t\t\t\t\t\t&#x2F;&#x2F;是否创建成功  \n\t\treturn 0;  \t\t\t\t\n\n\tCreateButton(hwnd);\t&#x2F;&#x2F;!!!!\n\n\t&#x2F;&#x2F;步骤7：显示窗口\t\t\t\t\t\n\n\t&#x2F;&#x2F; 显示窗口  \t\t\t\t\t\n\tShowWindow(hwnd, SW_SHOW);  \t\t\t\t\t\n\n\t&#x2F;&#x2F;步骤8：消息循环\t\t\t\t\t\n\n\tMSG msg;  \t\t\t\t\t\n\twhile(GetMessage(&amp;msg, NULL, 0, 0))  \t\t\t\t\t\n\t&#123;  \t\t\t\t\t\n\t\tTranslateMessage(&amp;msg);  \t\t\t\t\n\t\tDispatchMessage(&amp;msg);  \t\t\t\t\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;步骤9：回调函数\t\t\t\t\t\n\n&#x2F;*\t\t\t\t\t\n窗口消息处理程序 窗口回调函数：\t\t\t\t\t\n\t\t\t\t\t\n1、窗口回调函数处理过的消息，必须传回0.\t\t\t\t\t\n\t\t\t\t\t\n2、窗口回调不处理的消息，由DefWindowProc来处理.\t\t\t\t\t\n*&#x2F;\t\t\t\t\t\n\nLRESULT CALLBACK WindowProc(  \t\t\t\t\t\t\t\n\tIN  HWND hwnd,  \n\tIN  UINT uMsg,  \n\tIN  WPARAM wParam,  \n\tIN  LPARAM lParam  \n\t)\t\t\t\n&#123;  \t\t\n\t&#x2F;&#x2F;DbgPrintf(&quot;%x\\n&quot;,uMsg);\n\tswitch(uMsg)\t\t\t\t\n\t&#123;\t\t\t\t\n\t\t\n\t\t&#x2F;&#x2F;窗口消息\t\t\t\n\t\tcase WM_CREATE: \t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tCREATESTRUCT* createst &#x3D; (CREATESTRUCT*)lParam;\t\t\n\t\t\tDbgPrintf(&quot;WM_CREATE: %s\\n&quot;,createst-&gt;lpszClass);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_MOVE:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_MOVE %d %d\\n&quot;,wParam,lParam);\t\t\n\t\t\tPOINTS points &#x3D; MAKEPOINTS(lParam);\t\t\n\t\t\tDbgPrintf(&quot;X Y %d %d\\n&quot;,points.x,points.y);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_SIZE:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_SIZE %d %d\\n&quot;,wParam,lParam);\t\t\n\t\t\tint newWidth  &#x3D; (int)(short) LOWORD(lParam);    \t\t\n\t\t\tint newHeight  &#x3D; (int)(short) HIWORD(lParam);   \t\t\n\t\t\tDbgPrintf(&quot;WM_SIZE %d %d\\n&quot;,newWidth,newHeight);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_DESTROY:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_DESTROY %d %d\\n&quot;,wParam,lParam);\t\t\n\t\t\tPostQuitMessage(0);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\t&#x2F;&#x2F;键盘消息\t\t\t\n\t\tcase WM_KEYUP:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_KEYUP %d %d\\n&quot;,wParam,lParam);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_KEYDOWN:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_KEYDOWN %d %d\\n&quot;,wParam,lParam);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\t&#x2F;&#x2F;鼠标消息\t\t\t\n\t\tcase WM_LBUTTONDOWN:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_LBUTTONDOWN %d %d\\n&quot;,wParam,lParam);\t\t\n\t\t\tPOINTS points &#x3D; MAKEPOINTS(lParam);\t\t\n\t\t\tDbgPrintf(&quot;WM_LBUTTONDOWN %d %d\\n&quot;,points.x,points.y);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t&#125;\t\t\t\t\n\treturn DefWindowProc(hwnd,uMsg,wParam,lParam);\t\t&#x2F;&#x2F;default 判断消息的类型是不是我关心的:是就处理,不是 让Windows去处理\n\n&#125;  \t\t\t\t\t\n\n\n\n\n\n\n&#x2F;&#x2F;win32_res\n\n#include &quot;stdafx.h&quot;\n#include &quot;resource.h&quot;\n\n\nBOOL CALLBACK DialogProc(\t\t\t\t\t\t\n\t\t\t\t\t\t HWND hwndDlg,  &#x2F;&#x2F; handle to dialog box\n\t\t\t\t\t\t UINT uMsg,     &#x2F;&#x2F; message\n\t\t\t\t\t\t WPARAM wParam, &#x2F;&#x2F; first message parameter\n\t\t\t\t\t\t LPARAM lParam  &#x2F;&#x2F; second message parameter\n\t\t\t\t\t\t )\n&#123;\t\t\t\t\t\t\n\n\tHWND hEditUser &#x3D; NULL;\n\tHWND hEditPass &#x3D; NULL;\n\n\tswitch(uMsg)\t\t\t\t\t\n\t&#123;\t\t\t\t\t\n\t\tcase  WM_INITDIALOG :\t\t\t\t\t\n\n\t&#x2F;&#x2F;\tMessageBox(NULL,TEXT(&quot;WM_INITDIALOG&quot;),TEXT(&quot;INIT&quot;),MB_OK);\t\t\t\t\n\n\t\treturn TRUE ;\t\t\t\t\n\n\t\tcase  WM_COMMAND :\t\t\t\t\t\n\n\t\tswitch (LOWORD (wParam))\t\t\t\t\n\t\t&#123;\t\t\t\t\n\t\t\tcase   IDC_BUTTON_OK :\t\t\t\t\n\t\t\t&#x2F;&#x2F;MessageBox(NULL,TEXT(&quot;IDC_BUTTON_OK&quot;),TEXT(&quot;OK&quot;),MB_OK);\t\t\t\t\t\n\t\t\t\n\t\t\t&#x2F;&#x2F;hHandle\n\t\t\thEditUser &#x3D; GetDlgItem(hwndDlg,IDC_EDIT_USERNAME);\n\t\t\thEditPass &#x3D; GetDlgItem(hwndDlg,IDC_EDIT_PASSWORD);\n\t\t\t&#x2F;&#x2F;content\n\t\t\tTCHAR szUserBuff[128];\n\t\t\tTCHAR szPassBuff[128];\n\n\t\t\tGetWindowText(hEditUser,szUserBuff,128);\n\t\t\tGetWindowText(hEditPass,szPassBuff,128);\n\n\t\t\tif (strcmp(szUserBuff, TEXT(&quot;admin&quot;)) &#x3D;&#x3D; 0 &amp;&amp; strcmp(szPassBuff, TEXT(&quot;123&quot;)) &#x3D;&#x3D; 0)\n\t\t\t&#123;\n\t\t\t\tMessageBox(NULL, TEXT(&quot;密码正确&quot;), TEXT(&quot;密码正确&quot;), MB_OK);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tMessageBox(NULL, TEXT(&quot;密码错误&quot;), TEXT(&quot;密码错误&quot;), MB_OK);\n\t\t\t&#125;\n\t\t\t\n\t\t\treturn TRUE;\n\n\t\t\tcase   IDC_BUTTON_ERROR:\n\n\t\t\tMessageBox(NULL,TEXT(&quot;IDC_BUTTON_ERROR&quot;),TEXT(&quot;ERROR&quot;),MB_OK);\t\t\t\n\n\t\t\tEndDialog(hwndDlg, 0);\t\t\t\n\n\t\t\treturn TRUE;\t\t\t\n\t\t&#125;\t\t\n\n\t\tbreak ;\t\t\t\t\n\t&#125;\t\t\t\t\t\t\n\n\treturn FALSE ;\t\t\t\t\t\n&#125;\t\t\t\t\t\t\n\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\n\t\n\tDialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, DialogProc);\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;IconDemo\n\n#include &quot;stdafx.h&quot;\n#include &quot;resource.h&quot;\nHINSTANCE hAppInstance;\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tBOOL bRet &#x3D; TRUE;\n\tHICON hIconSmall;\n\tHICON hIconBig;\n\tswitch(uMsg)\n\t&#123;\n\t\tcase WM_INITDIALOG :\n\t\thIconSmall &#x3D; LoadIcon (hAppInstance, MAKEINTRESOURCE (IDI_ICON_SMALL));\n\t\thIconBig &#x3D; LoadIcon (hAppInstance, MAKEINTRESOURCE (IDI_ICON_BIG));\n\t\t  &#x2F;&#x2F;设置图标\n\t\tSendMessage(hDlg,WM_SETICON,ICON_BIG,(DWORD)hIconBig);\n\t\tSendMessage(hDlg,WM_SETICON,ICON_SMALL,(DWORD)hIconSmall);\n\t\t\n\t\treturn 0 ;\n\t\tcase WM_COMMAND:\n\t\tswitch(LOWORD(wParam))\n\t\t&#123;\n\t\t\tcase IDC_BUTTON_OUT:\n\t\t\tEndDialog(hDlg,0);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tbRet &#x3D; FALSE;\n\t\t\tbreak;\n\t\t&#125;\n\t\tbreak;\n\n\t\tdefault:\n\t\tbRet &#x3D; FALSE;\n\t\tbreak;\n\t&#125;\n\t\n\treturn bRet;\n&#125;\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\thAppInstance &#x3D; hInstance;\n\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n&#x2F;&#x2F;项目：LordPE\tWin32\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;thread Timer\nfor (int i &#x3D; 0; i &lt; 10; i++)\n&#123;\n\tprintf(&quot;+++++++++\\n&quot;);\n&#125;\n\n\n\n\n&#x2F;&#x2F;threadd_ctrl\t\twin32\n#include &quot;resource.h&quot;\n\nHWND hEdit;\nHANDLE hThread;\n&#x2F;&#x2F;DWORD isEnd;\t\t\t\t\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\t\n\tDWORD dwIndex &#x3D; 0;\t\t\t\t\n\tDWORD dwCount;\t\t\t\t\n\n\twhile(dwIndex&lt;1000)\t\t\t\t\n\t&#123;\t\t\t\n\t&#x2F;*\tif(dwIndex &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tbreak;\n\t\t\t&#x2F;&#x2F;::ExitThread(2);&#x2F;&#x2F;退出码 清理堆栈 不管new 直接返回!\n\t\t&#125;*&#x2F;\n\t\tGetWindowText(hEdit,szBuffer,10);\t\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwCount );\t\t\t\n\t\tdwCount++;\t\n\t\tSleep(200);\n\t\tmemset(szBuffer,0,10);\t\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwCount);\t\t\t\n\t\tSetWindowText(hEdit,szBuffer);\t\t\t\n\t\tdwIndex++;\t\t\t\n\t&#125;\t\n\t&#x2F;&#x2F;free delete\n\n\treturn 0;\t\t\t\t\n&#125;\t\t\t\t\t\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\t\n\tDWORD dwIndex &#x3D; 0;\t\t\t\t\n\tDWORD dwCount;\t\t\t\t\n\n\n\twhile(dwIndex&lt;10)\t\t\t\t\n\t&#123;\t\t\t\t\n\t\tGetWindowText(hEdit,szBuffer,10);\t\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwCount );\t\t\t\n\t\tdwCount++;\t\t\t\n\t\tmemset(szBuffer,0,10);\t\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwCount);\t\t\t\n\t\tSetWindowText(hEdit,szBuffer);\t\t\t\n\t\tdwIndex++;\t\t\t\n\t&#125;\t\t\t\t\n\n\treturn 0;\t\t\t\t\n&#125;\t\t\t\t\t\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tBOOL bRet &#x3D; FALSE;\t\t\t\t\n\n\tswitch(uMsg)\t\t\t\t\n\t&#123;\t\t\t\t\n\t\tcase WM_CLOSE:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tEndDialog(hDlg,0);\t\t\n\t\t\tbreak;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_INITDIALOG:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\thEdit &#x3D; GetDlgItem(hDlg,IDC_EDIT);\t\t\n\t\t\tSetWindowText(hEdit,&quot;0&quot;);\t\t\n\n\t\t\tbreak;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_COMMAND:\t\t\t\t\n\n\t\tswitch (LOWORD (wParam))\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tcase IDC_BUTTON1:\t\t\t\n\t\t\t&#123;\t\t\n\t\t\t\thThread &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\t\t\t\tNULL, 0, NULL);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t\tcase IDC_BUTTON2:\t\t\t\n\t\t\t&#123;\t\t\n\n\t\t\t\t::SuspendThread(hThread);\n\t\t\t\tCONTEXT context;\n\n\t\t\t\t&#x2F;&#x2F;设置要获取的类型\n\t\t\t\tcontext.ContextFlags &#x3D; CONTEXT_CONTROL;\n\n\t\t\t\t&#x2F;&#x2F;获取\n\t\t\t\tBOOL ok &#x3D; ::GetThreadContext(hThread,&amp;context);\n\n\t\t\t\t&#x2F;&#x2F;设置\n\t\t\t\tcontext.Eip &#x3D; 0x401000;&#x2F;&#x2F;\n\n\t\t\t\tSetThreadContext(hThread,&amp;context);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t\tcase IDC_BUTTON3:\t\t\t\n\t\t\t&#123;\t\t\n\t\t\t\t::ResumeThread(hThread);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\t\n\t\t\tcase IDC_BUTTON4:\t\t\t\n\t\t\t&#123;\n\t\t\t\t::TerminateThread(hThread,3);&#x2F;&#x2F;异步 只通知OS终止，不等  不清理堆栈（local_var有引用）\n\n\t\t\t\t::WaitForSingleObject(hThread,INFINITE);&#x2F;&#x2F;阻塞self\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t&#125;\t\n\t\tbreak ;\t\t\t\n\t&#125;\t\t\t\t\n\n\treturn bRet;\t\t\t\t\n&#125;\t\t\t\t\t\n\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\n\n\tDialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, MainDlgProc);\n\treturn 0;\n&#125;\n\n\n\n\n在g_num&#x3D;0时，t1取得g_num&#x3D;0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num&#x3D;0\n然后t2对得到的值进行加1并赋给g_num，使得g_num&#x3D;1\n然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。\n这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num&#x3D;1\n\n&#x2F;&#x2F;加临界区 &#x3D;&#x3D;20000了\n#include &quot;stdafx.h&quot;\n#include &quot;resource.h&quot;\n\nHWND hEdit;\nHANDLE hThread1;\nHANDLE hThread2;\nCRITICAL_SECTION cs;\n\n\n&#x2F;&#x2F;DWORD isEnd;\t\t\t\t\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\t\n\tDWORD dwIndex &#x3D; 0;\t\t\t\t\n\tDWORD dwCount;\t\t\t\t\n\n\twhile(dwIndex&lt;10000)\t\t\t\t\n\t&#123;\t\t\t\n\t&#x2F;*\tif(dwIndex &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tbreak;\n\t\t\t&#x2F;&#x2F;::ExitThread(2);&#x2F;&#x2F;退出码 清理堆栈 不管new 直接返回!\n\t\t&#125;*&#x2F;\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit,szBuffer,10);\t\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwCount );\t\t\t\n\t\tdwCount++;\t\n\n\t\tmemset(szBuffer,0,10);\t\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwCount);\t\t\t\n\t\tSetWindowText(hEdit,szBuffer);\t\t\t\n\t\tdwIndex++;\t\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t&#125;\t\n\t&#x2F;&#x2F;free delete\n\n\treturn 0;\t\t\t\t\n&#125;\t\t\t\t\t\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\t\n\tDWORD dwIndex &#x3D; 0;\t\t\t\t\n\tDWORD dwCount;\t\t\t\t\n\n\n\twhile(dwIndex&lt;10000)\t\t\t\t\n\t&#123;\t\t\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit,szBuffer,10);\t\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwCount );\t\t\t\n\t\tdwCount++;\t\t\t\n\t\tmemset(szBuffer,0,10);\t\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwCount);\t\t\t\n\t\tSetWindowText(hEdit,szBuffer);\t\t\t\n\t\tdwIndex++;\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t&#125;\t\t\t\t\n\n\treturn 0;\t\t\t\t\n&#125;\t\t\t\t\t\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tBOOL bRet &#x3D; FALSE;\t\t\t\t\n\n\tswitch(uMsg)\t\t\t\t\n\t&#123;\t\t\t\t\n\t\tcase WM_CLOSE:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tEndDialog(hDlg,0);\t\t\n\t\t\tbreak;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_INITDIALOG:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\thEdit &#x3D; GetDlgItem(hDlg,IDC_EDIT);\t\t\n\t\t\tSetWindowText(hEdit,&quot;0&quot;);\t\t\n\n\t\t\tbreak;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_COMMAND:\t\t\t\t\n\n\t\tswitch (LOWORD (wParam))\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tcase IDC_BUTTON1:\t\t\t\n\t\t\t&#123;\t\t\n\t\t\t\thThread1 &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\t\t\t\tNULL, 0, NULL);\n\n\t\t\t\t::CloseHandle(hThread1);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t\tcase IDC_BUTTON2:\t\t\t\n\t\t\t&#123;\t\t\n\n\t\t\t\thThread2 &#x3D; ::CreateThread(NULL, 0, ThreadProc2, \t\n\t\t\t\t\tNULL, 0, NULL);\n\n\t\t\t\t::CloseHandle(hThread2);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t\tcase IDC_BUTTON3:\t\t\t\n\t\t\t&#123;\t\t\n\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\t\n\t\t\tcase IDC_BUTTON4:\t\t\t\n\t\t\t&#123;\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t&#125;\t\n\t\tbreak ;\t\t\t\n\t&#125;\t\t\t\t\n\n\treturn bRet;\t\t\t\t\n&#125;\t\t\t\t\t\n\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\n\tInitializeCriticalSection(&amp;cs);\t\n\tDialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, MainDlgProc);\n\tDeleteCriticalSection(&amp;cs);\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n&#x2F;&#x2F;临界区\t\tthread_ctl\twin32 console\n#include &quot;stdafx.h&quot;\t\t\n#include &lt;windows.h&gt;\t\t\nCRITICAL_SECTION cs;\t\t\n\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int x&#x3D;0;x&lt;1000;x++)\t\n\t&#123;\t\n\t\tEnterCriticalSection(&amp;cs);\n\n\t\tSleep(1000);\n\t\t\n\t\tprintf(&quot;11111:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\n\n\t\tLeaveCriticalSection(&amp;cs);\n\t\t\n\t&#125;\t\n\treturn 0;\t\n&#125;\t\t\n\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int x&#x3D;0;x&lt;1000;x++)\t\n\t&#123;\t\n\t\tEnterCriticalSection(&amp;cs);\n\t\t\n\t\tSleep(1000);\n\t\t\n\t\tprintf(&quot;22222:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\n\t\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t\t\n\t&#125;\t\n\n\treturn 0;\t\n&#125;\t\t\n\nDWORD WINAPI ThreadProc3(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int x&#x3D;0;x&lt;1000;x++)\t\n\t&#123;\t\n\t\tEnterCriticalSection(&amp;cs);\n\t\t\n\t\tSleep(1000);\n\t\t\n\t\tprintf(&quot;33333:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\n\t\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t\t\n\t&#125;\t\n\n\treturn 0;\t\n&#125;\t\t\n\nDWORD WINAPI ThreadProc4(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int x&#x3D;0;x&lt;1000;x++)\t\n\t&#123;\t\n\t\tEnterCriticalSection(&amp;cs);\n\t\t\n\t\tSleep(1000);\n\t\t\n\t\tprintf(&quot;44444:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\n\t\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t\t\n\t&#125;\t\n\n\treturn 0;\t\n&#125;\t\t\n\n\nint main(int argc, char* argv[])\t\t\n&#123;\t\t\n\tInitializeCriticalSection(&amp;cs);\t\n\n\t&#x2F;&#x2F;printf(&quot;主线程:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\t\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread1 &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread2 &#x3D; ::CreateThread(NULL, 0, ThreadProc2, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread3 &#x3D; ::CreateThread(NULL, 0, ThreadProc3, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread4 &#x3D; ::CreateThread(NULL, 0, ThreadProc4, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;如果不在其他的地方引用它 关闭句柄\t\n\t::CloseHandle(hThread1);\t\n\t::CloseHandle(hThread2);\t\n\t::CloseHandle(hThread3);\t\n\t::CloseHandle(hThread4);\t\n\n\tSleep(1000*60*60);\t\n\n\tDeleteCriticalSection(&amp;cs);\n\n\treturn 0;\t\n&#125;\t\t\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;互斥体 mutex\n&#x2F;*\nWIN32 使用 MUTEX 实现禁止多开\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;Kwansy&#x2F;article&#x2F;details&#x2F;106485735\n*&#x2F;\n&#x2F;&#x2F; MutexLimitMultiOpen2.cpp : Defines the entry point for the application.\n&#x2F;&#x2F;\n\n#include &quot;stdafx.h&quot;\n\nBOOL CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)\n&#123;\n\tswitch(uMsg)\n\t&#123;\n\tcase WM_CLOSE:\n\t\t&#123;\n\t\t\tEndDialog(hDlg, 0);\n\t\t\treturn TRUE;\n\t\t&#125;\n\t&#125;\n\treturn FALSE;\n&#125;\n\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n                     HINSTANCE hPrevInstance,\n                     LPSTR     lpCmdLine,\n                     int       nCmdShow)\n&#123;\n\tHANDLE hMutex;\n\t&#x2F;&#x2F; 尝试获取\n\thMutex &#x3D; OpenMutex(MUTEX_ALL_ACCESS, FALSE, &quot;MYMUTEXTAG&quot;);\n\tif (NULL &#x3D;&#x3D; hMutex)\n\t&#123;\n\t\t&#x2F;&#x2F; 如果没有，说明咱是第一个，那就创建一个MUTEX\n\t\thMutex &#x3D; CreateMutex(0, FALSE, &quot;MYMUTEXTAG&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F; 如果有，说明已经有了，不准多开\n\t\tMessageBox(0, &quot;请不要多开&quot;, &quot;Error&quot;, MB_OK);\n\t\treturn -1;\n\t&#125;\n \tDialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), 0, DlgProc);\n\tReleaseMutex(hMutex);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n&#x2F;&#x2F;WaitForSingleObject\n#include &lt;windows.h&gt;\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int i&#x3D;0;i&lt;5;i++)\t\n\t&#123;\t\n\t\tprintf(&quot;+++++++++\\n&quot;);\n\t\tSleep(1000);\n\t&#125;\t\n\treturn 0;\t\n&#125;\t\t\n\nint main(int argc, char* argv[])\t\t\n&#123;\t\t\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread1 &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\tNULL, 0, NULL);\n\t&#x2F;&#x2F;WaitForSingleObject处理的是进程&#x2F;线程句柄(para1),不会恢复回“未通知”状态，保持“已通知”\n\t&#x2F;&#x2F;[其他内核对象的话不一定，有可能恢复回“未通知”状态，会一直等，一直阻塞！！！！]\n\t\n\t&#x2F;&#x2F;DWORD dwCode &#x3D; ::WaitForSingleObject(hThread1, INFINITE);&#x2F;&#x2F;3000 监视0环内存\n\t\n\t::WaitForSingleObject(hThread1, 3000);\n\tMessageBox(0,0,0,0);\n\t::WaitForSingleObject(hThread1, 3000);\n\tMessageBox(0,0,0,0);\n\t::WaitForSingleObject(hThread1, 3000);\n\tMessageBox(0,0,0,0);\n\n\t&#x2F;&#x2F;CloseHandle(hThread1);&#x2F;&#x2F;否则[程序运行时]：内核对象泄露\n\n\treturn 0;\t\n&#125;\t\t\n\n\n\n&#x2F;&#x2F;WaitForMultipleObjects\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int i&#x3D;0;i&lt;5;i++)\t\n\t&#123;\t\n\t\tprintf(&quot;+++++++++\\n&quot;);\n\t\tSleep(1000);\n\t&#125;\t\n\treturn 0;\t\n&#125;\t\t\n\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int i&#x3D;0;i&lt;3;i++)\t\n\t&#123;\t\n\t\tprintf(&quot;---------\\n&quot;);\n\t\tSleep(1000);\n\t&#125;\t\n\n\treturn 0;\t\n&#125;\t\t\n\n\nint main(int argc, char* argv[])\t\t\n&#123;\t\t\n\n\tHANDLE hArray[2];\t\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread1 &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread2 &#x3D; ::CreateThread(NULL, 0, ThreadProc2, \t\n\t\tNULL, 0, NULL);\n\n\thArray[0] &#x3D; hThread1;\t\n\thArray[1] &#x3D; hThread2;\t\n\n\tDWORD dwCode &#x3D; ::WaitForMultipleObjects(2, hArray,FALSE,INFINITE);\t\n\tCloseHandle(hArray[0]);\n\tCloseHandle(hArray[1]);\n\t\n\tMessageBox(0,0,0,0);\t\n\n\treturn 0;\t\n&#125;\t\t\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_41020820&#x2F;article&#x2F;details&#x2F;108029582\n&#x2F;&#x2F;抢红包-临界区\n#include &quot;stdafx.h&quot;\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &quot;resource.h&quot;\n\nHWND hEdit1,hEdit2,hEdit3,hEdit4;\nCRITICAL_SECTION cs;\n\nDWORD WINAPI GetMoney1(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0; &#x2F;&#x2F;从EDIT1当中通过GetWindowText()获取到的红包金额\n\tDWORD dwMoney&#x3D;0; &#x2F;&#x2F;当前线程金额\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit2,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money) &#x2F;&#x2F;红包金额\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,–-Money);\n\t\t\tSetWindowText(hEdit2,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tflag&#x3D;FALSE;\n\t\t&#125;\n\t\tLeaveCriticalSection(&amp;cs);\n\t\tSleep(50);\n\t&#125;\n\treturn 0;\n&#125;\n\nDWORD WINAPI GetMoney2(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit3,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,–-Money);\n\t\t\tSetWindowText(hEdit3,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;else\n\t\t&#123;\n\t\t\tflag&#x3D;FALSE;\n\t\t&#125;\n\t\tLeaveCriticalSection(&amp;cs);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n\n&#125;\nDWORD WINAPI GetMoney3(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit4,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,–-Money);\n\t\t\tSetWindowText(hEdit4,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tflag &#x3D;FALSE;\n\t\t&#125;\n\t\tLeaveCriticalSection(&amp;cs);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n\n&#125;\n\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\n&#123;\n\tHANDLE hThreads[3];\n\thThreads[0]&#x3D; CreateThread(NULL,0,GetMoney1,NULL,NULL,NULL);\n\thThreads[1]&#x3D;CreateThread(NULL,0,GetMoney2,NULL,NULL,NULL);\n\thThreads[2]&#x3D;CreateThread(NULL,0,GetMoney3,NULL,NULL,NULL);\n\n\tWaitForMultipleObjects(3,hThreads,TRUE,INFINITE);\n\t&#x2F;&#x2F;自己用来释放资源的代码\n\tCloseHandle(hThreads[0]);\n\tCloseHandle(hThreads[1]);\n\tCloseHandle(hThreads[2]);\n\treturn 0;\n&#125;\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tswitch(uMsg)\n\t&#123;\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hDlg,0);\n\t\t\treturn TRUE;\n\t\tcase WM_INITDIALOG:\n\t\t&#123;\n\t\t\thEdit1 &#x3D; GetDlgItem(hDlg,IDC_EDIT1);\n\t\t\thEdit2 &#x3D; GetDlgItem(hDlg,IDC_EDIT2);\n\t\t\thEdit3 &#x3D; GetDlgItem(hDlg,IDC_EDIT3);\n\t\t\thEdit4 &#x3D; GetDlgItem(hDlg,IDC_EDIT4);\n\t\t\tSetWindowText(hEdit1,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\n\t\t\treturn TRUE;\n\t\t&#125;\n\t\tcase WM_COMMAND:\n\t\t\tswitch(LOWORD(wParam))\n\t\t\t&#123;\n\t\t\t\tcase IDC_BUTTON1:\n\t\t\t\t&#123;\n\t\t\t\t\tTCHAR szBuff[10];\n\t\t\t\t\tmemset(szBuff,0,10);\n\t\t\t\t\tGetWindowText(hEdit1,szBuff,10);\n\t\t\t\t\tSetWindowText(hEdit1,szBuff);\n\t\t\t\t\tSetWindowText(hEdit2,“0”);\n\t\t\t\t\tSetWindowText(hEdit3,“0”);\n\t\t\t\t\tSetWindowText(hEdit4,“0”);\n\t\t\t\t\tCreateThread(NULL,0,ThreadProc1,NULL,NULL,NULL);\n\t\t\t\t\t&#x2F;&#x2F;WaitForSingleObject(hThread,INFINITE);\n\t\t\t\t\treturn TRUE;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tbreak;\n\t&#125;\n\treturn 0;\n&#125;\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR lpCmdLine,\n\tint nCmdShow)\n&#123;\n&#x2F;&#x2F; TODO: Place code here.\n\tInitializeCriticalSection(&amp;cs);\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\treturn 0;\n&#125;\n\n\n\n\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_41020820&#x2F;article&#x2F;details&#x2F;108029837\n&#x2F;&#x2F;抢红包-mutex (hongbao)\n#include &quot;stdafx.h&quot;\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &quot;resource.h&quot;\n\nHWND hEdit1,hEdit2,hEdit3,hEdit4;\n\nHANDLE hMutex;\n\n&#x2F;&#x2F;CRITICAL_SECTION cs;\n\nDWORD WINAPI GetMoney1(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\n\t\t&#x2F;&#x2F;EnterCriticalSection(&amp;cs);\n\t\tWaitForSingleObject(hMutex,INFINITE);\n\t\tGetWindowText(hEdit2,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,--Money);\n\t\t\tSetWindowText(hEdit2,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tflag&#x3D;FALSE;\n\t\t&#125;\n\t\t&#x2F;&#x2F;LeaveCriticalSection(&amp;cs);\n\t\tReleaseMutex(hMutex);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n&#125;\nDWORD WINAPI GetMoney2(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\t&#x2F;&#x2F;EnterCriticalSection(&amp;cs);\n\t\tWaitForSingleObject(hMutex,INFINITE);\n\t\tGetWindowText(hEdit3,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,-–Money);\n\t\t\tSetWindowText(hEdit3,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;else\n\t\t&#123;\n\t\t\tflag&#x3D;FALSE;\n\t\t&#125;\n\t\t&#x2F;&#x2F;LeaveCriticalSection(&amp;cs);\n\t\tReleaseMutex(hMutex);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n\n&#125;\nDWORD WINAPI GetMoney3(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\t&#x2F;&#x2F;EnterCriticalSection(&amp;cs);\n\t\tWaitForSingleObject(hMutex,INFINITE);\n\t\tGetWindowText(hEdit4,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,-–Money);\n\t\t\tSetWindowText(hEdit4,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tflag &#x3D;FALSE;\n\t\t&#125;\n\t\t&#x2F;&#x2F;LeaveCriticalSection(&amp;cs);\n\t\tReleaseMutex(hMutex);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n\n&#125;\n\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\n&#123;\n\thMutex&#x3D; CreateMutex( NULL,FALSE, NULL);\n\tHANDLE hThreads[3];\n\thThreads[0]&#x3D; CreateThread(NULL,0,GetMoney1,NULL,NULL,NULL);\n\thThreads[1]&#x3D;CreateThread(NULL,0,GetMoney2,NULL,NULL,NULL);\n\thThreads[2]&#x3D;CreateThread(NULL,0,GetMoney3,NULL,NULL,NULL);\n\n\tWaitForMultipleObjects(3,hThreads,TRUE,INFINITE);\n\t&#x2F;&#x2F;自己用来释放资源的代码\n\tCloseHandle(hThreads[0]);\n\tCloseHandle(hThreads[1]);\n\tCloseHandle(hThreads[2]);\n\tCloseHandle(hMutex);\n\treturn 0;\n&#125;\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tswitch(uMsg)\n\t&#123;\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hDlg,0);\n\t\t\treturn TRUE;\n\t\tcase WM_INITDIALOG:\n\t\t&#123;\n\t\t\thEdit1 &#x3D; GetDlgItem(hDlg,IDC_EDIT1);\n\t\t\thEdit2 &#x3D; GetDlgItem(hDlg,IDC_EDIT2);\n\t\t\thEdit3 &#x3D; GetDlgItem(hDlg,IDC_EDIT3);\n\t\t\thEdit4 &#x3D; GetDlgItem(hDlg,IDC_EDIT4);\n\t\t\tSetWindowText(hEdit1,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\n\t\t\treturn TRUE;\n\t\t&#125;\n\t\tcase WM_COMMAND:\n\t\t\tswitch(LOWORD(wParam))\n\t\t\t&#123;\n\t\t\t\tcase IDC_BUTTON1:\n\t\t\t\t&#123;\n\t\t\t\t\tTCHAR szBuff[10];\n\t\t\t\t\tmemset(szBuff,0,10);\n\t\t\t\t\tGetWindowText(hEdit1,szBuff,10);\n\t\t\t\t\tSetWindowText(hEdit1,szBuff);\n\t\t\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\n\t\t\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\n\t\t\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\n\t\t\t\t\tCreateThread(NULL,0,ThreadProc1,NULL,NULL,NULL);\n\t\t\t\t\t&#x2F;&#x2F;WaitForSingleObject(hThread,INFINITE);\n\t\t\t\t\treturn TRUE;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tbreak;\n\t&#125;\n\treturn 0;\n&#125;\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR lpCmdLine,\n\tint nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\t&#x2F;&#x2F;InitializeCriticalSection(&amp;cs);\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\treturn 0;\n&#125;\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;线程同步\n\n&#x2F;&#x2F;event\n#include &quot;stdafx.h&quot;\n\nHANDLE g_hEvent;\t\n\t\nHWND hEdit1;\t\nHWND hEdit2;\t\nHWND hEdit3;\t\nHWND hEdit4;\t\nHANDLE hThread1;\t\nHANDLE hThread2;\t\nHANDLE hThread3;\t\nHANDLE hThread4;\t\n\t\n\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\n&#123;\t\n\tTCHAR szBuffer[10] &#x3D; &#123;0&#125;;\n\t\n\t&#x2F;&#x2F;当事件变成已通知时 \n\tWaitForSingleObject(g_hEvent, INFINITE);&#x2F;&#x2F;auto改成未通知\n\t\n\t&#x2F;&#x2F;读取内容\n\tGetWindowText(hEdit1,szBuffer,10);\n\tSleep(1000);\t\n\tSetWindowText(hEdit2,szBuffer);\n\n\tSetEvent(g_hEvent);\n\n\treturn 0;\n&#125;\t\nDWORD WINAPI ThreadProc3(LPVOID lpParameter)\t\n&#123;\t\n\tTCHAR szBuffer[10] &#x3D; &#123;0&#125;;\n\t\n\t&#x2F;&#x2F;当事件变成已通知时 \n\tWaitForSingleObject(g_hEvent, INFINITE);\n\t\n\t&#x2F;&#x2F;读取内容\n\tGetWindowText(hEdit1,szBuffer,10);\n\tSleep(1000);\t\n\tSetWindowText(hEdit3,szBuffer);\n\tSetEvent(g_hEvent);\n\n\treturn 0;\n&#125;\t\nDWORD WINAPI ThreadProc4(LPVOID lpParameter)\t\n&#123;\t\n\tTCHAR szBuffer[10] &#x3D; &#123;0&#125;;\n\t\n\t&#x2F;&#x2F;当事件变成已通知时 \n\tWaitForSingleObject(g_hEvent, INFINITE);\n\t\n\t&#x2F;&#x2F;读取内容\n\tGetWindowText(hEdit1,szBuffer,10);\n\tSleep(1000);\t\n\tSetWindowText(hEdit4,szBuffer);\n\tSetEvent(g_hEvent);\n\n\treturn 0;\n&#125;\t\n\n\nDWORD WINAPI ThreadMain(LPVOID lpParameter)\t\n&#123;\t\n\t&#x2F;&#x2F;创建事件\n\t&#x2F;&#x2F;默认安全属性  手动设置未通知状态(TRUE)  初始状态未通知 没有名字 \n\tg_hEvent &#x3D; CreateEvent(NULL, FALSE, FALSE, NULL);&#x2F;&#x2F;auto改成未通知\n\tHANDLE hThread[3];\n\t&#x2F;&#x2F;创建3个线程\n\thThread[0] &#x3D; ::CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL);\n\thThread[1] &#x3D; ::CreateThread(NULL, 0, ThreadProc3, NULL, 0, NULL);\n\thThread[2] &#x3D; ::CreateThread(NULL, 0, ThreadProc4, NULL, 0, NULL);\n\t\n\t&#x2F;&#x2F;设置文本框的值\n\tSetWindowText(hEdit1,&quot;1000&quot;);\n\t\n\t&#x2F;&#x2F;设置事件为已通知\n\tSetEvent(g_hEvent);\n\tSleep(50);\n\t&#x2F;&#x2F;等待线程结束 销毁内核对象\n\tWaitForMultipleObjects(3, hThread, TRUE, INFINITE);  \n\tCloseHandle(hThread[0]);  \n\tCloseHandle(hThread[1]);\n\tCloseHandle(hThread[2]);\n\tCloseHandle(g_hEvent);  \n\t\n\treturn 0;\n&#125;\t\n\t\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tswitch(uMsg)\n\t&#123;\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hDlg,0);\n\t\t\treturn TRUE;\n\t\tcase WM_INITDIALOG:\n\t\t&#123;\n\t\t\thEdit1 &#x3D; GetDlgItem(hDlg,IDC_EDIT1);\n\t\t\thEdit2 &#x3D; GetDlgItem(hDlg,IDC_EDIT2);\n\t\t\thEdit3 &#x3D; GetDlgItem(hDlg,IDC_EDIT3);\n\t\t\thEdit4 &#x3D; GetDlgItem(hDlg,IDC_EDIT4);\n\t\t\tSetWindowText(hEdit1,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\n\t\t\treturn TRUE;\n\t\t&#125;\n\t\tcase WM_COMMAND:\n\t\t\tswitch(LOWORD(wParam))\n\t\t\t&#123;\n\t\t\t\tcase IDC_BUTTON_BEGIN:\n\t\t\t\t&#123;\n\n\t\t\t\t\t::CreateThread(NULL,0,ThreadMain,NULL,NULL,NULL);\n\n\t\t\t\t\treturn TRUE;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tbreak;\n\t&#125;\n\treturn 0;\n&#125;\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\t\t\t\t\t HINSTANCE hPrevInstance,\n\t\t\t\t\t LPSTR     lpCmdLine,\n\t\t\t\t\t int       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;ProdConsum\n&#x2F;&#x2F;事件 实现线程同步[交替 轮流]\nHANDLE g_hSet, g_hClear;\t\t\nint g_Max &#x3D; 10;\t\t\nint g_Number &#x3D; 0;\t\t\n\t\t\t\t\t\t\n&#x2F;&#x2F;生产者线程函数  \t\t\nDWORD WINAPI ThreadProduct(LPVOID pM)  \t\t\n&#123;  \t\t\n\tfor (int i &#x3D; 0; i &lt; g_Max; i++)\t\t\n\t&#123;  \t\t\n\t\tWaitForSingleObject(g_hSet, INFINITE);\t\t&#x2F;&#x2F;\n\t\tg_Number &#x3D; 1; \n\t\tDWORD id &#x3D; GetCurrentThreadId();\n\t\tprintf(&quot;生产者%d将数据%d放入缓冲区\\n&quot;,id, g_Number); \n\t\tSetEvent(g_hClear);\t\t&#x2F;&#x2F;\n\t&#125;  \t\t\n\treturn 0;  \t\t\n&#125;  \t\t\n&#x2F;&#x2F;消费者线程函数\t\t\nDWORD WINAPI ThreadConsumer(LPVOID pM)  \t\t\n&#123;  \t\t\n\tfor (int i &#x3D; 0; i &lt; g_Max; i++)\t\t\n\t&#123;  \t\t\n\t\tWaitForSingleObject(g_hClear, INFINITE);\t&#x2F;&#x2F;\n\t\tg_Number &#x3D; 0; \n\t\tDWORD id &#x3D; GetCurrentThreadId();\n\t\tprintf(&quot;----消费者%d将数据%d放入缓冲区\\n&quot;,id, g_Number); \n\t\tSetEvent(g_hSet);\t\t&#x2F;&#x2F;\n\t&#125;  \t\t\n\treturn 0;  \t\t\n&#125;  \t\t\n\t\t\nint main(int argc, char* argv[])\t\t\n&#123;\t\t\n\t\t\n\tHANDLE hThread[2]; \t\t\n\t\t\n\tg_hSet &#x3D; CreateEvent(NULL, FALSE, TRUE, NULL); &#x2F;&#x2F;false:auto改 \ttrue:Producer先\n\tg_hClear &#x3D; CreateEvent(NULL, FALSE, FALSE, NULL); \t\t\t\t&#x2F;&#x2F;false\n\t\t\n\thThread[0] &#x3D; ::CreateThread(NULL, 0, ThreadProduct, NULL, 0, NULL); \t\t\n\thThread[1] &#x3D; ::CreateThread(NULL, 0, ThreadConsumer, NULL, 0, NULL);\t\n\t\t\n\tWaitForMultipleObjects(2, hThread, TRUE, INFINITE);  \t\t\n\tCloseHandle(hThread[0]);\t\t\n\tCloseHandle(hThread[1]);\t\t\n\t\t\n\t&#x2F;&#x2F;销毁 \t\n\tCloseHandle(g_hSet);  \t\n\tCloseHandle(g_hClear);  \t\t\n\t\t\n\tgetchar();\n\treturn 0;\t\n&#125;\t\t\n\n\n\n\n&#x2F;&#x2F;Semaphore:hongbao\n#include &quot;stdafx.h&quot;\t\t\t\t\n#include &quot;resource.h&quot;\t\t\t\t\nHANDLE hSemaphore;\t\t\t\t\nHWND hArray[3];\t\t\t\t\nHWND hEdit1;\nHWND hEdit2;\nHWND hEdit3;\nHWND hEdit4;\t\t\t\t\nHANDLE hThread[3];\n\t\t\t\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\t\t\n&#123;\t\t\t\t\n\tTCHAR szBuffer[10];\t\n\n\tDWORD dwTimmer&#x3D;0;\t\t\t\n\tWaitForSingleObject(hSemaphore, INFINITE);\n\t\n\tDWORD dwIndex &#x3D; (DWORD)lpParameter;\n\twhile(dwTimmer&lt;100)\t\t\t\n\t&#123;\t\t\t\n\t\tSleep(50);\t\t\n\t\tmemset(szBuffer,0,10);\t\t\n\t\tGetWindowText(hArray[dwIndex],szBuffer,10);\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwTimmer );\t\t\n\t\tdwTimmer++;\t\t\n\t\tmemset(szBuffer,0,10);\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwTimmer);\t\t\n\t\tSetWindowText(hArray[dwIndex],szBuffer);\t\t\n\t&#125;\t\t\t\n\tReleaseSemaphore(hSemaphore, 1, NULL);\t\t\t\n\treturn 0;\t\t\t\n&#125;\t\t\n\nDWORD WINAPI ThreadBegin(LPVOID lpParameter)\t\t\t\t\n&#123;\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\n\tDWORD dwMoney&#x3D;0;\t\t\t\n\t\t\t\t\n\t\t\t\t\n\thSemaphore &#x3D; CreateSemaphore(NULL,0,3,NULL);\t\t\t\n\t\t\n\t\n\thThread[0] &#x3D; ::CreateThread(NULL, 0, ThreadProc1, (void*)0, 0, NULL);\t\t\t\n\thThread[1] &#x3D; ::CreateThread(NULL, 0, ThreadProc1, (void*)1, 0, NULL);\t\t\t\n\thThread[2] &#x3D; ::CreateThread(NULL, 0, ThreadProc1, (void*)2, 0, NULL);\t\t\t\n\t\t\t\t\n\t&#x2F;&#x2F;开始准备红包\t\t\t\n\twhile(dwMoney&lt;1000)\t\t\t\n\t&#123;\t\t\t\n\t\tmemset(szBuffer,0,10);\t\t\n\t\tGetWindowText(hEdit1,szBuffer,10);\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwMoney );\t\t\n\t\tdwMoney++;\t\t\n\t\tmemset(szBuffer,0,10);\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwMoney);\t\t\n\t\tSetWindowText(hEdit1,szBuffer);\t\t\n\t&#125;\t\t\t\n\tReleaseSemaphore(hSemaphore, 2, NULL);\t&#x2F;&#x2F;\t\t\n\t\t\t\t\n\t::WaitForMultipleObjects(3, hThread,TRUE,INFINITE);\t\t\t\n\t::CloseHandle(hSemaphore);\t\t\t\n\t\t\t\t\n\treturn 0;\t\t\t\n&#125;\t\t\t\t\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\t\t\t\t\n&#123;\t\t\t\t\n\tBOOL bRet &#x3D; FALSE;\t\t\t\n\t\t\t\t\n\tswitch(uMsg)\t\t\t\n\t&#123;\t\t\t\n\tcase WM_CLOSE:\t\t\t\n\t\t&#123;\t\t\n\t\t\tEndDialog(hDlg,0);\t\n\t\t\tbreak;\t\n\t\t&#125;\t\t\n\tcase WM_INITDIALOG:\t\t\t\n\t\t&#123;\t\t\n\t\t\thEdit1 &#x3D; GetDlgItem(hDlg,IDC_EDIT1);\t\n\t\t\thEdit2 &#x3D; GetDlgItem(hDlg,IDC_EDIT2);\t\n\t\t\thEdit3 &#x3D; GetDlgItem(hDlg,IDC_EDIT3);\t\n\t\t\thEdit4 &#x3D; GetDlgItem(hDlg,IDC_EDIT4);\t\n\t\t\t\t\n\t\t\tSetWindowText(hEdit1,&quot;0&quot;);\t\n\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\t\n\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\t\n\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\t\n\n\t\t\thArray[0] &#x3D; hEdit2;\n\t\t\thArray[1] &#x3D; hEdit3;\n\t\t\thArray[2] &#x3D; hEdit4;\n\t\t\t\t\n\t\t\tbreak;\t\n\t\t&#125;\t\t\n\tcase WM_COMMAND:\t\t\t\n\t\t\t\t\n\t\tswitch (LOWORD (wParam))\t\t\n\t\t&#123;\t\t\n\t\tcase IDC_BUTTON1:\t\t\n\t\t\t&#123;\t\n\t\t\t\tCreateThread(NULL, 0, ThreadBegin,NULL, 0, NULL);\n\t\t\t\t\n\t\t\t\treturn TRUE;\n\t\t\t&#125;\t\n\t\t&#125;\t\t\n\t\tbreak ;\t\t\n\t&#125;\t\t\t\n\t\t\t\t\n\treturn bRet;\t\t\t\n&#125;\t\t\t\t\nint APIENTRY WinMain(HINSTANCE hInstance,\t\t\t\t\n\t\t\t\t\t HINSTANCE hPrevInstance,\t\t\t\t\n\t\t\t\t\t LPSTR     lpCmdLine,\t\t\t\t\n\t\t\t\t\t int       nCmdShow)\t\t\t\t\n&#123;\t\t\t\t\n\t&#x2F;&#x2F; TODO: Place code here.\t\t\t\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\t\t\t\n\treturn 0;\t\t\t\n&#125;\t\t\t\t\n\n\n\n\n\n\n\n\n\n&#x2F;*\n吃字母\n\n(1)ziyuan：输入ABCDEF\n(2)buffer*2\n(3)consumer*4\n\n(1)(3)资源间同步\n(2)资源与buffer之间R&#x2F;W互斥\n\nzzzzzz\n*&#x2F;\n\n#include &quot;stdafx.h&quot;\n#include &quot;resource.h&quot;\n&#x2F;&#x2F;文本框句柄\nHWND hEdit_RC;\nHWND hEdit_B1;\nHWND hEdit_B2;\nHWND hEdit_C1;\nHWND hEdit_C2;\nHWND hEdit_C3;\nHWND hEdit_C4;\n&#x2F;&#x2F;线程数组\nHANDLE hThread[5];\n&#x2F;&#x2F;互斥体[临界区]：缓冲区\nCRITICAL_SECTION g_Buffer_CS;\n&#x2F;&#x2F;信号量：缓冲区有空闲\nHANDLE hSemaphoreEmpty;\n&#x2F;&#x2F;信号量：缓冲区有资源\nHANDLE hSemaphoreFull;\n&#x2F;&#x2F;缓冲区文本框数组\nHWND hEditBuffer[3];\n&#x2F;&#x2F;消费者文本框数组\nHWND hEditCustomer[4];\n\nDWORD WINAPI ThreadProduct(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[256];\n\tTCHAR szTemp[2];\n\tDWORD dwLength;\n\tmemset(szBuffer,0,256);\n\n\tGetWindowText(hEdit_RC,szBuffer,256);\n\tdwLength &#x3D; strlen(szBuffer);\n\tif(dwLength &#x3D;&#x3D; 0)\n\t\treturn -1;\n\tfor(DWORD i&#x3D;0;i&lt;dwLength;i++)\n\t&#123;\n\t\t&#x2F;&#x2F;等待缓冲区可写资源的信息\n\t\tWaitForSingleObject(hSemaphoreEmpty, INFINITE);&#x2F;&#x2F;empty-1\n\t\t&#x2F;&#x2F;找到可写的缓冲区\n\t\tfor(DWORD k&#x3D;0;k&lt;2;k++)\n\t\t&#123;\n\t\t\tmemset(szTemp,0,2);\n\t\t\tEnterCriticalSection(&amp;g_Buffer_CS); \n\t\t\tGetWindowText(hEditBuffer[k],szTemp,2);\n\t\t\tif(!strcmp(szTemp,&quot;0&quot;))\n\t\t\t&#123;\n\t\t\t\tTCHAR szT[2] &#x3D; &#123;0&#125;;\n\t\t\t\tmemcpy(szT,&amp;szBuffer[i],1);\n\t\t\t\tSetWindowText(hEditBuffer[k],szT);\n\t\t\t\tLeaveCriticalSection(&amp;g_Buffer_CS); \n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\tLeaveCriticalSection(&amp;g_Buffer_CS); \n\t\t&#125;\n\t\t&#x2F;&#x2F;通知 缓冲区有资源\n\t\tSleep(1000);\n\t\tReleaseSemaphore(hSemaphoreFull, 1, NULL);&#x2F;&#x2F;full+1\n\t&#125;\n\treturn 0;\n&#125;\n\nDWORD WINAPI ThreadCustomer(LPVOID lpParameter)\n&#123;\n\tTCHAR szTemp[2];\n\tTCHAR szBuffer[256];\n\tTCHAR szNewBuffer[256];\n\tDWORD dwExitCode;\n\twhile(true)\n\t&#123;\n\t\t&#x2F;&#x2F;等待缓冲区有资源\n\t\tdwExitCode &#x3D; WaitForSingleObject(hSemaphoreFull, 10000);\n\t\tif(dwExitCode &#x3D;&#x3D; 0x102)\n\t\t\treturn -1;\n\t\t&#x2F;&#x2F;找到可写取资源的缓冲区\n\t\tEnterCriticalSection(&amp;g_Buffer_CS); \n\t\tfor(DWORD k&#x3D;0;k&lt;2;k++)\n\t\t&#123;\n\t\t\tmemset(szTemp,0,2);\n\t\t\tGetWindowText(hEditBuffer[k],szTemp,2);\n\t\t\tif(strcmp(szTemp,&quot;0&quot;))\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;存储到自己的文本框\n\t\t\t\tDWORD dwCusIndex &#x3D; (DWORD)lpParameter;\n\t\t\t\tmemset(szBuffer,0,256);\n\t\t\t\tGetWindowText(hEditCustomer[dwCusIndex],szBuffer,256);\n\t\t\t\tsprintf(szNewBuffer,&quot;%s-%s&quot;,szBuffer,szTemp);&#x2F;&#x2F;\n\t\t\t\tSetWindowText(hEditCustomer[dwCusIndex],szNewBuffer);\n\t\t\t\tSleep(500);\n\t\t\t\tSetWindowText(hEditBuffer[k],&quot;0&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tLeaveCriticalSection(&amp;g_Buffer_CS); \n\t\t&#x2F;&#x2F;通知 缓冲区可写\n\t\tSleep(1000);\n\t\tReleaseSemaphore(hSemaphoreEmpty, 1, NULL);\n\t&#125;\n\treturn 0;\n&#125;\n\nDWORD WINAPI ThreadMain(LPVOID lpParameter)\n&#123;\n\t&#x2F;&#x2F;创建信号量\n\thSemaphoreEmpty &#x3D; CreateSemaphore(NULL,2,2,NULL);\n\thSemaphoreFull &#x3D; CreateSemaphore(NULL,0,2,NULL);\n\t&#x2F;&#x2F;创建临界区\n\tInitializeCriticalSection(&amp;g_Buffer_CS);\n\t&#x2F;&#x2F;创建线程\n\thThread[0] &#x3D; ::CreateThread(NULL, 0, ThreadProduct,NULL, 0, NULL);\n\thThread[1] &#x3D; ::CreateThread(NULL, 0, ThreadCustomer,(void*)0, 0, NULL);\n\thThread[2] &#x3D; ::CreateThread(NULL, 0, ThreadCustomer,(void*)1, 0, NULL);\n\thThread[3] &#x3D; ::CreateThread(NULL, 0, ThreadCustomer,(void*)2, 0, NULL);\n\thThread[4] &#x3D; ::CreateThread(NULL, 0, ThreadCustomer,(void*)3, 0, NULL);\n\t&#x2F;&#x2F;等待线程结束\n\t::WaitForMultipleObjects(5, hThread,TRUE,INFINITE);\n\t::CloseHandle(hSemaphoreEmpty);\n\t::CloseHandle(hSemaphoreFull);\n\t::DeleteCriticalSection(&amp;g_Buffer_CS);  \n\n\treturn 0;\n&#125;\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tBOOL bRet &#x3D; FALSE;\n\t\n\tswitch(uMsg)\n\t&#123;\n\tcase WM_CLOSE:\n\t\t&#123;\n\t\t\tEndDialog(hDlg,0);\n\t\t\tbreak;\n\t\t&#125;\n\tcase WM_INITDIALOG:\n\t\t&#123;\n\t\t\thEdit_RC &#x3D; GetDlgItem(hDlg,IDC_EDIT_RC);\n\t\t\thEdit_B1 &#x3D; GetDlgItem(hDlg,IDC_EDIT_B1);\n\t\t\thEdit_B2 &#x3D; GetDlgItem(hDlg,IDC_EDIT_B2);\n\t\t\thEditBuffer[0] &#x3D; hEdit_B1;\n\t\t\thEditBuffer[1] &#x3D; hEdit_B2;\n\t\t\thEdit_C1 &#x3D; GetDlgItem(hDlg,IDC_EDIT_C1);\n\t\t\thEdit_C2 &#x3D; GetDlgItem(hDlg,IDC_EDIT_C2);\n\t\t\thEdit_C3 &#x3D; GetDlgItem(hDlg,IDC_EDIT_C3);\n\t\t\thEdit_C4 &#x3D; GetDlgItem(hDlg,IDC_EDIT_C4);\n\t\t\thEditCustomer[0] &#x3D; hEdit_C1;\n\t\t\thEditCustomer[1] &#x3D; hEdit_C2;\n\t\t\thEditCustomer[2] &#x3D; hEdit_C3;\n\t\t\thEditCustomer[3] &#x3D; hEdit_C4;\n\t\t\tSetWindowText(hEdit_RC,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit_B1,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit_B2,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit_C1,&quot;&quot;);\n\t\t\tSetWindowText(hEdit_C2,&quot;&quot;);\n\t\t\tSetWindowText(hEdit_C3,&quot;&quot;);\n\t\t\tSetWindowText(hEdit_C4,&quot;&quot;);\n\t\t\t\n\t\t\tbreak;\n\t\t&#125;\n\tcase WM_COMMAND:\n\t\t\n\t\tswitch (LOWORD (wParam))\n\t\t&#123;\n\t\tcase IDC_BUTTON_BEGIN:\n\t\t\t&#123;\n\n\t\t\t\tCreateThread(NULL, 0, ThreadMain,NULL, 0, NULL);\n\t\t\t\t\n\t\t\t\treturn TRUE;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\tbreak ;\n\t&#125;\n\t\n\treturn bRet;\n&#125;\nint APIENTRY WinMain(HINSTANCE hInstance,\n\t\t\t\t\t HINSTANCE hPrevInstance,\n\t\t\t\t\t LPSTR     lpCmdLine,\n\t\t\t\t\t int       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;&#x2F;进程\n&#x2F;&#x2F;process1\n#include &quot;windows.h&quot;\n\nVOID TestCreateProcess()\t\t\n&#123;\t\t\n\tSTARTUPINFO si &#x3D; &#123;0&#125;;   \t\n\t\tPROCESS_INFORMATION pi;\t\n\t\t\n\tsi.cb &#x3D; sizeof(si);\t\n\t\t\n\tTCHAR szCmdline[] &#x3D;TEXT(&quot; http:&#x2F;&#x2F;www.ifeng.com&quot;);&#x2F;&#x2F;space~\n\t\t\n\tBOOL res &#x3D; CreateProcess(\t\n\t\tTEXT(&quot;c:&#x2F;&#x2F;program files&#x2F;&#x2F;internet explorer&#x2F;&#x2F;iexplore.exe&quot;), \n\t\tszCmdline, \n\t\tNULL, \n\t\tNULL, \n\t\tFALSE, \n\t\tCREATE_NEW_CONSOLE, \n\t\tNULL, \n\t\tNULL, &amp;si, &amp;pi); \n\n\t&#x2F;&#x2F;printf(&quot;%x %x %x %x\\n&quot;,pi.dwProcessId,pi.dwThreadId,pi.hProcess,pi.hThread);\n&#125;\t\n\nint main(int argc, char* argv[])\n&#123;\n\tTestCreateProcess();\n\n&#x2F;&#x2F;\tprintf(&quot;%s\\n&quot;, argv[0]);\n&#x2F;&#x2F;\tprintf(&quot;%s\\n&quot;, argv[1]);\n\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;[句柄的继承]\n&#x2F;&#x2F;父进程handle\n#include &quot;windows.h&quot;\n\nint main(int argc, char* argv[])\n&#123;\n\tchar szBuffer[256] &#x3D; &#123;0&#125;;\n\tchar szHandle[8] &#x3D; &#123;0&#125;;\n\n\tSECURITY_ATTRIBUTES sa;\n\tsa.nLength &#x3D; sizeof(sa);\n\tsa.lpSecurityDescriptor &#x3D; NULL;\n\tsa.bInheritHandle &#x3D; TRUE; \n\t&#x2F;&#x2F;创建一个可以被继承的内核对象\n\tHANDLE g_hEvent &#x3D; CreateEvent(&amp;sa, TRUE, FALSE, NULL);\n\n\t&#x2F;&#x2F;组织命令行参数\t\n\tsprintf(szHandle,&quot;%x&quot;,g_hEvent);\t\n\tsprintf(szBuffer,&quot;C:&#x2F;handle2.exe %s&quot;,szHandle);&#x2F;&#x2F;子进程 父句柄\n\t\t\n\t&#x2F;&#x2F;定义创建进程需要用的结构体\t\n\tSTARTUPINFO si &#x3D; &#123;0&#125;;   \t\n\tPROCESS_INFORMATION pi;\t\n\tsi.cb &#x3D; sizeof(si);\t\n\t\n\t&#x2F;&#x2F;创建子进程\t\n\tBOOL res &#x3D; CreateProcess(\t\n\t\tNULL, \n\t\tszBuffer, \n\t\tNULL, \n\t\tNULL, \n\t\tTRUE, &#x2F;&#x2F; 允许继承（&#x3D;1）的句柄，copy父进程句柄表\n\t\tCREATE_NEW_CONSOLE, \n\t\tNULL, \n\t\tNULL, &amp;si, &amp;pi); \n\n\t&#x2F;&#x2F;设置事件为已通知\n\tSetEvent(g_hEvent);&#x2F;&#x2F;下断点，单步~~~~~~~~~~~~~~~~~~~~~~\n\n\t&#x2F;&#x2F;关闭句柄 内核对象是否会被销毁？否\n\tCloseHandle(g_hEvent);\n\n\tgetchar();\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;子进程handle2\n#include &quot;windows.h&quot;\n\nint main(int argc, char* argv[])\n&#123;\n\tchar szBuffer[256] &#x3D; &#123;0&#125;;\n\n\tmemcpy(szBuffer,argv[1],8);\n\n\tDWORD dwHandle &#x3D; 0;\n\n\tsscanf(szBuffer,&quot;%x&quot;,&amp;dwHandle);\n\n\tprintf(&quot;%s\\n&quot;,argv[0]);&#x2F;&#x2F; 子进程\n\n\tprintf(&quot;%x\\n&quot;,dwHandle);&#x2F;&#x2F; 父句柄\n\n\tHANDLE g_hEvent &#x3D; (HANDLE)dwHandle;&#x2F;&#x2F;复制系统有效句柄表\n\n\n\tprintf(&quot;开始等待.....\\n&quot;);\n\t&#x2F;&#x2F;当事件变成已通知时 \n\tWaitForSingleObject(g_hEvent, INFINITE);\n\n\tDWORD dwCode &#x3D; GetLastError();\n\n\tprintf(&quot;等到消息.....%x\\n&quot;,dwCode);\n\n\tgetchar();\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n2、以挂起的方式创建进程，获取进程的ImageBase和AddressOfEntryPoint\n\nSTARTUPINFO ie_si &#x3D; &#123;0&#125;;   \t\nPROCESS_INFORMATION ie_pi;\t\nie_si.cb &#x3D; sizeof(ie_si);\t\n\t\n&#x2F;&#x2F;以挂起的方式创建进程\t\nTCHAR szBuffer[256] &#x3D; &quot;C:\\\\ipmsg.exe&quot;;\t\nCreateProcess(\t\n\tNULL,                    &#x2F;&#x2F; name of executable module\n\tszBuffer,                &#x2F;&#x2F; command line string\n\tNULL, \n\tNULL,  \n\tFALSE,                   &#x2F;&#x2F; handle inheritance option\n\tCREATE_SUSPENDED,     \n\tNULL,                    &#x2F;&#x2F; new environment block\n\tNULL,                    &#x2F;&#x2F; current directory name\n\t&amp;ie_si,                  &#x2F;&#x2F; startup information\n\t&amp;ie_pi                   &#x2F;&#x2F; process information\n\t);\n\t\n\t\nCONTEXT contx;  \t\ncontx.ContextFlags &#x3D; CONTEXT_FULL;  \t\n\t\n\t\nGetThreadContext(ie_pi.hThread, &amp;contx);\t\n\t\n&#x2F;&#x2F;获取入口点：ImageBase+AddressOfEntryPoint\t\nDWORD dwEntryPoint &#x3D; contx.Eax;\t\n\t\n&#x2F;&#x2F;获取ImageBase\t\nchar* baseAddress &#x3D; (CHAR *) contx.Ebx+8;\t\n\t\nmemset(szBuffer,0,256);\t\n\t\nReadProcessMemory(ie_pi.hProcess,baseAddress,szBuffer,4,NULL);\t\n\t\n&#x2F;&#x2F;将自己的壳子 拉伸 替换外壳程序。。。。\n\n\n&#x2F;&#x2F;恢复执行\nResumeThread(ie_pi.hThread);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\nhttps:&#x2F;&#x2F;download.csdn.net&#x2F;download&#x2F;xubiniq&#x2F;364282\n\n\n&#x2F;&#x2F;2015-5-21加密壳项目video:\t\thttps:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1yt41127Cd?p&#x3D;85\n&#x2F;&#x2F;part\nhttps:&#x2F;&#x2F;bbs.pediy.com&#x2F;thread-258555.htm\nhttps:&#x2F;&#x2F;bbs.pediy.com&#x2F;thread-258657.htm\nhttps:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1135335-1-1.html\nhttps:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-931981-1-1.html        shell.rar&#x2F;123.rar\n&#x2F;&#x2F;file\nhttps:&#x2F;&#x2F;www.haolizi.net&#x2F;example&#x2F;view_27057.html\nhttps:&#x2F;&#x2F;download.csdn.net&#x2F;download&#x2F;qq_41490873&#x2F;11255977?utm_medium&#x3D;distribute.pc_relevant_download.none-task-download-blogcommendfrombaidu-1.nonecase&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_download.none-task-download-blogcommendfrombaidu-1.nonecase\n&#x2F;&#x2F;blog\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;ABCDABCD321123&#x2F;article&#x2F;details&#x2F;106852327?utm_medium&#x3D;distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase\n\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;ILXYR&#x2F;p&#x2F;13436933.html\n&#x2F;&#x2F;PEStudy.h\n#pragma once\n#define _CRT_SECURE_NO_WARNINGS\n#include &lt;wtypes.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;Windows.h&gt;\n#include&lt;stdlib.h&gt;\n\nclass PEStudy\n&#123;\npublic:\n\tsize_t thisSize;&#x2F;&#x2F;This data is the size of opende file\n\tIN CHAR _lpszfFile[100] &#x3D; &quot;C:\\\\Users\\\\86182\\\\source\\\\repos\\\\Shell\\\\Release\\\\Shell.exe&quot;;\n\tOUT LPVOID* _pFileBuffer &#x3D; nullptr;\n\tPIMAGE_RESOURCE_DIRECTORY pImageResourceHeader &#x3D; nullptr;&#x2F;&#x2F;this ptr is init in the findresource() func\n\tPIMAGE_DOS_HEADER pImageDosHeader &#x3D; nullptr;\n\tPIMAGE_FILE_HEADER pImageFileHeader &#x3D; nullptr;\n\tPIMAGE_OPTIONAL_HEADER pImageOptionalPEHeader &#x3D; nullptr;\n\tPIMAGE_OPTIONAL_HEADER64 pImageOptionalHeader64 &#x3D; nullptr;\n\tPIMAGE_SECTION_HEADER pImageSectionHeads[99] &#x3D; &#123; nullptr &#125;;\n\tWORD SectionNumNow &#x3D; 0;&#x2F;&#x2F;The section number\n\n\tvoid initAllPoint();\n\tsize_t readFileBufferToTempBuffer(IN CHAR* lpszfFile, OUT LPVOID* pFileBuffer);&#x2F;&#x2F; lpszFile: The road of the desFile\n\tvoid printDosHeader();\n\tvoid printFilePEHeader();\n\tvoid printOptionalPEHeader();&#x2F;&#x2F;各种表的数据均未导出\n\tvoid getSectionHeaders();\n\tWORD maxNow(DWORD a, DWORD b) &#123; return a &gt; b ? a : b; &#125;\n\tDWORD RVAToFOA(DWORD RVA);\n\tDWORD FOAToRVA(DWORD RVA);\n\tDWORD querryAddress(DWORD beforeAddress, DWORD Size, DWORD align);\n\tvoid addASection(const char* chunkName,DWORD chunkSize);\n\tvoid SaveToTheSameCatalog(const char* fileName);\n\tvoid addSize(DWORD chunkSize);\n\t&#x2F;*********************************************************************************\n\t * the size of this added chunk is 0x1000 byte ,the same catalog is not doing now\n\t * fileName is the name of the file which saves your changeed data\n\t * chunkName is the name of the chunk you add\n\t *********************************************************************************&#x2F;\n\tvoid changeExportTable();&#x2F;&#x2F;DataDirectory[0]; 导出表\n\tvoid splayTheFile();\n\tvoid findResource();\n\tstatic PEStudy* getInstance();\nprivate:\n\tvoid DFSFindResource1(DWORD offset);\n\tvoid DFSFindResource2(DWORD offset);\n\tstatic PEStudy* _Instance;\n&#125;;\n\n\n\n&#x2F;&#x2F;PEStudy.cpp\n#include &quot;PEStudy.h&quot;\n#include&lt;Windows.h&gt;\n\nPEStudy* PEStudy::_Instance &#x3D; nullptr;\n\nPEStudy* PEStudy::getInstance()\n&#123;\n\tif (!_Instance)\n\t&#123;\n\t\t_Instance &#x3D; new PEStudy;\n\t&#125;\n\treturn _Instance;\n&#125;\n\nvoid PEStudy::addSize(DWORD chunkSize)\n&#123;\n\tchar* des &#x3D; (char*)((DWORD)(*_pFileBuffer) + thisSize);\n\tthisSize +&#x3D; chunkSize;\n\t\n\tvoid* tmp &#x3D; realloc(*_pFileBuffer, thisSize);\n\tif (!tmp);&#x2F;&#x2F;printf(&quot;realloc failed!!!\\n&quot;);\n\telse *_pFileBuffer &#x3D; tmp;\n\t\n\tmemset(des, 0, chunkSize);\n&#125;\n\nvoid PEStudy::changeExportTable()&#x2F;&#x2F;DataDirectory[0]; 导出表\n&#123;\n\tif (!pImageOptionalPEHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;Open file failed!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tgetSectionHeaders();\n\n\t_IMAGE_DATA_DIRECTORY now &#x3D; pImageOptionalPEHeader-&gt;DataDirectory[0];\n\n\tDWORD to &#x3D; RVAToFOA(now.VirtualAddress);\n\n\tPIMAGE_EXPORT_DIRECTORY ExportTable &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)(*_pFileBuffer) + to);\n\n\t&#x2F;*DWORD* to2 &#x3D; (DWORD*)((DWORD)(*_pFileBuffer) + (DWORD)RVAToFOA((DWORD)ExportTable-&gt;AddressOfNames));\n\t\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfNames + 7; i++)\n\t&#123;\n\t\tDWORD dress &#x3D; RVAToFOA(*to2);\n\t\tchar* name1 &#x3D; (char*)((DWORD)(*_pFileBuffer) + dress);\n\t\tto2++;\n\t&#125;*&#x2F;\n\n\tDWORD* addressOfFunctions, * addressOfNames, * addressOfOrdinals;\n\t&#x2F;&#x2F;这三个数组记录每个单元的是这些具体数据的虚拟地址\n\taddressOfFunctions &#x3D; (DWORD*)((DWORD)(*_pFileBuffer) + (DWORD)RVAToFOA((DWORD)ExportTable-&gt;AddressOfFunctions));\n\taddressOfNames &#x3D; (DWORD*)((DWORD)(*_pFileBuffer) + (DWORD)RVAToFOA((DWORD)ExportTable-&gt;AddressOfNames));\n\taddressOfOrdinals &#x3D; (DWORD*)((DWORD)(*_pFileBuffer) + (DWORD)RVAToFOA((DWORD)ExportTable-&gt;AddressOfNameOrdinals));\n\n\tchar* WriteTo &#x3D; (char*)pImageSectionHeads[pImageFileHeader-&gt;NumberOfSections - 1]-&gt;PointerToRawData;\n\n\tExportTable-&gt;AddressOfFunctions &#x3D; FOAToRVA((DWORD)WriteTo);\n\t\t\n\n\tWriteTo &#x3D; (char*)((DWORD)WriteTo + (DWORD)*_pFileBuffer);&#x2F;&#x2F;把修改内存的writeto指针指向要修改的区域\n\tDWORD* ali &#x3D; (DWORD*)WriteTo;\n\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfNames; i++)\n\t&#123;\n\t\tchar* see &#x3D; (char*)((DWORD)*_pFileBuffer + RVAToFOA((DWORD)addressOfNames[i]));\n\t&#125;\n\n\t&#x2F;&#x2F;memcpy(WriteTo, addressOfFunctions, ExportTable-&gt;NumberOfFunctions * 4);\n\n\tDWORD* RVAChange &#x3D; (DWORD*)ali, * RVADes &#x3D; NULL;\n\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfFunctions; i++)ali++;&#x2F;&#x2F;挪出导出函数RVA储存空间\n\tRVADes &#x3D; (DWORD*)ali;&#x2F;&#x2F;该地址开始转RVA\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfFunctions; i++)\n\t&#123;\n\t\tDWORD source &#x3D; (DWORD)((DWORD)(*_pFileBuffer) + RVAToFOA((DWORD)addressOfFunctions[i]));\n\t\tDWORD* tmp &#x3D; (DWORD*)source;\n\t\t*ali &#x3D; *tmp;\n\t\tali++;\n\t&#125;&#x2F;&#x2F;函数的具体数据，挪出的空间存储他们\n\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfFunctions; i++)\n\t&#123;\n\t\tRVAChange[i] &#x3D; FOAToRVA((DWORD)(RVADes + i) - (DWORD)(*_pFileBuffer));\n\t&#125;\n\n\n\treturn;\n&#125;\n\nDWORD PEStudy::querryAddress(DWORD beforeAddress, DWORD Size, DWORD align)&#x2F;&#x2F; 原来的偏移地址   数据大小    对齐大小\n&#123;\n\twhile ((beforeAddress + Size) % align)Size++;\n\treturn beforeAddress + Size;\n&#125;\n\nvoid PEStudy::SaveToTheSameCatalog(const char* fileName)\n&#123;\n\tFILE* fp;\n\n\tif ((fp &#x3D; fopen(fileName, &quot;wb+&quot;)) &#x3D;&#x3D; NULL)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;Open failed!!!\\nThere is another .exe opened this file&quot;);\n\t\treturn;\n\t&#125;\n\n\n\tvoid* now &#x3D; (*_pFileBuffer);\n\n\tif (!fwrite(now, 1, thisSize, fp))\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;Push data wrong,the problem question is the data size is not same!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\n\tfflush(fp);\n\n\tfclose(fp);\n\n\t&#x2F;&#x2F;printf(&quot;Sucess!!!\\n&quot;);\n&#125;\n\nvoid PEStudy::addASection(const char* chunkName, DWORD chunkSize)\n&#123;\n\tif (!pImageFileHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;FIle open failed!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tif (!SectionNumNow)\n\t&#123;\n\t\tgetSectionHeaders();\n\t\tif (!SectionNumNow)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;FIle open failed!!!\\n&quot;);\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;pImageFileHeader\n\tpImageOptionalPEHeader-&gt;SizeOfImage +&#x3D; chunkSize;\n\t\n\tSectionNumNow &#x3D; ++pImageFileHeader-&gt;NumberOfSections;&#x2F;&#x2F;section加一（块）\n\n\tstrcpy((char*)pImageSectionHeads[SectionNumNow - 1]-&gt;Name, chunkName);\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;Misc.VirtualSize &#x3D; (DWORD)chunkSize;\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;Characteristics &#x3D; (DWORD)0x60000020;\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;SizeOfRawData &#x3D; (DWORD)chunkSize;\n\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;PointerToRawData &#x3D; querryAddress(pImageSectionHeads[SectionNumNow - 2]-&gt;PointerToRawData\n\t\t, pImageSectionHeads[SectionNumNow - 2]-&gt;SizeOfRawData, pImageOptionalPEHeader-&gt;FileAlignment);\n\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;VirtualAddress &#x3D; querryAddress(pImageSectionHeads[SectionNumNow - 2]-&gt;VirtualAddress,\n\t\tmaxNow(pImageSectionHeads[SectionNumNow - 2]-&gt;SizeOfRawData, pImageSectionHeads[SectionNumNow - 2]-&gt;Misc.VirtualSize),\n\t\tpImageOptionalPEHeader-&gt;SectionAlignment);\n\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;NumberOfLinenumbers &#x3D; pImageSectionHeads[SectionNumNow - 1]-&gt;NumberOfRelocations &#x3D;\n\t\tpImageSectionHeads[SectionNumNow - 1]-&gt;PointerToLinenumbers &#x3D; pImageSectionHeads[SectionNumNow - 1]-&gt;PointerToRelocations &#x3D; 0;\n\n&#125;\n\nvoid PEStudy::getSectionHeaders()\n&#123;\n\tif (!pImageFileHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;pImageFileHeader is nullptr!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tSectionNumNow &#x3D; pImageFileHeader-&gt;NumberOfSections;\n\tauto filePoint &#x3D; *(_pFileBuffer);\n\n\tfor (int i &#x3D; 0; i &lt; SectionNumNow + 7; i++)&#x2F;&#x2F;加上7的原因是获得接下来空节表的地址，配合addSection函数使用的\n\t\tpImageSectionHeads[i] &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalPEHeader + pImageFileHeader-&gt;SizeOfOptionalHeader + i * 40);\n&#125;\n\nvoid PEStudy::printOptionalPEHeader()&#x2F;&#x2F;各种表的数据均未导出\n&#123;\n\tif (!pImageOptionalPEHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;pImageOptionalPEHeader is nullptr!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\treturn;\n&#125;\n\nvoid PEStudy::printFilePEHeader()\n&#123;\n\tif (!pImageFileHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;pImageFileHeader is null ptr&quot;);\n\t\treturn;\n\t&#125;\n\treturn;\n&#125;\n\nvoid PEStudy::initAllPoint()\n&#123;\n\t\n\n\tif (!thisSize)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;Open failed!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tauto filePoint &#x3D; *(_pFileBuffer);\n\n\tpImageDosHeader &#x3D; (PIMAGE_DOS_HEADER)(filePoint);\n\n\tpImageFileHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)filePoint + pImageDosHeader-&gt;e_lfanew + 0x4);\n\n\tpImageOptionalPEHeader &#x3D; (PIMAGE_OPTIONAL_HEADER)((DWORD)pImageFileHeader + 20);\n&#125;\n\nsize_t PEStudy::readFileBufferToTempBuffer(IN CHAR* lpszfFile, OUT LPVOID* pFileBuffer)&#x2F;&#x2F; lpszFile: The road of the desFile\n&#123;\n\tFILE* fp;\n\tDWORD fileSize &#x3D; 0;\n\tvoid* pTempFileBuffer &#x3D; NULL;\n\n\tif ((fp &#x3D; fopen(lpszfFile, &quot;rb&quot;)) &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;OpenFailed!!!&quot;), 0, 0);\n\t\treturn 0;\n\t&#125;\n\n\t&#x2F;&#x2F;find the teXt size\n\tfseek(fp, 0, SEEK_END);\n\tfileSize &#x3D; ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n\n\tpTempFileBuffer &#x3D; malloc(fileSize);\n\n\tif (!pTempFileBuffer)\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;The leaved space is not enough!!!!\\n&quot;), 0, 0);\n\t\tfclose(fp);\n\t\treturn 0;\n\t&#125;\n\n\tsize_t readSucess &#x3D; fread(pTempFileBuffer, fileSize, 1, fp);\n\n\tif (!readSucess)\n\t&#123;\n\t\tfclose(fp);\n\t\treturn 0;\n\t&#125;\n\n\tthisSize &#x3D; fileSize;\n\t*pFileBuffer &#x3D; pTempFileBuffer;\n\tpTempFileBuffer &#x3D; NULL;\n\tfclose(fp);\n\n\treturn fileSize;\n\n&#125;\n\nvoid PEStudy::printDosHeader()\n&#123;\n\tif (!pImageDosHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;&#x2F;&#x2F;printf(&quot;The pImageDOsHeader is nullptr!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\t\n&#125;\n\nDWORD PEStudy::RVAToFOA(DWORD RVA)\n&#123;\n\tif (!SectionNumNow)\n\t&#123;\n\t\tgetSectionHeaders();\n\t\tif (!SectionNumNow)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;The File opened failed!!!\\n&quot;);\n\t\t\tsystem(&quot;pause&quot;);\n\t\t\treturn -1;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; SectionNumNow; i++)\n\t&#123;\n\t\tDWORD see &#x3D; pImageSectionHeads[i]-&gt;VirtualAddress + pImageSectionHeads[i]-&gt;SizeOfRawData;&#x2F;&#x2F;在数据里，就不用考虑内存对齐前的大小了\n\t\tif (see &gt;&#x3D; RVA &amp;&amp; pImageSectionHeads[i]-&gt;VirtualAddress &lt;&#x3D; RVA)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;&#x2F;&#x2F;printf(&quot;RVA is in the %dth Section!!!\\n&quot;, i);\n\t\t\t&#x2F;&#x2F;&#x2F;&#x2F;printf(&quot;FOA is 0x%X\\n&quot;, RVA - pImageSectionHeads[i]-&gt;VirtualAddress + pImageSectionHeads[i]-&gt;PointerToRawData);\n\t\t\treturn RVA - pImageSectionHeads[i]-&gt;VirtualAddress + pImageSectionHeads[i]-&gt;PointerToRawData;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;printf(&quot;Data is illegal!!!\\n&quot;);\n\treturn -1;\n&#125;\n\nDWORD PEStudy::FOAToRVA(DWORD FOA)\n&#123;\n\tif (!SectionNumNow)\n\t&#123;\n\t\tgetSectionHeaders();\n\t\tif (!SectionNumNow)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;The File opened failed!!!\\n&quot;);\n\t\t\tsystem(&quot;pause&quot;);\n\t\t\treturn -1;\n\t\t&#125;\n\t&#125;\n\n\tfor (int i &#x3D; 0; i &lt; SectionNumNow; i++)\n\t&#123;\n\t\t\n\t\tif (pImageSectionHeads[i]-&gt;PointerToRawData &lt;&#x3D; FOA &amp;&amp;\n\t\t\tpImageSectionHeads[i]-&gt;PointerToRawData + pImageSectionHeads[i]-&gt;SizeOfRawData &gt; FOA)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;FOA is in the %dth Section!!!\\n&quot;, i);\n\t\t\t&#x2F;&#x2F;printf(&quot;RVA is 0x%X\\n&quot;, FOA - pImageSectionHeads[i]-&gt;PointerToRawData + pImageSectionHeads[i]-&gt;VirtualAddress);\n\t\t\treturn FOA - pImageSectionHeads[i]-&gt;PointerToRawData + pImageSectionHeads[i]-&gt;VirtualAddress;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;printf(&quot;Data is illegal!!!\\n&quot;);\n\treturn -1;\n&#125;\n\nvoid PEStudy::DFSFindResource2(DWORD offset)\n&#123;\n\tint idx &#x3D; -1;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; SectionNumNow; i++)\n\t\tif (!strcmp((const char*)pImageSectionHeads[i]-&gt;Name, &quot;.rsrc&quot;))idx &#x3D; i;\n\tauto now &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)offset +\n\t\t(DWORD)(*_pFileBuffer) + pImageSectionHeads[idx]-&gt;PointerToRawData);\n\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY DiaLogNow &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(\n\t\t(DWORD)now + (DWORD)16);\n\t\t\n\t&#x2F;&#x2F;printf(&quot;---------------该资源的语言内码为：%d\\n&quot;, DiaLogNow[0].Name);\n\n\tauto real &#x3D; (PIMAGE_RESOURCE_DATA_ENTRY)((DWORD)DiaLogNow[0].OffsetToData +\n\t\t(DWORD)(*_pFileBuffer) + pImageSectionHeads[idx]-&gt;PointerToRawData);\n\n\t&#x2F;&#x2F;printf(&quot;RVA:%X\\nFOA:%X\\nSIZE:%X\\n&quot;, real-&gt;OffsetToData, RVAToFOA(real-&gt;OffsetToData), real-&gt;Size);\n\n\treturn;\n\n\t\t\t&#x2F;&#x2F;DFSFindResource(DiaLogNow[i].OffsetToDirectory);\n\t\t\n\t\n&#125;\n\nvoid PEStudy::DFSFindResource1(DWORD offset)\n&#123;\n\tint idx &#x3D; -1;\n\tfor(int i&#x3D;0;i&lt;&#x3D;SectionNumNow;i++)\n\tif(!strcmp((const char *)pImageSectionHeads[i]-&gt;Name,&quot;.rsrc&quot;))idx&#x3D;i;\n\tauto now &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)offset + \n\t\t(DWORD)(*_pFileBuffer) + pImageSectionHeads[idx]-&gt;PointerToRawData);\n\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY DiaLogNow &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(\n\t\t(DWORD)now + (DWORD)16);\n\n\n\tfor (int i &#x3D; 0; i &lt; now-&gt;NumberOfIdEntries + now-&gt;NumberOfNamedEntries; i++)\n\t&#123;\n\t\tif (!DiaLogNow[i].NameIsString)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;该物品编号为：%d\\n该位置的下一项目录是否为具体资源：%s\\n&quot;,\n\t\t\t\t&#x2F;&#x2F;DiaLogNow[i].Id, DiaLogNow[i].DataIsDirectory ? &quot;NO&quot; : &quot;YES&quot;);\n\t\t\tDFSFindResource2(DiaLogNow[i].OffsetToDirectory);\n\t\t&#125;\n\t\telse; &#x2F;&#x2F;printf(&quot;---------------------------用户自制资源！！！------------------------------------\\n&quot;);\n\t&#125;\n\n\n\treturn;\n&#125;\n\nvoid PEStudy::findResource()\n&#123;\n\tif (!pImageOptionalPEHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;open file failed!!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tauto ali &#x3D; pImageOptionalPEHeader-&gt;DataDirectory[2];\n\n\tpImageResourceHeader &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)RVAToFOA(ali.VirtualAddress) + (DWORD)(*_pFileBuffer));\n\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY firstDia &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pImageResourceHeader + (DWORD)16);\n\n\n\tfor (int i &#x3D; 0; i &lt; pImageResourceHeader-&gt;NumberOfIdEntries +\n\t\tpImageResourceHeader-&gt;NumberOfNamedEntries; i++)\n\t&#123;\n\t\tif (!firstDia[i].NameIsString)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;该类型为：%d\\n该位置的下一项目录是否为具体资源：%s\\n&quot;,\n\t\t\t\t&#x2F;&#x2F;firstDia[i].Id, firstDia[i].DataIsDirectory ? &quot;NO&quot; : &quot;YES&quot;);\n\t\t\tDFSFindResource1(firstDia[i].OffsetToDirectory);\n\t\t&#125;\n\t\telse; &#x2F;&#x2F;printf(&quot;用户自制资源！！！\\n&quot;);\n\t&#125;\n\n\treturn;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;壳\n&#x2F;&#x2F; Shell.cpp : 定义应用程序的入口点。\n&#x2F;&#x2F;\n#define _CRT_SECURE_NO_WARNINGS\n#include &quot;framework.h&quot;\n#include &quot;Shell.h&quot;\n#include &quot;PEStudy.h&quot;\n#include&lt;wdmguid.h&gt;\n#include&lt;ntddkbd.h&gt;\n#include&lt;string.h&gt;\n\nPEStudy* PEInstance &#x3D; nullptr;\nTCHAR exeFullPath[MAX_PATH]; &#x2F;&#x2F; Full path   \n\ntypedef struct _ChildProcessInfo &#123;\n\n\tDWORD dwBaseAddress;\n\tDWORD dwReserve;\n&#125; CHILDPROCESS, * PCHILDPROCESS;\n\n&#x2F;&#x2F;getInstance就是单例模式，很好理解的一种设计模式，写游戏的时候学到的，\n&#x2F;&#x2F;它相当于一个全局对象，PEStudy有该函数\n\nBOOL CreateInjectProcess(\n\n\tPPROCESS_INFORMATION pi,\n\tPCONTEXT pThreadCxt,\n\tCHILDPROCESS* pChildProcess)\n&#123;\n\tSTARTUPINFO si;\n\tZeroMemory(&amp;si, sizeof(si));\n\tDWORD* PPEB;\n\tDWORD read;\n\n\t&#x2F;&#x2F;\n\tif (CreateProcess(\n\t\tNULL,   &#x2F;&#x2F;  指向一个NULL结尾的、用来指定可执行模块的宽字节字符串  \n\t\texeFullPath, &#x2F;&#x2F; 命令行字符串  \n\t\tNULL, &#x2F;&#x2F;    指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。  \n\t\tNULL, &#x2F;&#x2F;    如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。&lt;同上&gt;  \n\t\tfalse,&#x2F;&#x2F;    指示新进程是否从调用进程处继承了句柄。   \n\t\tCREATE_SUSPENDED,  &#x2F;&#x2F;  指定附加的、用来控制优先类和进程的创建的标  \n\t\t\t&#x2F;&#x2F;  CREATE_NEW_CONSOLE  新控制台打开子进程  \n\t\t\t&#x2F;&#x2F;  CREATE_SUSPENDED    子进程创建后挂起，直到调用ResumeThread函数  \n\t\tNULL, &#x2F;&#x2F;    指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境  \n\t\tNULL, &#x2F;&#x2F;    指定子进程的工作路径  \n\t\t&amp;si, &#x2F;&#x2F; 决定新进程的主窗体如何显示的STARTUPINFO结构体  \n\t\tpi  &#x2F;&#x2F; 接收新进程的识别信息的PROCESS_INFORMATION结构体  \n\t))\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;挂起创建程序成功！！！&quot;), 0, 0);\n\t\tpThreadCxt-&gt;ContextFlags &#x3D; CONTEXT_FULL;\n\t\tGetThreadContext(pi-&gt;hThread, pThreadCxt);\n\n\t\tPPEB &#x3D; (DWORD*)pThreadCxt-&gt;Ebx;\n\t\t&#x2F;&#x2F;\n\t\tReadProcessMemory(\n\t\t\tpi-&gt;hProcess,\n\t\t\t&amp;PPEB[2],\n\t\t\t(LPVOID) &amp; (pChildProcess-&gt;dwBaseAddress),\n\t\t\tsizeof(DWORD),\n\t\t\t&amp;read);\n\t\treturn TRUE;\n\t&#125;\n\telse MessageBox(0, TEXT(&quot;挂起创建程序失败！！！&quot;), 0, 0);\n\treturn FALSE;\n&#125;\n\nBOOL UnloadShell(HANDLE ProcHnd, unsigned long BaseAddr)\n&#123;\n\ttypedef unsigned long(__stdcall* pfZwUnmapViewOfSection)(unsigned long, unsigned long);\n\tpfZwUnmapViewOfSection ZwUnmapViewOfSection &#x3D; NULL;\n\n\tBOOL res &#x3D; FALSE;\n\tHMODULE m &#x3D; LoadLibrary(TEXT(&quot;ntdll.dll&quot;));\n\tif (m)\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;load exe sucess！！！&quot;), 0, 0);\n\t\tZwUnmapViewOfSection &#x3D; (pfZwUnmapViewOfSection)GetProcAddress(m, &quot;ZwUnmapViewOfSection&quot;);\n\t\tif (ZwUnmapViewOfSection)\n\t\t\tres &#x3D; (ZwUnmapViewOfSection((unsigned long)ProcHnd, BaseAddr) &#x3D;&#x3D; 0);\n\t\tFreeLibrary(m);\n\t&#125;\n\telse MessageBox(0, TEXT(&quot;load exe false！！！&quot;), 0, 0);\n\treturn res;\n&#125;\n\nDWORD GetSelfImageSize(HMODULE hModule)\n&#123;\n\tDWORD dwImageSize;\n\t_asm\n\t&#123;\n\t\tmov ecx, 0x30\n\t\tmov eax, fs: [ecx]\n\t\tmov eax, [eax + 0x0c]\n\t\tmov esi, [eax + 0x0c]\n\t\tadd esi, 0x20\n\t\tlodsd\n\t\tmov dwImageSize, eax\n\t&#125;\n\treturn dwImageSize;&#x2F;&#x2F;getSize\n&#125;\n\n&#x2F;&#x2F;本程序使用该函数卸载挂起进程\nBOOL  UnMapTargetProcess(HANDLE hProcess, CONTEXT&amp; stThreadContext)\n&#123;\n\ttypedef ULONG(WINAPI* PFNNtUnmapViewOfSection) (HANDLE ProcessHandle, PVOID BaseAddress);\n\tHMODULE hNtModule &#x3D; GetModuleHandle(_T(&quot;ntdll.dll&quot;));\n\n\tDWORD dwProcessBaseAddr &#x3D; 0x400000;\n\t\n\tif (hNtModule &#x3D;&#x3D; NULL)\n\t&#123;\n\t\thNtModule &#x3D; LoadLibrary(_T(&quot;ntdll.dll&quot;));\n\t\tif (hNtModule &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\tMessageBox(0, L&quot;ntdll find faied!!!&quot;, 0, 0);\n\t\t\treturn -1;\n\t\t&#125;\n\t&#125;\n\n\tPFNNtUnmapViewOfSection pfnNtUnmapViewOfSection &#x3D; (PFNNtUnmapViewOfSection)GetProcAddress(hNtModule, &quot;NtUnmapViewOfSection&quot;);\n\tif (pfnNtUnmapViewOfSection &#x3D;&#x3D; NULL)\n\t&#123;\n\t\treturn -1;\n\t&#125;\n\n\tpfnNtUnmapViewOfSection(hProcess, (PVOID)dwProcessBaseAddr);\n\n\treturn true;\n&#125;\n\nBOOL InjectProcess(void)\n&#123;\n\tchar szModulePath[MAX_PATH];\n\tDWORD dwImageSize &#x3D; 0;\n\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\tCONTEXT ThreadCxt;\n\tDWORD* PPEB;\n\tDWORD dwWrite &#x3D; 0;\n\tCHILDPROCESS stChildProcess;\n\tLPVOID lpVirtual &#x3D; NULL;\n\tPIMAGE_DOS_HEADER pDosheader &#x3D; NULL;\n\tPIMAGE_NT_HEADERS pVirPeHead &#x3D; NULL;\n\n\tHMODULE hModule &#x3D; NULL;\n\n\n\tGetModuleFileName(NULL, exeFullPath, MAX_PATH);\n\t&#x2F;&#x2F;获取当前进程的运行目录\n\t&#x2F;&#x2F;wsprintf(str, TEXT(&quot;%08X&quot;), num);&#x2F;&#x2F;wstr\n\tPEStudy::getInstance()-&gt;_pFileBuffer &#x3D; (OUT LPVOID*)malloc(sizeof(OUT LPVOID));\n\tsprintf(PEStudy::getInstance()-&gt;_lpszfFile, &quot;%ws&quot;, exeFullPath);\n\tPEStudy::getInstance()-&gt;readFileBufferToTempBuffer(PEStudy::getInstance()-&gt;_lpszfFile,\n\t\tPEStudy::getInstance()-&gt;_pFileBuffer);\n\n\tPEInstance &#x3D; PEStudy::getInstance();\n\n\tPEInstance-&gt;initAllPoint();\n\n\tPEInstance &#x3D; PEStudy::getInstance();\n\n\tPEInstance-&gt;getSectionHeaders();\n\n\tint whi &#x3D; -1;\n\n\tfor (int i &#x3D; 0; i &lt; PEInstance-&gt;pImageFileHeader-&gt;NumberOfSections; i++)\n\t\tif (!strcmp((const char*)PEInstance-&gt;pImageSectionHeads[i]-&gt;Name, &quot;.other&quot;))\n\t\t&#123;\n\t\t\twhi &#x3D; i;\n\t\t\tbreak;\n\t\t&#125;\n\n\tif (-1 &#x3D;&#x3D; whi)\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;该程序未被加壳，或仅含壳（空）&quot;), 0, 0);\n\t\treturn 0;\n\t&#125;\n\n\t&#x2F;&#x2F;unLock\n\n\tchar* now &#x3D; (char*)((DWORD)PEInstance-&gt;pImageSectionHeads[whi]-&gt;PointerToRawData +\n\t\t(DWORD)*PEInstance-&gt;_pFileBuffer);\n\n\tDWORD size &#x3D; PEInstance-&gt;pImageSectionHeads[whi]-&gt;SizeOfRawData;\n\n\t&#x2F;&#x2F;解密，若该节数据有加密的话\n\t&#x2F;*while (size--)\n\t&#123;\n\t\t(*now) ^&#x3D; 999;\n\t\tnow++;\n\t&#125;*&#x2F;\n\n\t&#x2F;&#x2F;sucess\n\n\tMessageBox(0, TEXT(&quot;程序解密已完成！！！&quot;), 0, 0);\n\n\t\n\tCONTEXT pThreadCxt;&#x2F;&#x2F;挂起上下文\n\t&#x2F;&#x2F;CHILDPROCESS stChildProcess;&#x2F;&#x2F;基址\n\n\tZeroMemory(szModulePath, MAX_PATH);\n\n\thModule &#x3D; GetModuleHandle(NULL);\n\tif (hModule &#x3D;&#x3D; NULL)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\n\tpDosheader &#x3D; (PIMAGE_DOS_HEADER)hModule;\n\tpVirPeHead &#x3D; (PIMAGE_NT_HEADERS)((DWORD)hModule + pDosheader-&gt;e_lfanew);\n\tLPVOID lpPuppetProcessBaseAddr &#x3D; NULL;&#x2F;&#x2F;分配内存成功与否\n\tdwImageSize &#x3D; GetSelfImageSize(hModule);\n\n\t&#x2F;&#x2F; 以挂起模式启动一个傀儡进程,传进去的是OUT类型的参数，便于获得这些数据\n\tif (CreateInjectProcess(&amp;pi, &amp;ThreadCxt, &amp;stChildProcess))\n\t&#123;\n\t\t&#x2F;&#x2F; 卸载需要注入进程中的代码 \n\t\tif (UnMapTargetProcess(pi.hProcess, ThreadCxt))\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 重新分配内存 \n\t\t\t&#x2F;&#x2F;loadNewPE，把PE的指针指向该节，把它当作新PE文件\n\t\t\t*PEInstance-&gt;_pFileBuffer &#x3D;\n\t\t\t\t(LPVOID)((DWORD)PEInstance-&gt;pImageSectionHeads[whi]-&gt;PointerToRawData +\n\t\t\t\t(DWORD)*PEInstance-&gt;_pFileBuffer);\n\n\t\t\tPEInstance-&gt;initAllPoint();&#x2F;&#x2F;重新初始化各个头DOS，PE，OPPE\n\t\t\t&#x2F;&#x2F;\n\t\t\tlpPuppetProcessBaseAddr &#x3D;\n\t\t\t\tVirtualAllocEx(pi.hProcess, (LPVOID)PEInstance-&gt;pImageOptionalPEHeader-&gt;ImageBase,\n\t\t\t\t\tPEInstance-&gt;pImageOptionalPEHeader-&gt;SizeOfImage,\n\t\t\t\t\tMEM_COMMIT | MEM_RESERVE,\n\t\t\t\t\tPAGE_EXECUTE_READWRITE);\n\n\n\t\t\tif (lpPuppetProcessBaseAddr)\n\t\t\t&#123;\n\t\t\t\tMessageBox(0, L&quot;sucess&quot;, 0, 0);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tMessageBox(0, L&quot;重新分配内存 failed&quot;, 0, 0);\n\t\t\t\treturn TRUE;\n\t\t\t&#125;\n\n\t\t\tif (lpPuppetProcessBaseAddr)\n\t\t\t&#123;\n\t\t\t\tBOOL bRet &#x3D; WriteProcessMemory(pi.hProcess,\n\t\t\t\t\tlpPuppetProcessBaseAddr,\n\t\t\t\t\t*PEInstance-&gt;_pFileBuffer,\n\t\t\t\t\tPEInstance-&gt;pImageOptionalPEHeader-&gt;SizeOfHeaders,\n\t\t\t\t\tNULL);\n\n\t\t\t\tif (!bRet)\n\t\t\t\t&#123;\n\t\t\t\t\treturn FALSE;\n\t\t\t\t&#125;\n\n\t\t\t\t&#x2F;&#x2F; 替换节\n\t\t\t\tLPVOID lpSectionBaseAddr &#x3D; (LPVOID)((DWORD)*PEInstance-&gt;_pFileBuffer\n\t\t\t\t\t+ PEInstance-&gt;pImageDosHeader-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS));\n\t\t\t\tPIMAGE_SECTION_HEADER pSectionHeader;\n\t\t\t\tDWORD dwIndex &#x3D; 0;\n\t\t\t\tTCHAR ans[100];\n\n\t\t\t\t&#x2F;&#x2F;一些调试信息\n\t\t\t\t&#x2F;*wsprintf(ans, L&quot;共有%d个节&quot;,\n\t\t\t\t\tPEInstance-&gt;pImageFileHeader-&gt;NumberOfSections);\n\t\t\t\tMessageBox(0, ans, 0, 0);*&#x2F;\n\n\t\t\t\tfor (; dwIndex &lt; PEInstance-&gt;pImageFileHeader-&gt;NumberOfSections;\n\t\t\t\t\t++dwIndex)\n\t\t\t\t&#123;\n\t\t\t\t\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)lpSectionBaseAddr;\n\t\t\t\t\tbRet &#x3D; WriteProcessMemory(pi.hProcess,\n\t\t\t\t\t\t(LPVOID)((DWORD)lpPuppetProcessBaseAddr +\n\t\t\t\t\t\t\tpSectionHeader-&gt;VirtualAddress),\n\t\t\t\t\t\t\t(LPCVOID)((DWORD)*PEInstance-&gt;_pFileBuffer +\n\t\t\t\t\t\t\t\tpSectionHeader-&gt;PointerToRawData),\n\t\t\t\t\t\tpSectionHeader-&gt;SizeOfRawData,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\t\tif (!bRet)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tMessageBox(0, L&quot;节区拓展失败！！！\\n&quot;, 0, 0);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t&#125;\n\n\t\t\t\t\tlpSectionBaseAddr &#x3D; (LPVOID)((DWORD)lpSectionBaseAddr + sizeof(IMAGE_SECTION_HEADER));\n\t\t\t\t&#125;\n\n\t\t\t\tMessageBox(0, L&quot;节区拓展成功！！！\\n&quot;, 0, 0);\n\n\t\t\t\tDWORD dwImageBase &#x3D; PEInstance-&gt;pImageOptionalPEHeader-&gt;ImageBase;\n\t\t\t\t&#x2F;&#x2F;ebx指向了一个结构，8个偏移之后指向了一个指针，指针指向了imageBase，（未确定）\n\t\t\t\tbRet &#x3D; WriteProcessMemory(pi.hProcess, \n\t\t\t\t\t(LPVOID)(ThreadCxt.Ebx + 8), (LPCVOID)&amp;dwImageBase, sizeof(PVOID), NULL);\n\n\t\t\t\tif (!bRet)\n\t\t\t\t&#123;\n\t\t\t\t\treturn FALSE;\n\t\t\t\t&#125;\n\n\t\t\t\t&#x2F;&#x2F; 替换入口点\n\t\t\t\tThreadCxt.Eax &#x3D; dwImageBase + PEInstance-&gt;pImageOptionalPEHeader\n\t\t\t\t\t-&gt;AddressOfEntryPoint;\n\t\t\t\tbRet &#x3D; SetThreadContext(pi.hThread, &amp;ThreadCxt);\n\n\t\t\t\tif (!bRet)\n\t\t\t\t&#123;\n\t\t\t\t\treturn FALSE;\n\t\t\t\t&#125;\n\n\t\t\t\tResumeThread(pi.hThread);\n\n\t\t\t\t&#x2F;&#x2F;该消息出来后若程序未远行，则加壳失败——原因可能是加壳程序逻辑错误，或者解壳程序逻辑错误，如开头所说\n\t\t\t\tMessageBox(0, L&quot;载入成功！！！&quot;, 0, 0);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\treturn TRUE;\n&#125;\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n\t_In_opt_ HINSTANCE hPrevInstance,\n\t_In_ LPWSTR    lpCmdLine,\n\t_In_ int       nCmdShow)\n&#123;\n\t&#x2F;&#x2F;调试\n\t&#x2F;&#x2F;MessageBox(0, L&quot;ReadFileFailed!!!\\n&quot;, 0, 0);\n\treturn InjectProcess();\n&#125;\n\n\n\n\n\n\n\n\n</code></pre>\n\n\n\n<h1 id=\"Win32-proj\"><a href=\"#Win32-proj\" class=\"headerlink\" title=\"Win32_proj\"></a>Win32_proj</h1><p>仓库<br><a href=\"https://github.com/Kwansy98?tab=repositories\">https://github.com/Kwansy98?tab=repositories</a><br>专栏<br><a href=\"https://blog.csdn.net/kwansy/category_9909961.html\">https://blog.csdn.net/kwansy/category_9909961.html</a></p>\n","text":"Win32&#x2F;* 对于字符串，ASCII 中使用 char 来定义，而 Unicode 中使用 wchar_t 来定义，并且需要添加前缀L。 那么在 windows.h 头文件中（或者是它包含的其他头文件）就这样来处理： #ifdef UNICODE typedef wc...","link":"","photos":[],"count_time":{"symbolsCount":"75k","symbolsTime":"1:08"},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Win32\"><span class=\"toc-text\">Win32</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Win32-proj\"><span class=\"toc-text\">Win32_proj</span></a></li></ol>","author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"core","uid":"353cf78a0c7522820ab388e96d2cdefc","slug":"core","date":"2020-09-17T02:21:18.000Z","updated":"2022-08-22T07:47:03.603Z","comments":true,"path":"api/articles/core.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/480_296_0/t019e08ebfa47d7cc34.jpg","text":"一、【保护模式】 段寄存器有96位，但我们只能看见16位，那如果证明Attribute、Base、Limit的存在呢？ 2、探测Attribute int var &#x3D; 0; __asm &#123; mov ax,ss &#x2F;&#x2F;cs不行 cs是可读 可执...","link":"","photos":[],"count_time":{"symbolsCount":"68k","symbolsTime":"1:02"},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"PEToolKit","uid":"a1e4caef696c9dadabec86ca767b0052","slug":"PEToolKit","date":"2020-08-14T15:41:26.000Z","updated":"2022-08-22T07:52:21.331Z","comments":true,"path":"api/articles/PEToolKit.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/960_593_0/t016c300191cf22c2f0.jpg","text":"&#x2F;&#x2F;PE课后作业参考代码（含测试代码） &#x2F;&#x2F;https:&#x2F;&#x2F;blog.csdn.net&#x2F;Kwansy&#x2F;article&#x2F;details&#x2F;106234264 #include &quo...","link":"","photos":[],"count_time":{"symbolsCount":"60k","symbolsTime":"54 mins."},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}