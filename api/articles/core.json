{"title":"core","uid":"353cf78a0c7522820ab388e96d2cdefc","slug":"core","date":"2020-09-17T02:21:18.000Z","updated":"2022-08-22T07:47:03.603Z","comments":true,"path":"api/articles/core.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/480_296_0/t019e08ebfa47d7cc34.jpg","content":"<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">一、【保护模式】\n\n段寄存器有96位，但我们只能看见16位，那如果证明Attribute、Base、Limit的存在呢？\n\n2、探测Attribute\n\nint var &#x3D; 0;\n__asm\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tmov ax,ss\t&#x2F;&#x2F;cs不行 cs是可读 可执行 但不可写\n\tmov ds,ax\t&#x2F;&#x2F; 将 ss 段选择子代入 ds 段寄存器\n\tmov dword ptr ds:[var],eax\n&#125;\n\n3、探测Base\n[0]不可读不可写\n\nint var &#x3D; 1;\t\t\t\t\t\n__asm\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tmov ax,fs\t\t&#x2F;&#x2F;不要用DS 否则编译不过去\n\tmov gs,ax\t\t\t\t\n\tmov eax,gs:[0]\t&#x2F;&#x2F;&#x3D;&#x3D; fs.base+0\n\tmov dword ptr ds:[var],eax\t\n\t\n\t&#x2F;&#x2F;相当于mov edx,dword ptr ds:[0x7FFDF000]\n&#125;\n\n\n3、探测Limit\n\nint var &#x3D; 1;\t\t\t\t\t\n__asm\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tmov ax,fs\t\t\t&#x2F;&#x2F;不要用DS 否则编译不过去\n\tmov gs,ax\t\t\t\t\n\t\n\t&#x2F;&#x2F;mov eax,gs:[0x1000]\t&#x2F;&#x2F;FS limit&#x3D;0xFFF 0x1000越界了！\n\tmov edx,dword ptr ds:[0x7FFDF000+0x1000]&#x2F;&#x2F;等价，ds limit大 没越界\n\t\n\tmov dword ptr ds:[var],eax\n&#125;\n\n\n\n\n写段寄存器时，只给了16位[2B]，剩下的80位填什么？数据从哪里来？\n\nchar buffer[6] &#x3D; &#39;00001B&#39;;&#x2F;&#x2F;?????????\n__asm\n&#123;\n\tles ecx,fword ptr ds:[buffer] &#x2F;&#x2F;高2个字节给es，低四个字节给ecx\t\n&#125;&#x2F;&#x2F;dw:4 fw:6 qw:8 \n把另一个段寄存器中的数据读入到寄存器 ax(16bit)，然后把 ax 代入到了 ds，可是 ax 明明只有 16 位啊，而 ds 有 96 位。\nCPU必然在背后帮我们做了一些事情，它从 GDT 表中取出对应的段描述符，经过分析后自动的填写的了段寄存器中。\n\n段描述符共有64位，但需要填充的是80位，怎么填？\n\n当用Selector找到我们需要的描述符（GDT或LDT中的某一表项）后，\n我们把这个描述符拆解成3个部分，分别是 attribute, base 和 limit。\n\n段描述符 gdt[Selector]&#x3D;...;\n-&gt;\n段寄存器一共有 96 位，其中 16 可见部分来源于段选择子的索引部分。剩下 80 位来源于 GDT 表。\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;q1007729991&#x2F;article&#x2F;details&#x2F;52538080\n分析段选择子为0x1B、0x23对应的段描述符，并将内容填写到段寄存器结构体中.\n段描述符结构\n|   7    |     6       |     5     |   4    |   3    |   2    |   1    |   0    |  字节\n|76543210|7 6 5 4 3210 |7 65 4 3210|76543210|76543210|76543210|76543210|76543210|  比特\n|--------|-|-|-|-|---- |-|--|-|----|--------|--------|--------|--------|--------|  占位\n|  BASE  |G|D|0|A|LIMIT|P|D |S|TYPE|&lt;------- BASE 23-0 ------&gt;|&lt;-- LIMIT 15-0 -&gt;|  含义\n|  31-24 | |&#x2F;| |V|19-16| |P |\n\t\t   |B| |L|     | |L |\n\n0x1B &#x3D; 0000 0000 0001 1011\n索引号：0000 0000 0001 1&#x3D; 3 (查找gdt[3])\nRPL: 11b &#x3D; 3\nTI: 0 (查找 GDT 表)\n查找到的 GDT 描述符为：gdt[3] &#x3D; 00[cffb]00&#96;0000ffff\n00000000 |[ 1 1 0 0 1111 | 1 11 1 1011 ]|0000 0000 0000 0000 0000 0000 | 1111 1111 1111 1111\n段寄存器结构：\nselector  &#x3D; 0x001B\n[attribute &#x3D; 0xcffb] (G &#x3D; 1 DB &#x3D; 1 P &#x3D; 1 DPL &#x3D; 3 S &#x3D; 1 TYPE &#x3D; 1011(非一致代码段，可读已访问过))\nbase      &#x3D; 0x00000000\nlimit     &#x3D; 0xffffffff\n\n\n0x23 &#x3D; 0000 0000 0010 0011b\n索引号：0000 0000 0010 0 &#x3D; 4\nTI: 0 (查找 GDT 表)\nRPL: 11b &#x3D; 3\n查找到的 GDT 描述符为：gdt[4] &#x3D; 00[cff3]00&#96;0000ffff\n段寄存器结构：\nselector  &#x3D; 0x23\nattribute &#x3D; 0xcff3 (G &#x3D; 1 DB &#x3D; 1 P &#x3D; 1 DPL &#x3D; 3 S &#x3D; 1 TYPE &#x3D; 0011(可读可写向上扩展的数据段))\nbase      &#x3D; 0x00000000\nlimit     &#x3D; 0xffffffff\n\nchar buffer[6];\n__asm\n&#123;\n\tmov fword ptr ds:[buffer],0x1B0000\n\tles ecx,fword ptr ds:[buffer] &#x2F;&#x2F;高2个字节给es，低四个字节给ecx\t\n&#125;\n\nMOV DS,AX\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;102592866\n调用门（无参）\n实验：构造一个无参调用门\n#include &quot;stdafx.h&quot;\n#include &lt;windows.h&gt;\n\nvoid __declspec(naked) GetRegister()\n&#123;\n\t__asm\n\t&#123;\n\t\tint 3\n\n\t\tretf\t\t&#x2F;&#x2F; 注意返回，不能是ret\n\t&#125;\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\tchar buff[6];\n\t*(DWORD*)&amp;buff[0] &#x3D; 0x12345678;\t\t\t&#x2F;&#x2F; 在这行设置断点\n\t*(WORD*)&amp;buff[4] &#x3D; 0x48;\t\t\t\t&#x2F;&#x2F; 段选择子所在偏移\n\t__asm\n\t&#123;\n\t\tcall fword ptr[buff]\t\t\t\t&#x2F;&#x2F; 长调用\n\t&#125;\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n修改代码：R3读取高2G内存\n#include &lt;windows.h&gt;\n\nBYTE GDT[6] &#x3D; &#123;0&#125;;\nDWORD dwH2GValue;\n\nvoid __declspec(naked) GetRegister()\n&#123;\n\t__asm\n\t&#123;\n\t\tpushad\n\t\tpushfd\n\n\t\tmov eax,0x8003f00c\t&#x2F;&#x2F; 读取高2G内存\n\t\tmov ebx,[eax]\n\t\tmov dwH2GValue,ebx\n\t\tsgdt GDT;\t\t\t&#x2F;&#x2F; 读取GDT\n\n\t\tpopfd\n\t\tpopad\n\n\t\tretf\n\t&#125;\n&#125;\n\nvoid PrintRegister()\n&#123;\n\tDWORD GDT_ADDR &#x3D; *(PDWORD)(&amp;GDT[2]);\n\tWORD GDT_LIMIT &#x3D; *(PWORD)(&amp;GDT[0]);\n\n\tprintf(&quot;%x %x %x \\n&quot;, dwH2GValue, GDT_ADDR, GDT_LIMIT);\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\t__asm\n\t&#123;\n\t\tmov ebx,ebx\n\t\tmov ebx,ebx\n\t&#125;\n\n\tchar buff[6];\n\t*(DWORD*)&amp;buff[0] &#x3D; 0x12345678;\n\t*(WORD*)&amp;buff[4] &#x3D; 0x48;\t&#x2F;&#x2F; segment select\n\n\t__asm\n\t&#123;\n\t\tcall fword ptr[buff]\n\t&#125;\n\tPrintRegister();\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;无参\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;q1007729991&#x2F;article&#x2F;details&#x2F;52537782\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\nWORD g_cs0, g_ss0, g_ds0, g_es0, g_fs0, g_gs0;\nDWORD r0_data_lowdword, r0_data_hidword;\n\n__declspec(naked) void getData() &#123;\n\t__asm &#123;\n\t\tpushfd\n\t\tpushad\n\t\tmov g_cs0, cs\n\t\tmov g_ss0, ss\n\t\tmov g_ds0, ds\n\t\tmov g_es0, es\n\t\tmov g_fs0, fs\n\t\tmov g_gs0, gs\n\t\tmov eax, 0x8003f048\n\t\tmov eax, [eax]\n\t\tmov r0_data_lowdword, eax\n\t\tmov eax, 0x8003f04c\n\t\tmov eax, [eax]\n\t\tmov r0_data_hidword, eax\n\t\tpopad\n\t\tpopfd\n\t\tretf\n\t&#125;\n&#125;\n\nvoid printData() &#123;\n\tprintf(&quot;g_cs0&#x3D;%02x\\ng_ss0&#x3D;%02x\\ng_ds0&#x3D;%02x\\ng_es0&#x3D;%02x\\ng_fs0&#x3D;%02x\\ng_gs0&#x3D;%02x\\nr0_data(0x8003f048)&#x3D;%08x %08x\\n&quot;, \n\t\tg_cs0, g_ss0, g_ds0, g_es0, g_fs0, g_gs0, r0_data_hidword, r0_data_lowdword);\n&#125;&#x2F;&#x2F;r0_data(0x8003f048)&#x3D;0040ec00 00081030\n\nint main(int argc, char* argv[]) &#123;\n\tchar cs_eip[6] &#x3D; &#123;0, 0, 0, 0, 0x48, 0&#125;;&#x2F;&#x2F; 这里的 eip 被废弃\n\t__asm &#123;\n\t\tcall fword ptr [cs_eip]\n\t&#125;\n\tprintData();\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;有参\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;q1007729991&#x2F;article&#x2F;details&#x2F;52542296\nint g_a, g_b, g_c;\n__declspec(naked) void getParam(int a, int b, int c) &#123;\n\t__asm &#123;\n\t\t&#x2F;&#x2F; int 3 &#x2F;&#x2F; 取消注释可以在WinDbg中看R0栈数据\n\t\tpushad &#x2F;&#x2F; 0x20 B\n\t\tpushfd &#x2F;&#x2F; 0x04 B\n\t\t&#x2F;&#x2F;             .- 8 个通用寄存器和标志寄存器占用大小\n\t\t&#x2F;&#x2F;             |     .- cs 和 eip 占用大小\n\t\t&#x2F;&#x2F;             |     |\n\t\tmov eax, [esp+0x24+0x08+0x08] &#x2F;&#x2F; 参数 a\n\t\tmov g_a, eax\n\t\tmov eax, [esp+0x24+0x08+0x04] &#x2F;&#x2F; 参数 b\n\t\tmov g_b, eax\n\t\tmov eax, [esp+0x24+0x08+0x00] &#x2F;&#x2F; 参数 c\n\t\tmov g_c, eax\n\t\tpopfd\n\t\tpopad\n\t\tretf 0x0c\n\t&#125;\n&#125;\nint main(int argc, char* argv[])\n&#123;\n\t&#x2F;&#x2F; 构造cs:eip\n\tchar cs_eip[6] &#x3D; &#123;0, 0, 0, 0, 0x48, 0&#125;;\n\t__asm &#123;\n\t\tpush 1\n\t\tpush 2\n\t\tpush 3\n\t\tcall fword ptr [cs_eip];\n\t&#125;\n\tprintf(&quot;g_a &#x3D; %d\\ng_b &#x3D; %d\\ng_c &#x3D; %d\\n&quot;, g_a, g_b, g_c);\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;08.阶段测试.xls???????????????????????????????????????????？？？？？？？？？？？？\n2.在第一题的基础上进行修改,实现通过翻墙的方式返回到其他地址【修改压入堆栈的值esp】\n#include &lt;windows.h&gt;\n\nBYTE GDT[6] &#x3D; &#123;0&#125;;\nDWORD dwH2GValue;\n\nvoid __declspec(naked) GetRegister()\n&#123;\n\t__asm\n\t&#123;\n\n\t\tmov eax,0x8003f00c\t&#x2F;&#x2F; 读取高2G内存\n\t\tmov ebx,[eax]\n\t\tmov dwH2GValue,ebx\n\t\tsgdt GDT;\t\t\t&#x2F;&#x2F; 读取GDT\n\n\t\tmov eax,0x1140118B\n\t\tmov [esp],eax \t\t&#x2F;&#x2F;\n\n\t\tretf\n\t&#125;\n&#125;\n\nvoid PrintRegister()\n&#123;\n\tDWORD GDT_ADDR &#x3D; *(PDWORD)(&amp;GDT[2]);\n\tWORD GDT_LIMIT &#x3D; *(PWORD)(&amp;GDT[0]);\n\n\tprintf(&quot;%x %x %x \\n&quot;, dwH2GValue, GDT_ADDR, GDT_LIMIT);\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\t__asm\n\t&#123;\n\t\tmov ebx,ebx\n\t\tmov ebx,ebx\n\t&#125;\n\n\tchar buff[6];\n\t*(DWORD*)&amp;buff[0] &#x3D; 0x12345678;\n\t*(WORD*)&amp;buff[4] &#x3D; 0x48;\t&#x2F;&#x2F; segment select\n\n\t__asm\n\t&#123;\n\t\tcall fword ptr[buff]\n\t&#125;\n\tprintf(&quot;%X\\n&quot;, temp);\n\tprintf(&quot;成功！\\n&quot;);\n\tscanf(&quot;%d&quot;, &amp;GDT);\n\n\tPrintRegister();\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n3.在第一题的基础上进行修改,在门中再建一个门跳转到其他地址\n&#x2F;&#x2F; Test_For_Call_Gate.cpp : Defines the entry point for the console application.\t\t\t\n&#x2F;&#x2F;\t\t\t\n\t\t\t\n#include &quot;stdafx.h&quot;\t\t\t\n#include &quot;stdio.h&quot;\t\t\t\n#include &quot;windows.h&quot;\t\t\t\n\t\t\t\nint temp;\t\t\t\nBYTE GDT[6] &#x3D; &#123;0&#125;;\t\t\t\nint x,y,z;\t\t\t\nvoid WuCanTiQuan();\t\t\t\n\t\t\t\nchar buff[6] &#x3D; &#123;0,0,0,0,0x48,0&#125;;\t\t\t\n\t\t\t\nvoid __declspec(naked) Test ()\t\t\t\n&#123;\t\t\t\n\t&#x2F;&#x2F;就是这个printf\t\t\n\t&#x2F;&#x2F;printf(&quot;chenggong\\n&quot;);\t\t\n\t_asm\t\t\n\t&#123;\t\t\n\t\tretf\t\n\t&#125;\t\t\n&#125;\t\t\t\n\t\t\t\n&#x2F;&#x2F;Address:00401005\t\t\t\nvoid __declspec(naked) WuCanTiQuan_naked()\t\t\t\n&#123;\t\t\t\n\t_asm\t\t\n\t&#123;\t\t\n\t\t&#x2F;&#x2F;int 3\t\n\t\t\tmov eax,0x8003f008\n\t\t\tmov ebx,[eax]\n\t\t\tmov ds:[temp],ebx\n\t\t\t\n\t\t\t\n\t&#125;\t\t\n\t*(DWORD*)0x8003f048 &#x3D; (DWORD)0x0040ec0000081030;\t\t\n\t_asm\t\t\n\t&#123;\t\t\n\t\tcall fword ptr[buff]\t\n\t\tretf\t\n\t&#125;\t\t\n&#125;\t\t\t\n\t\t\t\nint main(int argc, char* argv[])\t\t\t\n&#123;\t\t\t\n\t\t\t\n\tWuCanTiQuan();\t\t\n\t\t\t\n\treturn 0;\t\t\n&#125;\t\t\t\n\t\t\t\nvoid WuCanTiQuan()\t\t\t\n&#123;\t\t\t\n\tchar buffer[6];\t\t\n\t*(DWORD*)&amp;buffer[0] &#x3D; 0x12345678;\t\t\n\t*(WORD*)&amp;buffer[4] &#x3D; 0x48;\t\t\n\t_asm\t\t\n\t&#123;\t\t\n\t\tcall fword ptr[buffer]\t\n\t&#125;\t\t\n\t\t\t\n\tprintf(&quot;%X\\n&quot;,temp);\t\t\n\tprintf(&quot;成功!\\n&quot;);\t\t\n\tscanf(&quot;%d&quot;,&amp;GDT);\t\t\n&#125;\t\t\t\n&#x2F;&#x2F;Address:\t\t\t\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n&#x2F;&#x2F;中断门\n#include &lt;stdio.h&gt;\n\nint g_high2G; &#x2F;&#x2F; 在中断门中读取高2G内存保存进来。\nint g_eflagsBefore; &#x2F;&#x2F; 保存进入中断门前的 EFLAGS 寄存器。\nint g_eflagsAfter; &#x2F;&#x2F; 保存进入中断门里的 EFLAGS 寄存器。\nint g_eax; &#x2F;&#x2F; 待会在中断门里要用到 eax ，先把旧的保存到这里。\n\n__declspec(naked) void func() &#123;\n\t__asm &#123;\n\t\t&#x2F;*\n\t\t  此时栈结构：\n\t\t\t| eip3 | &lt;- esp0\n\t\t\t| cs3  |\n\t\t\t|eflags|\n\t\t\t| esp3 |\n\t\t\t| ss3  |\n\t\t *&#x2F;\n\t\tmov g_eax, eax\n\t\t&#x2F;&#x2F; 保存当前 eflags\n\t\tpushfd\n\t\tpop g_eflagsAfter\t&#x2F;&#x2F;???\n\t\t&#x2F;&#x2F; 保存原始 eflags\n\t\tmov eax, [esp+0x08]\n\t\tmov g_eflagsBefore, eax\n\t\t&#x2F;&#x2F; 读取 8003f500 处的值\n\t\tmov eax, ds:[0x8003f500]\n\t\tmov g_high2G, eax\n\t\t&#x2F;&#x2F; 恢复 eax\n\t\tmov eax, g_eax\n\n\t\t&#x2F;&#x2F; 中断门返回\n\t\tiretd\n\t&#125;\n&#125;\nint main(int argc, char* argv[])\n&#123;\n\t__asm &#123;\n\t\t&#x2F;&#x2F; 构造的中断门描述符安装在 IDT[20] 这个位置。\n\t\tint 0x20;\n\t&#125;\n\tprintf(&quot;0x8003f500: %08x\\n&quot;, g_high2G);\n\tprintf(&quot;进入中断门前的 EFLAGS &#x3D; %08x\\n&quot;, g_eflagsBefore);\n\tprintf(&quot;进入中断门后的 EFLAGS &#x3D; %08x\\n&quot;, g_eflagsAfter);&#x2F;&#x2F;IF&#x3D;1-&gt;0\n\treturn 0;\n&#125;\n\n\n\n\n\n\n&#x2F;&#x2F;TSS切换实验\n&#x2F;&#x2F; 文件：tss.h\n#pragma once\n\ntypedef struct TSS &#123;\n\tDWORD link; &#x2F;&#x2F; 保存前一个 TSS 段选择子，使用 call 指令切换寄存器的时候由CPU填写。\n\t&#x2F;&#x2F; 这 6 个值是固定不变的，用于提权，CPU 切换栈的时候用\n\tDWORD esp0; &#x2F;&#x2F; 保存 0 环栈指针\n\tDWORD ss0;  &#x2F;&#x2F; 保存 0 环栈段选择子\n\tDWORD esp1; &#x2F;&#x2F; 保存 1 环栈指针\n\tDWORD ss1;  &#x2F;&#x2F; 保存 1 环栈段选择子\n\tDWORD esp2; &#x2F;&#x2F; 保存 2 环栈指针\n\tDWORD ss2;  &#x2F;&#x2F; 保存 2 环栈段选择子\n\t&#x2F;&#x2F; 下面这些都是用来做切换寄存器值用的，切换寄存器的时候由CPU自动填写。\n\tDWORD cr3; \n\tDWORD eip;  \n\tDWORD eflags;\n\tDWORD eax;\n\tDWORD ecx;\n\tDWORD edx;\n\tDWORD ebx;\n\tDWORD esp;\n\tDWORD ebp;\n\tDWORD esi;\n\tDWORD edi;\n\tDWORD es;\n\tDWORD cs;\n\tDWORD ss;\n\tDWORD ds;\n\tDWORD fs;\n\tDWORD gs;\n\tDWORD ldt;\n\t&#x2F;&#x2F; 这个暂时忽略\n\tDWORD io_map;\n&#125; TSS;\n\n\n\n\n&#x2F;&#x2F; 文件：SwitchTSS.cpp\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &quot;tss.h&quot;\n\nchar st[10] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 0042b034\n\nDWORD g_esp;\nDWORD g_cs;\n\nTSS tss &#x3D; &#123;&#x2F;&#x2F; 0x00427b40\n\t\t0x00000000,&#x2F;&#x2F;link\n\t\t(DWORD)st,&#x2F;&#x2F;esp0\n\t\t0x00000010,&#x2F;&#x2F;ss0\n\t\t0x00000000,&#x2F;&#x2F;esp1\n\t\t0x00000000,&#x2F;&#x2F;ss1\n\t\t0x00000000,&#x2F;&#x2F;esp2\n\t\t0x00000000,&#x2F;&#x2F;ss2\n\t\t0x00000000,&#x2F;&#x2F;cr3\n\t\t0x0040fad0,&#x2F;&#x2F;eip\n\t\t0x00000000,&#x2F;&#x2F;eflags\n\t\t0x00000000,&#x2F;&#x2F;eax\n\t\t0x00000000,&#x2F;&#x2F;ecx\n\t\t0x00000000,&#x2F;&#x2F;edx\n\t\t0x00000000,&#x2F;&#x2F;ebx\n\t\t(DWORD)st,&#x2F;&#x2F;esp\n\t\t0x00000000,&#x2F;&#x2F;ebp\n\t\t0x00000000,&#x2F;&#x2F;esi\n\t\t0x00000000,&#x2F;&#x2F;edi\n\t\t0x00000023,&#x2F;&#x2F;es  \n\t\t0x00000008,&#x2F;&#x2F;cs  \n\t\t0x00000010,&#x2F;&#x2F;ss\n\t\t0x00000023,&#x2F;&#x2F;ds\n\t\t0x00000030,&#x2F;&#x2F;fs\n\t\t0x00000000,&#x2F;&#x2F;gs\n\t\t0x00000000,&#x2F;&#x2F;ldt\n\t\t0x20ac0000\n&#125;;\n\n__declspec(naked) func() &#123;&#x2F;&#x2F;0040FAD0\n\t__asm &#123;\n\t\tmov g_esp, esp\n\t\tmov eax, 0\n\t\tmov ax, cs\n\t\tmov g_cs, eax\n\n\t\tiret\n\t&#125;\n&#125;\nint main(int argc, char* argv[])\n&#123;\n\tprintf(&quot;please input cr3:\\n&quot;);\n\tscanf(&quot;%x&quot;, &amp;(tss.cr3));\n\n\tchar buffer[6] &#x3D; &#123;0, 0, 0, 0, 0x48, 0&#125;;\n\t__asm &#123;\n\t\tcall fword ptr [buffer]\n\t&#125;\n\n\t&#x2F;&#x2F; 不出意外，这里打印的值分别是 00000008, 0042b034\n\tprintf(&quot;g_cs &#x3D; %08x\\ng_esp &#x3D; %08x\\n&quot;, g_cs, g_esp);\n\treturn 0;\n&#125;\n\n&#x2F;*\n1.\neq 8003f048 0000e942&#96;7b400068\t【mem窗口看 427b40:tss.base】\n最后一个字节0x68如何得来的呢?\n这是 io_map 字段，固定大小 104，二进制 0x68. 固定值即可。\n2.\nCR3 需要在 WinDbg 中查看。在 WinDbg 中使用命令 !process 0 0来查看程序SwitchTSS.exe 的 DirBase\n3.\n怎么看全局变量tss的首地址，在调试时打开memory子窗口，然后在address一栏输入tss，回车，第一行左边的地址就是tss在内存中的地址了\n4.\n#如果运行到iret蓝屏解决方法# vc用ctrl+f5直接跑。 不要使用f5调试模式。（这会设置tf位而导致试验失败！）\n不止单步会出问题 ，如果函数里有int3的话也会出问题。去掉就可以返回来的。\n5.\ncall 执行执行任务切换（记住，是切换一堆寄存器）。本实验并没有使用 jmp，\n 如果使用 jmp 的话，唯一的区别就是在测试函数那里返回不要使用 iret 指令，否则一定会蓝屏的。\n call的话会保存上一个tss，所以直接iret就成。 如果用jmp，需要自己在内存构造一块tss内存，自己填写值。\n\n在分别使用 call 和 jmp 的时候，有两个地方需要观察一下：1. EFLAGS寄存器 2. TSS 的 link 域。\n\nJMP FAR和CALL FAR访问任务段的区别:\n当使用JMP FAR来实现任务切换时，TSS结构体中的Previous Task Link的值在任务切换完成之后为0，CPU不会为其赋值；\n如果使用CALL FAR来实现任务切换，Previous Task Link的值在任务切换完成之后会CPU会将其填充为原来的TSS段选择子 \n\n当使用JMP FAR来实现任务切换时，EFLAGS寄存器中的NT位不变；\n当使用CALL FAR来实现任务切换时，EFLAGS寄存器中的NT位就会被置1\n(NT位会对iret指令产生影响 NT位如果为0，iret的值从堆栈中取(中断返回)；如果NT位为1，会找TSS中的Previous Task Link进行返回)\n\n*&#x2F;\n\n\n\n&#x2F;&#x2F; 文件：TaskGate.cpp\n#include &lt;windows.h&gt;\n#include &quot;tss.h&quot; &#x2F;&#x2F; tss.h 文件请移步至第11篇《TSS切换实验》中查看。\n\nchar st[10] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 0042ace4\n\nDWORD g_esp;\nDWORD g_cs;\n\nTSS tss &#x3D; &#123;&#x2F;&#x2F; 0x00427a30\n\t\t0x00000000,&#x2F;&#x2F;link\n\t\t(DWORD)st,&#x2F;&#x2F;esp0\n\t\t0x00000010,&#x2F;&#x2F;ss0\n\t\t0x00000000,&#x2F;&#x2F;esp1\n\t\t0x00000000,&#x2F;&#x2F;ss1\n\t\t0x00000000,&#x2F;&#x2F;esp2\n\t\t0x00000000,&#x2F;&#x2F;ss2\n\t\t0x00000000,&#x2F;&#x2F;cr3\n\t\t0x00401020,&#x2F;&#x2F;eip\n\t\t0x00000000,&#x2F;&#x2F;eflags\n\t\t0x00000000,&#x2F;&#x2F;eax\n\t\t0x00000000,&#x2F;&#x2F;ecx\n\t\t0x00000000,&#x2F;&#x2F;edx\n\t\t0x00000000,&#x2F;&#x2F;ebx\n\t\t(DWORD)st,&#x2F;&#x2F;esp\n\t\t0x00000000,&#x2F;&#x2F;ebp\n\t\t0x00000000,&#x2F;&#x2F;esi\n\t\t0x00000000,&#x2F;&#x2F;edi\n\t\t0x00000023,&#x2F;&#x2F;es  \n\t\t0x00000008,&#x2F;&#x2F;cs  \n\t\t0x00000010,&#x2F;&#x2F;ss\n\t\t0x00000023,&#x2F;&#x2F;ds\n\t\t0x00000030,&#x2F;&#x2F;fs\n\t\t0x00000000,&#x2F;&#x2F;gs\n\t\t0x00000000,&#x2F;&#x2F;ldt\n\t\t0x20ac0000\n&#125;;\n\n__declspec(naked) func() &#123;&#x2F;&#x2F;00401020\n\t__asm &#123;\n\t\tmov g_esp, esp\n\t\tmov eax, 0\n\t\tmov ax, cs\n\t\tmov g_cs, eax\n\n\t\tiretd\n\t&#125;\n&#125;\nint main(int argc, char* argv[])\n&#123;\n\tprintf(&quot;please input cr3:\\n&quot;); \n\tscanf(&quot;%x&quot;, &amp;(tss.cr3)); &#x2F;&#x2F; 使用 !process 0 0 查看\n\n\t__asm &#123;\n\t\tint 0x20\n\t&#125;\n\n\t&#x2F;&#x2F; 不出意外，这里打印的值分别是 00000008, 0042ace4\n\tprintf(&quot;g_cs &#x3D; %08x\\ng_esp &#x3D; %08x\\n&quot;, g_cs, g_esp);\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;页的机制\n\n&#x2F;&#x2F;PDE PTE\n&#x2F;&#x2F;0地址读写\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nint main(int argc, char *argv[])\n&#123;\n\tint x &#x3D; 1;\n\n\tprintf(&quot;x的地址：%x\\n&quot;, &amp;x);\n\n\tgetchar();\n\n\t&#x2F;&#x2F; 向0地址写入数据\n\t*(int*)0 &#x3D; 123;\n\t&#x2F;&#x2F; 从0地址读出数据\n\tprintf(&quot;0地址的数据：&quot;, *(int*)0);\n\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;不提权读取高2G内存\nint main(int argc, char* argv[])\n&#123;\n\tint *p &#x3D; (int*)0x8003f00c;\n\tgetchar();\n\tprintf(&quot;%08x\\n&quot;, *p);\n\treturn 0;\n&#125;\n\n\n\n\n\n-------------------------------------------------------------\n\n&#x2F;&#x2F;实验3：通过修改物理页属性使字符串常量可修改\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nint main(int argc, char *argv[])\n&#123;\n\tchar *str &#x3D; &quot;Hello World&quot;;\n\n\tprintf(&quot;线性地址：%x&quot;, str);\n\n\tgetchar();\t\t\t\t\t\t&#x2F;&#x2F; 让程序执行到这里\n\n\t&#x2F;&#x2F;修改只读变量\n\tstr[0] &#x3D; &#39;M&#39;;\n\n\tprintf(&quot;修改后的值：%s\\n&quot;,str);\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;实验4：通过修改物理页属性使普通用户读取高2G内存\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nint main(int argc, char *argv[])\n&#123;\n\tPDWORD p &#x3D; (PDWORD)0x8003F00C;\n\n\tgetchar();\t\t\t&#x2F;&#x2F; 让程序运行到这里\n\n\tprintf(&quot;读取高2G内存：%x \\n&quot;, *p);\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;TLB实验\n&#x2F;&#x2F;PAE分页模式\n#include &lt;windows.h&gt;\n\nDWORD zero, one, two;\n\n__declspec(naked) \nvoid MountPageOnNull() &#123;\n\t__asm &#123;\n\t\tpush ebp\n\t\tmov ebp, esp\n\t\tsub esp, 0x100\n\t\tpush ebx\n\t\tpush esi\n\t\tpush edi\n\t&#125;\n\n\tDWORD* pPTE;\t&#x2F;&#x2F; 保存目标线性地址的 PTE 线性地址\n\tDWORD* pNullPTE; &#x2F;&#x2F; 0 地址的 PTE 线性地址\n\tpNullPTE &#x3D; (DWORD*)0xc0000000;\n\n\t&#x2F;&#x2F; 挂上 0x50000000 所在位置\n\tpPTE &#x3D; (DWORD*)(0xc0000000 + ((0x50000000 &gt;&gt; 9) &amp; 0x7ffff8));\t\n\t*pNullPTE &#x3D; *pPTE;\n\n\tzero &#x3D; *(DWORD*)0;\n\n\t&#x2F;&#x2F; 挂上 0x60000000 所在位置\n\tpPTE &#x3D; (DWORD*)(0xc0000000 + ((0x60000000 &gt;&gt; 9) &amp; 0x7ffff8));\t\n\t*pNullPTE &#x3D; *pPTE;\n\n\tone &#x3D; *(DWORD*)0;\n\n\t&#x2F;&#x2F; 刷新 TLB \n\t__asm &#123;\n\t\tmov eax, cr3\n\t\tmov cr3, eax\n\t&#125;\n\t\n\t&#x2F;&#x2F; 再次读取 0 地址位置的数据\n\ttwo &#x3D; *(DWORD*)0;\n\n\n\n\t__asm &#123;\n\t\tpop edi\n\t\tpop esi\n\t\tpop ebx\n\t\tmov esp, ebp\n\t\tpop ebp\n\t\tiretd\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 外壳包裹函数\n__declspec(naked)\nvoid MyMountPageOnNull() &#123;\n\t__asm &#123;\n\t\tint 0x20\n\t\tret\n\t&#125;\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\tDWORD* x &#x3D; (DWORD*)VirtualAlloc((LPVOID)0x50000000, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\tDWORD* y &#x3D; (DWORD*)VirtualAlloc((LPVOID)0x60000000, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\n\t*x &#x3D; 0x12345678;\n\t*y &#x3D; 0x87654321;\n\n\tif (x !&#x3D; (DWORD*)0x50000000 || y !&#x3D; (DWORD*)0x60000000) &#123;\n\t\tprintf(&quot;Error alloc!\\n&quot;);\n\t\treturn -1;\n\t&#125;\n\n\tMyMountPageOnNull();\n\n\tprintf(&quot;1. 读 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%08x\\n\\n&quot;, zero);\n\n\tprintf(&quot;2. 给 0 地址重新挂上物理页\\n\\n&quot;);\n\n\n\tprintf(&quot;3. 重新读取 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%08x\\n\\n&quot;, one);\n\n\tprintf(&quot;4. 刷新 TLB \\n\\n&quot;);\n\n\tprintf(&quot;5. 再次读取 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%08x\\n&quot;, two);\n\n\t\n\treturn 0;\n&#125;\n\n\n\n\n\n&#x2F;&#x2F;TLB    10-10-12分页模式\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nDWORD x, y, z;\n\nvoid __declspec(naked) PageOnNull() &#123;\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;保存现场\n\t\tpush ebp\n\t\tmov ebp, esp\n\t\tsub esp, 0x100\n\t\tpush ebx\n\t\tpush esi\n\t\tpush edi\n\t&#125;\n\n\tDWORD* pPTE;\t\t\t&#x2F;&#x2F; 保存目标线性地址的 PTE 线性地址\n\tDWORD* pNullPTE;\t\t&#x2F;&#x2F; 0 地址的 PTE 线性地址\n\tpNullPTE &#x3D; (DWORD*)0xC0000000;\n\n\t&#x2F;&#x2F; 挂上 0x50000000 所在位置\n\tpPTE &#x3D; (DWORD*)(0xC0000000 + (0x50000000 &gt;&gt; 10));\n\t*pNullPTE &#x3D; *pPTE;\n\n\tx &#x3D; *(DWORD*)0;\n\n\t&#x2F;&#x2F; 挂上 0x60000000 所在位置\n\tpPTE &#x3D; (DWORD*)(0xC0000000 + (0x60000000 &gt;&gt; 10));\n\t*pNullPTE &#x3D; *pPTE;\n\n\ty &#x3D; *(DWORD*)0;\n\n\t&#x2F;&#x2F; 刷新 TLB\n\t__asm &#123;\n\t\tmov eax, cr3\n\t\tmov cr3, eax\n\t&#125;\n\t\n\t&#x2F;&#x2F; 再次读取 0 地址位置的数据\n\tz &#x3D; *(DWORD*)0;\n\n\n\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;恢复现场\n\t\tpop edi\n\t\tpop esi\n\t\tpop ebx\n\t\tmov esp, ebp\n\t\tpop ebp\n\t\tiretd\n\t&#125;\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\tDWORD* p5 &#x3D; (DWORD*)VirtualAlloc((LPVOID)0x50000000, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\tDWORD* p6 &#x3D; (DWORD*)VirtualAlloc((LPVOID)0x60000000, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\n\tif (p5 !&#x3D; (DWORD*)0x50000000 || p6 !&#x3D; (DWORD*)0x60000000)\n\t&#123;\n\t\tprintf(&quot;Error alloc!\\n&quot;);\n\t\treturn -1;\n\t&#125;\n\n\t*p5 &#x3D; 0x1234;\n\t*p6 &#x3D; 0x5678;\n\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F; 通过中断门提权\n\t\tint 0x20\n\t&#125;\n\n\tprintf(&quot;1. 读 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%x \\n\\n&quot;, x);\n\n\tprintf(&quot;2. 给 0 地址重新挂上物理页\\n\\n&quot;);\n\n\tprintf(&quot;3. 重新读取 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%x \\n\\n&quot;, y);\n\n\tprintf(&quot;4. 刷新 TLB \\n\\n&quot;);\n\n\tprintf(&quot;5. 再次读取 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%x \\n&quot;, z);\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41490873&#x2F;article&#x2F;details&#x2F;89847738\n&#x2F;*\n1. 给定一个线性地址，和长度，读取内容；\nint ReadMemory(OUT BYTE* buffer,IN DWORD dwAddr,IN DWORD dwLeght)\n要求：\n1) 可以自己指定分页方式。\n2) 页不存在，要提示，不能报错。\n3) 可以正确读取数据。\n\n说说思路吧，如果给出的线性地址+读取的长度没有超过0x1000。那么这种情况很好处理，判断PDE和PTE的p都为1就行了\n如果超过了1页，把线性地址加上0x1000那么这个值肯定就对应下一个物理页了。再次判断一下PDE和PTE的p位，注意下细节就好了。\n*&#x2F;\n\n&#x2F;&#x2F; readPageAttr.cpp : 定义控制台应用程序的入口点。\n&#x2F;&#x2F;调用门描述符 eq 8003f048 0041ec00&#96;00081087\n\n#include &quot;stdafx.h&quot;\n#include &lt;Windows.h&gt;\nDWORD dwPDT_Index&#x3D;0;\nDWORD dwPTT_Index&#x3D;0;\nDWORD dwPageIndex&#x3D;0;\nDWORD result&#x3D;0;\nbool bRead&#x3D;false;  &#x2F;&#x2F;地址是否可读标志 true为可正常读\nvoid CallGate();\nvoid _declspec(naked) test()\n&#123;\n\n\n\t_asm\n\t&#123;\n\t\t\n\t\tpush 0x30&#x2F;&#x2F;???\n\t\tpop fs&#x2F;&#x2F;\n\n\t\tpushad\n\t\tpushfd\n\n\t\txor eax,eax\n\t\tmov bRead,al\n\n\t\t&#x2F;&#x2F;PDE&#x3D;0xc0300000+PDI*4\n\t\tmov eax,0xc0300000 \n\t\t&#x2F;&#x2F;dwPDT_Index&#x3D;PDI\n\t\tmov ecx,dwPDT_Index\n\t\tshl ecx,2\n\t\t&#x2F;&#x2F;eax&#x3D;PDE的指针\n\t\tadd eax,ecx\n\t\t&#x2F;&#x2F;读出pde的值\n\t\tmov ebx,[eax]\n\t\t&#x2F;&#x2F;保存在全局变量PDE\n\t\t&#x2F;&#x2F;判断PDE的p位是否为1\n\t\ttest ebx,0x1\n\t\tjz end\n\n\t\t&#x2F;&#x2F;解析PTE 0xc0000000+PDI*4096+PTI*4\n\t\t&#x2F;&#x2F;在上面已经移了2位  再左移10位就是4096\n\t\tshl ecx,10\n\t\t&#x2F;&#x2F;eax&#x3D;PTI\n\t\tmov eax,dwPTT_Index\n\t\tshl eax,2\n\t\t&#x2F;&#x2F;ebx&#x3D;PTE的指针\n\t\tmov ebx,0xc0000000\n\t\tadd ebx,eax\n\t\tadd ebx,ecx\n\t\tmov ebx,[ebx]\n\t\t&#x2F;&#x2F;判断PTE的p位\n\t\ttest ebx,0x1\n\t\tjz end\n\t\t\n\t\t&#x2F;&#x2F;设置bRead为1\n\t\txor eax,eax\n\t\tmov al,0x1\n\t\tmov bRead,al\n\nend:\tpopfd\n\t\tpopad\n\t\tretf\n\t&#125;\n\n&#125;\n\n\n\nvoid ParsePage(DWORD dwAddr)\n&#123;\n\t&#x2F;&#x2F;10  10  12分页模式\n\t&#x2F;&#x2F;获取PDT索引\n\tdwPDT_Index&#x3D;(dwAddr&gt;&gt;22);\n\t&#x2F;&#x2F;获取PTT的索引\n\tdwPTT_Index&#x3D;((dwAddr&lt;&lt;10)&gt;&gt;22);\n\n\tdwPageIndex&#x3D;(dwAddr&amp;0xfff);\n\tprintf(&quot;dwPTT_Index&#x3D;%x&quot;,dwPTT_Index);\n\tCallGate();&#x2F;&#x2F;长调用跨段提权\n\t\n\n&#125;\n\nvoid CallGate()\n&#123;\n\tchar buffer[6]&#x3D;&#123;0&#125;;\n\t*(DWORD*)&amp;buffer[0]&#x3D;0;\n\t*(WORD*)&amp;buffer[4]&#x3D;0x4b;&#x2F;&#x2F;段选择子  01001[idx&#x3D;9] 0[GDT] 11[R3]\n\t_asm\n\t&#123;\n\t\tcall fword ptr [buffer]\n\t\tpush 0x3b\t&#x2F;&#x2F;？ 0011 1011   12、调用门（无参）？？？？？？\n\t\tpop fs \t\t&#x2F;&#x2F;?\n\t&#125;\n\n&#125;\n\n\nbool ReadMemory(OUT void*buffer,IN DWORD dwAddr,IN DWORD\n\t\t\t\tdwlength)\n&#123; \n\t&#x2F;&#x2F;自己制定分页方式 10 10 12\n\t&#x2F;&#x2F;页不存在，要提示不能报错\n\t&#x2F;&#x2F;如果dwAddr+dwLength&gt;0x1000则发生跨页，需要检查两个页\n\tprintf(&quot;dwAddr&#x3D;%x&quot;,dwAddr);\n\tif((dwAddr&amp;0xfff+dwlength)&gt;0x1000)\n\t&#123;\n\t\t&#x2F;&#x2F;判断是否可读\n\t\tParsePage(dwAddr);\n\t\tif (bRead)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;如果该物理页可读，则判断下一个物理页  该线性地址+0x1000\n\t\t\t&#x2F;&#x2F;就肯定是下一个物理页了\n\t\t\tParsePage((dwAddr+0x1000));\n\t\t\tif (bRead)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;到这里说明是两个物理页都是可读的，读取值\n\t\t\t\tmemcpy_s(buffer,dwlength,(DWORD*)dwAddr,dwlength);\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t\t\n\t\t&#125; \n\t\t\t\n\t\n\n\t&#125;\n\telse\n\t&#123;\n\t\tParsePage(dwAddr);\n\t\tif (bRead)\n\t\t&#123;\n\t\t\n\t\t\t&#x2F;&#x2F;到这里说明该物理页是可读的，读取值\n\t\t\tmemcpy_s(buffer,dwlength,(DWORD*)dwAddr,dwlength);\n\t\t\treturn true;\n\t\t&#125; \n\t\t\n\t&#125;\n\n\treturn false;\n\t\t\n&#125;\n\nint _tmain(int argc, _TCHAR* argv[])\n&#123;\n\n\tDWORD buf[100]&#x3D;&#123;0&#125;;\n\tprintf(&quot;调用门地址：%x\\n&quot;,test);&#x2F;&#x2F;test()函数首地址\n\tint *p&#x3D;(int *)0x11ffc;\n\t*p&#x3D;0x12345678;\n\tBOOL bRet&#x3D;ReadMemory(buf,0x11ffc,4);&#x2F;&#x2F;ffc+4&#x3D;0x1000 没跨页\n\t\t\n\t\n\tif (bRet)\n\t&#123;\n\t\tfor(int i&#x3D;0;i&lt;1;i++)&#123;\n\t\t\tprintf(&quot;\\n 内存读取成功\\n buf[%d]&#x3D;%x&quot;,i,buf[i]);&#x2F;&#x2F; 1 2 3 4 5 6 7 8\n\t\t&#125;\n\t&#125; \n\telse\n\t&#123;\n\t\tprintf(&quot;内存读取失败&quot;);\n\t&#125;\n\tgetchar();\n\treturn 0;\n\t\n&#125;\n\n\n\n\n\n&#x2F;*\n2.申请长度为100的DWORD的数组,且每项用该项的地址初始化；\n把[这个数组所在的物理页挂到0x1000的地址上];\n定义一个指针，指向0x1000这个页里的数组所在的地址,用0x1000这个页的线性地址打印出这数组的值；\n\n要求：\n数组所在的物理页，是同一个页；\n*&#x2F;\n\n&#x2F;&#x2F; protect2.cpp : 定义控制台应用程序的入口点。\n&#x2F;&#x2F;调用门描述符 eq 8003f048 0041【ec00&#96;0008】1087\n&#x2F;&#x2F;00411087:段偏移[看函数首址]\t  R3-&gt;R0段base\n#include &quot;stdafx.h&quot;\n#include&lt;windows.h&gt;\nDWORD dwPDT_Index&#x3D;0;\nDWORD dwPTT_Index&#x3D;0;\nDWORD dwPageIndex&#x3D;0;\nDWORD dwPDE;\nDWORD dwPTE;\n\n\nvoid CallGate()\n&#123;\n\tchar buffer[6]&#x3D;&#123;0&#125;;\n\t*(DWORD*)&amp;buffer[0]&#x3D;0;\n\t*(WORD*)&amp;buffer[4]&#x3D;0x4b;\n\t_asm\n\t&#123;\n\t\tcall fword ptr [buffer]\n\t\tpush 0x3b&#x2F;&#x2F;\n\t\tpop fs&#x2F;&#x2F;\n\t&#125;\n\n&#125;\n\nvoid _declspec(naked) test()\n&#123;\n\n\n\t_asm\n\t&#123;\n\n\t\t\tpush 0x30\n\t\t\tpop fs\n\t\t\tpushad\n\t\t\tpushfd\n\n\t\t\t&#x2F;&#x2F;PDE&#x3D;0xc0300000+PDI*4 参见23-24、PDT&#x2F;PTT基址\n\t\t\tmov eax,0xc0300000 \n\t\t\t&#x2F;&#x2F;dwPDT_Index&#x3D;PDI\n\t\t\tmov ecx,dwPDT_Index\n\t\t\tshl ecx,2\n\t\t\t&#x2F;&#x2F;eax&#x3D;PDE的指针\n\t\t\tadd eax,ecx\n\t\t\t&#x2F;&#x2F;读出pde的值\n\t\t\tmov eax,[eax]\n\t\t\tmov dwPDE,eax\n\n\t\t\t&#x2F;&#x2F;解析PTE 0xc0000000+PDI*4096+PTI*4\n\t\t\t&#x2F;&#x2F;在上面已经移了2位  再左移10位就是4096\n\t\t\tshl ecx,10\n\t\t\t&#x2F;&#x2F;eax&#x3D;PTI\n\t\t\tmov eax,dwPTT_Index\n\t\t\tshl eax,2\n\t\t\t&#x2F;&#x2F;ebx&#x3D;PTE的指针\n\t\t\tmov ebx,0xc0000000\n\t\t\tadd ebx,eax\n\t\t\tadd ebx,ecx\n\t\t\tmov ebx,[ebx]\n\t\t\tand ebx,0xfffff000\n\t\t\tor ebx,0x067\t&#x2F;&#x2F;线性地址后3位:067\n\t\t\tmov dwPTE,ebx\t&#x2F;&#x2F;dwPTE存物理页首址\n\t\t\t\n\n\t\t\t&#x2F;&#x2F;找出0x1000的PDE\n\t\t\tmov eax,0x1000\n\t\t\tshr eax,20\t &#x2F;&#x2F;??\n\t\t\tand eax,0xffc&#x2F;&#x2F;??\n\t\t\tmov ecx,eax  &#x2F;&#x2F;用ecx来保存PDI？？？？？？\n\t\t\tadd eax,0xc0300000\n\t\t\tint 3\n\t\t\t&#x2F;&#x2F;找到PDE&#x3D;0xc0300000+PDI(*4???)\n\t\t\tmov ebx,[eax]\n\t\t\t\n\t\t\t&#x2F;&#x2F;判断 如果无效 则挂一个dwPDE\n\t\t\ttest ebx,0\n\t\t\tjnz s\n\t\t\tmov ebx,dwPDE\n\t\t\tmov [eax],ebx\n\ns:\t\t\tmov eax,0x1000\n\t\t\tshl eax,10\n\t\t\tshr eax,20\n\t\t\t&#x2F;&#x2F;计算 PTI*4 ?????\n\t\t\tand eax,0xffc\n\t\t\t&#x2F;&#x2F;计算PDI*4096\n\t\t\tshl ecx,12\n\t\t\t&#x2F;&#x2F;解析PTE 0xc0000000+PDI*4096+PTI*4\n\t\t\tmov ebx,0xc0000000\n\t\t\tadd ebx,eax\n\t\t\tadd ebx,ecx\n\t\t\tmov eax,dwPTE\n\t\t\tmov [ebx],g_eax&#x2F;&#x2F;挂dwPTE：数组所在的物理页首址\n\n\t\t\tpopfd\n\t\t\tpopad\n\t\t\tretf\n\t&#125;\n\n&#125;\n\nvoid ParsePage(DWORD dwAddr)\n&#123;\n\t&#x2F;&#x2F;10  10  12分页模式\n\t&#x2F;&#x2F;获取PDT索引\n\tdwPDT_Index&#x3D;(dwAddr&gt;&gt;22);\n\t&#x2F;&#x2F;获取PTT的索引\n\tdwPTT_Index&#x3D;((dwAddr&lt;&lt;10)&gt;&gt;22);\n\n\tdwPageIndex&#x3D;(dwAddr&amp;0xfff);\n\tprintf(&quot;dwPTT_Index&#x3D;%x\\n&quot;,dwPTT_Index);\n\tCallGate();\n\n&#125;\n\n\n\nint _tmain(int argc, _TCHAR* argv[])\n&#123;\n\t&#x2F;&#x2F; 1.这个函数可以用来对虚拟地址空间进行分配(保留操作MEM_RESERVE) \n\t&#x2F;&#x2F; 2.这个函数可以把已经保留的虚拟地址提交到物理存储器(MEM_COMMIT) \n\tDWORD* dwAddr&#x3D;(DWORD*)VirtualAlloc(0,0x1000,MEM_COMMIT,PAGE_READWRITE);&#x2F;&#x2F;地址0开始的一页\n\tDWORD *p&#x3D;dwAddr;\n\tprintf(&quot;test&#x3D;%x   dwAddr&#x3D;%x\\n&quot;,test,(DWORD)dwAddr);\n\tfor (int i&#x3D;0;i&lt;100;i++)\n\t&#123;\n\t\t*p&#x3D;(DWORD)p;\n\t\tp++;\n\t&#125;\n\tParsePage((DWORD)dwAddr);\n\n\t&#x2F;&#x2F;3：定义一个指针，指向0x1000  使用指针打印出数组的值。\n\tdwAddr&#x3D;(DWORD*)0x1000;\n\tfor (int i&#x3D;0;i&lt;100;i++)\n\t&#123;\n\t\tprintf(&quot;test&#x3D;%x\\n&quot;,*dwAddr);\n\t\tdwAddr++;\n\t&#125;\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;API函数 系统调用\n\n\n&#x2F;*\n编写一个ReadProcessMemory函数\n要求：不使用任何DLL，直接调用0环函数\n意义：自己实现的API，可以避免3环程序被恶意挂钩\n*&#x2F;\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;102786700\n&#x2F;&#x2F;进程1\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint num &#x3D; 0x12345678;\n\n\tprintf(&quot;&amp;num &#x3D; %x \\n&quot;, &amp;num);\n\n\tgetchar();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;进程2 ?????????\nvoid MyReadProcessMemory(\n\tHANDLE hProcess, \n\tLPCVOID lpBaseAddress, \n\tLPVOID lpBuffer, \n\tDWORD nSize, \n\tLPDWORD lpNumberOfBytesRead)\n&#123;\n\t__asm\n\t&#123;\n\t\tlea  eax, [ebp+0x14]\n\t\tpush eax\t\t\t\t; ReturnLength\n\t\tpush [ebp+0x14]\t\t\t; BufferLength\n\t\tpush [ebp+0x10]\t\t\t; Buffer\n\t\tpush [ebp+0x0C]\t\t\t; BaseAddress\n\t\tpush [ebp+0x08]\t\t\t; ProcessHandle\n\n\t\tmov  eax, 0BAh\n\t\tmov  edx, esp\n\t\tint  02eh\t\t\t\t; Windows操作系统提供IDT[0x2e]给用户进行内核调用\n\t\t\n\t\tadd  esp, 20\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tDWORD pBuffer;\t\t\t\t\t\t\t&#x2F;&#x2F; 接收数据的缓冲区\n\tHANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, 0, PID);\t\t\t&#x2F;&#x2F; 获得进程句柄，PID修改为进程1的PID\n\tMyReadProcessMemory(hProcess, (PVOID)0x12ff7c, &amp;pBuffer, 4, 0);\t\t&#x2F;&#x2F; 调用自定义的ReadProcessMemory\n\n\tprintf(&quot;pBuffer &#x3D; %x \\n&quot;, pBuffer);\t\t&#x2F;&#x2F; 打印从其他进程中读取的数据\n\n\tgetchar();\n\treturn 0;\n&#125;\n&#x2F;&#x2F;成功从进程1中读取了变量num的值！\n\n\n&#x2F;&#x2F;R\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;onetrainee&#x2F;p&#x2F;11704626.html\n\n&#x2F;&#x2F;W？？？？？？？？？\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;dubh3&#x2F;p&#x2F;13322156.html\n&#x2F;*\n分析过程如下：\n\n1.先正常的调用WriteProcessMemory函数，然后在OllyDbg中跟踪它，\n看他执行到 NtWriteProcessMemory 时的堆栈是什么样的，观察我们传进去的每一个参数在栈中此时的位置\n2.进入 NtWriteProcessMemory ，看下此时我们的栈又发生了什么变化\n3.根据参数在栈中的变化，以及分析执行完后栈要怎么平衡回去才能让我们的函数正常返回\n*&#x2F;\n#include &quot;stdio.h&quot;\n#include &quot;windows.h&quot;\n\nvoid MyWriteProcessMemory(HANDLE hProcess,LPVOID lpBaseAddress,LPVOID lpBuffer,DWORD nSize,LPDWORD lpNumberOfBytesWritten)\n&#123;\n\t_asm\n\t&#123;\n\t\tlea eax,[ebp+0x18]\n\t\tpush eax 　　　　　　　　&#x2F;&#x2F;lpNumberOfBytesWritten10         push [ebp+0x14]　　　　　&#x2F;&#x2F;nSize\n\t\tpush [ebp+0x10]　　　　&#x2F;&#x2F;lpBuffer\n\t\tpush [ebp+0xc]　　　　&#x2F;&#x2F;lpBaseAddress\n\t\tpush [ebp+8]　　　　　　&#x2F;&#x2F;hProcess\n\t\tsub esp,4　　　　　　　　&#x2F;&#x2F;平衡堆栈，因为在call NtWriteProcessMemory后，栈中会压入一个4字节数据（我们不用管这4字节数据干嘛的）\n\t\tmov eax,0x115　　　　　　&#x2F;&#x2F;把服务号保存在eax中\n\t\tmov edx,0x7FFE0300　　　　&#x2F;&#x2F;获取SystemCall中的地址\n\t\tcall dword ptr [edx]   &#x2F;&#x2F;调用SystemCall　　18         add esp,0x18　　　　　　&#x2F;&#x2F;本来这个call后面是跟retn 0x14的，我们是自己写的程序，不能返回到它那里去，我们只需要平衡到这段代码执行之前的esp就行了\n\t&#125;\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\tchar inBuffer[10] &#x3D; &quot;abcdefg&quot;;　　&#x2F;&#x2F;要写入的数据\n\tchar strA[10] &#x3D; &#123;0&#125;;　　&#x2F;&#x2F;要写入数据的缓冲区　　\n\tSIZE_T size &#x3D; 0;　　　　&#x2F;&#x2F;接收实际的数据长度\n\tMyWriteProcessMemory((HANDLE)-1,strA,inBuffer,9,&amp;size);　　&#x2F;&#x2F;其实和WriteProcessMemory的参数一样，我们采用这种方式来调用自己的函数，开头的-1表示操作的进程是自己\n\tprintf(&quot;%s\\n&quot;,strA);　　　　&#x2F;&#x2F;打印strA，如果写入成功，会打印出上面的 abcdefg\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;&#x2F;【进程线程】\n练习 ：通过进程结构体遍历所有的进程\n\tULONG ProcessListHead&#x3D;0;\n\tPLIST_ENTRY pListHead;\n\tPLIST_ENTRY pListNext;\n\t__asm&#123;\n\t\n\t\tmov eax,fs:124h\n\t\tmov ebx,[eax+220h]  &#x2F;&#x2F;得到线程结构体\n\t\tmov ProcessListHead,ebx\n\t&#125;\n\n\tpListHead&#x3D;(PLIST_ENTRY)(ProcessListHead+0x88);\n\tpListNext&#x3D;pListHead;\n\t\n\tdo\n\t&#123;\n\t\n\t\tDbgPrint(&quot;ImageFileName&#x3D;%s\\n&quot;,(PULONG)pListNext-0x88&#x2F;4+0x174&#x2F;4);\n\t\t\n\t\tpListNext&#x3D;pListNext-&gt;Flink;\n\t&#125;while(pListHead!&#x3D;pListNext);\n\n\n\n\n\n\n\n\n\n（五）—— 模拟线程切换\n&#x2F;&#x2F; ThreadSwitch.cpp : Defines the entry point for the console application.\n&#x2F;&#x2F;\n\n#include &quot;stdafx.h&quot;\n#include &quot;ThreadCore.h&quot;\n\nint main(int argc, char* argv[])\n&#123;\n\t&#x2F;&#x2F;初始化线程环境\n\tRegisterGMThread(&quot;Thread1&quot;,Thread1,NULL);\n\tRegisterGMThread(&quot;Thread2&quot;,Thread2,NULL);\n\tRegisterGMThread(&quot;Thread3&quot;,Thread3,NULL);\n\tRegisterGMThread(&quot;Thread4&quot;,Thread4,NULL);\n\n    &#x2F;&#x2F;仿Windows线程切换\n\tfor (;;)\n\t&#123;\n\t\tSleep(20);\n\t\tThreadPolling();\n\t&#125;\n\t\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; ThreadCore.h: interface for the ThreadCore class.\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n#if !defined(AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_)\n#define AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_\n\n#if _MSC_VER &gt; 1000\n#pragma once\n#endif &#x2F;&#x2F; _MSC_VER &gt; 1000\n\n\n\n#define MAXGMTHREAD\t0x100\n\n\n#define GMTHREAD_CREATE\t\t0x01\n#define GMTHREAD_READY\t\t0x02\n#define GMTHREAD_RUNING\t\t0x04\n#define GMTHREAD_SLEEP\t\t0x08\n#define GMTHREAD_SUSPEND\t0x10\n#define GMTHREAD_EXIT\t0x100\n\ntypedef struct\n&#123;\n\tchar *name;\t\t\t\t\t&#x2F;&#x2F; 线程名 相当于线程TID\n\tint Flags;\t\t\t\t\t&#x2F;&#x2F; 线程状态\n\tint SleepMillisecondDot;\t&#x2F;&#x2F; 休眠时间\n\t\n\tvoid *InitialStack;\t\t\t&#x2F;&#x2F; 线程堆栈起始位置，也就是EBP\n\tvoid *StackLimit;\t\t\t&#x2F;&#x2F; 线程堆栈界限\n\tvoid *KernelStack;\t\t\t&#x2F;&#x2F; 线程堆栈当前位置，也就是ESP\n\t\n\tvoid *lpParameter;\t\t\t&#x2F;&#x2F; 线程函数的参数\n\tvoid (*func)(void *lpParameter);\t&#x2F;&#x2F; 线程函数\n\t\n&#125; GMThread_t;\t\n\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\n&#x2F;* 线程结构体数组\n * 线程在不同状态的存储位置不同\n * 正在运行的线程位于KPCR\n * 等待中的线程位于等待链表\n * 就绪的线程位于调度链表中\n * 这里对于以上三种情况使用一个数组进行包含\n * main函数也是一个线程，信息存在第一个数组成员里，也就是下标为0的位置\n * 创建线程时，是从下标为1的位置开始分配的\n *&#x2F;\nextern GMThread_t GMThreadList[MAXGMTHREAD];\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\nvoid IdleGMThread(void *lpParameter);\n\nvoid GMThreadStartup(GMThread_t *GMThreadp);\nvoid initGMThread(GMThread_t *GMThreadp,char *name,void (*func)(void *lpParameter),void *lpParameter);\nint RegisterGMThread(char *name,void (*func)(void *lpParameter),void *lpParameter);\nvoid Scheduling(void);\n\nvoid GMSleep(int Milliseconds);\n\nvoid ThreadPolling();\n\nvoid Thread1(void *lpParameter);\nvoid Thread2(void *lpParameter);\nvoid Thread3(void *lpParameter);\nvoid Thread4(void *lpParameter);\n\n#endif &#x2F;&#x2F; !defined(AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_)\n\n\n\n\n\n&#x2F;&#x2F;ThreadCore.cpp\n#include &quot;stdafx.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;windows.h&quot;\n\n#include &quot;ThreadCore.h&quot;\n\n#define _SELF\t\t&quot;滴水_仿Windows线程切换&quot;\n\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\nint CurrentThreadindex &#x3D; 0;\nGMThread_t GMThreadList[MAXGMTHREAD] &#x3D; &#123; NULL,0 &#125;;\n\n#define GMTHREADSTACKSIZE 0x80000\n\nvoid *WindowsStackLimit &#x3D; NULL;\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\n__declspec(naked) void SwitchContext(GMThread_t *SrcGMThreadp,GMThread_t *DstGMThreadp)\n&#123;\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;保存现场\n\t\tpush ebp\n\t\tmov  ebp,esp\n\t\t&#x2F;&#x2F;sub esp,__LOCAL_SIZE\n\t\tpush edi\n\t\tpush esi\n\t\tpush ebx\n\t\tpush ecx\n\t\tpush edx\n\t\tpush eax\n\t\t\n\t\tmov esi,SrcGMThreadp\t&#x2F;&#x2F;当前线程结构体指针\n\t\tmov edi,DstGMThreadp\t&#x2F;&#x2F;目标线程结构体指针\n\n\t\t&#x2F;&#x2F; esi + GMThread_t.KernelStack &#x3D;&#x3D; SrcGMThreadp.KernelStack\n\t\tmov [esi+GMThread_t.KernelStack], esp\n\t\t&#x2F;&#x2F;---------------经典堆栈切换 另一个线程复活----------------------------------\n\t\t&#x2F;&#x2F; edi + GMThread_t.KernelStack &#x3D;&#x3D; DstGMThreadp.KernelStack\n\t\tmov esp, [edi+GMThread_t.KernelStack]\n\n\t\t&#x2F;&#x2F;此时，ESP为目标线程堆栈栈顶\n\t\tpop eax\n\t\tpop edx\n\t\tpop ecx\n\t\tpop ebx\n\t\tpop esi\n\t\tpop edi\n\t\t&#x2F;&#x2F;add esp,__LOCAL_SIZE\n\t\tpop ebp\n\t\tret\t\t&#x2F;&#x2F;ebp之后是GMThreadStartup函数地址\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;用来执行线程函数\nvoid GMThreadStartup(GMThread_t *GMThreadp)\n&#123;\n\t&#x2F;&#x2F;执行线程函数\n\tGMThreadp-&gt;func(GMThreadp-&gt;lpParameter);\n\t&#x2F;&#x2F;线程函数执行结束，设置线程状态为EXIT\n\tGMThreadp-&gt;Flags &#x3D; GMTHREAD_EXIT;\n\t&#x2F;&#x2F;线程切换\n\tScheduling();\n\n\treturn ;\n&#125;\n\nvoid IdleGMThread(void *lpParameter)\n&#123;\n\tScheduling();\n\treturn ;\n&#125;\n\nvoid PushStack(unsigned int **Stackpp,unsigned int v)\n&#123;\n\t&#x2F;&#x2F; ESP 减去一个单位（4个字节）\n\t*Stackpp -&#x3D; 1;\n\n\t&#x2F;&#x2F;[ESP] &#x3D; 参数v\n\t**Stackpp &#x3D; v;\n\n\treturn ;\n&#125;\n\nvoid initGMThread(GMThread_t *GMThreadp,char *name,void (*func)(void *lpParameter),void *lpParameter)\n&#123;\n\tunsigned char *StackPages;\n\tunsigned int *StackDWORDParam;\n\t\n    &#x2F;&#x2F;结构初始化赋值\n\tGMThreadp-&gt;Flags &#x3D; GMTHREAD_CREATE;\t\t&#x2F;&#x2F;初始化线程为创建状态\n\tGMThreadp-&gt;name &#x3D; name;\t\t\t\t\t&#x2F;&#x2F;线程名\n\tGMThreadp-&gt;func &#x3D; func;\t\t\t\t\t&#x2F;&#x2F;线程函数，已经定义好\n\tGMThreadp-&gt;lpParameter &#x3D; lpParameter;\t&#x2F;&#x2F;参数\n\t\n    &#x2F;&#x2F;申请堆栈空间\n\tStackPages &#x3D; (unsigned char*)VirtualAlloc(NULL,GMTHREADSTACKSIZE,MEM_COMMIT,PAGE_READWRITE);\n\t\n\t&#x2F;&#x2F;堆栈清零\n\tmemset(StackPages,0,GMTHREADSTACKSIZE);\n\t\n\t&#x2F;&#x2F;堆栈栈底（EBP）\n\tGMThreadp-&gt;InitialStack &#x3D; (StackPages+GMTHREADSTACKSIZE-0x10);\n\t\n\t&#x2F;&#x2F;堆栈边界地址\n\tGMThreadp-&gt;StackLimit &#x3D; StackPages;\n\t\n\tStackDWORDParam &#x3D; (unsigned int*)GMThreadp-&gt;InitialStack;\n\t\n\t&#x2F;&#x2F;入栈\n\tPushStack(&amp;StackDWORDParam,(unsigned int)GMThreadp);\t\t&#x2F;&#x2F;线程结构体自身指针，用来寻找 线程函数|函数参数\n\tPushStack(&amp;StackDWORDParam,(unsigned int)9);\t\t\t\t&#x2F;&#x2F;平衡堆栈\n\tPushStack(&amp;StackDWORDParam,(unsigned int)GMThreadStartup);\t&#x2F;&#x2F;函数地址，执行线程函数的入口函数\n\t&#x2F;&#x2F;下面的值可以随便写\n\tPushStack(&amp;StackDWORDParam,5); &#x2F;&#x2F;push ebp\n\tPushStack(&amp;StackDWORDParam,7); &#x2F;&#x2F;push edi\n\tPushStack(&amp;StackDWORDParam,6); &#x2F;&#x2F;push esi\n\tPushStack(&amp;StackDWORDParam,3); &#x2F;&#x2F;push ebx\n\tPushStack(&amp;StackDWORDParam,2); &#x2F;&#x2F;push ecx\n\tPushStack(&amp;StackDWORDParam,1); &#x2F;&#x2F;push edx\n\tPushStack(&amp;StackDWORDParam,0); &#x2F;&#x2F;push eax\n\t&#x2F;&#x2F;执行后，堆栈变化如下\n\n\tGMThreadp-&gt;KernelStack &#x3D; StackDWORDParam;\t&#x2F;&#x2F;指向当前线程的栈顶（ESP）\n\tGMThreadp-&gt;Flags &#x3D; GMTHREAD_READY;\t\t\t&#x2F;&#x2F;线程状态设置为就绪\n\n\treturn ;\n&#125;\n\nint RegisterGMThread(char *name,void (*func)(void *lpParameter),void *lpParameter)\n&#123;\n\tint i;\n\n\t&#x2F;&#x2F;为数组下标为0的成员赋值，IDLE GM Thread，相当于main函数线程\n\tif (GMThreadList[0].name&#x3D;&#x3D;NULL)\n\t&#123;\n\t\t&#x2F;&#x2F;申请堆栈初始化操作  线程数组 ，线程名字 ，函数地址 ，参数\n\t\tinitGMThread(&amp;GMThreadList[0], &quot;IDLE GM Thread&quot;, IdleGMThread, NULL);\n\t&#125;\n\n\t&#x2F;&#x2F;新增的线程从下标为1开始写入\n\tfor (i&#x3D;1;GMThreadList[i].name;i++)\n\t&#123;\n\t\t&#x2F;&#x2F;判断数组中尚未初始化的成员\n\t\tif (0&#x3D;&#x3D;stricmp(GMThreadList[i].name,name))\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;初始化线程结构体\n\tinitGMThread(&amp;GMThreadList[i],name,func,lpParameter);\n\n\treturn (i|0x55AA0000);&#x2F;&#x2F;??????????\n&#125;\n\nvoid Scheduling(void)\n&#123;\n\tint i;\n\tint TickCount;\n\tGMThread_t *SrcGMThreadp;\n\tGMThread_t *DstGMThreadp;\n\n\tTickCount &#x3D; GetTickCount();\n\n\tSrcGMThreadp &#x3D; &amp;GMThreadList[CurrentThreadindex];\t\t&#x2F;&#x2F;当前线程结构体指针\n\tDstGMThreadp &#x3D; &amp;GMThreadList[0];\t\t\t\t\t\t&#x2F;&#x2F;目标线程结构体指针\n\n\t&#x2F;&#x2F;遍历线程数组，找到状态为就绪的线程\n\tfor (i&#x3D;1;GMThreadList[i].name;i++)\n\t&#123;\n\t\tif (GMThreadList[i].Flags&amp;GMTHREAD_SLEEP)\n\t\t&#123;\n\t\t\tif (TickCount&gt;GMThreadList[i].SleepMillisecondDot)\n\t\t\t&#123;\n\t\t\t\tGMThreadList[i].Flags &#x3D; GMTHREAD_READY;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif ((GMThreadList[i].Flags&amp;GMTHREAD_READY))\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;检测到有线程的状态为就绪，将其作为目标线程\n\t\t\tDstGMThreadp &#x3D; &amp;GMThreadList[i];\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\t\n\tCurrentThreadindex &#x3D; DstGMThreadp-GMThreadList;\t\t&#x2F;&#x2F;得到即将执行的线程下标\n\tSwitchContext(SrcGMThreadp,DstGMThreadp);\t\t\t&#x2F;&#x2F;线程切换\n\t\n\treturn ;\n&#125;\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\nvoid GMSleep(int Milliseconds)\n&#123;\n\tGMThread_t *GMThreadp;\n\tGMThreadp &#x3D; &amp;GMThreadList[CurrentThreadindex];\n\n\tif ((GMThreadp-&gt;Flags&amp;GMTHREAD_SUSPEND)&#x3D;&#x3D;0)\n\t&#123;\n\t\tGMThreadp-&gt;SleepMillisecondDot &#x3D; GetTickCount()+Milliseconds;\n\t\tGMThreadp-&gt;Flags &#x3D; GMTHREAD_SLEEP;\n\t&#125;\n\n\t&#x2F;&#x2F;线程切换\n\tScheduling();\n\treturn ;\n&#125;\n\nvoid ThreadPolling()\n&#123;\n\tunsigned char StackPage[GMTHREADSTACKSIZE];\n\tmemset(StackPage,0,GMTHREADSTACKSIZE);\n\t&#x2F;&#x2F;模拟线程切换\n\tIdleGMThread(StackPage);\n\n\treturn ;\n&#125;\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\nvoid vmmprint(char *f,int l,char *fmt, ...)\n&#123;\n\tint ret;\n\tchar buffer[0x100];\n\tva_list args;\n\t\n\t&#x2F;&#x2F;----------------------------------\n\tva_start(args, fmt);\n\t_snprintf(buffer,0x80,&quot;[%s]:&quot;,f,l);\n\tret &#x3D; _vsnprintf(buffer+strlen(buffer), 0x100-strlen(buffer), fmt, args);\n\tif (ret &#x3D;&#x3D; -1)\n\t&#123;\n\t\tstrcpy(buffer, &quot;vmmprint: error.&quot;);\n\t&#125;\n\t&#x2F;&#x2F;----------------------------------\n\tprintf(&quot;%s&quot;,buffer);\n\t&#x2F;&#x2F;OutputDebugString(buffer);\n\t\n\treturn ;\n&#125;\n\nvoid Thread1(void *lpParameter)\n&#123;\n\tint i;\n\tfor (i&#x3D;0;i&lt;3;i++)\n\t&#123;\n\t\tvmmprint(_SELF,__LINE__,&quot;Thread1 \\n&quot;);\n\t\tGMSleep(1000);\n\t&#125;\n\n\treturn ;\n&#125;\n\nvoid Thread2(void *lpParameter)\n&#123;\n\tfor (;;)\n\t&#123;\n\t\tvmmprint(_SELF,__LINE__,&quot;Thread2 \\n&quot;);\n\t\tGMSleep(500);\n\t&#125;\n\t\n\treturn ;\n&#125;\n\nvoid Thread3(void *lpParameter)\n&#123;\n\tfor (;;)\n\t&#123;\n\t\tvmmprint(_SELF,__LINE__,&quot;Thread3 \\n&quot;);\n\t\tGMSleep(800);\n\t&#125;\n\t\n\treturn ;\n&#125;\n\nvoid Thread4(void *lpParameter)\n&#123;\n\tfor (;;)\n\t&#123;\n\t\tvmmprint(_SELF,__LINE__,&quot;Thread4 \\n&quot;);\n\t\tGMSleep(200);\n\t&#125;\n\t\n\treturn ;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;二、驱动开发\n\n\n#include &quot;ntddk.h&quot;\n\n&#x2F;&#x2F;卸载函数\nVOID DriverUnload(PDRIVER_OBJECT driver)\n&#123;\n\tDbgPrint(&quot;驱动程序已停止.\\r\\n&quot;);\n&#125;\n\n&#x2F;&#x2F;驱动程序入口函数，相当于控制台的main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)\n&#123;\n\tDbgPrint(&quot;驱动程序已运行.\\r\\n&quot;);\n\tDbgPrint(&quot;%x . \\r\\n&quot;, DriverObject);\n\n\t&#x2F;&#x2F;设置一个卸载函数  便于退出\n\tDriverObject-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;103519478\nWindows驱动开发学习笔记（四）—— 3环与0环通信（常规方式）\n\n&#x2F;&#x2F;R0代码\n#include &lt;ntddk.h&gt;\n#include &lt;ntstatus.h&gt;\n\n#define DEVICE_NAME L&quot;\\\\Device\\\\MyDevice&quot;\n&#x2F;&#x2F; Ring3用CreateFile打开设备时，用&quot;\\\\\\\\.\\\\MyTestDriver&quot;\n#define SYMBOLICLINK_NAME L&quot;\\\\??\\\\MyTestDriver&quot;\n\n&#x2F;&#x2F; 0-2047是保留的  2048~4095\n#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\n&#x2F;&#x2F; 卸载函数\nVOID DriverUnload(PDRIVER_OBJECT pDriver)\n&#123;\n\tUNICODE_STRING SymbolicLinkName &#x3D; &#123;0&#125;;\n\n\tDbgPrint(&quot;驱动程序停止运行了 . \\r\\n&quot;);\n\n\t&#x2F;&#x2F; 删除符号链接 删除设备\n\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME);\n\tIoDeleteSymbolicLink(&amp;SymbolicLinkName);\n\tIoDeleteDevice(pDriver-&gt;DeviceObject);\n&#125;\n\n&#x2F;&#x2F; IRP_MJ_CREATE处理函数\nNTSTATUS IrpCreateProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)\n&#123;\n\tDbgPrint(&quot;DispatchCreate ... \\n&quot;);\n\n\t&#x2F;&#x2F; 返回状态如果不设置 Ring3返回的是失败\n\tpIrp-&gt;IoStatus.Status &#x3D; STATUS_SUCCESS;\n\tpIrp-&gt;IoStatus.Information &#x3D; 0;\n\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\n\treturn STATUS_SUCCESS;\n&#125;\n\n&#x2F;&#x2F; IRP_MJ_CLOSE处理函数\nNTSTATUS IrpCloseProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)\n&#123;\n\tDbgPrint(&quot;DispatchClose ... \\n&quot;);\n\tpIrp-&gt;IoStatus.Status &#x3D; STATUS_SUCCESS;\n\tpIrp-&gt;IoStatus.Information &#x3D; 0;\n\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\n\treturn STATUS_SUCCESS;\n&#125;\n\n&#x2F;&#x2F; IRP_MJ_DEVICE_CONTROL处理函数 用来处理与Ring3交互\nNTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)\n&#123;\n\tNTSTATUS status &#x3D; STATUS_INVALID_DEVICE_REQUEST;\n\tPIO_STACK_LOCATION pIrpStack;\n\tULONG uIoControlCode;\n\tPVOID pIoBuffer;\n\tULONG uInLength;\n\tULONG uOutLength;\n\tULONG uRead;\n\tULONG uWrite;\n\n\t&#x2F;&#x2F; 设置临时变量的值\n\tpIrpStack &#x3D; IoGetCurrentIrpStackLocation(pIrp);\n\t&#x2F;&#x2F; 获取控制码\n\tuIoControlCode &#x3D; pIrpStack-&gt;Parameters.DeviceIoControl.IoControlCode;\n\t&#x2F;&#x2F; 获取缓冲区地址(输入和输出的缓冲区都是一个)\n\tpIoBuffer &#x3D; pIrp-&gt;AssociatedIrp.SystemBuffer;\n\t&#x2F;&#x2F; Ring3 发送数据的长度\n\tuInLength &#x3D; pIrpStack-&gt;Parameters.DeviceIoControl.InputBufferLength;\n\t&#x2F;&#x2F; Ring0 发送数据的长度\n\tuOutLength &#x3D; pIrpStack-&gt;Parameters.DeviceIoControl.OutputBufferLength;\n\n\tswitch(uIoControlCode)\n\t&#123;\n\tcase OPER1:\n\t\t&#123;\n\t\t\tDbgPrint(&quot;IrpDeviceControlProc -&gt; OPER1 ... \\n&quot;);\n\n\t\t\tpIrp-&gt;IoStatus.Information &#x3D; 0;\n\t\t\tstatus &#x3D; STATUS_SUCCESS;\n\t\t\tbreak;\n\t\t&#125;\n\tcase OPER2:\n\t\t&#123;\n\t\t\tDbgPrint(&quot;IrpDeviceControlProc -&gt; OPER2 接收字节数：%d \\n&quot;, uInLength);\n\t\t\tDbgPrint(&quot;IrpDeviceControlProc -&gt; OPER2 输出字节数：%d \\n&quot;, uOutLength);\n\t\t\t&#x2F;&#x2F; Read From Buffer\n\t\t\tmemcpy(&amp;uRead, pIoBuffer, 4);\n\t\t\tDbgPrint(&quot;IrpDeviceControlProc -&gt; OPER2 ... %x \\n&quot;, uRead);\n\t\t\t&#x2F;&#x2F; Write To Buffer\n\t\t\tmemcpy(&amp;pIoBuffer, &amp;uWrite, 4);\n\t\t\t&#x2F;&#x2F; Set Status\n\t\t\tpIrp-&gt;IoStatus.Information &#x3D; 2;\n\t\t\tstatus &#x3D; STATUS_SUCCESS;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 设置返回状态\n\tpIrp-&gt;IoStatus.Status &#x3D; status;\n\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\n\treturn status;\n&#125;\n\n&#x2F;&#x2F; 入口函数 相当于Main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)\n&#123;\n\tNTSTATUS status &#x3D; 0;\n\tULONG    uIndex &#x3D; 0;\n\tPDEVICE_OBJECT pDeviceObj &#x3D; NULL;\n\tUNICODE_STRING Devicename;\n\tUNICODE_STRING SymbolicLinkName;\n\n\tDbgPrint(&quot;驱动程序开始运行了 . \\r\\n&quot;);\n\n\t&#x2F;&#x2F; 创建设备名称\n\tRtlInitUnicodeString(&amp;Devicename, DEVICE_NAME);\n\t\n\t&#x2F;&#x2F; 创建设备\n\tstatus &#x3D; IoCreateDevice(pDriver, 0, &amp;Devicename,\n\t\tFILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDeviceObj);\n\tif(status !&#x3D; STATUS_SUCCESS)\n\t&#123;\n\t\tDbgPrint(&quot;创建设备失败! \\r\\n&quot;);\n\t\treturn status;\n\t&#125;\n\t&#x2F;&#x2F;设置交互数据的方式\n\tpDeviceObj-&gt;Flags |&#x3D; DO_BUFFERED_IO;\n\n\t&#x2F;&#x2F; 创建符号链接名称\n\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME);\n\n\t&#x2F;&#x2F; 创建符号链接\n\tstatus &#x3D; IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);\n\tif(status !&#x3D; STATUS_SUCCESS)\n\t&#123;\n\t\tDbgPrint(&quot;创建符号链接失败! \\r\\n&quot;);\n\t\tIoDeleteDevice(pDeviceObj);\n\t\treturn status;\n\t&#125;\n\n\t&#x2F;&#x2F; 设置分发函数和卸载函数\n\tpDriver-&gt;MajorFunction[IRP_MJ_CREATE] &#x3D; IrpCreateProc;\n\tpDriver-&gt;MajorFunction[IRP_MJ_CLOSE]   &#x3D; IrpCloseProc;\n\tpDriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] &#x3D; IrpDeviceControlProc;\n\tpDriver-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n\n\n&#x2F;&#x2F;R3代码\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;winioctl.h&gt;\n\n#define IN_BUFFER_MAXLENGTH  0x10\t&#x2F;&#x2F;输入缓存最大长度\n#define OUT_BUFFER_MAXLENGTH 0x10\t&#x2F;&#x2F;输出缓存最大长度\n#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#define SYMBOLICLINK_NAME &quot;\\\\\\\\.\\\\MyTestDriver&quot;\n\nHANDLE g_hDevice;\t&#x2F;&#x2F;驱动句柄\n\n&#x2F;***************************************************************************&#x2F;\n&#x2F;&#x2F;打开驱动服务句柄\n&#x2F;&#x2F;打开三环链接名：\\\\\\\\.\\\\Driver\n&#x2F;***************************************************************************&#x2F;\nBOOL Open(PCHAR pLinkName)\n&#123;\n\tTCHAR szBuffer[10] &#x3D; &#123;0&#125;;\n\t&#x2F;&#x2F;在3环获取驱动程序\n\tg_hDevice &#x3D; CreateFile(pLinkName, GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tDWORD err &#x3D; GetLastError();\n\tsprintf(szBuffer, &quot;%d\\n&quot;, err);\n\tif(g_hDevice !&#x3D; INVALID_HANDLE_VALUE)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n&#125;\n\n&#x2F;***************************************************************************&#x2F;\n&#x2F;&#x2F;与驱动通信的函数\n&#x2F;***************************************************************************&#x2F;\nBOOL IoControl(DWORD dwIoCode, PVOID InBuff, DWORD InBuffLen, PVOID OutBuff, DWORD OutBuffLen)\n&#123;\n\tDWORD dw;\n\t&#x2F;&#x2F;驱动句柄&#x2F;操作码&#x2F;输入缓冲区地址&#x2F;输入缓冲区长度&#x2F;输出缓冲区地址&#x2F;输出缓冲区长度&#x2F;返回长度&#x2F;指向OVERLAPPED 此处为NULL\n\tDeviceIoControl(g_hDevice, dwIoCode, InBuff, InBuffLen, OutBuff, OutBuffLen, &amp;dw, NULL);\n\treturn TRUE;\n&#125;\n\n\nint main()\n&#123;\n\tDWORD dwInBuffer &#x3D; 0x11223344;\n\tTCHAR szOutBuffer[OUT_BUFFER_MAXLENGTH] &#x3D; &#123;0&#125;;\n\n\t&#x2F;&#x2F;1. 通过符号链接，打开设备\n\tOpen(SYMBOLICLINK_NAME);\n\t&#x2F;&#x2F;2. 测试通信\n\tIoControl(OPER2, &amp;dwInBuffer, IN_BUFFER_MAXLENGTH, szOutBuffer, OUT_BUFFER_MAXLENGTH);\n\n\tprintf(&quot;%s&quot;, szOutBuffer);\n\t&#x2F;&#x2F;3. 关闭设备\n\tCloseHandle(g_hDevice);\n\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;103527830\nWindows驱动开发学习笔记（五）—— SSDT HOOK\n实验一：通过代码获取SSDT表地址\n#include &lt;ntddk.h&gt;\n#include &lt;ntstatus.h&gt;\n\ntypedef struct _KSYSTEM_SERVICE_TABLE  \n&#123;  \n\tPULONG  ServiceTableBase;\t\t\t\t\t\t\t\t&#x2F;&#x2F; 服务函数地址表基址  \n\tPULONG  ServiceCounterTableBase;\t\t\t\t\t\t&#x2F;&#x2F; SSDT函数被调用的次数\n\tULONG   NumberOfService;\t\t\t\t\t\t\t\t&#x2F;&#x2F; 服务函数的个数  \n\tPULONG   ParamTableBase;\t\t\t\t\t\t\t\t&#x2F;&#x2F; 服务函数参数表基址   \n&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;  \n\ntypedef struct _KSERVICE_TABLE_DESCRIPTOR  \n&#123;  \n\tKSYSTEM_SERVICE_TABLE   ntoskrnl;                       &#x2F;&#x2F; ntoskrnl.exe 的服务函数  \n\tKSYSTEM_SERVICE_TABLE   win32k;                         &#x2F;&#x2F; win32k.sys 的服务函数(GDI32.dll&#x2F;User32.dll 的内核支持)  \n\tKSYSTEM_SERVICE_TABLE   notUsed1;  \n\tKSYSTEM_SERVICE_TABLE   notUsed2;  \n&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\n&#x2F;&#x2F; KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了\nextern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;\n\n&#x2F;&#x2F;卸载函数\nVOID DriverUnload(PDRIVER_OBJECT driver)\n&#123;\n\tDbgPrint(&quot;驱动程序已停止.\\r\\n&quot;);\n&#125;\n\n&#x2F;&#x2F;驱动程序入口函数，相当于控制台的main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)\n&#123;\n\tDbgPrint(&quot;驱动程序已运行.\\r\\n&quot;);\n\t\n\tKdPrint((&quot;--&gt; %x \\n&quot;, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase));\n\n\t&#x2F;&#x2F;设置一个卸载函数  便于退出\n\tDriverObject-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n\n\n\n\n通过页表基址修改页属性\n描述：SSDT所在的物理页是只读的，如果要修改，要先修改页属性为可写\n\n方法1：修改页属性\nif(RCR4 &amp; 0x00000020)\n&#123;&#x2F;&#x2F;说明是2-9-9-12分页\n\tKdPrint((&quot;2-9-9-12分页 %p\\n&quot;,RCR4));\n\tKdPrint((&quot;PTE1 %p\\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));\n\t*(DWORD64*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8)) |&#x3D; 0x02; \n\tKdPrint((&quot;PTE1 %p\\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));\n&#125;\nelse\n&#123;&#x2F;&#x2F;说明是10-10-12分页\n\tKdPrint((&quot;10-10-12分页\\n&quot;));\n\tKdPrint((&quot;PTE1 %p\\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));\n\t*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC)) |&#x3D; 0x02;\n\tKdPrint((&quot;PTE2 %p\\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));\n&#125;\n\n\n方法2：修改CR0寄存器\n描述：CR0寄存器的第16位叫做保护属性位，控制着页的读&#x2F;写属性\nVOID PageProtectOn()\n&#123;\n\t__asm&#123;\n\t\t\tmov  eax,cr0\n\t\t\tor   eax,10000h\t\t\t&#x2F;&#x2F;\n\t\t\tmov  cr0,eax\n\t\t\tsti\n\t&#125;\n&#125;\n\nVOID PageProtectOff()\n&#123;\n\t__asm&#123;\n\t\t\tcli\n\t\t\tmov  eax,cr0\n\t\t\tand  eax,not 10000h\t\t&#x2F;&#x2F;\n\t\t\tmov  cr0,eax\n\t&#125;\n&#125;\n\n\n\n\n\n实验二：SSDT HOOK\n第一步：编译如下代码\n#include &lt;ntddk.h&gt;\n#include &lt;ntstatus.h&gt;\n\nULONG uOldNtOpenProcess;\t\t\t&#x2F;&#x2F;存储原来的NtOpenProcess地址\n\ntypedef NTSTATUS (*NTOPENPROCESS)(\n\tPHANDLE ProcessHandle,\n\tACCESS_MASK DesiredAccess,\n\tPOBJECT_ATTRIBUTES ObjectAttributes,\n\tPCLIENT_ID ClientId);\n\nVOID PageProtectOn()\n&#123;\n\t__asm&#123;&#x2F;&#x2F;开启内存保护\n\t\tmov  eax,cr0\n\t\tor   eax,10000h\n\t\tmov  cr0,eax\n\t\tsti\n\t&#125;\n&#125;\n\nVOID PageProtectOff()\n&#123;\n\t__asm&#123;&#x2F;&#x2F;关闭内存保护\n\t\tcli\n\t\tmov  eax,cr0\n\t\tand  eax,not 10000h\n\t\tmov  cr0,eax\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;1. 找到系统服务表：函数地址表\ntypedef struct _KSYSTEM_SERVICE_TABLE  \n&#123;  \n\tPULONG  ServiceTableBase;\t\t\t&#x2F;&#x2F; 服务函数地址表基址  \n\tPULONG  ServiceCounterTableBase;\t\t&#x2F;&#x2F; SSDT函数被调用的次数\n\tULONG   NumberOfService;\t\t\t&#x2F;&#x2F; 服务函数的个数  \n\tPULONG   ParamTableBase;\t\t\t&#x2F;&#x2F; 服务函数参数表基址   \n&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;  \n\ntypedef struct _KSERVICE_TABLE_DESCRIPTOR  \n&#123;  \n\tKSYSTEM_SERVICE_TABLE   ntoskrnl;\t\t&#x2F;&#x2F; ntoskrnl.exe 的服务函数  \n\tKSYSTEM_SERVICE_TABLE   win32k;\t\t\t&#x2F;&#x2F; win32k.sys 的服务函数(GDI32.dll&#x2F;User32.dll 的内核支持)  \n\tKSYSTEM_SERVICE_TABLE   notUsed1;  \n\tKSYSTEM_SERVICE_TABLE   notUsed2;  \n&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\n&#x2F;&#x2F; KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了\nextern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;\n\n&#x2F;&#x2F;2. 准备用于替换的函数\nNTSTATUS MyNtOpenProcess(\n\tPHANDLE ProcessHandle,\n\tACCESS_MASK DesiredAccess,\n\tPOBJECT_ATTRIBUTES ObjectAttributes,\n\tPCLIENT_ID ClientId\n)&#123;\n\t&#x2F;&#x2F;自己的业务..各种过滤，或者修改返回结构\n\n\tNTSTATUS status;\n\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tKdPrint((&quot;%x %x %x %x \\n&quot;, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId));\n\n\treturn ((NTOPENPROCESS)uOldNtOpenProcess)(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);\n&#125;\n\n&#x2F;&#x2F;3. Hook\nNTSTATUS HookNtOpenPRocess()\n&#123;\n\tNTSTATUS status;\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tPageProtectOff();\n\n\tuOldNtOpenProcess &#x3D; KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7A];\n\n\tKeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7A] &#x3D; (ULONG)MyNtOpenProcess;\n\n\tPageProtectOn();\n\n\treturn status;\n&#125;\n\n&#x2F;&#x2F;4. 恢复\nNTSTATUS UnHookNtOpenPRocess()\n&#123;\n\tNTSTATUS status;\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tPageProtectOff();\n\n\tKeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7A] &#x3D; (ULONG)uOldNtOpenProcess;\n\n\tPageProtectOn();\n\n\treturn status;\n&#125;\n\n&#x2F;&#x2F;卸载函数\nVOID DriverUnload(PDRIVER_OBJECT driver)\n&#123;\n\tUnHookNtOpenPRocess();\n\n\tDbgPrint(&quot;驱动程序已停止.\\r\\n&quot;);\n&#125;\n\n&#x2F;&#x2F;驱动程序入口函数，相当于控制台的main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)\n&#123;\n\tDbgPrint(&quot;驱动程序已运行.\\r\\n&quot;);\n\n\tHookNtOpenPRocess();\n\n\t&#x2F;&#x2F;设置一个卸载函数  便于退出\n\tDriverObject-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n\n\n\n\n\nWindows驱动开发学习笔记（六）—— Inline HOOK\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;103557383\nSSDT HOOK 缺点：\n容易发现，容易绕过\n只能HOOK系统服务表里的函数\n\nInline Hook：\nJMP的偏移 &#x3D; 跳转地址 - 补丁地址&amp;[0xE9] - 5\n\n实验一：3环 Inline Hook\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nBYTE* ProcAddr &#x3D; 0;\t\t\t&#x2F;&#x2F;原函数地址\nDWORD OldProtect &#x3D; 0;\t\t&#x2F;&#x2F;保存旧的内存保护\nBYTE  OldCmd[20] &#x3D; &#123;0&#125;;\t\t&#x2F;&#x2F;存储原函数头部原始指令 在最后面构造返回到原函数的指令\n\nBYTE* HookProcAddr  &#x3D; 0;\t&#x2F;&#x2F;钩子函数的地址\n\n&#x2F;&#x2F;函数指针 将数据作为指令执行\ntypedef void (*POLDCMD)();\nPOLDCMD pOldCmd &#x3D; (POLDCMD)(char*)OldCmd;\n&#x2F;&#x2F;printf的格式\nchar *format &#x3D; &quot;%x&quot;;\n\n\nDWORD add(DWORD a, DWORD b)\n&#123;\n\treturn a + b;\n&#125;\n\nvoid __declspec(naked) HookProc()\n&#123;\n\t&#x2F;&#x2F;保存现场\n\t__asm\n\t&#123;\n\t\tpushad\n\t\tpushfd\n\t&#125;\n\n\t&#x2F;&#x2F;获得参数1\n\tprintf(&quot;a &#x3D; &quot;);\n\n\t__asm\n\t&#123;\n\t\tmov eax, esp\n\t\tadd eax, 40\n\n\t\tpush [eax]\n\t\tpush format\n\t\tcall printf\n\t\tadd esp, 8\n\t&#125;\n\n\t&#x2F;&#x2F;获得参数2\n\tprintf(&quot;\\nb &#x3D; &quot;);\n\n\t__asm\n\t&#123;\n\t\tmov eax, esp\n\t\tadd eax, 44\n\n\t\tpush [eax]\n\t\tpush format\n\t\tcall printf\n\t\tadd esp, 8\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\t&#x2F;&#x2F;还原现场\n\t__asm\n\t&#123;\n\n\t\tpopfd\n\t\tpopad\n\t\t\n\t\t&#x2F;&#x2F;执行原函数头部指令 并返回到原函数下一行继续执行\n\t\tjmp pOldCmd\n\t&#125;\n&#125;\n\nvoid InlineHook()\n&#123;\n\t&#x2F;&#x2F;获得需要挂钩的函数地址???????????????\n\tProcAddr  &#x3D;   (BYTE*)add + 1;\n\tProcAddr +&#x3D; *(DWORD*)ProcAddr + 4;\n\t&#x2F;&#x2F;修改内存保护\n\tVirtualProtect(ProcAddr, 6, PAGE_EXECUTE_READWRITE, &amp;OldProtect);\n\t&#x2F;&#x2F;将被覆盖的指令复制到数组中\n\tstrncpy((char*)OldCmd, (char*)ProcAddr, 6);\n\t&#x2F;&#x2F;数组末尾添上跳转指令 用于返回到被挂钩的函数\n\tOldCmd[6] &#x3D; 0xE9;\n\t*(DWORD*)&amp;OldCmd[7] &#x3D; (DWORD)(ProcAddr+6) - (DWORD)&amp;OldCmd[6] - 5;\n\n\t&#x2F;&#x2F;获得钩子函数的地址???????????\n\tHookProcAddr &#x3D; (BYTE*)HookProc + 1;\n\tHookProcAddr +&#x3D; *(DWORD*)HookProcAddr + 4;\n\t&#x2F;&#x2F;修改原函数的头部 跳转到钩子函数\n\tProcAddr[0] &#x3D; 0xE9;\n\t*(DWORD*)&amp;ProcAddr[1] &#x3D; HookProcAddr - ProcAddr - 5;\n\t&#x2F;&#x2F;跳转指令只占五个字节 原函数头部三行指令占六个字节 因此将多余字节填充为nop: 0x90\n\tProcAddr[5] &#x3D; 0x90;\n\n&#125;\n\nvoid UnInlineHook()\n&#123;\n\t&#x2F;&#x2F;判断函数是否被挂钩\n\tif(ProcAddr[0] &#x3D;&#x3D; 0xE9)\n\t&#123;\n\t\tstrncpy((char*)ProcAddr, (char*)OldCmd, 6);\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tDWORD sum;\n\n\t&#x2F;&#x2F;挂钩：打印1 2\n\tInlineHook();\n\n\tsum &#x3D; add(1, 2);\n\tprintf(&quot;sum &#x3D; %x\\n&quot;, sum);&#x2F;&#x2F;3\n\n\t&#x2F;&#x2F;脱钩：不打印\n\tUnInlineHook();\n\n\tsum &#x3D; add(3, 4);\n\tprintf(&quot;sum &#x3D; %x\\n&quot;, sum);&#x2F;&#x2F;7\n\n\treturn 0;\n&#125;\n\n\n\n\n\n实验二：0环 Inline Hook\n#include &lt;ntddk.h&gt;\n#include &lt;ntstatus.h&gt;\n\nPUCHAR pNtOpenProcess;\nUCHAR  OldCmd[20] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;函数指针 用于将数据作为指令执行\ntypedef VOID (*POLDCMD)();\nPOLDCMD pOldCmd &#x3D; (POLDCMD)(PUCHAR)OldCmd;\n\nPCHAR format &#x3D; &quot;%x %x %x %x \\r\\n&quot;;\n\ntypedef NTSTATUS (*NTOPENPROCESS)(\n\tPHANDLE ProcessHandle,\n\tACCESS_MASK DesiredAccess,\n\tPOBJECT_ATTRIBUTES ObjectAttributes,\n\tPCLIENT_ID ClientId);\n\ntypedef struct _KSYSTEM_SERVICE_TABLE  \n&#123;  \n\tPULONG  ServiceTableBase;\t\t\t&#x2F;&#x2F; 服务函数地址表基址  \n\tPULONG  ServiceCounterTableBase;\t&#x2F;&#x2F; SSDT函数被调用的次数\n\tULONG   NumberOfService;\t\t\t&#x2F;&#x2F; 服务函数的个数  \n\tPULONG   ParamTableBase;\t\t\t&#x2F;&#x2F; 服务函数参数表基址   \n&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;  \n\ntypedef struct _KSERVICE_TABLE_DESCRIPTOR  \n&#123;  \n\tKSYSTEM_SERVICE_TABLE   ntoskrnl;\t\t&#x2F;&#x2F; ntoskrnl.exe 的服务函数  \n\tKSYSTEM_SERVICE_TABLE   win32k;\t\t\t&#x2F;&#x2F; win32k.sys 的服务函数(GDI32.dll&#x2F;User32.dll 的内核支持)  \n\tKSYSTEM_SERVICE_TABLE   notUsed1;  \n\tKSYSTEM_SERVICE_TABLE   notUsed2;  \n&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\n&#x2F;&#x2F; KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了\nextern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;\n\nVOID PageProtectOn()\n&#123;\n\t__asm&#123;&#x2F;&#x2F;开启内存保护\n\t\tmov  eax,cr0\n\t\tor   eax,10000h\n\t\tmov  cr0,eax\n\t\tsti\n\t&#125;\n&#125;\n\nVOID PageProtectOff()\t\t\t\t\n&#123;\n\t__asm&#123;&#x2F;&#x2F;关闭内存保护\n\t\tcli\t\t\t\t\t\n\t\tmov  eax,cr0\n\t\tand  eax,not 10000h\n\t\tmov  cr0,eax\n\t&#125;\n&#125;\n\nVOID __declspec(naked) HookProc()&#123;\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;保存现场\n\t\tpushad\n\t\tpushfd\n\t\n\t\tmov eax, esp\n\t\tadd eax, 40\t\t&#x2F;&#x2F;eflags + 8个通用寄存器 + 返回地址 4B*10\n\t\tadd eax, 12\t\t&#x2F;&#x2F;定位到最后一个参数\n\t\tpush [eax]\t\t&#x2F;&#x2F;ClientId\n\t\tpush [eax-0x4]\t&#x2F;&#x2F;ObjectAttributes\n\t\tpush [eax-0x8]\t&#x2F;&#x2F;DesiredAccess\n\t\tpush [eax-0xC]\t&#x2F;&#x2F;ProcessHandle\n\t\tpush format\n\t\tcall DbgPrint\n\t\tadd esp, 20\n\n\t\t&#x2F;&#x2F;还原现场\n\t\tpopfd\n\t\tpopad\n\n\t\t&#x2F;&#x2F;[HookProc-&gt;OldCmd]调用原本的指令，然后返回到原函数\n\t\tjmp pOldCmd\n\t&#125;\n&#125;\n\nNTSTATUS InlineHook()\n&#123;\n\tNTSTATUS status;\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tPageProtectOff();\n\n\t&#x2F;&#x2F;保存原来的指令[OldCmd]\t\n\tpNtOpenProcess &#x3D; (PUCHAR)KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7A];\n\tRtlMoveMemory(OldCmd, pNtOpenProcess, 5);\n\n\t&#x2F;&#x2F;[后面续上]构造回去的指令，用于返回到原函数\n\tOldCmd[5] &#x3D; 0xE9;\n\t*(PULONG)&amp;OldCmd[6] &#x3D; ((ULONG)pNtOpenProcess+5) - (ULONG)&amp;OldCmd[5] - 5;\n\n\t&#x2F;&#x2F;[NT-&gt;HookProc]内核函数不存在中间人（call后通过jmp跳转），函数地址为实际地址\n\tpNtOpenProcess[0] &#x3D; 0xE9;\n\t*(PULONG)&amp;pNtOpenProcess[1] &#x3D; (ULONG)HookProc - (ULONG)pNtOpenProcess - 5;\n\n\tPageProtectOn();\n\n\treturn status;\n&#125;\n\nNTSTATUS UnInlineHook()\n&#123;\n\tNTSTATUS status;\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tif(pNtOpenProcess[0] &#x3D;&#x3D; 0xE9)\n\t&#123;\n\t\tPageProtectOff();\n\t\tRtlMoveMemory(pNtOpenProcess, OldCmd, 5);&#x2F;&#x2F;内核中的memcpy！\n\t\tPageProtectOn();\n\t&#125;\n\n\treturn status;\n&#125;\n\n&#x2F;&#x2F;卸载函数\nVOID DriverUnload(PDRIVER_OBJECT driver)\n&#123;\n\t&#x2F;&#x2F;卸载驱动时脱钩\n\tUnInlineHook();\n\n\tDbgPrint(&quot;驱动程序已停止.\\r\\n&quot;);\n&#125;\n\n&#x2F;&#x2F;驱动程序入口函数，相当于控制台的main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)\n&#123;\n\tDbgPrint(&quot;驱动程序已运行.\\r\\n&quot;);\n\t&#x2F;&#x2F;运行驱动时挂钩\n\tInlineHook();\n\n\t&#x2F;&#x2F;设置一个卸载函数  便于退出\n\tDriverObject-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n【正确的临界区】\n全局变量：\nFlag &#x3D; 0;\n\n进入临界区：\nLab：\n\tmov eax,1\n\t&#x2F;&#x2F;多核情况下必须加lock\n\tlock xadd [Flag],eax\n\tcmp eax,0\n\tjz endLab\n\tdec [Flag]\n\t&#x2F;&#x2F;线程等待Sleep..\n\tjmp Lab\nendLab:\n\tret\n\n离开临界区：\nlock dec [Flag]\n\n通过代码实现内核重载。。。\n步骤：\n\n申请内存，按内存对齐展开\n根据重定位表修复全局变量\n修复IAT表(修复导入表的说法不准确)\n山寨系统服务表\n狸猫换太子（Hook KiFastCallEntry）\n\n\n\n笔记-进程监控项目分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n【APC】\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n\n","text":"一、【保护模式】 段寄存器有96位，但我们只能看见16位，那如果证明Attribute、Base、Limit的存在呢？ 2、探测Attribute int var &#x3D; 0; __asm &#123; mov ax,ss &#x2F;&#x2F;cs不行 cs是可读 可执...","link":"","photos":[],"count_time":{"symbolsCount":"68k","symbolsTime":"1:02"},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"}],"toc":"","author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《恶意代码分析实战》实验","uid":"ff3b385e81d2e459aa67c54453b93307","slug":"《恶意代码分析实战》实验","date":"2020-11-26T16:25:37.000Z","updated":"2022-08-22T07:46:57.462Z","comments":true,"path":"api/articles/《恶意代码分析实战》实验.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/480_296_0/t0128e904ff207c846b.jpg","text":"1https://down.52pojie.cn/Tools/ 1-1： https://www.virustotal.com/gui/ https://www.virscan.org/ pe.jpg PEiD PEtools 1-2: 脱壳机FUPX—改源文件 sysinter...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"},{"name":"反汇编","slug":"反汇编","count":1,"path":"api/tags/反汇编.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Win32","uid":"02fb78d957647a82a5e9777a15428562","slug":"Win32","date":"2020-08-20T05:41:47.000Z","updated":"2022-08-22T08:01:23.487Z","comments":true,"path":"api/articles/Win32.json","keywords":null,"cover":"http://p6.qhimg.com/bdm/960_593_0/t011cb371b497218f8d.jpg","text":"Win32&#x2F;* 对于字符串，ASCII 中使用 char 来定义，而 Unicode 中使用 wchar_t 来定义，并且需要添加前缀L。 那么在 windows.h 头文件中（或者是它包含的其他头文件）就这样来处理： #ifdef UNICODE typedef wc...","link":"","photos":[],"count_time":{"symbolsCount":"75k","symbolsTime":"1:08"},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}