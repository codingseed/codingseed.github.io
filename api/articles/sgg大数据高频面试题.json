{"title":"sgg大数据高频面试题","uid":"128485c0403ac0ca82c74aaa720458ad","slug":"sgg大数据高频面试题","date":"2021-12-26T12:18:53.000Z","updated":"2022-08-22T07:56:11.565Z","comments":true,"path":"api/articles/sgg大数据高频面试题.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/480_296_0/t015eb817c1c36a6fc1.jpg","content":"<p>尚硅谷大数据技术之高频面试题</p>\n<p>（作者：尚硅谷大数据研发部）</p>\n<p>版本：V8.0.15</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h1 id=\"项目涉及技术\"><a href=\"#项目涉及技术\" class=\"headerlink\" title=\"项目涉及技术\"></a>项目涉及技术</h1><h2 id=\"1-1-Linux-amp-Shell\"><a href=\"#1-1-Linux-amp-Shell\" class=\"headerlink\" title=\"1.1 Linux&amp;Shell\"></a>1.1 Linux&amp;Shell</h2><h3 id=\"1-1-1-Linux常用高级命令\"><a href=\"#1-1-1-Linux常用高级命令\" class=\"headerlink\" title=\"1.1.1 Linux常用高级命令\"></a>1.1.1 Linux常用高级命令</h3><hr>\n<p>  序号   命令                            命令解释<br>  1      top                             查看内存<br>  2      df -h                           查看磁盘存储情况<br>  3      iotop                           查看磁盘IO读写(yum install iotop安装）<br>  4      iotop -o                        直接查看比较高的磁盘读写程序<br>  5      netstat -tunlp | grep 端口号   查看端口占用情况<br>  6      uptime                          查看报告系统运行时长及平均负载<br>  7      ps -ef                          查看进程</p>\n<hr>\n<h3 id=\"1-1-2-Shell常用工具及写过的脚本\"><a href=\"#1-1-2-Shell常用工具及写过的脚本\" class=\"headerlink\" title=\"1.1.2 Shell常用工具及写过的脚本\"></a>1.1.2 Shell常用工具及写过的脚本</h3><p>1）awk、sed、cut、sort</p>\n<p>2）用Shell写过哪些脚本</p>\n<p>（1）集群启动，分发脚本</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>#!&#x2F;bin&#x2F;bash</p>\n<p>case $1 in</p>\n<p>“start”)</p>\n<p>for i in hadoop102 hadoop103 hadoop104</p>\n<p>do</p>\n<p>ssh $i “绝对路径”</p>\n<p>done</p>\n<p>;;</p>\n<p>“stop”)</p>\n<p>;;</p>\n<p>esac</p></blockquote>\n<p>（2）数仓与MySQL的导入导出</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>MySQL HDFS hive</p>\n<p>sqoop （4个map）</p>\n<p>除了sqoop之外还可以用：DataX、hadoop、java</p>\n<p>驱动</p>\n<p>主机名 端口号</p>\n<p>用户名</p>\n<p>密码</p>\n<p>路径</p>\n<p>删除</p>\n<p>同步策略： 全量 特殊 新增 新增和变化</p>\n<p>query “select id , name from user where 创建时间&#x3D;今天 or 操作时间&#x3D;<br>今天”</p>\n<p>压缩</p>\n<p>列式存储</p></blockquote>\n<p>（3）数仓层级内部的导入：ods-&gt;dwd-&gt;dws-&gt;dwt-&gt;ads</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>①#!&#x2F;bin&#x2F;bash</p>\n<p>②定义变量 APP&#x3D;gmall</p>\n<p>③获取时间</p>\n<p>传入 按照传入时间</p>\n<p>不传 T+1</p>\n<p>④sql&#x3D;”</p>\n<p>先按照当前天 写sql &#x3D;&gt; 遇到时间 $do_date 遇到表 {$APP}.</p>\n<p>自定义函数 UDF UDTF {$APP}.</p>\n<p>“</p>\n<p>⑤执行sql</p></blockquote>\n<h3 id=\"1-1-3-Shell中提交了一个脚本，进程号已经不知道了，但是需要kill掉这个进程，怎么操作\"><a href=\"#1-1-3-Shell中提交了一个脚本，进程号已经不知道了，但是需要kill掉这个进程，怎么操作\" class=\"headerlink\" title=\"1.1.3 Shell中提交了一个脚本，进程号已经不知道了，但是需要kill掉这个进程，怎么操作?\"></a>1.1.3 Shell中提交了一个脚本，进程号已经不知道了，但是需要kill掉这个进程，怎么操作?</h3><p>ssh $i “ps -ef | grep file-flume-kafka | grep -v grep |awk ‘{print<br>$2}’ | <strong>xargs</strong> kill”</p>\n<h3 id=\"1-1-4-Shell中单引号和双引号区别\"><a href=\"#1-1-4-Shell中单引号和双引号区别\" class=\"headerlink\" title=\"1.1.4 Shell中单引号和双引号区别\"></a>1.1.4 Shell中单引号和双引号区别</h3><p>1）在&#x2F;home&#x2F;atguigu&#x2F;bin创建一个test.sh文件</p>\n<p>[atguigu@hadoop102 bin]$ vim test.sh</p>\n<p>在文件中添加如下内容</p>\n<p>#!&#x2F;bin&#x2F;bash</p>\n<p>do_date&#x3D;$1</p>\n<p>echo ‘$do_date’</p>\n<p>echo “$do_date”</p>\n<p>echo “‘$do_date’”</p>\n<p>echo ‘“$do_date”‘</p>\n<p>echo <code>date</code></p>\n<p>2）查看执行结果</p>\n<p>[atguigu@hadoop102 bin]$ test.sh 2019-02-10</p>\n<p>$do_date</p>\n<p>2019-02-10</p>\n<p>‘2019-02-10’</p>\n<p>“$do_date”</p>\n<p>2019年 05月 02日 星期四 21:02:08 CST</p>\n<p>3）总结：</p>\n<p>（1）单引号不取变量值</p>\n<p>（2）双引号取变量值</p>\n<p>（3）反引号&#96;，执行引号中命令</p>\n<p>（4）双引号内部嵌套单引号，取出变量值</p>\n<p>（5）单引号内部嵌套双引号，不取出变量值</p>\n<h2 id=\"1-2-Hadoop\"><a href=\"#1-2-Hadoop\" class=\"headerlink\" title=\"1.2 Hadoop\"></a>1.2 Hadoop</h2><h3 id=\"1-2-1-Hadoop常用端口号\"><a href=\"#1-2-1-Hadoop常用端口号\" class=\"headerlink\" title=\"1.2.1 Hadoop常用端口号\"></a>1.2.1 Hadoop常用端口号</h3><hr>\n<pre><code>                   hadoop2.x   Hadoop3.x\n</code></pre>\n<p>  访问HDFS端口         50070       9870<br>  访问MR执行情况端口   8088        8088<br>  历史服务器           19888       19888<br>  客户端访问集群端口   9000        8020</p>\n<hr>\n<h3 id=\"1-2-2-Hadoop配置文件\"><a href=\"#1-2-2-Hadoop配置文件\" class=\"headerlink\" title=\"1.2.2 Hadoop配置文件\"></a>1.2.2 Hadoop配置文件</h3><p>配置文件：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>hadoop2.x core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml<br>slaves</p>\n<p>hadoop3.x core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml<br>workers</p></blockquote>\n<h3 id=\"1-2-3-HDFS读流程和写流程\"><a href=\"#1-2-3-HDFS读流程和写流程\" class=\"headerlink\" title=\"1.2.3 HDFS读流程和写流程\"></a>1.2.3 HDFS读流程和写流程</h3><h3 id=\"1-2-4-HDFS小文件处理\"><a href=\"#1-2-4-HDFS小文件处理\" class=\"headerlink\" title=\"1.2.4 HDFS小文件处理\"></a>1.2.4 HDFS小文件处理</h3><p>1）会有什么影响</p>\n<p>（1）存储层面：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1个文件块，占用namenode多大内存150字节</p>\n<p>128G能存储多少文件块？ 128 g* 1024m<em>1024kb</em>1024byte&#x2F;150字节 &#x3D;<br>9.1亿文件块</p></blockquote>\n<p>（2）计算层面：</p>\n<p>每个小文件都会起到一个MapTask，1个MapTask默认内存1G。浪费资源。</p>\n<p>2）怎么解决</p>\n<p>（1）采用har归档方式，将小文件归档</p>\n<p>（2）采用CombineTextInputFormat</p>\n<p>（3）有小文件场景开启JVM重用；如果没有小文件，不要开启JVM重用，因为会一直占用使用到的task卡槽，直到任务完成才释放。</p>\n<p>JVM重用可以使得JVM实例在同一个job中重新使用N次，N的值可以在Hadoop的mapred-site.xml文件中进行配置。通常在10-20之间</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><property>\n\n<p><name>mapreduce.job.jvm.numtasks</name></p>\n<p><value>10</value></p>\n<p><description>How many tasks to run per jvm,if set to -1 ,there is no<br>limit</description></p>\n</property></blockquote>\n<h3 id=\"1-2-5-HDFS的NameNode内存\"><a href=\"#1-2-5-HDFS的NameNode内存\" class=\"headerlink\" title=\"1.2.5 HDFS的NameNode内存\"></a>1.2.5 HDFS的NameNode内存</h3><p>1）Hadoop2.x系列，配置NameNode默认2000m</p>\n<p>2）Hadoop3.x系列，配置NameNode内存是动态分配的</p>\n<p>NameNode内存最小值1G，每增加100万个block，增加1G内存。</p>\n<h3 id=\"1-2-6-NameNode心跳并发配置\"><a href=\"#1-2-6-NameNode心跳并发配置\" class=\"headerlink\" title=\"1.2.6 NameNode心跳并发配置\"></a>1.2.6 NameNode心跳并发配置</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image4.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”1.8868055555555556in”}</p>\n<p>企业经验：dfs.namenode.handler.count&#x3D;$20 times log_{e}^{text{Cluster Size}}$，比如集群规模（DataNode台数）为3台时，此参数设置为21。可通过简单的python代码计算该值，代码如下。</p>\n<h3 id=\"1-2-7-纠删码原理\"><a href=\"#1-2-7-纠删码原理\" class=\"headerlink\" title=\"1.2.7 纠删码原理\"></a>1.2.7 纠删码原理</h3><p>CPU资源换取存储空间。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image5.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.535416666666667in”}</p>\n<h3 id=\"1-2-8-异构存储（冷热数据分离）\"><a href=\"#1-2-8-异构存储（冷热数据分离）\" class=\"headerlink\" title=\"1.2.8 异构存储（冷热数据分离）\"></a>1.2.8 异构存储（冷热数据分离）</h3><p>期望经常使用的数据存储在固态硬盘或者内存镜像硬盘；不经常使用的历史数据存储在老旧的破旧硬盘。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image6.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”1.6479166666666667in”}</p>\n<h3 id=\"1-2-9-Shuffle及优化\"><a href=\"#1-2-9-Shuffle及优化\" class=\"headerlink\" title=\"1.2.9 Shuffle及优化\"></a>1.2.9 Shuffle及优化</h3><p><strong>1、Shuffle过程</strong></p>\n<h3 id=\"1-2-10-Yarn工作机制\"><a href=\"#1-2-10-Yarn工作机制\" class=\"headerlink\" title=\"1.2.10 Yarn工作机制\"></a>1.2.10 Yarn工作机制</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image10.png\"></p>\n<h3 id=\"1-2-11-Yarn调度器\"><a href=\"#1-2-11-Yarn调度器\" class=\"headerlink\" title=\"1.2.11 Yarn调度器\"></a>1.2.11 Yarn调度器</h3><p>1）Hadoop调度器重要分为三类：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>FIFO 、Capacity Scheduler（容量调度器）和Fair Sceduler（公平调度器）。</p>\n<p>Apache默认的资源调度器是容量调度器；</p>\n<p>CDH默认的资源调度器是公平调度器。</p></blockquote>\n<p>2）区别：</p>\n<p><strong>FIFO调度器：</strong>支持单队列 、先进先出 生产环境不会用。</p>\n<p><strong>容量调度器：</strong>支持多队列。队列资源分配，优先选择资源占用率最低的队列分配资源；作业资源分配，按照作业的优先级和提交时间顺序分配资源；容器资源分配，本地原则（同一节点&#x2F;同一机架&#x2F;不同节点不同机架）</p>\n<p><strong>公平调度器：</strong>支持多队列，保证每个任务公平享有队列资源。资源不够时可以按照缺额分配。</p>\n<p>3）在生产环境下怎么选择？</p>\n<p>大厂：如果对并发度要求比较高，选择公平，要求服务器性能必须OK；</p>\n<p>中小公司，集群服务器资源不太充裕选择容量。</p>\n<p>4）在生产环境怎么创建队列？</p>\n<p>（1）调度器默认就1个default队列，不能满足生产要求。</p>\n<p>（2）按照框架：hive &#x2F;spark&#x2F; flink<br>每个框架的任务放入指定的队列（企业用的不是特别多）</p>\n<p>（3）按照部门：业务部门1、业务部门2</p>\n<p>（4）按照业务模块：登录注册、购物车、下单</p>\n<p>5）创建多队列的好处？</p>\n<p>（1）因为担心员工不小心，写递归死循环代码，把所有资源全部耗尽。</p>\n<p>（2）实现任务的<strong>降级</strong>使用，特殊时期保证重要的任务队列资源充足。</p>\n<p>业务部门1（重要）&#x3D;》业务部门2（比较重要）&#x3D;》下单（一般）&#x3D;》购物车（一般）&#x3D;》登录注册（次要）</p>\n<h3 id=\"1-2-12-项目经验之基准测试\"><a href=\"#1-2-12-项目经验之基准测试\" class=\"headerlink\" title=\"1.2.12 项目经验之基准测试\"></a>1.2.12 项目经验之基准测试</h3><p><strong>硬盘的读写速度</strong>和<strong>网络带宽</strong>影响<strong>集群吞吐量</strong>的两个核心因素。</p>\n<h3 id=\"1-2-13-Hadoop宕机\"><a href=\"#1-2-13-Hadoop宕机\" class=\"headerlink\" title=\"1.2.13 Hadoop宕机\"></a>1.2.13 Hadoop宕机</h3><p>1）如果MR造成系统宕机。此时要控制Yarn同时运行的任务数，和每个任务申请的最大内存。调整参数：yarn.scheduler.maximum-allocation-mb（单个任务可申请的最多物理内存量，默认是8192MB）</p>\n<p>2）如果写入文件过快造成NameNode宕机。那么调高Kafka的存储大小，控制从Kafka到HDFS的写入速度。例如，可以调整Flume每批次拉取数据量的大小参数batchsize。</p>\n<h3 id=\"1-2-14-Hadoop解决数据倾斜方法\"><a href=\"#1-2-14-Hadoop解决数据倾斜方法\" class=\"headerlink\" title=\"1.2.14 Hadoop解决数据倾斜方法\"></a>1.2.14 Hadoop解决数据倾斜方法</h3><p><strong>1）提前在map进行combine，减少传输的数据量</strong></p>\n<p>在Mapper加上combiner相当于提前进行reduce，即把一个Mapper中的相同key进行了聚合，减少shuffle过程中传输的数据量，以及Reducer端的计算量。</p>\n<p>如果导致数据倾斜的key大量分布在不同的mapper的时候，这种方法就不是很有效了。</p>\n<p><strong>2）导致数据倾斜的key 大量分布在不同的mapper</strong></p>\n<p>（1）局部聚合加全局聚合。</p>\n<p>第一次在map阶段对那些导致了数据倾斜的key<br>加上1到n的随机前缀，这样本来相同的key<br>也会被分到多个Reducer中进行局部聚合，数量就会大大降低。</p>\n<p>第二次mapreduce，去掉key的随机前缀，进行全局聚合。</p>\n<p>思想：二次mr，第一次将key随机散列到不同reducer进行处理达到负载均衡目的。第二次再根据去掉key的随机前缀，按原key进行reduce处理。</p>\n<p>这个方法进行两次mapreduce，性能稍差。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>（2）增加Reducer，提升并行度<br>JobConf.setNumReduceTasks(int)</p>\n<p>（3）实现自定义分区</p>\n<p>根据数据分布情况，自定义散列函数，将key均匀分配到不同Reducer</p></blockquote>\n<h2 id=\"1-3-Zookeeper\"><a href=\"#1-3-Zookeeper\" class=\"headerlink\" title=\"1.3 Zookeeper\"></a>1.3 Zookeeper</h2><h3 id=\"1-3-1-常用命令\"><a href=\"#1-3-1-常用命令\" class=\"headerlink\" title=\"1.3.1 常用命令\"></a>1.3.1 常用命令</h3><p>ls、get、create、delete</p>\n<h3 id=\"1-3-2-Paxos算法和ZAB协议（扩展）\"><a href=\"#1-3-2-Paxos算法和ZAB协议（扩展）\" class=\"headerlink\" title=\"1.3.2 Paxos算法和ZAB协议（扩展）\"></a>1.3.2 Paxos算法和ZAB协议（扩展）</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：暂时先不用看。如果后期准备面今日头条，需要认真准备，其他公司几乎都不问。</p>\n<p>关注尚硅谷教育公众号回复大数据。 找zookeeper视频。</p></blockquote>\n<h3 id=\"1-3-3-讲一讲什么是CAP法则？Zookeeper符合了这个法则的哪两个？（扩展）\"><a href=\"#1-3-3-讲一讲什么是CAP法则？Zookeeper符合了这个法则的哪两个？（扩展）\" class=\"headerlink\" title=\"1.3.3 讲一讲什么是CAP法则？Zookeeper符合了这个法则的哪两个？（扩展）\"></a>1.3.3 讲一讲什么是CAP法则？Zookeeper符合了这个法则的哪两个？（扩展）</h3><h3 id=\"1-3-4-选举机制\"><a href=\"#1-3-4-选举机制\" class=\"headerlink\" title=\"1.3.4 选举机制\"></a>1.3.4 选举机制</h3><p>半数机制：2n+1，安装奇数台</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>10台服务器：3台</p>\n<p>20台服务器：5台</p>\n<p>100台服务器：11台</p>\n<p>台数多，好处：提高可靠性；坏处：影响通信延时</p></blockquote>\n<h3 id=\"1-3-5-Follower和Leader状态同步\"><a href=\"#1-3-5-Follower和Leader状态同步\" class=\"headerlink\" title=\"1.3.5 Follower和Leader状态同步\"></a>1.3.5 Follower和Leader状态同步</h3><h2 id=\"1-4-Flume\"><a href=\"#1-4-Flume\" class=\"headerlink\" title=\"1.4 Flume\"></a>1.4 Flume</h2><h3 id=\"1-4-1-Flume组成，Put事务，Take事务\"><a href=\"#1-4-1-Flume组成，Put事务，Take事务\" class=\"headerlink\" title=\"1.4.1 Flume组成，Put事务，Take事务\"></a>1.4.1 Flume组成，Put事务，Take事务</h3><p>1）taildir source</p>\n<p>（1）断点续传、多目录</p>\n<p>（2）哪个Flume版本产生的？Apache1.7、CDH1.6</p>\n<p>（3）没有断点续传功能时怎么做的？ 自定义</p>\n<p>（4）taildir挂了怎么办？</p>\n<p>不会丢数：断点续传</p>\n<p>重复数据：</p>\n<p>（5）怎么处理重复数据？</p>\n<p>不处理：生产环境通常不处理，出现重复的概率比较低。处理会影响传输效率。</p>\n<p>处理</p>\n<p>自身：在taildirsource里面增加自定义事务，影响效率</p>\n<p>找兄弟：下一级处理（hive dwd sparkstreaming<br>flink布隆）、去重手段（groupby、开窗取窗口第一条、redis）</p>\n<p>（6）taildir source 是否支持递归遍历文件夹读取文件？</p>\n<p>不支持。 自定义 递归遍历文件夹 + 读取文件</p>\n<p>2）file channel &#x2F;memory channel&#x2F;kafka channel</p>\n<p>（1）File Channel</p>\n<p>数据存储于磁盘，优势：可靠性高；劣势：传输速度低</p>\n<p>默认容量：100万event</p>\n<p>注意：FileChannel可以通过配置dataDirs指向多个路径，每个路径对应不同的硬盘，增大Flume吞吐量。</p>\n<p>（2）Memory Channel</p>\n<p>数据存储于内存，优势：传输速度快；劣势：可靠性差</p>\n<p>默认容量：100个event</p>\n<p>（3）Kafka Channel</p>\n<p>数据存储于Kafka，基于磁盘；</p>\n<p>优势：可靠性高；</p>\n<p>传输速度快 Kafka Channel 大于Memory Channel + Kafka Sink<br>原因省去了Sink阶段</p>\n<p>（4）Kafka Channel哪个版本产生的？</p>\n<p>Flume1.6 版本产生&#x3D;》并没有火；因为有bug</p>\n<p>event(header body ) ture 和false<br>控制是否包含header信息，很遗憾，都不起作用。增加了额外清洗的工作量。</p>\n<p>Flume1.7解决了这个问题，开始火了。</p>\n<p>（5）生产环境如何选择</p>\n<p>如果下一级是Kafka，优先选择Kafka Channel</p>\n<p>如果是金融、对钱要求准确的公司，选择File Channel</p>\n<p>如果就是普通的日志，通常可以选择Memory Channel</p>\n<p>每天丢几百万数据 pb级 亿万富翁，掉1块钱会捡？</p>\n<p>3）HDFS sink</p>\n<p>（1）时间（半个小时） or 大小128m、event个数（0禁止）</p>\n<p>具体参数：hdfs.rollInterval&#x3D;1800，hdfs.rollSize&#x3D;134217728，hdfs.rollCount<br>&#x3D;0</p>\n<p>4）事务</p>\n<p>Source到Channel是Put事务</p>\n<p>Channel到Sink是Take事务</p>\n<h3 id=\"1-4-2-Flume拦截器\"><a href=\"#1-4-2-Flume拦截器\" class=\"headerlink\" title=\"1.4.2 Flume拦截器\"></a>1.4.2 Flume拦截器</h3><p>1）拦截器注意事项</p>\n<p>（1）ETL拦截器：主要是用来判断json是否完整。没有做复杂的清洗操作主要是防止过多的降低传输速率。</p>\n<p>（2）时间戳拦截器：主要是解决零点漂移问题</p>\n<p>2）自定义拦截器步骤</p>\n<p>（1）实现 Interceptor</p>\n<p>（2）重写四个方法</p>\n<ul>\n<li><p>initialize 初始化</p>\n</li>\n<li><p>public Event intercept(Event event) 处理单个Event</p>\n</li>\n<li><p>public List<Event> intercept(List<Event> events)</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>处理多个Event，在这个方法中调用Event intercept(Event event)</p></blockquote>\n<ul>\n<li>close方法</li>\n</ul>\n<p>（3）静态内部类，实现Interceptor.Builder</p>\n<p>3）拦截器可以不用吗？</p>\n<p>ETL拦截器可以不用；需要在下一级Hive的dwd层和SparkSteaming里面处理</p>\n<p>时间戳拦截器建议使用。<br>如果不用需要采用延迟15-20分钟处理数据的方式，比较麻烦。</p>\n<h3 id=\"1-4-3-Flume-Channel选择器\"><a href=\"#1-4-3-Flume-Channel选择器\" class=\"headerlink\" title=\"1.4.3 Flume Channel选择器\"></a>1.4.3 Flume Channel选择器</h3><p>Replicating：默认选择器。功能：将数据发往下一级所有通道</p>\n<p>Multiplexing：选择性发往指定通道。</p>\n<h3 id=\"1-4-4-Flume监控器\"><a href=\"#1-4-4-Flume监控器\" class=\"headerlink\" title=\"1.4.4 Flume监控器\"></a>1.4.4 Flume监控器</h3><p>1）采用Ganglia监控器，监控到Flume尝试提交的次数远远大于最终成功的次数，说明Flume运行比较差。主要是内存不够导致的。</p>\n<p>2）解决办法？</p>\n<p>（1）自身：flume默认内存2000m。考虑增加flume内存，在flume-env.sh配置文件中修改flume内存为<br>4-6g</p>\n<p>-Xmx与-Xms最好设置一致，减少内存抖动带来的性能影响，如果设置不一致容易导致频繁fullgc。</p>\n<p>（2）找朋友：增加服务器台数</p>\n<p>搞活动 618 &#x3D;》增加服务器&#x3D;》用完在退出</p>\n<p>日志服务器配置：8-16g内存、磁盘8T</p>\n<h3 id=\"1-4-5-Flume采集数据会丢失吗-（防止数据丢失的机制）\"><a href=\"#1-4-5-Flume采集数据会丢失吗-（防止数据丢失的机制）\" class=\"headerlink\" title=\"1.4.5 Flume采集数据会丢失吗?（防止数据丢失的机制）\"></a>1.4.5 Flume采集数据会丢失吗?（防止数据丢失的机制）</h3><p>如果是FileChannel不会，Channel存储可以存储在File中，数据传输自身有事务。</p>\n<p>如果是MemoryChannel有可能丢。</p>\n<h2 id=\"1-5-Kafka\"><a href=\"#1-5-Kafka\" class=\"headerlink\" title=\"1.5 Kafka\"></a>1.5 Kafka</h2><h3 id=\"1-5-1-Kafka架构\"><a href=\"#1-5-1-Kafka架构\" class=\"headerlink\" title=\"1.5.1 Kafka架构\"></a>1.5.1 Kafka架构</h3><p>生产者、Broker、消费者、Zookeeper；</p>\n<p>注意：Zookeeper中保存Broker<br>id和消费者offsets等信息，但是没有生产者信息。</p>\n<h3 id=\"1-5-2-Kafka的机器数量\"><a href=\"#1-5-2-Kafka的机器数量\" class=\"headerlink\" title=\"1.5.2 Kafka的机器数量\"></a>1.5.2 Kafka的机器数量</h3><p>Kafka机器数量 &#x3D; 2 *（峰值生产速度 * 副本数 &#x2F; 100）+ 1</p>\n<h3 id=\"1-5-3-副本数设定\"><a href=\"#1-5-3-副本数设定\" class=\"headerlink\" title=\"1.5.3 副本数设定\"></a>1.5.3 副本数设定</h3><p>一般我们设置成2个或3个，很多企业设置为2个。</p>\n<p>副本的优势：提高可靠性；副本劣势：增加了网络IO传输</p>\n<h3 id=\"1-5-4-Kafka压测\"><a href=\"#1-5-4-Kafka压测\" class=\"headerlink\" title=\"1.5.4 Kafka压测\"></a>1.5.4 Kafka压测</h3><p>Kafka官方自带压力测试脚本（kafka-consumer-perf-test.sh、kafka-producer-perf-test.sh）。Kafka压测时，可以查看到哪个地方出现了瓶颈（CPU，内存，网络IO）。一般都是网络IO达到瓶颈。</p>\n<h3 id=\"1-5-5-Kafka日志保存时间\"><a href=\"#1-5-5-Kafka日志保存时间\" class=\"headerlink\" title=\"1.5.5 Kafka日志保存时间\"></a>1.5.5 Kafka日志保存时间</h3><p>默认保存7天；生产环境建议3天</p>\n<h3 id=\"1-5-6-Kafka中数据量计算\"><a href=\"#1-5-6-Kafka中数据量计算\" class=\"headerlink\" title=\"1.5.6 Kafka中数据量计算\"></a>1.5.6 Kafka中数据量计算</h3><p>每天总数据量100g，每天产生1亿条日志，10000万&#x2F;24&#x2F;60&#x2F;60&#x3D;1150条&#x2F;每秒钟</p>\n<p>平均每秒钟：1150条</p>\n<p>低谷每秒钟：50条</p>\n<p>高峰每秒钟：1150条 *（2-20倍）&#x3D; 2300条 - 23000条</p>\n<p>每条日志大小：0.5k - 2k（取1k）</p>\n<p>每秒多少数据量：2.0M - 20MB</p>\n<h3 id=\"1-5-7-Kafka的硬盘大小\"><a href=\"#1-5-7-Kafka的硬盘大小\" class=\"headerlink\" title=\"1.5.7 Kafka的硬盘大小\"></a>1.5.7 Kafka的硬盘大小</h3><p>每天的数据量100g * 2个副本 * 3天 &#x2F; 70%</p>\n<h3 id=\"1-5-8-Kafka监控\"><a href=\"#1-5-8-Kafka监控\" class=\"headerlink\" title=\"1.5.8 Kafka监控\"></a>1.5.8 Kafka监控</h3><p>公司自己开发的监控器；</p>\n<p>开源的监控器：KafkaManager、KafkaMonitor、KafkaEagle</p>\n<h3 id=\"1-5-9-Kakfa分区数\"><a href=\"#1-5-9-Kakfa分区数\" class=\"headerlink\" title=\"1.5.9 Kakfa分区数\"></a>1.5.9 Kakfa分区数</h3><p>1）创建一个只有1个分区的topic</p>\n<p>2）测试这个topic的producer吞吐量和consumer吞吐量。</p>\n<p>3）假设他们的值分别是Tp和Tc，单位可以是MB&#x2F;s。</p>\n<p>4）然后假设总的目标吞吐量是Tt，那么分区数&#x3D;Tt &#x2F; min（Tp，Tc）</p>\n<p>例如：producer吞吐量 &#x3D; 20m&#x2F;s；consumer吞吐量 &#x3D; 50m&#x2F;s，期望吞吐量100m&#x2F;s；</p>\n<p>分区数 &#x3D; 100 &#x2F; 20 &#x3D; 5分区</p>\n<p><a href=\"https://blog.csdn.net/weixin_42641909/article/details/89294698\">[https://blog.csdn.net/weixin_42641909&#x2F;article&#x2F;details&#x2F;89294698]{.underline}</a></p>\n<p>分区数一般设置为：3-10个</p>\n<h3 id=\"1-5-10-多少个Topic\"><a href=\"#1-5-10-多少个Topic\" class=\"headerlink\" title=\"1.5.10 多少个Topic\"></a>1.5.10 多少个Topic</h3><p>通常情况：多少个日志类型就多少个Topic。也有对日志类型进行合并的。</p>\n<h3 id=\"1-5-11-Kafka的ISR副本同步队列\"><a href=\"#1-5-11-Kafka的ISR副本同步队列\" class=\"headerlink\" title=\"1.5.11 Kafka的ISR副本同步队列\"></a>1.5.11 Kafka的ISR副本同步队列</h3><p>ISR（In-Sync<br>Replicas），副本同步队列。ISR中包括Leader和Follower。如果Leader进程挂掉，会在ISR队列中选择一个服务作为新的Leader。有replica.lag.max.messages（延迟条数）和replica.lag.time.max.ms（延迟时间）两个参数决定一台服务是否可以加入ISR副本队列，在0.10版本移除了replica.lag.max.messages参数，防止服务频繁的进去队列。</p>\n<p>任意一个维度超过阈值都会把Follower剔除出ISR，存入OSR（Outof-Sync<br>Replicas）列表，新加入的Follower也会先存放在OSR中。</p>\n<h3 id=\"1-5-12-Kafka分区分配策略\"><a href=\"#1-5-12-Kafka分区分配策略\" class=\"headerlink\" title=\"1.5.12 Kafka分区分配策略\"></a>1.5.12 Kafka分区分配策略</h3><p>在 Kafka内部存在两种默认的分区分配策略：Range和 RoundRobin。</p>\n<p>Range是默认策略。Range是对每个Topic而言的（即一个Topic一个Topic分），首先对同一个Topic里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。然后用Partitions分区的个数除以消费者线程的总数来决定每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。</p>\n<p>例如：我们有10个分区，两个消费者（C1，C2），3个消费者线程，10 &#x2F; 3 &#x3D;<br>3而且除不尽。</p>\n<p>C1-0 将消费 0, 1, 2, 3 分区</p>\n<p>C2-0 将消费 4, 5, 6 分区</p>\n<p>C2-1 将消费 7, 8, 9 分区</p>\n<p>第一步：将所有主题分区组成TopicAndPartition列表，然后对TopicAndPartition列表按照hashCode进行排序，最后按照轮询的方式发给每一个消费线程。</p>\n<h3 id=\"1-5-13-Kafka挂掉\"><a href=\"#1-5-13-Kafka挂掉\" class=\"headerlink\" title=\"1.5.13 Kafka挂掉\"></a>1.5.13 Kafka挂掉</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1）Flume记录</p>\n<p>2）日志有记录</p>\n<p>3）短期没事</p></blockquote>\n<h3 id=\"1-5-14-Kafka丢不丢数据\"><a href=\"#1-5-14-Kafka丢不丢数据\" class=\"headerlink\" title=\"1.5.14 Kafka丢不丢数据\"></a>1.5.14 Kafka丢不丢数据</h3><p><strong>1）producer角度</strong></p>\n<ul>\n<li><p>Ack &#x3D; 0，相当于异步发送，消息发送完毕即offset增加，继续生产。</p>\n</li>\n<li><p>Ack &#x3D; 1，leader收到leader replica<br>对一个消息的接受ack才增加offset，然后继续生产。</p>\n</li>\n<li><p>Ack &#x3D; -1，leader收到所有replica<br>对一个消息的接受ack才增加offset，然后继续生产。</p>\n</li>\n</ul>\n<p>ack在生产者指定，不同生产者可以不同。</p>\n<p>ack设为-1，需要ISR里的所有follower应答，想要真正不丢数据，需要配合参数：</p>\n<ul>\n<li>min.insync.replicas: ack为-1时生效，ISR里应答的最小follower数量。</li>\n</ul>\n<p>默认为1（leader本身也算一个！），所以当ISR里除了leader本身，没有其他的follower，即使ack设为-1，相当于1的效果，不能保证不丢数据。</p>\n<p>需要将min.insync.replicas设置大于等于2，才能保证有其他副本同步到数据。</p>\n<ul>\n<li>retries &#x3D;<br>Integer.MAX_VALUE，无限重试。如果上述两个条件不满足，写入一直失败，就会无限次重试，保证数据必须成功的发送给两个副本，如果做不到，就不停的重试，除非是面向金融级的场景，面向企业大客户，或者是广告计费，跟钱的计算相关的场景下，才会通过严格配置保证数据绝对不丢失</li>\n</ul>\n<p>kafka-topics.sh –bootstrap-server hadoop1:9092 –create –topic<br>testisr2 –replication-factor 3 –partitions 4 –config<br>min.insync.replicas&#x3D;2</p>\n<p><strong>完全不丢结论：ack&#x3D;-1 + min.insync.replicas&gt;&#x3D;2 +无限重试</strong></p>\n<p><strong>2）broker角度</strong></p>\n<p>副本数大于1</p>\n<p>min.insync.replicas大于1</p>\n<p><strong>3）consumer角度</strong></p>\n<p>手动提交offset，flink结合checkpoint</p>\n<h3 id=\"1-5-15-Kafka数据重复\"><a href=\"#1-5-15-Kafka数据重复\" class=\"headerlink\" title=\"1.5.15 Kafka数据重复\"></a>1.5.15 Kafka数据重复</h3><p>重复指的是发生重试造成的重复。</p>\n<p>幂等性 + ack-1 + 事务</p>\n<p>Kafka数据重复，可以在下一级：SparkStreaming、redis、Flink或者Hive中dwd层去重，去重的手段：分组、按照id开窗只取第一个值；</p>\n<p><em>了解：</em></p>\n<p>Kafka幂等性原理（单分区单会话）：producer重试引起的乱序和重复</p>\n<p>1、重复问题的解决：</p>\n<p>1）Kafka增加了pid和seq。Producer中每个RecordBatch都有一个单调递增的seq;<br>Broker上每个topic的partition也会维护pid-seq的映射，并且每Commit都会更新lastSeq。</p>\n<p>2）recordBatch到来时，broker会先检查RecordBatch再保存数据：</p>\n<p>如果batch中<br>baseSeq（第一条消息的seq）比Broker维护的序号（lastSeq）大1，则保存数据，否则不保存。</p>\n<p>2、乱序问题的解决</p>\n<p>假设我们有5个请求，batch1、batch2、batch3、batch4、batch5；</p>\n<p>如果只有batch2 ack<br>failed，3、4、5都保存了，那2将会随下次batch重发而造成重复。</p>\n<p>可以设置max.in.flight.requests.per.connection&#x3D;1（客户端在单个连接上能够发送的未响应请求的个数）来解决乱序，但降低了系统吞吐。</p>\n<p>新版本kafka设置enable.idempotence&#x3D;true后能够动态调整max-in-flight-request。正常情况下max.in.flight.requests.per.connection大于1。当重试请求到来时，batch<br>会根据<br>seq重新添加到队列的合适位置，并把max.in.flight.requests.per.connection设为1，这样它前面的<br>batch序号都比它小，只有前面的都发完了，它才能发。</p>\n<h3 id=\"1-5-16-Kafka消息数据积压，Kafka消费能力不足怎么处理？\"><a href=\"#1-5-16-Kafka消息数据积压，Kafka消费能力不足怎么处理？\" class=\"headerlink\" title=\"1.5.16 Kafka消息数据积压，Kafka消费能力不足怎么处理？\"></a>1.5.16 Kafka消息数据积压，Kafka消费能力不足怎么处理？</h3><p>1）如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费组的消费者数量，消费者数<br>&#x3D; 分区数。（两者缺一不可）</p>\n<p>2）如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据&#x2F;处理时间<br>&lt; 生产速度），使处理的数据小于生产的数据，也会造成数据积压。</p>\n<h3 id=\"1-5-17-Kafka参数优化\"><a href=\"#1-5-17-Kafka参数优化\" class=\"headerlink\" title=\"1.5.17 Kafka参数优化\"></a>1.5.17 Kafka参数优化</h3><p><strong>1）Broker参数配置（server.properties）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1、日志保留策略配置</p>\n<h1 id=\"保留三天，也可以更短-（log-cleaner-delete-retention-ms）\"><a href=\"#保留三天，也可以更短-（log-cleaner-delete-retention-ms）\" class=\"headerlink\" title=\"保留三天，也可以更短 （log.cleaner.delete.retention.ms）\"></a>保留三天，也可以更短 （log.cleaner.delete.retention.ms）</h1><p>log.retention.hours&#x3D;72</p>\n<p>2、Replica相关配置</p>\n<p>default.replication.factor:1 默认副本1个</p>\n<p>3、网络通信延时</p>\n<p>replica.socket.timeout.ms:30000 #当集群之间网络不稳定时,调大该参数</p>\n<p>replica.lag.time.max.ms&#x3D; 600000#<br>如果网络不好,或者kafka集群压力较大,会出现副本丢失,然后会频繁复制副本,导致集群压力更大,此时可以调大该参数</p></blockquote>\n<p><strong>2）Producer优化（producer.properties）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>compression.type:none gzip snappy lz4</p>\n<p>#默认发送不进行压缩，推荐配置一种适合的压缩算法，可以大幅度的减缓网络压力和Broker的存储压力。</p></blockquote>\n<p><strong>3）Kafka内存调整（</strong>kafka-server-start.sh<strong>）</strong></p>\n<p>默认内存1个G，生产环境尽量不要超过6个G。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>export KAFKA_HEAP_OPTS&#x3D;”-Xms4g -Xmx4g”</p></blockquote>\n<h3 id=\"1-5-18-Kafka高效读写数据\"><a href=\"#1-5-18-Kafka高效读写数据\" class=\"headerlink\" title=\"1.5.18 Kafka高效读写数据\"></a>1.5.18 Kafka高效读写数据</h3><p><strong>1）Kafka本身是分布式集群，同时采用分区技术，并发度高。</strong></p>\n<p><strong>2）顺序写磁盘</strong></p>\n<p>Kafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端，为顺序写。官网有数据表明，同样的磁盘，顺序写能到600M&#x2F;s，而随机写只有100K&#x2F;s。</p>\n<p><strong>3）零复制技术</strong></p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image19.png\">{width&#x3D;”2.9694444444444446in”<br>height&#x3D;”1.429861111111111in”}</p>\n<h3 id=\"1-5-19-Kafka单条日志传输大小\"><a href=\"#1-5-19-Kafka单条日志传输大小\" class=\"headerlink\" title=\"1.5.19 Kafka单条日志传输大小\"></a>1.5.19 Kafka单条日志传输大小</h3><p>Kafka对于消息体的大小默认为单条最大值是1M但是在我们应用场景中，常常会出现一条消息大于1M，如果不对Kafka进行配置。则会出现生产者无法将消息推送到Kafka或消费者无法去消费Kafka里面的数据，这时我们就要对Kafka进行以下配置：server.properties</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>replica.fetch.max.bytes: 1048576 broker可复制的消息的最大字节数,<br>默认为1M</p>\n<p>message.max.bytes: 1000012 kafka 会接收单个消息size的最大限制，<br>默认为1M左右</p></blockquote>\n<p>注意：message.max.bytes必须小于等于replica.fetch.max.bytes，否则就会导致replica之间数据同步失败。</p>\n<h3 id=\"1-5-20-Kafka过期数据清理\"><a href=\"#1-5-20-Kafka过期数据清理\" class=\"headerlink\" title=\"1.5.20 Kafka过期数据清理\"></a>1.5.20 Kafka过期数据清理</h3><p>保证数据没有被引用（没人消费他）</p>\n<p>日志清理的策略只有delete和compact两种</p>\n<p>log.cleanup.policy &#x3D; delete启用删除策略</p>\n<p>log.cleanup.policy &#x3D; compact启用压缩策略</p>\n<p><a href=\"https://www.jianshu.com/p/fa6adeae8eb5\">https://www.jianshu.com/p/fa6adeae8eb5</a></p>\n<h3 id=\"1-5-21-Kafka可以按照时间消费数据\"><a href=\"#1-5-21-Kafka可以按照时间消费数据\" class=\"headerlink\" title=\"1.5.21 Kafka可以按照时间消费数据\"></a>1.5.21 Kafka可以按照时间消费数据</h3><p>Map&lt;TopicPartition, OffsetAndTimestamp&gt; startOffsetMap &#x3D;<br>KafkaUtil.fetchOffsetsWithTimestamp(topic, sTime, kafkaProp);</p>\n<h3 id=\"1-5-22-Kafka消费者角度考虑是拉取数据还是推送数据\"><a href=\"#1-5-22-Kafka消费者角度考虑是拉取数据还是推送数据\" class=\"headerlink\" title=\"1.5.22 Kafka消费者角度考虑是拉取数据还是推送数据\"></a>1.5.22 Kafka消费者角度考虑是拉取数据还是推送数据</h3><p>拉取数据</p>\n<h3 id=\"1-5-23-Kafka中的数据是有序的吗！！！\"><a href=\"#1-5-23-Kafka中的数据是有序的吗！！！\" class=\"headerlink\" title=\"1.5.23 Kafka中的数据是有序的吗！！！\"></a>1.5.23 Kafka中的数据是有序的吗！！！</h3><p>单分区内有序；多分区，分区与分区间无序；</p>\n<p><strong>扩展：</strong></p>\n<p>kafka producer发送消息的时候，可以指定key:</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image20.png\">{width&#x3D;”5.424305555555556in”<br>height&#x3D;”2.609722222222222in”}</p>\n<p>这个key的作用是为消息选择存储分区，key可以为空，当指定key且不为空的时候，Kafka是根据key的hash值与分区数取模来决定数据存储到那个分区。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image21.png\">{width&#x3D;”5.444444444444445in”<br>height&#x3D;”2.959722222222222in”}</p>\n<p><strong>有序解决方案：同一张表的数据 放到 同一个 分区</strong></p>\n<p>&#x3D;&gt; ProducerRecord里传入key，会根据key取hash算出分区号</p>\n<p>&#x3D;&gt; key使用表名，如果有库名，拼接上库名</p>\n<h3 id=\"1-5-24-Kafka的LeaderEpoch哪个版本引入的？\"><a href=\"#1-5-24-Kafka的LeaderEpoch哪个版本引入的？\" class=\"headerlink\" title=\"1.5.24 Kafka的LeaderEpoch哪个版本引入的？\"></a>1.5.24 Kafka的LeaderEpoch哪个版本引入的？</h3><p>Kafka 0.11版本以后采用的。</p>\n<h3 id=\"1-5-25-Kafka生产者调优配置\"><a href=\"#1-5-25-Kafka生产者调优配置\" class=\"headerlink\" title=\"1.5.25 Kafka生产者调优配置\"></a>1.5.25 Kafka生产者调优配置</h3><p>Properties props &#x3D; new Properties();</p>\n<p>props.put(“bootstrap.servers”,</p>\n<p>“hadoop1:9092,hadoop2:9092,hadoop3:9092”);</p>\n<p>props.put(“key.serializer”,<br>“org.apache.kafka.common.serialization.StringSerializer”);</p>\n<p>props.put(“value.serializer”,<br>“org.apache.kafka.common.serialization.StringSerializer”);</p>\n<p>&#x2F;&#x2F;如果要想保证数据不丢失，得如下设置：</p>\n<p>&#x2F;&#x2F; min.insync.replicas &#x3D; 2</p>\n<p>&#x2F;&#x2F; acks &#x3D; -1</p>\n<p>&#x2F;&#x2F; retries &#x3D; Integer.MAX_VALUE</p>\n<p>props.put(“acks”, “-1”);</p>\n<p>&#x2F;&#x2F;如果消息发送失败，就会重试，这里的3次代表重试的次数</p>\n<p>props.put(“retries”, 3);</p>\n<p>&#x2F;&#x2F;重试的时间间隔</p>\n<p>props.put(“retry.backoff.ms”,5000);</p>\n<p>&#x2F;&#x2F;设置是否开启压缩，默认是none不压缩</p>\n<p>&#x2F;&#x2F;如果要压缩的话，建议设置lz4,经过实际检验，效果还是不错的</p>\n<p>props.put(“compression.type”,”lz4”);</p>\n<p>&#x2F;&#x2F;发送一次消息的批次大小，如果批次太小，会导致网络请求频繁，</p>\n<p>&#x2F;&#x2F;建议设置大一些,默认16384Byte（16k）,建议调大，这里用32k</p>\n<p>props.put(“batch.size”, 32384);</p>\n<p>&#x2F;&#x2F;批次达到时间就发送。默认是0，意思是消息必须立即被发送，建议100ms</p>\n<p>props.put(“linger.ms”, 100);</p>\n<p>&#x2F;&#x2F;设置的缓冲区大小,默认33554432（32M）,一般不用动</p>\n<p>&#x2F;&#x2F;验证何时该调整缓冲区的大小：</p>\n<p>&#x2F;&#x2F;用一般Java获取结束时间和开始时间: System.currentTime()</p>\n<p>&#x2F;&#x2F;当结束时间减去开始时间大于设置的linger.ms(100ms)，此时Sender线程处理速度慢，需要调大缓冲区大小。</p>\n<p>props.put(“buffer.memory”, 33554432);</p>\n<p>&#x2F;&#x2F;发送消息的最大大小，默认是1048576(1M),上限可以调大到10M</p>\n<p>props.put(“max.request.size”,10485760);</p>\n<p>&#x2F;&#x2F;保证一个消息发送成功，再发另外一个消息,保证单分区有序</p>\n<p>props.put(“max.in.flight.requests.per.connection”,1);</p>\n<p>&#x2F;&#x2F;最大阻塞时间，RecordAccumulator缓存不足时或者没有可用的元数据时，KafkaProducer的send()方法调用要么被阻塞，要么抛出异常，此参数的默认值为60000，即60s</p>\n<p>props.put(“max.block.ms”, 3000);</p>\n<p>&#x2F;&#x2F; 创建一个Producer实例</p>\n<p>KafkaProducer&lt;String, String&gt; producer &#x3D;</p>\n<p>new KafkaProducer&lt;String, String&gt;(props);</p>\n<p>&#x2F;&#x2F; 有序性考虑，可以指定生产者的key</p>\n<p>ProducerRecord&lt;String, String&gt; record &#x3D;</p>\n<p>new ProducerRecord&lt;&gt;(“mytopic”, “mykey”, “myvalue”);</p>\n<p>&#x2F;&#x2F;可以计算开始时间</p>\n<p>long startTime&#x3D;System.currentTime();</p>\n<p>&#x2F;&#x2F;发送消息的模式有两种，一种是异步的，一种是同步的，我们在实际生产中一般是使用异步的发送方式</p>\n<p>producer.send(record, new Callback() {</p>\n<p>@Override</p>\n<p>public void onCompletion(RecordMetadata metadata, Exception exception) {</p>\n<p>if(exception &#x3D;&#x3D; null) {</p>\n<p>&#x2F;&#x2F; 消息发送成功</p>\n<p>System.out.println(“消息发送成功”);</p>\n<p>} else {</p>\n<p>&#x2F;&#x2F; 消息发送失败，需要重新发送</p>\n<p>}</p>\n<p>}</p>\n<p>});</p>\n<p>&#x2F;&#x2F;计算结束时间</p>\n<p>long endTime&#x3D;System.currentTime();</p>\n<p>if(endTime - startTime &gt; 100){&#x2F;&#x2F;说明内存被压满了</p>\n<p>&#x2F;&#x2F;说明有问题，考虑调大buffer.memory</p>\n<p>}</p>\n<p>&#x2F;&#x2F; 这是同步发送的模式</p>\n<p>&#x2F;&#x2F;producer.send(record).get();</p>\n<p>producer.close();</p>\n<h2 id=\"1-6-Hive\"><a href=\"#1-6-Hive\" class=\"headerlink\" title=\"1.6 Hive\"></a>1.6 Hive</h2><h3 id=\"1-6-1-Hive的架构及HQL转换为MR流程\"><a href=\"#1-6-1-Hive的架构及HQL转换为MR流程\" class=\"headerlink\" title=\"1.6.1 Hive的架构及HQL转换为MR流程\"></a>1.6.1 Hive的架构及HQL转换为MR流程</h3><p>Hive元数据默认存储在derby数据库，不支持多客户端访问，所以将元数据存储在MySQl，支持多客户端访问。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image23.png\" alt=\"图片\">{width&#x3D;”3.2708333333333335in”<br>height&#x3D;”2.5347222222222223in”}</p></blockquote>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image24.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.9138888888888888in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image25.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.140277777777778in”}</p>\n<h3 id=\"1-6-2-Hive和数据库比较\"><a href=\"#1-6-2-Hive和数据库比较\" class=\"headerlink\" title=\"1.6.2 Hive和数据库比较\"></a>1.6.2 Hive和数据库比较</h3><p>Hive 和数据库除了拥有类似的查询语言，再无类似之处。</p>\n<p>1）数据存储位置</p>\n<p>Hive 存储在 HDFS 。数据库将数据保存在块设备或者本地文件系统中。</p>\n<p>2）数据更新</p>\n<p>Hive中不建议对数据的改写。而数据库中的数据通常是需要经常进行修改的，</p>\n<p>3）执行延迟</p>\n<p>Hive 执行延迟较高。数据库的执行延迟较低。当然，这个是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。</p>\n<p>4）数据规模</p>\n<p>Hive支持很大规模的数据计算；数据库可以支持的数据规模较小。</p>\n<h3 id=\"1-6-3-内部表和外部表\"><a href=\"#1-6-3-内部表和外部表\" class=\"headerlink\" title=\"1.6.3 内部表和外部表\"></a>1.6.3 内部表和外部表</h3><p>元数据、原始数据</p>\n<p>1）删除数据时：</p>\n<p>内部表：元数据、原始数据，全删除</p>\n<p>外部表：元数据 只删除</p>\n<p>2）在公司生产环境下，什么时候创建内部表，什么时候创建外部表？</p>\n<p>在公司中绝大多数场景都是外部表。</p>\n<p>自己使用的临时表，才会创建内部表；</p>\n<h3 id=\"1-6-4-4个By区别\"><a href=\"#1-6-4-4个By区别\" class=\"headerlink\" title=\"1.6.4 4个By区别\"></a>1.6.4 4个By区别</h3><p>1）Order By：全局排序，只有一个Reducer；</p>\n<p>2）Sort By：分区内有序；</p>\n<p>3）Distrbute By：类似MR中Partition，进行分区，结合sort by使用。</p>\n<p>4） Cluster By：当Distribute by和Sorts by字段相同时，可以使用Cluster<br>by方式。Cluster by除了具有Distribute by的功能外还兼具Sort<br>by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。</p>\n<p>在生产环境中Order By用的比较少，容易导致OOM。</p>\n<p>在生产环境中Sort By + Distrbute By用的多。</p>\n<h3 id=\"1-6-5-系统函数\"><a href=\"#1-6-5-系统函数\" class=\"headerlink\" title=\"1.6.5 系统函数\"></a>1.6.5 系统函数</h3><p>1）date_add、date_sub函数（加减日期）</p>\n<p>2）next_day函数（周指标相关）</p>\n<p>3）date_format函数（根据格式整理日期）</p>\n<p>4）last_day函数（求当月最后一天日期）</p>\n<p>5）CONCAT、CONCAT_WS、COLLECT_SET</p>\n<p>6）EXPLODE</p>\n<p>7）collect_set函数</p>\n<p>8）get_json_object解析json函数</p>\n<p>9）NVL（表达式1，表达式2）</p>\n<p>如果表达式1为空值，NVL返回值为表达式2的值，否则返回表达式1的值。</p>\n<h3 id=\"1-6-6-自定义UDF、UDTF函数\"><a href=\"#1-6-6-自定义UDF、UDTF函数\" class=\"headerlink\" title=\"1.6.6 自定义UDF、UDTF函数\"></a>1.6.6 自定义UDF、UDTF函数</h3><p>1）在项目中是否自定义过UDF、UDTF函数，以及用他们处理了什么问题，及自定义步骤？</p>\n<p>（1）用UDF函数解析公共字段；用UDTF函数解析事件字段。</p>\n<p>（2）自定义UDF：继承UDF，重写evaluate方法</p>\n<p>（3）自定义UDTF：继承自GenericUDTF，重写3个方法：initialize（自定义输出的列名和类型），process（将结果返回forward(result)），close</p>\n<p>2）为什么要自定义UDF&#x2F;UDTF？</p>\n<p>因为自定义函数，可以自己埋点Log打印日志，出错或者数据异常，方便调试。</p>\n<p>引入第三方jar包时，也需要。</p>\n<h3 id=\"1-6-7-窗口函数\"><a href=\"#1-6-7-窗口函数\" class=\"headerlink\" title=\"1.6.7 窗口函数\"></a>1.6.7 窗口函数</h3><p>1）Rank</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>（1）RANK() 排序相同时会重复，总数不会变</p>\n<p>（2）DENSE_RANK() 排序相同时会重复，总数会减少</p>\n<p>（3）ROW_NUMBER() 会根据顺序计算</p></blockquote>\n<p>2） OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化</p>\n<p>（1）CURRENT ROW：当前行</p>\n<p>（2）n PRECEDING：往前n行数据</p>\n<p>（3） n FOLLOWING：往后n行数据</p>\n<p>（4）UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点，<br>UNBOUNDED FOLLOWING表示到后面的终点</p>\n<p>（5） LAG(col,n)：往前第n行数据</p>\n<p>（6）LEAD(col,n)：往后第n行数据</p>\n<p>（7） NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</p>\n<p><strong>3）手写：分组TopN、行转列、列转行</strong></p>\n<h3 id=\"1-6-8-Hive优化\"><a href=\"#1-6-8-Hive优化\" class=\"headerlink\" title=\"1.6.8 Hive优化\"></a>1.6.8 Hive优化</h3><p><strong>1）MapJoin</strong></p>\n<p>如果不指定MapJoin或者不符合MapJoin的条件，那么Hive解析器会将Join操作转换成Common<br>Join，即：在Reduce阶段完成join。容易发生数据倾斜。可以用MapJoin把小表全部加载到内存在map端进行join，避免reducer处理。</p>\n<p><strong>2）行列过滤</strong></p>\n<p>列处理：在SELECT中，只拿需要的列，如果有，尽量使用分区过滤，少用SELECT<br>*。</p>\n<p>行处理：在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where后面，那么就会先全表关联，之后再过滤。</p>\n<p><strong>3）列式存储</strong></p>\n<p><strong>4）采用分区技术</strong></p>\n<p><strong>5）合理设置Map数</strong></p>\n<p>mapred.min.split.size: 指的是数据的最小分割单元大小；min的默认值是1B</p>\n<p>mapred.max.split.size: 指的是数据的最大分割单元大小；max的默认值是256MB</p>\n<p>通过调整max可以起到调整map数的作用，减小max可以增加map数，增大max可以减少map数。</p>\n<p>需要提醒的是，直接调整mapred.map.tasks这个参数是没有效果的。</p>\n<p><a href=\"https://www.cnblogs.com/swordfall/p/11037539.html\">[https://www.cnblogs.com/swordfall/p/11037539.html]{.underline}</a></p>\n<p><strong>6）合理设置Reduce数</strong></p>\n<p>Reduce个数并不是越多越好</p>\n<p>（1）过多的启动和初始化Reduce也会消耗时间和资源；</p>\n<p>（2）另外，有多少个Reduce，就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；</p>\n<p>在设置Reduce个数的时候也需要考虑这两个原则：处理大数据量利用合适的Reduce数；使单个Reduce任务处理数据量大小要合适；</p>\n<p><strong>7）小文件如何产生的？</strong></p>\n<p>（1）动态分区插入数据，产生大量的小文件，从而导致map数量剧增；</p>\n<p>（2）reduce数量越多，小文件也越多（reduce的个数和输出文件是对应的）；</p>\n<p>（3）数据源本身就包含大量的小文件。</p>\n<p><strong>8）小文件解决方案</strong></p>\n<p>（1）在Map执行前合并小文件，减少Map数：CombineHiveInputFormat具有对小文件进行合并的功能（系统默认的格式）。HiveInputFormat没有对小文件合并功能。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>（2）merge</strong></p>\n<p>&#x2F;&#x2F; 输出合并小文件</p></blockquote>\n<p>SET hive.merge.mapfiles &#x3D; true; –<br>默认true，在map-only任务结束时合并小文件</p>\n<p>SET hive.merge.mapredfiles &#x3D; true; –<br>默认false，在map-reduce任务结束时合并小文件</p>\n<p>SET hive.merge.size.per.task &#x3D; 268435456; – 默认256M</p>\n<p>SET hive.merge.smallfiles.avgsize &#x3D; 16777216; –<br>当输出文件的平均大小小于16m该值时，启动一个独立的map-reduce任务进行文件merge</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>（3）开启JVM重用</strong></p></blockquote>\n<p>set mapreduce.job.jvm.numtasks&#x3D;10</p>\n<p><strong>9）开启map端combiner（不影响最终业务逻辑）</strong></p>\n<p>set hive.map.aggr&#x3D;true；</p>\n<p><strong>10）压缩（选择快的）</strong></p>\n<p>设置map端输出、中间结果压缩。（不完全是解决数据倾斜的问题，但是减少了IO读写和网络传输，能提高很多效率）</p>\n<p>set hive.exec.compress.intermediate&#x3D;true –启用中间数据压缩</p>\n<p>set mapreduce.map.output.compress&#x3D;true –启用最终数据压缩</p>\n<p>set mapreduce.map.outout.compress.codec&#x3D;…; –设置压缩方式</p>\n<p><strong>11）采用tez引擎或者spark引擎</strong></p>\n<h3 id=\"1-6-9-Hive解决数据倾斜方法\"><a href=\"#1-6-9-Hive解决数据倾斜方法\" class=\"headerlink\" title=\"1.6.9 Hive解决数据倾斜方法\"></a>1.6.9 Hive解决数据倾斜方法</h3><p><strong>1）数据倾斜长啥样？</strong></p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image27.jpeg\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”1.882638888888889in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image28.jpeg\">{width&#x3D;”5.647222222222222in”<br>height&#x3D;”4.199305555555555in”}</p>\n<p><strong>2）怎么产生的数据倾斜？</strong></p>\n<p><strong>（1）不同数据类型关联产生数据倾斜</strong></p>\n<p>情形：比如用户表中user_id字段为int，log表中user_id字段string类型。当按照user_id进行两个表的Join操作时。</p>\n<p>解决方式：把数字类型转换成字符串类型</p>\n<p>select * from users a</p>\n<p>left outer join logs b</p>\n<p>on a.usr_id &#x3D; cast(b.user_id as string)</p>\n<p>bug记录：<a href=\"https://www.jianshu.com/p/2181e00d74dc\">[https://www.jianshu.com/p/2181e00d74dc]{.underline}</a></p>\n<p><strong>（2）控制空值分布</strong></p>\n<p>在生产环境经常会用大量空值数据进入到一个reduce中去，导致数据倾斜。</p>\n<p>解决办法：</p>\n<p>自定义分区，将为空的key转变为字符串加随机数或纯随机数，将因空值而造成倾斜的数据分不到多个Reducer。</p>\n<p>注意：对于异常值如果不需要的话，最好是提前在where条件里过滤掉，这样可以使计算量大大减少</p>\n<p><strong>3) 单表 – group by id</strong></p>\n<p>(1) 按照id分组计算count值</p>\n<p>-&gt; 单个Key</p>\n<p>-&gt; 多个Key</p>\n<p>(2) 单个Key</p>\n<p>加随机数，双重聚合</p>\n<p>配置参数，双重聚合 set hive.groupby.skewindata &#x3D; true;</p>\n<p>过滤出这个Key单独处理</p>\n<p>(3) 多个Key</p>\n<p>增加Reducer个数,一定程度上解决问题</p>\n<p>自定义分区器</p>\n<p>加随机数，双重聚合</p>\n<p>配置参数，双重聚合 set hive.groupby.skewindata &#x3D; true;</p>\n<p><strong>4) JOIN ON 关联字段</strong></p>\n<p>(1) 大表JOIN小表 mapJoin 避免了Reducer</p>\n<p>(2) 大表JOIN大表 A表加随机数 B表扩容 聚合</p>\n<p>A concat(name,’_’,随机数[1,2])</p>\n<p>B</p>\n<p>concat(name,’_’,1)</p>\n<p>union all</p>\n<p>concat(name,’_’,2)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>name a1 name b1</p>\n<p>name a2 name b2</p>\n<p>name_1 a1 name_1 b1</p>\n<p>name_2 a2 name_2 b2</p>\n<p>name_1 a1 name_1 b1</p>\n<p>name_2 b1</p>\n<p>name_2 a2 name_1 b2</p>\n<p>name_2 b2</p></blockquote>\n<h3 id=\"1-6-10-Hive里边字段的分隔符用的什么？为什么用t？有遇到过字段里边有t的情况吗，怎么处理的？\"><a href=\"#1-6-10-Hive里边字段的分隔符用的什么？为什么用t？有遇到过字段里边有t的情况吗，怎么处理的？\" class=\"headerlink\" title=\"1.6.10 Hive里边字段的分隔符用的什么？为什么用t？有遇到过字段里边有t的情况吗，怎么处理的？\"></a>1.6.10 Hive里边字段的分隔符用的什么？为什么用t？有遇到过字段里边有t的情况吗，怎么处理的？</h3><p>hive 默认的字段分隔符为ascii码的控制符001（^A）,建表的时候用fields<br>terminated by<br>‘001’。注意：如果采用t或者001等为分隔符，需要要求前端埋点和javaEE后台传递过来的数据必须不能出现该分隔符，通过代码规范约束。一旦传输过来的数据含有分隔符，需要在前一级数据中转义或者替换（ETL）。</p>\n<p>可以设置参数（导入HDFS同样有效）：</p>\n<p>–hive-drop-import-delims 导入到hive时删除 n, r, 001</p>\n<p>–hive-delims-replacement 导入到hive时用自定义的字符替换掉 n, r,<br>001</p>\n<ul>\n<li>字段包含分隔符存在的问题：</li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image29.png\">{width&#x3D;”5.432638888888889in”<br>height&#x3D;”3.4340277777777777in”}</p>\n<ul>\n<li>添加参数的效果：</li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image30.png\">{width&#x3D;”5.313194444444444in”<br>height&#x3D;”4.254861111111111in”}</p>\n<ul>\n<li>在Hive表里的体现：</li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image31.png\">{width&#x3D;”5.322222222222222in”<br>height&#x3D;”1.4118055555555555in”}</p>\n<h3 id=\"1-6-11-Tez引擎优点？\"><a href=\"#1-6-11-Tez引擎优点？\" class=\"headerlink\" title=\"1.6.11 Tez引擎优点？\"></a>1.6.11 Tez引擎优点？</h3><p>Tez可以将多个有依赖的作业转换为一个作业，这样只需写一次HDFS，且中间节点较少，从而大大提升作业的计算性能。</p>\n<p>Mr&#x2F;tez&#x2F;spark区别：</p>\n<p>Mr引擎：多job串联，基于磁盘，落盘的地方比较多。虽然慢，但一定能跑出结果。一般处理，周、月、年指标。</p>\n<p>Spark引擎：虽然在Shuffle过程中也落盘，但是并不是所有算子都需要Shuffle，尤其是多算子过程，中间过程不落盘<br>DAG有向无环图。 兼顾了可靠性和效率。一般处理天指标。</p>\n<p>Tez引擎：完全基于内存。<br>注意：如果数据量特别大，慎重使用。容易OOM。一般用于快速出结果，数据量比较小的场景。</p>\n<h3 id=\"1-6-12-MySQL元数据备份\"><a href=\"#1-6-12-MySQL元数据备份\" class=\"headerlink\" title=\"1.6.12 MySQL元数据备份\"></a>1.6.12 MySQL元数据备份</h3><p><strong>1）MySQL之元数据备份（项目中遇到的问题）</strong></p>\n<p>元数据备份（重点，如数据损坏，可能整个集群无法运行，至少要保证每日零点之后备份到其它服务器两个复本）</p>\n<p>Keepalived或者用mycat</p>\n<p>2）MySQL utf8超过字节数问题</p>\n<p>MySQL的utf8编码最多存储3个字节，当数据中存在表情号、特色符号时会占用超过3个字节数的字节，那么会出现错误<br>Incorrect string value: ‘xF0x9Fx91x91xE5xB0…’</p>\n<p>解决办法：将utf8修改为utf8mb4</p>\n<p>首先修改库的基字符集和数据库排序规则</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image33.png\" alt=\"e46516d3561eea6523d980c7af9eadd\">{width&#x3D;”4.0368055555555555in”<br>height&#x3D;”2.1638888888888888in”}</p>\n<p>再使用 SHOW VARIABLES LIKE ‘%char%’; 命令查看参数</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image34.png\">{width&#x3D;”2.2868055555555555in”<br>height&#x3D;”1.8145833333333334in”}</p>\n<p>确保这几个参数的value值为utf8mb4 如果不是使用set命令修改</p>\n<p>如：set character_set_server &#x3D; utf8mb4;</p>\n<h3 id=\"1-6-13-Union与Union-all区别\"><a href=\"#1-6-13-Union与Union-all区别\" class=\"headerlink\" title=\"1.6.13 Union与Union all区别\"></a>1.6.13 Union与Union all区别</h3><p>1）union会将联合的结果集去重，效率较union all差</p>\n<p>2）union all不会对结果集去重，所以效率高</p>\n<h2 id=\"1-7-Sqoop\"><a href=\"#1-7-Sqoop\" class=\"headerlink\" title=\"1.7 Sqoop\"></a>1.7 Sqoop</h2><h3 id=\"1-7-1-Sqoop参数\"><a href=\"#1-7-1-Sqoop参数\" class=\"headerlink\" title=\"1.7.1 Sqoop参数\"></a>1.7.1 Sqoop参数</h3><p>&#x2F;opt&#x2F;module&#x2F;sqoop&#x2F;bin&#x2F;sqoop import </p>\n<p>–connect </p>\n<p>–username </p>\n<p>–password </p>\n<p>–target-dir </p>\n<p>–delete-target-dir </p>\n<p>–num-mappers </p>\n<p>–fields-terminated-by   </p>\n<p>–query   “$2” ‘ and $CONDITIONS;’</p>\n<h3 id=\"1-7-2-Sqoop导入导出Null存储一致性问题\"><a href=\"#1-7-2-Sqoop导入导出Null存储一致性问题\" class=\"headerlink\" title=\"1.7.2 Sqoop导入导出Null存储一致性问题\"></a>1.7.2 Sqoop导入导出Null存储一致性问题</h3><p>Hive中的Null在底层是以”N”来存储，而MySQL中的Null在底层就是Null，为了保证数据两端的一致性。在导出数据时采用–input-null-string和–input-null-non-string两个参数。导入数据时采用–null-string和–null-non-string。</p>\n<h3 id=\"1-7-3-Sqoop数据导出一致性问题\"><a href=\"#1-7-3-Sqoop数据导出一致性问题\" class=\"headerlink\" title=\"1.7.3 Sqoop数据导出一致性问题\"></a>1.7.3 Sqoop数据导出一致性问题</h3><p>场景1：如Sqoop在导出到Mysql时，使用4个Map任务，过程中有2个任务失败，那此时MySQL中存储了另外两个Map任务导入的数据，此时老板正好看到了这个报表数据。而开发工程师发现任务失败后，会调试问题并最终将全部数据正确的导入MySQL，那后面老板再次看报表数据，发现本次看到的数据与之前的不一致，这在生产环境是不允许的。</p>\n<p>官网：<a href=\"http://sqoop.apache.org/docs/1.4.6/SqoopUserGuide.html\">http://sqoop.apache.org/docs/1.4.6/SqoopUserGuide.html</a></p>\n<p>Since Sqoop breaks down export process into multiple transactions, it is<br>possible that a failed export job may result in partial data being<br>committed to the database. This can further lead to subsequent jobs<br>failing due to insert collisions in some cases, or lead to duplicated<br>data in others. You can overcome this problem by specifying a staging<br>table via the –staging-table option which acts as an auxiliary table<br>that is used to stage exported data. The staged data is finally moved to<br>the destination table in a single transaction.</p>\n<p>–staging-table方式</p>\n<p>sqoop export –connect jdbc:mysql:&#x2F;&#x2F;192.168.137.10:3306&#x2F;user_behavior<br>–username root –password 123456 –table app_cource_study_report<br>–columns watch_video_cnt,complete_video_cnt,dt<br>–fields-terminated-by “t” –export-dir<br>“&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;tmp.db&#x2F;app_cource_study_analysis_${day}”<br>–staging-table app_cource_study_report_tmp –clear-staging-table<br>–input-null-string ‘N’</p>\n<h3 id=\"1-7-4-Sqoop底层运行的任务是什么\"><a href=\"#1-7-4-Sqoop底层运行的任务是什么\" class=\"headerlink\" title=\"1.7.4 Sqoop底层运行的任务是什么\"></a>1.7.4 Sqoop底层运行的任务是什么</h3><p>只有Map阶段，没有Reduce阶段的任务。默认是4个MapTask。</p>\n<h3 id=\"1-7-5-Sqoop一天导入多少数据\"><a href=\"#1-7-5-Sqoop一天导入多少数据\" class=\"headerlink\" title=\"1.7.5 Sqoop一天导入多少数据\"></a>1.7.5 Sqoop一天导入多少数据</h3><p>100万日活&#x3D;》10万订单，1人10条，每天1g左右业务数据</p>\n<p>Sqoop每天将1G的数据量导入到数仓。</p>\n<h3 id=\"1-7-6-Sqoop数据导出的时候一次执行多长时间\"><a href=\"#1-7-6-Sqoop数据导出的时候一次执行多长时间\" class=\"headerlink\" title=\"1.7.6 Sqoop数据导出的时候一次执行多长时间\"></a>1.7.6 Sqoop数据导出的时候一次执行多长时间</h3><p>每天晚上00:10开始执行，Sqoop任务一般情况20-30分钟的都有。取决于数据量（11.11，6.18等活动在1个小时左右）。</p>\n<h3 id=\"1-7-7-Sqoop在导入数据的时候数据倾斜\"><a href=\"#1-7-7-Sqoop在导入数据的时候数据倾斜\" class=\"headerlink\" title=\"1.7.7 Sqoop在导入数据的时候数据倾斜\"></a>1.7.7 Sqoop在导入数据的时候数据倾斜</h3><p>Sqoop参数撇嘴： split-by：按照自增主键来切分表的工作单元。</p>\n<p>num-mappers：启动N个map来并行导入数据，默认4个；</p>\n<h3 id=\"1-7-8-Sqoop数据导出Parquet（项目中遇到的问题）\"><a href=\"#1-7-8-Sqoop数据导出Parquet（项目中遇到的问题）\" class=\"headerlink\" title=\"1.7.8 Sqoop数据导出Parquet（项目中遇到的问题）\"></a>1.7.8 Sqoop数据导出Parquet（项目中遇到的问题）</h3><p>Ads层数据用Sqoop往MySql中导入数据的时候，如果用了orc（Parquet）不能导入，需转化成text格式</p>\n<p>（1）创建临时表，把Parquet中表数据导入到临时表，把临时表导出到目标表用于可视化</p>\n<p>（2）ads层建表的时候就不要建Parquet表</p>\n<h2 id=\"1-8-Azkaban\"><a href=\"#1-8-Azkaban\" class=\"headerlink\" title=\"1.8 Azkaban \"></a>1.8 Azkaban </h2><h3 id=\"1-8-1-每天集群运行多少指标\"><a href=\"#1-8-1-每天集群运行多少指标\" class=\"headerlink\" title=\"1.8.1 每天集群运行多少指标?\"></a>1.8.1 每天集群运行多少指标?</h3><p>每天跑100多个指标，有活动时跑200个左右。</p>\n<h3 id=\"1-8-2-任务挂了怎么办？\"><a href=\"#1-8-2-任务挂了怎么办？\" class=\"headerlink\" title=\"1.8.2 任务挂了怎么办？\"></a>1.8.2 任务挂了怎么办？</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1）运行成功或者失败都会发邮件、发钉钉、集成自动打电话<strong>（项目中遇到的问题）</strong></p>\n<p>2）最主要的解决方案就是重新跑。</p>\n<p>3）报警网站<a href=\"http://www.onealert.com/\">[http://www.onealert.com/]{.underline}</a></p></blockquote>\n<h2 id=\"1-9-HBase\"><a href=\"#1-9-HBase\" class=\"headerlink\" title=\"1.9 HBase\"></a>1.9 HBase</h2><h3 id=\"1-9-1-HBase存储结构\"><a href=\"#1-9-1-HBase存储结构\" class=\"headerlink\" title=\"1.9.1 HBase存储结构\"></a>1.9.1 HBase存储结构</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image35.png\"></p>\n<h3 id=\"1-9-2-RowKey设计原则\"><a href=\"#1-9-2-RowKey设计原则\" class=\"headerlink\" title=\"1.9.2 RowKey设计原则\"></a>1.9.2 RowKey设计原则</h3><p>1）rowkey长度原则</p>\n<p>2）rowkey散列原则</p>\n<p>3）rowkey唯一原则</p>\n<h3 id=\"1-9-3-RowKey如何设计\"><a href=\"#1-9-3-RowKey如何设计\" class=\"headerlink\" title=\"1.9.3 RowKey如何设计\"></a>1.9.3 RowKey如何设计</h3><p>使用场景:</p>\n<p>电信案例:查询某个人(手机号)某年<a href=\"%E6%97%B6%E9%97%B4\">某月某日</a>的通话详情。</p>\n<ol>\n<li>预分区</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>(1) 评估未来半年到一年的数据增长,不让其自动分区(10G)</p></blockquote>\n<p>(2) 确定分区键</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>00| 01| 02| …</p>\n<p>000| 001| …</p></blockquote>\n<ol start=\"2\">\n<li>设计RowKey</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>(1) 确定分区号 (散列性)</p>\n<p>00_ 01_ 02_…</p>\n<p>手机号%分区数 不够散列</p>\n<p>(手机号+年月日)%分区数 按照月份、年进行查询 不方便</p>\n<p>(手机号+年月)%分区数</p>\n<p>(2) 拼接字段 (唯一性、长度)</p>\n<p>XX_手机号_时间戳</p>\n<p>XX_手机号_年月日 时分秒</p>\n<p>XX_时间戳_手机号</p>\n<p>XX_年月日 时分秒_手机号</p>\n<p>(3) 校验</p>\n<p>13412341234 2021-09-07</p>\n<p>XX_手机号_年月日 时分秒</p>\n<p>startRow:05_13412341234_2021-09-07</p>\n<p>stopRow :05_13412341234_2021-09-08</p>\n<p>05_13412341234_2021-09-07|</p>\n<p>XX_年月日 时分秒_手机号</p>\n<p>startRow:05_2021-09-07 00:00:00_13412341234</p>\n<p>stopRow :05_2021-09-08 00:00:00_13412341234</p>\n<p>13412341234 2021-09 2021-11</p>\n<p>XX_手机号_年月日 时分秒</p>\n<p>startRow:05_13412341234_2021-09</p>\n<p>stopRow :05_13412341234_2021-09|</p>\n<p>05_13412341234_2021-10</p>\n<p>startRow:03_13412341234_2021-10</p>\n<p>stopRow :03_13412341234_2021-11</p>\n<p>startRow:04_13412341234_2021-11</p>\n<p>stopRow :04_13412341234_2021-12</p></blockquote>\n<h3 id=\"1-9-4-Phoenix二级索引（讲原理）\"><a href=\"#1-9-4-Phoenix二级索引（讲原理）\" class=\"headerlink\" title=\"1.9.4 Phoenix二级索引（讲原理）\"></a>1.9.4 Phoenix二级索引（讲原理）</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>一级索引</li>\n</ol>\n<p>RowKey</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>协处理器(HBase) coprocessor</p>\n<ol start=\"3\">\n<li>种类及用法</li>\n</ol>\n<p>(1) 全局:另外创建一张表专门存储索引</p>\n<p>读多写少 索引RowKey zs_1001</p>\n<p>(2) 本地:将索引数据直接写入原表(原Region)</p>\n<p>写多读少 索引RowKey 没有预分区 __zs_1001</p></blockquote>\n<p>预分区 分区键_zs_1001</p>\n<h2 id=\"1-10-Scala\"><a href=\"#1-10-Scala\" class=\"headerlink\" title=\"1.10 Scala\"></a>1.10 Scala</h2><h3 id=\"1-10-1-开发环境\"><a href=\"#1-10-1-开发环境\" class=\"headerlink\" title=\"1.10.1 开发环境\"></a>1.10.1 开发环境</h3><p>要求掌握必要的Scala开发环境搭建技能。</p>\n<h3 id=\"1-10-2-变量和数据类型\"><a href=\"#1-10-2-变量和数据类型\" class=\"headerlink\" title=\"1.10.2 变量和数据类型\"></a>1.10.2 变量和数据类型</h3><p>掌握var和val的区别</p>\n<p>掌握数值类型（Byte、Short、Int、Long、Float、Double、Char）之间的转换关系</p>\n<h3 id=\"1-10-3-流程控制\"><a href=\"#1-10-3-流程控制\" class=\"headerlink\" title=\"1.10.3 流程控制\"></a>1.10.3 流程控制</h3><p>掌握if-else、for、while等必要的流程控制结构，掌握如何实现break、continue的功能。</p>\n<h3 id=\"1-10-4-函数式编程\"><a href=\"#1-10-4-函数式编程\" class=\"headerlink\" title=\"1.10.4 函数式编程\"></a>1.10.4 函数式编程</h3><p>函数可以作为参数进行传递（spark 移动数据不如移动逻辑）</p>\n<p>_</p>\n<p>掌握高阶函数、匿名函数、函数柯里化、函数参数以及函数至简原则。</p>\n<h3 id=\"1-10-5-面向对象\"><a href=\"#1-10-5-面向对象\" class=\"headerlink\" title=\"1.10.5 面向对象\"></a>1.10.5 面向对象</h3><p>掌握Scala与Java继承方面的区别、单例对象（伴生对象）、特质的用法及功能。</p>\n<h3 id=\"1-10-6-集合\"><a href=\"#1-10-6-集合\" class=\"headerlink\" title=\"1.10.6 集合\"></a>1.10.6 集合</h3><p>map flatmap</p>\n<p>掌握常用集合的使用、集合常用的计算函数。</p>\n<h3 id=\"1-10-7-模式匹配\"><a href=\"#1-10-7-模式匹配\" class=\"headerlink\" title=\"1.10.7 模式匹配\"></a>1.10.7 模式匹配</h3><p>switch case 样例类</p>\n<p>掌握模式匹配的用法</p>\n<h3 id=\"1-10-8-异常\"><a href=\"#1-10-8-异常\" class=\"headerlink\" title=\"1.10.8 异常\"></a>1.10.8 异常</h3><p>掌握异常常用操作即可</p>\n<h3 id=\"1-10-9-隐式转换\"><a href=\"#1-10-9-隐式转换\" class=\"headerlink\" title=\"1.10.9 隐式转换\"></a>1.10.9 隐式转换</h3><p>掌握隐式方法、隐式参数、隐式类，以及隐式解析机制</p>\n<h3 id=\"1-10-10-泛型\"><a href=\"#1-10-10-泛型\" class=\"headerlink\" title=\"1.10.10 泛型\"></a>1.10.10 泛型</h3><p>掌握泛型语法</p>\n<h2 id=\"1-11-Spark-Core-amp-SQL\"><a href=\"#1-11-Spark-Core-amp-SQL\" class=\"headerlink\" title=\"1.11 Spark Core &amp; SQL\"></a>1.11 Spark Core &amp; SQL</h2><h3 id=\"1-11-1-Spark解决什么问题\"><a href=\"#1-11-1-Spark解决什么问题\" class=\"headerlink\" title=\"1.11.1 Spark解决什么问题\"></a>1.11.1 Spark解决什么问题</h3><p>回顾：Hadoop主要解决，海量数据的存储和海量数据的分析计算。</p>\n<p>Spark主要解决海量数据的分析计算。</p>\n<h3 id=\"1-11-2-Spark为什么会有自己的资源调度器\"><a href=\"#1-11-2-Spark为什么会有自己的资源调度器\" class=\"headerlink\" title=\"1.11.2 Spark为什么会有自己的资源调度器\"></a>1.11.2 Spark为什么会有自己的资源调度器</h3><p>Hadoop的Yarn框架比Spark框架诞生的晚，所以Spark自己也设计了一套资源调度框架。</p>\n<h3 id=\"1-11-3-Spark运行模式\"><a href=\"#1-11-3-Spark运行模式\" class=\"headerlink\" title=\"1.11.3 Spark运行模式\"></a>1.11.3 Spark运行模式</h3><p>1）Local：运行在一台机器上。 测试用。</p>\n<p>2）Standalone：是Spark自身的一个调度系统。<br>对集群性能要求非常高时用。国内很少使用。</p>\n<p>3）Yarn：采用Hadoop的资源调度器。 国内大量使用。</p>\n<p>4）Mesos：国内很少使用。</p>\n<h3 id=\"1-11-4-Spark常用端口号\"><a href=\"#1-11-4-Spark常用端口号\" class=\"headerlink\" title=\"1.11.4 Spark常用端口号\"></a>1.11.4 Spark常用端口号</h3><p>1）4040 spark-shell任务端口</p>\n<p>2）7077 内部通讯端口。 类比Hadoop的8020&#x2F;9000</p>\n<p>3）8080 查看任务执行情况端口。 类比Hadoop的8088</p>\n<p>4）18080 历史服务器。类比Hadoop的19888</p>\n<p>注意：由于Spark只负责计算，所有并没有Hadoop中存储数据的端口50070</p>\n<h3 id=\"1-11-5-简述Spark的架构与作业提交流程（画图讲解，注明各个部分的作用）（重点）\"><a href=\"#1-11-5-简述Spark的架构与作业提交流程（画图讲解，注明各个部分的作用）（重点）\" class=\"headerlink\" title=\"1.11.5 简述Spark的架构与作业提交流程（画图讲解，注明各个部分的作用）（重点）\"></a>1.11.5 简述Spark的架构与作业提交流程（画图讲解，注明各个部分的作用）（重点）</h3><h3 id=\"1-11-6-Spark任务使用什么进行提交，JavaEE界面还是脚本\"><a href=\"#1-11-6-Spark任务使用什么进行提交，JavaEE界面还是脚本\" class=\"headerlink\" title=\"1.11.6 Spark任务使用什么进行提交，JavaEE界面还是脚本\"></a>1.11.6 Spark任务使用什么进行提交，JavaEE界面还是脚本</h3><p>Shell脚本。</p>\n<h3 id=\"1-11-7-Spark提交作业参数（重点）\"><a href=\"#1-11-7-Spark提交作业参数（重点）\" class=\"headerlink\" title=\"1.11.7 Spark提交作业参数（重点）\"></a>1.11.7 Spark提交作业参数（重点）</h3><p>参考答案：</p>\n<p><a href=\"https://blog.csdn.net/gamer_gyt/article/details/79135118\">https://blog.csdn.net/gamer_gyt/article/details/79135118</a></p>\n<p>1）在提交任务时的几个重要参数</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>executor-cores ——<br>每个executor使用的内核数，默认为1，官方建议2-5个，我们企业是4个</p>\n<p>num-executors —— 启动executors的数量，默认为2</p>\n<p>executor-memory —— executor内存大小，默认1G</p>\n<p>driver-cores —— driver使用内核数，默认为1</p>\n<p>driver-memory —— driver内存大小，默认512M</p></blockquote>\n<p>2）边给一个提交任务的样式</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>spark-submit </p>\n<p>–master local[5] </p>\n<p>–driver-cores 2 </p>\n<p>–driver-memory 8g </p>\n<p>–executor-cores 4 </p>\n<p>–num-executors 10 </p>\n<p>–executor-memory 8g </p>\n<p>–class PackageName.ClassName XXXX.jar </p>\n<p>–name “Spark Job Name” </p>\n<p>InputPath </p>\n<p>OutputPath</p></blockquote>\n<h3 id=\"1-11-8-RDD五大属性\"><a href=\"#1-11-8-RDD五大属性\" class=\"headerlink\" title=\"1.11.8 RDD五大属性\"></a>1.11.8 RDD五大属性</h3><h3 id=\"1-11-9-Spark的transformation算子（不少于8个）（重点）\"><a href=\"#1-11-9-Spark的transformation算子（不少于8个）（重点）\" class=\"headerlink\" title=\"1.11.9 Spark的transformation算子（不少于8个）（重点）\"></a>1.11.9 Spark的transformation算子（不少于8个）（重点）</h3><p>1）单Value</p>\n<p>（1）map</p>\n<p>（2）mapPartitions</p>\n<p>（3）mapPartitionsWithIndex</p>\n<p>（4）flatMap</p>\n<p>（5）glom</p>\n<p>（6）groupBy</p>\n<p>（7）filter</p>\n<p>（8）sample</p>\n<p>（9）distinct</p>\n<p>（10）coalesce</p>\n<p>（11）repartition</p>\n<p>（12）sortBy</p>\n<p>（13）pipe</p>\n<p>2）双vlaue</p>\n<p>（1）intersection</p>\n<p>（2）union</p>\n<p>（3）subtract</p>\n<p>（4）zip</p>\n<p>3）Key-Value</p>\n<p>（1）partitionBy</p>\n<p>（2）reduceByKey</p>\n<p>（3）groupByKey</p>\n<p>（4）aggregateByKey</p>\n<p>（5）foldByKey</p>\n<p>（6）combineByKey</p>\n<p>（7）sortByKey</p>\n<p>（8）mapValues</p>\n<p>（9）join</p>\n<p>（10）cogroup</p>\n<h3 id=\"1-11-10-Spark的action算子（不少于6个）（重点）\"><a href=\"#1-11-10-Spark的action算子（不少于6个）（重点）\" class=\"headerlink\" title=\"1.11.10 Spark的action算子（不少于6个）（重点）\"></a>1.11.10 Spark的action算子（不少于6个）（重点）</h3><p>（1）reduce</p>\n<p>（2）collect</p>\n<p>（3）count</p>\n<p>（4）first</p>\n<p>（5）take</p>\n<p>（6）takeOrdered</p>\n<p>（7）aggregate</p>\n<p>（8）fold</p>\n<p>（9）countByKey</p>\n<p>（10）save</p>\n<p>（11）foreach</p>\n<h3 id=\"1-11-11-map和mapPartitions区别\"><a href=\"#1-11-11-map和mapPartitions区别\" class=\"headerlink\" title=\"1.11.11 map和mapPartitions区别\"></a>1.11.11 map和mapPartitions区别</h3><p>1）map：每次处理一条数据</p>\n<p>2）mapPartitions：每次处理一个分区数据</p>\n<h3 id=\"1-11-12-Repartition和Coalesce区别\"><a href=\"#1-11-12-Repartition和Coalesce区别\" class=\"headerlink\" title=\"1.11.12 Repartition和Coalesce区别\"></a>1.11.12 Repartition和Coalesce区别</h3><p>1）关系：</p>\n<p>两者都是用来改变RDD的partition数量的，repartition底层调用的就是coalesce方法：coalesce(numPartitions,<br>shuffle &#x3D; true)</p>\n<p>2）区别：</p>\n<p>repartition一定会发生shuffle，coalesce根据传入的参数来判断是否发生shuffle</p>\n<p>一般情况下增大rdd的partition数量使用repartition，减少partition数量时使用coalesce</p>\n<h3 id=\"1-11-13-reduceByKey与groupByKey的区别\"><a href=\"#1-11-13-reduceByKey与groupByKey的区别\" class=\"headerlink\" title=\"1.11.13 reduceByKey与groupByKey的区别\"></a>1.11.13 reduceByKey与groupByKey的区别</h3><p>reduceByKey：具有预聚合操作</p>\n<p>groupByKey：没有预聚合</p>\n<p>在不影响业务逻辑的前提下，优先采用reduceByKey。</p>\n<h3 id=\"1-11-14-reduceByKey、foldByKey、aggregateByKey、combineByKey区别\"><a href=\"#1-11-14-reduceByKey、foldByKey、aggregateByKey、combineByKey区别\" class=\"headerlink\" title=\"1.11.14 reduceByKey、foldByKey、aggregateByKey、combineByKey区别\"></a>1.11.14 reduceByKey、foldByKey、aggregateByKey、combineByKey区别</h3><p>ReduceByKey 没有初始值 分区内和分区间逻辑相同</p>\n<p>foldByKey 有初始值 分区内和分区间逻辑相同</p>\n<p>aggregateByKey 有初始值 分区内和分区间逻辑可以不同</p>\n<p>combineByKey 初始值可以变化结构 分区内和分区间逻辑不同</p>\n<h3 id=\"1-11-15-Kryo序列化\"><a href=\"#1-11-15-Kryo序列化\" class=\"headerlink\" title=\"1.11.15 Kryo序列化\"></a>1.11.15 Kryo序列化</h3><p>Kryo序列化比Java序列化更快更紧凑，但Spark默认的序列化是Java序列化并不是Spark序列化，因为Spark并不支持所有序列化类型，而且每次使用都必须进行注册。注册只针对于RDD。在DataFrames和DataSet当中自动实现了Kryo序列化。</p>\n<h3 id=\"1-11-16-Spark中的血缘（笔试重点）\"><a href=\"#1-11-16-Spark中的血缘（笔试重点）\" class=\"headerlink\" title=\"1.11.16 Spark中的血缘（笔试重点）\"></a>1.11.16 Spark中的血缘（笔试重点）</h3><p>宽依赖和窄依赖。有Shuffle的是宽依赖。</p>\n<h3 id=\"1-11-17-Spark任务的划分\"><a href=\"#1-11-17-Spark任务的划分\" class=\"headerlink\" title=\"1.11.17 Spark任务的划分\"></a>1.11.17 Spark任务的划分</h3><p>（1）Application：初始化一个SparkContext即生成一个Application；</p>\n<p>（2）Job：一个Action算子就会生成一个Job；</p>\n<p>（3）Stage：Stage等于宽依赖的个数加1；</p>\n<p>（4）Task：一个Stage阶段中，最后一个RDD的分区个数就是Task的个数。</p>\n<h3 id=\"1-11-18-cache缓存级别\"><a href=\"#1-11-18-cache缓存级别\" class=\"headerlink\" title=\"1.11.18 cache缓存级别\"></a>1.11.18 cache缓存级别</h3><p>DataFrame的cache默认采用 MEMORY_AND_DISK</p>\n<p>RDD 的cache默认方式采用MEMORY_ONLY</p>\n<h3 id=\"1-11-19-释放缓存和缓存\"><a href=\"#1-11-19-释放缓存和缓存\" class=\"headerlink\" title=\"1.11.19 释放缓存和缓存\"></a>1.11.19 释放缓存和缓存</h3><p>缓存：(1)dataFrame.cache (2)sparkSession.catalog.cacheTable(“tableName”)</p>\n<p>释放缓存：(1)dataFrame.unpersist<br>(2)sparkSession.catalog.uncacheTable(“tableName”)</p>\n<h3 id=\"1-11-20-缓存和检查点区别\"><a href=\"#1-11-20-缓存和检查点区别\" class=\"headerlink\" title=\"1.11.20 缓存和检查点区别\"></a>1.11.20 缓存和检查点区别</h3><p>1）Cache缓存只是将数据保存起来，不切断血缘依赖。Checkpoint检查点切断血缘依赖。</p>\n<p>2）Cache缓存的数据通常存储在磁盘、内存等地方，可靠性低。Checkpoint的数据通常存储在HDFS等容错、高可用的文件系统，可靠性高。</p>\n<p>3）建议对checkpoint()的RDD使用Cache缓存，这样checkpoint的job只需从Cache缓存中读取数据即可，否则需要再从头计算一次RDD。</p>\n<h3 id=\"1-11-21-Spark分区\"><a href=\"#1-11-21-Spark分区\" class=\"headerlink\" title=\"1.11.21 Spark分区\"></a>1.11.21 Spark分区</h3><p>1）默认采用Hash分区</p>\n<p>缺点：可能导致每个分区中数据量的不均匀，极端情况下会导致某些分区拥有RDD的全部数据。</p>\n<p>2）Ranger分区</p>\n<p>要求RDD中的KEY类型必须可以排序。</p>\n<p>3）自定义分区</p>\n<p>根据需求，自定义分区。</p>\n<h3 id=\"1-11-22-Spark累加器\"><a href=\"#1-11-22-Spark累加器\" class=\"headerlink\" title=\"1.11.22 Spark累加器\"></a>1.11.22 Spark累加器</h3><h3 id=\"1-11-23-Spark广播变量\"><a href=\"#1-11-23-Spark广播变量\" class=\"headerlink\" title=\"1.11.23 Spark广播变量\"></a>1.11.23 Spark广播变量</h3><h3 id=\"1-11-24-SparkSQL中RDD、DataFrame、DataSet三者的转换-（笔试重点）\"><a href=\"#1-11-24-SparkSQL中RDD、DataFrame、DataSet三者的转换-（笔试重点）\" class=\"headerlink\" title=\"1.11.24 SparkSQL中RDD、DataFrame、DataSet三者的转换 （笔试重点）\"></a>1.11.24 SparkSQL中RDD、DataFrame、DataSet三者的转换 （笔试重点）</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image42.png\">{width&#x3D;”5.6715277777777775in”<br>height&#x3D;”3.1569444444444446in”}</p>\n<h3 id=\"1-11-25-请列举会引起Shuffle过程的Spark算子，并简述功能。\"><a href=\"#1-11-25-请列举会引起Shuffle过程的Spark算子，并简述功能。\" class=\"headerlink\" title=\"1.11.25 请列举会引起Shuffle过程的Spark算子，并简述功能。\"></a>1.11.25 请列举会引起Shuffle过程的Spark算子，并简述功能。</h3><p>reduceBykey：</p>\n<p>groupByKey：</p>\n<p>…ByKey:</p>\n<h3 id=\"1-11-26-当Spark涉及到数据库的操作时，如何减少Spark运行中的数据库连接数？\"><a href=\"#1-11-26-当Spark涉及到数据库的操作时，如何减少Spark运行中的数据库连接数？\" class=\"headerlink\" title=\"1.11.26 当Spark涉及到数据库的操作时，如何减少Spark运行中的数据库连接数？\"></a>1.11.26 当Spark涉及到数据库的操作时，如何减少Spark运行中的数据库连接数？</h3><p>使用foreachPartition代替foreach，在foreachPartition内获取数据库的连接。</p>\n<h3 id=\"1-11-27-如何使用Spark实现TopN的获取（描述思路或使用伪代码）（重点）\"><a href=\"#1-11-27-如何使用Spark实现TopN的获取（描述思路或使用伪代码）（重点）\" class=\"headerlink\" title=\"1.11.27 如何使用Spark实现TopN的获取（描述思路或使用伪代码）（重点）\"></a>1.11.27 如何使用Spark实现TopN的获取（描述思路或使用伪代码）（重点）</h3><p>方法1：</p>\n<p>（1）按照key对数据进行聚合（groupByKey）</p>\n<p>（2）将value转换为数组，利用scala的sortBy或者sortWith进行排序（mapValues）数据量太大，会OOM。</p>\n<p>方法2：</p>\n<p>（1）取出所有的key</p>\n<p>（2）对key进行迭代，每次取出一个key利用spark的排序算子进行排序</p>\n<p>方法3：</p>\n<p>（1）自定义分区器，按照key进行分区，使不同的key进到不同的分区</p>\n<p>（2）对每个分区运用spark的排序算子进行排序</p>\n<h3 id=\"1-11-28-京东：调优之前与调优之后性能的详细对比（例如调整map个数，map个数之前多少、之后多少，有什么提升）\"><a href=\"#1-11-28-京东：调优之前与调优之后性能的详细对比（例如调整map个数，map个数之前多少、之后多少，有什么提升）\" class=\"headerlink\" title=\"1.11.28 京东：调优之前与调优之后性能的详细对比（例如调整map个数，map个数之前多少、之后多少，有什么提升）\"></a>1.11.28 京东：调优之前与调优之后性能的详细对比（例如调整map个数，map个数之前多少、之后多少，有什么提升）</h3><p>这里举个例子。比如我们有几百个文件，会有几百个map出现，读取之后进行join操作，会非常的慢。这个时候我们可以进行coalesce操作，比如240个map，我们合成60个map，也就是窄依赖。这样再shuffle，过程产生的文件数会大大减少。提高join的时间性能。</p>\n<h3 id=\"1-11-29-Spark-Shuffle默认并行度\"><a href=\"#1-11-29-Spark-Shuffle默认并行度\" class=\"headerlink\" title=\"1.11.29 Spark Shuffle默认并行度\"></a>1.11.29 Spark Shuffle默认并行度</h3><p>参数spark.sql.shuffle.partitions 决定 默认并行度200</p>\n<h3 id=\"1-11-30-控制Spark-reduce缓存-调优shuffle\"><a href=\"#1-11-30-控制Spark-reduce缓存-调优shuffle\" class=\"headerlink\" title=\"1.11.30 控制Spark reduce缓存 调优shuffle\"></a>1.11.30 控制Spark reduce缓存 调优shuffle</h3><p>spark.reducer.maxSizeInFilght 此参数为reduce<br>task能够拉取多少数据量的一个参数默认48MB，当集群资源足够时，增大此参数可减少reduce拉取数据量的次数，从而达到优化shuffle的效果，一般调大为96MB,，资源够大可继续往上调。</p>\n<p>spark.shuffle.file.buffer<br>此参数为每个shuffle文件输出流的内存缓冲区大小，调大此参数可以减少在创建shuffle文件时进行磁盘搜索和系统调用的次数，默认参数为32k<br>一般调大为64k。</p>\n<h3 id=\"1-11-31-Spark内核源码（重点）\"><a href=\"#1-11-31-Spark内核源码（重点）\" class=\"headerlink\" title=\"1.11.31 Spark内核源码（重点）\"></a>1.11.31 Spark内核源码（重点）</h3><h2 id=\"1-12-Spark-Streaming\"><a href=\"#1-12-Spark-Streaming\" class=\"headerlink\" title=\"1.12 Spark Streaming\"></a>1.12 Spark Streaming</h2><h3 id=\"1-12-1-Spark-Streaming第一次运行不丢失数据\"><a href=\"#1-12-1-Spark-Streaming第一次运行不丢失数据\" class=\"headerlink\" title=\"1.12.1 Spark Streaming第一次运行不丢失数据\"></a>1.12.1 Spark Streaming第一次运行不丢失数据</h3><p>kafka参数 auto.offset.reset 参数设置成earliest<br>从最初始偏移量开始消费数据</p>\n<h3 id=\"1-12-2-Spark-Streaming精准一次消费\"><a href=\"#1-12-2-Spark-Streaming精准一次消费\" class=\"headerlink\" title=\"1.12.2 Spark Streaming精准一次消费\"></a>1.12.2 Spark Streaming精准一次消费</h3><ol>\n<li><p>手动维护偏移量</p>\n</li>\n<li><p>处理完业务数据后，再进行提交偏移量操作</p>\n</li>\n</ol>\n<p>极端情况下，如在提交偏移量时断网或停电会造成spark程序第二次启动时重复消费问题，所以在涉及到金额或精确性非常高的场景会使用事物保证精准一次消费</p>\n<h3 id=\"1-12-3-Spark-Streaming控制每秒消费数据的速度\"><a href=\"#1-12-3-Spark-Streaming控制每秒消费数据的速度\" class=\"headerlink\" title=\"1.12.3 Spark Streaming控制每秒消费数据的速度\"></a>1.12.3 Spark Streaming控制每秒消费数据的速度</h3><p>通过spark.streaming.kafka.maxRatePerPartition参数来设置Spark<br>Streaming从kafka分区每秒拉取的条数</p>\n<h3 id=\"1-12-4-Spark-Streaming背压机制\"><a href=\"#1-12-4-Spark-Streaming背压机制\" class=\"headerlink\" title=\"1.12.4 Spark Streaming背压机制\"></a>1.12.4 Spark Streaming背压机制</h3><p>把spark.streaming.backpressure.enabled<br>参数设置为ture，开启背压机制后Spark<br>Streaming会根据延迟动态去kafka消费数据，上限由spark.streaming.kafka.maxRatePerPartition参数控制，所以两个参数一般会一起使用。</p>\n<h3 id=\"1-12-5-Spark-Streaming一个stage耗时\"><a href=\"#1-12-5-Spark-Streaming一个stage耗时\" class=\"headerlink\" title=\"1.12.5 Spark Streaming一个stage耗时\"></a>1.12.5 Spark Streaming一个stage耗时</h3><p>Spark Streaming<br>stage耗时由最慢的task决定，所以数据倾斜时某个task运行慢会导致整个Spark<br>Streaming都运行非常慢。</p>\n<h3 id=\"1-12-6-Spark-Streaming优雅关闭\"><a href=\"#1-12-6-Spark-Streaming优雅关闭\" class=\"headerlink\" title=\"1.12.6 Spark Streaming优雅关闭\"></a>1.12.6 Spark Streaming优雅关闭</h3><p>把spark.streaming.stopGracefullyOnShutdown参数设置成ture，Spark会在JVM关闭时正常关闭StreamingContext，而不是立马关闭</p>\n<p>Kill 命令：yarn application -kill 后面跟 applicationid</p>\n<h3 id=\"1-12-7-Spark-Streaming默认分区个数\"><a href=\"#1-12-7-Spark-Streaming默认分区个数\" class=\"headerlink\" title=\"1.12.7 Spark Streaming默认分区个数\"></a>1.12.7 Spark Streaming默认分区个数</h3><p>Spark Streaming默认分区个数与所对接的kafka topic分区个数一致，Spark<br>Streaming里一般不会使用repartition算子增大分区，因为repartition会进行shuffle增加耗时。</p>\n<h3 id=\"1-12-8-SparkStreaming有哪几种方式消费Kafka中的数据，它们之间的区别是什么？\"><a href=\"#1-12-8-SparkStreaming有哪几种方式消费Kafka中的数据，它们之间的区别是什么？\" class=\"headerlink\" title=\"1.12.8 SparkStreaming有哪几种方式消费Kafka中的数据，它们之间的区别是什么？\"></a>1.12.8 SparkStreaming有哪几种方式消费Kafka中的数据，它们之间的区别是什么？</h3><p><strong>一、基于Receiver的方式</strong></p>\n<p>这种方式使用Receiver来获取数据。Receiver是使用Kafka的高层次Consumer<br>API来实现的。receiver从Kafka中获取的数据都是存储在Spark<br>Executor的内存中的（如果突然数据暴增，大量batch堆积，很容易出现内存溢出的问题），然后Spark<br>Streaming启动的job会去处理那些数据。</p>\n<p>然而，在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用Spark<br>Streaming的预写日志机制（Write Ahead<br>Log，WAL）。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。</p>\n<p><strong>二、基于Direct的方式</strong></p>\n<p>这种新的不基于Receiver的直接方式，是在Spark<br>1.3中引入的，从而能够确保更加健壮的机制。替代掉使用Receiver来接收数据后，这种方式会周期性地查询Kafka，来获得每个topic+partition的最新的offset，从而定义每个batch的offset的范围。当处理数据的job启动时，就会使用Kafka的简单consumer<br>api来获取Kafka指定offset范围的数据。</p>\n<p>**优点如下： **</p>\n<p><strong>简化并行读取：</strong>如果要读取多个partition，不需要创建多个输入DStream然后对它们进行union操作。Spark会创建跟Kafka<br>partition一样多的RDD partition，并且会并行从Kafka中读取数据。所以在Kafka<br>partition和RDD partition之间，有一个一对一的映射关系。</p>\n<p><strong>高性能：</strong>如果要保证零数据丢失，在基于receiver的方式中，需要开启WAL机制。这种方式其实效率低下，因为数据实际上被复制了两份，Kafka自己本身就有高可靠的机制，会对数据复制一份，而这里又会复制一份到WAL中。而基于direct的方式，不依赖Receiver，不需要开启WAL机制，只要Kafka中作了数据的复制，那么就可以通过Kafka的副本进行恢复。</p>\n<p><strong>一次且仅一次的事务机制</strong>。</p>\n<p><strong>三、对比：</strong></p>\n<p>基于receiver的方式，是使用Kafka的高阶API来在ZooKeeper中保存消费过的offset的。这是消费Kafka数据的传统方式。这种方式配合着WAL机制可以保证数据零丢失的高可靠性，但是却无法保证数据被处理一次且仅一次，可能会处理两次。因为Spark和ZooKeeper之间可能是不同步的。</p>\n<p>基于direct的方式，使用kafka的简单api，Spark<br>Streaming自己就负责追踪消费的offset，并保存在checkpoint中。Spark自己一定是同步的，因此可以保证数据是消费一次且仅消费一次。</p>\n<p>在实际生产环境中大都用Direct方式</p>\n<h3 id=\"1-12-9-简述SparkStreaming窗口函数的原理（重点）\"><a href=\"#1-12-9-简述SparkStreaming窗口函数的原理（重点）\" class=\"headerlink\" title=\"1.12.9 简述SparkStreaming窗口函数的原理（重点）\"></a>1.12.9 简述SparkStreaming窗口函数的原理（重点）</h3><p>窗口函数就是在原来定义的SparkStreaming计算批次大小的基础上再次进行封装，每次计算多个批次的数据，同时还需要传递一个滑动步长的参数，用来设置当次计算任务完成之后下一次从什么地方开始计算。</p>\n<p>图中time1就是SparkStreaming计算批次大小，虚线框以及实线大框就是窗口的大小，必须为批次的整数倍。虚线框到大实线框的距离（相隔多少批次），就是滑动步长。</p>\n<h2 id=\"1-13-数据倾斜\"><a href=\"#1-13-数据倾斜\" class=\"headerlink\" title=\"1.13 数据倾斜\"></a>1.13 数据倾斜</h2><p>公司一：总用户量1000万，5台64G内存的服务器。</p>\n<p>公司二：总用户量10亿，1000台64G内存的服务器。</p>\n<p>1.公司一的数据分析师在做join的时候发生了数据倾斜，会导致有几百万用户的相关数据集中到了一台服务器上，几百万的用户数据，说大也不大，正常字段量的数据的话64G还是能轻松处理掉的。</p>\n<p>2.公司二的数据分析师在做join的时候也发生了数据倾斜，可能会有1个亿的用户相关数据集中到了一台机器上了（相信我，这很常见）。这时候一台机器就很难搞定了，最后会很难算出结果。</p>\n<h3 id=\"1-13-1-数据倾斜表现\"><a href=\"#1-13-1-数据倾斜表现\" class=\"headerlink\" title=\"1.13.1 数据倾斜表现\"></a>1.13.1 数据倾斜表现</h3><p>1）hadoop中的数据倾斜表现：</p>\n<ul>\n<li><p>有一个多几个Reduce卡住，卡在99.99%，一直不能结束。</p>\n</li>\n<li><p>各种container报错OOM</p>\n</li>\n<li><p>异常的Reducer读写的数据量极大，至少远远超过其它正常的Reducer</p>\n</li>\n<li><p>伴随着数据倾斜，会出现任务被kill等各种诡异的表现。</p>\n</li>\n</ul>\n<p>2）hive中数据倾斜</p>\n<p>一般都发生在Sql中group by和join on上，而且和数据逻辑绑定比较深。</p>\n<p>3）Spark中的数据倾斜</p>\n<p>Spark中的数据倾斜，包括Spark Streaming和Spark Sql，表现主要有下面几种：</p>\n<ul>\n<li><p>Executor lost，OOM，Shuffle过程出错；</p>\n</li>\n<li><p>Driver OOM；</p>\n</li>\n<li><p>单个Executor执行时间特别久，整体任务卡在某个阶段不能结束；</p>\n</li>\n<li><p>正常运行的任务突然失败；</p>\n</li>\n</ul>\n<h3 id=\"1-13-2-数据倾斜产生原因\"><a href=\"#1-13-2-数据倾斜产生原因\" class=\"headerlink\" title=\"1.13.2 数据倾斜产生原因\"></a>1.13.2 数据倾斜产生原因</h3><p>我们以Spark和Hive的使用场景为例。</p>\n<p>他们在做数据运算的时候会涉及到，count distinct、group by、join<br>on等操作，这些都会触发Shuffle动作。一旦触发Shuffle，所有相同key的值就会被拉到一个或几个Reducer节点上，容易发生单点计算问题，导致数据倾斜。</p>\n<p>一般来说，数据倾斜原因有以下几方面：</p>\n<p><strong>1）key分布不均匀；</strong></p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image50.png\">{width&#x3D;”4.779166666666667in”<br>height&#x3D;”3.988888888888889in”}</p>\n<p><strong>2）建表时考虑不周</strong></p>\n<p>我们举一个例子，就说数据默认值的设计吧，假设我们有两张表：</p>\n<p>user（用户信息表）：userid，register_ip</p>\n<p>ip（IP表）：ip，register_user_cnt</p>\n<p>这可能是两个不同的人开发的数据表。如果我们的数据规范不太完善的话，会出现一种情况：</p>\n<p>user表中的register_ip字段，如果获取不到这个信息，我们默认为null；</p>\n<p>但是在ip表中，我们在统计这个值的时候，为了方便，我们把获取不到ip的用户，统一认为他们的ip为0。</p>\n<p>两边其实都没有错的，但是一旦我们做关联了，这个任务会在做关联的阶段，也就是sql的on的阶段卡死。</p>\n<p><strong>3）业务数据激增</strong></p>\n<p>比如订单场景，我们在某一天在北京和上海两个城市多了强力的推广，结果可能是这两个城市的订单量增长了10000%，其余城市的数据量不变。</p>\n<p>然后我们要统计不同城市的订单情况，这样，一做group操作，可能直接就数据倾斜了。</p>\n<h3 id=\"1-13-3-解决数据倾斜思路\"><a href=\"#1-13-3-解决数据倾斜思路\" class=\"headerlink\" title=\"1.13.3 解决数据倾斜思路\"></a>1.13.3 解决数据倾斜思路</h3><p>很多数据倾斜的问题，都可以用和平台无关的方式解决，比如更好的<strong>数据预处理</strong>，<strong>异常值的过滤</strong>等。因此，解决数据倾斜的重点在于对数据设计和业务的理解，这两个搞清楚了，数据倾斜就解决了大部分了。</p>\n<p><strong>1）业务逻辑</strong></p>\n<p>我们从业务逻辑的层面上来优化数据倾斜，比如上面的两个城市做推广活动导致那两个城市数据量激增的例子，我们可以单独对这两个城市来做count，单独做时可用两次MR，第一次打散计算，第二次再最终聚合计算。完成后和其它城市做整合。</p>\n<p><strong>2）程序层面</strong></p>\n<p>比如说在Hive中，经常遇到count(distinct)操作，这样会导致最终只有一个Reduce任务。</p>\n<p>我们可以先group<br>by，再在外面包一层count，就可以了。比如计算按用户名去重后的总用户量：</p>\n<p>（1）优化前 只有一个reduce，先去重再count负担比较大：</p>\n<p>select name,count(distinct name)from user;</p>\n<p>（2）优化后</p>\n<p>&#x2F;&#x2F; 设置该任务的每个job的reducer个数为3个。Hive默认-1，自动推断。</p>\n<p>set mapred.reduce.tasks&#x3D;3;</p>\n<p>&#x2F;&#x2F; 启动两个job，一个负责子查询(可以有多个reduce)，另一个负责count(1)：</p>\n<p>select count(1) from (select name from user group by name) tmp;</p>\n<p><strong>3）调参方面</strong></p>\n<p>Hadoop和Spark都自带了很多的参数和机制来调节数据倾斜，合理利用它们就能解决大部分问题。</p>\n<p><strong>4）从业务和数据上解决数据倾斜</strong></p>\n<p>很多数据倾斜都是在数据的使用上造成的。我们举几个场景，并分别给出它们的解决方案。</p>\n<ul>\n<li><p>有损的方法：找到异常数据，比如ip为0的数据，过滤掉</p>\n</li>\n<li><p>无损的方法：对分布不均匀的数据，单独计算</p>\n</li>\n<li><p>先对key做一层hash，先将数据随机打散让它的并行度变大，再汇集</p>\n</li>\n<li><p>数据预处理</p>\n</li>\n</ul>\n<h3 id=\"1-13-4-定位导致数据倾斜代码\"><a href=\"#1-13-4-定位导致数据倾斜代码\" class=\"headerlink\" title=\"1.13.4 定位导致数据倾斜代码\"></a>1.13.4 定位导致数据倾斜代码</h3><p>Spark数据倾斜只会发生在shuffle过程中。</p>\n<p>这里给大家罗列一些常用的并且可能会触发shuffle操作的算子：distinct、groupByKey、reduceByKey、aggregateByKey、join、cogroup、repartition等。</p>\n<p>出现数据倾斜时，可能就是你的代码中使用了这些算子中的某一个所导致的。</p>\n<h4 id=\"1-13-4-1-某个task执行特别慢的情况\"><a href=\"#1-13-4-1-某个task执行特别慢的情况\" class=\"headerlink\" title=\"1.13.4.1 某个task执行特别慢的情况\"></a>1.13.4.1 某个task执行特别慢的情况</h4><p>首先要看的，就是数据倾斜发生在第几个stage中：</p>\n<p>如果是用yarn-client模式提交，那么在提交的机器本地是直接可以看到log，可以在log中找到当前运行到了第几个stage；</p>\n<p>如果是用yarn-cluster模式提交，则可以通过Spark Web<br>UI来查看当前运行到了第几个stage。</p>\n<p>此外，无论是使用yarn-client模式还是yarn-cluster模式，我们都可以在Spark<br>Web<br>UI上深入看一下当前这个stage各个task分配的数据量，从而进一步确定是不是task分配的数据不均匀导致了数据倾斜。</p>\n<p>看task运行时间和数据量</p>\n<p>task运行时间</p>\n<p>比如下图中，倒数第三列显示了每个task的运行时间。明显可以看到，有的task运行特别快，只需要几秒钟就可以运行完；而有的task运行特别慢，需要几分钟才能运行完，此时单从运行时间上看就已经能够确定发生数据倾斜了。</p>\n<p>task数据量</p>\n<p>此外，倒数第一列显示了每个task处理的数据量，明显可以看到，运行时间特别短的task只需要处理几百KB的数据即可，而运行时间特别长的task需要处理几千KB的数据，处理的数据量差了10倍。此时更加能够确定是发生了数据倾斜。</p>\n<p>推断倾斜代码</p>\n<p>知道数据倾斜发生在哪一个stage之后，接着我们就需要根据stage划分原理，推算出来发生倾斜的那个stage对应代码中的哪一部分，这部分代码中肯定会有一个shuffle类算子。</p>\n<p>精准推算stage与代码的对应关系，需要对Spark的源码有深入的理解，这里我们可以介绍一个相对简单实用的推算方法：只要看到Spark代码中出现了一个shuffle类算子或者是Spark<br>SQL的SQL语句中出现了会导致shuffle的语句（比如group<br>by语句），那么就可以判定，以那个地方为界限划分出了前后两个stage。</p>\n<p>这里我们就以如下单词计数来举例。</p>\n<p>val conf &#x3D; new SparkConf()val sc &#x3D; new SparkContext(conf)val lines &#x3D;<br>sc.textFile(“hdfs:&#x2F;&#x2F;…”)val words &#x3D; lines.flatMap(<em>.split(“<br>“))val pairs &#x3D; words.map((</em>, 1))val wordCounts &#x3D; pairs.reduceByKey(_</p>\n<ul>\n<li><em>)wordCounts.collect().foreach(println(</em>))</li>\n</ul>\n<p>在整个代码中只有一个reduceByKey是会发生shuffle的算子，也就是说这个算子为界限划分出了前后两个stage：</p>\n<p>stage0，主要是执行从textFile到map操作，以及shuffle write操作（对pairs<br>RDD中的数据进行分区操作，每个task处理的数据中，相同的key会写入同一个磁盘文件内）。</p>\n<p>stage1，主要是执行从reduceByKey到collect操作，以及stage1的各个task一开始运行，就会首先执行shuffle<br>read操作（会从stage0的各个task所在节点拉取属于自己处理的那些key，然后对同一个key进行全局性的聚合或join等操作，在这里就是对key的value值进行累加）</p>\n<p>stage1在执行完reduceByKey算子之后，就计算出了最终的wordCounts<br>RDD，然后会执行collect算子，将所有数据拉取到Driver上，供我们遍历和打印输出。</p>\n<p>123456789</p>\n<p>通过对单词计数程序的分析，希望能够让大家了解最基本的stage划分的原理，以及stage划分后shuffle操作是如何在两个stage的边界处执行的。然后我们就知道如何快速定位出发生数据倾斜的stage对应代码的哪一个部分了。</p>\n<p>比如我们在Spark Web<br>UI或者本地log中发现，stage1的某几个task执行得特别慢，判定stage1出现了数据倾斜，那么就可以回到代码中，定位出stage1主要包括了reduceByKey这个shuffle类算子，此时基本就可以确定是是该算子导致了数据倾斜问题。</p>\n<p>此时，如果某个单词出现了100万次，其他单词才出现10次，那么stage1的某个task就要处理100万数据，整个stage的速度就会被这个task拖慢。</p>\n<h4 id=\"1-13-4-2-某个task莫名其妙内存溢出的情况\"><a href=\"#1-13-4-2-某个task莫名其妙内存溢出的情况\" class=\"headerlink\" title=\"1.13.4.2 某个task莫名其妙内存溢出的情况\"></a>1.13.4.2 某个task莫名其妙内存溢出的情况</h4><p>这种情况下去定位出问题的代码就比较容易了。我们建议直接看yarn-client模式下本地log的异常栈，或者是通过YARN查看yarn-cluster模式下的log中的异常栈。一般来说，通过异常栈信息就可以定位到你的代码中哪一行发生了内存溢出。然后在那行代码附近找找，一般也会有shuffle类算子，此时很可能就是这个算子导致了数据倾斜。</p>\n<p>但是大家要注意的是，不能单纯靠偶然的内存溢出就判定发生了数据倾斜。因为自己编写的代码的bug，以及偶然出现的数据异常，也可能会导致内存溢出。因此还是要按照上面所讲的方法，通过Spark<br>Web<br>UI查看报错的那个stage的各个task的运行时间以及分配的数据量，才能确定是否是由于数据倾斜才导致了这次内存溢出。</p>\n<h3 id=\"1-13-5-查看导致数据倾斜的key分布情况\"><a href=\"#1-13-5-查看导致数据倾斜的key分布情况\" class=\"headerlink\" title=\"1.13.5 查看导致数据倾斜的key分布情况\"></a>1.13.5 查看导致数据倾斜的key分布情况</h3><p>先对pairs采样10%的样本数据，然后使用countByKey算子统计出每个key出现的次数，最后在客户端遍历和打印样本数据中各个key的出现次数。</p>\n<p>val sampledPairs &#x3D; pairs.sample(false, 0.1)</p>\n<p>val sampledWordCounts &#x3D; sampledPairs.countByKey()</p>\n<p>sampledWordCounts.foreach(println(_))</p>\n<h3 id=\"1-13-6-Spark-数据倾斜的解决方案\"><a href=\"#1-13-6-Spark-数据倾斜的解决方案\" class=\"headerlink\" title=\"1.13.6 Spark 数据倾斜的解决方案\"></a>1.13.6 Spark 数据倾斜的解决方案</h3><h4 id=\"1-13-6-1-使用Hive-ETL预处理数据\"><a href=\"#1-13-6-1-使用Hive-ETL预处理数据\" class=\"headerlink\" title=\"1.13.6.1 使用Hive ETL预处理数据\"></a>1.13.6.1 使用Hive ETL预处理数据</h4><h5 id=\"1-13-6-1-1-适用场景\"><a href=\"#1-13-6-1-1-适用场景\" class=\"headerlink\" title=\"1.13.6.1.1 适用场景\"></a>1.13.6.1.1 适用场景</h5><p>导致数据倾斜的是Hive表。如果该Hive表中的数据本身很不均匀（比如某个key对应了100万数据，其他key才对应了10条数据），而且业务场景需要频繁使用Spark对Hive表执行某个分析操作，那么比较适合使用这种技术方案。</p>\n<h5 id=\"1-13-6-1-2-实现思路\"><a href=\"#1-13-6-1-2-实现思路\" class=\"headerlink\" title=\"1.13.6.1.2 实现思路\"></a>1.13.6.1.2 实现思路</h5><p>此时可以评估一下，是否可以通过Hive来进行数据预处理（即通过Hive<br>ETL预先对数据按照key进行聚合，或者是预先和其他表进行join），然后在Spark作业中针对的数据源就不是原来的Hive表了，而是预处理后的Hive表。此时由于数据已经预先进行过聚合或join操作了，那么在Spark作业中也就不需要使用原先的shuffle类算子执行这类操作了。</p>\n<h5 id=\"1-13-6-1-3-方案实现原理\"><a href=\"#1-13-6-1-3-方案实现原理\" class=\"headerlink\" title=\"1.13.6.1.3 方案实现原理\"></a>1.13.6.1.3 方案实现原理</h5><p>这种方案从根源上解决了数据倾斜，因为彻底避免了在Spark中执行shuffle类算子，那么肯定就不会有数据倾斜的问题了。但是这里也要提醒一下大家，这种方式属于治标不治本。因为毕竟数据本身就存在分布不均匀的问题，所以Hive<br>ETL中进行group by或者join等shuffle操作时，还是会出现数据倾斜，导致Hive<br>ETL的速度很慢。我们只是把数据倾斜的发生提前到了Hive<br>ETL中，避免Spark程序发生数据倾斜而已。</p>\n<h5 id=\"1-13-6-1-4-方案优缺点\"><a href=\"#1-13-6-1-4-方案优缺点\" class=\"headerlink\" title=\"1.13.6.1.4 方案优缺点\"></a>1.13.6.1.4 方案优缺点</h5><p>优点：实现起来简单便捷，效果还非常好，完全规避掉了数据倾斜，Spark作业的性能会大幅度提升。</p>\n<p>缺点：治标不治本，Hive ETL中还是会发生数据倾斜。</p>\n<h5 id=\"1-13-6-1-5-方案实践经验\"><a href=\"#1-13-6-1-5-方案实践经验\" class=\"headerlink\" title=\"1.13.6.1.5 方案实践经验\"></a>1.13.6.1.5 方案实践经验</h5><p>在一些Java系统与Spark结合使用的项目中，会出现Java代码频繁调用Spark作业的场景，而且对Spark作业的执行性能要求很高，就比较适合使用这种方案。将数据倾斜提前到上游的Hive<br>ETL，每天仅执行一次，只有那一次是比较慢的，而之后每次Java调用Spark作业时，执行速度都会很快，能够提供更好的用户体验。</p>\n<h5 id=\"1-13-6-1-6-项目实践经验\"><a href=\"#1-13-6-1-6-项目实践经验\" class=\"headerlink\" title=\"1.13.6.1.6 项目实践经验\"></a>1.13.6.1.6 项目实践经验</h5><p>在美团·点评的交互式用户行为分析系统中使用了这种方案，该系统主要是允许用户通过Java<br>Web系统提交数据分析统计任务，后端通过Java提交Spark作业进行数据分析统计。要求Spark作业速度必须要快，尽量在10分钟以内，否则速度太慢，用户体验会很差。所以我们将有些Spark作业的shuffle操作提前到了Hive<br>ETL中，从而让Spark直接使用预处理的Hive中间表，尽可能地减少Spark的shuffle操作，大幅度提升了性能，将部分作业的性能提升了6倍以上。</p>\n<h4 id=\"1-13-6-2-过滤少数导致倾斜的key\"><a href=\"#1-13-6-2-过滤少数导致倾斜的key\" class=\"headerlink\" title=\"1.13.6.2 过滤少数导致倾斜的key\"></a>1.13.6.2 过滤少数导致倾斜的key</h4><h5 id=\"1-13-6-2-1-方案适用场景\"><a href=\"#1-13-6-2-1-方案适用场景\" class=\"headerlink\" title=\"1.13.6.2.1 方案适用场景\"></a>1.13.6.2.1 方案适用场景</h5><p>如果发现导致倾斜的key就少数几个，而且对计算本身的影响并不大的话，那么很适合使用这种方案。比如99%的key就对应10条数据，但是只有一个key对应了100万数据，从而导致了数据倾斜。</p>\n<h5 id=\"1-13-6-2-2-方案实现思路\"><a href=\"#1-13-6-2-2-方案实现思路\" class=\"headerlink\" title=\"1.13.6.2.2 方案实现思路\"></a>1.13.6.2.2 方案实现思路</h5><p>如果我们判断那少数几个数据量特别多的key，对作业的执行和计算结果不是特别重要的话，那么干脆就直接过滤掉那少数几个key。</p>\n<p>比如，在Spark SQL中可以使用where子句过滤掉这些key或者在Spark<br>Core中对RDD执行filter算子过滤掉这些key。</p>\n<p>如果需要每次作业执行时，动态判定哪些key的数据量最多然后再进行过滤，那么可以使用sample算子对RDD进行采样，然后计算出每个key的数量，取数据量最多的key过滤掉即可。</p>\n<h5 id=\"1-13-6-2-3-方案实现原理\"><a href=\"#1-13-6-2-3-方案实现原理\" class=\"headerlink\" title=\"1.13.6.2.3 方案实现原理\"></a>1.13.6.2.3 方案实现原理</h5><p>将导致数据倾斜的key给过滤掉之后，这些key就不会参与计算了，自然不可能产生数据倾斜。</p>\n<h5 id=\"1-13-6-2-4-方案优缺点\"><a href=\"#1-13-6-2-4-方案优缺点\" class=\"headerlink\" title=\"1.13.6.2.4 方案优缺点\"></a>1.13.6.2.4 方案优缺点</h5><p>优点：实现简单，而且效果也很好，可以完全规避掉数据倾斜。</p>\n<p>缺点：适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。</p>\n<h5 id=\"1-13-6-2-5-方案实践经验\"><a href=\"#1-13-6-2-5-方案实践经验\" class=\"headerlink\" title=\"1.13.6.2.5 方案实践经验\"></a>1.13.6.2.5 方案实践经验</h5><p>在项目中我们也采用过这种方案解决数据倾斜。有一次发现某一天Spark作业在运行的时候突然OOM了，追查之后发现，是Hive表中的某一个key在那天数据异常，导致数据量暴增。因此就采取每次执行前先进行采样，计算出样本中数据量最大的几个key之后，直接在程序中将那些key给过滤掉。</p>\n<h4 id=\"1-13-6-3-提高shuffle操作的并行度\"><a href=\"#1-13-6-3-提高shuffle操作的并行度\" class=\"headerlink\" title=\"1.13.6.3 提高shuffle操作的并行度\"></a>1.13.6.3 提高shuffle操作的并行度</h4><h5 id=\"1-13-6-3-1-方案适用场景\"><a href=\"#1-13-6-3-1-方案适用场景\" class=\"headerlink\" title=\"1.13.6.3.1 方案适用场景\"></a>1.13.6.3.1 方案适用场景</h5><p>如果我们必须要对数据倾斜迎难而上，那么建议优先使用这种方案，因为这是处理数据倾斜最简单的一种方案。</p>\n<h5 id=\"1-13-6-3-2-方案实现思路\"><a href=\"#1-13-6-3-2-方案实现思路\" class=\"headerlink\" title=\"1.13.6.3.2 方案实现思路\"></a>1.13.6.3.2 方案实现思路</h5><p>在对RDD执行shuffle算子时，给shuffle算子传入一个参数，比如reduceByKey(1000)，该参数就设置了这个shuffle算子执行时shuffle<br>read task的数量，即spark.sql.shuffle.partitions，该参数代表了shuffle<br>read task的并行度，默认是200，对于很多场景来说都有点过小。</p>\n<h5 id=\"1-13-6-3-3-方案实现原理\"><a href=\"#1-13-6-3-3-方案实现原理\" class=\"headerlink\" title=\"1.13.6.3.3 方案实现原理\"></a>1.13.6.3.3 方案实现原理</h5><p>增加shuffle read<br>task的数量，可以让原本分配给一个task的多个key分配给多个task，从而让每个task处理比原来更少的数据。举例来说，如果原本有5个key，每个key对应10条数据，这5个key都是分配给一个task的，那么这个task就要处理50条数据。</p>\n<p>而增加了shuffle read<br>task以后，每个task就分配到一个key，即每个task就处理10条数据，那么自然每个task的执行时间都会变短了。具体原理如下图所示。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image51.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.517361111111111in”}</p>\n<h5 id=\"1-13-6-3-4-方案优缺点\"><a href=\"#1-13-6-3-4-方案优缺点\" class=\"headerlink\" title=\"1.13.6.3.4 方案优缺点\"></a>1.13.6.3.4 方案优缺点</h5><p>优点：实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。</p>\n<p>缺点：只是缓解了数据倾斜而已，没有彻底根除问题，根据实践经验来看，其效果有限。</p>\n<h5 id=\"1-13-6-3-5-方案实践经验\"><a href=\"#1-13-6-3-5-方案实践经验\" class=\"headerlink\" title=\"1.13.6.3.5 方案实践经验\"></a>1.13.6.3.5 方案实践经验</h5><p>该方案通常无法彻底解决数据倾斜，因为如果出现一些极端情况，比如某个key对应的数据量有100万，那么无论你的task数量增加到多少，这个对应着100万数据的key肯定还是会分配到一个task中去处理，因此注定还是会发生数据倾斜的。所以这种方案只能说是在发现数据倾斜时尝试使用的第一种手段，尝试去用最简单的方法缓解数据倾斜而已，或者是和其他方案结合起来使用。</p>\n<h4 id=\"1-13-6-4-两阶段聚合（局部聚合-全局聚合）\"><a href=\"#1-13-6-4-两阶段聚合（局部聚合-全局聚合）\" class=\"headerlink\" title=\"1.13.6.4 两阶段聚合（局部聚合+全局聚合）\"></a>1.13.6.4 两阶段聚合（局部聚合+全局聚合）</h4><h5 id=\"1-13-6-4-1-方案适用场景\"><a href=\"#1-13-6-4-1-方案适用场景\" class=\"headerlink\" title=\"1.13.6.4.1 方案适用场景\"></a>1.13.6.4.1 方案适用场景</h5><p>对RDD执行reduceByKey等聚合类shuffle算子或者在Spark SQL中使用group<br>by语句进行分组聚合时，比较适用这种方案。</p>\n<h5 id=\"1-13-6-4-2-方案实现思路\"><a href=\"#1-13-6-4-2-方案实现思路\" class=\"headerlink\" title=\"1.13.6.4.2 方案实现思路\"></a>1.13.6.4.2 方案实现思路</h5><p>这个方案的核心实现思路就是进行两阶段聚合：</p>\n<p>第一次是局部聚合，先给每个key都打上一个随机数，比如10以内的随机数，此时原先一样的key就变成不一样的了，比如(hello,</p>\n<ol>\n<li>(hello, 1) (hello, 1) (hello, 1)，就会变成(1_hello, 1) (1_hello, 1)<br>(2_hello, 1) (2_hello, 1)。</li>\n</ol>\n<p>接着对打上随机数后的数据，执行reduceByKey等聚合操作，进行局部聚合，那么局部聚合结果，就会变成了(1_hello,<br>2) (2_hello, 2)。</p>\n<p>然后将各个key的前缀给去掉，就会变成(hello,2)(hello,2)，再次进行全局聚合操作，就可以得到最终结果了，比如(hello,<br>4)。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>示例代码如下：</p></blockquote>\n<p>&#x2F;&#x2F; 第一步，给RDD中的每个key都打上一个随机前缀。<br>JavaPairRDD&lt;String, Long&gt; randomPrefixRdd &#x3D; rdd.mapToPair(<br>new PairFunction&lt;Tuple2&lt;Long,Long&gt;, String, Long&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Tuple2&lt;String, Long&gt; call(Tuple2&lt;Long, Long&gt; tuple)<br>throws Exception {<br>Random random &#x3D; new Random();<br>int prefix &#x3D; random.nextInt(10);<br>return new Tuple2&lt;String, Long&gt;(prefix + “_” + tuple._1,<br>tuple._2);<br>}<br>});</p>\n<p>&#x2F;&#x2F; 第二步，对打上随机前缀的key进行局部聚合。<br>JavaPairRDD&lt;String, Long&gt; localAggrRdd &#x3D; randomPrefixRdd.reduceByKey(<br>new Function2&lt;Long, Long, Long&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Long call(Long v1, Long v2) throws Exception {<br>return v1 + v2;<br>}<br>});</p>\n<p>&#x2F;&#x2F; 第三步，去除RDD中每个key的随机前缀。<br>JavaPairRDD&lt;Long, Long&gt; removedRandomPrefixRdd &#x3D;<br>localAggrRdd.mapToPair(<br>new PairFunction&lt;Tuple2&lt;String,Long&gt;, Long, Long&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Tuple2&lt;Long, Long&gt; call(Tuple2&lt;String, Long&gt; tuple)<br>throws Exception {<br>long originalKey &#x3D; Long.valueOf(tuple.<em>1.split(“</em>“)[1]);<br>return new Tuple2&lt;Long, Long&gt;(originalKey, tuple._2);<br>}<br>});</p>\n<p>&#x2F;&#x2F; 第四步，对去除了随机前缀的RDD进行全局聚合。<br>JavaPairRDD&lt;Long, Long&gt; globalAggrRdd &#x3D;<br>removedRandomPrefixRdd.reduceByKey(<br>new Function2&lt;Long, Long, Long&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Long call(Long v1, Long v2) throws Exception {<br>return v1 + v2;<br>}<br>});</p>\n<h5 id=\"1-13-6-4-3-方案实现原理\"><a href=\"#1-13-6-4-3-方案实现原理\" class=\"headerlink\" title=\"1.13.6.4.3 方案实现原理\"></a>1.13.6.4.3 方案实现原理</h5><p>将原本相同的key通过附加随机前缀的方式，变成多个不同的key，就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，进而解决单个task处理数据量过多的问题。接着去除掉随机前缀，再次进行全局聚合，就可以得到最终的结果。具体原理见下图。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image52.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.45in”}</p>\n<h5 id=\"1-13-6-4-4-方案优缺点\"><a href=\"#1-13-6-4-4-方案优缺点\" class=\"headerlink\" title=\"1.13.6.4.4 方案优缺点\"></a>1.13.6.4.4 方案优缺点</h5><p>优点<br>对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。</p>\n<p>缺点<br>仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案。</p>\n<h4 id=\"1-13-6-5-将reduce-join转为map-join\"><a href=\"#1-13-6-5-将reduce-join转为map-join\" class=\"headerlink\" title=\"1.13.6.5 将reduce join转为map join\"></a>1.13.6.5 将reduce join转为map join</h4><h5 id=\"1-13-6-5-1-方案适用场景\"><a href=\"#1-13-6-5-1-方案适用场景\" class=\"headerlink\" title=\"1.13.6.5.1 方案适用场景\"></a>1.13.6.5.1 方案适用场景</h5><p>在对RDD使用join类操作，或者是在Spark<br>SQL中使用join语句时，而且join操作中的一个RDD或表的数据量比较小（比如几百M或者一两G），比较适用此方案。</p>\n<h5 id=\"1-13-6-5-2-方案实现思路\"><a href=\"#1-13-6-5-2-方案实现思路\" class=\"headerlink\" title=\"1.13.6.5.2 方案实现思路\"></a>1.13.6.5.2 方案实现思路</h5><p>不使用join算子进行连接操作，而使用Broadcast变量与map类算子实现join操作，进而完全规避掉shuffle类的操作，彻底避免数据倾斜的发生和出现。将较小RDD中的数据直接通过collect算子拉取到Driver端的内存中来，然后对其创建一个Broadcast变量，广播给其他Executor节点；</p>\n<p>接着对另外一个RDD执行map类算子，在算子函数内，从Broadcast变量中获取较小RDD的全量数据，与当前RDD的每一条数据按照连接key进行比对，如果连接key相同的话，那么就将两个RDD的数据用你需要的方式连接起来。</p>\n<p>示例如下：</p>\n<p>&#x2F;&#x2F; 首先将数据量比较小的RDD的数据，collect到Driver中来。<br>List&lt;Tuple2&lt;Long, Row&gt;&gt; rdd1Data &#x3D; rdd1.collect()<br>&#x2F;&#x2F;<br>然后使用Spark的广播功能，将小RDD的数据转换成广播变量，这样每个Executor就只有一份RDD的数据。<br>&#x2F;&#x2F; 可以尽可能节省内存空间，并且减少网络传输性能开销。<br>final Broadcast&lt;List&lt;Tuple2&lt;Long, Row&gt;&gt;&gt; rdd1DataBroadcast &#x3D;<br>sc.broadcast(rdd1Data);</p>\n<p>&#x2F;&#x2F; 对另外一个RDD执行map类操作，而不再是join类操作。<br>JavaPairRDD&lt;String, Tuple2&lt;String, Row&gt;&gt; joinedRdd &#x3D;<br>rdd2.mapToPair(<br>new PairFunction&lt;Tuple2&lt;Long,String&gt;, String, Tuple2&lt;String,<br>Row&gt;&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Tuple2&lt;String, Tuple2&lt;String, Row&gt;&gt; call(Tuple2&lt;Long,<br>String&gt; tuple)<br>throws Exception {<br>&#x2F;&#x2F; 在算子函数中，通过广播变量，获取到本地Executor中的rdd1数据。<br>List&lt;Tuple2&lt;Long, Row&gt;&gt; rdd1Data &#x3D; rdd1DataBroadcast.value();<br>&#x2F;&#x2F; 可以将rdd1的数据转换为一个Map，便于后面进行join操作。<br>Map&lt;Long, Row&gt; rdd1DataMap &#x3D; new HashMap&lt;Long, Row&gt;();<br>for(Tuple2&lt;Long, Row&gt; data : rdd1Data) {<br>rdd1DataMap.put(data._1, data._2);<br>}<br>&#x2F;&#x2F; 获取当前RDD数据的key以及value。<br>String key &#x3D; tuple._1;<br>String value &#x3D; tuple._2;<br>&#x2F;&#x2F; 从rdd1数据Map中，根据key获取到可以join到的数据。<br>Row rdd1Value &#x3D; rdd1DataMap.get(key);<br>return new Tuple2&lt;String, String&gt;(key, new Tuple2&lt;String,<br>Row&gt;(value, rdd1Value));<br>}<br>});</p>\n<p>&#x2F;&#x2F; 这里得提示一下。<br>&#x2F;&#x2F; 上面的做法，仅仅适用于rdd1中的key没有重复，全部是唯一的场景。<br>&#x2F;&#x2F;<br>如果rdd1中有多个相同的key，那么就得用flatMap类的操作，在进行join的时候不能用map，而是得遍历rdd1所有数据进行join。<br>&#x2F;&#x2F; rdd2中每条数据都可能会返回多条join后的数据。</p>\n<h5 id=\"1-13-6-5-3-方案实现原理\"><a href=\"#1-13-6-5-3-方案实现原理\" class=\"headerlink\" title=\"1.13.6.5.3 方案实现原理\"></a>1.13.6.5.3 方案实现原理</h5><p>普通的join是会走shuffle过程的，而一旦shuffle，就相当于会将相同key的数据拉取到一个shuffle<br>read task中再进行join，此时就是reduce join。</p>\n<p>但是如果一个RDD是比较小的，则可以采用广播小RDD全量数据+map算子来实现与join同样的效果，也就是map<br>join，此时就不会发生shuffle操作，也就不会发生数据倾斜。具体原理如下图所示。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image53.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.035416666666667in”}</p>\n<h5 id=\"1-13-6-5-4-方案优缺点\"><a href=\"#1-13-6-5-4-方案优缺点\" class=\"headerlink\" title=\"1.13.6.5.4 方案优缺点\"></a>1.13.6.5.4 方案优缺点</h5><p>优点：对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。</p>\n<p>缺点：适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。</p>\n<h4 id=\"1-13-6-6-采样倾斜key并分拆join操作\"><a href=\"#1-13-6-6-采样倾斜key并分拆join操作\" class=\"headerlink\" title=\"1.13.6.6 采样倾斜key并分拆join操作\"></a>1.13.6.6 采样倾斜key并分拆join操作</h4><h5 id=\"1-13-6-6-1-方案适用场景\"><a href=\"#1-13-6-6-1-方案适用场景\" class=\"headerlink\" title=\"1.13.6.6.1 方案适用场景\"></a>1.13.6.6.1 方案适用场景</h5><p>两个RDD&#x2F;Hive表进行join的时候，如果数据量都比较大，无法采用”解决方案五”，那么此时可以看一下两个RDD&#x2F;Hive表中的key分布情况。</p>\n<p>如果出现数据倾斜，是因为其中某一个RDD&#x2F;Hive表中的少数几个key的数据量过大，而另一个RDD&#x2F;Hive表中的所有key都分布比较均匀，那么采用这个解决方案是比较合适的。</p>\n<h5 id=\"1-13-6-6-2-方案实现思路\"><a href=\"#1-13-6-6-2-方案实现思路\" class=\"headerlink\" title=\"1.13.6.6.2 方案实现思路\"></a>1.13.6.6.2 方案实现思路</h5><p>对包含少数几个数据量过大的key的那个RDD，通过sample算子采样出一份样本来，然后统计一下每个key的数量，计算出来数据量最大的是哪几个key。</p>\n<p>然后将这几个key对应的数据从原来的RDD中拆分出来，形成一个单独的RDD，并给每个key都打上n以内的随机数作为前缀；</p>\n<p>而不会导致倾斜的大部分key形成另外一个RDD。</p>\n<p>接着将需要join的另一个RDD，也过滤出来那几个倾斜key对应的数据并形成一个单独的RDD，将每条数据膨胀成n条数据，这n条数据都按顺序附加一个0~n的前缀；</p>\n<p>不会导致倾斜的大部分key也形成另外一个RDD。</p>\n<p>再将附加了随机前缀的独立RDD与另一个膨胀n倍的独立RDD进行join，此时就可以将原先相同的key打散成n份，分散到多个task中去进行join了。</p>\n<p>而另外两个普通的RDD就照常join即可。</p>\n<p>最后将两次join的结果使用union算子合并起来即可，就是最终的join结果。</p>\n<p>示例如下：</p>\n<p>&#x2F;&#x2F; 首先从包含了少数几个导致数据倾斜key的rdd1中，采样10%的样本数据。<br>JavaPairRDD&lt;Long, String&gt; sampledRDD &#x3D; rdd1.sample(false, 0.1);</p>\n<p>&#x2F;&#x2F; 对样本数据RDD统计出每个key的出现次数，并按出现次数降序排序。<br>&#x2F;&#x2F; 对降序排序后的数据，取出top 1或者top<br>100的数据，也就是key最多的前n个数据。<br>&#x2F;&#x2F;<br>具体取出多少个数据量最多的key，由大家自己决定，我们这里就取1个作为示范。</p>\n<p>&#x2F;&#x2F; 每行数据变为&lt;key,1&gt;<br>JavaPairRDD&lt;Long, Long&gt; mappedSampledRDD &#x3D; sampledRDD.mapToPair(<br>new PairFunction&lt;Tuple2&lt;Long,String&gt;, Long, Long&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Tuple2&lt;Long, Long&gt; call(Tuple2&lt;Long, String&gt; tuple)<br>throws Exception {<br>return new Tuple2&lt;Long, Long&gt;(tuple._1, 1L);<br>}<br>});</p>\n<p>&#x2F;&#x2F; 按key累加行数<br>JavaPairRDD&lt;Long, Long&gt; countedSampledRDD &#x3D;<br>mappedSampledRDD.reduceByKey(<br>new Function2&lt;Long, Long, Long&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Long call(Long v1, Long v2) throws Exception {<br>return v1 + v2;<br>}<br>});</p>\n<p>&#x2F;&#x2F; 反转key和value,变为&lt;value,key&gt;<br>JavaPairRDD&lt;Long, Long&gt; reversedSampledRDD &#x3D;<br>countedSampledRDD.mapToPair(<br>new PairFunction&lt;Tuple2&lt;Long,Long&gt;, Long, Long&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Tuple2&lt;Long, Long&gt; call(Tuple2&lt;Long, Long&gt; tuple)<br>throws Exception {<br>return new Tuple2&lt;Long, Long&gt;(tuple._2, tuple._1);<br>}<br>});</p>\n<p>&#x2F;&#x2F; 以行数排序key，取最多行数的key<br>final Long skewedUserid &#x3D;<br>reversedSampledRDD.sortByKey(false).take(1).get(0)._2;</p>\n<p>&#x2F;&#x2F; 从rdd1中分拆出导致数据倾斜的key，形成独立的RDD。<br>JavaPairRDD&lt;Long, String&gt; skewedRDD &#x3D; rdd1.filter(<br>new Function&lt;Tuple2&lt;Long,String&gt;, Boolean&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Boolean call(Tuple2&lt;Long, String&gt; tuple) throws Exception {<br>return tuple._1.equals(skewedUserid);<br>}<br>});</p>\n<p>&#x2F;&#x2F; 从rdd1中分拆出不导致数据倾斜的普通key，形成独立的RDD。<br>JavaPairRDD&lt;Long, String&gt; commonRDD &#x3D; rdd1.filter(<br>new Function&lt;Tuple2&lt;Long,String&gt;, Boolean&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Boolean call(Tuple2&lt;Long, String&gt; tuple) throws Exception {<br>return !tuple._1.equals(skewedUserid);<br>}<br>});</p>\n<p>&#x2F;&#x2F; rdd2，就是那个所有key的分布相对较为均匀的rdd。<br>&#x2F;&#x2F;<br>这里将rdd2中，前面获取到的key对应的数据，过滤出来，分拆成单独的rdd，并对rdd中的数据使用flatMap算子都扩容100倍。<br>&#x2F;&#x2F; 对扩容的每条数据，都打上0～100的前缀。<br>JavaPairRDD&lt;String, Row&gt; skewedRdd2 &#x3D; rdd2.filter(<br>new Function&lt;Tuple2&lt;Long,Row&gt;, Boolean&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Boolean call(Tuple2&lt;Long, Row&gt; tuple) throws Exception {<br>return tuple.<em>1.equals(skewedUserid);<br>}<br>}).flatMapToPair(new PairFlatMapFunction&lt;Tuple2&lt;Long,Row&gt;, String,<br>Row&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Iterable&lt;Tuple2&lt;String, Row&gt;&gt; call(<br>Tuple2&lt;Long, Row&gt; tuple) throws Exception {<br>Random random &#x3D; new Random();<br>List&lt;Tuple2&lt;String, Row&gt;&gt; list &#x3D; new ArrayList&lt;Tuple2&lt;String,<br>Row&gt;&gt;();<br>for(int i &#x3D; 0; i &lt; 100; i++) {<br>list.add(new Tuple2&lt;String, Row&gt;(i + “</em>“ + tuple._1, tuple._2));<br>}<br>return list;<br>}</p>\n<p>});</p>\n<p>&#x2F;&#x2F;<br>将rdd1中分拆出来的导致倾斜的key的独立rdd，每条数据都打上100以内的随机前缀。<br>&#x2F;&#x2F;<br>然后将这个rdd1中分拆出来的独立rdd，与上面rdd2中分拆出来的独立rdd，进行join。<br>JavaPairRDD&lt;Long, Tuple2&lt;String, Row&gt;&gt; joinedRDD1 &#x3D;<br>skewedRDD.mapToPair(<br>new PairFunction&lt;Tuple2&lt;Long,String&gt;, String, String&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Tuple2&lt;String, String&gt; call(Tuple2&lt;Long, String&gt; tuple)<br>throws Exception {<br>Random random &#x3D; new Random();<br>int prefix &#x3D; random.nextInt(100);<br>return new Tuple2&lt;String, String&gt;(prefix + “_” + tuple._1,<br>tuple._2);<br>}<br>})<br>.join(skewedUserid2infoRDD)<br>.mapToPair(new PairFunction&lt;Tuple2&lt;String,Tuple2&lt;String,Row&gt;&gt;,<br>Long, Tuple2&lt;String, Row&gt;&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Tuple2&lt;Long, Tuple2&lt;String, Row&gt;&gt; call(<br>Tuple2&lt;String, Tuple2&lt;String, Row&gt;&gt; tuple)<br>throws Exception {<br>long key &#x3D; Long.valueOf(tuple.<em>1.split(“</em>“)[1]);<br>return new Tuple2&lt;Long, Tuple2&lt;String, Row&gt;&gt;(key, tuple._2);<br>}<br>});</p>\n<p>&#x2F;&#x2F; 将rdd1中分拆出来的包含普通key的独立rdd，直接与rdd2进行join。<br>JavaPairRDD&lt;Long, Tuple2&lt;String, Row&gt;&gt; joinedRDD2 &#x3D;<br>commonRDD.join(rdd2);</p>\n<p>&#x2F;&#x2F; 将倾斜key join后的结果与普通key join后的结果，uinon起来。<br>&#x2F;&#x2F; 就是最终的join结果。<br>JavaPairRDD&lt;Long, Tuple2&lt;String, Row&gt;&gt; joinedRDD &#x3D;<br>joinedRDD1.union(joinedRDD2);</p>\n<h5 id=\"1-13-6-6-3-方案实现原理\"><a href=\"#1-13-6-6-3-方案实现原理\" class=\"headerlink\" title=\"1.13.6.6.3 方案实现原理\"></a>1.13.6.6.3 方案实现原理</h5><p>对于join导致的数据倾斜，如果只是某几个key导致了倾斜，可以将少数几个key分拆成独立RDD，并附加随机前缀打散成n份去进行join，此时这几个key对应的数据就不会集中在少数几个task上，而是分散到多个task进行join了。具体原理见下图。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image54.png\">{width&#x3D;”5.708333333333333in”<br>height&#x3D;”6.489583333333333in”}</p>\n<h5 id=\"1-13-6-6-4-方案优缺点\"><a href=\"#1-13-6-6-4-方案优缺点\" class=\"headerlink\" title=\"1.13.6.6.4 方案优缺点\"></a>1.13.6.6.4 方案优缺点</h5><p>优点：对于join导致的数据倾斜，如果只是某几个key导致了倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容。避免了占用过多内存。</p>\n<p>缺点：如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜，那么这种方式也不适合。</p>\n<h4 id=\"1-13-6-7-使用随机前缀和扩容RDD进行join\"><a href=\"#1-13-6-7-使用随机前缀和扩容RDD进行join\" class=\"headerlink\" title=\"1.13.6.7 使用随机前缀和扩容RDD进行join\"></a>1.13.6.7 使用随机前缀和扩容RDD进行join</h4><h5 id=\"1-13-6-7-1-方案适用场景\"><a href=\"#1-13-6-7-1-方案适用场景\" class=\"headerlink\" title=\"1.13.6.7.1 方案适用场景\"></a>1.13.6.7.1 方案适用场景</h5><p>如果在进行join操作时，RDD中有大量的key导致数据倾斜，那么进行分拆key也没什么意义，此时就只能使用最后一种方案来解决问题了。</p>\n<h5 id=\"1-13-6-7-2-方案实现思路\"><a href=\"#1-13-6-7-2-方案实现思路\" class=\"headerlink\" title=\"1.13.6.7.2 方案实现思路\"></a>1.13.6.7.2 方案实现思路</h5><p>该方案的实现思路基本和”解决方案六”类似，首先查看RDD&#x2F;Hive表中的数据分布情况，找到那个造成数据倾斜的RDD&#x2F;Hive表，比如有多个key都对应了超过1万条数据。</p>\n<p>然后将该RDD的每条数据都打上一个n以内的随机前缀。</p>\n<p>同时对另外一个正常的RDD进行扩容，将每条数据都扩容成n条数据，扩容出来的每条数据都依次打上一个0~n的前缀。</p>\n<p>最后将两个处理后的RDD进行join即可。</p>\n<p>示例代码如下：</p>\n<p>&#x2F;&#x2F; 首先将其中一个key分布相对较为均匀的RDD膨胀100倍。<br>JavaPairRDD&lt;String, Row&gt; expandedRDD &#x3D; rdd1.flatMapToPair(<br>new PairFlatMapFunction&lt;Tuple2&lt;Long,Row&gt;, String, Row&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Iterable&lt;Tuple2&lt;String, Row&gt;&gt; call(Tuple2&lt;Long, Row&gt;<br>tuple)<br>throws Exception {<br>List&lt;Tuple2&lt;String, Row&gt;&gt; list &#x3D; new ArrayList&lt;Tuple2&lt;String,<br>Row&gt;&gt;();<br>for(int i &#x3D; 0; i &lt; 100; i++) {<br>list.add(new Tuple2&lt;String, Row&gt;(0 + “_” + tuple._1, tuple._2));<br>}<br>return list;<br>}<br>});</p>\n<p>&#x2F;&#x2F; 其次，将另一个有数据倾斜key的RDD，每条数据都打上100以内的随机前缀。<br>JavaPairRDD&lt;String, String&gt; mappedRDD &#x3D; rdd2.mapToPair(<br>new PairFunction&lt;Tuple2&lt;Long,String&gt;, String, String&gt;() {<br>private static final long serialVersionUID &#x3D; 1L;<br>@Override<br>public Tuple2&lt;String, String&gt; call(Tuple2&lt;Long, String&gt; tuple)<br>throws Exception {<br>Random random &#x3D; new Random();<br>int prefix &#x3D; random.nextInt(100);<br>return new Tuple2&lt;String, String&gt;(prefix + “_” + tuple._1,<br>tuple._2);<br>}<br>});</p>\n<p>&#x2F;&#x2F; 将两个处理后的RDD进行join即可。<br>JavaPairRDD&lt;String, Tuple2&lt;String, Row&gt;&gt; joinedRDD &#x3D;<br>mappedRDD.join(expandedRDD);</p>\n<h5 id=\"1-13-6-7-3-方案实现原理\"><a href=\"#1-13-6-7-3-方案实现原理\" class=\"headerlink\" title=\"1.13.6.7.3 方案实现原理\"></a>1.13.6.7.3 方案实现原理</h5><p>将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的”不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。</p>\n<p>该方案与”解决方案六”的不同之处就在于，上一种方案是尽量只对少数倾斜key对应的数据进行特殊处理，由于处理过程需要扩容RDD，因此上一种方案扩容RDD后对内存的占用并不大；</p>\n<p>而这一种方案是针对有大量倾斜key的情况，没法将部分key拆分出来进行单独处理，因此只能对整个RDD进行数据扩容，对内存资源要求很高。</p>\n<h5 id=\"1-13-6-7-4-方案优缺点\"><a href=\"#1-13-6-7-4-方案优缺点\" class=\"headerlink\" title=\"1.13.6.7.4 方案优缺点\"></a>1.13.6.7.4 方案优缺点</h5><p>优点：对join类型的数据倾斜基本都可以处理，而且效果也相对比较显著，性能提升效果非常不错。</p>\n<p>缺点：该方案更多的是缓解数据倾斜，而不是彻底避免数据倾斜。而且需要对整个RDD进行扩容，对内存资源要求很高。</p>\n<h5 id=\"1-13-6-7-5-方案实践经验\"><a href=\"#1-13-6-7-5-方案实践经验\" class=\"headerlink\" title=\"1.13.6.7.5 方案实践经验\"></a>1.13.6.7.5 方案实践经验</h5><p>曾经开发一个数据需求的时候，发现一个join导致了数据倾斜。优化之前，作业的执行时间大约是60分钟左右；使用该方案优化之后，执行时间缩短到10分钟左右，性能提升了6倍。</p>\n<h4 id=\"1-13-6-8-多种方案组合使用\"><a href=\"#1-13-6-8-多种方案组合使用\" class=\"headerlink\" title=\"1.13.6.8 多种方案组合使用\"></a>1.13.6.8 多种方案组合使用</h4><p>在实践中发现，很多情况下，如果只是处理较为简单的数据倾斜场景，那么使用上述方案中的某一种基本就可以解决。但是如果要处理一个较为复杂的数据倾斜场景，那么可能需要将多种方案组合起来使用。</p>\n<p>比如说，我们针对出现了多个数据倾斜环节的Spark作业，可以先运用解决方案一HiveETL预处理和过滤少数导致倾斜的k，预处理一部分数据，并过滤一部分数据来缓解；</p>\n<p>其次可以对某些shuffle操作提升并行度，优化其性能；</p>\n<p>最后还可以针对不同的聚合或join操作，选择一种方案来优化其性能。</p>\n<p>大家需要对这些方案的思路和原理都透彻理解之后，在实践中根据各种不同的情况，灵活运用多种方案，来解决自己的数据倾斜问题。</p>\n<h3 id=\"1-13-7-Spark数据倾斜处理小结\"><a href=\"#1-13-7-Spark数据倾斜处理小结\" class=\"headerlink\" title=\"1.13.7 Spark数据倾斜处理小结\"></a>1.13.7 Spark数据倾斜处理小结</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image55.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”4.545138888888889in”}</p>\n<h2 id=\"1-14-Flink\"><a href=\"#1-14-Flink\" class=\"headerlink\" title=\"1.14 Flink \"></a>1.14 Flink </h2><h3 id=\"1-14-1-简单介绍一下-Flink\"><a href=\"#1-14-1-简单介绍一下-Flink\" class=\"headerlink\" title=\"1.14.1 简单介绍一下 Flink\"></a>1.14.1 简单介绍一下 Flink</h3><p>Flink<br>是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。并且<br>Flink<br>提供了数据分布、容错机制以及资源管理等核心功能。Flink提供了诸多高抽象层的API以便用户编写分布式任务：</p>\n<p>DataSet API，<br>对静态数据进行批处理操作，将静态数据抽象成分布式的数据集，用户可以方便地使用Flink提供的各种操作符对分布式数据集进行处理，支持Java、Scala和Python。</p>\n<p>DataStream<br>API，对数据流进行流处理操作，将流式的数据抽象成分布式的数据流，用户可以方便地对分布式数据流进行各种操作，支持Java和Scala。</p>\n<p>Table<br>API，对结构化数据进行查询操作，将结构化数据抽象成关系表，并通过类SQL的DSL对关系表进行各种查询操作，支持Java和Scala。</p>\n<p>此外，Flink 还针对特定的应用领域提供了领域库，例如： Flink ML，Flink<br>的机器学习库，提供了机器学习Pipelines API并实现了多种机器学习算法。<br>Gelly，Flink 的图计算库，提供了图计算的相关API及多种图计算算法实现。</p>\n<h3 id=\"1-14-2-Flink跟Spark-Streaming的区别\"><a href=\"#1-14-2-Flink跟Spark-Streaming的区别\" class=\"headerlink\" title=\"1.14.2 Flink跟Spark Streaming的区别\"></a>1.14.2 Flink跟Spark Streaming的区别</h3><p>这个问题是一个非常宏观的问题，因为两个框架的不同点非常之多。但是在面试时有非常重要的一点一定要回答出来：<strong>Flink<br>是标准的实时处理引擎，基于事件驱动。而 Spark Streaming<br>是微批（Micro-Batch）的模型。</strong></p>\n<p>下面我们就分几个方面介绍两个框架的主要区别：</p>\n<p>1）架构模型Spark Streaming<br>在运行时的主要角色包括：Master、Worker、Driver、Executor，Flink<br>在运行时主要包含：Jobmanager、Taskmanager和Slot。</p>\n<p>2）任务调度Spark Streaming<br>连续不断的生成微小的数据批次，构建有向无环图DAG，Spark Streaming<br>会依次创建 DStreamGraph、JobGenerator、JobScheduler。Flink<br>根据用户提交的代码生成 StreamGraph，经过优化生成 JobGraph，然后提交给<br>JobManager进行处理，JobManager 会根据 JobGraph 生成<br>ExecutionGraph，ExecutionGraph 是 Flink 调度最核心的数据结构，JobManager<br>根据 ExecutionGraph 对 Job 进行调度。</p>\n<p>3）时间机制Spark Streaming 支持的时间机制有限，只支持处理时间。 Flink<br>支持了流处理程序在时间上的三个定义：处理时间、事件时间、注入时间。同时也支持<br>watermark 机制来处理滞后数据。</p>\n<p>4）容错机制对于 Spark Streaming 任务，我们可以设置<br>checkpoint，然后假如发生故障并重启，我们可以从上次 checkpoint<br>之处恢复，但是这个行为只能使得数据不丢失，可能会重复处理，不能做到恰好一次处理语义。Flink<br>则使用两阶段提交协议来解决这个问题。</p>\n<h3 id=\"1-14-3-Flink集群有哪些角色？各自有什么作用？\"><a href=\"#1-14-3-Flink集群有哪些角色？各自有什么作用？\" class=\"headerlink\" title=\"1.14.3 Flink集群有哪些角色？各自有什么作用？\"></a>1.14.3 Flink集群有哪些角色？各自有什么作用？</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image56.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”4.245833333333334in”}</p>\n<p>Flink程序在运行时主要有TaskManager，JobManager，Client三种角色。</p>\n<p>JobManager扮演着集群中的管理者Master的角色，它是整个集群的协调者，负责接收Flink<br>Job，协调检查点，Failover<br>故障恢复等，同时管理Flink集群中从节点TaskManager。</p>\n<p>TaskManager是实际负责执行计算的Worker，在其上执行Flink<br>Job的一组Task，每个TaskManager负责管理其所在节点上的资源信息，如内存、磁盘、网络，在启动的时候将资源的状态向JobManager汇报。</p>\n<p>Client是Flink程序提交的客户端，当用户提交一个Flink程序时，会首先创建一个Client，该Client首先会对用户提交的Flink程序进行预处理，并提交到Flink集群中处理，所以Client需要从用户提交的Flink程序配置中获取JobManager的地址，并建立到JobManager的连接，将Flink<br>Job提交给JobManager。</p>\n<h3 id=\"1-14-4-Flink的编程模型是什么？\"><a href=\"#1-14-4-Flink的编程模型是什么？\" class=\"headerlink\" title=\"1.14.4 Flink的编程模型是什么？\"></a>1.14.4 Flink的编程模型是什么？</h3><p>Environment -&gt; Source -&gt; Transform -&gt; Sink</p>\n<p>分层API</p>\n<h3 id=\"1-14-5-公司怎么提交的实时任务，有多少Job-Manager？-有多少TaskManager？\"><a href=\"#1-14-5-公司怎么提交的实时任务，有多少Job-Manager？-有多少TaskManager？\" class=\"headerlink\" title=\"1.14.5 公司怎么提交的实时任务，有多少Job Manager？ 有多少TaskManager？\"></a>1.14.5 公司怎么提交的实时任务，有多少Job Manager？ 有多少TaskManager？</h3><p>1）我们使用yarn per-job模式提交任务</p>\n<p>2）集群默认只有一个 Job<br>Manager。但为了防止单点故障，我们配置了高可用。对于standlone模式，我们公司一般配置一个主<br>Job Manager，两个备用 Job Manager，然后结合 ZooKeeper<br>的使用，来达到高可用；对于yarn模式，yarn在Job<br>Mananger故障会自动进行重启，所以只需要一个，我们配置的最大重启次数是10次。</p>\n<p>3）基于yarn，动态申请TaskManager的数量</p>\n<h3 id=\"1-14-6-Flink的并行度了解吗？Flink的并行度设置是怎样的？\"><a href=\"#1-14-6-Flink的并行度了解吗？Flink的并行度设置是怎样的？\" class=\"headerlink\" title=\"1.14.6 Flink的并行度了解吗？Flink的并行度设置是怎样的？\"></a>1.14.6 Flink的并行度了解吗？Flink的并行度设置是怎样的？</h3><p>Flink中的任务被分为多个并行任务来执行，其中每个并行的实例处理一部分数据。这些并行实例的数量被称为并行度。我们在实际生产环境中可以从四个不同层面设置并行度：</p>\n<p>操作算子层面(Operator Level)</p>\n<p>执行环境层面(Execution Environment Level)</p>\n<p>客户端层面(Client Level)</p>\n<p>系统层面(System Level)</p>\n<p>需要注意的优先级：算子层面&gt;环境层面&gt;客户端层面&gt;系统层面。</p>\n<p>并行度的设置：一般设为kafka的分区数，达到1：1</p>\n<p>遵循2的n次方：比如2、4、8、16…..</p>\n<h3 id=\"1-14-7-Flink的keyby怎么实现的分区？分区、分组的区别是什么？\"><a href=\"#1-14-7-Flink的keyby怎么实现的分区？分区、分组的区别是什么？\" class=\"headerlink\" title=\"1.14.7 Flink的keyby怎么实现的分区？分区、分组的区别是什么？\"></a>1.14.7 Flink的keyby怎么实现的分区？分区、分组的区别是什么？</h3><p>Keyby实现原理：</p>\n<p>对指定的key调用自身的hashCode方法&#x3D;》hash1</p>\n<p>调用murmruhash算法，进行第二次hash &#x3D;》键组ID</p>\n<p>通过一个公式，计算出当前数据应该去往哪个下游分区：</p>\n<p>键组id * 下游算子并行度 &#x2F; 最大并行度（默认128）</p>\n<p>分区：算子的一个并行实例可以理解成一个分区，是物理上的资源</p>\n<p>分组：数据根据key进行区分，是一个逻辑上的划分</p>\n<p>一个分区可以有多个分组，同一个分组的数据肯定在同一个分区</p>\n<h3 id=\"1-14-8-Flink的interval-join的实现原理？join不上的怎么办？\"><a href=\"#1-14-8-Flink的interval-join的实现原理？join不上的怎么办？\" class=\"headerlink\" title=\"1.14.8 Flink的interval join的实现原理？join不上的怎么办？\"></a>1.14.8 Flink的interval join的实现原理？join不上的怎么办？</h3><p>底层调用的是keyby+connect ，处理逻辑：</p>\n<p>1）判断是否迟到（迟到就不处理了）</p>\n<p>2）每条流都存了一个Map类型的状态（key是时间戳，value是List存数据）</p>\n<p>3）任一条流，来了一条数据，遍历对方的map状态，能匹配上就发往join方法</p>\n<p>4）超过有效时间范围，会删除对应Map中的数据（不是clear，是remove）</p>\n<p>Interval join不会处理join不上的数据，如果需要没join上的数据，可以用<br>coGroup+connect算子实现，或者直接使用flinksql里的left join或right<br>join语法。</p>\n<h3 id=\"1-14-9-介绍一下Flink的状态编程、状态机制？\"><a href=\"#1-14-9-介绍一下Flink的状态编程、状态机制？\" class=\"headerlink\" title=\"1.14.9 介绍一下Flink的状态编程、状态机制？\"></a>1.14.9 介绍一下Flink的状态编程、状态机制？</h3><p>算子状态：作用范围是算子，算子的多个并行实例各自维护一个状态</p>\n<p>键控状态：每个分组维护一个状态</p>\n<p>状态后端：两件事&#x3D;》 本地状态存哪里、checkpoint存哪里</p>\n<p>本地状态 Checkpoint</p>\n<p>内存 TaskManager的内存 JobManager内存</p>\n<p>文件 TaskManager的内存 HDFS</p>\n<p>RocksDB RocksDB HDFS</p>\n<h3 id=\"1-14-10-Flink的三种时间语义\"><a href=\"#1-14-10-Flink的三种时间语义\" class=\"headerlink\" title=\"1.14.10 Flink的三种时间语义\"></a>1.14.10 Flink的三种时间语义</h3><p>Event<br>Time：是事件创建的时间。它通常由事件中的时间戳描述，例如采集的日志数据中，每一条日志都会记录自己的生成时间，Flink通过时间戳分配器访问事件时间戳。</p>\n<p>Ingestion Time：是数据进入Flink的时间。</p>\n<p>Processing<br>Time：是每一个执行基于时间操作的算子的本地系统时间，与机器相关，默认的时间属性就是Processing<br>Time。</p>\n<h3 id=\"1-14-11-Flink-中的Watermark机制\"><a href=\"#1-14-11-Flink-中的Watermark机制\" class=\"headerlink\" title=\"1.14.11 Flink 中的Watermark机制\"></a>1.14.11 Flink 中的Watermark机制</h3><p>1）Watermark 是一种衡量 Event Time 进展的机制，可以设定延迟触发</p>\n<p>2）Watermark 是用于处理乱序事件的，而正确的处理乱序事件，通常用Watermark<br>机制结合 window 来实现；</p>\n<p>3）基于事件时间，用来触发窗口、定时器等</p>\n<p>4）watermark主要属性就是时间戳，可以理解一个特殊的数据，插入到流里面</p>\n<p>5）watermark是单调不减的</p>\n<p>6）数据流中的 Watermark 用于表示 timestamp 小于 Watermark<br>的数据，都已经到达了，如果后续还有timestamp 小于 Watermark<br>的数据到达，称为迟到数据</p>\n<h3 id=\"1-14-12-Watermark是数据吗？怎么生成的？怎么传递的？\"><a href=\"#1-14-12-Watermark是数据吗？怎么生成的？怎么传递的？\" class=\"headerlink\" title=\"1.14.12 Watermark是数据吗？怎么生成的？怎么传递的？\"></a>1.14.12 Watermark是数据吗？怎么生成的？怎么传递的？</h3><p>Watermark是一条携带时间戳的特殊数据，从代码指定生成的位置，插入到流里面。</p>\n<p>一对多：广播</p>\n<p>多对一：取最小</p>\n<p>多对多：拆分来看，其实就是上面两种的结合</p>\n<h3 id=\"1-14-13-Watermark的生成方式？\"><a href=\"#1-14-13-Watermark的生成方式？\" class=\"headerlink\" title=\"1.14.13 Watermark的生成方式？\"></a>1.14.13 Watermark的生成方式？</h3><p>间歇性：来一条数据，更新一次watermark</p>\n<p>周期性：固定周期更新watermark</p>\n<p>官方提供的api是基于周期的，默认200ms，因为间歇性会给系统带来压力。</p>\n<p>Watermark&#x3D;当前最大事件时间-乱序时间-1ms</p>\n<h3 id=\"1-14-14-说说Flink中的窗口（分类、生命周期、触发、划分）\"><a href=\"#1-14-14-说说Flink中的窗口（分类、生命周期、触发、划分）\" class=\"headerlink\" title=\"1.14.14 说说Flink中的窗口（分类、生命周期、触发、划分）\"></a>1.14.14 说说Flink中的窗口（分类、生命周期、触发、划分）</h3><p>1）窗口分类： Keyed Window和Non-keyed Window</p>\n<p>基于时间：滚动、滑动、会话</p>\n<p>基于数量：滚动、滑动</p>\n<p>2）Window口的4个相关重要组件：</p>\n<ul>\n<li><p>assigner（分配器）：如何将元素分配给窗口</p>\n</li>\n<li><p>function（计算函数）：为窗口定义的计算。其实是一个计算函数，完成窗口内容的计算。</p>\n</li>\n<li><p>triger（触发器）：在什么条件下触发窗口的计算</p>\n</li>\n<li><p>evictor（退出器）：定义从窗口中移除数据</p>\n</li>\n</ul>\n<p>3）窗口的划分：如，基于事件时间的滚动窗口</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>start&#x3D;按照数据的事件时间向下取窗口长度的整数倍</p>\n<p>end&#x3D;start+size</p>\n<p>比如开了一个10s的滚动窗口，第一条数据是857s，那么它属于[850s,860s)</p></blockquote>\n<p>4）窗口的创建：当属于某个窗口的第一个元素到达，Flink就会创建一个窗口，</p>\n<p>5）窗口的销毁：当时间超过其结束时间+用户指定的允许延迟时间（Flink保证只删除基于时间的窗口，而不能删除其他类型的窗口，例如全局窗口）。</p>\n<p>6）窗口为什么左闭右开：属于窗口的最大时间戳&#x3D;end-1ms</p>\n<p>7）窗口什么时候触发：如基于事件时间的窗口 watermark&gt;&#x3D;end-1ms</p>\n<h3 id=\"1-14-15-Exactly-Once的保证\"><a href=\"#1-14-15-Exactly-Once的保证\" class=\"headerlink\" title=\"1.14.15 Exactly-Once的保证\"></a>1.14.15 Exactly-Once的保证</h3><p>一般说的是端到端一致性，要考虑source和sink：</p>\n<p>Source：可重发</p>\n<p>Flink内部：Checkpoint机制（介绍Chandy-Lamport算法、barrier对齐）</p>\n<p>Sink：幂等性 或 事务性 写入</p>\n<p>我们使用的Source和Sink主要是Kafka：</p>\n<p>作为source可以重发，由Flink维护offset，作为状态存储</p>\n<p>作为sink官方的实现类是基于两阶段提交，能保证写入的Exactly-Once</p>\n<p>如果下级存储不支持事务：</p>\n<p>具体实现是幂等写入，需要下级存储具有幂等性写入特性。</p>\n<p>比如结合HBase的rowkey的唯一性、数据的多版本，实现幂等</p>\n<h3 id=\"1-14-16-Flink分布式快照的原理是什么\"><a href=\"#1-14-16-Flink分布式快照的原理是什么\" class=\"headerlink\" title=\"1.14.16 Flink分布式快照的原理是什么\"></a>1.14.16 Flink分布式快照的原理是什么</h3><p>Flink的容错机制的核心部分是制作分布式数据流和操作算子状态的一致性快照。<br>这些快照充当一致性checkpoint，系统可以在发生故障时回滚。<br>Flink用于制作这些快照的机制在”分布式数据流的轻量级异步快照”中进行了描述。<br>它受到分布式快照的标准Chandy-Lamport算法的启发，专门针对Flink的执行模型而定制。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image57.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”1.7861111111111112in”}</p>\n<p>barriers在数据流源处被注入并行数据流中。快照n的barriers被插入的位置（我们称之为Sn）是快照所包含的数据在数据源中最大位置。</p>\n<p>例如，在Apache Kafka中，此位置将是分区中最后一条记录的偏移量。<br>将该位置Sn报告给checkpoint协调器（Flink的JobManager）。</p>\n<p>然后barriers向下游流动。当一个中间操作算子从其所有输入流中收到快照n的barriers时，它会为快照n发出barriers进入其所有输出流中。</p>\n<p>一旦sink操作算子（流式DAG的末端）从其所有输入流接收到barriers<br>n，它就向checkpoint协调器确认快照n完成。</p>\n<p>在所有sink确认快照后，意味快照着已完成。一旦完成快照n，job将永远不再向数据源请求Sn之前的记录，因为此时这些记录（及其后续记录）将已经通过整个数据流拓扑，也即是已经被处理结束。</p>\n<h3 id=\"1-14-17-Checkpoint的参数怎么设置的？\"><a href=\"#1-14-17-Checkpoint的参数怎么设置的？\" class=\"headerlink\" title=\"1.14.17 Checkpoint的参数怎么设置的？\"></a>1.14.17 Checkpoint的参数怎么设置的？</h3><p>1）间隔、语义： 1min~10min，3min，语义默认精准一次</p>\n<p>因为一些异常原因可能导致某些barrier无法向下游传递，造成job失败，对于一些时效性要求高、精准性要求不是特别严格的指标，可以设置为至少一次。</p>\n<p>2）超时 ： 参考间隔， 0.5~2倍之间， 建议0.5倍</p>\n<p>3）最小等待间隔：上一次ck结束 到 下一次ck开始<br>之间的时间间隔，设置间隔的0.5倍</p>\n<p>4）设置保存ck：Retain</p>\n<p>5）失败次数：5</p>\n<p>6）Task重启策略（Failover）：</p>\n<p>固定延迟重启策略： 重试几次、每次间隔多久</p>\n<p>失败率重启策略： 重试次数、重试区间、重试间隔</p>\n<h3 id=\"1-14-18-介绍一下Flink的CEP机制\"><a href=\"#1-14-18-介绍一下Flink的CEP机制\" class=\"headerlink\" title=\"1.14.18 介绍一下Flink的CEP机制\"></a>1.14.18 介绍一下Flink的CEP机制</h3><p>CEP全称为Complex Event Processing，复杂事件处理</p>\n<p>Flink CEP是在 Flink 中实现的复杂事件处理（CEP）库</p>\n<p>CEP 允许在无休止的事件流中检测事件模式，让我们有机会掌握数据中重要的部分</p>\n<p>一个或多个由简单事件构成的事件流通过一定的规则匹配，然后输出用户想得到的数据<br>—— 满足规则的复杂事件</p>\n<h3 id=\"1-14-19-Flink-CEP-编程中当状态没有到达的时候会将数据保存在哪里？\"><a href=\"#1-14-19-Flink-CEP-编程中当状态没有到达的时候会将数据保存在哪里？\" class=\"headerlink\" title=\"1.14.19 Flink CEP 编程中当状态没有到达的时候会将数据保存在哪里？\"></a>1.14.19 Flink CEP 编程中当状态没有到达的时候会将数据保存在哪里？</h3><p>在流式处理中，CEP 当然是要支持 EventTime<br>的，那么相对应的也要支持数据的迟到现象，也就是watermark的处理逻辑。CEP对未匹配成功的事件序列的处理，和迟到数据是类似的。在<br>Flink<br>CEP的处理逻辑中，状态没有满足的和迟到的数据，都会存储在一个Map数据结构中，也就是说，如果我们限定判断事件序列的时长为5分钟，那么内存中就会存储5分钟的数据，这在我看来，也是对内存的极大损伤之一。</p>\n<h3 id=\"1-14-20-Flink-SQL的工作机制？\"><a href=\"#1-14-20-Flink-SQL的工作机制？\" class=\"headerlink\" title=\"1.14.20 Flink SQL的工作机制？\"></a>1.14.20 Flink SQL的工作机制？</h3><p>通过Calcite对编写的 Sql 进行解析、验证、优化等操作。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image58.png\">{width&#x3D;”3.75in”<br>height&#x3D;”1.0743055555555556in”}</p>\n<p>Blink Planner与Calcite进行对接,对接流程如下：</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image59.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.527083333333333in”}</p>\n<p>1）在Table&#x2F;SQL 编写完成后，通过Calcite<br>中的parse、validate、rel阶段，以及Blink额外添加的convert阶段,将其先转为Operation；</p>\n<p>2）通过Blink Planner<br>的translateToRel、optimize、translateToExecNodeGraph和translateToPlan四个阶段，将Operation转换成DataStream<br>API的 Transformation；</p>\n<p>3）再经过StreamJraph -&gt; JobGraph -&gt;<br>ExecutionGraph等一系列流程，SQL最终被提交到集群。</p>\n<h3 id=\"1-14-21-FlinkSQL怎么对SQL语句进行优化的？\"><a href=\"#1-14-21-FlinkSQL怎么对SQL语句进行优化的？\" class=\"headerlink\" title=\"1.14.21 FlinkSQL怎么对SQL语句进行优化的？\"></a>1.14.21 FlinkSQL怎么对SQL语句进行优化的？</h3><p>会使用两个优化器:RBO(基于规则的优化器) 和 CBO(基于代价的优化器)</p>\n<p>1）RBO(基于规则的优化器)会将原有表达式裁剪掉，遍历一系列规则（Rule），只要满足条件就转换，生成最终的执行计划。一些常见的规则包括分区裁剪（Partition<br>Prune）、列裁剪、谓词下推（Predicate Pushdown）、投影下推（Projection<br>Pushdown）、聚合下推、limit下推、sort下推、常量折叠（Constant<br>Folding）、子查询内联转join等。</p>\n<p>2）CBO(基于代价的优化器)会将原有表达式保留，基于统计信息和代价模型，尝试探索生成等价关系表达式，最终取代价最小的执行计划。CBO的实现有两种模型，Volcano模型，Cascades模型。这两种模型思想很是相似，不同点在于Cascades模型一边遍历SQL逻辑树，一边优化，从而进一步裁剪掉一些执行计划。</p>\n<h3 id=\"1-14-22-Flink提交流程、组件通讯、调度机制、任务执行、内存模型（重点）\"><a href=\"#1-14-22-Flink提交流程、组件通讯、调度机制、任务执行、内存模型（重点）\" class=\"headerlink\" title=\"1.14.22 Flink提交流程、组件通讯、调度机制、任务执行、内存模型（重点）\"></a>1.14.22 Flink提交流程、组件通讯、调度机制、任务执行、内存模型（重点）</h3><p><strong>0.1 Flink提交流程（Yarn-Per-Job）</strong></p>\n<p>**0.2 Flink通讯过程 **</p>\n<p><strong>0.3 Task调度</strong></p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image62.png\">{width&#x3D;”5.176388888888889in”<br>height&#x3D;”5.402777777777778in”}</p>\n<p><strong>0.4 内存模型</strong></p>\n<h3 id=\"1-14-23-Flink优化、背压、数据倾斜（重点）\"><a href=\"#1-14-23-Flink优化、背压、数据倾斜（重点）\" class=\"headerlink\" title=\"1.14.23 Flink优化、背压、数据倾斜（重点）\"></a>1.14.23 Flink优化、背压、数据倾斜（重点）</h3><h3 id=\"1-14-24-Flink常见的维表Join方案\"><a href=\"#1-14-24-Flink常见的维表Join方案\" class=\"headerlink\" title=\"1.14.24 Flink常见的维表Join方案\"></a>1.14.24 Flink常见的维表Join方案</h3><p>1）预加载： open（）方法，查询维表，存储下来 &#x3D;&#x3D;》 定时查询</p>\n<p>2）热存储： 存在外部系统redis、hbase等</p>\n<p>缓存</p>\n<p>异步查询： 异步io功能</p>\n<p>3）广播维表</p>\n<p>4）Temporal join：外部存储，connector创建</p>\n<h1 id=\"第2章-项目架构\"><a href=\"#第2章-项目架构\" class=\"headerlink\" title=\"第2章 项目架构\"></a>第2章 项目架构</h1><h2 id=\"2-1-提高自信\"><a href=\"#2-1-提高自信\" class=\"headerlink\" title=\"2.1 提高自信\"></a>2.1 提高自信</h2><p>云上数据仓库解决方案：<a href=\"https://www.aliyun.com/solution/datavexpo/datawarehouse\">[https://www.aliyun.com/solution/datavexpo/datawarehouse]{.underline}</a></p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image67.png\">{width&#x3D;”3.884027777777778in”<br>height&#x3D;”4.625in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image68.png\">{width&#x3D;”5.345138888888889in”<br>height&#x3D;”2.6993055555555556in”}</p>\n<h2 id=\"2-2-数仓概念\"><a href=\"#2-2-数仓概念\" class=\"headerlink\" title=\"2.2 数仓概念\"></a>2.2 数仓概念</h2><p><strong>数据仓库的输入数据源和输出系统分别是什么？</strong></p>\n<p>输入系统：埋点产生的用户行为数据、JavaEE后台产生的业务数据、个别公司有爬虫数据。</p>\n<p>输出系统：报表系统、用户画像系统、推荐系统</p>\n<h2 id=\"2-3-系统数据流程设计\"><a href=\"#2-3-系统数据流程设计\" class=\"headerlink\" title=\"2.3 系统数据流程设计\"></a>2.3 系统数据流程设计</h2><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image69.png\"></p>\n<h2 id=\"2-4-框架版本选型\"><a href=\"#2-4-框架版本选型\" class=\"headerlink\" title=\"2.4 框架版本选型\"></a>2.4 框架版本选型</h2><p>1）Apache：运维麻烦，组件间兼容性需要自己调研。（一般大厂使用，技术实力雄厚，有专业的运维人员）</p>\n<p>2）CDH6.3.2：国内使用最多的版本，但<br>CM不开源，但其实对中、小公司使用来说没有影响（建议使用）10000美金一个节点<br>CDP7.0</p>\n<p>3）HDP：开源，可以进行二次开发，但是没有CDH稳定，国内使用较少</p>\n<p><strong>4）云服务选择</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>（1）阿里云的EMR、MaxCompute、DataWorks</p>\n<p>（2）亚马逊云EMR</p>\n<p>（3）腾讯云EMR</p>\n<p>（4）华为云EMR</p></blockquote>\n<p>Apache框架版本</p>\n<p>+—————–+—————–+—————–+—————–+<br>| 产品            | 旧版本          | 新版本          | 版本新增        |<br>+—————–+—————–+—————–+—————–+<br>| Hadoop          | 2.7.2           | 3.1.3           | HDFS的web端口号由500 |<br>|                 |                 |                 | 70变为9870，    |<br>|                 |                 |                 |                 |<br>|                 |                 |                 | 客户端访问端口号9820&#x2F;80 |<br>|                 |                 |                 | 20&#x2F;9000         |<br>+—————–+—————–+—————–+—————–+<br>| Zookeeper       | 3.4.10          | 3.5.7           |                 |<br>+—————–+—————–+—————–+—————–+<br>| Mysql           | 5.6.24          | 5.7.16          | ①原生json支持：不需要遍历 |<br>|                 |                 |                 | 所有字符串、通过虚拟列的功能对 |<br>|                 |                 |                 | json的数据进行索引 |<br>|                 |                 |                 |                 |<br>|                 |                 |                 |                 |<br>|                 |                 |                 | ②多源复制：多主一从 |<br>|                 |                 |                 |                 |<br>|                 |                 |                 |                 |<br>|                 |                 |                 | ③InnoDB优化：为inno |<br>|                 |                 |                 | DB_buffer_poo |<br>|                 |                 |                 | l_size、       |<br>|                 |                 |                 |                 |<br>|                 |                 |                 | innoDB_log_fi |<br>|                 |                 |                 | le_size、innoDB |<br>|                 |                 |                 | _flush_method |<br>|                 |                 |                 | 提供了更加合适的默认值 |<br>+—————–+—————–+—————–+—————–+<br>| Hive            | 1.2.1           | 3.1.2           | （没有查到，查到的都是说不再支 |<br>|                 |                 |                 | 持mr引擎）      |<br>+—————–+—————–+—————–+—————–+<br>| Flume           | 1.7.0           | 1.9.0           |                 |<br>+—————–+—————–+—————–+—————–+<br>| Kafka           | 0.11-0.2        | _2.11-2.4.1、2. | ①kafka         |<br>|                 |                 | 8.0、3.0.0      | 0.9版本之前，offset保 |<br>|                 |                 |                 | 存在Zookeeper中；从0 |<br>|                 |                 |                 | .9版本开始，consumer |<br>|                 |                 |                 | 自己维护了一个offset |<br>|                 |                 |                 |                 |<br>|                 |                 |                 |                 |<br>|                 |                 |                 | ②允许使用者从最近的副本中获取 |<br>+—————–+—————–+—————–+—————–+<br>| Kafka Eagle     | 1.3.7           | 1.4.5           |                 |<br>+—————–+—————–+—————–+—————–+<br>| Azkaban         | 2.5.0           | 3.84.4          | 集成了给用户打电话的功能 |<br>+—————–+—————–+—————–+—————–+<br>| Spark           | 2.1.1           | 3.0.0           | 不支持scala     |<br>|                 |                 |                 | 2.11.x，升级为2.12. |<br>|                 |                 |                 | x               |<br>+—————–+—————–+—————–+—————–+<br>| Hbase           | 1.3.1           | 2.0.5           |                 |<br>+—————–+—————–+—————–+—————–+<br>| Phoenix         | 4.14.1          | 5.0.0           | 支持Apache      |<br>|                 |                 |                 | HBase 2.0       |<br>+—————–+—————–+—————–+—————–+<br>| Redis           | 3.2.5           | 3.2.5           |                 |<br>+—————–+—————–+—————–+—————–+<br>| Canal           | 1.1.2           | 1.1.2           |                 |<br>+—————–+—————–+—————–+—————–+<br>| ElasticSearch+K | 6.3.1           | 6.3.1           |                 |<br>| ibana           |                 |                 |                 |<br>+—————–+—————–+—————–+—————–+</p>\n<p>Azkaban、hive、kylin需要重新编译</p>\n<h2 id=\"2-5-服务器选型\"><a href=\"#2-5-服务器选型\" class=\"headerlink\" title=\"2.5 服务器选型\"></a>2.5 服务器选型</h2><p>服务器使用物理机还是云主机？</p>\n<p>1）机器成本考虑：</p>\n<p>（1）物理机：以128G内存，20核物理CPU，40线程，8THDD和2TSSD硬盘，单台报价4W出头，惠普品牌。一般物理机寿命5年左右。</p>\n<p>（2）云主机，以阿里云为例，差不多相同配置，每年5W</p>\n<p>2）运维成本考虑：</p>\n<p>（1）物理机：需要有专业的运维人员（1万*13个月）、电费（商业用户）、安装空调、场地</p>\n<p>（2）云主机：很多运维工作都由阿里云已经完成，运维相对较轻松</p>\n<p>3）企业选择</p>\n<p>（1）金融有钱公司选择阿里云（上海）</p>\n<p>（2）中小公司、为了融资上市，选择阿里云，拉到融资后买物理机。</p>\n<p>（3）有长期打算，资金比较足，选择物理机。</p>\n<h2 id=\"2-6-集群规模\"><a href=\"#2-6-集群规模\" class=\"headerlink\" title=\"2.6 集群规模\"></a>2.6 集群规模</h2><p>20核物理CPU 40线程 * 7 &#x3D; 280线程</p>\n<p>内存128g * 7台 &#x3D; 896g （计算任务内存700g，其他安装框架需要内存）</p>\n<p>128m &#x3D;》1g内存</p>\n<p>&#x3D;》</p>\n<p>87g数据 、700g内存</p>\n<p>根据数据规模大家集群（在企业，干了三年 通常服务器集群 5-20台之间）</p>\n<hr>\n<p>  1         2         3       4       5       6    7    8       9       10<br>  nn        nn        dn      dn      dn      dn   dn   dn      dn      dn<br>                      rm      rm      nm      nm   nm   nm      nm      nm<br>                      nm      nm<br>                                                        zk      zk      zk<br>                                                        kafka   kafka   kafka<br>                                                        Flume   Flume   flume<br>                      Hbase   Hbase   Hbase<br>  hive      hive<br>  mysql     mysql<br>  spark     spark<br>  Azkaban   Azkaban                           ES   ES                   </p>\n<hr>\n<p>1）消耗内存的分开；</p>\n<p>2）kafka 、zk 、flume 传输数据比较紧密的放在一起；</p>\n<p>3）客户端尽量放在一到两台服务器上，方便外部访问；</p>\n<p>4）有依赖关系的尽量放到同一台服务器（例如：Hive和Azkaban Executor）</p>\n<h2 id=\"2-7-人员配置参考\"><a href=\"#2-7-人员配置参考\" class=\"headerlink\" title=\"2.7 人员配置参考\"></a>2.7 人员配置参考</h2><h3 id=\"2-7-1-整体架构\"><a href=\"#2-7-1-整体架构\" class=\"headerlink\" title=\"2.7.1 整体架构\"></a>2.7.1 整体架构</h3><p>属于<strong>研发部</strong>&#x2F;技术部&#x2F;数据部，我们属于<strong>大数据组</strong>，其他还有后端项目组，前端组、测试组、UI组等。其他的还有产品部、运营部、人事部、财务部、行政部等。</p>\n<p>大数据开发工程师&#x3D;&gt;大数据组组长&#x3D;》项目经理&#x3D;&gt;部门经理&#x3D;》技术总监CTO</p>\n<h3 id=\"2-7-2-你们部门的职级等级，晋升规则\"><a href=\"#2-7-2-你们部门的职级等级，晋升规则\" class=\"headerlink\" title=\"2.7.2 你们部门的职级等级，晋升规则\"></a>2.7.2 你们部门的职级等级，晋升规则</h3><p>职级就分初级，中级，高级。晋升规则不一定，看公司效益和职位空缺。</p>\n<p>京东：T1、T2应届生；T3 14k左右 T4 18K左右 T5 24k-28k左右</p>\n<p>阿里：p5、p6、p7、p8</p>\n<p>字节：</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image72.png\">{width&#x3D;”4.191666666666666in”<br>height&#x3D;”2.703472222222222in”}</p>\n<h3 id=\"2-7-3-人员配置参考\"><a href=\"#2-7-3-人员配置参考\" class=\"headerlink\" title=\"2.7.3 人员配置参考\"></a>2.7.3 人员配置参考</h3><p>小型公司（1-3人左右）：组长1人，剩余组员无明确分工，并且可能兼顾javaEE和前端。</p>\n<p>中小型公司（3~6人左右）：组长1人，离线2人左右，实时1人左右（离线一般多于实时），组长兼顾和JavaEE、前端。</p>\n<p>中型公司（5<del>10人左右）：组长1人，离线3</del>5人左右（离线处理、数仓），实时2人左右，组长和技术大牛兼顾和javaEE、前端。</p>\n<p>中大型公司（10<del>20人左右）：组长1人，离线5</del>10人（离线处理、数仓），实时5人左右，JavaEE1人左右（负责对接JavaEE业务），前端1人（有或者没有人单独负责前端）。（发展比较良好的中大型公司可能大数据部门已经细化拆分，分成多个大数据组，分别负责不同业务）</p>\n<p>上面只是参考配置，因为公司之间差异很大，例如ofo大数据部门只有5个人左右，因此根据所选公司规模确定一个合理范围，在面试前必须将这个人员配置考虑清楚，回答时要非常确定。</p>\n<p>IOS多少人 安卓多少人 前端多少人 JavaEE多少人 测试多少人</p>\n<p>（IOS、安卓） 1-2个人 前端3个人；<br>JavaEE一般是大数据的1-1.5倍，测试：有的有，有的没有。1个左右。<br>产品经理1个、产品助理1-2个，运营1-3个</p>\n<p>公司划分：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>0-50 小公司</p>\n<p>50-500 中等</p>\n<p>500-1000 大公司</p>\n<p>1000以上 大厂 领军的存在</p></blockquote>\n<h1 id=\"第3章-数仓分层\"><a href=\"#第3章-数仓分层\" class=\"headerlink\" title=\"第3章 数仓分层\"></a>第3章 数仓分层</h1><h2 id=\"3-1-数据仓库建模（绝对重点）\"><a href=\"#3-1-数据仓库建模（绝对重点）\" class=\"headerlink\" title=\"3.1 数据仓库建模（绝对重点）\"></a>3.1 数据仓库建模（绝对重点）</h2><h3 id=\"3-1-1-建模工具是什么？\"><a href=\"#3-1-1-建模工具是什么？\" class=\"headerlink\" title=\"3.1.1 建模工具是什么？\"></a>3.1.1 建模工具是什么？</h3><p>PowerDesigner&#x2F;SQLYog&#x2F;EZDML</p>\n<h3 id=\"3-1-2-ODS层\"><a href=\"#3-1-2-ODS层\" class=\"headerlink\" title=\"3.1.2 ODS层\"></a>3.1.2 ODS层</h3><p>（1）保持数据原貌不做任何修改，起到备份数据的作用。</p>\n<p>（2）数据采用压缩，减少磁盘存储空间（例如：原始数据100G，可以压缩到10G左右）</p>\n<p>（3）创建分区表，防止后续的全表扫描</p>\n<h3 id=\"3-1-3-DWD层\"><a href=\"#3-1-3-DWD层\" class=\"headerlink\" title=\"3.1.3 DWD层\"></a>3.1.3 DWD层</h3><p>DWD层需构建维度模型，一般采用星型模型，呈现的状态一般为星座模型。</p>\n<p>维度建模一般按照以下四个步骤：</p>\n<p><strong>选择业务过程→声明粒度→确认维度→确认事实</strong></p>\n<p><strong>（1）选择业务过程</strong></p>\n<p>在业务系统中，如果业务表过多，挑选我们感兴趣的业务线，比如下单业务，支付业务，退款业务，物流业务，一条业务线对应一张事实表。如果小公司业务表比较少，建议选择所有业务线。</p>\n<p><strong>（2）声明粒度</strong></p>\n<p>数据粒度指数据仓库的数据中保存数据的细化程度或综合程度的级别。</p>\n<p>声明粒度意味着精确定义事实表中的一行数据表示什么，应该尽可能选择最小粒度，以此来应各种各样的需求。</p>\n<p><strong>典型的粒度声明如下：</strong></p>\n<p>订单当中的每个商品项作为下单事实表中的一行，粒度为每次</p>\n<p>每周的订单次数作为一行，粒度为每周。</p>\n<p>每月的订单次数作为一行，粒度为每月。</p>\n<p>如果在DWD层粒度就是每周或者每月，那么后续就没有办法统计细粒度的指标了。所有建议采用最小粒度。</p>\n<p><strong>（3）确定维度</strong></p>\n<p>维度的主要作用是描述业务是事实，主要表示的是”谁，何处，何时”等信息。例如：时间维度、用户维度、地区维度等常见维度。</p>\n<p><strong>（4）确定事实</strong></p>\n<p>此处的”事实”一词，指的是业务中的度量值，例如订单金额、下单次数等。</p>\n<p>在DWD层，以<strong>业务过程</strong>为建模驱动，基于每个具体业务过程的特点，构建<strong>最细粒度</strong>的明细层事实表。事实表可做适当的宽表化处理。</p>\n<p>通过以上步骤，结合本数仓的业务事实，得出业务总线矩阵表如下表所示。业务总线矩阵的原则，主要是根据维度表和事实表之间的关系，如果两者有关联则使用√标记。</p>\n<p>表 业务总线矩阵表</p>\n<hr>\n<pre><code>           时间   用户   地区   商品   优惠券   活动   编码   度量值\n</code></pre>\n<p>  订单         √      √      √                      √             件数&#x2F;金额<br>  订单详情     √             √      √                             件数&#x2F;金额<br>  支付         √             √                                    次数&#x2F;金额<br>  加购         √      √             √                             件数&#x2F;金额<br>  收藏         √      √             √                             个数<br>  评价         √      √             √                             个数<br>  退款         √      √             √                             件数&#x2F;金额<br>  优惠券领用   √      √                    √                      个数</p>\n<hr>\n<p>根据维度建模中的星型模型思想，将维度进行退化。例如下图所示：地区表和省份表退化为地区维度表，商品表、品类表、spu表、商品三级分类、商品二级分类、商品一级分类表退化为商品维度表，活动信息表和活动规则表退化为活动维度表。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image73.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.363888888888889in”}</p>\n<p>至此，数仓的维度建模已经完毕，DWS、DWT和ADS和维度建模已经没有关系了。</p>\n<p>DWS和DWT都是建宽表，宽表都是按照主题去建。主题相当于观察问题的角度。对应着维度表。</p>\n<h3 id=\"3-1-4-DWS层\"><a href=\"#3-1-4-DWS层\" class=\"headerlink\" title=\"3.1.4 DWS层\"></a>3.1.4 DWS层</h3><p>DWS层统计各个主题对象的当天行为，服务于DWT层的主题宽表。如图所示，DWS层的宽表字段，是站在不同维度的视角去看事实表，重点关注事实表的度量值，通过与之关联的事实表，获得不同的事实表的度量值。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image74.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.3340277777777776in”}</p>\n<h3 id=\"3-1-5-DWT层\"><a href=\"#3-1-5-DWT层\" class=\"headerlink\" title=\"3.1.5 DWT层\"></a>3.1.5 DWT层</h3><p>以分析的<strong>主题对象</strong>为建模驱动，基于上层的应用和产品的指标需求，构建主题对象的全量宽表。</p>\n<p>DWT层主题宽表都记录什么字段？</p>\n<p>如图所示，每个维度关联的不同事实表度量值以及首次、末次时间、累积至今的度量值、累积某个时间段的度量值。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image75.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.3625in”}</p>\n<h3 id=\"3-1-6-ADS层\"><a href=\"#3-1-6-ADS层\" class=\"headerlink\" title=\"3.1.6 ADS层\"></a>3.1.6 ADS层</h3><p>分别对设备主题、会员主题、商品主题和营销主题进行指标分析，其中营销主题是用户主题和商品主题的跨主题分析案例</p>\n<h2 id=\"3-2-ODS层做了哪些事？\"><a href=\"#3-2-ODS层做了哪些事？\" class=\"headerlink\" title=\"3.2 ODS层做了哪些事？\"></a>3.2 ODS层做了哪些事？</h2><p>1）保持数据原貌，不做任何修改</p>\n<p>2）压缩采用LZO，压缩比是100g数据压缩完10g左右。</p>\n<p>3）创建分区表</p>\n<h2 id=\"3-3-DWD层做了哪些事？\"><a href=\"#3-3-DWD层做了哪些事？\" class=\"headerlink\" title=\"3.3 DWD层做了哪些事？\"></a>3.3 DWD层做了哪些事？</h2><h3 id=\"3-3-1-数据清洗\"><a href=\"#3-3-1-数据清洗\" class=\"headerlink\" title=\"3.3.1 数据清洗\"></a>3.3.1 数据清洗</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>（1）空值去除</p>\n<p>（2）过滤核心字段无意义的数据，比如订单表中订单id为null，支付表中支付id为空</p>\n<p>（3）将用户行为宽表和业务表进行数据一致性处理</p>\n<p>select case when a is null then b else a end as JZR,</p>\n<p>…</p>\n<p>from A</p></blockquote>\n<h3 id=\"3-3-2-清洗的手段\"><a href=\"#3-3-2-清洗的手段\" class=\"headerlink\" title=\"3.3.2 清洗的手段\"></a>3.3.2 清洗的手段</h3><p>HQL、MR、SparkSQL、Kettle、Python（项目中采用sql进行清除）</p>\n<h3 id=\"3-3-3-清洗掉多少数据算合理\"><a href=\"#3-3-3-清洗掉多少数据算合理\" class=\"headerlink\" title=\"3.3.3 清洗掉多少数据算合理\"></a>3.3.3 清洗掉多少数据算合理</h3><p>1万条数据清洗掉1条。</p>\n<h3 id=\"3-3-4-脱敏\"><a href=\"#3-3-4-脱敏\" class=\"headerlink\" title=\"3.3.4 脱敏\"></a>3.3.4 脱敏</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对手机号、身份证号等敏感数据脱敏</p></blockquote>\n<h3 id=\"3-3-5-维度退化\"><a href=\"#3-3-5-维度退化\" class=\"headerlink\" title=\"3.3.5 维度退化\"></a>3.3.5 维度退化</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对业务数据传过来的表进行维度退化和降维。（商品一级二级三级、省市县、年月日）</p>\n<p>商品表、spu表、品类表、商品一级分类、二级分类、三级分类&#x3D;》商品表</p>\n<p>省份表、地区表&#x3D;》地区表</p></blockquote>\n<h3 id=\"3-3-6-压缩LZO\"><a href=\"#3-3-6-压缩LZO\" class=\"headerlink\" title=\"3.3.6 压缩LZO\"></a>3.3.6 压缩LZO</h3><h3 id=\"3-3-7-列式存储parquet\"><a href=\"#3-3-7-列式存储parquet\" class=\"headerlink\" title=\"3.3.7 列式存储parquet\"></a>3.3.7 列式存储parquet</h3><h2 id=\"3-4-DWS层做了哪些事？\"><a href=\"#3-4-DWS层做了哪些事？\" class=\"headerlink\" title=\"3.4 DWS层做了哪些事？\"></a>3.4 DWS层做了哪些事？</h2><h3 id=\"3-4-1-DWS层有6张宽表（处理100-200个指标-70-以上的需求）\"><a href=\"#3-4-1-DWS层有6张宽表（处理100-200个指标-70-以上的需求）\" class=\"headerlink\" title=\"3.4.1 DWS层有6张宽表（处理100-200个指标 70%以上的需求）\"></a>3.4.1 DWS层有6张宽表（处理100-200个指标 70%以上的需求）</h3><p>具体宽表名称：用户行为宽表，商品宽表，访客宽表、活动宽表、优惠卷、地区表等。</p>\n<h3 id=\"3-4-2-哪个宽表最宽？大概有多少个字段？\"><a href=\"#3-4-2-哪个宽表最宽？大概有多少个字段？\" class=\"headerlink\" title=\"3.4.2 哪个宽表最宽？大概有多少个字段？\"></a>3.4.2 哪个宽表最宽？大概有多少个字段？</h3><p>最宽的是用户行为宽表。大概有60-100个字段</p>\n<h3 id=\"3-4-3-具体用户行为宽表字段名称\"><a href=\"#3-4-3-具体用户行为宽表字段名称\" class=\"headerlink\" title=\"3.4.3 具体用户行为宽表字段名称\"></a>3.4.3 具体用户行为宽表字段名称</h3><p>评论、打赏、收藏、关注–商品、关注–人、点赞、分享、好价爆料、文章发布、活跃、签到、补签卡、幸运屋、礼品、金币、电商点击、gmv</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>CREATE TABLE <code>app_usr_interact</code>(</p>\n<p><code>stat_dt</code> date COMMENT ‘互动日期’,</p>\n<p><code>user_id</code> string COMMENT ‘用户id’,</p>\n<p><code>nickname</code> string COMMENT ‘用户昵称’,</p>\n<p><code>register_date</code> string COMMENT ‘注册日期’,</p>\n<p><code>register_from</code> string COMMENT ‘注册来源’,</p>\n<p><code>remark</code> string COMMENT ‘细分渠道’,</p>\n<p><code>province</code> string COMMENT ‘注册省份’,</p>\n<p><code>pl_cnt</code> bigint COMMENT ‘评论次数’,</p>\n<p><code>ds_cnt</code> bigint COMMENT ‘打赏次数’,</p>\n<p><code>sc_add</code> bigint COMMENT ‘添加收藏’,</p>\n<p><code>sc_cancel</code> bigint COMMENT ‘取消收藏’,</p>\n<p><code>gzg_add</code> bigint COMMENT ‘关注商品’,</p>\n<p><code>gzg_cancel</code> bigint COMMENT ‘取消关注商品’,</p>\n<p><code>gzp_add</code> bigint COMMENT ‘关注人’,</p>\n<p><code>gzp_cancel</code> bigint COMMENT ‘取消关注人’,</p>\n<p><code>buzhi_cnt</code> bigint COMMENT ‘点不值次数’,</p>\n<p><code>zhi_cnt</code> bigint COMMENT ‘点值次数’,</p>\n<p><code>zan_cnt</code> bigint COMMENT ‘点赞次数’,</p>\n<p><code>share_cnts</code> bigint COMMENT ‘分享次数’,</p>\n<p><code>bl_cnt</code> bigint COMMENT ‘爆料数’,</p>\n<p><code>fb_cnt</code> bigint COMMENT ‘好价发布数’,</p>\n<p><code>online_cnt</code> bigint COMMENT ‘活跃次数’,</p>\n<p><code>checkin_cnt</code> bigint COMMENT ‘签到次数’,</p>\n<p><code>fix_checkin</code> bigint COMMENT ‘补签次数’,</p>\n<p><code>house_point</code> bigint COMMENT ‘幸运屋金币抽奖次数’,</p>\n<p><code>house_gold</code> bigint COMMENT ‘幸运屋积分抽奖次数’,</p>\n<p><code>pack_cnt</code> bigint COMMENT ‘礼品兑换次数’,</p>\n<p><code>gold_add</code> bigint COMMENT ‘获取金币’,</p>\n<p><code>gold_cancel</code> bigint COMMENT ‘支出金币’,</p>\n<p><code>surplus_gold</code> bigint COMMENT ‘剩余金币’,</p>\n<p><code>event</code> bigint COMMENT ‘电商点击次数’,</p>\n<p><code>gmv_amount</code> bigint COMMENT ‘gmv’,</p>\n<p><code>gmv_sales</code> bigint COMMENT ‘订单数’)</p>\n<p>PARTITIONED BY ( <code>dt</code> string)</p></blockquote>\n<h3 id=\"3-4-4-哪张表数据量最多\"><a href=\"#3-4-4-哪张表数据量最多\" class=\"headerlink\" title=\"3.4.4 哪张表数据量最多\"></a>3.4.4 哪张表数据量最多</h3><p>用户行为宽表：</p>\n<p>dws &#x3D;》 6张</p>\n<p>100g &#x3D;》 40g &#x2F; 6 &#x3D; 6.7 g 2* 3倍 &#x3D; 15g &#x3D;》 1500万条</p>\n<h2 id=\"3-5-ADS层分析过哪些指标\"><a href=\"#3-5-ADS层分析过哪些指标\" class=\"headerlink\" title=\"3.5 ADS层分析过哪些指标\"></a>3.5 ADS层分析过哪些指标</h2><h3 id=\"3-5-1-分析过的指标（一分钟至少说出30个指标）\"><a href=\"#3-5-1-分析过的指标（一分钟至少说出30个指标）\" class=\"headerlink\" title=\"3.5.1 分析过的指标（一分钟至少说出30个指标）\"></a>3.5.1 分析过的指标（一分钟至少说出30个指标）</h3><p>日活、月活、周活、留存、留存率、新增（日、周、年）、转化率、流失、回流、七天内连续3天登录（点赞、收藏、评价、购买、加购、下单、活动）、连续3周（月）登录、GMV、复购率、复购率排行、点赞、评论、收藏、领优惠卷人数、使用优惠卷人数、沉默、值不值得买、退款人数、退款率<br>topn 热门商品</p>\n<p>产品经理最关心的：留转G复活</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image76.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”6.031944444444444in”}</p>\n<h3 id=\"3-5-2-留转G复活指标\"><a href=\"#3-5-2-留转G复活指标\" class=\"headerlink\" title=\"3.5.2 留转G复活指标\"></a>3.5.2 留转G复活指标</h3><p>（1）活跃</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>日活：100万 ；周活是日活的1.1-1.3倍；月活：是日活的2-3倍 300万</p>\n<p>总注册的用户多少？1000万-3000万之间</p>\n<p>渠道来源：app 公众号 抖音 百度 36 头条 地推</p></blockquote>\n<p>（2）GMV</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>GMV：每天 10万订单 （50 – 100元） 500万-1000万</p>\n<p>10%-20% 100万-200万（人员：程序员、人事、行政、财务、房租、收电费）</p></blockquote>\n<p>（3）复购率</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>某日常商品复购；（手纸、面膜、牙膏）10%-20%</p></blockquote>\n<p>电脑、显示器、手表 1%</p>\n<p>（4）转化率</p>\n<p>商品详情 &#x3D;》 加购物车 &#x3D;》下单 &#x3D;》 支付</p>\n<p>5%-10% 60-70% 90%-95%</p>\n<p>（5）留存率</p>\n<p>1&#x2F;2&#x2F;3、周留存、月留存</p>\n<p>搞活动： 10-20%</p>\n<h3 id=\"3-5-3-哪个商品卖的好？\"><a href=\"#3-5-3-哪个商品卖的好？\" class=\"headerlink\" title=\"3.5.3 哪个商品卖的好？\"></a>3.5.3 哪个商品卖的好？</h3><p>面膜、手纸，每天销售5000个</p>\n<h2 id=\"3-6-ADS层手写指标\"><a href=\"#3-6-ADS层手写指标\" class=\"headerlink\" title=\"3.6 ADS层手写指标\"></a>3.6 ADS层手写指标</h2><h3 id=\"3-6-1-如何分析用户活跃？\"><a href=\"#3-6-1-如何分析用户活跃？\" class=\"headerlink\" title=\"3.6.1 如何分析用户活跃？\"></a>3.6.1 如何分析用户活跃？</h3><p>在启动日志中统计不同设备id出现次数。去重</p>\n<h3 id=\"3-6-2-如何分析用户新增？vivo\"><a href=\"#3-6-2-如何分析用户新增？vivo\" class=\"headerlink\" title=\"3.6.2 如何分析用户新增？vivo\"></a>3.6.2 如何分析用户新增？vivo</h3><p>用活跃用户表 left join 用户新增表，用户新增表中mid为空的即为用户新增。</p>\n<h3 id=\"3-6-3-如何分析用户1天留存？\"><a href=\"#3-6-3-如何分析用户1天留存？\" class=\"headerlink\" title=\"3.6.3 如何分析用户1天留存？\"></a>3.6.3 如何分析用户1天留存？</h3><p>留存用户&#x3D;前一天新增 join 今天活跃</p>\n<p>用户留存率&#x3D;留存用户&#x2F;前一天新增</p>\n<h3 id=\"3-6-4-如何分析沉默用户？\"><a href=\"#3-6-4-如何分析沉默用户？\" class=\"headerlink\" title=\"3.6.4 如何分析沉默用户？\"></a>3.6.4 如何分析沉默用户？</h3><p>（登录时间为7天前，且只出现过一次）</p>\n<p>按照设备id对日活表分组，登录次数为1，且是在一周前登录。</p>\n<h3 id=\"3-6-5-如何分析本周回流用户？\"><a href=\"#3-6-5-如何分析本周回流用户？\" class=\"headerlink\" title=\"3.6.5 如何分析本周回流用户？\"></a>3.6.5 如何分析本周回流用户？</h3><p>本周活跃left join本周新增 left<br>join上周活跃，且本周新增id和上周活跃id都为null</p>\n<h3 id=\"3-6-6-如何分析流失用户？\"><a href=\"#3-6-6-如何分析流失用户？\" class=\"headerlink\" title=\"3.6.6 如何分析流失用户？\"></a>3.6.6 如何分析流失用户？</h3><p>（登录时间为7天前）</p>\n<p>按照设备id对日活表分组，且七天内没有登录过。</p>\n<h3 id=\"3-6-7-如何分析最近连续3周活跃用户数？\"><a href=\"#3-6-7-如何分析最近连续3周活跃用户数？\" class=\"headerlink\" title=\"3.6.7 如何分析最近连续3周活跃用户数？\"></a>3.6.7 如何分析最近连续3周活跃用户数？</h3><p>按照设备id对周活进行分组，统计次数大于3次。</p>\n<h3 id=\"3-6-8-如何分析最近七天内连续三天活跃用户数？\"><a href=\"#3-6-8-如何分析最近七天内连续三天活跃用户数？\" class=\"headerlink\" title=\"3.6.8 如何分析最近七天内连续三天活跃用户数？\"></a>3.6.8 如何分析最近七天内连续三天活跃用户数？</h3><p>1）查询出最近7天的活跃用户，并对用户活跃日期进行排名</p>\n<p>2）计算用户活跃日期及排名之间的差值</p>\n<p>3）对同用户及差值分组，统计差值个数</p>\n<p>4）将差值相同个数大于等于3的数据取出，然后去重(去的是什么重???)，即为连续3天及以上活跃的用户</p>\n<p>7天连续收藏、点赞、购买、加购、付款、浏览、商品点击、退货</p>\n<p>1个月连续7天</p>\n<p>连续两周：</p>\n<h2 id=\"3-7-分析过最难的指标\"><a href=\"#3-7-分析过最难的指标\" class=\"headerlink\" title=\"3.7 分析过最难的指标\"></a>3.7 分析过最难的指标</h2><h3 id=\"3-7-1-最近连续3周活跃用户\"><a href=\"#3-7-1-最近连续3周活跃用户\" class=\"headerlink\" title=\"3.7.1 最近连续3周活跃用户\"></a>3.7.1 最近连续3周活跃用户</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image77.png\"></p>\n<h3 id=\"3-7-2-最近7天连续3天活跃用户数\"><a href=\"#3-7-2-最近7天连续3天活跃用户数\" class=\"headerlink\" title=\"3.7.2 最近7天连续3天活跃用户数\"></a>3.7.2 最近7天连续3天活跃用户数</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image78.png\"></p>\n<h3 id=\"3-7-3-运费分摊\"><a href=\"#3-7-3-运费分摊\" class=\"headerlink\" title=\"3.7.3 运费分摊\"></a>3.7.3 运费分摊</h3><h3 id=\"3-7-4-城市备注\"><a href=\"#3-7-4-城市备注\" class=\"headerlink\" title=\"3.7.4 城市备注\"></a>3.7.4 城市备注</h3><h1 id=\"第4章-生产经验—业务\"><a href=\"#第4章-生产经验—业务\" class=\"headerlink\" title=\"第4章 生产经验—业务\"></a>第4章 生产经验—业务</h1><h2 id=\"4-1-电商常识\"><a href=\"#4-1-电商常识\" class=\"headerlink\" title=\"4.1 电商常识\"></a>4.1 电商常识</h2><h3 id=\"4-1-1-SKU和SPU\"><a href=\"#4-1-1-SKU和SPU\" class=\"headerlink\" title=\"4.1.1 SKU和SPU\"></a>4.1.1 SKU和SPU</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SKU：一台银色、128G内存的、支持联通网络的iPhoneX</p>\n<p>SPU：iPhoneX</p>\n<p>Tm_id：品牌Id苹果，包括IPHONE，耳机，MAC等</p></blockquote>\n<h3 id=\"4-1-2-订单表跟订单详情表区别？\"><a href=\"#4-1-2-订单表跟订单详情表区别？\" class=\"headerlink\" title=\"4.1.2 订单表跟订单详情表区别？\"></a>4.1.2 订单表跟订单详情表区别？</h3><p>订单表的订单状态会变化，订单详情表不会，因为没有订单状态。</p>\n<p>订单表记录user_id，订单id订单编号，订单的总金额order_status，支付方式，订单状态等。</p>\n<p>订单详情表记录user_id，商品sku_id<br>，具体的商品信息（商品名称sku_name，价格order_price，数量sku_num）</p>\n<h2 id=\"4-2-埋点行为数据基本格式（基本字段）\"><a href=\"#4-2-埋点行为数据基本格式（基本字段）\" class=\"headerlink\" title=\"4.2 埋点行为数据基本格式（基本字段）\"></a>4.2 埋点行为数据基本格式（基本字段）</h2><p>我们要收集和分析的数据主要包括<strong>页面数据</strong>、<strong>事件数据、曝光数据、启动数据和错误数据</strong>。</p>\n<h3 id=\"4-2-1-页面\"><a href=\"#4-2-1-页面\" class=\"headerlink\" title=\"4.2.1 页面\"></a>4.2.1 页面</h3><p>页面数据主要记录一个页面的用户访问情况，包括访问时间、停留时间、页面路径等信息。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image79.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.2993055555555557in”}</p>\n<p>所有页面id如下</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>home(“首页”),</p>\n<p>category(“分类页”),</p>\n<p>discovery(“发现页”),</p>\n<p>top_n(“热门排行”),</p>\n<p>favor(“收藏页”),</p>\n<p>search(“搜索页”),</p>\n<p>good_list(“商品列表页”),</p>\n<p>good_detail(“商品详情”),</p>\n<p>good_spec(“商品规格”),</p>\n<p>comment(“评价”),</p>\n<p>comment_done(“评价完成”),</p>\n<p>comment_list(“评价列表”),</p>\n<p>cart(“购物车”),</p>\n<p>trade(“下单结算”),</p>\n<p>payment(“支付页面”),</p>\n<p>payment_done(“支付完成”),</p>\n<p>orders_all(“全部订单”),</p>\n<p>orders_unpaid(“订单待支付”),</p>\n<p>orders_undelivered(“订单待发货”),</p>\n<p>orders_unreceipted(“订单待收货”),</p>\n<p>orders_wait_comment(“订单待评价”),</p>\n<p>mine(“我的”),</p>\n<p>activity(“活动”),</p>\n<p>login(“登录”),</p>\n<p>register(“注册”);</p></blockquote>\n<p>所有页面对象类型如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>sku_id(“商品skuId”),</p>\n<p>keyword(“搜索关键词”),</p>\n<p>sku_ids(“多个商品skuId”),</p>\n<p>activity_id(“活动id”),</p>\n<p>coupon_id(“购物券id”);</p></blockquote>\n<p>所有来源类型如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>promotion(“商品推广”),</p>\n<p>recommend(“算法推荐商品”),</p>\n<p>query(“查询结果商品”),</p>\n<p>activity(“促销活动”);</p></blockquote>\n<h3 id=\"4-2-2-事件\"><a href=\"#4-2-2-事件\" class=\"headerlink\" title=\"4.2.2 事件\"></a>4.2.2 事件</h3><p>事件数据主要记录应用内一个具体操作行为，包括操作类型、操作对象、操作对象描述等信息。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image80.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.188888888888889in”}</p>\n<p>所有动作类型如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>favor_add(“添加收藏”),</p>\n<p>favor_canel(“取消收藏”),</p>\n<p>cart_add(“添加购物车”),</p>\n<p>cart_remove(“删除购物车”),</p>\n<p>cart_add_num(“增加购物车商品数量”),</p>\n<p>cart_minus_num(“减少购物车商品数量”),</p>\n<p>trade_add_address(“增加收货地址”),</p>\n<p>get_coupon(“领取优惠券”);</p></blockquote>\n<p>注：对于下单、支付等业务数据，可从业务数据库获取。</p>\n<p>所有动作目标类型如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>sku_id(“商品”),</p>\n<p>coupon_id(“购物券”);</p></blockquote>\n<h3 id=\"4-2-3-曝光\"><a href=\"#4-2-3-曝光\" class=\"headerlink\" title=\"4.2.3 曝光\"></a>4.2.3 曝光</h3><p>曝光数据主要记录页面所曝光的内容，包括曝光对象，曝光类型等信息。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image81.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.0194444444444444in”}</p>\n<p>所有曝光类型如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>promotion(“商品推广”),<br>recommend(“算法推荐商品”),<br>query(“查询结果商品”),<br>activity(“促销活动”);</p></blockquote>\n<p>所有曝光对象类型如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>sku_id(“商品skuId”),</p>\n<p>activity_id(“活动id”);</p></blockquote>\n<h3 id=\"4-2-4-启动\"><a href=\"#4-2-4-启动\" class=\"headerlink\" title=\"4.2.4 启动\"></a>4.2.4 启动</h3><p>启动数据记录应用的启动信息。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image82.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.0548611111111112in”}</p>\n<p>所有启动入口类型如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>icon(“图标”),<br>notification(“通知”),<br>install(“安装后启动”);</p></blockquote>\n<h3 id=\"4-2-5-错误\"><a href=\"#4-2-5-错误\" class=\"headerlink\" title=\"4.2.5 错误\"></a>4.2.5 错误</h3><p>错误数据记录应用使用过程中的错误信息，包括错误编号及错误信息。</p>\n<h3 id=\"4-2-6-埋点数据日志格式\"><a href=\"#4-2-6-埋点数据日志格式\" class=\"headerlink\" title=\"4.2.6 埋点数据日志格式\"></a>4.2.6 埋点数据日志格式</h3><p>我们的日志结构大致可分为两类，一是普通页面埋点日志，二是启动日志。</p>\n<p>普通页面日志结构如下，每条日志包含了，当前页面的页面信息，所有事件（动作）、所有曝光信息以及错误信息。除此之外，还包含了一系列公共信息，包括设备信息，地理位置，应用信息等，即下边的common字段。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>{</p>\n<p>“common”: { – 公共信息</p>\n<p>“ar”: “230000”, – 地区编码</p>\n<p>“ba”: “iPhone”, – 手机品牌</p>\n<p>“ch”: “Appstore”, – 渠道</p>\n<p>“md”: “iPhone 8”, – 手机型号</p>\n<p>“mid”: “YXfhjAYH6As2z9Iq”, – 设备id</p>\n<p>“os”: “iOS 13.2.9”, – 操作系统</p>\n<p>“uid”: “485”, – 会员id</p>\n<p>“vc”: “v2.1.134” – app版本号</p>\n<p>},</p>\n<p>“actions”: [ –动作(事件)</p>\n<p>{</p>\n<p>“action_id”: “favor_add”, –动作id</p>\n<p>“item”: “3”, –目标id</p>\n<p>“item_type”: “sku_id”, –目标类型</p>\n<p>“ts”: 1585744376605 –动作时间戳</p>\n<p>}</p>\n<p>]，</p>\n<p>“displays”: [</p>\n<p>{</p>\n<p>“displayType”: “query”, – 曝光类型</p>\n<p>“item”: “3”, – 曝光对象id</p>\n<p>“item_type”: “sku_id”, – 曝光对象类型</p>\n<p>“order”: 1 –出现顺序</p>\n<p>},</p>\n<p>{</p>\n<p>“displayType”: “promotion”,</p>\n<p>“item”: “6”,</p>\n<p>“item_type”: “sku_id”,</p>\n<p>“order”: 2</p>\n<p>},</p>\n<p>{</p>\n<p>“displayType”: “promotion”,</p>\n<p>“item”: “9”,</p>\n<p>“item_type”: “sku_id”,</p>\n<p>“order”: 3</p>\n<p>},</p>\n<p>{</p>\n<p>“displayType”: “recommend”,</p>\n<p>“item”: “6”,</p>\n<p>“item_type”: “sku_id”,</p>\n<p>“order”: 4</p>\n<p>},</p>\n<p>{</p>\n<p>“displayType”: “query “,</p>\n<p>“item”: “6”,</p>\n<p>“item_type”: “sku_id”,</p>\n<p>“order”: 5</p>\n<p>}</p>\n<p>],</p>\n<p>“page”: { –页面信息</p>\n<p>“during_time”: 7648, – 持续时间毫秒</p>\n<p>“item”: “3”, – 目标id</p>\n<p>“item_type”: “sku_id”, – 目标类型</p>\n<p>“last_page_id”: “login”, – 上页类型</p>\n<p>“page_id”: “good_detail”, – 页面ID</p>\n<p>“sourceType”: “promotion” – 来源类型</p>\n<p>},</p>\n<p>“err”:{ –错误</p>\n<p>“error_code”: “1234”, –错误码</p>\n<p>“msg”: “***********” –错误信息</p>\n<p>},</p>\n<p>“ts”: 1585744374423 –跳入时间戳</p>\n<p>}</p></blockquote>\n<p>启动日志结构相对简单，主要包含公共信息，启动信息和错误信息。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>{</p>\n<p>“common”: {</p>\n<p>“ar”: “370000”,</p>\n<p>“ba”: “Honor”,</p>\n<p>“ch”: “wandoujia”,</p>\n<p>“md”: “Honor 20s”,</p>\n<p>“mid”: “eQF5boERMJFOujcp”,</p>\n<p>“os”: “Android 11.0”,</p>\n<p>“uid”: “76”,</p>\n<p>“vc”: “v2.1.134”</p>\n<p>},</p>\n<p>“start”: {</p>\n<p>“entry”: “icon”, –icon手机图标 notice 通知 install 安装后启动</p>\n<p>“loading_time”: 18803, –启动加载时间</p>\n<p>“open_ad_id”: 7, –广告页ID</p>\n<p>“open_ad_ms”: 3449, – 广告总共播放时间</p>\n<p>“open_ad_skip_ms”: 1989 – 用户跳过广告时点</p>\n<p>},</p>\n<p>“err”:{ –错误</p>\n<p>“error_code”: “1234”, –错误码</p>\n<p>“msg”: “***********” –错误信息</p>\n<p>},</p>\n<p>“ts”: 1585744304000</p>\n<p>}</p></blockquote>\n<h2 id=\"4-3-电商业务流程\"><a href=\"#4-3-电商业务流程\" class=\"headerlink\" title=\"4.3 电商业务流程\"></a>4.3 电商业务流程</h2><p>1）记住表与表之间的关系</p>\n<p>2）每个表记住2-3个字段</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image83.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.2583333333333333in”}</p>\n<h2 id=\"4-4-维度表和事实表（重点）\"><a href=\"#4-4-维度表和事实表（重点）\" class=\"headerlink\" title=\"4.4 维度表和事实表（重点）\"></a>4.4 维度表和事实表（重点）</h2><h3 id=\"4-4-1-维度表\"><a href=\"#4-4-1-维度表\" class=\"headerlink\" title=\"4.4.1 维度表\"></a>4.4.1 维度表</h3><p><strong>维度表</strong>：一般是对事实的<strong>描述信息</strong>。每一张维表对应现实世界中的一个对象或者概念。<br>例如：用户、商品、日期、地区等。</p>\n<h3 id=\"4-4-2-事实表\"><a href=\"#4-4-2-事实表\" class=\"headerlink\" title=\"4.4.2 事实表\"></a>4.4.2 事实表</h3><p><strong>事实表中的每行数据代表一个业务事件（下单、支付、退款、评价等）</strong>。”事实”这个术语表示的是业务事件的<strong>度量值（可统计次数、个数、件数、金额等）</strong>，例如，订单事件中的下单金额。</p>\n<p>每一个事实表的行包括：具有可加性的数值型的度量值、与维表相连接的外键、通常具有两个和两个以上的外键、外键之间表示维表之间多对多的关系。</p>\n<p><strong>1）事务型事实表</strong></p>\n<p>以<strong>每个事务或事件为单位</strong>，例如一个销售订单记录，一笔支付记录等，作为事实表里的一行数据。一旦事务被提交，事实表数据被插入，数据就不再进行更改，其更新方式为增量更新。</p>\n<p><strong>2）周期型快照事实表</strong></p>\n<p>周期型快照事实表中<strong>不会保留所有数据</strong>，<strong>只保留固定时间间隔的数据</strong>，例如每天或者每月的销售额，或每月的账户余额等。</p>\n<p><strong>3）累积型快照事实表</strong></p>\n<p><strong>累计快照事实表用于跟踪业务事实的变化。</strong>例如，数据仓库中可能需要累积或者存储订单从下订单开始，到订单商品被打包、运输、和签收的各个业务阶段的时间点数据来跟踪订单声明周期的进展情况。当这个业务过程进行时，事实表的记录也要不断更新。</p>\n<hr>\n<p>  <strong>订单id</strong>   <strong>用户id</strong>   <strong>下单时间</strong>   <strong>打包时间</strong>   <strong>发货时间</strong>   <strong>签收时间</strong>   <strong>订单金额</strong><br>                            3-8            3-8            3-9            3-10           </p>\n<hr>\n<h2 id=\"4-5-同步策略（重点）\"><a href=\"#4-5-同步策略（重点）\" class=\"headerlink\" title=\"4.5 同步策略（重点）\"></a>4.5 同步策略（重点）</h2><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image84.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.9659722222222222in”}</p>\n<h2 id=\"4-6-关系型数据库范式理论（ER建模）\"><a href=\"#4-6-关系型数据库范式理论（ER建模）\" class=\"headerlink\" title=\"4.6 关系型数据库范式理论（ER建模）\"></a>4.6 关系型数据库范式理论（ER建模）</h2><p>1NF：属性不可再分割（例如不能存在5台电脑的属性，坏处：表都没法用）</p>\n<p>2NF：不能存在部分函数依赖（例如主键（学号+课名）–&gt;成绩，姓名，但学号–》姓名，所以姓名部分依赖于主键（学号+课名），所以要去除，坏处：数据冗余）</p>\n<p>3NF：不能存在传递函数依赖（学号–》宿舍种类–》价钱，坏处：数据冗余和增删异常）</p>\n<p>MySQL关系模型：关系模型主要应用与OLTP系统中，为了保证数据的一致性以及避免冗余，所以大部分业务系统的表都是遵循第三范式的。</p>\n<p>Hive<br>维度模型：维度模型主要应用于OLAP系统中，因为关系模型虽然冗余少，但是在大规模数据，跨表分析统计查询过程中，会造成多表关联，这会大大降低执行效率。所以HIVE把相关各种表整理成两种：事实表和维度表两种。所有维度表围绕着事实表进行解释。</p>\n<h2 id=\"4-7-数据模型\"><a href=\"#4-7-数据模型\" class=\"headerlink\" title=\"4.7 数据模型\"></a>4.7 数据模型</h2><p>雪花模型、星型模型和星座模型</p>\n<p>（在维度建模的基础上又分为三种模型：星型模型、雪花模型、星座模型）</p>\n<p><strong>星型模型（一级维度表）</strong>，雪花（多级维度），星座模型（星型模型+多个事实表）</p>\n<h2 id=\"4-8-拉链表（重点）\"><a href=\"#4-8-拉链表（重点）\" class=\"headerlink\" title=\"4.8 拉链表（重点）\"></a>4.8 拉链表（重点）</h2><p>拉链表处理的业务场景：主要处理缓慢变化维的业务场景。（用户表、订单表）</p>\n<h2 id=\"4-9-即席查询数据仓库\"><a href=\"#4-9-即席查询数据仓库\" class=\"headerlink\" title=\"4.9 即席查询数据仓库\"></a>4.9 即席查询数据仓库</h2><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image86.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.2430555555555554in”}</p>\n<p>Kylin: T+1</p>\n<p>Impala: CDH</p>\n<p>Presto: Apache版本框架</p>\n<h2 id=\"4-10-数据仓库每天跑多少张表，大概什么时候运行，运行多久？\"><a href=\"#4-10-数据仓库每天跑多少张表，大概什么时候运行，运行多久？\" class=\"headerlink\" title=\"4.10 数据仓库每天跑多少张表，大概什么时候运行，运行多久？\"></a>4.10 数据仓库每天跑多少张表，大概什么时候运行，运行多久？</h2><p>基本一个项目建一个库，表格个数为初始的原始数据表格加上统计结果表格的总数。（一般70-100张表格）</p>\n<p>用户行为5张；业务数据33张表 &#x3D;》ods34 &#x3D;》dwd&#x3D;&gt;32张&#x3D;》dws<br>6张宽表&#x3D;&gt;dwt6张宽表&#x3D;&gt;ads&#x3D;》30张 &#x3D;》108张</p>\n<p>每天0：10开始运行。&#x3D;》sqoop 20-30分钟：1点：&#x3D;》 5-6个小时运行完指标</p>\n<p>所有离线数据报表控制在8小时之内</p>\n<p>大数据实时处理部分控制在5分钟之内。（分钟级别、秒级别）</p>\n<p>如果是实时推荐系统，需要秒级响应</p>\n<h2 id=\"4-11-活动的话，数据量会增加多少？怎么解决？\"><a href=\"#4-11-活动的话，数据量会增加多少？怎么解决？\" class=\"headerlink\" title=\"4.11 活动的话，数据量会增加多少？怎么解决？\"></a>4.11 活动的话，数据量会增加多少？怎么解决？</h2><p>日活增加50%，GMV增加多少20%。（留转G复活）情人节，促销手纸。</p>\n<p>集群资源都留有预量。11.11，6.18，数据量过大，提前动态增加服务器。</p>\n<h2 id=\"4-12-并发峰值多少？大概哪个时间点？\"><a href=\"#4-12-并发峰值多少？大概哪个时间点？\" class=\"headerlink\" title=\"4.12 并发峰值多少？大概哪个时间点？ \"></a>4.12 并发峰值多少？大概哪个时间点？ </h2><p>高峰期晚上7-12点。Kafka里面20m&#x2F;s 2万&#x2F;s 并发峰值在1-2万人</p>\n<h2 id=\"4-13-数仓中使用的哪种文件存储格式\"><a href=\"#4-13-数仓中使用的哪种文件存储格式\" class=\"headerlink\" title=\"4.13 数仓中使用的哪种文件存储格式\"></a>4.13 数仓中使用的哪种文件存储格式</h2><p>常用的包括：textFile，ORC，Parquet，一般企业里使用ORC或者Parquet，因为是列式存储，且压缩比非常高，所以相比于textFile，查询速度快，占用硬盘空间少</p>\n<h2 id=\"4-14-哪张表最费时间，有没有优化\"><a href=\"#4-14-哪张表最费时间，有没有优化\" class=\"headerlink\" title=\"4.14 哪张表最费时间，有没有优化\"></a>4.14 哪张表最费时间，有没有优化</h2><p>用户行为宽表，数据量过大。数据倾斜的相关优化手段。（hadoop、hive、spark）</p>\n<p>哪两张表和哪两张表发生数据倾斜：</p>\n<p>11.11 数据量大 按照地区统计销售额</p>\n<p>订单表（10万* 50倍 * 1k &#x3D;500万 <em>1k&#x3D;5g ） 和 订单详情（50万 50倍 *<br>1k&#x3D;2500万</em>1k&#x3D;25g） 用户、商品 、地区（县）</p>\n<p>数据倾斜时，执行多久 2-5小时</p>\n<p>采取办法：解决数据倾斜 将key打散 自定义分区</p>\n<p>采用解决数据倾斜办法：执行40分钟搞定</p>\n<h2 id=\"4-14-哪张表数据量最大，是多少\"><a href=\"#4-14-哪张表数据量最大，是多少\" class=\"headerlink\" title=\"4.14 哪张表数据量最大，是多少\"></a>4.14 哪张表数据量最大，是多少</h2><p>用户行为数据：100g(1亿条)&#x2F;5 &#x3D; 2千万 * 2-3倍<br>动作、曝光、页面、故障、启动</p>\n<p>业务数据：10万人下单，详情（50-100万条） -》加购-》下单-》支付-》物流</p>\n<h2 id=\"4-15-用什么工具做权限管理\"><a href=\"#4-15-用什么工具做权限管理\" class=\"headerlink\" title=\"4.15 用什么工具做权限管理\"></a>4.15 用什么工具做权限管理</h2><p>Ranger或Sentry<br>（用户认证kerberos（张三、李四、王五）&#x3D;&gt;表级别权限（张三、李四）、字段级别权限（李四））</p>\n<h2 id=\"4-16-数仓当中数据多久删除一次\"><a href=\"#4-16-数仓当中数据多久删除一次\" class=\"headerlink\" title=\"4.16 数仓当中数据多久删除一次\"></a>4.16 数仓当中数据多久删除一次</h2><p>1）部分公司永久不删</p>\n<p>2）有一年、两年”删除”一次的，这里面说的删除是，先将超时数据压缩下载到单独安装的磁盘上。然后删除集群上数据。<br>很少有公司不备份数据，直接删除的。</p>\n<h1 id=\"第5章-生产经验–测试上线相关\"><a href=\"#第5章-生产经验–测试上线相关\" class=\"headerlink\" title=\"第5章 生产经验–测试上线相关\"></a>第5章 生产经验–测试上线相关</h1><h2 id=\"5-1-测试相关\"><a href=\"#5-1-测试相关\" class=\"headerlink\" title=\"5.1 测试相关\"></a>5.1 测试相关</h2><h3 id=\"5-1-1-公司有多少台测试服务器？\"><a href=\"#5-1-1-公司有多少台测试服务器？\" class=\"headerlink\" title=\"5.1.1 公司有多少台测试服务器？\"></a>5.1.1 公司有多少台测试服务器？</h3><p>测试服务器一般三台</p>\n<h3 id=\"5-1-2-测试环境什么样？\"><a href=\"#5-1-2-测试环境什么样？\" class=\"headerlink\" title=\"5.1.2 测试环境什么样？\"></a>5.1.2 测试环境什么样？</h3><p>有钱的公司和生产环境电脑配置一样。</p>\n<p>一般公司测试环境的配置是生产的一半。</p>\n<h3 id=\"5-1-3-测试数据哪来的？\"><a href=\"#5-1-3-测试数据哪来的？\" class=\"headerlink\" title=\"5.1.3 测试数据哪来的？\"></a>5.1.3 测试数据哪来的？</h3><p>一部分自己写Java程序自己造（更灵活），一部分从生产环境上取一部分（更真实）。</p>\n<h3 id=\"5-1-4-如何保证写的sql正确性（重点）\"><a href=\"#5-1-4-如何保证写的sql正确性（重点）\" class=\"headerlink\" title=\"5.1.4 如何保证写的sql正确性（重点）\"></a>5.1.4 如何保证写的sql正确性（重点）</h3><p>先在mysql的业务库里面把结果计算出来；在给你在ads层计算的结果进行比较；</p>\n<p>需要造一些特定的测试数据，测试。</p>\n<p>从生产环境抓取一部分数据，数据有多少你是知道的，运算完毕应该符合你的预期。</p>\n<p>离线数据和实时数据分析的结果比较。（日活1万 实时10100），倾向取离线。</p>\n<h3 id=\"5-1-5-测试之后如何上线？\"><a href=\"#5-1-5-测试之后如何上线？\" class=\"headerlink\" title=\"5.1.5 测试之后如何上线？\"></a>5.1.5 测试之后如何上线？</h3><p>大公司：上线的时候，将脚本打包，提交git。先发邮件抄送经理和总监，运维。运维负责上线。</p>\n<p>小公司：跟项目经理说一下，项目经理技术把关，项目经理通过了就可以上线了。风险意识。</p>\n<p>所谓的上线就是编写脚本，并在azkaban中进行作业调度。</p>\n<h2 id=\"5-2-项目实际工作流程\"><a href=\"#5-2-项目实际工作流程\" class=\"headerlink\" title=\"5.2 项目实际工作流程\"></a>5.2 项目实际工作流程</h2><p>以下是<strong>活跃用户</strong>需求的整体开发流程。</p>\n<p>产品经理负责收集需求：需求来源与客户反馈、老板的意见</p>\n<p><strong>第1步：确定指标的业务口径</strong></p>\n<p>由产品经理主导，找到提出该指标的运营负责人沟通。首先要问清楚<strong>指标是怎么定义的</strong>，比如活跃用户是指启动过APP的用户。设备id<br>还是用户id。</p>\n<p>邮件&#x2F;需求文档-》不要口头</p>\n<p><strong>第2步：需求评审</strong></p>\n<p>由产品经理主导设计原型，对于活跃主题，我们最终要展示的是<strong>最近n天的活跃用户数变化趋势</strong><br>，效果如下图所示。此处<strong>大数据开发工程师、后端开发工程师、前端开发工程师一同参与</strong>，一起说明整个功能的价值和详细的操作流程，确保大家理解的一致。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image87.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”1.7236111111111112in”}</p>\n<p><strong>第3步：大数据开发</strong></p>\n<p>大数据开发工程师，通过数据同步的工具如Flume、Sqoop等将数据同步到ODS层，然后就是一层一层的通过SQL计算到DWD、DWS层，最后形成可为应用直接服务的数据填充到ADS层。</p>\n<p><strong>第4步：后端开发</strong></p>\n<p>后端工程师负责，为大数据工程师提供业务数据接口；</p>\n<p>同时还负责读取ADS层分析后，写入MySQL中的数据。</p>\n<p><strong>第5步：前端开发</strong></p>\n<p>前端工程师负责，前端埋点。</p>\n<p>对分析后的结果数据进行可视化展示。</p>\n<p><strong>第6步：联调</strong></p>\n<p>此时大<strong>数据开发工程师、前端开发工程师、后端开发工程师</strong>都要参与进来。此时会要求大数据开发工程师基于历史的数据执行计算任务，大数据开发工程师承担数据准确性的校验。前后端解决用户操作的相关BUG保证不出现低级的问题完成自测。</p>\n<p><strong>第7步：测试</strong></p>\n<p>测试工程师对整个大数据系统进行测试。测试的手段包括，边界值、等价类等。</p>\n<p>提交测试异常的软件有：<strong>禅道、bugzila</strong>（测试人员记录测试问题1.0，输入是什么，结果是什么，跟预期不一样-&gt;需要开发人员解释，是一个bug，下一个版本解决1.1-&gt;测试人员再测试。测试1.1ok-&gt;测试经理关闭bug）</p>\n<p>1周开发写代码 &#x3D;》2周测试时间</p>\n<p><strong>第8步：上线</strong></p>\n<p>运维工程师会配合我们的前后端开发工程师更新最新的版本到服务器。此时产品经理要找到该指标的负责人长期跟进指标的准确性。重要的指标还要每过一个周期内部再次验证，从而保证数据的准确性。</p>\n<h2 id=\"5-3-项目中实现一个需求大概多长时间\"><a href=\"#5-3-项目中实现一个需求大概多长时间\" class=\"headerlink\" title=\"5.3 项目中实现一个需求大概多长时间\"></a>5.3 项目中实现一个需求大概多长时间</h2><p>刚入职第一个需求大概需要7天左右。</p>\n<p>对业务熟悉后，平均一天一个需求。</p>\n<p>影响时间的因素：测试服务器购买获取环境准备、对业务熟悉、开会讨论需求、表的权限申请、测试等。新员工培训（公司规章制度、代码规范）</p>\n<h2 id=\"5-4-项目在3年内迭代次数，每一个项目具体是如何迭代的。公司版本迭代多久一次，迭代到哪个版本\"><a href=\"#5-4-项目在3年内迭代次数，每一个项目具体是如何迭代的。公司版本迭代多久一次，迭代到哪个版本\" class=\"headerlink\" title=\"5.4 项目在3年内迭代次数，每一个项目具体是如何迭代的。公司版本迭代多久一次，迭代到哪个版本\"></a>5.4 项目在3年内迭代次数，每一个项目具体是如何迭代的。公司版本迭代多久一次，迭代到哪个版本</h2><p>瀑布式开发、敏捷开发</p>\n<p>差不多一个月会迭代一次。每月都有节日（元旦、春节、情人节、3.8妇女节、端午节、618、国庆、中秋、1111&#x2F;6.1&#x2F;5.1、生日、周末）新产品、新区域</p>\n<p>就产品或我们提出优化需求，然后评估时间。每周我们都会开会做下周计划和本周总结。（日报、周报、月报、季度报、年报）需求1周的时间，周三一定完成。周四周五（帮同事写代码、自己学习工作额外的技术）</p>\n<p>5.1.2</p>\n<p>5是大版本号：必须是重大升级</p>\n<p>1：一般是核心模块变动</p>\n<p>2：一般版本变化</p>\n<h2 id=\"5-5-项目开发中每天做什么事\"><a href=\"#5-5-项目开发中每天做什么事\" class=\"headerlink\" title=\"5.5 项目开发中每天做什么事\"></a>5.5 项目开发中每天做什么事</h2><p>1）新需求（活动、优化、新产品、新市场）。 60%</p>\n<p>2）故障分析：数仓的任何步骤出现问题，需要查看问题，比如日活，月活下降或快速上升等。20%</p>\n<p>3）新技术的预言（比如湖仓一体 数据湖 doris 实时数据质量监控）10%</p>\n<p>4）其临时任务 10%</p>\n<p>5）晨会-》10做操-》讨论中午吃什么-》12点出去吃1点-》睡到2点-》3点茶歇水果-》晚上吃啥-》吃加班餐-》开会-》晚上6点吃饭-》7点开始干活-10点-》11点</p>\n<h2 id=\"5-6-实时项目数据计算\"><a href=\"#5-6-实时项目数据计算\" class=\"headerlink\" title=\"5.6 实时项目数据计算\"></a>5.6 实时项目数据计算</h2><h3 id=\"5-6-1-跑实时任务，怎么分配内存和CPU资源\"><a href=\"#5-6-1-跑实时任务，怎么分配内存和CPU资源\" class=\"headerlink\" title=\"5.6.1 跑实时任务，怎么分配内存和CPU资源\"></a>5.6.1 跑实时任务，怎么分配内存和CPU资源</h3><p>128m数据对应1g内存</p>\n<p>1个Kafka分区对应1个CPU</p>\n<h3 id=\"5-6-2-跑实时任务，每天数据量多少？\"><a href=\"#5-6-2-跑实时任务，每天数据量多少？\" class=\"headerlink\" title=\"5.6.2 跑实时任务，每天数据量多少？\"></a>5.6.2 跑实时任务，每天数据量多少？</h3><p>用户行为：实时任务用到了用户行为多少张表（20g） 100g&#x2F;5张表</p>\n<p>业务数据：实时任务用到了业务数据多少张表（34m） 1g&#x2F;30张表</p>\n<p>活动、风控、销售、流量</p>\n<h1 id=\"第6章-生产经验—技术\"><a href=\"#第6章-生产经验—技术\" class=\"headerlink\" title=\"第6章 生产经验—技术\"></a>第6章 生产经验—技术</h1><h2 id=\"6-1-可视化报表工具\"><a href=\"#6-1-可视化报表工具\" class=\"headerlink\" title=\"6.1 可视化报表工具\"></a>6.1 可视化报表工具</h2><p>Echarts（百度开源）、Kibana（开源）、Tableau（功能强大的收费软件）、Superset（功能一般免费）、QuickBI（阿里云收费的离线）、DataV（阿里云收费的实时）suga（百度，收费）</p>\n<h2 id=\"6-2-集群监控工具\"><a href=\"#6-2-集群监控工具\" class=\"headerlink\" title=\"6.2 集群监控工具\"></a>6.2 集群监控工具</h2><p>Zabbix+ Grafana Prometheus&amp;Grafana监控 睿象云</p>\n<h2 id=\"6-3-项目中遇到的问题怎么解决的（重点-）\"><a href=\"#6-3-项目中遇到的问题怎么解决的（重点-）\" class=\"headerlink\" title=\"6.3 项目中遇到的问题怎么解决的（重点*****）\"></a>6.3 项目中遇到的问题怎么解决的（重点*****）</h2><p>Shell 中Flume停止脚本</p>\n<p>Hadoop宕机</p>\n<p>Hadoop解决数据倾斜方法</p>\n<p>集群资源分配参数（项目中遇到的问题）</p>\n<p>HDFS小文件处理</p>\n<p>Hadoop优化</p>\n<p>Flume挂掉</p>\n<p>Flume优化</p>\n<p>Kafka挂掉</p>\n<p>Kafka丢失</p>\n<p>Kafka数据重复</p>\n<p>Kafka消息数据积压</p>\n<p>Kafka优化</p>\n<p>Kafka单条日志传输大小</p>\n<p>自定义UDF、UDTF函数</p>\n<p>Hive优化</p>\n<p>Hive解决数据倾斜方法</p>\n<p>7天内连续3次活跃</p>\n<p>1 7 30指标</p>\n<p>分摊</p>\n<p>备注</p>\n<p>Sqoop空值、一致性、数据倾斜</p>\n<p>Azkaban任务挂了怎么办？</p>\n<p>Azkaban故障报警</p>\n<p>Spark数据倾斜</p>\n<p>Spark优化</p>\n<p>SparkStreaming精确一次性消费</p>\n<p>Flink 数据倾斜</p>\n<p>Flink水位线</p>\n<p>Flink反压</p>\n<p>Flink处理函数</p>\n<p>Flink SQL</p>\n<p>Flink多流join</p>\n<h2 id=\"6-4-Linux-Shell-Hadoop-ZK-Flume-kafka-Hive-Sqoop-Azkaban那些事\"><a href=\"#6-4-Linux-Shell-Hadoop-ZK-Flume-kafka-Hive-Sqoop-Azkaban那些事\" class=\"headerlink\" title=\"6.4 Linux+Shell+Hadoop+ZK+Flume+kafka+Hive+Sqoop+Azkaban那些事\"></a>6.4 Linux+Shell+Hadoop+ZK+Flume+kafka+Hive+Sqoop+Azkaban那些事</h2><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image88.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.21875in”}</p>\n<h1 id=\"第7章-生产经验—热点问题\"><a href=\"#第7章-生产经验—热点问题\" class=\"headerlink\" title=\"第7章 生产经验—热点问题\"></a>第7章 生产经验—热点问题</h1><h2 id=\"7-1-元数据管理（Atlas血缘系统）\"><a href=\"#7-1-元数据管理（Atlas血缘系统）\" class=\"headerlink\" title=\"7.1 元数据管理（Atlas血缘系统）\"></a>7.1 元数据管理（Atlas血缘系统）</h2><p>insert into table ads_user</p>\n<p>select id, name from dwt_user</p>\n<p>依赖关系能够做到：表级别和字段级别</p>\n<p>用处：作业执行失败，评估他的影响范围。 主要用于表比较多的公司。</p>\n<p>版本问题：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>0.84版本：2019-06-21</p>\n<p>2.0版本：2019-05-13</p></blockquote>\n<p>框架版本：</p>\n<p>Apache 0.84 2.0 2.1</p>\n<p>CDH 2.0</p>\n<h2 id=\"7-2-数据质量监控（Griffin）\"><a href=\"#7-2-数据质量监控（Griffin）\" class=\"headerlink\" title=\"7.2 数据质量监控（Griffin）\"></a>7.2 数据质量监控（Griffin）</h2><h3 id=\"7-2-1-监控原则\"><a href=\"#7-2-1-监控原则\" class=\"headerlink\" title=\"7.2.1 监控原则\"></a>7.2.1 监控原则</h3><p><strong>1）单表数据量监控</strong></p>\n<p>一张表的记录数在一个已知的范围内，或者上下浮动不会超过某个阈值</p>\n<ul>\n<li><p>SQL结果：var 数据量 &#x3D; select count（*）from 表 where 时间等过滤条件</p>\n</li>\n<li><p>报警触发条件设置：如果数据量不在[数值下限, 数值上限]， 则触发报警</p>\n</li>\n<li><p>同比增加：如果((本周的数据量 -<br>上周的数据量)&#x2F;上周的数据量*100)不在 [比例下线，比例上限]，则触发报警</p>\n</li>\n<li><p>环比增加：如果((今天的数据量 -<br>昨天的数据量)&#x2F;昨天的数据量*100)不在 [比例下线，比例上限]，则触发报警</p>\n</li>\n<li><p>报警触发条件设置一定要有。如果没有配置的阈值，不能做监控</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>日活、周活、月活、留存（日周月）、转化率（日、周、月）GMV（日、周、月）</p>\n<p>复购率（日周月） 30%</p></blockquote>\n<p><strong>2）单表空值检测</strong></p>\n<p>某个字段为空的记录数在一个范围内，或者占总量的百分比在某个阈值范围内</p>\n<ul>\n<li><p>目标字段：选择要监控的字段，不能选”无”</p>\n</li>\n<li><p>SQL结果：var 异常数据量 &#x3D; select count(*) from 表 where 目标字段 is<br>null</p>\n</li>\n<li><p>单次检测：如果（异常数据量）不在[数值下限, 数值上限]，则触发报警</p>\n</li>\n</ul>\n<p><strong>3）单表重复值检测</strong></p>\n<p>一个或多个字段是否满足某些规则</p>\n<ul>\n<li><p>目标字段：第一步先正常统计条数；select count(*) form 表；</p>\n</li>\n<li><p>第二步，去重统计；select count(*) from 表 group by 某个字段</p>\n</li>\n<li><p>第一步的值和第二步不的值做减法，看是否在上下线阀值之内</p>\n</li>\n<li><p>单次检测：如果（异常数据量）不在[数值下限, 数值上限]， 则触发报警</p>\n</li>\n</ul>\n<p><strong>4）单表值域检测</strong></p>\n<p>一个或多个字段没有重复记录</p>\n<ul>\n<li><p>目标字段：选择要监控的字段，支持多选</p>\n</li>\n<li><p>检测规则：填写”目标字段”要满足的条件。其中$1表示第一个目标字段，$2表示第二个目标字段，以此类推。上图中的”检测规则”经过渲染后变为”delivery_fee<br>&#x3D; delivery_fee_base+delivery_fee_extra”</p>\n</li>\n<li><p>阈值配置与”空值检测”相同</p>\n</li>\n</ul>\n<p><strong>5）跨表数据量对比</strong></p>\n<p>主要针对同步流程，监控两张表的数据量是否一致</p>\n<ul>\n<li><p>SQL结果：count（本表） - count（关联表）</p>\n</li>\n<li><p>阈值配置与”空值检测”相同</p>\n</li>\n</ul>\n<h3 id=\"7-2-2-数据质量实现\"><a href=\"#7-2-2-数据质量实现\" class=\"headerlink\" title=\"7.2.2 数据质量实现\"></a>7.2.2 数据质量实现</h3><h2 id=\"7-3-权限管理（Ranger）\"><a href=\"#7-3-权限管理（Ranger）\" class=\"headerlink\" title=\"7.3 权限管理（Ranger）\"></a>7.3 权限管理（Ranger）</h2><h2 id=\"7-4-数据治理\"><a href=\"#7-4-数据治理\" class=\"headerlink\" title=\"7.4 数据治理\"></a>7.4 数据治理</h2><p>包括：数据质量管理、元数据管理、权限管理（ranger sentry）、数仓</p>\n<p>CDH cloudmanager-》sentry； HDP ambari&#x3D;&gt;ranger</p>\n<p>2019年下半年<br>国家出了一本白皮书，要求给政府做的数仓项目，要具备如下功能：</p>\n<p>数据治理是一个复杂的系统工程，涉及到企业和单位多个领域，既要做好顶层设计，又要解决好统一标准、统一流程、统一管理体系等问题，同时也要解决好数据采集、数据清洗、数据对接和应用集成等相关问题。</p>\n<p>数据治理实施要点主要包含<strong>数据规划、制定数据标准、整理数据、搭建数据管理工具、构建运维体系及推广贯标</strong>六大部分，其中数据规划是纲领、制定数据标准是基础、整理数据是过程、搭建数据管理工具是技术手段、构建运维体系是前提，推广贯标是持续保障。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image91.jpeg\">{width&#x3D;”3.09375in”<br>height&#x3D;”2.1902777777777778in”}</p>\n<h2 id=\"7-5-数据中台\"><a href=\"#7-5-数据中台\" class=\"headerlink\" title=\"7.5 数据中台\"></a>7.5 数据中台</h2><p><a href=\"https://mp.weixin.qq.com/s/nXI0nSSOneteIClA7dming\">[https://mp.weixin.qq.com/s/nXI0nSSOneteIClA7dming]{.underline}</a></p>\n<h3 id=\"7-5-1-什么是中台？\"><a href=\"#7-5-1-什么是中台？\" class=\"headerlink\" title=\"7.5.1 什么是中台？\"></a>7.5.1 什么是中台？</h3><p>在传统IT企业，项目的物理结构是什么样的呢？无论项目内部的如何复杂，都可分为”前台”和”后台”这两部分。</p>\n<p><strong>什么是前台？</strong></p>\n<p>首先，这里所说的”前台”和”前端”并不是一回事。所谓前台即包括各种和用户直接交互的界面，比如web页面，手机app；也包括服务端各种实时响应用户请求的业务逻辑，比如商品查询、订单系统等等。</p>\n<p><strong>什么是后台？</strong></p>\n<p>后台并不直接面向用户，而是面向运营人员的配置管理系统，比如商品管理、物流管理、结算管理。后台为前台提供了一些简单的配置。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image92.png\">{width&#x3D;”2.441666666666667in”<br>height&#x3D;”2.5625in”}</p>\n<h3 id=\"7-5-2-传统项目痛点\"><a href=\"#7-5-2-传统项目痛点\" class=\"headerlink\" title=\"7.5.2 传统项目痛点\"></a>7.5.2 传统项目痛点</h3><p>痛点：重复造轮子。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image93.png\">{width&#x3D;”3.013888888888889in”<br>height&#x3D;”2.9479166666666665in”}</p>\n<h3 id=\"7-5-3-各家中台\"><a href=\"#7-5-3-各家中台\" class=\"headerlink\" title=\"7.5.3 各家中台\"></a>7.5.3 各家中台</h3><p>1）SuperCell公司</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image94.png\">{width&#x3D;”3.441666666666667in”<br>height&#x3D;”1.6576388888888889in”}</p>\n<p>2）阿里巴巴提出了”大中台，小前台”的战略</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image95.png\">{width&#x3D;”3.782638888888889in”<br>height&#x3D;”2.422222222222222in”}</p>\n<p>3）华为提出了”平台炮火支撑精兵作战”的战略</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image96.png\">{width&#x3D;”3.7680555555555557in”<br>height&#x3D;”2.442361111111111in”}</p>\n<h3 id=\"7-5-4-中台具体划分\"><a href=\"#7-5-4-中台具体划分\" class=\"headerlink\" title=\"7.5.4 中台具体划分\"></a>7.5.4 中台具体划分</h3><p>1）业务中台</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image97.png\">{width&#x3D;”2.8125in”<br>height&#x3D;”1.6979166666666667in”}</p>\n<p>2）技术中台</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image98.png\">{width&#x3D;”2.8541666666666665in”<br>height&#x3D;”1.7430555555555556in”}</p>\n<p>3）数据中台</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image99.png\">{width&#x3D;”2.7395833333333335in”<br>height&#x3D;”1.5465277777777777in”}</p>\n<p>4）算法中台</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image100.png\">{width&#x3D;”2.69375in”<br>height&#x3D;”1.6736111111111112in”}</p>\n<h3 id=\"7-5-5-中台使用场景\"><a href=\"#7-5-5-中台使用场景\" class=\"headerlink\" title=\"7.5.5 中台使用场景\"></a>7.5.5 中台使用场景</h3><p><strong>1）从0到1的阶段，没有必要搭建中台。</strong></p>\n<p>从0到1的创业型公司，首要目的是生存下去，以最快的速度打造出产品，证明自身的市场价值。</p>\n<p>这个时候，让项目野蛮生长才是最好的选择。如果不慌不忙地先去搭建中台，恐怕中台还没搭建好，公司早就饿死了。</p>\n<p><strong>2）从1到N的阶段，适合搭建中台。</strong></p>\n<p>当企业有了一定规模，产品得到了市场的认可，这时候公司的首要目的不再是活下去，而是活的更好。</p>\n<p>这个时候，趁着项目复杂度还不是特别高，可以考虑把各项目的通用部分下沉，组建中台，以方便后续新项目的尝试和旧项目的迭代。</p>\n<p><strong>3）从N到N+1的阶段，搭建中台势在必行。</strong></p>\n<p>当企业已经有了很大的规模，各种产品、服务、部门错综复杂，这时候做架构调整会比较痛苦。</p>\n<p>但是长痛不如短痛，为了项目的长期发展，还是需要尽早调整架构，实现平台化，以免日后越来越难以维护。</p>\n<h2 id=\"7-6-数据湖\"><a href=\"#7-6-数据湖\" class=\"headerlink\" title=\"7.6 数据湖\"></a>7.6 数据湖</h2><p><strong>数据湖（</strong>Data<br>Lake）**是一个存储企业的各种各样原始数据的大型仓库，其中的数据可供存取、处理、分析及传输。<br>**</p>\n<p><strong>hudi、iceberg、Data Lake</strong></p>\n<p>目前，Hadoop是最常用的部署数据湖的技术，所以很多人会觉得数据湖就是Hadoop集群。数据湖是一个概念，而Hadoop是用于实现这个概念的技术。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image101.jpeg\">{width&#x3D;”4.124305555555556in”<br>height&#x3D;”1.6222222222222222in”}</p>\n<p>+———————————–+———————————–+<br>| <strong>数据仓库</strong>                      | <strong>数据湖</strong>                        |<br>+———————————–+———————————–+<br>| 主要<strong>处理历史的、结构化的数据</strong>，而且这些数据必须与数据仓库事 | 能处理所有类型的数据，如结构化数据，非结构化数据，半结构化数据等， |<br>| 先定义的模型吻合。                | 数据的类型依赖于数据源系统的原始数据格式。非结构化数据（语音、图片 |<br>|                                   | 、视频等）                        |<br>+———————————–+———————————–+<br>| 数据仓库分析的指标都是产品经理提前规定好的。按需分析数据。（日活、 | 根据海量的数据，挖掘出规律，反应给运营部门。 |<br>| 新增、留存、转化率）              |                                   |<br>|                                   |                                   |<br>|                                   | 从海量的数据中找寻规律。拥有<strong>非常强的计算能力</strong>用于处理数据。 |<br>|                                   |                                   |<br>|                                   |                                   |<br>|                                   | 数据挖掘                          |<br>+———————————–+———————————–+</p>\n<h2 id=\"7-7-埋点\"><a href=\"#7-7-埋点\" class=\"headerlink\" title=\"7.7 埋点\"></a>7.7 埋点</h2><p>免费的埋点：上课演示。</p>\n<p>收费的埋点：神策<br><a href=\"https://mp.weixin.qq.com/s/Xp3-alWF4XHvKDP9rNWCoQ\">[https://mp.weixin.qq.com/s/Xp3-alWF4XHvKDP9rNWCoQ]{.underline}</a></p>\n<p>百度统计、友盟统计</p>\n<p>目前主流的埋点方式，有代码埋点（前端&#x2F;后端）、可视化埋点、全埋点三种。</p>\n<p><strong>代码埋点</strong>是通过调用埋点SDK函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据。例如，我们对页面中的某个按钮埋点后，当这个按钮被点击时，可以在这个按钮对应的<br>OnClick 函数里面调用SDK提供的数据发送接口，来发送数据。</p>\n<p><strong>可视化埋点</strong>只需要研发人员集成采集<br>SDK，不需要写埋点代码，业务人员就可以通过访问分析平台的”圈选”功能，来”圈”出需要对用户行为进行捕捉的控件，并对该事件进行命名。圈选完毕后，这些配置会同步到各个用户的终端上，由采集<br>SDK 按照圈选的配置自动进行用户行为数据的采集和发送。</p>\n<p><strong>全埋点</strong>是通过在产品中嵌入SDK，前端自动采集页面上的全部用户行为事件，上报埋点数据，相当于做了一个统一的埋点。然后再通过界面配置哪些数据需要在系统里面进行分析。</p>\n<h2 id=\"7-8-电商运营经验\"><a href=\"#7-8-电商运营经验\" class=\"headerlink\" title=\"7.8 电商运营经验\"></a>7.8 电商运营经验</h2><h3 id=\"7-8-1-电商8类基本指标\"><a href=\"#7-8-1-电商8类基本指标\" class=\"headerlink\" title=\"7.8.1 电商8类基本指标\"></a>7.8.1 电商8类基本指标</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image102.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.7493055555555554in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image103.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.4069444444444446in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image104.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”6.302083333333333in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image105.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.482638888888889in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image106.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.6534722222222222in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image107.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.022222222222222in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image108.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”2.638888888888889in”}</p>\n<p>8）市场竞争指标：主要分析市场份额以及网站排名，进一步进行调整</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image109.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”1.6423611111111112in”}</p>\n<h3 id=\"7-8-2-直播指标\"><a href=\"#7-8-2-直播指标\" class=\"headerlink\" title=\"7.8.2 直播指标\"></a>7.8.2 直播指标</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image110.png\">{width&#x3D;”3.7729166666666667in”<br>height&#x3D;”3.561111111111111in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image111.png\">{width&#x3D;”3.7395833333333335in”<br>height&#x3D;”6.854166666666667in”}<img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image112.png\">{width&#x3D;”5.768055555555556in”<br>height&#x3D;”3.626388888888889in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image113.png\">{width&#x3D;”4.377083333333333in”<br>height&#x3D;”6.40625in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image114.png\">{width&#x3D;”2.4923611111111112in”<br>height&#x3D;”3.1527777777777777in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image115.png\">{width&#x3D;”3.31875in”<br>height&#x3D;”3.4770833333333333in”}</p>\n<h1 id=\"第8章-实时数仓项目\"><a href=\"#第8章-实时数仓项目\" class=\"headerlink\" title=\"第8章 实时数仓项目\"></a>第8章 实时数仓项目</h1><h2 id=\"8-1-数据采集到ods层做了哪些事\"><a href=\"#8-1-数据采集到ods层做了哪些事\" class=\"headerlink\" title=\"8.1 数据采集到ods层做了哪些事\"></a>8.1 数据采集到ods层做了哪些事</h2><h3 id=\"8-1-1-前端埋点的行为数据为什么又采集一份？\"><a href=\"#8-1-1-前端埋点的行为数据为什么又采集一份？\" class=\"headerlink\" title=\"8.1.1 前端埋点的行为数据为什么又采集一份？\"></a>8.1.1 前端埋点的行为数据为什么又采集一份？</h3><p>时效性</p>\n<p>kafka保存3天，磁盘够：原来1T，现在2T，没压力</p>\n<h3 id=\"8-1-2为什么选择kafka？\"><a href=\"#8-1-2为什么选择kafka？\" class=\"headerlink\" title=\"8.1.2为什么选择kafka？\"></a>8.1.2为什么选择kafka？</h3><p>实时写、实时读</p>\n<p>&#x3D;》 消息队列适合，其他数据库受不了</p>\n<h3 id=\"8-1-3为什么用maxwell？历史数据同步怎么保证一致性？\"><a href=\"#8-1-3为什么用maxwell？历史数据同步怎么保证一致性？\" class=\"headerlink\" title=\"8.1.3为什么用maxwell？历史数据同步怎么保证一致性？\"></a>8.1.3为什么用maxwell？历史数据同步怎么保证一致性？</h3><p>flinkcdc在20年7月才发布</p>\n<p>canal与maxwell区别：</p>\n<p>maxwell支持同步历史数据</p>\n<p>maxwell支持断点还原（存在元数据库）</p>\n<p>数据格式更轻量</p>\n<p>保证至少一次，不丢</p>\n<h3 id=\"8-1-4-kafka保存多久？如果需要以前的数据怎么办？\"><a href=\"#8-1-4-kafka保存多久？如果需要以前的数据怎么办？\" class=\"headerlink\" title=\"8.1.4 kafka保存多久？如果需要以前的数据怎么办？\"></a>8.1.4 kafka保存多久？如果需要以前的数据怎么办？</h3><p>跟离线项目保持一致：3天</p>\n<p>我们的项目不需要，如果需要的话可以去数据库或Hive现查，ClickHouse也有历史的宽表数据</p>\n<h2 id=\"8-2-ods层\"><a href=\"#8-2-ods层\" class=\"headerlink\" title=\"8.2 ods层\"></a>8.2 ods层</h2><p>1）存储原始数据</p>\n<p>2个topic ：</p>\n<p>埋点的行为数据 ods_base_log</p>\n<p>业务数据 ods_base_db</p>\n<p>2）业务数据的有序性： maxwell配置，指定生产者分区的key为 table</p>\n<h2 id=\"8-3-dwd-dim层\"><a href=\"#8-3-dwd-dim层\" class=\"headerlink\" title=\"8.3 dwd+dim层\"></a>8.3 dwd+dim层</h2><h3 id=\"8-3-1-存储位置，为什么维度表存Hbase？\"><a href=\"#8-3-1-存储位置，为什么维度表存Hbase？\" class=\"headerlink\" title=\"8.3.1 存储位置，为什么维度表存Hbase？\"></a>8.3.1 存储位置，为什么维度表存Hbase？</h3><p>事实表存Kafka、维度表存Hbase</p>\n<p>基于热存储加载维表的join方案：</p>\n<p>随机查</p>\n<p>长远考虑</p>\n<p>适合实时读写</p>\n<h3 id=\"8-3-2-埋点行为数据分流\"><a href=\"#8-3-2-埋点行为数据分流\" class=\"headerlink\" title=\"8.3.2 埋点行为数据分流\"></a>8.3.2 埋点行为数据分流</h3><p>1）修复新老访客（选择性）：以前是前端试别新老访客，不够准确</p>\n<p>2）分流：侧输出流</p>\n<p>分了3个topic： 启动、页面、曝光</p>\n<h3 id=\"8-3-3-业务数据动态分流\"><a href=\"#8-3-3-业务数据动态分流\" class=\"headerlink\" title=\"8.3.3 业务数据动态分流\"></a>8.3.3 业务数据动态分流</h3><p>1）动态分流：<br>将事实表写入kafka的dwd层，将维度表写入hbase。为了避免因表的变化而重启Flink任务，在mysql存一张表来动态配置。</p>\n<p>动态实现：使用广播状态</p>\n<p>&#x3D;》 读取一张配置表 &#x3D;&#x3D;&#x3D;》 维护这张配置表</p>\n<p>source来源 sink写到哪 操作类型 字段 主键 扩展</p>\n<p>&#x3D;》实时获取配置表的变化 &#x3D;&#x3D;》CDC工具</p>\n<p>&#x3D;》 FlinkCDC</p>\n<p>&#x3D;》 使用了sql的方式，去同步这张配置表</p>\n<p>&#x3D;》sql的数据格式比较方便</p>\n<p>2）怎么写HBase：借助phoenix</p>\n<p>没有做维度退化</p>\n<p>维表数据量小、变化频率慢</p>\n<p>3）Hbase的rowkey怎么设计的？有没有数据热点问题？</p>\n<p>最大的维表：用户维表</p>\n<p>&#x3D;》百万日活，2000万注册用户为例，1条平均1k：2000万*1k&#x3D;约20G</p>\n<p>使用Phoenix创建的盐表，避免数据热点问题</p>\n<p><a href=\"https://developer.aliyun.com/article/532313\">[https://developer.aliyun.com/article/532313]{.underline}</a></p>\n<h2 id=\"8-4-dwm层\"><a href=\"#8-4-dwm层\" class=\"headerlink\" title=\"8.4 dwm层\"></a>8.4 dwm层</h2><h3 id=\"8-4-1-为什么要加一个dwm层？\"><a href=\"#8-4-1-为什么要加一个dwm层？\" class=\"headerlink\" title=\"8.4.1 为什么要加一个dwm层？\"></a>8.4.1 为什么要加一个dwm层？</h3><p>DWM层主要服务DWS，因为部分需求直接从DWD层到DWS层中间会有一定的计算量，而且这部分计算的结果很有可能被多个DWS层主题复用，所以部分DWD层会形成一层DWM，我们这里主要涉及业务</p>\n<ul>\n<li><p>访问UV计算</p>\n</li>\n<li><p>跳出明细计算</p>\n</li>\n<li><p>订单宽表</p>\n</li>\n<li><p>支付宽表</p>\n</li>\n</ul>\n<h3 id=\"8-4-2-事实表与事实表join\"><a href=\"#8-4-2-事实表与事实表join\" class=\"headerlink\" title=\"8.4.2 事实表与事实表join\"></a>8.4.2 事实表与事实表join</h3><p>1）事实表与事实表的双流join,使用了interval join</p>\n<p>2）Join不上的数据怎么办？</p>\n<p>在flink中的流join大体分为两种，一种是基于时间窗口的join（Time Windowed<br>Join），比如join、coGroup等。另一种是基于状态缓存的join（Temporal Table<br>Join），比如intervalJoin。</p>\n<p>这里选用intervalJoin，因为相比较窗口join，intervalJoin使用更简单，而且避免了应匹配的数据处于不同窗口的问题。intervalJoin目前只有一个问题，就是还不支持left<br>join。</p>\n<p>但是我们这里是订单主表与订单从表之间的关联不需要left<br>join，所以intervalJoin是较好的选择。</p>\n<h3 id=\"8-4-3-事实表与维度表join\"><a href=\"#8-4-3-事实表与维度表join\" class=\"headerlink\" title=\"8.4.3 事实表与维度表join\"></a>8.4.3 事实表与维度表join</h3><p>维度关联采用了热存储加载的join方案，实际上就是在流中查询存储在hbase中的数据表。但是即使通过主键的方式查询，hbase速度的查询也是不及流之间的join。外部数据源的查询常常是流式计算的性能瓶颈，所以在这个基础上还有进行一定的优化。</p>\n<p>1）使用了旁路缓存</p>\n<p>旁路缓存模式是一种非常常见的按需分配缓存的模式。如图，任何请求优先访问缓存，缓存命中，直接获得数据返回请求。如果未命中则，查询数据库，同时把结果写入缓存以备后续请求使用。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image116.png\">{width&#x3D;”1.8972222222222221in”<br>height&#x3D;”1.9104166666666667in”}</p>\n<p>2）异步IO</p>\n<p>Flink 在1.2中引入了Async<br>I&#x2F;O，在异步模式下，将IO操作异步化，单个并行可以连续发送多个请求，哪个请求先返回就先处理，从而在连续的请求间不需要阻塞式等待，大大提高了流处理效率。</p>\n<p>Async I&#x2F;O<br>是阿里巴巴贡献给社区的一个呼声非常高的特性，解决与外部系统交互时网络延迟成为了系统瓶颈的问题。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image117.png\">{width&#x3D;”4.8625in”<br>height&#x3D;”2.5854166666666667in”}</p>\n<p>异步查询实际上是把维表的查询操作托管给单独的线程池完成，这样不会因为某一个查询造成阻塞，单个并行可以连续发送多个请求，提高并发效率。</p>\n<p>这种方式特别针对涉及网络IO的操作，减少因为请求等待带来的消耗。</p>\n<h3 id=\"8-4-4怎么保证缓存一致性\"><a href=\"#8-4-4怎么保证缓存一致性\" class=\"headerlink\" title=\"8.4.4怎么保证缓存一致性\"></a>8.4.4怎么保证缓存一致性</h3><p>当我们获取到维表更新的数据，也就是拿到维度表操作类型为update时：</p>\n<p>1）更新Hbase的同时，删除redis里对应的之前缓存的数据</p>\n<p>2）redis设置了过期时间：24小时</p>\n<h2 id=\"8-5-dws层\"><a href=\"#8-5-dws层\" class=\"headerlink\" title=\"8.5 dws层\"></a>8.5 dws层</h2><h3 id=\"8-5-1-为什么选择ClickHouse\"><a href=\"#8-5-1-为什么选择ClickHouse\" class=\"headerlink\" title=\"8.5.1 为什么选择ClickHouse\"></a>8.5.1 为什么选择ClickHouse</h3><p>1）适合大宽表、数据量多、聚合统计分析 &#x3D;》 快</p>\n<p>2）宽表已经不再需要join，很合适</p>\n<h3 id=\"8-5-2-轻度聚合\"><a href=\"#8-5-2-轻度聚合\" class=\"headerlink\" title=\"8.5.2 轻度聚合\"></a>8.5.2 轻度聚合</h3><p>1）DWS层要应对很多实时查询，如果是完全的明细那么查询的压力是非常大的。将更多的实时数据以主题的方式组合起来便于管理，同时也能减少维度查询的次数。</p>\n<p>2）开一个小窗口，5s的滚动窗口</p>\n<p>3）同时减轻了写ClickHouse的压力，减少后续聚合的时间</p>\n<p>4）几张表？ 表名、字段</p>\n<p>访客、商品、地区、关键词</p>\n<h2 id=\"8-6-ads层\"><a href=\"#8-6-ads层\" class=\"headerlink\" title=\"8.6 ads层\"></a>8.6 ads层</h2><h3 id=\"8-6-1-实现方案\"><a href=\"#8-6-1-实现方案\" class=\"headerlink\" title=\"8.6.1 实现方案\"></a>8.6.1 实现方案</h3><p>为可视化大屏服务，提供一个数据接口用来查询ClickHouse中的数据。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image118.png\">{width&#x3D;”4.84375in”<br>height&#x3D;”3.0in”}</p>\n<h3 id=\"8-6-2-怎么保证ClickHouse的一致性？\"><a href=\"#8-6-2-怎么保证ClickHouse的一致性？\" class=\"headerlink\" title=\"8.6.2 怎么保证ClickHouse的一致性？\"></a>8.6.2 怎么保证ClickHouse的一致性？</h3><p>ReplacingMergeTree只能保证最终一致性，查询时的sql语法加上去重逻辑</p>\n<h2 id=\"8-7-监控\"><a href=\"#8-7-监控\" class=\"headerlink\" title=\"8.7 监控\"></a>8.7 监控</h2><p>Flink和ClickHouse都使用了Prometheus + Grafana</p>\n<h1 id=\"第9章-手写代码\"><a href=\"#第9章-手写代码\" class=\"headerlink\" title=\"第9章 手写代码\"></a>第9章 手写代码</h1><h2 id=\"9-1-基本算法\"><a href=\"#9-1-基本算法\" class=\"headerlink\" title=\"9.1 基本算法\"></a>9.1 基本算法</h2><h3 id=\"9-1-1-冒泡排序\"><a href=\"#9-1-1-冒泡排序\" class=\"headerlink\" title=\"9.1.1 冒泡排序\"></a>9.1.1 冒泡排序</h3><p>&#x2F;**</p>\n<ul>\n<li>冒泡排序 时间复杂度 O(n^2) 空间复杂度O(1)</li>\n</ul>\n<p>*&#x2F;</p>\n<p>public class BubbleSort {</p>\n<p>public static void bubbleSort(int[] data) {</p>\n<p>System.out.println(“开始排序”);</p>\n<p>int arrayLength &#x3D; data.length;</p>\n<p>for (int i &#x3D; 0; i &lt; arrayLength - 1; i++) {</p>\n<p>boolean flag &#x3D; false;</p>\n<p>for (int j &#x3D; 0; j &lt; arrayLength - 1 - i; j++) {</p>\n<p>if(data[j] &gt; data[j + 1]){</p>\n<p>int temp &#x3D; data[j + 1];</p>\n<p>data[j + 1] &#x3D; data[j];</p>\n<p>data[j] &#x3D; temp;</p>\n<p>flag &#x3D; true;</p>\n<p>}</p>\n<p>}</p>\n<p>System.out.println(java.util.Arrays.toString(data));</p>\n<p>if (!flag)</p>\n<p>break;</p>\n<p>}</p>\n<p>}</p>\n<p>public static void main(String[] args) {</p>\n<p>int[] data &#x3D; { 9, -16, 21, 23, -30, -49, 21, 30, 30 };</p>\n<p>System.out.println(“排序之前：n” + java.util.Arrays.toString(data));</p>\n<p>bubbleSort(data);</p>\n<p>System.out.println(“排序之后：n” + java.util.Arrays.toString(data));</p>\n<p>}</p>\n<p>}</p>\n<h3 id=\"9-1-2-二分查找\"><a href=\"#9-1-2-二分查找\" class=\"headerlink\" title=\"9.1.2 二分查找\"></a>9.1.2 二分查找</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image120.png\"></p>\n<p>图4-二分查找核心思路</p>\n<p>实现代码：</p>\n<p>&#x2F;**</p>\n<p> * 二分查找 时间复杂度O(log2n);空间复杂度O(1)</p>\n<p> *&#x2F;</p>\n<p> </p>\n<p>def binarySearch(arr:Array[Int],left:Int,right:Int,findVal:Int): Int&#x3D;{</p>\n<p>  if(left&gt;right){&#x2F;&#x2F;递归退出条件，找不到，返回-1</p>\n<p>    -1</p>\n<p>  }</p>\n<p>  val midIndex &#x3D; (left+right)&#x2F;2</p>\n<p>  if (findVal &lt; arr(midIndex)){&#x2F;&#x2F;向左递归查找</p>\n<p>    binarySearch(arr,left,midIndex-1,findVal)</p>\n<p>  }else if(findVal &gt; arr(midIndex)){&#x2F;&#x2F;向右递归查找</p>\n<p>    binarySearch(arr,midIndex+1,right,findVal)</p>\n<p>  }else{&#x2F;&#x2F;查找到，返回下标</p>\n<p>    midIndex</p>\n<p>  }</p>\n<p>}</p>\n<p>拓展需求：当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到。</p>\n<p>代码实现如下：</p>\n<p>&#x2F;*</p>\n<p>{1,8, 10, 89, 1000, 1000，1234}<br>当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的<br>1000.</p>\n<p>&#x2F;&#x2F;分析</p>\n<ol>\n<li><p>返回的结果是一个可变数组 ArrayBuffer</p>\n</li>\n<li><p>在找到结果时，向左边扫描，向右边扫描 [条件]</p>\n</li>\n<li><p>找到结果后，就加入到ArrayBuffer</p>\n</li>\n</ol>\n<p>*&#x2F;</p>\n<p>def binarySearch2(arr: Array[Int], l: Int, r: Int,</p>\n<p>findVal: Int): ArrayBuffer[Int] &#x3D; {</p>\n<p>&#x2F;&#x2F;找不到条件?</p>\n<p>if (l &gt; r) {</p>\n<p>return ArrayBuffer()</p>\n<p>}</p>\n<p>val midIndex &#x3D; (l + r) &#x2F; 2</p>\n<p>val midVal &#x3D; arr(midIndex)</p>\n<p>if (midVal &gt; findVal) {</p>\n<p>&#x2F;&#x2F;向左进行递归查找</p>\n<p>binarySearch2(arr, l, midIndex - 1, findVal)</p>\n<p>} else if (midVal &lt; findVal) { &#x2F;&#x2F;向右进行递归查找</p>\n<p>binarySearch2(arr, midIndex + 1, r, findVal)</p>\n<p>} else {</p>\n<p>println(“midIndex&#x3D;” + midIndex)</p>\n<p>&#x2F;&#x2F;定义一个可变数组</p>\n<p>val resArr &#x3D; ArrayBuffer<a href=\"\">Int</a></p>\n<p>&#x2F;&#x2F;向左边扫描</p>\n<p>var temp &#x3D; midIndex - 1</p>\n<p>breakable {</p>\n<p>while (true) {</p>\n<p>if (temp &lt; 0 || arr(temp) !&#x3D; findVal) {</p>\n<p>break()</p>\n<p>}</p>\n<p>if (arr(temp) &#x3D;&#x3D; findVal) {</p>\n<p>resArr.append(temp)</p>\n<p>}</p>\n<p>temp -&#x3D; 1</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;将中间这个索引加入</p>\n<p>resArr.append(midIndex)</p>\n<p>&#x2F;&#x2F;向右边扫描</p>\n<p>temp &#x3D; midIndex + 1</p>\n<p>breakable {</p>\n<p>while (true) {</p>\n<p>if (temp &gt; arr.length - 1 || arr(temp) !&#x3D; findVal) {</p>\n<p>break()</p>\n<p>}</p>\n<p>if (arr(temp) &#x3D;&#x3D; findVal) {</p>\n<p>resArr.append(temp)</p>\n<p>}</p>\n<p>temp +&#x3D; 1</p>\n<p>}</p>\n<p>}</p>\n<p>return resArr</p>\n<p>}</p>\n<h3 id=\"9-1-3-快排\"><a href=\"#9-1-3-快排\" class=\"headerlink\" title=\"9.1.3 快排\"></a>9.1.3 快排</h3><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image121.png\">图1-快速排序核心思想</p>\n<p>代码实现：</p>\n<p>&#x2F;**</p>\n<ul>\n<li><p>快排</p>\n</li>\n<li><p>时间复杂度:平均时间复杂度为O(nlogn)</p>\n</li>\n<li><p>空间复杂度:O(logn)，因为递归栈空间的使用问题</p>\n</li>\n</ul>\n<p>*&#x2F;</p>\n<p>def quickSort(list: List[Int]): List[Int] &#x3D; list match {</p>\n<p>case Nil &#x3D;&gt; Nil</p>\n<p>case List() &#x3D;&gt; List()</p>\n<p>case head :: tail &#x3D;&gt;</p>\n<p>val (left, right) &#x3D; tail.partition(_ &lt; head)</p>\n<p>quickSort(left) ::: head :: quickSort(right)</p>\n<p>}</p>\n<h3 id=\"9-1-4-归并\"><a href=\"#9-1-4-归并\" class=\"headerlink\" title=\"9.1.4 归并\"></a>9.1.4 归并</h3><p>归并排序核心思想</p>\n<p>核心思想：不断的将大的数组分成两个小数组，直到不能拆分为止，即形成了单个值。此时使用合并的排序思想对已经有序的数组进行合并，合并为一个大的数据，不断重复此过程，直到最终所有数据合并到一个数组为止。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image123.png\"></p>\n<p>图3-归并排序”治”流程</p>\n<p>代码实现：</p>\n<p>&#x2F;**</p>\n<ul>\n<li><p>快排</p>\n</li>\n<li><p>时间复杂度:O(nlogn)</p>\n</li>\n<li><p>空间复杂度:O(n)</p>\n</li>\n</ul>\n<p>*&#x2F;</p>\n<p>def merge(left: List[Int], right: List[Int]): List[Int] &#x3D; (left,<br>right) match {</p>\n<p>case (Nil, _) &#x3D;&gt; right</p>\n<p>case (_, Nil) &#x3D;&gt; left</p>\n<p>case (x :: xTail, y :: yTail) &#x3D;&gt;</p>\n<p>if (x &lt;&#x3D; y) x :: merge(xTail, right)</p>\n<p>else y :: merge(left, yTail)</p>\n<p>}</p>\n<h3 id=\"9-1-5-二叉树之Scala实现\"><a href=\"#9-1-5-二叉树之Scala实现\" class=\"headerlink\" title=\"9.1.5 二叉树之Scala实现\"></a>9.1.5 二叉树之Scala实现</h3><p>1）二叉树概念</p>\n<p>2）二叉树的特点</p>\n<p>（1）树执行查找、删除、插入的时间复杂度都是O(logN)</p>\n<p>（2）遍历二叉树的方法包括前序、中序、后序</p>\n<p>（3）非平衡树指的是根的左右两边的子节点的数量不一致</p>\n<p>（4）在非空二叉树中，第i层的结点总数不超过 , i&gt;&#x3D;1；</p>\n<p>（5）深度为h的二叉树最多有个结点(h&gt;&#x3D;1)，最少有h个结点；</p>\n<p>（6）对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0&#x3D;N2+1；</p>\n<p>3） 二叉树的Scala代码实现</p>\n<p>定义节点以及前序、中序、后序遍历</p>\n<p>class TreeNode(treeNo:Int){</p>\n<p>val no &#x3D; treeNo</p>\n<p>var left:TreeNode &#x3D; null</p>\n<p>var right:TreeNode &#x3D; null</p>\n<p>&#x2F;&#x2F;后序遍历</p>\n<p>def postOrder():Unit&#x3D;{</p>\n<p>&#x2F;&#x2F;向左递归输出左子树</p>\n<p>if(this.left !&#x3D; null){</p>\n<p>this.left.postOrder</p>\n<p>}</p>\n<p>&#x2F;&#x2F;向右递归输出右子树</p>\n<p>if (this.right !&#x3D; null) {</p>\n<p>this.right.postOrder</p>\n<p>}</p>\n<p>&#x2F;&#x2F;输出当前节点值</p>\n<p>printf(“节点信息 no&#x3D;%d n”,no)</p>\n<p>}</p>\n<p>&#x2F;&#x2F;中序遍历</p>\n<p>def infixOrder():Unit&#x3D;{</p>\n<p>&#x2F;&#x2F;向左递归输出左子树</p>\n<p>if(this.left !&#x3D; null){</p>\n<p>this.left.infixOrder()</p>\n<p>}</p>\n<p>&#x2F;&#x2F;输出当前节点值</p>\n<p>printf(“节点信息 no&#x3D;%d n”,no)</p>\n<p>&#x2F;&#x2F;向右递归输出右子树</p>\n<p>if (this.right !&#x3D; null) {</p>\n<p>this.right.infixOrder()</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;前序遍历</p>\n<p>def preOrder():Unit&#x3D;{</p>\n<p>&#x2F;&#x2F;输出当前节点值</p>\n<p>printf(“节点信息 no&#x3D;%d n”,no)</p>\n<p>&#x2F;&#x2F;向左递归输出左子树</p>\n<p>if(this.left !&#x3D; null){</p>\n<p>this.left.postOrder()</p>\n<p>}</p>\n<p>&#x2F;&#x2F;向右递归输出右子树</p>\n<p>if (this.right !&#x3D; null) {</p>\n<p>this.right.preOrder()</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;后序遍历查找</p>\n<p>def postOrderSearch(no:Int): TreeNode &#x3D; {</p>\n<p>&#x2F;&#x2F;向左递归输出左子树</p>\n<p>var resNode:TreeNode &#x3D; null</p>\n<p>if (this.left !&#x3D; null) {</p>\n<p>resNode &#x3D; this.left.postOrderSearch(no)</p>\n<p>}</p>\n<p>if (resNode !&#x3D; null) {</p>\n<p>return resNode</p>\n<p>}</p>\n<p>if (this.right !&#x3D; null) {</p>\n<p>resNode &#x3D; this.right.postOrderSearch(no)</p>\n<p>}</p>\n<p>if (resNode !&#x3D; null) {</p>\n<p>return resNode</p>\n<p>}</p>\n<p>println(“ttt~~”)</p>\n<p>if (this.no &#x3D;&#x3D; no) {</p>\n<p>return this</p>\n<p>}</p>\n<p>resNode</p>\n<p>}</p>\n<p>&#x2F;&#x2F;中序遍历查找</p>\n<p>def infixOrderSearch(no:Int): TreeNode &#x3D; {</p>\n<p>var resNode : TreeNode &#x3D; null</p>\n<p>&#x2F;&#x2F;先向左递归查找</p>\n<p>if (this.left !&#x3D; null) {</p>\n<p>resNode &#x3D; this.left.infixOrderSearch(no)</p>\n<p>}</p>\n<p>if (resNode !&#x3D; null) {</p>\n<p>return resNode</p>\n<p>}</p>\n<p>println(“yyy~~”)</p>\n<p>if (no &#x3D;&#x3D; this.no) {</p>\n<p>return this</p>\n<p>}</p>\n<p>&#x2F;&#x2F;向右递归查找</p>\n<p>if (this.right !&#x3D; null) {</p>\n<p>resNode &#x3D; this.right.infixOrderSearch(no)</p>\n<p>}</p>\n<p>return resNode</p>\n<p>}</p>\n<p>&#x2F;&#x2F;前序查找</p>\n<p>def preOrderSearch(no:Int): TreeNode &#x3D; {</p>\n<p>if (no &#x3D;&#x3D; this.no) {</p>\n<p>return this</p>\n<p>}</p>\n<p>&#x2F;&#x2F;向左递归查找</p>\n<p>var resNode : TreeNode &#x3D; null</p>\n<p>if (this.left !&#x3D; null) {</p>\n<p>resNode &#x3D; this.left.preOrderSearch(no)</p>\n<p>}</p>\n<p>if (resNode !&#x3D; null){</p>\n<p>return resNode</p>\n<p>}</p>\n<p>&#x2F;&#x2F;向右边递归查找</p>\n<p>if (this.right !&#x3D; null) {</p>\n<p>resNode &#x3D; this.right.preOrderSearch(no)</p>\n<p>}</p>\n<p>return resNode</p>\n<p>}</p>\n<p>&#x2F;&#x2F;删除节点</p>\n<p>&#x2F;&#x2F;删除节点规则</p>\n<p>&#x2F;&#x2F;1如果删除的节点是叶子节点，则删除该节点</p>\n<p>&#x2F;&#x2F;2如果删除的节点是非叶子节点，则删除该子树</p>\n<p>def delNode(no:Int): Unit &#x3D; {</p>\n<p>&#x2F;&#x2F;首先比较当前节点的左子节点是否为要删除的节点</p>\n<p>if (this.left !&#x3D; null &amp;&amp; this.left.no &#x3D;&#x3D; no) {</p>\n<p>this.left &#x3D; null</p>\n<p>return</p>\n<p>}</p>\n<p>&#x2F;&#x2F;比较当前节点的右子节点是否为要删除的节点</p>\n<p>if (this.right !&#x3D; null &amp;&amp; this.right.no &#x3D;&#x3D; no) {</p>\n<p>this.right &#x3D; null</p>\n<p>return</p>\n<p>}</p>\n<p>&#x2F;&#x2F;向左递归删除</p>\n<p>if (this.left !&#x3D; null) {</p>\n<p>this.left.delNode(no)</p>\n<p>}</p>\n<p>&#x2F;&#x2F;向右递归删除</p>\n<p>if (this.right !&#x3D; null) {</p>\n<p>this.right.delNode(no)</p>\n<p>}</p>\n<p>}</p>\n<p>}</p>\n<p>定义二叉树，前序、中序、后序遍历，前序、中序、后序查找，删除节点</p>\n<p>class BinaryTree{</p>\n<p>var root:TreeNode &#x3D; null</p>\n<p>&#x2F;&#x2F;后序遍历</p>\n<p>def postOrder(): Unit &#x3D; {</p>\n<p>if (root !&#x3D; null){</p>\n<p>root.postOrder()</p>\n<p>}else {</p>\n<p>println(“当前二叉树为空，不能遍历”)</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;中序遍历</p>\n<p>def infixOrder(): Unit &#x3D; {</p>\n<p>if (root !&#x3D; null){</p>\n<p>root.infixOrder()</p>\n<p>}else {</p>\n<p>println(“当前二叉树为空，不能遍历”)</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;前序遍历</p>\n<p>def preOrder(): Unit &#x3D; {</p>\n<p>if (root !&#x3D; null){</p>\n<p>root.preOrder()</p>\n<p>}else {</p>\n<p>println(“当前二叉树为空，不能遍历”)</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;后序遍历查找</p>\n<p>def postOrderSearch(no:Int): TreeNode &#x3D; {</p>\n<p>if (root !&#x3D; null) {</p>\n<p>root.postOrderSearch(no)</p>\n<p>}else{</p>\n<p>null</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;中序遍历查找</p>\n<p>def infixOrderSeacher(no:Int): TreeNode &#x3D; {</p>\n<p>if (root !&#x3D; null) {</p>\n<p>return root.infixOrderSearch(no)</p>\n<p>}else {</p>\n<p>return null</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;前序查找</p>\n<p>def preOrderSearch(no:Int): TreeNode &#x3D; {</p>\n<p>if (root !&#x3D; null) {</p>\n<p>return root.preOrderSearch(no)</p>\n<p>}else{</p>\n<p>&#x2F;&#x2F;println(“当前二叉树为空，不能查找”)</p>\n<p>return null</p>\n<p>}</p>\n<p>}</p>\n<p>&#x2F;&#x2F;删除节点</p>\n<p>def delNode(no:Int): Unit &#x3D; {</p>\n<p>if (root !&#x3D; null) {</p>\n<p>&#x2F;&#x2F;先处理一下root是不是要删除的</p>\n<p>if (root.no &#x3D;&#x3D; no){</p>\n<p>root &#x3D; null</p>\n<p>}else {</p>\n<p>root.delNode(no)</p>\n<p>}</p>\n<p>}</p>\n<p>}</p>\n<h2 id=\"9-2-开发代码\"><a href=\"#9-2-开发代码\" class=\"headerlink\" title=\"9.2 开发代码\"></a>9.2 开发代码</h2><h3 id=\"9-2-1-手写Spark-WordCount\"><a href=\"#9-2-1-手写Spark-WordCount\" class=\"headerlink\" title=\"9.2.1 手写Spark-WordCount\"></a>9.2.1 手写Spark-WordCount</h3><p>val conf: SparkConf &#x3D;</p>\n<p>new SparkConf().setMaster(“local[*]”).setAppName(“WordCount”)</p>\n<p>val sc &#x3D; new SparkContext(conf)</p>\n<p>sc.textFile(“&#x2F;input”)</p>\n<p>.flatMap(_.split(“ “))</p>\n<p>.map((_, 1))</p>\n<p>.reduceByKey(_ + _)</p>\n<p>.saveAsTextFile(“&#x2F;output”)</p>\n<p>sc.stop()</p>\n<h2 id=\"9-3-手写HQL\"><a href=\"#9-3-手写HQL\" class=\"headerlink\" title=\"9.3 手写HQL\"></a>9.3 手写HQL</h2><h3 id=\"9-3-1-手写HQL-第1题\"><a href=\"#9-3-1-手写HQL-第1题\" class=\"headerlink\" title=\"9.3.1 手写HQL 第1题\"></a>9.3.1 手写HQL 第1题</h3><p>表结构：uid,subject_id,score</p>\n<p>求：找出所有科目成绩都大于某一学科平均成绩的学生</p>\n<p>数据集如下</p>\n<p>1001 01 90</p>\n<p>1001 02 90</p>\n<p>1001 03 90</p>\n<p>1002 01 85</p>\n<p>1002 02 85</p>\n<p>1002 03 70</p>\n<p>1003 01 70</p>\n<p>1003 02 70</p>\n<p>1003 03 85</p>\n<p>1）建表语句</p>\n<p>create table score(</p>\n<p>uid string,</p>\n<p>subject_id string,</p>\n<p>score int)</p>\n<p>row format delimited fields terminated by ‘t’;</p>\n<p>2）求出每个学科平均成绩</p>\n<p>select</p>\n<p>uid,</p>\n<p>score,</p>\n<p>avg(score) over(partition by subject_id) avg_score</p>\n<p>from</p>\n<p>score;t1</p>\n<p>3）根据是否大于平均成绩记录flag，大于则记为0否则记为1</p>\n<p>select</p>\n<p>uid,</p>\n<p>if(score&gt;avg_score,0,1) flag</p>\n<p>from</p>\n<p>t1;t2</p>\n<p>4）根据学生id进行分组统计flag的和，和为0则是所有学科都大于平均成绩</p>\n<p>select</p>\n<p>uid</p>\n<p>from</p>\n<p>t2</p>\n<p>group by</p>\n<p>uid</p>\n<p>having</p>\n<p>sum(flag)&#x3D;0;</p>\n<p>5）最终SQL</p>\n<p>select</p>\n<p>uid</p>\n<p>from</p>\n<p>(select</p>\n<p>uid,</p>\n<p>if(score&gt;avg_score,0,1) flag</p>\n<p>from</p>\n<p>(select</p>\n<p>uid,</p>\n<p>score,</p>\n<p>avg(score) over(partition by subject_id) avg_score</p>\n<p>from</p>\n<p>score)t1)t2</p>\n<p>group by</p>\n<p>uid</p>\n<p>having</p>\n<p>sum(flag)&#x3D;0;</p>\n<h3 id=\"9-3-2-手写HQL-第2题\"><a href=\"#9-3-2-手写HQL-第2题\" class=\"headerlink\" title=\"9.3.2 手写HQL 第2题\"></a>9.3.2 手写HQL 第2题</h3><p>我们有如下的用户访问数据</p>\n<hr>\n<p>  userId   visitDate   visitCount<br>  u01      2017&#x2F;1&#x2F;21   5<br>  u02      2017&#x2F;1&#x2F;23   6<br>  u03      2017&#x2F;1&#x2F;22   8<br>  u04      2017&#x2F;1&#x2F;20   3<br>  u01      2017&#x2F;1&#x2F;23   6<br>  u01      2017&#x2F;2&#x2F;21   8<br>  U02      2017&#x2F;1&#x2F;23   6<br>  U01      2017&#x2F;2&#x2F;22   4</p>\n<hr>\n<p>要求使用SQL统计出每个用户的累积访问次数，如下表所示：</p>\n<hr>\n<p>  用户id   月份      小计   累积<br>  u01      2017-01   11     11<br>  u01      2017-02   12     23<br>  u02      2017-01   12     12<br>  u03      2017-01   8      8<br>  u04      2017-01   3      3</p>\n<hr>\n<p>数据集</p>\n<p>u01 2017&#x2F;1&#x2F;21 5</p>\n<p>u02 2017&#x2F;1&#x2F;23 6</p>\n<p>u03 2017&#x2F;1&#x2F;22 8</p>\n<p>u04 2017&#x2F;1&#x2F;20 3</p>\n<p>u01 2017&#x2F;1&#x2F;23 6</p>\n<p>u01 2017&#x2F;2&#x2F;21 8</p>\n<p>u02 2017&#x2F;1&#x2F;23 6</p>\n<p>u01 2017&#x2F;2&#x2F;22 4</p>\n<p>1）创建表</p>\n<p>create table action</p>\n<p>(userId string,</p>\n<p>visitDate string,</p>\n<p>visitCount int)</p>\n<p>row format delimited fields terminated by “t”;</p>\n<p>2）修改数据格式</p>\n<p>select</p>\n<p>userId,</p>\n<p>date_format(regexp_replace(visitDate,’&#x2F;‘,’-‘),’yyyy-MM’) mn,</p>\n<p>visitCount</p>\n<p>from</p>\n<p>action;t1</p>\n<p>3）计算每人单月访问量</p>\n<p>select</p>\n<p>userId,</p>\n<p>mn,</p>\n<p>sum(visitCount) mn_count</p>\n<p>from</p>\n<p>t1</p>\n<p>group by</p>\n<p>userId,mn;t2</p>\n<p>4）按月累计访问量</p>\n<p>select</p>\n<p>userId,</p>\n<p>mn,</p>\n<p>mn_count,</p>\n<p>sum(mn_count) over(partition by userId order by mn)</p>\n<p>from t2;</p>\n<p>5）最终SQL</p>\n<p>select</p>\n<p>userId,</p>\n<p>mn,</p>\n<p>mn_count,</p>\n<p>sum(mn_count) over(partition by userId order by mn)</p>\n<p>from</p>\n<p>( select</p>\n<p>userId,</p>\n<p>mn,</p>\n<p>sum(visitCount) mn_count</p>\n<p>from</p>\n<p>(select</p>\n<p>userId,</p>\n<p>date_format(regexp_replace(visitDate,’&#x2F;‘,’-‘),’yyyy-MM’) mn,</p>\n<p>visitCount</p>\n<p>from</p>\n<p>action)t1</p>\n<p>group by userId,mn)t2;</p>\n<h3 id=\"9-3-3-手写HQL-第3题\"><a href=\"#9-3-3-手写HQL-第3题\" class=\"headerlink\" title=\"9.3.3 手写HQL 第3题\"></a>9.3.3 手写HQL 第3题</h3><p>有50W个京东店铺，每个顾客访客访问任何一个店铺的任何一个商品时都会产生一条访问日志，访问日志存储的表名为Visit，访客的用户id为user_id，被访问的店铺名称为shop，请统计：</p>\n<p>1）每个店铺的UV（访客数）</p>\n<p>2）每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数</p>\n<p>数据集</p>\n<p>u1 a</p>\n<p>u2 b</p>\n<p>u1 b</p>\n<p>u1 a</p>\n<p>u3 c</p>\n<p>u4 b</p>\n<p>u1 a</p>\n<p>u2 c</p>\n<p>u5 b</p>\n<p>u4 b</p>\n<p>u6 c</p>\n<p>u2 c</p>\n<p>u1 b</p>\n<p>u2 a</p>\n<p>u2 a</p>\n<p>u3 a</p>\n<p>u5 a</p>\n<p>u5 a</p>\n<p>u5 a</p>\n<p>1）建表</p>\n<p>create table visit(user_id string,shop string) row format delimited<br>fields terminated by ‘t’;</p>\n<p>2）每个店铺的UV（访客数）</p>\n<p>select shop,count(distinct user_id) from visit group by shop;</p>\n<p>3）每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数</p>\n<p>（1）查询每个店铺被每个用户访问次数</p>\n<p>select shop,user_id,count(*) ct</p>\n<p>from visit</p>\n<p>group by shop,user_id;t1</p>\n<p>（2）计算每个店铺被用户访问次数排名</p>\n<p>select shop,user_id,ct,rank() over(partition by shop order by ct) rk</p>\n<p>from t1;t2</p>\n<p>（3）取每个店铺排名前3的</p>\n<p>select shop,user_id,ct</p>\n<p>from t2</p>\n<p>where rk&lt;&#x3D;3;</p>\n<p>（4）最终SQL</p>\n<p>select</p>\n<p>shop,</p>\n<p>user_id,</p>\n<p>ct</p>\n<p>from</p>\n<p>(select</p>\n<p>shop,</p>\n<p>user_id,</p>\n<p>ct,</p>\n<p>rank() over(partition by shop order by ct) rk</p>\n<p>from</p>\n<p>(select</p>\n<p>shop,</p>\n<p>user_id,</p>\n<p>count(*) ct</p>\n<p>from visit</p>\n<p>group by</p>\n<p>shop,</p>\n<p>user_id)t1</p>\n<p>)t2</p>\n<p>where rk&lt;&#x3D;3;</p>\n<h3 id=\"9-3-4-手写HQL-第4题\"><a href=\"#9-3-4-手写HQL-第4题\" class=\"headerlink\" title=\"9.3.4 手写HQL 第4题\"></a>9.3.4 手写HQL 第4题</h3><p>已知一个表STG.ORDER，有如下字段:Date，Order_id，User_id，amount。请给出sql进行统计:数据样例:2017-01-01,10029028,1000003251,33.57。</p>\n<p>1）给出 2017年每个月的订单数、用户数、总成交金额。</p>\n<p>2）给出2017年11月的新客数(指在11月才有第一笔订单)</p>\n<p>建表</p>\n<p>create table order_tab(dt string,order_id string,user_id<br>string,amount decimal(10,2)) row format delimited fields terminated by<br>‘t’;</p>\n<p>1）给出 2017年每个月的订单数、用户数、总成交金额。</p>\n<p>select</p>\n<p>date_format(dt,’yyyy-MM’),</p>\n<p>count(order_id),</p>\n<p>count(distinct user_id),</p>\n<p>sum(amount)</p>\n<p>from</p>\n<p>order_tab</p>\n<p>where</p>\n<p>date_format(dt,’yyyy’)&#x3D;’2017’</p>\n<p>group by</p>\n<p>date_format(dt,’yyyy-MM’);</p>\n<p>2）给出2017年11月的新客数(指在11月才有第一笔订单)</p>\n<p>select</p>\n<p>count(user_id)</p>\n<p>from</p>\n<p>order_tab</p>\n<p>group by</p>\n<p>user_id</p>\n<p>having</p>\n<p>date_format(min(dt),’yyyy-MM’)&#x3D;’2017-11’;</p>\n<h3 id=\"9-3-5-手写HQL-第5题\"><a href=\"#9-3-5-手写HQL-第5题\" class=\"headerlink\" title=\"9.3.5 手写HQL 第5题\"></a>9.3.5 手写HQL 第5题</h3><p>有日志如下，请写出代码求得所有用户和活跃用户的总数及平均年龄。（活跃用户指连续两天都有访问记录的用户）日期<br>用户 年龄</p>\n<p>数据集</p>\n<p>2019-02-11,test_1,23</p>\n<p>2019-02-11,test_2,19</p>\n<p>2019-02-11,test_3,39</p>\n<p>2019-02-11,test_1,23</p>\n<p>2019-02-11,test_3,39</p>\n<p>2019-02-11,test_1,23</p>\n<p>2019-02-12,test_2,19</p>\n<p>2019-02-13,test_1,23</p>\n<p>2019-02-15,test_2,19</p>\n<p>2019-02-16,test_2,19</p>\n<p>1）建表</p>\n<p>create table user_age(dt string,user_id string,age int)row format<br>delimited fields terminated by ‘,’;</p>\n<p>2）按照日期以及用户分组，按照日期排序并给出排名</p>\n<p>select</p>\n<p>dt,</p>\n<p>user_id,</p>\n<p>min(age) age,</p>\n<p>rank() over(partition by user_id order by dt) rk</p>\n<p>from</p>\n<p>user_age</p>\n<p>group by</p>\n<p>dt,user_id;t1</p>\n<p>3）计算日期及排名的差值</p>\n<p>select</p>\n<p>user_id,</p>\n<p>age,</p>\n<p>date_sub(dt,rk) flag</p>\n<p>from</p>\n<p>t1;t2</p>\n<p>4）过滤出差值大于等于2的，即为连续两天活跃的用户</p>\n<p>select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>t2</p>\n<p>group by</p>\n<p>user_id,flag</p>\n<p>having</p>\n<p>count(*)&gt;&#x3D;2;t3</p>\n<p>5）对数据进行去重处理（一个用户可以在两个不同的时间点连续登录），例如：a用户在1月10号1月11号以及1月20号和1月21号4天登录。</p>\n<p>select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>t3</p>\n<p>group by</p>\n<p>user_id;t4</p>\n<p>6）计算活跃用户（两天连续有访问）的人数以及平均年龄</p>\n<p>select</p>\n<p>count(*) ct,</p>\n<p>cast(sum(age)&#x2F;count(*) as decimal(10,2))</p>\n<p>from t4;</p>\n<p>7）对全量数据集进行按照用户去重</p>\n<p>select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>user_age</p>\n<p>group by</p>\n<p>user_id;t5</p>\n<p>8）计算所有用户的数量以及平均年龄</p>\n<p>select</p>\n<p>count(*) user_count,</p>\n<p>cast((sum(age)&#x2F;count(*)) as decimal(10,1))</p>\n<p>from</p>\n<p>t5;</p>\n<p>9）将第5步以及第7步两个数据集进行union all操作</p>\n<p>select</p>\n<p>0 user_total_count,</p>\n<p>0 user_total_avg_age,</p>\n<p>count(*) twice_count,</p>\n<p>cast(sum(age)&#x2F;count(*) as decimal(10,2)) twice_count_avg_age</p>\n<p>from</p>\n<p>(</p>\n<p>select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>(select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>(</p>\n<p>select</p>\n<p>user_id,</p>\n<p>age,</p>\n<p>date_sub(dt,rk) flag</p>\n<p>from</p>\n<p>(</p>\n<p>select</p>\n<p>dt,</p>\n<p>user_id,</p>\n<p>min(age) age,</p>\n<p>rank() over(partition by user_id order by dt) rk</p>\n<p>from</p>\n<p>user_age</p>\n<p>group by</p>\n<p>dt,user_id</p>\n<p>)t1</p>\n<p>)t2</p>\n<p>group by</p>\n<p>user_id,flag</p>\n<p>having</p>\n<p>count(*)&gt;&#x3D;2)t3</p>\n<p>group by</p>\n<p>user_id</p>\n<p>)t4</p>\n<p>union all</p>\n<p>select</p>\n<p>count(*) user_total_count,</p>\n<p>cast((sum(age)&#x2F;count(*)) as decimal(10,1)),</p>\n<p>0 twice_count,</p>\n<p>0 twice_count_avg_age</p>\n<p>from</p>\n<p>(</p>\n<p>select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>user_age</p>\n<p>group by</p>\n<p>user_id</p>\n<p>)t5;t6</p>\n<p>10）求和并拼接为最终SQL</p>\n<p>select</p>\n<p>sum(user_total_count),</p>\n<p>sum(user_total_avg_age),</p>\n<p>sum(twice_count),</p>\n<p>sum(twice_count_avg_age)</p>\n<p>from</p>\n<p>(select</p>\n<p>0 user_total_count,</p>\n<p>0 user_total_avg_age,</p>\n<p>count(*) twice_count,</p>\n<p>cast(sum(age)&#x2F;count(*) as decimal(10,2)) twice_count_avg_age</p>\n<p>from</p>\n<p>(</p>\n<p>select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>(select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>(</p>\n<p>select</p>\n<p>user_id,</p>\n<p>age,</p>\n<p>date_sub(dt,rk) flag</p>\n<p>from</p>\n<p>(</p>\n<p>select</p>\n<p>dt,</p>\n<p>user_id,</p>\n<p>min(age) age,</p>\n<p>rank() over(partition by user_id order by dt) rk</p>\n<p>from</p>\n<p>user_age</p>\n<p>group by</p>\n<p>dt,user_id</p>\n<p>)t1</p>\n<p>)t2</p>\n<p>group by</p>\n<p>user_id,flag</p>\n<p>having</p>\n<p>count(*)&gt;&#x3D;2)t3</p>\n<p>group by</p>\n<p>user_id</p>\n<p>)t4</p>\n<p>union all</p>\n<p>select</p>\n<p>count(*) user_total_count,</p>\n<p>cast((sum(age)&#x2F;count(*)) as decimal(10,1)),</p>\n<p>0 twice_count,</p>\n<p>0 twice_count_avg_age</p>\n<p>from</p>\n<p>(</p>\n<p>select</p>\n<p>user_id,</p>\n<p>min(age) age</p>\n<p>from</p>\n<p>user_age</p>\n<p>group by</p>\n<p>user_id</p>\n<p>)t5)t6;</p>\n<h3 id=\"9-3-6-手写HQL-第6题\"><a href=\"#9-3-6-手写HQL-第6题\" class=\"headerlink\" title=\"9.3.6 手写HQL 第6题\"></a>9.3.6 手写HQL 第6题</h3><p>请用sql写出所有用户中在今年10月份第一次购买商品的金额，表ordertable字段（购买用户：userid，金额：money，购买时间：paymenttime(格式：2017-10-01)，订单id：orderid）</p>\n<p>1）建表</p>\n<p>create table ordertable(</p>\n<p>userid string,</p>\n<p>money int,</p>\n<p>paymenttime string,</p>\n<p>orderid string)</p>\n<p>row format delimited fields terminated by ‘t’;</p>\n<p>2）查询出</p>\n<p>select</p>\n<p>userid,</p>\n<p>min(paymenttime) paymenttime</p>\n<p>from</p>\n<p>ordertable</p>\n<p>where</p>\n<p>date_format(paymenttime,’yyyy-MM’)&#x3D;’2017-10’</p>\n<p>group by</p>\n<p>userid;t1</p>\n<p>select</p>\n<p>t1.userid,</p>\n<p>t1.paymenttime,</p>\n<p>od.money</p>\n<p>from</p>\n<p>t1</p>\n<p>join</p>\n<p>ordertable od</p>\n<p>on</p>\n<p>t1.userid&#x3D;od.userid</p>\n<p>and</p>\n<p>t1.paymenttime&#x3D;od.paymenttime;</p>\n<p>select</p>\n<p>t1.userid,</p>\n<p>t1.paymenttime,</p>\n<p>od.money</p>\n<p>from</p>\n<p>(select</p>\n<p>userid,</p>\n<p>min(paymenttime) paymenttime</p>\n<p>from</p>\n<p>ordertable</p>\n<p>where</p>\n<p>date_format(paymenttime,’yyyy-MM’)&#x3D;’2017-10’</p>\n<p>group by</p>\n<p>userid)t1</p>\n<p>join</p>\n<p>ordertable od</p>\n<p>on</p>\n<p>t1.userid&#x3D;od.userid</p>\n<p>and</p>\n<p>t1.paymenttime&#x3D;od.paymenttime;</p>\n<h3 id=\"9-3-7-手写HQL-第7题\"><a href=\"#9-3-7-手写HQL-第7题\" class=\"headerlink\" title=\"9.3.7 手写HQL 第7题\"></a>9.3.7 手写HQL 第7题</h3><p>有一个线上服务器访问日志格式如下（用sql答题）</p>\n<p>时间 接口 ip地址</p>\n<p>2016-11-09 11：22：05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.33</p>\n<p>2016-11-09 11：23：10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16</p>\n<p>…..</p>\n<p>2016-11-09 23：59：40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166</p>\n<p>求11月9号下午14点（14-15点），访问api&#x2F;user&#x2F;login接口的top10的ip地址</p>\n<p>数据集</p>\n<p>2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.33</p>\n<p>2016-11-09 11:23:10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16</p>\n<p>2016-11-09 14:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166</p>\n<p>2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.34</p>\n<p>2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.34</p>\n<p>2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.34</p>\n<p>2016-11-09 11:23:10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16</p>\n<p>2016-11-09 23:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166</p>\n<p>2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.34</p>\n<p>2016-11-09 11:23:10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16</p>\n<p>2016-11-09 23:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166</p>\n<p>2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.35</p>\n<p>2016-11-09 14:23:10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16</p>\n<p>2016-11-09 23:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166</p>\n<p>2016-11-09 14:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166</p>\n<p>2016-11-09 14:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166</p>\n<p>1）建表</p>\n<p>create table ip(</p>\n<p>time string,</p>\n<p>interface string,</p>\n<p>ip string)</p>\n<p>row format delimited fields terminated by ‘t’;</p>\n<p>2）最终SQL</p>\n<p>select</p>\n<p>ip,</p>\n<p>interface,</p>\n<p>count(*) ct</p>\n<p>from</p>\n<p>ip</p>\n<p>where</p>\n<p>date_format(time,’yyyy-MM-dd HH’)&gt;&#x3D;’2016-11-09 14’</p>\n<p>and</p>\n<p>date_format(time,’yyyy-MM-dd HH’)&lt;&#x3D;’2016-11-09 15’</p>\n<p>and</p>\n<p>interface&#x3D;’&#x2F;api&#x2F;user&#x2F;login’</p>\n<p>group by</p>\n<p>ip,interface</p>\n<p>order by</p>\n<p>ct desc</p>\n<p>limit 2;t1</p>\n<h3 id=\"9-3-8-手写SQL-第8题\"><a href=\"#9-3-8-手写SQL-第8题\" class=\"headerlink\" title=\"9.3.8 手写SQL 第8题\"></a>9.3.8 手写SQL 第8题</h3><p>有一个账号表如下，请写出SQL语句，查询各自区组的money排名前十的账号（分组取前10）</p>\n<p>1）建表（MySQL）</p>\n<p>CREATE TABLE <code>account</code></p>\n<p>( <code>dist_id</code> int（11）DEFAULT NULL COMMENT ‘区组id’,</p>\n<p><code>account</code> varchar（100）DEFAULT NULL COMMENT ‘账号’,</p>\n<p><code>gold</code> int（11）DEFAULT 0 COMMENT ‘金币’）;</p>\n<p>2）最终SQL</p>\n<p>select</p>\n<ul>\n<li></li>\n</ul>\n<p>from</p>\n<p>account as a</p>\n<p>where</p>\n<p>(select</p>\n<p>count(distinct(a1.gold))</p>\n<p>from</p>\n<p>account as a1</p>\n<p>where</p>\n<p>a1.dist_id&#x3D;a.dist_id</p>\n<p>and</p>\n<p>a1.gold&gt;a.gold)&lt;3;</p>\n<h3 id=\"9-3-9-手写HQL-第9题\"><a href=\"#9-3-9-手写HQL-第9题\" class=\"headerlink\" title=\"9.3.9 手写HQL 第9题\"></a>9.3.9 手写HQL 第9题</h3><p>1）有三张表分别为会员表（member）销售表（sale）退货表（regoods）</p>\n<p>（1）会员表有字段memberid（会员id，主键）credits（积分）；</p>\n<p>（2）销售表有字段memberid（会员id，外键）购买金额（MNAccount）；</p>\n<p>（3）退货表中有字段memberid（会员id，外键）退货金额（RMNAccount）。</p>\n<p>2）业务说明</p>\n<p>（1）销售表中的销售记录可以是会员购买，也可以是非会员购买。（即销售表中的memberid可以为空）；</p>\n<p>（2）销售表中的一个会员可以有多条购买记录；</p>\n<p>（3）退货表中的退货记录可以是会员，也可是非会员；</p>\n<p>（4）一个会员可以有一条或多条退货记录。</p>\n<p>查询需求：分组查出销售表中所有会员购买金额，同时分组查出退货表中所有会员的退货金额，把会员id相同的购买金额-退款金额得到的结果更新到表会员表中对应会员的积分字段（credits）</p>\n<p>数据集</p>\n<p>sale</p>\n<p>1001 50.3</p>\n<p>1002 56.5</p>\n<p>1003 235</p>\n<p>1001 23.6</p>\n<p>1005 56.2</p>\n<p>25.6</p>\n<p>33.5</p>\n<p>regoods</p>\n<p>1001 20.1</p>\n<p>1002 23.6</p>\n<p>1001 10.1</p>\n<p>23.5</p>\n<p>10.2</p>\n<p>1005 0.8</p>\n<p>1）建表</p>\n<p>create table member(memberid string,credits double) row format delimited<br>fields terminated by ‘t’;</p>\n<p>create table sale(memberid string,MNAccount double) row format delimited<br>fields terminated by ‘t’;</p>\n<p>create table regoods(memberid string,RMNAccount double) row format<br>delimited fields terminated by ‘t’;</p>\n<p>2）最终SQL</p>\n<p>insert into table member</p>\n<p>select</p>\n<p>t1.memberid,</p>\n<p>MNAccount-RMNAccount</p>\n<p>from</p>\n<p>(select</p>\n<p>memberid,</p>\n<p>sum(MNAccount) MNAccount</p>\n<p>from</p>\n<p>sale</p>\n<p>where</p>\n<p>memberid!&#x3D;’’</p>\n<p>group by</p>\n<p>memberid</p>\n<p>)t1</p>\n<p>join</p>\n<p>(select</p>\n<p>memberid,</p>\n<p>sum(RMNAccount) RMNAccount</p>\n<p>from</p>\n<p>regoods</p>\n<p>where</p>\n<p>memberid!&#x3D;’’</p>\n<p>group by</p>\n<p>memberid</p>\n<p>)t2</p>\n<p>on</p>\n<p>t1.memberid&#x3D;t2.memberid;</p>\n<h3 id=\"9-3-10-手写HQL-第10题\"><a href=\"#9-3-10-手写HQL-第10题\" class=\"headerlink\" title=\"9.3.10 手写HQL 第10题\"></a>9.3.10 手写HQL 第10题</h3><p>1.用一条SQL语句查询出每门课都大于80分的学生姓名</p>\n<p>name   kecheng   fenshu</p>\n<p>张三    语文    81</p>\n<p>张三    数学    75</p>\n<p>李四    语文    76</p>\n<p>李四    数学    90</p>\n<p>王五    语文    81</p>\n<p>王五    数学    100</p>\n<p>王五    英语    90</p>\n<p>A: select distinct name from table where name not in (select distinct<br>name from table where fenshu&lt;&#x3D;80)</p>\n<p>B：select name from table group by name having min(fenshu)&gt;80</p>\n<p>2. 学生表 如下:<br>自动编号   学号  姓名 课程编号 课程名称 分数<br>1     2005001 张三  0001   数学   69<br>2     2005002 李四  0001   数学   89<br>3     2005001 张三  0001   数学   69<br>删除除了自动编号不同, 其他都相同的学生冗余信息</p>\n<p>A: delete tablename where 自动编号 not in(select min(自动编号) from<br>tablename group by学号, 姓名, 课程编号, 课程名称, 分数)</p>\n<p>3.一个叫team的表，里面只有一个字段name,一共有4条纪录，分别是a,b,c,d,对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合.</p>\n<p>答：select a.name, b.name<br>from team a, team b<br>where a.name &lt; b.name</p>\n<p>4.面试题：怎么把这样一个<br>year   month amount<br>1991   1     1.1<br>1991   2     1.2<br>1991   3     1.3<br>1991   4     1.4<br>1992   1     2.1<br>1992   2     2.2<br>1992   3     2.3<br>1992   4     2.4<br>查成这样一个结果<br>year m1  m2  m3 m4<br>1991 1.1 1.2 1.3 1.4<br>1992 2.1 2.2 2.3 2.4 </p>\n<p>答案<br>select year, <br>(select amount from aaa m where month&#x3D;1 and m.year&#x3D;aaa.year) as m1,<br>(select amount from aaa m where month&#x3D;2 and m.year&#x3D;aaa.year) as m2,<br>(select amount from aaa m where month&#x3D;3 and m.year&#x3D;aaa.year) as m3,<br>(select amount from aaa m where month&#x3D;4 and m.year&#x3D;aaa.year) as m4<br>from aaa group by year</p>\n<hr>\n<p>*5.说明：复制表(只复制结构,源表名：a新表名：b) </p>\n<p>SQL: select * into b from a where 1&lt;&gt;1<br>(where1&#x3D;1，拷贝表结构和数据内容)<br>ORACLE:create table b</p>\n<p>As</p>\n<p>Select * from a where 1&#x3D;2</p>\n<p> </p>\n<p>[&lt;&gt;（不等于）(SQL Server Compact)</p>\n<p>比较两个表达式。<br>当使用此运算符比较非空表达式时，如果左操作数不等于右操作数，则结果为<br>TRUE。 否则，结果为 FALSE。]</p>\n<ol start=\"6\">\n<li></li>\n</ol>\n<p>原表:<br>courseid coursename score</p>\n<hr>\n<p>1 java 70<br>2 oracle 90<br>3 xml 40<br>4 jsp 30<br>5 servlet 80</p>\n<hr>\n<p>为了便于阅读,查询此表后的结果显式如下(及格分数为60):<br>courseid coursename score mark</p>\n<hr>\n<p>1 java 70 pass<br>2 oracle 90 pass<br>3 xml 40 fail<br>4 jsp 30 fail<br>5 servlet 80 pass</p>\n<hr>\n<p>写出此查询语句<br>select courseid, coursename ,score ,if(score&gt;&#x3D;60, “pass”,”fail”) as<br>mark from course</p>\n<p>7.表名：购物信息</p>\n<p>购物人 商品名称 数量</p>\n<p>A 甲 2</p>\n<p>B 乙 4</p>\n<p>C 丙 1</p>\n<p>A 丁 2</p>\n<p>B 丙 5</p>\n<p>……</p>\n<p>给出所有购入商品为两种或两种以上的购物人记录</p>\n<p>答：select * from 购物信息 where 购物人 in (select 购物人 from 购物信息<br>group by 购物人 having count(*) &gt;&#x3D; 2);</p>\n<ol start=\"8\">\n<li></li>\n</ol>\n<p>info 表</p>\n<p>date result</p>\n<p>2005-05-09 win</p>\n<p>2005-05-09 lose</p>\n<p>2005-05-09 lose</p>\n<p>2005-05-09 lose</p>\n<p>2005-05-10 win</p>\n<p>2005-05-10 lose</p>\n<p>2005-05-10 lose</p>\n<p>如果要生成下列结果, 该如何写sql语句?</p>\n<p>　　 win lose</p>\n<p>2005-05-09 2 2</p>\n<p>2005-05-10 1 2</p>\n<p>答案：</p>\n<p>(1) select date, sum(case when result &#x3D; “win” then 1 else 0 end) as<br>“win”, sum(case when result &#x3D; “lose” then 1 else 0 end) as “lose”<br>from info group by date;</p>\n<p>(2) select a.date, a.result as win, b.result as lose</p>\n<p>　　from</p>\n<p>　　(select date, count(result) as result from info where result &#x3D;<br>“win” group by date) as a</p>\n<p>　　join</p>\n<p>　　(select date, count(result) as result from info where result &#x3D;<br>“lose” group by date) as b</p>\n<p>on a.date &#x3D; b.date;</p>\n<h3 id=\"9-3-11-手写HQL-第11题\"><a href=\"#9-3-11-手写HQL-第11题\" class=\"headerlink\" title=\"9.3.11 手写HQL 第11题\"></a>9.3.11 手写HQL 第11题</h3><p>有一个订单表order。已知字段有：order_id(订单ID),<br>user_id(用户ID),amount(金额),<br>pay_datetime(付费时间),channel_id(渠道ID),dt(分区字段)。</p>\n<ol>\n<li><p>在Hive中创建这个表。</p>\n</li>\n<li><p>查询dt&#x3D;’2018-09-01’里每个渠道的订单数，下单人数（去重），总金额。</p>\n</li>\n<li><p>查询dt&#x3D;’2018-09-01’里每个渠道的金额最大3笔订单。</p>\n</li>\n<li><p>有一天发现订单数据重复，请分析原因</p>\n</li>\n</ol>\n<p>create external table order(</p>\n<p>order_id int,</p>\n<p>user_id int,</p>\n<p>amount double,</p>\n<p>pay_datatime timestamp,</p>\n<p>channel_id int</p>\n<p>)partitioned by(dt string)</p>\n<p>row format delimited fields terminated by ‘t’;</p>\n<p>select</p>\n<p>count(order_id),</p>\n<p>count(distinct(user_id))</p>\n<p>sum(amount)</p>\n<p>from</p>\n<p>order</p>\n<p>where dt&#x3D;”2019-09-01”</p>\n<p>select</p>\n<p>order_id</p>\n<p>channel_id</p>\n<p>channel_id_amount</p>\n<p>from(</p>\n<p>select</p>\n<p>order_id</p>\n<p>channel_id,</p>\n<p>amount,</p>\n<p>max(amount) over(partition by channel_id)</p>\n<p>min(amount) over(partition by channel_id)</p>\n<p>row_number()</p>\n<p>over(</p>\n<p>partition by channel_id</p>\n<p>order by amount desc</p>\n<p>)rank</p>\n<p>from</p>\n<p>order</p>\n<p>where dt&#x3D;”2019-09-01”</p>\n<p>)t</p>\n<p>where t.rank&lt;4</p>\n<p>订单属于业务数据，在关系型数据库中不会存在数据重复</p>\n<p>hive建表时也不会导致数据重复，</p>\n<p>我推测是在数据迁移时，迁移失败导致重复迁移数据冗余了</p>\n<p>t_order订单表</p>\n<p>order_id,&#x2F;&#x2F;订单id</p>\n<p>item_id, &#x2F;&#x2F;商品id</p>\n<p>create_time,&#x2F;&#x2F;下单时间</p>\n<p>amount&#x2F;&#x2F;下单金额</p>\n<p>t_item商品表</p>\n<p>item_id,&#x2F;&#x2F;商品id</p>\n<p>item_name,&#x2F;&#x2F;商品名称</p>\n<p>category&#x2F;&#x2F;品类</p>\n<p>t_item商品表</p>\n<p>item_id,&#x2F;&#x2F;商品id</p>\n<p>item_name,&#x2F;&#x2F;名称</p>\n<p>category_1,&#x2F;&#x2F;一级品类</p>\n<p>category_2,&#x2F;&#x2F;二级品类</p>\n<ol>\n<li>最近一个月，销售数量最多的10个商品</li>\n</ol>\n<p>select</p>\n<p>item_id,</p>\n<p>count(order_id)a</p>\n<p>from</p>\n<p>t_order</p>\n<p>where</p>\n<p>dataediff(create_time,current_date)&lt;&#x3D;30</p>\n<p>group by</p>\n<p>item_id</p>\n<p>order by a desc;</p>\n<ol start=\"2\">\n<li>最近一个月，每个种类里销售数量最多的10个商品</li>\n</ol>\n<p>#一个订单对应一个商品 一个商品对应一个品类</p>\n<p>with(</p>\n<p>select</p>\n<p>order_id,</p>\n<p>item_id,</p>\n<p>item_name,</p>\n<p>category</p>\n<p>from</p>\n<p>t_order</p>\n<p>join</p>\n<p>t_item</p>\n<p>on</p>\n<p>t_order.item_id &#x3D; t_item.item_id</p>\n<p>) t</p>\n<p>select</p>\n<p>order_id,</p>\n<p>item_id,</p>\n<p>item_name,</p>\n<p>category,</p>\n<p>count(item_id)over(</p>\n<p>partition by category</p>\n<p>)item_count</p>\n<p>from</p>\n<p>t</p>\n<p>group by category</p>\n<p>order by item_count desc</p>\n<p>limit 10;</p>\n<p>计算平台的每一个用户发过多少日记、获得多少点赞数</p>\n<p>with t3 as(</p>\n<p>select * from</p>\n<p>t1 left join t2</p>\n<p>on t1.log_id &#x3D; t2.log_id</p>\n<p>)</p>\n<p>select</p>\n<p>uid,&#x2F;&#x2F;用户Id</p>\n<p>count(log_id)over(partition by uid)log_cnt,&#x2F;&#x2F;</p>\n<p>count(like_uid)over(partition by log_id)liked_cnt&#x2F;&#x2F;获得多少点赞数</p>\n<p>from</p>\n<p>t3</p>\n<p>处理产品版本号</p>\n<p>1、需求A:找出T1表中最大的版本号</p>\n<p>思路：列转行 切割版本号 一列变三列</p>\n<p>主版本号 子版本号 阶段版本号</p>\n<p>with t2 as(&#x2F;&#x2F;转换</p>\n<p>select</p>\n<p>v_id v1,&#x2F;&#x2F;版本号</p>\n<p>v_id v2 &#x2F;&#x2F;主</p>\n<p>from</p>\n<p>t1</p>\n<p>lateral view explode(v2) tmp as v2</p>\n<p>)</p>\n<p>select &#x2F;&#x2F;第一层 找出第一个</p>\n<p>v1,</p>\n<p>max(v2)</p>\n<p>from</p>\n<p>t2</p>\n<hr>\n<p>1、需求A:找出T1表中最大的版本号</p>\n<p>select</p>\n<p>v_id,&#x2F;&#x2F;版本号</p>\n<p>max(split(v_id,”.”)[0]) v1,&#x2F;&#x2F;主版本不会为空</p>\n<p>max(if(split(v_id,”.”)[1]&#x3D;””,0,split(v_id,”.”)[1]))v2,&#x2F;&#x2F;取出子版本并判断是否为空，并给默认值</p>\n<p>max(if(split(v_id,”.”)[2]&#x3D;””,0,split(v_id,”.”)[2]))v3&#x2F;&#x2F;取出阶段版本并判断是否为空，并给默认值</p>\n<p>from</p>\n<p>t1</p>\n<p>2、需求B：计算出如下格式的所有版本号排序，要求对于相同的版本号，顺序号并列：</p>\n<p>select</p>\n<p>v_id,</p>\n<p>rank() over(partition by v_id order by v_id)seq</p>\n<p>from</p>\n<p>t1</p>\n<h3 id=\"9-3-12-连续问题\"><a href=\"#9-3-12-连续问题\" class=\"headerlink\" title=\"9.3.12 连续问题\"></a>9.3.12 连续问题</h3><p>如下数据为蚂蚁森林中用户领取的减少碳排放量</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>id dt lowcarbon</p>\n<p>1001 2021-12-12 123</p>\n<p>1002 2021-12-12 45</p>\n<p>1001 2021-12-13 43</p>\n<p>1001 2021-12-13 45</p>\n<p>1001 2021-12-13 23</p>\n<p>1002 2021-12-14 45</p>\n<p>1001 2021-12-14 230</p>\n<p>1002 2021-12-15 45</p>\n<p>1001 2021-12-15 23</p>\n<p>… …</p></blockquote>\n<p>找出连续3天及以上减少碳排放量在100以上的用户</p>\n<p>1)按照用户ID及时间字段分组,计算每个用户单日减少的碳排放量</p>\n<p>select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>sum(lowcarbon) lowcarbon</p>\n<p>from test1</p>\n<p>group by id,dt</p>\n<p>having lowcarbon&gt;100;t1</p>\n<p>1001 2021-12-12 123</p>\n<p>1001 2021-12-13 111</p>\n<p>1001 2021-12-14 230</p>\n<p>等差数列法:两个等差数列如果等差相同,则相同位置的数据相减等到的结果相同</p>\n<p>2)按照用户分组,同时按照时间排序,计算每条数据的Rank值</p>\n<p>select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>lowcarbon,</p>\n<p>rank() over(partition by id order by dt) rk</p>\n<p>from t1;t2</p>\n<p>3)将每行数据中的日期减去Rank值</p>\n<p>select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>lowcarbon,</p>\n<p>date_sub(dt,rk) flag</p>\n<p>from t2;t3</p>\n<p>4)按照用户及Flag分组,求每个组有多少条数据,并找出大于等于3条的数据</p>\n<p>select</p>\n<p>id,</p>\n<p>flag,</p>\n<p>count(*) ct</p>\n<p>from t3</p>\n<p>group by id,flag</p>\n<p>having ct&gt;&#x3D;3;</p>\n<p>5)最终HQL</p>\n<p>select</p>\n<p>id,</p>\n<p>flag,</p>\n<p>count(*) ct</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>lowcarbon,</p>\n<p>date_sub(dt,rk) flag</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>lowcarbon,</p>\n<p>rank() over(partition by id order by dt) rk</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>sum(lowcarbon) lowcarbon</p>\n<p>from test1</p>\n<p>group by id,dt</p>\n<p>having lowcarbon&gt;100)t1)t2)t3</p>\n<p>group by id,flag</p>\n<p>having ct&gt;&#x3D;3;</p>\n<h3 id=\"9-3-13-分组问题\"><a href=\"#9-3-13-分组问题\" class=\"headerlink\" title=\"9.3.13 分组问题\"></a>9.3.13 分组问题</h3><p>如下为电商公司用户访问时间数据</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>id ts(秒)</p>\n<p>1001 17523641234</p>\n<p>1001 17523641256</p>\n<p>1002 17523641278</p>\n<p>1001 17523641334</p>\n<p>1002 17523641434</p>\n<p>1001 17523641534</p>\n<p>1001 17523641544</p>\n<p>1002 17523641634</p>\n<p>1001 17523641638</p>\n<p>1001 17523641654</p></blockquote>\n<p>某个用户连续的访问记录如果时间间隔小于60秒，则分为同一个组，结果为：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>id ts(秒) group</p>\n<p>1001 17523641234 1</p>\n<p>1001 17523641256 1</p>\n<p>1001 17523641334 2</p>\n<p>1001 17523641534 3</p>\n<p>1001 17523641544 3</p>\n<p>1001 17523641638 4</p>\n<p>1001 17523641654 4</p>\n<p>1002 17523641278 1</p>\n<p>1002 17523641434 2</p>\n<p>1002 17523641634 3</p></blockquote>\n<p>1)将上一行时间数据下移</p>\n<p>lead:领导</p>\n<p>lag:延迟</p>\n<p>select</p>\n<p>id,</p>\n<p>ts,</p>\n<p>lag(ts,1,0) over(partition by id order by ts) lagts</p>\n<p>from</p>\n<p>test2;t1</p>\n<p>1001 17523641234 0</p>\n<p>1001 17523641256 17523641234</p>\n<p>1001 17523641334 17523641256</p>\n<p>1001 17523641534 17523641334</p>\n<p>1001 17523641544 17523641534</p>\n<p>1001 17523641638 17523641544</p>\n<p>1001 17523641654 17523641638</p>\n<p>1002 17523641278 0</p>\n<p>1002 17523641434 17523641278</p>\n<p>1002 17523641634 17523641434</p>\n<p>2)将当前行时间数据减去上一行时间数据</p>\n<p>select</p>\n<p>id,</p>\n<p>ts,</p>\n<p>ts-lagts tsdiff</p>\n<p>from</p>\n<p>t1;t2</p>\n<p>select</p>\n<p>id,</p>\n<p>ts,</p>\n<p>ts-lagts tsdiff</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>ts,</p>\n<p>lag(ts,1,0) over(partition by id order by ts) lagts</p>\n<p>from</p>\n<p>test2)t1;t2</p>\n<p>1001 17523641234 17523641234</p>\n<p>1001 17523641256 22</p>\n<p>1001 17523641334 78</p>\n<p>1001 17523641534 200</p>\n<p>1001 17523641544 10</p>\n<p>1001 17523641638 94</p>\n<p>1001 17523641654 16</p>\n<p>1002 17523641278 17523641278</p>\n<p>1002 17523641434 156</p>\n<p>1002 17523641634 200</p>\n<p>3)计算每个用户范围内从第一行到当前行tsdiff大于等于60的总个数(分组号)</p>\n<p>select</p>\n<p>id,</p>\n<p>ts,</p>\n<p>sum(if(tsdiff&gt;&#x3D;60,1,0)) over(partition by id order by ts) groupid</p>\n<p>from</p>\n<p>t2;</p>\n<p>4)最终HQL</p>\n<p>select</p>\n<p>id,</p>\n<p>ts,</p>\n<p>sum(if(tsdiff&gt;&#x3D;60,1,0)) over(partition by id order by ts) groupid</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>ts,</p>\n<p>ts-lagts tsdiff</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>ts,</p>\n<p>lag(ts,1,0) over(partition by id order by ts) lagts</p>\n<p>from</p>\n<p>test2)t1)t2;</p>\n<h3 id=\"9-3-14-间隔连续问题\"><a href=\"#9-3-14-间隔连续问题\" class=\"headerlink\" title=\"9.3.14 间隔连续问题\"></a>9.3.14 间隔连续问题</h3><p>某游戏公司记录的用户每日登录数据</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>id dt</p>\n<p>1001 2021-12-12</p>\n<p>1002 2021-12-12</p>\n<p>1001 2021-12-13</p>\n<p>1001 2021-12-14</p>\n<p>1001 2021-12-16</p>\n<p>1002 2021-12-16</p>\n<p>1001 2021-12-19</p>\n<p>1002 2021-12-17</p>\n<p>1001 2021-12-20</p></blockquote>\n<p>计算每个用户最大的连续登录天数，可以间隔一天。解释：如果一个用户在1,3,5,6登录游戏，则视为连续6天登录。</p>\n<p>思路一：等差数列</p>\n<p>1001 2021-12-12 1</p>\n<p>1001 2021-12-13 2</p>\n<p>1001 2021-12-14 3</p>\n<p>1001 2021-12-16 4</p>\n<p>1001 2021-12-19 5</p>\n<p>1001 2021-12-20 6</p>\n<p>1001 2021-12-12 1 2021-12-11</p>\n<p>1001 2021-12-13 2 2021-12-11</p>\n<p>1001 2021-12-14 3 2021-12-11</p>\n<p>1001 2021-12-16 4 2021-12-12</p>\n<p>1001 2021-12-19 5 2021-12-14</p>\n<p>1001 2021-12-20 6 2021-12-14</p>\n<p>1001 2021-12-11 3</p>\n<p>1001 2021-12-12 1</p>\n<p>1001 2021-12-14 1</p>\n<p>1001 2021-12-11 3 1</p>\n<p>1001 2021-12-12 1 2</p>\n<p>1001 2021-12-14 1 3</p>\n<p>1001 2021-12-11 3 1 2021-12-10</p>\n<p>1001 2021-12-12 1 2 2021-12-10</p>\n<p>1001 2021-12-14 1 3 2021-12-11</p>\n<p>思路二：分组</p>\n<p>1001 2021-12-12</p>\n<p>1001 2021-12-13</p>\n<p>1001 2021-12-14</p>\n<p>1001 2021-12-16</p>\n<p>1001 2021-12-19</p>\n<p>1001 2021-12-20</p>\n<p>1)将上一行时间数据下移</p>\n<p>1001 2021-12-12 1970-01-01</p>\n<p>1001 2021-12-13 2021-12-12</p>\n<p>1001 2021-12-14 2021-12-13</p>\n<p>1001 2021-12-16 2021-12-14</p>\n<p>1001 2021-12-19 2021-12-16</p>\n<p>1001 2021-12-20 2021-12-19</p>\n<p>select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>lag(dt,1,’1970-01-01’) over(partition by id order by dt) lagdt</p>\n<p>from</p>\n<p>test3;t1</p>\n<p>2)将当前行时间减去上一行时间数据(datediff(dt1,dt2))</p>\n<p>1001 2021-12-12 564564</p>\n<p>1001 2021-12-13 1</p>\n<p>1001 2021-12-14 1</p>\n<p>1001 2021-12-16 2</p>\n<p>1001 2021-12-19 3</p>\n<p>1001 2021-12-20 1</p>\n<p>select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>datediff(dt,lagdt) flag</p>\n<p>from</p>\n<p>t1;t2</p>\n<p>3)按照用户分组,同时按照时间排序,计算从第一行到当前行大于2的数据的总条数(sum(if(flag&gt;2,1,0)))</p>\n<p>1001 2021-12-12 1</p>\n<p>1001 2021-12-13 1</p>\n<p>1001 2021-12-14 1</p>\n<p>1001 2021-12-16 1</p>\n<p>1001 2021-12-19 2</p>\n<p>1001 2021-12-20 2</p>\n<p>select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>sum(if(flag&gt;2,1,0)) over(partition by id order by dt) flag</p>\n<p>from</p>\n<p>t2;t3</p>\n<p>4)按照用户和flag分组,求最大时间减去最小时间并加上1</p>\n<p>select</p>\n<p>id,</p>\n<p>flag,</p>\n<p>datediff(max(dt),min(dt)) days</p>\n<p>from</p>\n<p>t3</p>\n<p>group by id,flag;t4</p>\n<p>5)取连续登录天数的最大值</p>\n<p>select</p>\n<p>id,</p>\n<p>max(days)+1</p>\n<p>from</p>\n<p>t4</p>\n<p>group by id;</p>\n<p>6)最终HQL</p>\n<p>select</p>\n<p>id,</p>\n<p>max(days)+1</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>flag,</p>\n<p>datediff(max(dt),min(dt)) days</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>sum(if(flag&gt;2,1,0)) over(partition by id order by dt) flag</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>datediff(dt,lagdt) flag</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>lag(dt,1,’1970-01-01’) over(partition by id order by dt) lagdt</p>\n<p>from</p>\n<p>test3)t1)t2)t3</p>\n<p>group by id,flag)t4</p>\n<p>group by id;</p>\n<h3 id=\"9-3-15-打折日期交叉问题\"><a href=\"#9-3-15-打折日期交叉问题\" class=\"headerlink\" title=\"9.3.15 打折日期交叉问题\"></a>9.3.15 打折日期交叉问题</h3><p>如下为平台商品促销数据：字段为品牌，打折开始日期，打折结束日期</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>brand stt edt</p>\n<p>oppo 2021-06-05 2021-06-09</p>\n<p>oppo 2021-06-11 2021-06-21</p>\n<p>vivo 2021-06-05 2021-06-15</p>\n<p>vivo 2021-06-09 2021-06-21</p>\n<p>redmi 2021-06-05 2021-06-21</p>\n<p>redmi 2021-06-09 2021-06-15</p>\n<p>redmi 2021-06-17 2021-06-26</p>\n<p>huawei 2021-06-05 2021-06-26</p>\n<p>huawei 2021-06-09 2021-06-15</p>\n<p>huawei 2021-06-17 2021-06-21</p></blockquote>\n<p>计算每个品牌总的打折销售天数，注意其中的交叉日期，比如vivo品牌，第一次活动时间为2021-06-05到2021-06-15，第二次活动时间为2021-06-09到2021-06-21其中9号到15号为重复天数，只统计一次，即vivo总打折天数为2021-06-05到2021-06-21共计17天。</p>\n<p>1)将当前行以前的数据中最大的edt放置当前行</p>\n<p>select</p>\n<p>id,</p>\n<p>stt,</p>\n<p>edt,</p>\n<p>max(edt) over(partition by id order by stt rows between UNBOUNDED<br>PRECEDING and 1 PRECEDING) maxEdt</p>\n<p>from test4;t1</p>\n<p>redmi 2021-06-05 2021-06-21 null</p>\n<p>redmi 2021-06-09 2021-06-15 2021-06-21</p>\n<p>redmi 2021-06-17 2021-06-26 2021-06-21</p>\n<p>2)比较开始时间与移动下来的数据,如果开始时间大,则不需要操作,</p>\n<p>反之则需要将移动下来的数据加一替换当前行的开始时间</p>\n<p>如果是第一行数据,maxEDT为null,则不需要操作</p>\n<p>select</p>\n<p>id,</p>\n<p>if(maxEdt is null,stt,if(stt&gt;maxEdt,stt,date_add(maxEdt,1))) stt,</p>\n<p>edt</p>\n<p>from t1;t2</p>\n<p>redmi 2021-06-05 2021-06-21</p>\n<p>redmi 2021-06-22 2021-06-15</p>\n<p>redmi 2021-06-22 2021-06-26</p>\n<p>3)将每行数据中的结束日期减去开始日期</p>\n<p>select</p>\n<p>id,</p>\n<p>datediff(edt,stt) days</p>\n<p>from</p>\n<p>t2;t3</p>\n<p>redmi 16</p>\n<p>redmi -4</p>\n<p>redmi 4</p>\n<p>4)按照品牌分组,计算每条数据加一的总和</p>\n<p>select</p>\n<p>id,</p>\n<p>sum(if(days&gt;&#x3D;0,days+1,0)) days</p>\n<p>from</p>\n<p>t3</p>\n<p>group by id;</p>\n<p>redmi 22</p>\n<p>5)最终HQL</p>\n<p>select</p>\n<p>id,</p>\n<p>sum(if(days&gt;&#x3D;0,days+1,0)) days</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>datediff(edt,stt) days</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>if(maxEdt is null,stt,if(stt&gt;maxEdt,stt,date_add(maxEdt,1))) stt,</p>\n<p>edt</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>stt,</p>\n<p>edt,</p>\n<p>max(edt) over(partition by id order by stt rows between UNBOUNDED<br>PRECEDING and 1 PRECEDING) maxEdt</p>\n<p>from test4)t1)t2)t3</p>\n<p>group by id;</p>\n<h3 id=\"9-3-16-同时在线问题\"><a href=\"#9-3-16-同时在线问题\" class=\"headerlink\" title=\"9.3.16 同时在线问题\"></a>9.3.16 同时在线问题</h3><p>如下为某直播平台主播开播及关播时间，根据该数据计算出平台最高峰同时在线的主播人数。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>id stt edt</p>\n<p>1001 2021-06-14 12:12:12 2021-06-14 18:12:12</p>\n<p>1003 2021-06-14 13:12:12 2021-06-14 16:12:12</p>\n<p>1004 2021-06-14 13:15:12 2021-06-14 20:12:12</p>\n<p>1002 2021-06-14 15:12:12 2021-06-14 16:12:12</p>\n<p>1005 2021-06-14 15:18:12 2021-06-14 20:12:12</p>\n<p>1001 2021-06-14 20:12:12 2021-06-14 23:12:12</p>\n<p>1006 2021-06-14 21:12:12 2021-06-14 23:15:12</p>\n<p>1007 2021-06-14 22:12:12 2021-06-14 23:10:12</p>\n<p>… …</p></blockquote>\n<p>1)对数据分类,在开始数据后添加正1,表示有主播上线,同时在关播数据后添加-1,表示有主播下线</p>\n<p>select id,stt dt,1 p from test5</p>\n<p>union</p>\n<p>select id,edt dt,-1 p from test5;t1</p>\n<p>1001 2021-06-14 12:12:12 1</p>\n<p>1001 2021-06-14 18:12:12 -1</p>\n<p>1001 2021-06-14 20:12:12 1</p>\n<p>1001 2021-06-14 23:12:12 -1</p>\n<p>1002 2021-06-14 15:12:12 1</p>\n<p>1002 2021-06-14 16:12:12 -1</p>\n<p>1003 2021-06-14 13:12:12 1</p>\n<p>1003 2021-06-14 16:12:12 -1</p>\n<p>1004 2021-06-14 13:15:12 1</p>\n<p>1004 2021-06-14 20:12:12 -1</p>\n<p>1005 2021-06-14 15:18:12 1</p>\n<p>1005 2021-06-14 20:12:12 -1</p>\n<p>1006 2021-06-14 21:12:12 1</p>\n<p>1006 2021-06-14 23:15:12 -1</p>\n<p>1007 2021-06-14 22:12:12 1</p>\n<p>1007 2021-06-14 23:10:12 -1</p>\n<p>2)按照时间排序,计算累加人数</p>\n<p>select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>sum(p) over(order by dt) sum_p</p>\n<p>from</p>\n<p>(select id,stt dt,1 p from test5</p>\n<p>union</p>\n<p>select id,edt dt,-1 p from test5)t1;t2</p>\n<p>3)找出同时在线人数最大值</p>\n<p>select</p>\n<p>max(sum_p)</p>\n<p>from</p>\n<p>(select</p>\n<p>id,</p>\n<p>dt,</p>\n<p>sum(p) over(order by dt) sum_p</p>\n<p>from</p>\n<p>(select id,stt dt,1 p from test5</p>\n<p>union</p>\n<p>select id,edt dt,-1 p from test5)t1)t2;</p>\n<h1 id=\"第10章-JavaSE\"><a href=\"#第10章-JavaSE\" class=\"headerlink\" title=\"第10章 JavaSE\"></a>第10章 JavaSE</h1><h2 id=\"10-1-HashMap底层源码，数据结构\"><a href=\"#10-1-HashMap底层源码，数据结构\" class=\"headerlink\" title=\"10.1 HashMap底层源码，数据结构\"></a>10.1 HashMap底层源码，数据结构</h2><p>hashMap的底层结构在jdk1.7中由数组+链表实现，在jdk1.8中由数组+链表+红黑树实现，以数组+链表的结构为例。</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image125.png\">{width&#x3D;”5.761805555555555in”<br>height&#x3D;”2.2090277777777776in”}</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image126.png\">{width&#x3D;”5.7659722222222225in”<br>height&#x3D;”3.183333333333333in”}</p>\n<p><strong>JDK1.8之前Put方法：</strong></p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image127.png\">{width&#x3D;”5.405555555555556in”<br>height&#x3D;”5.988888888888889in”}</p>\n<p><strong>JDK1.8之后Put方法：</strong></p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image128.png\">{width&#x3D;”5.708333333333333in”<br>height&#x3D;”7.023611111111111in”}</p>\n<h2 id=\"10-2-Java自带哪几种线程池？\"><a href=\"#10-2-Java自带哪几种线程池？\" class=\"headerlink\" title=\"10.2 Java自带哪几种线程池？\"></a>10.2 Java自带哪几种线程池？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>1）newCachedThreadPool</strong></p></blockquote>\n<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：</p>\n<p>工作线程的创建数量几乎没有限制（其实也有限制的，数目为Interger.<br>MAX_VALUE）, 这样可灵活的往线程池中添加线程。</p>\n<p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为1分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p>\n<p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>2）newFixedThreadPool</strong></p></blockquote>\n<p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>3）newSingleThreadExecutor</strong></p></blockquote>\n<p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO,<br>LIFO,<br>优先级）执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>4）newScheduleThreadPool</strong></p></blockquote>\n<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。延迟3秒执行。</p>\n<h2 id=\"10-3-HashMap和HashTable区别\"><a href=\"#10-3-HashMap和HashTable区别\" class=\"headerlink\" title=\"10.3 HashMap和HashTable区别\"></a>10.3 HashMap和HashTable区别</h2><ol>\n<li>线程安全性不同</li>\n</ol>\n<p>HashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTabl，但是使用HashMap时必须自己增加同步处理。</p>\n<ol start=\"2\">\n<li>是否提供contains方法</li>\n</ol>\n<p>HashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。</p>\n<ol start=\"3\">\n<li>key和value是否允许null值</li>\n</ol>\n<p>Hashtable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p>\n<ol start=\"4\">\n<li>数组初始化和扩容机制</li>\n</ol>\n<p> HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</p>\n<p> Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</p>\n<h2 id=\"10-4-TreeSet和HashSet区别\"><a href=\"#10-4-TreeSet和HashSet区别\" class=\"headerlink\" title=\"10.4 TreeSet和HashSet区别\"></a>10.4 TreeSet和HashSet区别</h2><p>HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。</p>\n<p>TreeSet是采用树结构实现（红黑树算法）。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log<br>(n))的方法。它还提供了一些方法来处理排序的set，如first()，last()，headSet()，tailSet()等等。</p>\n<h2 id=\"10-5-String-buffer和String-build区别\"><a href=\"#10-5-String-buffer和String-build区别\" class=\"headerlink\" title=\"10.5 String buffer和String build区别\"></a>10.5 String buffer和String build区别</h2><p>1、StringBuffer与StringBuilder中的方法和功能完全是等价的。</p>\n<p>2、只是StringBuffer中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而StringBuilder没有这个修饰，可以被认为是线程不安全的。 </p>\n<p>3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低</p>\n<h2 id=\"10-6-Final、Finally、Finalize\"><a href=\"#10-6-Final、Finally、Finalize\" class=\"headerlink\" title=\"10.6 Final、Finally、Finalize\"></a>10.6 Final、Finally、Finalize</h2><p>final：修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。</p>\n<p>finally：通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。</p>\n<p>finalize：Object类中定义的方法，Java中允许使用finalize()<br>方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()<br>方法可以整理系统资源或者执行其他清理工作。</p>\n<h2 id=\"10-7-x3D-x3D-和Equals区别\"><a href=\"#10-7-x3D-x3D-和Equals区别\" class=\"headerlink\" title=\"10.7 &#x3D;&#x3D;和Equals区别\"></a>10.7 &#x3D;&#x3D;和Equals区别</h2><p> &#x3D;&#x3D; : 如果比较的是基本数据类型，那么比较的是变量的值</p>\n<p>如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）</p>\n<p> equals:如果没重写equals方法比较的是两个对象的地址值。</p>\n<p> 如果重写了equals方法后我们往往比较的是对象中的属性的内容</p>\n<p>equals方法是从Object类中继承的，默认的实现就是使用&#x3D;&#x3D;</p>\n<p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image129.png\">{width&#x3D;”4.454861111111111in”<br>height&#x3D;”0.6979166666666666in”}</p>\n<h1 id=\"第11章-Redis\"><a href=\"#第11章-Redis\" class=\"headerlink\" title=\"第11章 Redis\"></a>第11章 Redis</h1><h2 id=\"11-1-缓存穿透、缓存雪崩、缓存击穿\"><a href=\"#11-1-缓存穿透、缓存雪崩、缓存击穿\" class=\"headerlink\" title=\"11.1 缓存穿透、缓存雪崩、缓存击穿\"></a>11.1 缓存穿透、缓存雪崩、缓存击穿</h2><p>1）缓存穿透是指查询一个一定不存在的数据。由于缓存命不中时会去查询数据库，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>\n<p>解决方案：</p>\n<ol>\n<li>是将空对象也缓存起来，并给它设置一个很短的过期时间，最长不超过5分钟</li>\n</ol>\n<p>②<br>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</p>\n<p>2）如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就会造成缓存雪崩。</p>\n<p>解决方案：</p>\n<p>尽量让失效的时间点不分布在同一个时间点</p>\n<p>3）缓存击穿，是指一个key非常热点，在不停的扛着大并发，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<p>解决方案：</p>\n<p>可以设置key永不过期</p>\n<h2 id=\"11-2-哨兵模式\"><a href=\"#11-2-哨兵模式\" class=\"headerlink\" title=\"11.2 哨兵模式\"></a>11.2 哨兵模式</h2><p>主从复制中反客为主的自动版，如果主机Down掉，哨兵会从从机中选择一台作为主机，并将它设置为其他从机的主机，而且如果原来的主机再次启动的话也会成为从机。</p>\n<h2 id=\"10-3-数据类型\"><a href=\"#10-3-数据类型\" class=\"headerlink\" title=\"10.3 数据类型\"></a>10.3 数据类型</h2><hr>\n<p>  string              字符串<br>  list                可以重复的集合<br>  set                 不可以重复的集合<br>  hash                类似于Map&lt;String,String&gt;<br>  zset(sorted set）   带分数的set</p>\n<hr>\n<h2 id=\"11-4-持久化\"><a href=\"#11-4-持久化\" class=\"headerlink\" title=\"11.4 持久化\"></a>11.4 持久化</h2><p><strong>1）RDB持久化：</strong></p>\n<ol>\n<li><p><strong>在指定的时间间隔内持久化</strong></p>\n</li>\n<li><p><strong>服务shutdown会自动持久化</strong></p>\n</li>\n</ol>\n<p><strong>③ 输入bgsave也会持久化</strong></p>\n<p><strong>2）AOF : 以日志形式记录每个更新操作</strong></p>\n<p>Redis重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。</p>\n<p><strong>保存策略：</strong></p>\n<p>推荐（并且也是默认）的措施为每秒持久化一次，这种策略可以兼顾速度和安全性。</p>\n<p><strong>缺点：</strong></p>\n<p>1 比起RDB占用更多的磁盘空间</p>\n<p>2 恢复备份速度要慢</p>\n<p>3 每次读写都同步的话，有一定的性能压力</p>\n<p>4 存在个别Bug，造成恢复不能</p>\n<p><strong>选择策略：</strong></p>\n<p>官方推荐：</p>\n<p>如果对数据不敏感，可以选单独用RDB；不建议单独用AOF，因为可能出现Bug;如果只是做纯内存缓存，可以都不用</p>\n<h2 id=\"11-5-悲观锁\"><a href=\"#11-5-悲观锁\" class=\"headerlink\" title=\"11.5 悲观锁\"></a>11.5 悲观锁</h2><p>执行操作前假设当前的操作肯定（或有很大几率）会被打断（悲观）。基于这个假设，我们在做操作前就会把相关资源锁定，不允许自己执行期间有其他操作干扰。</p>\n<h2 id=\"11-6-乐观锁\"><a href=\"#11-6-乐观锁\" class=\"headerlink\" title=\"11.6 乐观锁\"></a>11.6 乐观锁</h2><p>执行操作前假设当前操作不会被打断（乐观）。基于这个假设，我们在做操作前不会锁定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。Redis使用的就是乐观锁。</p>\n<h1 id=\"第12章-MySql\"><a href=\"#第12章-MySql\" class=\"headerlink\" title=\"第12章 MySql\"></a>第12章 MySql</h1><h2 id=\"12-1-MyISAM与InnoDB的区别\"><a href=\"#12-1-MyISAM与InnoDB的区别\" class=\"headerlink\" title=\"12.1 MyISAM与InnoDB的区别\"></a>12.1 MyISAM与InnoDB的区别</h2><p>+———————–+———————–+———————–+<br>| <strong>对比项</strong>            | <strong>MyISAM</strong>            | <strong>InnoDB</strong>            |<br>+———————–+———————–+———————–+<br>| <strong>外键</strong>              | <strong>不支持</strong>            | <strong>支持</strong>              |<br>+———————–+———————–+———————–+<br>| <strong>事务</strong>              | <strong>不支持</strong>            | <strong>支持</strong>              |<br>+———————–+———————–+———————–+<br>| <strong>行表锁</strong>            | <strong>表锁，即使操作一条记录也会锁住整个表， | <strong>行锁,操作时只锁某一行，不对其它行有影 |<br>|                       | 不适合高并发的操作</strong>  | 响，</strong>                |<br>|                       |                       |                       |<br>|                       |                       | <strong>适合高并发的操作</strong>  |<br>+———————–+———————–+———————–+<br>| <strong>缓存</strong>              | <strong>只缓存索引，不缓存真实数据</strong> | *<em>不仅缓存索引还要缓存真实数据，对内存要 |<br>|                       |                       | 求较高，而且内存大小对性能有决定性的影响</em> |<br>|                       |                       | *                     |<br>+———————–+———————–+———————–+</p>\n<h2 id=\"12-2-索引优化\"><a href=\"#12-2-索引优化\" class=\"headerlink\" title=\"12.2 索引优化\"></a>12.2 索引优化</h2><p><strong>数据结构：B+Tree</strong></p>\n<p>一般来说能够达到range就可以算是优化了 idx name_deptId</p>\n<p><strong>口诀（两个法则加6种索引失效的情况）</strong></p>\n<p>全值匹配我最爱，最左前缀要遵守；</p>\n<p>带头大哥不能死，中间兄弟不能断；</p>\n<p>索引列上少计算，范围之后全失效；</p>\n<p>LIKE百分写最右，覆盖索引不写*；</p>\n<p>不等空值还有OR，索引影响要注意；</p>\n<p>VAR引号不可丢，SQL优化有诀窍。</p>\n<h2 id=\"12-3-b-tree和b-tree的区别\"><a href=\"#12-3-b-tree和b-tree的区别\" class=\"headerlink\" title=\"12.3 b-tree和b+tree的区别\"></a>12.3 b-tree和b+tree的区别</h2><ol>\n<li><p>B-树的关键字、索引和记录是放在一起的，<br>B+树的[非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。]{.underline}</p>\n</li>\n<li><p>在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中[每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。]{.underline}</p>\n</li>\n</ol>\n<h2 id=\"12-4-redis是单线程的，为什么那么快\"><a href=\"#12-4-redis是单线程的，为什么那么快\" class=\"headerlink\" title=\"12.4 redis是单线程的，为什么那么快\"></a>12.4 redis是单线程的，为什么那么快</h2><p>1)完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。</p>\n<p>2)数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的</p>\n<p>3)采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗<br>CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</p>\n<p>4)使用多路I&#x2F;O复用模型，非阻塞IO</p>\n<p>5)使用[底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM<br>机制<br>，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求]{.underline}</p>\n<h2 id=\"12-5-MySQL的事务\"><a href=\"#12-5-MySQL的事务\" class=\"headerlink\" title=\"12.5 MySQL的事务\"></a>12.5 MySQL的事务</h2><p><strong>一、事务的基本要素（ACID）</strong></p>\n<p>1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位</p>\n<p>2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏<br>。比如A向B转账，不可能A扣了钱，B却没收到。</p>\n<p>3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>\n<p>4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>\n<p><strong>二、事务的并发问题</strong></p>\n<p>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>\n<p>2、不可重复读：事务 A 多次读取同一数据，事务 B<br>在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果<br>不一致</p>\n<p>3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>\n<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>\n<p><strong>三、MySQL事务隔离级别</strong></p>\n<p>事务隔离级别 脏读 不可重复读 幻读</p>\n<p>读未提交（read-uncommitted） 是 是 是</p>\n<p>不可重复读（read-committed） 否 是 是</p>\n<p>可重复读（repeatable-read） 否 否 是</p>\n<p>串行化（serializable） 否 否 否</p>\n<h1 id=\"第13章-JVM\"><a href=\"#第13章-JVM\" class=\"headerlink\" title=\"第13章 JVM\"></a>第13章 JVM</h1><h2 id=\"13-1-JVM内存分哪几个区，每个区的作用是什么\"><a href=\"#13-1-JVM内存分哪几个区，每个区的作用是什么\" class=\"headerlink\" title=\"13.1 JVM内存分哪几个区，每个区的作用是什么?\"></a>13.1 JVM内存分哪几个区，每个区的作用是什么?</h2><p><img src=\"http://cache.itzy8.top/sgg%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/image130.png\">{width&#x3D;”5.458333333333333in”<br>height&#x3D;”4.927083333333333in”}</p>\n<p>java虚拟机主要分为以下几个区:</p>\n<ol>\n<li><strong>方法区</strong>：</li>\n</ol>\n<!-- -->\n\n<p>a.  有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载</p>\n<p>b.  方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。</p>\n<p>c.  该区域是被线程共享的。</p>\n<p>d.  方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。</p>\n<!-- -->\n\n<ol start=\"2\">\n<li><strong>虚拟机栈</strong>:</li>\n</ol>\n<!-- -->\n\n<p>a.  虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p>\n<p>b.  虚拟机栈是线程私有的，它的生命周期与线程相同。</p>\n<p>c.  局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p>\n<p>d.  操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p>\n<p>e.  每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p>\n<!-- -->\n\n<ol start=\"3\">\n<li><p><strong>本地方法栈</strong>：<br>本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。</p>\n</li>\n<li><p><strong>堆</strong>：</p>\n</li>\n</ol>\n<p>java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。</p>\n<ol start=\"5\">\n<li><strong>程序计数器：</strong></li>\n</ol>\n<p>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。</p>\n<h2 id=\"13-2-Java类加载过程\"><a href=\"#13-2-Java类加载过程\" class=\"headerlink\" title=\"13.2 Java类加载过程?\"></a>13.2 Java类加载过程?</h2><p>Java类加载需要经历一下几个过程：</p>\n<ol>\n<li>加载</li>\n</ol>\n<p>加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：</p>\n<p>a.  通过一个类的全限定名获取该类的二进制流。</p>\n<p>b.  将该二进制流中的静态存储结构转化为方法去运行时数据结构。 </p>\n<p>c.  在内存中生成该类的Class对象，作为该类的数据访问入口。</p>\n<!-- -->\n\n<ol start=\"2\">\n<li>验证</li>\n</ol>\n<p>验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:</p>\n<p>a.  文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</p>\n<p>b.  元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</p>\n<p>c.  字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</p>\n<p>d.  符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</p>\n<p>e.  准备</p>\n<p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>\n<ol start=\"3\">\n<li>解析</li>\n</ol>\n<p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</p>\n<ol start=\"4\">\n<li>初始化</li>\n</ol>\n<p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p>\n<h2 id=\"13-3-java中垃圾收集的方法有哪些\"><a href=\"#13-3-java中垃圾收集的方法有哪些\" class=\"headerlink\" title=\"13.3 java中垃圾收集的方法有哪些?\"></a>13.3 java中垃圾收集的方法有哪些?</h2><p><strong>1）引用计数法</strong>   应用于：微软的COM&#x2F;ActionScrip3&#x2F;Python等</p>\n<p>a) 如果对象没有被引用，就会被回收，缺点：需要维护一个引用计算器</p>\n<p><strong>2）复制算法</strong> 年轻代中使用的是Minor<br>GC，这种GC算法采用的是复制算法(Copying)</p>\n<p>a) 效率高，缺点：需要内存容量大，比较耗内存</p>\n<p>b) 使用在占空间比较小、刷新次数多的新生区</p>\n<p><strong>3）标记清除</strong> 老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p>\n<p>a) 效率比较低，会差生碎片。</p>\n<p><strong>4）标记压缩</strong> 老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p>\n<p>a) 效率低速度慢，需要移动对象，但不会产生碎片。</p>\n<p><strong>5）标记清除压缩</strong>标记清除-标记压缩的集合，多次GC后才Compact</p>\n<p>a) 使用于占空间大刷新次数少的养老区，是3 4的集合体</p>\n<h2 id=\"13-4-如何判断一个对象是否存活-或者GC对象的判定方法\"><a href=\"#13-4-如何判断一个对象是否存活-或者GC对象的判定方法\" class=\"headerlink\" title=\"13.4 如何判断一个对象是否存活?(或者GC对象的判定方法)\"></a>13.4 如何判断一个对象是否存活?(或者GC对象的判定方法)</h2><p>判断一个对象是否存活有两种方法:</p>\n<ol>\n<li><p>引用计数法</p>\n</li>\n<li><p>可达性算法(引用链法)</p>\n</li>\n</ol>\n<h2 id=\"13-5-什么是类加载器，类加载器有哪些\"><a href=\"#13-5-什么是类加载器，类加载器有哪些\" class=\"headerlink\" title=\"13.5 什么是类加载器，类加载器有哪些?\"></a>13.5 什么是类加载器，类加载器有哪些?</h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p>\n<p>主要有一下四种类加载器:</p>\n<ol>\n<li><p>启动类加载器(Bootstrap<br>ClassLoader)用来加载java核心类库，无法被java程序直接引用。</p>\n</li>\n<li><p>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java<br>虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载<br>Java 类。</p>\n</li>\n<li><p>系统类加载器（system class loader）也叫应用类加载器：它根据 Java<br>应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java<br>应用的类都是由它来完成加载的。可以通过<br>ClassLoader.getSystemClassLoader()来获取它。</p>\n</li>\n<li><p>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</p>\n</li>\n</ol>\n<h2 id=\"13-6-简述Java内存分配与回收策略以及Minor-GC和Major-GC（full-GC）\"><a href=\"#13-6-简述Java内存分配与回收策略以及Minor-GC和Major-GC（full-GC）\" class=\"headerlink\" title=\"13.6 简述Java内存分配与回收策略以及Minor GC和Major GC（full GC）\"></a>13.6 简述Java内存分配与回收策略以及Minor GC和Major GC（full GC）</h2><p><strong>内存分配：</strong></p>\n<ol>\n<li><p><strong>栈区</strong>：栈分为java虚拟机栈和本地方法栈</p>\n</li>\n<li><p><strong>堆区</strong>：堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From<br>survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比<br>8:1:1。</p>\n</li>\n<li><p><strong>方法区</strong>：被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment<br>generation）</p>\n</li>\n<li><p><strong>程序计数器</strong>：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。线程私有的。</p>\n</li>\n</ol>\n<p><strong>回收策略以及Minor GC和Major GC：</strong></p>\n<ol>\n<li><p>对象优先在堆的Eden区分配。</p>\n</li>\n<li><p>大对象直接进入老年代。</p>\n</li>\n<li><p>长期存活的对象将直接进入老年代。</p>\n</li>\n</ol>\n<p>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor<br>GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full<br>Gc&#x2F;Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor<br>GC,但是通过配置，可以在Full GC之前进行一次Minor<br>GC这样可以加快老年代的回收速度。</p>\n<h1 id=\"第14章-JUC\"><a href=\"#第14章-JUC\" class=\"headerlink\" title=\"第14章 JUC\"></a>第14章 JUC</h1><p><strong>14.1 Synchronized与Lock的区别</strong></p>\n<p>1）Synchronized能实现的功能Lock都可以实现，而且Lock比Synchronized更好用，更灵活。</p>\n<p>2）Synchronized可以自动上锁和解锁；Lock需要手动上锁和解锁</p>\n<p><strong>14.2 Runnable和Callable的区别</strong></p>\n<p>1）Runnable接口中的方法没有返回值；Callable接口中的方法有返回值</p>\n<p>2）Runnable接口中的方法没有抛出异常；Callable接口中的方法抛出了异常</p>\n<p>3）Runnable接口中的落地方法是call方法；Callable接口中的落地方法是run方法</p>\n<p><strong>14.3 什么是分布式锁</strong></p>\n<p>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如<br>Redis，通过set (key,value,nx,px,timeout)方法添加分布式锁。</p>\n<p><strong>14.4 什么是分布式事务</strong></p>\n<p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p>\n<h1 id=\"第15章-面试说明\"><a href=\"#第15章-面试说明\" class=\"headerlink\" title=\"第15章 面试说明\"></a>第15章 面试说明</h1><h2 id=\"15-1-面试过程最关键的是什么？\"><a href=\"#15-1-面试过程最关键的是什么？\" class=\"headerlink\" title=\"15.1 面试过程最关键的是什么？\"></a>15.1 面试过程最关键的是什么？</h2><p>1）大大方方的聊，放松</p>\n<p>2）体现优势，避免劣势</p>\n<h2 id=\"15-2-面试时该怎么说？\"><a href=\"#15-2-面试时该怎么说？\" class=\"headerlink\" title=\"15.2 面试时该怎么说？\"></a>15.2 面试时该怎么说？</h2><p>1）语言表达清楚</p>\n<p>（1）思维逻辑清晰，表达流畅</p>\n<p>（2）一二三层次表达</p>\n<p>2）所述内容不犯错</p>\n<p>（1）不说前东家或者自己的坏话</p>\n<p>（2）往自己擅长的方面说</p>\n<p>（3）实质，对考官来说，内容听过，就是自我肯定；没听过，那就是个学习的过程。</p>\n<h2 id=\"15-3-面试技巧\"><a href=\"#15-3-面试技巧\" class=\"headerlink\" title=\"15.3 面试技巧\"></a>15.3 面试技巧</h2><h3 id=\"15-3-1-六个常见问题\"><a href=\"#15-3-1-六个常见问题\" class=\"headerlink\" title=\"15.3.1 六个常见问题\"></a>15.3.1 六个常见问题</h3><p>1）你的优点是什么？</p>\n<p>大胆的说出自己各个方面的优势和特长</p>\n<p>2）你的缺点是什么？</p>\n<p>不要谈自己真实问题；用”缺点”衬托自己的优点</p>\n<p>3）你的离职原因是什么？</p>\n<ul>\n<li><p>不说前东家坏话，哪怕被伤过</p>\n</li>\n<li><p>合情合理合法</p>\n</li>\n<li><p>不要说超过1个以上的原因</p>\n</li>\n</ul>\n<p>4）您对薪资的期望是多少？</p>\n<ul>\n<li><p>非终面不深谈薪资</p>\n</li>\n<li><p>只说区间，不说具体数字</p>\n</li>\n<li><p>底线是不低于当前薪资</p>\n</li>\n<li><p>非要具体数字，区间取中间值，或者当前薪资的+20%</p>\n</li>\n</ul>\n<p>5）您还有什么想问的问题？</p>\n<ul>\n<li><p>这是体现个人眼界和层次的问题</p>\n</li>\n<li><p>问题本身不在于面试官想得到什么样的答案，而在于你跟别的应聘者的对比</p>\n</li>\n<li><p>标准答案：</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>公司希望我入职后的3-6个月内，给公司解决什么样的问题</p>\n<p>公司（或者对这个部门）未来的战略规划是什么样子的？</p>\n<p>以你现在对我的了解，您觉得我需要多长时间融入公司？</p></blockquote>\n<p>6）您最快多长时间能入职？</p>\n<p>一周左右，如果公司需要，可以适当提前。</p>\n<h3 id=\"15-3-2-两个注意事项\"><a href=\"#15-3-2-两个注意事项\" class=\"headerlink\" title=\"15.3.2 两个注意事项\"></a>15.3.2 两个注意事项</h3><p>1）职业化的语言</p>\n<p>2）职业化的形象</p>\n<h3 id=\"15-3-3-自我介绍（控制在4分半以内，不超过5分钟）\"><a href=\"#15-3-3-自我介绍（控制在4分半以内，不超过5分钟）\" class=\"headerlink\" title=\"15.3.3 自我介绍（控制在4分半以内，不超过5分钟）\"></a>15.3.3 自我介绍（控制在4分半以内，不超过5分钟）</h3><p>1）个人基本信息</p>\n<p>2）工作履历</p>\n<p>时间、公司名称、任职岗位、主要工作内容、工作业绩、离职原因</p>\n<p>3）深度沟通（也叫压力面试）</p>\n<p>刨根问底下沉式追问（注意是下沉式，而不是发散式的）</p>\n<p>基本技巧：往自己熟悉的方向说</p>\n<h1 id=\"第16章-LeetCode题目精选\"><a href=\"#第16章-LeetCode题目精选\" class=\"headerlink\" title=\"第16章 LeetCode题目精选\"></a>第16章 LeetCode题目精选</h1><p><a href=\"https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa\">[https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa]{.underline}</a></p>\n<h2 id=\"16-1-两数之和\"><a href=\"#16-1-两数之和\" class=\"headerlink\" title=\"16.1 两数之和\"></a>16.1 两数之和</h2><p>问题链接：<a href=\"https://leetcode-cn.com/problems/two-sum/\">https://leetcode-cn.com/problems/two-sum/</a></p>\n<h3 id=\"16-1-1-问题描述\"><a href=\"#16-1-1-问题描述\" class=\"headerlink\" title=\"16.1.1 问题描述\"></a>16.1.1 问题描述</h3><p>给定一个整数数组 nums 和一个目标值<br>target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9\n\n因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9\n\n所以返回 [0, 1]\n</code></pre></blockquote>\n<h3 id=\"16-1-2-参考答案\"><a href=\"#16-1-2-参考答案\" class=\"headerlink\" title=\"16.1.2 参考答案\"></a>16.1.2 参考答案</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n\n\nclass Solution &#123;\n\npublic int[] twoSum(int[] nums, int target) &#123;\n\nMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n\nfor (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n\nint complement &#x3D; target - nums[i];\n\nif (map.containsKey(complement)) &#123;\n\nreturn new int[] &#123; map.get(complement), i &#125;;\n\n&#125;\n\nmap.put(nums[i], i);\n\n&#125;\n\nthrow new IllegalArgumentException(&quot;No two sum solution&quot;);\n\n&#125;\n\n&#125;\n\n\n</code></pre></blockquote>\n<h2 id=\"16-2-爬楼梯\"><a href=\"#16-2-爬楼梯\" class=\"headerlink\" title=\"16.2 爬楼梯\"></a>16.2 爬楼梯</h2><p>问题链接：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">https://leetcode-cn.com/problems/climbing-stairs/</a></p>\n<h3 id=\"16-2-1-问题描述\"><a href=\"#16-2-1-问题描述\" class=\"headerlink\" title=\"16.2.1 问题描述\"></a>16.2.1 问题描述</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>注意：给定 n 是一个正整数。</p>\n<p>示例 1：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入： 2\n\n输出： 2\n\n解释： 有两种方法可以爬到楼顶。\n\n1. 1 阶 + 1 阶\n\n2. 2 阶\n</code></pre>\n\n<p>示例 2：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入： 3\n\n输出： 3\n\n解释： 有三种方法可以爬到楼顶。\n\n1. 1 阶 + 1 阶 + 1 阶\n\n2. 1 阶 + 2 阶\n\n3. 2 阶 + 1 阶\n</code></pre>\n\n<h3 id=\"16-2-2-参考答案\"><a href=\"#16-2-2-参考答案\" class=\"headerlink\" title=\"16.2.2 参考答案\"></a>16.2.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\npublic class Solution &#123;\n\npublic int climbStairs(int n) &#123;\n\nif (n &#x3D;&#x3D; 1) &#123;\n\nreturn 1;\n\n&#125;\n\nint[] dp &#x3D; new int[n + 1];\n\ndp[1] &#x3D; 1;\n\ndp[2] &#x3D; 2;\n\nfor (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;\n\ndp[i] &#x3D; dp[i - 1] + dp[i - 2];\n\n&#125;\n\nreturn dp[n];\n\n&#125;\n\n&#125;\n</code></pre>\n\n<h2 id=\"16-3-翻转二叉树\"><a href=\"#16-3-翻转二叉树\" class=\"headerlink\" title=\"16.3 翻转二叉树\"></a>16.3 翻转二叉树</h2><p>链接：<a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>\n<h3 id=\"16-3-1-问题描述\"><a href=\"#16-3-1-问题描述\" class=\"headerlink\" title=\"16.3.1 问题描述\"></a>16.3.1 问题描述</h3><p>翻转一棵二叉树。</p>\n<p>示例：</p>\n<p>输入：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n4\n\n&#x2F; \n\n2 7\n\n&#x2F;  &#x2F; \n\n1 3 6 9\n</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n4\n\n&#x2F; \n\n7 2\n\n&#x2F;  &#x2F; \n\n9 6 3 1\n</code></pre>\n\n<h3 id=\"16-3-2-参考答案\"><a href=\"#16-3-2-参考答案\" class=\"headerlink\" title=\"16.3.2 参考答案\"></a>16.3.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\npublic TreeNode invertTree(TreeNode root) &#123;\n\nif (root &#x3D;&#x3D; null) &#123;\n\nreturn null;\n\n&#125;\n\nTreeNode right &#x3D; invertTree(root.right);\n\nTreeNode left &#x3D; invertTree(root.left);\n\nroot.left &#x3D; right;\n\nroot.right &#x3D; left;\n\nreturn root;\n\n&#125;\n</code></pre>\n\n<h2 id=\"16-4-反转链表\"><a href=\"#16-4-反转链表\" class=\"headerlink\" title=\"16.4 反转链表\"></a>16.4 反转链表</h2><p>链接：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>\n<h3 id=\"16-4-1-问题描述\"><a href=\"#16-4-1-问题描述\" class=\"headerlink\" title=\"16.4.1 问题描述\"></a>16.4.1 问题描述</h3><p>反转一个单链表。</p>\n<p>示例:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n\n输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n</code></pre>\n\n<h3 id=\"16-4-2-参考答案\"><a href=\"#16-4-2-参考答案\" class=\"headerlink\" title=\"16.4.2 参考答案\"></a>16.4.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\npublic ListNode reverseList(ListNode head) &#123;\n\nListNode prev &#x3D; null;\n\nListNode curr &#x3D; head;\n\nwhile (curr !&#x3D; null) &#123;\n\nListNode nextTemp &#x3D; curr.next;\n\ncurr.next &#x3D; prev;\n\nprev &#x3D; curr;\n\ncurr &#x3D; nextTemp;\n\n&#125;\n\nreturn prev;\n\n&#125;\n</code></pre>\n\n<h2 id=\"16-5-LRU缓存机制\"><a href=\"#16-5-LRU缓存机制\" class=\"headerlink\" title=\"16.5 LRU缓存机制\"></a>16.5 LRU缓存机制</h2><p>链接：<a href=\"https://leetcode-cn.com/problems/lru-cache/\">https://leetcode-cn.com/problems/lru-cache/</a></p>\n<h3 id=\"16-5-1-问题描述\"><a href=\"#16-5-1-问题描述\" class=\"headerlink\" title=\"16.5.1 问题描述\"></a>16.5.1 问题描述</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用)<br>缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>\n<p>获取数据 get(key) - 如果密钥 (key)<br>存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。</p>\n<p>写入数据 put(key, value) -<br>如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>\n<p>进阶:</p>\n<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>\n<p>示例:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nLRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );\n\ncache.put(1, 1);\n\ncache.put(2, 2);\n\ncache.get(1); &#x2F;&#x2F; 返回 1\n\ncache.put(3, 3); &#x2F;&#x2F; 该操作会使得密钥 2 作废\n\ncache.get(2); &#x2F;&#x2F; 返回 -1 (未找到)\n\ncache.put(4, 4); &#x2F;&#x2F; 该操作会使得密钥 1 作废\n\ncache.get(1); &#x2F;&#x2F; 返回 -1 (未找到)\n\ncache.get(3); &#x2F;&#x2F; 返回 3\n\ncache.get(4); &#x2F;&#x2F; 返回 4\n</code></pre>\n\n<h3 id=\"16-5-2-参考答案\"><a href=\"#16-5-2-参考答案\" class=\"headerlink\" title=\"16.5.2 参考答案\"></a>16.5.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nclass LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;\n\nprivate int capacity;\n\npublic LRUCache(int capacity) &#123;\n\nsuper(capacity, 0.75F, true);\n\nthis.capacity &#x3D; capacity;\n\n&#125;\n\npublic int get(int key) &#123;\n\nreturn super.getOrDefault(key, -1);\n\n&#125;\n\npublic void put(int key, int value) &#123;\n\nsuper.put(key, value);\n\n&#125;\n\n@Override\n\nprotected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt;\neldest) &#123;\n\nreturn size() &gt; capacity;\n\n&#125;\n\n&#125;\n\n&#x2F;**\n\n* LRUCache 对象会以如下语句构造和调用:\n\n* LRUCache obj &#x3D; new LRUCache(capacity);\n\n* int param_1 &#x3D; obj.get(key);\n\n* obj.put(key,value);\n\n*&#x2F;\n</code></pre>\n\n<h2 id=\"16-6-最长回文子串\"><a href=\"#16-6-最长回文子串\" class=\"headerlink\" title=\"16.6 最长回文子串\"></a>16.6 最长回文子串</h2><p>链接：<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>\n<h3 id=\"16-6-1-问题描述\"><a href=\"#16-6-1-问题描述\" class=\"headerlink\" title=\"16.6.1 问题描述\"></a>16.6.1 问题描述</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为<br>1000。</p>\n<p>示例 1：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: &quot;babad&quot;\n\n输出: &quot;bab&quot;\n\n注意: &quot;aba&quot; 也是一个有效答案。\n</code></pre>\n\n<p>示例 2：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: &quot;cbbd&quot;\n\n输出: &quot;bb&quot;\n</code></pre>\n\n<h3 id=\"16-6-2-参考答案\"><a href=\"#16-6-2-参考答案\" class=\"headerlink\" title=\"16.6.2 参考答案\"></a>16.6.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\npublic String longestPalindrome(String s) &#123;\n\nif (s &#x3D;&#x3D; null || s.length() &lt; 1) return &quot;&quot;;\n\nint start &#x3D; 0, end &#x3D; 0;\n\nfor (int i &#x3D; 0; i &lt; s.length(); i++) &#123;\n\nint len1 &#x3D; expandAroundCenter(s, i, i);\n\nint len2 &#x3D; expandAroundCenter(s, i, i + 1);\n\nint len &#x3D; Math.max(len1, len2);\n\nif (len &gt; end - start) &#123;\n\nstart &#x3D; i - (len - 1) &#x2F; 2;\n\nend &#x3D; i + len &#x2F; 2;\n\n&#125;\n\n&#125;\n\nreturn s.substring(start, end + 1);\n\n&#125;\n\nprivate int expandAroundCenter(String s, int left, int right) &#123;\n\nint L &#x3D; left, R &#x3D; right;\n\nwhile (L &gt;&#x3D; 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) &#x3D;&#x3D; s.charAt(R)) &#123;\n\nL--;\n\nR++;\n\n&#125;\n\nreturn R - L - 1;\n\n&#125;\n</code></pre>\n\n<h2 id=\"16-7-有效的括号\"><a href=\"#16-7-有效的括号\" class=\"headerlink\" title=\"16.7 有效的括号\"></a>16.7 有效的括号</h2><p>链接：<a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">https://leetcode-cn.com/problems/valid-parentheses/</a></p>\n<h3 id=\"16-7-1-问题描述\"><a href=\"#16-7-1-问题描述\" class=\"headerlink\" title=\"16.7.1 问题描述\"></a>16.7.1 问题描述</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’<br>的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li><p>左括号必须用相同类型的右括号闭合。</p>\n</li>\n<li><p>左括号必须以正确的顺序闭合。</p>\n</li>\n</ol>\n<p>注意空字符串可被认为是有效字符串。</p>\n<p>示例 1:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: &quot;()&quot;\n\n输出: true\n</code></pre>\n\n<p>示例 2:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: &quot;()[]&#123;&#125;&quot;\n\n输出: true\n</code></pre>\n\n<p>示例 3:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: &quot;(]&quot;\n\n输出: false\n</code></pre>\n\n<p>示例 4:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: &quot;([)]&quot;\n\n输出: false\n</code></pre>\n\n<p>示例 5:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: &quot;&#123;[]&#125;&quot;\n\n输出: true\n</code></pre>\n\n<h3 id=\"16-7-2-参考答案\"><a href=\"#16-7-2-参考答案\" class=\"headerlink\" title=\"16.7.2 参考答案\"></a>16.7.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nclass Solution &#123;\n\n&#x2F;&#x2F; Hash table that takes care of the mappings.\n\nprivate HashMap&lt;Character, Character&gt; mappings;\n\n&#x2F;&#x2F; Initialize hash map with mappings. This simply makes the code easier\nto read.\n\npublic Solution() &#123;\n\nthis.mappings &#x3D; new HashMap&lt;Character, Character&gt;();\n\nthis.mappings.put(&#39;)&#39;, &#39;(&#39;);\n\nthis.mappings.put(&#39;&#125;&#39;, &#39;&#123;&#39;);\n\nthis.mappings.put(&#39;]&#39;, &#39;[&#39;);\n\n&#125;\n\npublic boolean isValid(String s) &#123;\n\n&#x2F;&#x2F; Initialize a stack to be used in the algorithm.\n\nStack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();\n\nfor (int i &#x3D; 0; i &lt; s.length(); i++) &#123;\n\nchar c &#x3D; s.charAt(i);\n\n&#x2F;&#x2F; If the current character is a closing bracket.\n\nif (this.mappings.containsKey(c)) &#123;\n\n&#x2F;&#x2F; Get the top element of the stack. If the stack is empty, set a dummy\nvalue of &#39;#&#39;\n\nchar topElement &#x3D; stack.empty() ? &#39;#&#39; : stack.pop();\n\n&#x2F;&#x2F; If the mapping for this bracket doesn&#39;t match the stack&#39;s top\nelement, return false.\n\nif (topElement !&#x3D; this.mappings.get(c)) &#123;\n\nreturn false;\n\n&#125;\n\n&#125; else &#123;\n\n&#x2F;&#x2F; If it was an opening bracket, push to the stack.\n\nstack.push(c);\n\n&#125;\n\n&#125;\n\n&#x2F;&#x2F; If the stack still contains elements, then it is an invalid\nexpression.\n\nreturn stack.isEmpty();\n\n&#125;\n\n&#125;\n</code></pre>\n\n<h2 id=\"16-8-数组中的第K个最大元素\"><a href=\"#16-8-数组中的第K个最大元素\" class=\"headerlink\" title=\"16.8 数组中的第K个最大元素\"></a>16.8 数组中的第K个最大元素</h2><p>链接：<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>\n<h3 id=\"16-8-1-问题描述\"><a href=\"#16-8-1-问题描述\" class=\"headerlink\" title=\"16.8.1 问题描述\"></a>16.8.1 问题描述</h3><p>在未排序的数组中找到第 k<br>个最大的元素。请注意，你需要找的是数组排序后的第 k<br>个最大的元素，而不是第 k 个不同的元素。</p>\n<p>示例 1:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: [3,2,1,5,6,4] 和 k &#x3D; 2\n\n输出: 5\n</code></pre>\n\n<p>示例 2:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4\n\n输出: 4\n</code></pre>\n\n<p>说明:</p>\n<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>\n<h3 id=\"16-8-2-参考答案\"><a href=\"#16-8-2-参考答案\" class=\"headerlink\" title=\"16.8.2 参考答案\"></a>16.8.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nimport java.util.Random;\n\nclass Solution &#123;\n\nint [] nums;\n\npublic void swap(int a, int b) &#123;\n\nint tmp &#x3D; this.nums[a];\n\nthis.nums[a] &#x3D; this.nums[b];\n\nthis.nums[b] &#x3D; tmp;\n\n&#125;\n\npublic int partition(int left, int right, int pivot_index) &#123;\n\nint pivot &#x3D; this.nums[pivot_index];\n\n&#x2F;&#x2F; 1. move pivot to end\n\nswap(pivot_index, right);\n\nint store_index &#x3D; left;\n\n&#x2F;&#x2F; 2. move all smaller elements to the left\n\nfor (int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;\n\nif (this.nums[i] &lt; pivot) &#123;\n\nswap(store_index, i);\n\nstore_index++;\n\n&#125;\n\n&#125;\n\n&#x2F;&#x2F; 3. move pivot to its final place\n\nswap(store_index, right);\n\nreturn store_index;\n\n&#125;\n\npublic int quickselect(int left, int right, int k_smallest) &#123;\n\n&#x2F;*\n\nReturns the k-th smallest element of list within left..right.\n\n*&#x2F;\n\nif (left &#x3D;&#x3D; right) &#x2F;&#x2F; If the list contains only one element,\n\nreturn this.nums[left]; &#x2F;&#x2F; return that element\n\n&#x2F;&#x2F; select a random pivot_index\n\nRandom random_num &#x3D; new Random();\n\nint pivot_index &#x3D; left + random_num.nextInt(right - left);\n\npivot_index &#x3D; partition(left, right, pivot_index);\n\n&#x2F;&#x2F; the pivot is on (N - k)th smallest position\n\nif (k_smallest &#x3D;&#x3D; pivot_index)\n\nreturn this.nums[k_smallest];\n\n&#x2F;&#x2F; go left side\n\nelse if (k_smallest &lt; pivot_index)\n\nreturn quickselect(left, pivot_index - 1, k_smallest);\n\n&#x2F;&#x2F; go right side\n\nreturn quickselect(pivot_index + 1, right, k_smallest);\n\n&#125;\n\npublic int findKthLargest(int[] nums, int k) &#123;\n\nthis.nums &#x3D; nums;\n\nint size &#x3D; nums.length;\n\n&#x2F;&#x2F; kth largest is (N - k)th smallest\n\nreturn quickselect(0, size - 1, size - k);\n\n&#125;\n\n&#125;\n</code></pre>\n\n<h2 id=\"16-9-实现-Trie-前缀树\"><a href=\"#16-9-实现-Trie-前缀树\" class=\"headerlink\" title=\"16.9 实现 Trie (前缀树)\"></a>16.9 实现 Trie (前缀树)</h2><h3 id=\"16-9-1-问题描述\"><a href=\"#16-9-1-问题描述\" class=\"headerlink\" title=\"16.9.1 问题描述\"></a>16.9.1 问题描述</h3><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>\n<p>示例:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nTrie trie &#x3D; new Trie();\n\ntrie.insert(&quot;apple&quot;);\n\ntrie.search(&quot;apple&quot;); &#x2F;&#x2F; 返回 true\n\ntrie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 false\n\ntrie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 true\n\ntrie.insert(&quot;app&quot;);\n\ntrie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 true\n</code></pre>\n\n<p>说明:</p>\n<ul>\n<li><p>你可以假设所有的输入都是由小写字母 a-z 构成的。</p>\n</li>\n<li><p>保证所有输入均为非空字符串。</p>\n</li>\n</ul>\n<h3 id=\"16-9-2-参考答案\"><a href=\"#16-9-2-参考答案\" class=\"headerlink\" title=\"16.9.2 参考答案\"></a>16.9.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nclass Trie &#123;\n\nprivate TrieNode root;\n\npublic Trie() &#123;\n\nroot &#x3D; new TrieNode();\n\n&#125;\n\n&#x2F;&#x2F; Inserts a word into the trie.\n\npublic void insert(String word) &#123;\n\nTrieNode node &#x3D; root;\n\nfor (int i &#x3D; 0; i &lt; word.length(); i++) &#123;\n\nchar currentChar &#x3D; word.charAt(i);\n\nif (!node.containsKey(currentChar)) &#123;\n\nnode.put(currentChar, new TrieNode());\n\n&#125;\n\nnode &#x3D; node.get(currentChar);\n\n&#125;\n\nnode.setEnd();\n\n&#125;\n\n&#x2F;&#x2F; search a prefix or whole key in trie and\n\n&#x2F;&#x2F; returns the node where search ends\n\nprivate TrieNode searchPrefix(String word) &#123;\n\nTrieNode node &#x3D; root;\n\nfor (int i &#x3D; 0; i &lt; word.length(); i++) &#123;\n\nchar curLetter &#x3D; word.charAt(i);\n\nif (node.containsKey(curLetter)) &#123;\n\nnode &#x3D; node.get(curLetter);\n\n&#125; else &#123;\n\nreturn null;\n\n&#125;\n\n&#125;\n\nreturn node;\n\n&#125;\n\n&#x2F;&#x2F; Returns if the word is in the trie.\n\npublic boolean search(String word) &#123;\n\nTrieNode node &#x3D; searchPrefix(word);\n\nreturn node !&#x3D; null &amp;&amp; node.isEnd();\n\n&#125;\n\n&#125;\n</code></pre>\n\n<h2 id=\"16-10-编辑距离\"><a href=\"#16-10-编辑距离\" class=\"headerlink\" title=\"16.10 编辑距离\"></a>16.10 编辑距离</h2><p>链接：<a href=\"https://leetcode-cn.com/problems/edit-distance/\">https://leetcode-cn.com/problems/edit-distance/</a></p>\n<h3 id=\"16-10-1-问题描述\"><a href=\"#16-10-1-问题描述\" class=\"headerlink\" title=\"16.10.1 问题描述\"></a>16.10.1 问题描述</h3><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2<br>所使用的最少操作数 。</p>\n<p>你可以对一个单词进行如下三种操作：</p>\n<ol>\n<li><p>插入一个字符</p>\n</li>\n<li><p>删除一个字符</p>\n</li>\n<li><p>替换一个字符</p>\n</li>\n</ol>\n<p>示例 1:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;\n\n输出: 3\n\n解释:\n\nhorse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)\n\nrorse -&gt; rose (删除 &#39;r&#39;)\n\nrose -&gt; ros (删除 &#39;e&#39;)\n</code></pre>\n\n<p>示例 2:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;\n\n输出: 5\n\n解释:\n\nintention -&gt; inention (删除 &#39;t&#39;)\n\ninention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)\n\nenention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)\n\nexention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)\n\nexection -&gt; execution (插入 &#39;u&#39;)\n</code></pre>\n\n<h3 id=\"16-10-2-参考答案\"><a href=\"#16-10-2-参考答案\" class=\"headerlink\" title=\"16.10.2 参考答案\"></a>16.10.2 参考答案</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nclass Solution &#123;\n\npublic int minDistance(String word1, String word2) &#123;\n\nint n &#x3D; word1.length();\n\nint m &#x3D; word2.length();\n\n&#x2F;&#x2F; if one of the strings is empty\n\nif (n * m &#x3D;&#x3D; 0)\n\nreturn n + m;\n\n&#x2F;&#x2F; array to store the convertion history\n\nint [][] d &#x3D; new int[n + 1][m + 1];\n\n&#x2F;&#x2F; init boundaries\n\nfor (int i &#x3D; 0; i &lt; n + 1; i++) &#123;\n\nd[i][0] &#x3D; i;\n\n&#125;\n\nfor (int j &#x3D; 0; j &lt; m + 1; j++) &#123;\n\nd[0][j] &#x3D; j;\n\n&#125;\n\n&#x2F;&#x2F; DP compute\n\nfor (int i &#x3D; 1; i &lt; n + 1; i++) &#123;\n\nfor (int j &#x3D; 1; j &lt; m + 1; j++) &#123;\n\nint left &#x3D; d[i - 1][j] + 1;\n\nint down &#x3D; d[i][j - 1] + 1;\n\nint left_down &#x3D; d[i - 1][j - 1];\n\nif (word1.charAt(i - 1) !&#x3D; word2.charAt(j - 1))\n\nleft_down +&#x3D; 1;\n\nd[i][j] &#x3D; Math.min(left, Math.min(down, left_down));\n\n&#125;\n\n&#125;\n\nreturn d[n][m];\n\n&#125;\n\n&#125;\n</code></pre>\n","text":"尚硅谷大数据技术之高频面试题 （作者：尚硅谷大数据研发部） 版本：V8.0.15 目录项目涉及技术1.1 Linux&amp;Shell1.1.1 Linux常用高级命令 序号 命令 命令解释 1 top 查看内存 2 df -h 查看磁盘存储情况 3 iotop 查看磁盘IO读...","link":"","photos":[],"count_time":{"symbolsCount":"143k","symbolsTime":"2:10"},"categories":[{"name":"大数据","slug":"大数据","count":2,"path":"api/categories/大数据.json"}],"tags":[{"name":"大数据","slug":"大数据","count":2,"path":"api/tags/大数据.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">目录</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">项目涉及技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-Linux-amp-Shell\"><span class=\"toc-text\">1.1 Linux&amp;Shell</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-Linux%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">1.1.1 Linux常用高级命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-Shell%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%86%99%E8%BF%87%E7%9A%84%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">1.1.2 Shell常用工具及写过的脚本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-3-Shell%E4%B8%AD%E6%8F%90%E4%BA%A4%E4%BA%86%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%B7%B2%E7%BB%8F%E4%B8%8D%E7%9F%A5%E9%81%93%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E9%9C%80%E8%A6%81kill%E6%8E%89%E8%BF%99%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.1.3 Shell中提交了一个脚本，进程号已经不知道了，但是需要kill掉这个进程，怎么操作?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-4-Shell%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.1.4 Shell中单引号和双引号区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-Hadoop\"><span class=\"toc-text\">1.2 Hadoop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-Hadoop%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><span class=\"toc-text\">1.2.1 Hadoop常用端口号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-Hadoop%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">1.2.2 Hadoop配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-3-HDFS%E8%AF%BB%E6%B5%81%E7%A8%8B%E5%92%8C%E5%86%99%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1.2.3 HDFS读流程和写流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-4-HDFS%E5%B0%8F%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1.2.4 HDFS小文件处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-5-HDFS%E7%9A%84NameNode%E5%86%85%E5%AD%98\"><span class=\"toc-text\">1.2.5 HDFS的NameNode内存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-6-NameNode%E5%BF%83%E8%B7%B3%E5%B9%B6%E5%8F%91%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1.2.6 NameNode心跳并发配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-7-%E7%BA%A0%E5%88%A0%E7%A0%81%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.2.7 纠删码原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-8-%E5%BC%82%E6%9E%84%E5%AD%98%E5%82%A8%EF%BC%88%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%EF%BC%89\"><span class=\"toc-text\">1.2.8 异构存储（冷热数据分离）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-9-Shuffle%E5%8F%8A%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">1.2.9 Shuffle及优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-10-Yarn%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1.2.10 Yarn工作机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-11-Yarn%E8%B0%83%E5%BA%A6%E5%99%A8\"><span class=\"toc-text\">1.2.11 Yarn调度器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-12-%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E4%B9%8B%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">1.2.12 项目经验之基准测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-13-Hadoop%E5%AE%95%E6%9C%BA\"><span class=\"toc-text\">1.2.13 Hadoop宕机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-14-Hadoop%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.2.14 Hadoop解决数据倾斜方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-Zookeeper\"><span class=\"toc-text\">1.3 Zookeeper</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-1-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">1.3.1 常用命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-2-Paxos%E7%AE%97%E6%B3%95%E5%92%8CZAB%E5%8D%8F%E8%AE%AE%EF%BC%88%E6%89%A9%E5%B1%95%EF%BC%89\"><span class=\"toc-text\">1.3.2 Paxos算法和ZAB协议（扩展）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-3-%E8%AE%B2%E4%B8%80%E8%AE%B2%E4%BB%80%E4%B9%88%E6%98%AFCAP%E6%B3%95%E5%88%99%EF%BC%9FZookeeper%E7%AC%A6%E5%90%88%E4%BA%86%E8%BF%99%E4%B8%AA%E6%B3%95%E5%88%99%E7%9A%84%E5%93%AA%E4%B8%A4%E4%B8%AA%EF%BC%9F%EF%BC%88%E6%89%A9%E5%B1%95%EF%BC%89\"><span class=\"toc-text\">1.3.3 讲一讲什么是CAP法则？Zookeeper符合了这个法则的哪两个？（扩展）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-4-%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1.3.4 选举机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-5-Follower%E5%92%8CLeader%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">1.3.5 Follower和Leader状态同步</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-Flume\"><span class=\"toc-text\">1.4 Flume</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-1-Flume%E7%BB%84%E6%88%90%EF%BC%8CPut%E4%BA%8B%E5%8A%A1%EF%BC%8CTake%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">1.4.1 Flume组成，Put事务，Take事务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-2-Flume%E6%8B%A6%E6%88%AA%E5%99%A8\"><span class=\"toc-text\">1.4.2 Flume拦截器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-3-Flume-Channel%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">1.4.3 Flume Channel选择器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-4-Flume%E7%9B%91%E6%8E%A7%E5%99%A8\"><span class=\"toc-text\">1.4.4 Flume监控器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-5-Flume%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%90%97-%EF%BC%88%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%89\"><span class=\"toc-text\">1.4.5 Flume采集数据会丢失吗?（防止数据丢失的机制）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-Kafka\"><span class=\"toc-text\">1.5 Kafka</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-1-Kafka%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1.5.1 Kafka架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-2-Kafka%E7%9A%84%E6%9C%BA%E5%99%A8%E6%95%B0%E9%87%8F\"><span class=\"toc-text\">1.5.2 Kafka的机器数量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-3-%E5%89%AF%E6%9C%AC%E6%95%B0%E8%AE%BE%E5%AE%9A\"><span class=\"toc-text\">1.5.3 副本数设定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-4-Kafka%E5%8E%8B%E6%B5%8B\"><span class=\"toc-text\">1.5.4 Kafka压测</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-5-Kafka%E6%97%A5%E5%BF%97%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">1.5.5 Kafka日志保存时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-6-Kafka%E4%B8%AD%E6%95%B0%E6%8D%AE%E9%87%8F%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">1.5.6 Kafka中数据量计算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-7-Kafka%E7%9A%84%E7%A1%AC%E7%9B%98%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">1.5.7 Kafka的硬盘大小</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-8-Kafka%E7%9B%91%E6%8E%A7\"><span class=\"toc-text\">1.5.8 Kafka监控</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-9-Kakfa%E5%88%86%E5%8C%BA%E6%95%B0\"><span class=\"toc-text\">1.5.9 Kakfa分区数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-10-%E5%A4%9A%E5%B0%91%E4%B8%AATopic\"><span class=\"toc-text\">1.5.10 多少个Topic</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-11-Kafka%E7%9A%84ISR%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97\"><span class=\"toc-text\">1.5.11 Kafka的ISR副本同步队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-12-Kafka%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">1.5.12 Kafka分区分配策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-13-Kafka%E6%8C%82%E6%8E%89\"><span class=\"toc-text\">1.5.13 Kafka挂掉</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-14-Kafka%E4%B8%A2%E4%B8%8D%E4%B8%A2%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1.5.14 Kafka丢不丢数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-15-Kafka%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D\"><span class=\"toc-text\">1.5.15 Kafka数据重复</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-16-Kafka%E6%B6%88%E6%81%AF%E6%95%B0%E6%8D%AE%E7%A7%AF%E5%8E%8B%EF%BC%8CKafka%E6%B6%88%E8%B4%B9%E8%83%BD%E5%8A%9B%E4%B8%8D%E8%B6%B3%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">1.5.16 Kafka消息数据积压，Kafka消费能力不足怎么处理？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-17-Kafka%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">1.5.17 Kafka参数优化</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E7%95%99%E4%B8%89%E5%A4%A9%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%9B%B4%E7%9F%AD-%EF%BC%88log-cleaner-delete-retention-ms%EF%BC%89\"><span class=\"toc-text\">保留三天，也可以更短 （log.cleaner.delete.retention.ms）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-18-Kafka%E9%AB%98%E6%95%88%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1.5.18 Kafka高效读写数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-19-Kafka%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E4%BC%A0%E8%BE%93%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">1.5.19 Kafka单条日志传输大小</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-20-Kafka%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86\"><span class=\"toc-text\">1.5.20 Kafka过期数据清理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-21-Kafka%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1.5.21 Kafka可以按照时间消费数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-22-Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E8%A7%92%E5%BA%A6%E8%80%83%E8%99%91%E6%98%AF%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%E8%BF%98%E6%98%AF%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1.5.22 Kafka消费者角度考虑是拉取数据还是推送数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-23-Kafka%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%81%EF%BC%81%EF%BC%81\"><span class=\"toc-text\">1.5.23 Kafka中的数据是有序的吗！！！</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-24-Kafka%E7%9A%84LeaderEpoch%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC%E5%BC%95%E5%85%A5%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">1.5.24 Kafka的LeaderEpoch哪个版本引入的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-25-Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E8%B0%83%E4%BC%98%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1.5.25 Kafka生产者调优配置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-Hive\"><span class=\"toc-text\">1.6 Hive</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-1-Hive%E7%9A%84%E6%9E%B6%E6%9E%84%E5%8F%8AHQL%E8%BD%AC%E6%8D%A2%E4%B8%BAMR%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1.6.1 Hive的架构及HQL转换为MR流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-2-Hive%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">1.6.2 Hive和数据库比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-3-%E5%86%85%E9%83%A8%E8%A1%A8%E5%92%8C%E5%A4%96%E9%83%A8%E8%A1%A8\"><span class=\"toc-text\">1.6.3 内部表和外部表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-4-4%E4%B8%AABy%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.6.4 4个By区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-5-%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1.6.5 系统函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-6-%E8%87%AA%E5%AE%9A%E4%B9%89UDF%E3%80%81UDTF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1.6.6 自定义UDF、UDTF函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-7-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1.6.7 窗口函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-8-Hive%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">1.6.8 Hive优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-9-Hive%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.6.9 Hive解决数据倾斜方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-10-Hive%E9%87%8C%E8%BE%B9%E5%AD%97%E6%AE%B5%E7%9A%84%E5%88%86%E9%9A%94%E7%AC%A6%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8t%EF%BC%9F%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E5%AD%97%E6%AE%B5%E9%87%8C%E8%BE%B9%E6%9C%89t%E7%9A%84%E6%83%85%E5%86%B5%E5%90%97%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">1.6.10 Hive里边字段的分隔符用的什么？为什么用t？有遇到过字段里边有t的情况吗，怎么处理的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-11-Tez%E5%BC%95%E6%93%8E%E4%BC%98%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">1.6.11 Tez引擎优点？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-12-MySQL%E5%85%83%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD\"><span class=\"toc-text\">1.6.12 MySQL元数据备份</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-13-Union%E4%B8%8EUnion-all%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.6.13 Union与Union all区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-Sqoop\"><span class=\"toc-text\">1.7 Sqoop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-1-Sqoop%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">1.7.1 Sqoop参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-2-Sqoop%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BANull%E5%AD%98%E5%82%A8%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.7.2 Sqoop导入导出Null存储一致性问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-3-Sqoop%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.7.3 Sqoop数据导出一致性问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-4-Sqoop%E5%BA%95%E5%B1%82%E8%BF%90%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.7.4 Sqoop底层运行的任务是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-5-Sqoop%E4%B8%80%E5%A4%A9%E5%AF%BC%E5%85%A5%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1.7.5 Sqoop一天导入多少数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-6-Sqoop%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">1.7.6 Sqoop数据导出的时候一次执行多长时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-7-Sqoop%E5%9C%A8%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C\"><span class=\"toc-text\">1.7.7 Sqoop在导入数据的时候数据倾斜</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-8-Sqoop%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BAParquet%EF%BC%88%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89\"><span class=\"toc-text\">1.7.8 Sqoop数据导出Parquet（项目中遇到的问题）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-8-Azkaban\"><span class=\"toc-text\">1.8 Azkaban </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-8-1-%E6%AF%8F%E5%A4%A9%E9%9B%86%E7%BE%A4%E8%BF%90%E8%A1%8C%E5%A4%9A%E5%B0%91%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">1.8.1 每天集群运行多少指标?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-8-2-%E4%BB%BB%E5%8A%A1%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">1.8.2 任务挂了怎么办？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-9-HBase\"><span class=\"toc-text\">1.9 HBase</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-9-1-HBase%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.9.1 HBase存储结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-9-2-RowKey%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">1.9.2 RowKey设计原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-9-3-RowKey%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">1.9.3 RowKey如何设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-9-4-Phoenix%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88%E8%AE%B2%E5%8E%9F%E7%90%86%EF%BC%89\"><span class=\"toc-text\">1.9.4 Phoenix二级索引（讲原理）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-10-Scala\"><span class=\"toc-text\">1.10 Scala</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-1-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">1.10.1 开发环境</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-2-%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">1.10.2 变量和数据类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-3-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">1.10.3 流程控制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-4-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">1.10.4 函数式编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.10.5 面向对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-6-%E9%9B%86%E5%90%88\"><span class=\"toc-text\">1.10.6 集合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-7-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">1.10.7 模式匹配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-8-%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">1.10.8 异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-9-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">1.10.9 隐式转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-10-10-%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">1.10.10 泛型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-11-Spark-Core-amp-SQL\"><span class=\"toc-text\">1.11 Spark Core &amp; SQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-1-Spark%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.11.1 Spark解决什么问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-2-Spark%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%99%A8\"><span class=\"toc-text\">1.11.2 Spark为什么会有自己的资源调度器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-3-Spark%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.11.3 Spark运行模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-4-Spark%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><span class=\"toc-text\">1.11.4 Spark常用端口号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-5-%E7%AE%80%E8%BF%B0Spark%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%EF%BC%88%E7%94%BB%E5%9B%BE%E8%AE%B2%E8%A7%A3%EF%BC%8C%E6%B3%A8%E6%98%8E%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%89%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.11.5 简述Spark的架构与作业提交流程（画图讲解，注明各个部分的作用）（重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-6-Spark%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%9B%E8%A1%8C%E6%8F%90%E4%BA%A4%EF%BC%8CJavaEE%E7%95%8C%E9%9D%A2%E8%BF%98%E6%98%AF%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">1.11.6 Spark任务使用什么进行提交，JavaEE界面还是脚本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-7-Spark%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A%E5%8F%82%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.11.7 Spark提交作业参数（重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-8-RDD%E4%BA%94%E5%A4%A7%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">1.11.8 RDD五大属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-9-Spark%E7%9A%84transformation%E7%AE%97%E5%AD%90%EF%BC%88%E4%B8%8D%E5%B0%91%E4%BA%8E8%E4%B8%AA%EF%BC%89%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.11.9 Spark的transformation算子（不少于8个）（重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-10-Spark%E7%9A%84action%E7%AE%97%E5%AD%90%EF%BC%88%E4%B8%8D%E5%B0%91%E4%BA%8E6%E4%B8%AA%EF%BC%89%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.11.10 Spark的action算子（不少于6个）（重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-11-map%E5%92%8CmapPartitions%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.11.11 map和mapPartitions区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-12-Repartition%E5%92%8CCoalesce%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.11.12 Repartition和Coalesce区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-13-reduceByKey%E4%B8%8EgroupByKey%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.11.13 reduceByKey与groupByKey的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-14-reduceByKey%E3%80%81foldByKey%E3%80%81aggregateByKey%E3%80%81combineByKey%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.11.14 reduceByKey、foldByKey、aggregateByKey、combineByKey区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-15-Kryo%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">1.11.15 Kryo序列化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-16-Spark%E4%B8%AD%E7%9A%84%E8%A1%80%E7%BC%98%EF%BC%88%E7%AC%94%E8%AF%95%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.11.16 Spark中的血缘（笔试重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-17-Spark%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%92%E5%88%86\"><span class=\"toc-text\">1.11.17 Spark任务的划分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-18-cache%E7%BC%93%E5%AD%98%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">1.11.18 cache缓存级别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-19-%E9%87%8A%E6%94%BE%E7%BC%93%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">1.11.19 释放缓存和缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-20-%E7%BC%93%E5%AD%98%E5%92%8C%E6%A3%80%E6%9F%A5%E7%82%B9%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.11.20 缓存和检查点区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-21-Spark%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">1.11.21 Spark分区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-22-Spark%E7%B4%AF%E5%8A%A0%E5%99%A8\"><span class=\"toc-text\">1.11.22 Spark累加器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-23-Spark%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">1.11.23 Spark广播变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-24-SparkSQL%E4%B8%ADRDD%E3%80%81DataFrame%E3%80%81DataSet%E4%B8%89%E8%80%85%E7%9A%84%E8%BD%AC%E6%8D%A2-%EF%BC%88%E7%AC%94%E8%AF%95%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.11.24 SparkSQL中RDD、DataFrame、DataSet三者的转换 （笔试重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-25-%E8%AF%B7%E5%88%97%E4%B8%BE%E4%BC%9A%E5%BC%95%E8%B5%B7Shuffle%E8%BF%87%E7%A8%8B%E7%9A%84Spark%E7%AE%97%E5%AD%90%EF%BC%8C%E5%B9%B6%E7%AE%80%E8%BF%B0%E5%8A%9F%E8%83%BD%E3%80%82\"><span class=\"toc-text\">1.11.25 请列举会引起Shuffle过程的Spark算子，并简述功能。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-26-%E5%BD%93Spark%E6%B6%89%E5%8F%8A%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91Spark%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">1.11.26 当Spark涉及到数据库的操作时，如何减少Spark运行中的数据库连接数？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-27-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Spark%E5%AE%9E%E7%8E%B0TopN%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%88%E6%8F%8F%E8%BF%B0%E6%80%9D%E8%B7%AF%E6%88%96%E4%BD%BF%E7%94%A8%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%89%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.11.27 如何使用Spark实现TopN的获取（描述思路或使用伪代码）（重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-28-%E4%BA%AC%E4%B8%9C%EF%BC%9A%E8%B0%83%E4%BC%98%E4%B9%8B%E5%89%8D%E4%B8%8E%E8%B0%83%E4%BC%98%E4%B9%8B%E5%90%8E%E6%80%A7%E8%83%BD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%EF%BC%88%E4%BE%8B%E5%A6%82%E8%B0%83%E6%95%B4map%E4%B8%AA%E6%95%B0%EF%BC%8Cmap%E4%B8%AA%E6%95%B0%E4%B9%8B%E5%89%8D%E5%A4%9A%E5%B0%91%E3%80%81%E4%B9%8B%E5%90%8E%E5%A4%9A%E5%B0%91%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E6%8F%90%E5%8D%87%EF%BC%89\"><span class=\"toc-text\">1.11.28 京东：调优之前与调优之后性能的详细对比（例如调整map个数，map个数之前多少、之后多少，有什么提升）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-29-Spark-Shuffle%E9%BB%98%E8%AE%A4%E5%B9%B6%E8%A1%8C%E5%BA%A6\"><span class=\"toc-text\">1.11.29 Spark Shuffle默认并行度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-30-%E6%8E%A7%E5%88%B6Spark-reduce%E7%BC%93%E5%AD%98-%E8%B0%83%E4%BC%98shuffle\"><span class=\"toc-text\">1.11.30 控制Spark reduce缓存 调优shuffle</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-11-31-Spark%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.11.31 Spark内核源码（重点）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-12-Spark-Streaming\"><span class=\"toc-text\">1.12 Spark Streaming</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-1-Spark-Streaming%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8C%E4%B8%8D%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1.12.1 Spark Streaming第一次运行不丢失数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-2-Spark-Streaming%E7%B2%BE%E5%87%86%E4%B8%80%E6%AC%A1%E6%B6%88%E8%B4%B9\"><span class=\"toc-text\">1.12.2 Spark Streaming精准一次消费</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-3-Spark-Streaming%E6%8E%A7%E5%88%B6%E6%AF%8F%E7%A7%92%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">1.12.3 Spark Streaming控制每秒消费数据的速度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-4-Spark-Streaming%E8%83%8C%E5%8E%8B%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1.12.4 Spark Streaming背压机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-5-Spark-Streaming%E4%B8%80%E4%B8%AAstage%E8%80%97%E6%97%B6\"><span class=\"toc-text\">1.12.5 Spark Streaming一个stage耗时</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-6-Spark-Streaming%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">1.12.6 Spark Streaming优雅关闭</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-7-Spark-Streaming%E9%BB%98%E8%AE%A4%E5%88%86%E5%8C%BA%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">1.12.7 Spark Streaming默认分区个数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-8-SparkStreaming%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%B6%88%E8%B4%B9Kafka%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.12.8 SparkStreaming有哪几种方式消费Kafka中的数据，它们之间的区别是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-12-9-%E7%AE%80%E8%BF%B0SparkStreaming%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.12.9 简述SparkStreaming窗口函数的原理（重点）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-13-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C\"><span class=\"toc-text\">1.13 数据倾斜</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-13-1-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E8%A1%A8%E7%8E%B0\"><span class=\"toc-text\">1.13.1 数据倾斜表现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-13-2-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">1.13.2 数据倾斜产生原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-13-3-%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">1.13.3 解决数据倾斜思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-13-4-%E5%AE%9A%E4%BD%8D%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1.13.4 定位导致数据倾斜代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-4-1-%E6%9F%90%E4%B8%AAtask%E6%89%A7%E8%A1%8C%E7%89%B9%E5%88%AB%E6%85%A2%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">1.13.4.1 某个task执行特别慢的情况</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-4-2-%E6%9F%90%E4%B8%AAtask%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">1.13.4.2 某个task莫名其妙内存溢出的情况</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-13-5-%E6%9F%A5%E7%9C%8B%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E7%9A%84key%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5\"><span class=\"toc-text\">1.13.5 查看导致数据倾斜的key分布情况</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-13-6-Spark-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">1.13.6 Spark 数据倾斜的解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-6-1-%E4%BD%BF%E7%94%A8Hive-ETL%E9%A2%84%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1.13.6.1 使用Hive ETL预处理数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-1-1-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.13.6.1.1 适用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-1-2-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">1.13.6.1.2 实现思路</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-1-3-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.13.6.1.3 方案实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-1-4-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">1.13.6.1.4 方案优缺点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-1-5-%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C\"><span class=\"toc-text\">1.13.6.1.5 方案实践经验</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-1-6-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C\"><span class=\"toc-text\">1.13.6.1.6 项目实践经验</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-6-2-%E8%BF%87%E6%BB%A4%E5%B0%91%E6%95%B0%E5%AF%BC%E8%87%B4%E5%80%BE%E6%96%9C%E7%9A%84key\"><span class=\"toc-text\">1.13.6.2 过滤少数导致倾斜的key</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-2-1-%E6%96%B9%E6%A1%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.13.6.2.1 方案适用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-2-2-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">1.13.6.2.2 方案实现思路</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-2-3-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.13.6.2.3 方案实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-2-4-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">1.13.6.2.4 方案优缺点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-2-5-%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C\"><span class=\"toc-text\">1.13.6.2.5 方案实践经验</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-6-3-%E6%8F%90%E9%AB%98shuffle%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6\"><span class=\"toc-text\">1.13.6.3 提高shuffle操作的并行度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-3-1-%E6%96%B9%E6%A1%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.13.6.3.1 方案适用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-3-2-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">1.13.6.3.2 方案实现思路</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-3-3-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.13.6.3.3 方案实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-3-4-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">1.13.6.3.4 方案优缺点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-3-5-%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C\"><span class=\"toc-text\">1.13.6.3.5 方案实践经验</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-6-4-%E4%B8%A4%E9%98%B6%E6%AE%B5%E8%81%9A%E5%90%88%EF%BC%88%E5%B1%80%E9%83%A8%E8%81%9A%E5%90%88-%E5%85%A8%E5%B1%80%E8%81%9A%E5%90%88%EF%BC%89\"><span class=\"toc-text\">1.13.6.4 两阶段聚合（局部聚合+全局聚合）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-4-1-%E6%96%B9%E6%A1%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.13.6.4.1 方案适用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-4-2-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">1.13.6.4.2 方案实现思路</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-4-3-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.13.6.4.3 方案实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-4-4-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">1.13.6.4.4 方案优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-6-5-%E5%B0%86reduce-join%E8%BD%AC%E4%B8%BAmap-join\"><span class=\"toc-text\">1.13.6.5 将reduce join转为map join</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-5-1-%E6%96%B9%E6%A1%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.13.6.5.1 方案适用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-5-2-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">1.13.6.5.2 方案实现思路</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-5-3-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.13.6.5.3 方案实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-5-4-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">1.13.6.5.4 方案优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-6-6-%E9%87%87%E6%A0%B7%E5%80%BE%E6%96%9Ckey%E5%B9%B6%E5%88%86%E6%8B%86join%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.13.6.6 采样倾斜key并分拆join操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-6-1-%E6%96%B9%E6%A1%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.13.6.6.1 方案适用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-6-2-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">1.13.6.6.2 方案实现思路</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-6-3-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.13.6.6.3 方案实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-6-4-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">1.13.6.6.4 方案优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-6-7-%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E5%89%8D%E7%BC%80%E5%92%8C%E6%89%A9%E5%AE%B9RDD%E8%BF%9B%E8%A1%8Cjoin\"><span class=\"toc-text\">1.13.6.7 使用随机前缀和扩容RDD进行join</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-7-1-%E6%96%B9%E6%A1%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.13.6.7.1 方案适用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-7-2-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">1.13.6.7.2 方案实现思路</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-7-3-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.13.6.7.3 方案实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-7-4-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">1.13.6.7.4 方案优缺点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-13-6-7-5-%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C\"><span class=\"toc-text\">1.13.6.7.5 方案实践经验</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-13-6-8-%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%A1%88%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.13.6.8 多种方案组合使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-13-7-Spark%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%A4%84%E7%90%86%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">1.13.7 Spark数据倾斜处理小结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-14-Flink\"><span class=\"toc-text\">1.14 Flink </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-1-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Flink\"><span class=\"toc-text\">1.14.1 简单介绍一下 Flink</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-2-Flink%E8%B7%9FSpark-Streaming%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.14.2 Flink跟Spark Streaming的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-3-Flink%E9%9B%86%E7%BE%A4%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%92%E8%89%B2%EF%BC%9F%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">1.14.3 Flink集群有哪些角色？各自有什么作用？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-4-Flink%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.14.4 Flink的编程模型是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-5-%E5%85%AC%E5%8F%B8%E6%80%8E%E4%B9%88%E6%8F%90%E4%BA%A4%E7%9A%84%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%9C%89%E5%A4%9A%E5%B0%91Job-Manager%EF%BC%9F-%E6%9C%89%E5%A4%9A%E5%B0%91TaskManager%EF%BC%9F\"><span class=\"toc-text\">1.14.5 公司怎么提交的实时任务，有多少Job Manager？ 有多少TaskManager？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-6-Flink%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9FFlink%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6%E8%AE%BE%E7%BD%AE%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">1.14.6 Flink的并行度了解吗？Flink的并行度设置是怎样的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-7-Flink%E7%9A%84keyby%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%8C%BA%EF%BC%9F%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.14.7 Flink的keyby怎么实现的分区？分区、分组的区别是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-8-Flink%E7%9A%84interval-join%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9Fjoin%E4%B8%8D%E4%B8%8A%E7%9A%84%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">1.14.8 Flink的interval join的实现原理？join不上的怎么办？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-9-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BFlink%E7%9A%84%E7%8A%B6%E6%80%81%E7%BC%96%E7%A8%8B%E3%80%81%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">1.14.9 介绍一下Flink的状态编程、状态机制？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-10-Flink%E7%9A%84%E4%B8%89%E7%A7%8D%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89\"><span class=\"toc-text\">1.14.10 Flink的三种时间语义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-11-Flink-%E4%B8%AD%E7%9A%84Watermark%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1.14.11 Flink 中的Watermark机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-12-Watermark%E6%98%AF%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BC%A0%E9%80%92%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">1.14.12 Watermark是数据吗？怎么生成的？怎么传递的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-13-Watermark%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">1.14.13 Watermark的生成方式？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-14-%E8%AF%B4%E8%AF%B4Flink%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%EF%BC%88%E5%88%86%E7%B1%BB%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E8%A7%A6%E5%8F%91%E3%80%81%E5%88%92%E5%88%86%EF%BC%89\"><span class=\"toc-text\">1.14.14 说说Flink中的窗口（分类、生命周期、触发、划分）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-15-Exactly-Once%E7%9A%84%E4%BF%9D%E8%AF%81\"><span class=\"toc-text\">1.14.15 Exactly-Once的保证</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-16-Flink%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.14.16 Flink分布式快照的原理是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-17-Checkpoint%E7%9A%84%E5%8F%82%E6%95%B0%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">1.14.17 Checkpoint的参数怎么设置的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-18-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BFlink%E7%9A%84CEP%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1.14.18 介绍一下Flink的CEP机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-19-Flink-CEP-%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%BD%93%E7%8A%B6%E6%80%81%E6%B2%A1%E6%9C%89%E5%88%B0%E8%BE%BE%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F\"><span class=\"toc-text\">1.14.19 Flink CEP 编程中当状态没有到达的时候会将数据保存在哪里？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-20-Flink-SQL%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">1.14.20 Flink SQL的工作机制？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-21-FlinkSQL%E6%80%8E%E4%B9%88%E5%AF%B9SQL%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">1.14.21 FlinkSQL怎么对SQL语句进行优化的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-22-Flink%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E3%80%81%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E3%80%81%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.14.22 Flink提交流程、组件通讯、调度机制、任务执行、内存模型（重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-23-Flink%E4%BC%98%E5%8C%96%E3%80%81%E8%83%8C%E5%8E%8B%E3%80%81%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">1.14.23 Flink优化、背压、数据倾斜（重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-14-24-Flink%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%B4%E8%A1%A8Join%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">1.14.24 Flink常见的维表Join方案</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC2%E7%AB%A0-%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">第2章 项目架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E6%8F%90%E9%AB%98%E8%87%AA%E4%BF%A1\"><span class=\"toc-text\">2.1 提高自信</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E6%95%B0%E4%BB%93%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.2 数仓概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">2.3 系统数据流程设计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%A1%86%E6%9E%B6%E7%89%88%E6%9C%AC%E9%80%89%E5%9E%8B\"><span class=\"toc-text\">2.4 框架版本选型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B\"><span class=\"toc-text\">2.5 服务器选型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1\"><span class=\"toc-text\">2.6 集群规模</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-%E4%BA%BA%E5%91%98%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83\"><span class=\"toc-text\">2.7 人员配置参考</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-7-1-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">2.7.1 整体架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-7-2-%E4%BD%A0%E4%BB%AC%E9%83%A8%E9%97%A8%E7%9A%84%E8%81%8C%E7%BA%A7%E7%AD%89%E7%BA%A7%EF%BC%8C%E6%99%8B%E5%8D%87%E8%A7%84%E5%88%99\"><span class=\"toc-text\">2.7.2 你们部门的职级等级，晋升规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-7-3-%E4%BA%BA%E5%91%98%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83\"><span class=\"toc-text\">2.7.3 人员配置参考</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82\"><span class=\"toc-text\">第3章 数仓分层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%BB%BA%E6%A8%A1%EF%BC%88%E7%BB%9D%E5%AF%B9%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">3.1 数据仓库建模（绝对重点）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-1-%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">3.1.1 建模工具是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-ODS%E5%B1%82\"><span class=\"toc-text\">3.1.2 ODS层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-3-DWD%E5%B1%82\"><span class=\"toc-text\">3.1.3 DWD层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-4-DWS%E5%B1%82\"><span class=\"toc-text\">3.1.4 DWS层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-5-DWT%E5%B1%82\"><span class=\"toc-text\">3.1.5 DWT层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-6-ADS%E5%B1%82\"><span class=\"toc-text\">3.1.6 ADS层</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-ODS%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%EF%BC%9F\"><span class=\"toc-text\">3.2 ODS层做了哪些事？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-DWD%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%EF%BC%9F\"><span class=\"toc-text\">3.3 DWD层做了哪些事？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97\"><span class=\"toc-text\">3.3.1 数据清洗</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-%E6%B8%85%E6%B4%97%E7%9A%84%E6%89%8B%E6%AE%B5\"><span class=\"toc-text\">3.3.2 清洗的手段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-3-%E6%B8%85%E6%B4%97%E6%8E%89%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%E7%AE%97%E5%90%88%E7%90%86\"><span class=\"toc-text\">3.3.3 清洗掉多少数据算合理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-4-%E8%84%B1%E6%95%8F\"><span class=\"toc-text\">3.3.4 脱敏</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-5-%E7%BB%B4%E5%BA%A6%E9%80%80%E5%8C%96\"><span class=\"toc-text\">3.3.5 维度退化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-6-%E5%8E%8B%E7%BC%A9LZO\"><span class=\"toc-text\">3.3.6 压缩LZO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-7-%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8parquet\"><span class=\"toc-text\">3.3.7 列式存储parquet</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-DWS%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%EF%BC%9F\"><span class=\"toc-text\">3.4 DWS层做了哪些事？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-1-DWS%E5%B1%82%E6%9C%896%E5%BC%A0%E5%AE%BD%E8%A1%A8%EF%BC%88%E5%A4%84%E7%90%86100-200%E4%B8%AA%E6%8C%87%E6%A0%87-70-%E4%BB%A5%E4%B8%8A%E7%9A%84%E9%9C%80%E6%B1%82%EF%BC%89\"><span class=\"toc-text\">3.4.1 DWS层有6张宽表（处理100-200个指标 70%以上的需求）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-2-%E5%93%AA%E4%B8%AA%E5%AE%BD%E8%A1%A8%E6%9C%80%E5%AE%BD%EF%BC%9F%E5%A4%A7%E6%A6%82%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%9F\"><span class=\"toc-text\">3.4.2 哪个宽表最宽？大概有多少个字段？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-3-%E5%85%B7%E4%BD%93%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%AE%BD%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">3.4.3 具体用户行为宽表字段名称</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-4-%E5%93%AA%E5%BC%A0%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E6%9C%80%E5%A4%9A\"><span class=\"toc-text\">3.4.4 哪张表数据量最多</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-ADS%E5%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E5%93%AA%E4%BA%9B%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">3.5 ADS层分析过哪些指标</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-1-%E5%88%86%E6%9E%90%E8%BF%87%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%88%E4%B8%80%E5%88%86%E9%92%9F%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA30%E4%B8%AA%E6%8C%87%E6%A0%87%EF%BC%89\"><span class=\"toc-text\">3.5.1 分析过的指标（一分钟至少说出30个指标）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-2-%E7%95%99%E8%BD%ACG%E5%A4%8D%E6%B4%BB%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">3.5.2 留转G复活指标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-3-%E5%93%AA%E4%B8%AA%E5%95%86%E5%93%81%E5%8D%96%E7%9A%84%E5%A5%BD%EF%BC%9F\"><span class=\"toc-text\">3.5.3 哪个商品卖的好？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-ADS%E5%B1%82%E6%89%8B%E5%86%99%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">3.6 ADS层手写指标</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-1-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E7%94%A8%E6%88%B7%E6%B4%BB%E8%B7%83%EF%BC%9F\"><span class=\"toc-text\">3.6.1 如何分析用户活跃？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-2-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E7%94%A8%E6%88%B7%E6%96%B0%E5%A2%9E%EF%BC%9Fvivo\"><span class=\"toc-text\">3.6.2 如何分析用户新增？vivo</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-3-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E7%94%A8%E6%88%B71%E5%A4%A9%E7%95%99%E5%AD%98%EF%BC%9F\"><span class=\"toc-text\">3.6.3 如何分析用户1天留存？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-4-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%B2%89%E9%BB%98%E7%94%A8%E6%88%B7%EF%BC%9F\"><span class=\"toc-text\">3.6.4 如何分析沉默用户？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-5-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%9C%AC%E5%91%A8%E5%9B%9E%E6%B5%81%E7%94%A8%E6%88%B7%EF%BC%9F\"><span class=\"toc-text\">3.6.5 如何分析本周回流用户？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-6-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%B5%81%E5%A4%B1%E7%94%A8%E6%88%B7%EF%BC%9F\"><span class=\"toc-text\">3.6.6 如何分析流失用户？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-7-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%9C%80%E8%BF%91%E8%BF%9E%E7%BB%AD3%E5%91%A8%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">3.6.7 如何分析最近连续3周活跃用户数？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-8-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%9C%80%E8%BF%91%E4%B8%83%E5%A4%A9%E5%86%85%E8%BF%9E%E7%BB%AD%E4%B8%89%E5%A4%A9%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">3.6.8 如何分析最近七天内连续三天活跃用户数？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7-%E5%88%86%E6%9E%90%E8%BF%87%E6%9C%80%E9%9A%BE%E7%9A%84%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">3.7 分析过最难的指标</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-1-%E6%9C%80%E8%BF%91%E8%BF%9E%E7%BB%AD3%E5%91%A8%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7\"><span class=\"toc-text\">3.7.1 最近连续3周活跃用户</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-2-%E6%9C%80%E8%BF%917%E5%A4%A9%E8%BF%9E%E7%BB%AD3%E5%A4%A9%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E6%95%B0\"><span class=\"toc-text\">3.7.2 最近7天连续3天活跃用户数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-3-%E8%BF%90%E8%B4%B9%E5%88%86%E6%91%8A\"><span class=\"toc-text\">3.7.3 运费分摊</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-4-%E5%9F%8E%E5%B8%82%E5%A4%87%E6%B3%A8\"><span class=\"toc-text\">3.7.4 城市备注</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC4%E7%AB%A0-%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E2%80%94%E4%B8%9A%E5%8A%A1\"><span class=\"toc-text\">第4章 生产经验—业务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E7%94%B5%E5%95%86%E5%B8%B8%E8%AF%86\"><span class=\"toc-text\">4.1 电商常识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-1-SKU%E5%92%8CSPU\"><span class=\"toc-text\">4.1.1 SKU和SPU</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-2-%E8%AE%A2%E5%8D%95%E8%A1%A8%E8%B7%9F%E8%AE%A2%E5%8D%95%E8%AF%A6%E6%83%85%E8%A1%A8%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">4.1.2 订单表跟订单详情表区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E5%9F%8B%E7%82%B9%E8%A1%8C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%AD%97%E6%AE%B5%EF%BC%89\"><span class=\"toc-text\">4.2 埋点行为数据基本格式（基本字段）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-1-%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">4.2.1 页面</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-2-%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">4.2.2 事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-3-%E6%9B%9D%E5%85%89\"><span class=\"toc-text\">4.2.3 曝光</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-4-%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">4.2.4 启动</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-5-%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">4.2.5 错误</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-6-%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AE%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">4.2.6 埋点数据日志格式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">4.3 电商业务流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E7%BB%B4%E5%BA%A6%E8%A1%A8%E5%92%8C%E4%BA%8B%E5%AE%9E%E8%A1%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">4.4 维度表和事实表（重点）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-1-%E7%BB%B4%E5%BA%A6%E8%A1%A8\"><span class=\"toc-text\">4.4.1 维度表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-2-%E4%BA%8B%E5%AE%9E%E8%A1%A8\"><span class=\"toc-text\">4.4.2 事实表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">4.5 同步策略（重点）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E7%90%86%E8%AE%BA%EF%BC%88ER%E5%BB%BA%E6%A8%A1%EF%BC%89\"><span class=\"toc-text\">4.6 关系型数据库范式理论（ER建模）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">4.7 数据模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-8-%E6%8B%89%E9%93%BE%E8%A1%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">4.8 拉链表（重点）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-9-%E5%8D%B3%E5%B8%AD%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">4.9 即席查询数据仓库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-10-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%AF%8F%E5%A4%A9%E8%B7%91%E5%A4%9A%E5%B0%91%E5%BC%A0%E8%A1%A8%EF%BC%8C%E5%A4%A7%E6%A6%82%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B9%85%EF%BC%9F\"><span class=\"toc-text\">4.10 数据仓库每天跑多少张表，大概什么时候运行，运行多久？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-11-%E6%B4%BB%E5%8A%A8%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%87%8F%E4%BC%9A%E5%A2%9E%E5%8A%A0%E5%A4%9A%E5%B0%91%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F\"><span class=\"toc-text\">4.11 活动的话，数据量会增加多少？怎么解决？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-12-%E5%B9%B6%E5%8F%91%E5%B3%B0%E5%80%BC%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%A4%A7%E6%A6%82%E5%93%AA%E4%B8%AA%E6%97%B6%E9%97%B4%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">4.12 并发峰值多少？大概哪个时间点？ </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-13-%E6%95%B0%E4%BB%93%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">4.13 数仓中使用的哪种文件存储格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-14-%E5%93%AA%E5%BC%A0%E8%A1%A8%E6%9C%80%E8%B4%B9%E6%97%B6%E9%97%B4%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">4.14 哪张表最费时间，有没有优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-14-%E5%93%AA%E5%BC%A0%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E6%9C%80%E5%A4%A7%EF%BC%8C%E6%98%AF%E5%A4%9A%E5%B0%91\"><span class=\"toc-text\">4.14 哪张表数据量最大，是多少</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-15-%E7%94%A8%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%E5%81%9A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.15 用什么工具做权限管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-16-%E6%95%B0%E4%BB%93%E5%BD%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%A4%9A%E4%B9%85%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1\"><span class=\"toc-text\">4.16 数仓当中数据多久删除一次</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC5%E7%AB%A0-%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E2%80%93%E6%B5%8B%E8%AF%95%E4%B8%8A%E7%BA%BF%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">第5章 生产经验–测试上线相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">5.1 测试相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-1-%E5%85%AC%E5%8F%B8%E6%9C%89%E5%A4%9A%E5%B0%91%E5%8F%B0%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">5.1.1 公司有多少台测试服务器？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-2-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E4%BB%80%E4%B9%88%E6%A0%B7%EF%BC%9F\"><span class=\"toc-text\">5.1.2 测试环境什么样？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-3-%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%93%AA%E6%9D%A5%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">5.1.3 测试数据哪来的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-4-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%99%E7%9A%84sql%E6%AD%A3%E7%A1%AE%E6%80%A7%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">5.1.4 如何保证写的sql正确性（重点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-5-%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%EF%BC%9F\"><span class=\"toc-text\">5.1.5 测试之后如何上线？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%99%85%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">5.2 项目实际工作流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82%E5%A4%A7%E6%A6%82%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">5.3 项目中实现一个需求大概多长时间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-%E9%A1%B9%E7%9B%AE%E5%9C%A83%E5%B9%B4%E5%86%85%E8%BF%AD%E4%BB%A3%E6%AC%A1%E6%95%B0%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%85%B7%E4%BD%93%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%AD%E4%BB%A3%E7%9A%84%E3%80%82%E5%85%AC%E5%8F%B8%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E5%A4%9A%E4%B9%85%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%88%B0%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">5.4 项目在3年内迭代次数，每一个项目具体是如何迭代的。公司版本迭代多久一次，迭代到哪个版本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E6%AF%8F%E5%A4%A9%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B\"><span class=\"toc-text\">5.5 项目开发中每天做什么事</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-6-%E5%AE%9E%E6%97%B6%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">5.6 实时项目数据计算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-6-1-%E8%B7%91%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8CCPU%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">5.6.1 跑实时任务，怎么分配内存和CPU资源</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-6-2-%E8%B7%91%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%AF%8F%E5%A4%A9%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%9A%E5%B0%91%EF%BC%9F\"><span class=\"toc-text\">5.6.2 跑实时任务，每天数据量多少？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC6%E7%AB%A0-%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E2%80%94%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">第6章 生产经验—技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E8%A1%A8%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">6.1 可视化报表工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">6.2 集群监控工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%88%E9%87%8D%E7%82%B9-%EF%BC%89\"><span class=\"toc-text\">6.3 项目中遇到的问题怎么解决的（重点*****）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-4-Linux-Shell-Hadoop-ZK-Flume-kafka-Hive-Sqoop-Azkaban%E9%82%A3%E4%BA%9B%E4%BA%8B\"><span class=\"toc-text\">6.4 Linux+Shell+Hadoop+ZK+Flume+kafka+Hive+Sqoop+Azkaban那些事</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC7%E7%AB%A0-%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E2%80%94%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">第7章 生产经验—热点问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%88Atlas%E8%A1%80%E7%BC%98%E7%B3%BB%E7%BB%9F%EF%BC%89\"><span class=\"toc-text\">7.1 元数据管理（Atlas血缘系统）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%8E%A7%EF%BC%88Griffin%EF%BC%89\"><span class=\"toc-text\">7.2 数据质量监控（Griffin）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-1-%E7%9B%91%E6%8E%A7%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">7.2.1 监控原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-2-%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">7.2.2 数据质量实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%EF%BC%88Ranger%EF%BC%89\"><span class=\"toc-text\">7.3 权限管理（Ranger）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-4-%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86\"><span class=\"toc-text\">7.4 数据治理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-5-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0\"><span class=\"toc-text\">7.5 数据中台</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E5%8F%B0%EF%BC%9F\"><span class=\"toc-text\">7.5.1 什么是中台？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-5-2-%E4%BC%A0%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%97%9B%E7%82%B9\"><span class=\"toc-text\">7.5.2 传统项目痛点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-5-3-%E5%90%84%E5%AE%B6%E4%B8%AD%E5%8F%B0\"><span class=\"toc-text\">7.5.3 各家中台</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-5-4-%E4%B8%AD%E5%8F%B0%E5%85%B7%E4%BD%93%E5%88%92%E5%88%86\"><span class=\"toc-text\">7.5.4 中台具体划分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-5-5-%E4%B8%AD%E5%8F%B0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">7.5.5 中台使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-6-%E6%95%B0%E6%8D%AE%E6%B9%96\"><span class=\"toc-text\">7.6 数据湖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-7-%E5%9F%8B%E7%82%B9\"><span class=\"toc-text\">7.7 埋点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-8-%E7%94%B5%E5%95%86%E8%BF%90%E8%90%A5%E7%BB%8F%E9%AA%8C\"><span class=\"toc-text\">7.8 电商运营经验</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-8-1-%E7%94%B5%E5%95%868%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">7.8.1 电商8类基本指标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-8-2-%E7%9B%B4%E6%92%AD%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">7.8.2 直播指标</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC8%E7%AB%A0-%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">第8章 实时数仓项目</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-1-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%88%B0ods%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B\"><span class=\"toc-text\">8.1 数据采集到ods层做了哪些事</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-1-1-%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9%E7%9A%84%E8%A1%8C%E4%B8%BA%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E9%87%87%E9%9B%86%E4%B8%80%E4%BB%BD%EF%BC%9F\"><span class=\"toc-text\">8.1.1 前端埋点的行为数据为什么又采集一份？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-1-2%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9kafka%EF%BC%9F\"><span class=\"toc-text\">8.1.2为什么选择kafka？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-1-3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8maxwell%EF%BC%9F%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">8.1.3为什么用maxwell？历史数据同步怎么保证一致性？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-1-4-kafka%E4%BF%9D%E5%AD%98%E5%A4%9A%E4%B9%85%EF%BC%9F%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E4%BB%A5%E5%89%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\"><span class=\"toc-text\">8.1.4 kafka保存多久？如果需要以前的数据怎么办？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-2-ods%E5%B1%82\"><span class=\"toc-text\">8.2 ods层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-3-dwd-dim%E5%B1%82\"><span class=\"toc-text\">8.3 dwd+dim层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3-1-%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%B4%E5%BA%A6%E8%A1%A8%E5%AD%98Hbase%EF%BC%9F\"><span class=\"toc-text\">8.3.1 存储位置，为什么维度表存Hbase？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3-2-%E5%9F%8B%E7%82%B9%E8%A1%8C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%88%86%E6%B5%81\"><span class=\"toc-text\">8.3.2 埋点行为数据分流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3-3-%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%8A%A8%E6%80%81%E5%88%86%E6%B5%81\"><span class=\"toc-text\">8.3.3 业务数据动态分流</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-4-dwm%E5%B1%82\"><span class=\"toc-text\">8.4 dwm层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E4%B8%80%E4%B8%AAdwm%E5%B1%82%EF%BC%9F\"><span class=\"toc-text\">8.4.1 为什么要加一个dwm层？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-2-%E4%BA%8B%E5%AE%9E%E8%A1%A8%E4%B8%8E%E4%BA%8B%E5%AE%9E%E8%A1%A8join\"><span class=\"toc-text\">8.4.2 事实表与事实表join</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-3-%E4%BA%8B%E5%AE%9E%E8%A1%A8%E4%B8%8E%E7%BB%B4%E5%BA%A6%E8%A1%A8join\"><span class=\"toc-text\">8.4.3 事实表与维度表join</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-4%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7\"><span class=\"toc-text\">8.4.4怎么保证缓存一致性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-5-dws%E5%B1%82\"><span class=\"toc-text\">8.5 dws层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9ClickHouse\"><span class=\"toc-text\">8.5.1 为什么选择ClickHouse</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-5-2-%E8%BD%BB%E5%BA%A6%E8%81%9A%E5%90%88\"><span class=\"toc-text\">8.5.2 轻度聚合</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-6-ads%E5%B1%82\"><span class=\"toc-text\">8.6 ads层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-6-1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">8.6.1 实现方案</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-6-2-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81ClickHouse%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">8.6.2 怎么保证ClickHouse的一致性？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-7-%E7%9B%91%E6%8E%A7\"><span class=\"toc-text\">8.7 监控</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC9%E7%AB%A0-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">第9章 手写代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">9.1 基本算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">9.1.1 冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">9.1.2 二分查找</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-3-%E5%BF%AB%E6%8E%92\"><span class=\"toc-text\">9.1.3 快排</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-4-%E5%BD%92%E5%B9%B6\"><span class=\"toc-text\">9.1.4 归并</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8BScala%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">9.1.5 二叉树之Scala实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">9.2 开发代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-2-1-%E6%89%8B%E5%86%99Spark-WordCount\"><span class=\"toc-text\">9.2.1 手写Spark-WordCount</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-3-%E6%89%8B%E5%86%99HQL\"><span class=\"toc-text\">9.3 手写HQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-1-%E6%89%8B%E5%86%99HQL-%E7%AC%AC1%E9%A2%98\"><span class=\"toc-text\">9.3.1 手写HQL 第1题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-2-%E6%89%8B%E5%86%99HQL-%E7%AC%AC2%E9%A2%98\"><span class=\"toc-text\">9.3.2 手写HQL 第2题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-3-%E6%89%8B%E5%86%99HQL-%E7%AC%AC3%E9%A2%98\"><span class=\"toc-text\">9.3.3 手写HQL 第3题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-4-%E6%89%8B%E5%86%99HQL-%E7%AC%AC4%E9%A2%98\"><span class=\"toc-text\">9.3.4 手写HQL 第4题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-5-%E6%89%8B%E5%86%99HQL-%E7%AC%AC5%E9%A2%98\"><span class=\"toc-text\">9.3.5 手写HQL 第5题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-6-%E6%89%8B%E5%86%99HQL-%E7%AC%AC6%E9%A2%98\"><span class=\"toc-text\">9.3.6 手写HQL 第6题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-7-%E6%89%8B%E5%86%99HQL-%E7%AC%AC7%E9%A2%98\"><span class=\"toc-text\">9.3.7 手写HQL 第7题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-8-%E6%89%8B%E5%86%99SQL-%E7%AC%AC8%E9%A2%98\"><span class=\"toc-text\">9.3.8 手写SQL 第8题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-9-%E6%89%8B%E5%86%99HQL-%E7%AC%AC9%E9%A2%98\"><span class=\"toc-text\">9.3.9 手写HQL 第9题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-10-%E6%89%8B%E5%86%99HQL-%E7%AC%AC10%E9%A2%98\"><span class=\"toc-text\">9.3.10 手写HQL 第10题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-11-%E6%89%8B%E5%86%99HQL-%E7%AC%AC11%E9%A2%98\"><span class=\"toc-text\">9.3.11 手写HQL 第11题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-12-%E8%BF%9E%E7%BB%AD%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">9.3.12 连续问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-13-%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">9.3.13 分组问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-14-%E9%97%B4%E9%9A%94%E8%BF%9E%E7%BB%AD%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">9.3.14 间隔连续问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-15-%E6%89%93%E6%8A%98%E6%97%A5%E6%9C%9F%E4%BA%A4%E5%8F%89%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">9.3.15 打折日期交叉问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-16-%E5%90%8C%E6%97%B6%E5%9C%A8%E7%BA%BF%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">9.3.16 同时在线问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC10%E7%AB%A0-JavaSE\"><span class=\"toc-text\">第10章 JavaSE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-1-HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">10.1 HashMap底层源码，数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-2-Java%E8%87%AA%E5%B8%A6%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F\"><span class=\"toc-text\">10.2 Java自带哪几种线程池？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-3-HashMap%E5%92%8CHashTable%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">10.3 HashMap和HashTable区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-4-TreeSet%E5%92%8CHashSet%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">10.4 TreeSet和HashSet区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-5-String-buffer%E5%92%8CString-build%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">10.5 String buffer和String build区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-6-Final%E3%80%81Finally%E3%80%81Finalize\"><span class=\"toc-text\">10.6 Final、Finally、Finalize</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-7-x3D-x3D-%E5%92%8CEquals%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">10.7 &#x3D;&#x3D;和Equals区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC11%E7%AB%A0-Redis\"><span class=\"toc-text\">第11章 Redis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF\"><span class=\"toc-text\">11.1 缓存穿透、缓存雪崩、缓存击穿</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-2-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">11.2 哨兵模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">10.3 数据类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-4-%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">11.4 持久化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-5-%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\">11.5 悲观锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-6-%E4%B9%90%E8%A7%82%E9%94%81\"><span class=\"toc-text\">11.6 乐观锁</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC12%E7%AB%A0-MySql\"><span class=\"toc-text\">第12章 MySql</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-1-MyISAM%E4%B8%8EInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">12.1 MyISAM与InnoDB的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-2-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">12.2 索引优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-3-b-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">12.3 b-tree和b+tree的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-4-redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB\"><span class=\"toc-text\">12.4 redis是单线程的，为什么那么快</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-5-MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">12.5 MySQL的事务</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC13%E7%AB%A0-JVM\"><span class=\"toc-text\">第13章 JVM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-1-JVM%E5%86%85%E5%AD%98%E5%88%86%E5%93%AA%E5%87%A0%E4%B8%AA%E5%8C%BA%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">13.1 JVM内存分哪几个区，每个区的作用是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-2-Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">13.2 Java类加载过程?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-3-java%E4%B8%AD%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">13.3 java中垃圾收集的方法有哪些?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-4-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB-%E6%88%96%E8%80%85GC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">13.4 如何判断一个对象是否存活?(或者GC对象的判定方法)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-5-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">13.5 什么是类加载器，类加载器有哪些?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-6-%E7%AE%80%E8%BF%B0Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8AMinor-GC%E5%92%8CMajor-GC%EF%BC%88full-GC%EF%BC%89\"><span class=\"toc-text\">13.6 简述Java内存分配与回收策略以及Minor GC和Major GC（full GC）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC14%E7%AB%A0-JUC\"><span class=\"toc-text\">第14章 JUC</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC15%E7%AB%A0-%E9%9D%A2%E8%AF%95%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">第15章 面试说明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-1-%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B%E6%9C%80%E5%85%B3%E9%94%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">15.1 面试过程最关键的是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-2-%E9%9D%A2%E8%AF%95%E6%97%B6%E8%AF%A5%E6%80%8E%E4%B9%88%E8%AF%B4%EF%BC%9F\"><span class=\"toc-text\">15.2 面试时该怎么说？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-3-%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">15.3 面试技巧</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-3-1-%E5%85%AD%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">15.3.1 六个常见问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-3-2-%E4%B8%A4%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">15.3.2 两个注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-3-3-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%EF%BC%88%E6%8E%A7%E5%88%B6%E5%9C%A84%E5%88%86%E5%8D%8A%E4%BB%A5%E5%86%85%EF%BC%8C%E4%B8%8D%E8%B6%85%E8%BF%875%E5%88%86%E9%92%9F%EF%BC%89\"><span class=\"toc-text\">15.3.3 自我介绍（控制在4分半以内，不超过5分钟）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC16%E7%AB%A0-LeetCode%E9%A2%98%E7%9B%AE%E7%B2%BE%E9%80%89\"><span class=\"toc-text\">第16章 LeetCode题目精选</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">16.1 两数之和</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-1-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.1.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-1-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.1.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-2-%E7%88%AC%E6%A5%BC%E6%A2%AF\"><span class=\"toc-text\">16.2 爬楼梯</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-2-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.2.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-2-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.2.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-3-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">16.3 翻转二叉树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-3-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.3.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-3-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.3.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-4-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">16.4 反转链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-4-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.4.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-4-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.4.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-5-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">16.5 LRU缓存机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-5-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.5.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-5-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.5.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-6-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2\"><span class=\"toc-text\">16.6 最长回文子串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-6-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.6.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-6-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.6.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-7-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7\"><span class=\"toc-text\">16.7 有效的括号</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-7-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.7.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-7-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.7.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-8-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">16.8 数组中的第K个最大元素</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-8-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.8.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-8-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.8.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-9-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91\"><span class=\"toc-text\">16.9 实现 Trie (前缀树)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-9-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.9.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-9-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.9.2 参考答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-10-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB\"><span class=\"toc-text\">16.10 编辑距离</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-10-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">16.10.1 问题描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-10-2-%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">16.10.2 参考答案</span></a></li></ol></li></ol></li></ol>","author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"学Netty-黑马满哥","uid":"ab3568622c7f6e7ae567a8af8514c4cd","slug":"学Netty-黑马满哥","date":"2022-04-26T14:11:41.000Z","updated":"2022-08-22T08:05:45.171Z","comments":true,"path":"api/articles/学Netty-黑马满哥.json","keywords":null,"cover":"http://p9.qhimg.com/bdm/960_593_0/t01747d916d50e11a77.jpg","text":"黑马Netty：https://www.bilibili.com/video/BV1py4y1E7oA 学Netty，建议看黑马Netty教程。然后尚硅谷Netty课的Protobuf, DubboRPC等案例就可以了。 尚硅谷-韩顺平：https://www.bilibili....","link":"","photos":[],"count_time":{"symbolsCount":"317k","symbolsTime":"4:48"},"categories":[{"name":"Netty","slug":"Netty","count":1,"path":"api/categories/Netty.json"}],"tags":[{"name":"Netty","slug":"Netty","count":1,"path":"api/tags/Netty.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"TiKV学习","uid":"b4b469edf0864513cb59986e5c3c8faf","slug":"TiKV学习","date":"2021-12-17T03:10:40.000Z","updated":"2022-08-22T07:58:37.485Z","comments":true,"path":"api/articles/TiKV学习.json","keywords":null,"cover":"http://p7.qhimg.com/bdm/960_593_0/t0126965e612a7835ac.jpg","text":"[TOC] 开源 $ git config –global http.sslBackend “openssl” $ git config –global http.sslCAInfo “D:&#x2F;Software&#x2F;Program Files&#x2F;Git&#x...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"分布式存储引擎TiKV","slug":"分布式存储引擎TiKV","count":1,"path":"api/categories/分布式存储引擎TiKV.json"}],"tags":[{"name":"TiKV","slug":"TiKV","count":1,"path":"api/tags/TiKV.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}