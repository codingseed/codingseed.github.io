{"title":"yxc_share模板","uid":"5c08fcc79221f552ac38df01c4301f35","slug":"yxc-share模板","date":"2020-04-16T14:45:44.000Z","updated":"2022-08-22T08:02:59.839Z","comments":true,"path":"api/articles/yxc-share模板.json","keywords":null,"cover":"http://p2.qhimg.com/bdm/960_593_0/t0170f576586b06c9f4.jpg","content":"<p>日本信奥网站 Atcoder AGC 思维难度 训练思维 Complexity:AGC 的 D 题<br>《计算概论》，华东师范大学第二附属中学 chen_zhe<br>hzwer 发起的的 shareOI、OI Wiki、Loj 与 Uoj、洛谷的集训队 50 题<br>用洛谷的RemoteJudge去评测这些题目（部分带有翻译，需要先绑定UvaOJ账号），体验会好一些，提升刷题效率 CodeForces SPOJ AtCoder UVA<br>欧拉计划<br>OI-Wiki</p>\n<hr>\n<h1 id=\"《C-之-unordered-map——哈希表》\"><a href=\"#《C-之-unordered-map——哈希表》\" class=\"headerlink\" title=\"《C++ 之 unordered_map——哈希表》\"></a>《C++ 之 unordered_map——哈希表》</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">unordered_map是C++中的哈希表，可以在任意类型与类型之间做映射。\n\n基本操作\n引用头文件(C++11)：#include &lt;unordered_map&gt;\n定义：unordered_map&lt;int,int&gt;、unordered_map&lt;string, double&gt; ...\n插入：例如将(&quot;ABC&quot; -&gt; 5.45) 插入unordered_map&lt;string, double&gt; hash中，hash[&quot;ABC&quot;]&#x3D;5.45\n查询：hash[&quot;ABC&quot;]会返回5.45\n判断key是否存在：hash.count(&quot;ABC&quot;) !&#x3D; 0 或 hash.find(&quot;ABC&quot;) !&#x3D; hash.end()\n遍历\nfor (auto &amp;item : hash)\n&#123;\n    cout &lt;&lt; item.first &lt;&lt; &#39; &#39; &lt;&lt; item.second &lt;&lt; endl;\n&#125;\n或\n\nfor (unordered_map&lt;string, double&gt;::iterator it &#x3D; hash.begin(); it !&#x3D; hash.end(); it ++ )\n&#123;\n    cout &lt;&lt; it-&gt;first &lt;&lt; &#39; &#39; &lt;&lt; it-&gt;second &lt;&lt; endl;\n&#125;\n进阶操作\n如果想让自定义的class作为key（unordered_map&lt;key,value&gt;）来使用unordered_map，需要实现：\n(1) 哈希函数，需要实现一个class重载operator()，将自定义class变量映射到一个size_t类型的数。一般常用std::hash模板来实现。\n(2) 判断两个自定义class类型的变量是否相等的函数，一般在自定义class里重载operator&#x3D;&#x3D;。\n示例代码：\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nclass Myclass\n&#123;\npublic:\n    int first;\n    vector&lt;int&gt; second;\n\n    &#x2F;&#x2F; 重载等号，判断两个Myclass类型的变量是否相等\n    bool operator&#x3D;&#x3D; (const Myclass &amp;other) const\n    &#123;\n        return first &#x3D;&#x3D; other.first &amp;&amp; second &#x3D;&#x3D; other.second;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 实现Myclass类的hash函数\nnamespace std\n&#123;\n    template &lt;&gt;\n    struct hash&lt;Myclass&gt;\n    &#123;\n        size_t operator()(const Myclass &amp;k) const\n        &#123;\n            int h &#x3D; k.first;\n            for (auto x : k.second)\n            &#123;\n                h ^&#x3D; x;\n            &#125;\n            return h;\n        &#125;\n    &#125;;\n&#125;\n\nint main()\n&#123;\n    unordered_map&lt;Myclass, double&gt; S;\n    Myclass a &#x3D; &#123; 2, &#123;3, 4&#125; &#125;;\n    Myclass b &#x3D; &#123; 3, &#123;1, 2, 3, 4&#125; &#125;;\n    S[a] &#x3D; 2.5;\n    S[b] &#x3D; 3.123;\n    cout &lt;&lt; S[a] &lt;&lt; &#39; &#39; &lt;&lt; S[b] &lt;&lt; endl;\n    return 0;\n&#125;\n输出:\n\n2.5 3.123\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;9&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n<h1 id=\"《由数据范围反推算法复杂度以及算法内容》\"><a href=\"#《由数据范围反推算法复杂度以及算法内容》\" class=\"headerlink\" title=\"《由数据范围反推算法复杂度以及算法内容》\"></a>《由数据范围反推算法复杂度以及算法内容》</h1><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 10^7 为最佳。</p>\n<p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>\n<p>n≤30, 指数级别, dfs+剪枝，状态压缩dp<br>n≤100 &#x3D;&gt; O(n^3)，floyd，dp<br>n≤1000 &#x3D;&gt; O(n^2)，O(n^2<em>logn)，dp，二分<br>n≤10000 &#x3D;&gt; O(n</em>√n)，块状链表<br>n≤100000 &#x3D;&gt; O(nlogn) &#x3D;&gt; 各种sort，线段树、树状数组、set&#x2F;map、heap、dijkstra+heap、spfa、求凸包、求半平面交、二分<br>n≤1000000 &#x3D;&gt; O(n), 以及常数较小的 O(nlogn) 算法 &#x3D;&gt; hash、双指针扫描、kmp、(Trie)AC自动机，常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa<br>n≤10000000 &#x3D;&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数<br>n≤10^9 &#x3D;&gt; O(√n)，判断质数<br>n≤10^18 &#x3D;&gt; O(logn)，最大公约数</p>\n<hr>\n<h1 id=\"《求解斐波那契数列的若干方法》\"><a href=\"#《求解斐波那契数列的若干方法》\" class=\"headerlink\" title=\"《求解斐波那契数列的若干方法》\"></a>《求解斐波那契数列的若干方法》</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">今天来给大家介绍几个在面试中常用的、求解斐波那契数列问题的方法。\n\n首先定义斐波那契数列问题：\n\n定义 a0&#x3D;1a0&#x3D;1, a1&#x3D;1a1&#x3D;1, an&#x3D;an−1+an−2an&#x3D;an−1+an−2，求 anan 是多少。\n为了避免考虑整数溢出问题，我们求 an%pan%p 的值，p&#x3D;109+7p&#x3D;109+7。\n\n算法1\n递归。\n递归计算的节点个数是 O(2n)O(2n) 的级别的，存在大量重复计算。\n时间复杂度是 O(2n)O(2n)，一秒内大约能算到第三四十项。\n\nC++ 代码\nconst int MOD &#x3D; 1000000007;\nint f(int n)\n&#123;\n    if (n &lt;&#x3D; 1) return 1;\n    return (f(n - 1) + f(n - 2)) % MOD;\n&#125;\n算法2\n记忆化搜索。\n开一个大数组记录中间结果，如果一个状态被计算过，则直接查表，否则再递归计算。\n总共有 nn 个状态，计算每个状态的复杂度是 O(1)O(1)，所以时间复杂度是 O(n)O(n)。\n一秒内算 n&#x3D;107n&#x3D;107 毫无压力，但由于是递归计算，递归层数太多会爆栈，大约只能算到 n&#x3D;105n&#x3D;105 级别。\n\nC++ 代码\nconst int N &#x3D; 100000, MOD &#x3D; 1000000007;\nint a[N];\nint f2(int n)\n&#123;\n    if (a[n]) return a[n];\n    if (n &lt;&#x3D; 1) return 1;\n    a[n] &#x3D; f2(n - 1) + f2(n - 2);\n    a[n] %&#x3D; MOD;\n    return a[n];\n&#125;\n算法3\n递推。\n开一个大数组，记录每个数的值。用循环递推计算。\n总共计算 nn 个状态，所以时间复杂度是 O(n)O(n)。\n但需要开一个长度是 nn 的数组，内存将成为瓶颈，当 n&#x3D;108n&#x3D;108 时，需要的内存是 4∗1081024×1024≈381MB4∗1081024×1024≈381MB。\n分子中乘4是因为C++中 int 类型占4字节。\n\nC++代码\nconst int N &#x3D; 100000000, MOD &#x3D; 1000000007;\nint f3(int n)\n&#123;\n    a[0] &#x3D; a[1] &#x3D; 1;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        a[i] &#x3D; a[i - 1] + a[i - 2];\n        a[i] %&#x3D; MOD;\n    &#125;\n    return a[n];\n&#125;\n算法4\n递归+滚动变量。\n仔细观察我们会发现，递推时我们只需要记录前两项的值即可，没有必要记录所有值，所以我们可以用滚动变量递推。\n时间复杂度还是 O(n)O(n)，但空间复杂度变成了 O(1)O(1)。\n\nC++代码：\nconst int MOD &#x3D; 1000000007;\nint f4(int n)\n&#123;\n    int x, y, z;\n    x &#x3D; y &#x3D; 1;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        z &#x3D; (x + y) % MOD;\n        x &#x3D; y;\n        y &#x3D; z;\n    &#125;\n    return z;\n&#125;\n算法5\n矩阵运算 + 快速幂。\n\n快速幂算法的模板可以参考这里。\n用算法4我们1秒内最多可以算到 108108 级别，那当 nn 更大时该怎么办呢？\n可以先利用矩阵运算的性质将通项公式变成幂次形式，然后用平方倍增（快速幂）的方法求解第 nn 项。\n\n首先我们定义向量\nXn&#x3D;[anan−1],边界：X1&#x3D;[a1a0]\nXn&#x3D;[anan−1],边界：X1&#x3D;[a1a0]\n然后我们可以找出矩阵：\nA&#x3D;[1110]\nA&#x3D;[1110]\n则有：\nXn&#x3D;Xn−1×A\nXn&#x3D;Xn−1×A\n所以：\n\nXn&#x3D;X1×An−1\nXn&#x3D;X1×An−1\n由于矩阵具有结合律，所以我们可以先求出 An−1%PAn−1%P，然后再用 X1X1 左乘，即可求出 XnXn，向量 XnXn 的第一个元素就是 anan。\n\n时间复杂度分析：快速幂的时间复杂度是 O(logn)O(logn)，所以算法5的时间复杂度也是 O(logn)O(logn)。\n\nC++代码\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nconst int MOD &#x3D; 1000000007;\n\nvoid mul(int a[][2], int b[][2], int c[][2])\n&#123;\n    int temp[][2] &#x3D; &#123;&#123;0, 0&#125;, &#123;0, 0&#125;&#125;;\n    for (int i &#x3D; 0; i &lt; 2; i ++ )\n        for (int j &#x3D; 0; j &lt; 2; j ++ )\n            for (int k &#x3D; 0; k &lt; 2; k ++ )\n            &#123;\n                long long x &#x3D; temp[i][j] + (long long)a[i][k] * b[k][j];\n                temp[i][j] &#x3D; x % MOD;\n            &#125;\n    for (int i &#x3D; 0; i &lt; 2; i ++ )\n        for (int j &#x3D; 0; j &lt; 2; j ++ )\n            c[i][j] &#x3D; temp[i][j];\n&#125;\n\n\nint f_final(long long n)\n&#123;\n    int x[2] &#x3D; &#123;1, 1&#125;;\n\n    int res[][2] &#x3D; &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;\n    int t[][2] &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;\n    long long k &#x3D; n - 1;\n    while (k)\n    &#123;\n        if (k&amp;1) mul(res, t, res);\n        mul(t, t, t);\n        k &gt;&gt;&#x3D; 1;\n    &#125;\n\n    int c[2] &#x3D; &#123;0, 0&#125;;\n    for (int i &#x3D; 0; i &lt; 2; i ++ )\n        for (int j &#x3D; 0; j &lt; 2; j ++ )\n        &#123;\n            long long r &#x3D; c[i] + (long long)x[j] * res[j][i];\n            c[i] &#x3D; r % MOD;\n        &#125;\n\n    return c[0];\n&#125;\n\n\nint main()\n&#123;\n    long long n ;\n\n    cin &gt;&gt; n;\n    cout &lt;&lt; f_final(n) &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;25&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<hr>\n<h1 id=\"《常用代码模板1——基础算法》\"><a href=\"#《常用代码模板1——基础算法》\" class=\"headerlink\" title=\"《常用代码模板1——基础算法》\"></a>《常用代码模板1——基础算法》</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">算法基础课相关代码模板\n活动链接 —— 算法基础课\n快速排序算法模板 —— 模板题 AcWing 785. 快速排序\nvoid quick_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    &#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    &#125;\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n&#125;\n归并排序算法模板 —— 模板题 AcWing 787. 归并排序\nvoid merge_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int mid &#x3D; l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];\n        else tmp[k ++ ] &#x3D; q[j ++ ];\n\n    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];\n    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];\n\n    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];\n&#125;\n整数二分算法模板 —— 模板题 AcWing 789. 数的范围\nbool check(int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质\n        else l &#x3D; mid + 1;\n    &#125;\n    return l;\n&#125;\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l &#x3D; mid;\n        else r &#x3D; mid - 1;\n    &#125;\n    return l;\n&#125;\n浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根\nbool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    &#123;\n        double mid &#x3D; (l + r) &#x2F; 2;\n        if (check(mid)) r &#x3D; mid;\n        else l &#x3D; mid;\n    &#125;\n    return l;\n&#125;\n高精度加法 —— 模板题 AcWing 791. 高精度加法\n&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t +&#x3D; A[i];\n        if (i &lt; B.size()) t +&#x3D; B[i];\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    if (t) C.push_back(t);\n    return C;\n&#125;\n高精度减法 —— 模板题 AcWing 792. 高精度减法\n&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t &#x3D; A[i] - t;\n        if (i &lt; B.size()) t -&#x3D; B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t &#x3D; 1;\n        else t &#x3D; 0;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;\n高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法\n&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n&#123;\n    vector&lt;int&gt; C;\n\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )\n    &#123;\n        if (i &lt; A.size()) t +&#x3D; A[i] * b;\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n    return C;\n&#125;\n高精度除以低精度 —— 模板题 AcWing 794. 高精度除法\n&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int&gt; C;\n    r &#x3D; 0;\n    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )\n    &#123;\n        r &#x3D; r * 10 + A[i];\n        C.push_back(r &#x2F; b);\n        r %&#x3D; b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;\n一维前缀和 —— 模板题 AcWing 795. 前缀和\nS[i] &#x3D; a[1] + a[2] + ... a[i]\na[l] + ... + a[r] &#x3D; S[r] - S[l - 1]\n二维前缀和 —— 模板题 AcWing 796. 子矩阵的和\nS[i, j] &#x3D; 第i行j列格子左上部分所有元素的和\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n一维差分 —— 模板题 AcWing 797. 差分\n给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c\n二维差分 —— 模板题 AcWing 798. 差分矩阵\n给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c\n位运算 —— 模板题 AcWing 801. 二进制中1的个数\n求n的第k位数字: n &gt;&gt; k &amp; 1\n返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n\n双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和\nfor (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;\n\n    &#x2F;&#x2F; 具体问题的逻辑\n&#125;\n常见问题分类：\n    (1) 对于一个序列，用两个指针维护一段区间\n    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\n离散化 —— 模板题 AcWing 802. 区间和\nvector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值\nsort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素\n\n&#x2F;&#x2F; 二分求出x对应的离散化的值\nint find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n\n&#125;\n区间合并 —— 模板题 AcWing 803. 区间合并\n&#x2F;&#x2F; 将所有存在交集的区间合并\nvoid merge(vector&lt;PII&gt; &amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n\n    sort(segs.begin(), segs.end());\n\n    int st &#x3D; -2e9, ed &#x3D; -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)\n        &#123;\n            if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n            st &#x3D; seg.first, ed &#x3D; seg.second;\n        &#125;\n        else ed &#x3D; max(ed, seg.second);\n\n    if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n\n    segs &#x3D; res;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;277&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<hr>\n<h1 id=\"《常用代码模板2——数据结构》\"><a href=\"#《常用代码模板2——数据结构》\" class=\"headerlink\" title=\"《常用代码模板2——数据结构》\"></a>《常用代码模板2——数据结构》</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">算法基础课相关代码模板\n活动链接 —— 算法基础课\n单链表 —— 模板题 AcWing 826. 单链表\n&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    head &#x3D; -1;\n    idx &#x3D; 0;\n&#125;\n\n&#x2F;&#x2F; 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head &#x3D; ne[head];\n&#125;\n双链表 —— 模板题 AcWing 827. 双链表\n&#x2F;&#x2F; e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    &#x2F;&#x2F;0是左端点，1是右端点\n    r[0] &#x3D; 1, l[1] &#x3D; 0;\n    idx &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] &#x3D; x;\n    l[idx] &#x3D; a, r[idx] &#x3D; r[a];\n    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] &#x3D; l[a];\n    r[l[a]] &#x3D; r[a];\n&#125;\n栈 —— 模板题 AcWing 828. 模拟栈\n&#x2F;&#x2F; tt表示栈顶\nint stk[N], tt &#x3D; 0;\n\n&#x2F;&#x2F; 向栈顶插入一个数\nstk[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从栈顶弹出一个数\ntt -- ;\n\n&#x2F;&#x2F; 栈顶的值\nstk[tt];\n\n&#x2F;&#x2F; 判断栈是否为空\nif (tt &gt; 0)\n&#123;\n\n&#125;\n队列 —— 模板题 AcWing 829. 模拟队列\n\n1. 普通队列：\n   &#x2F;&#x2F; hh 表示队头，tt表示队尾\n   int q[N], hh &#x3D; 0, tt &#x3D; -1;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh &lt;&#x3D; tt)\n&#123;\n\n&#125;\n\n2. 循环队列\n   &#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置\n   int q[N], hh &#x3D; 0, tt &#x3D; 0;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[tt ++ ] &#x3D; x;\nif (tt &#x3D;&#x3D; N) tt &#x3D; 0;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\nif (hh &#x3D;&#x3D; N) hh &#x3D; 0;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh !&#x3D; tt)\n&#123;\n\n&#125;\n单调栈 —— 模板题 AcWing 830. 单调栈\n常见模型：找出每个数左边离它最近的比它大&#x2F;小的数\nint tt &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n&#123;\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] &#x3D; i;\n&#125;\n单调队列 —— 模板题 AcWing 154. 滑动窗口\n常见模型：找出滑动窗口中的最大值&#x2F;最小值\nint hh &#x3D; 0, tt &#x3D; -1;\nfor (int i &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (hh &lt;&#x3D; tt &amp;&amp; check_out(q[hh])) hh ++ ;  &#x2F;&#x2F; 判断队头是否滑出窗口\n    while (hh &lt;&#x3D; tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] &#x3D; i;\n&#125;\nKMP —— 模板题 AcWing 831. KMP字符串\n&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度\n求模式串的Next数组：\nfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )\n&#123;\n    while (j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];\n    if (p[i] &#x3D;&#x3D; p[j + 1]) j ++ ;\n    ne[i] &#x3D; j;\n&#125;\n\n&#x2F;&#x2F; 匹配\nfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )\n&#123;\n    while (j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];\n    if (s[i] &#x3D;&#x3D; p[j + 1]) j ++ ;\n    if (j &#x3D;&#x3D; m)\n    &#123;\n        j &#x3D; ne[j];\n        &#x2F;&#x2F; 匹配成功后的逻辑\n    &#125;\n&#125;\nTrie树 —— 模板题 AcWing 835. Trie字符串统计\nint son[N][26], cnt[N], idx;\n&#x2F;&#x2F; 0号点既是根节点，又是空节点\n&#x2F;&#x2F; son[][]存储树中每个节点的子节点\n&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量\n\n&#x2F;&#x2F; 插入一个字符串\nvoid insert(char *str)\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) son[p][u] &#x3D; ++ idx;\n        p &#x3D; son[p][u];\n    &#125;\n    cnt[p] ++ ;\n&#125;\n\n&#x2F;&#x2F; 查询字符串出现的次数\nint query(char *str)\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) return 0;\n        p &#x3D; son[p][u];\n    &#125;\n    return cnt[p];\n&#125;\n并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量\n(1)朴素并查集：\n\n    int p[N]; &#x2F;&#x2F;存储每个点的祖宗节点\n    \n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n        return p[x];\n    &#125;\n    \n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;\n    \n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    p[find(a)] &#x3D; find(b);\n\n\n(2)维护size的并查集：\n\n    int p[N], size[N];\n    &#x2F;&#x2F;p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量\n    \n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n        return p[x];\n    &#125;\n    \n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        p[i] &#x3D; i;\n        size[i] &#x3D; 1;\n    &#125;\n    \n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    size[find(b)] +&#x3D; size[find(a)];\n    p[find(a)] &#x3D; find(b);\n\n\n(3)维护到祖宗节点距离的并查集：\n\n    int p[N], d[N];\n    &#x2F;&#x2F;p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离\n    \n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x)\n        &#123;\n            int u &#x3D; find(p[x]);\n            d[x] +&#x3D; d[p[x]];\n            p[x] &#x3D; u;\n        &#125;\n        return p[x];\n    &#125;\n    \n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        p[i] &#x3D; i;\n        d[i] &#x3D; 0;\n    &#125;\n    \n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    p[find(a)] &#x3D; find(b);\n    d[find(a)] &#x3D; distance; &#x2F;&#x2F; 根据具体问题，初始化find(a)的偏移量\n\n堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆\n&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置\n&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n\n&#x2F;&#x2F; 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n&#123;\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n&#125;\n\nvoid down(int u)\n&#123;\n    int t &#x3D; u;\n    if (u * 2 &lt;&#x3D; size &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;\n    if (u * 2 + 1 &lt;&#x3D; size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;\n    if (u !&#x3D; t)\n    &#123;\n        heap_swap(u, t);\n        down(t);\n    &#125;\n&#125;\n\nvoid up(int u)\n&#123;\n    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])\n    &#123;\n        heap_swap(u, u &#x2F; 2);\n        u &gt;&gt;&#x3D; 1;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; O(n)建堆\nfor (int i &#x3D; n &#x2F; 2; i; i -- ) down(i);\n一般哈希 —— 模板题 AcWing 840. 模拟散列表\n(1) 拉链法\n    int h[N], e[N], ne[N], idx;\n\n    &#x2F;&#x2F; 向哈希表中插入一个数\n    void insert(int x)\n    &#123;\n        int k &#x3D; (x % N + N) % N;\n        e[idx] &#x3D; x;\n        ne[idx] &#x3D; h[k];\n        h[k] &#x3D; idx ++ ;\n    &#125;\n    \n    &#x2F;&#x2F; 在哈希表中查询某个数是否存在\n    bool find(int x)\n    &#123;\n        int k &#x3D; (x % N + N) % N;\n        for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i])\n            if (e[i] &#x3D;&#x3D; x)\n                return true;\n    \n        return false;\n    &#125;\n\n(2) 开放寻址法\n    int h[N];\n\n    &#x2F;&#x2F; 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\n    int find(int x)\n    &#123;\n        int t &#x3D; (x % N + N) % N;\n        while (h[t] !&#x3D; null &amp;&amp; h[t] !&#x3D; x)\n        &#123;\n            t ++ ;\n            if (t &#x3D;&#x3D; N) t &#x3D; 0;\n        &#125;\n        return t;\n    &#125;\n\n字符串哈希 —— 模板题 AcWing 841. 字符串哈希\n核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\n\ntypedef unsigned long long ULL;\nULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n\n&#x2F;&#x2F; 初始化\np[0] &#x3D; 1;\nfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n&#123;\n    h[i] &#x3D; h[i - 1] * P + str[i];\n    p[i] &#x3D; p[i - 1] * P;\n&#125;\n\n&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\nC++ STL简介\nvector, 变长数组，倍增的思想\n    size()  返回元素个数\n    empty()  返回是否为空\n    clear()  清空\n    front()&#x2F;back()\n    push_back()&#x2F;pop_back()\n    begin()&#x2F;end()\n    []\n    支持比较运算，按字典序\n\npair&lt;int, int&gt;\n    first, 第一个元素\n    second, 第二个元素\n    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\nstring，字符串\n    size()&#x2F;length()  返回字符串长度\n    empty()\n    clear()\n    substr(起始下标，(子串长度))  返回子串\n    c_str()  返回字符串所在字符数组的起始地址\n\nqueue, 队列\n    size()\n    empty()\n    push()  向队尾插入一个元素\n    front()  返回队头元素\n    back()  返回队尾元素\n    pop()  弹出队头元素\n\npriority_queue, 优先队列，默认是大根堆\n    size()\n    empty()\n    push()  插入一个元素\n    top()  返回堆顶元素\n    pop()  弹出堆顶元素\n    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n\nstack, 栈\n    size()\n    empty()\n    push()  向栈顶插入一个元素\n    top()  返回栈顶元素\n    pop()  弹出栈顶元素\n\ndeque, 双端队列\n    size()\n    empty()\n    clear()\n    front()&#x2F;back()\n    push_back()&#x2F;pop_back()\n    push_front()&#x2F;pop_front()\n    begin()&#x2F;end()\n    []\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\n    size()\n    empty()\n    clear()\n    begin()&#x2F;end()\n    ++, -- 返回前驱和后继，时间复杂度 O(logn)\n\n    set&#x2F;multiset\n        insert()  插入一个数\n        find()  查找一个数\n        count()  返回某一个数的个数\n        erase()\n            (1) 输入是一个数x，删除所有x   O(k + logn)\n            (2) 输入一个迭代器，删除这个迭代器\n        lower_bound()&#x2F;upper_bound()\n            lower_bound(x)  返回大于等于x的最小的数的迭代器\n            upper_bound(x)  返回大于x的最小的数的迭代器\n    map&#x2F;multimap\n        insert()  插入的数是一个pair\n        erase()  输入的参数是pair或者迭代器\n        find()\n        []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n        lower_bound()&#x2F;upper_bound()\n\nunordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--\n\nbitset, 圧位\n    bitset&lt;10000&gt; s;\n    ~, &amp;, |, ^\n    &gt;&gt;, &lt;&lt;\n    &#x3D;&#x3D;, !&#x3D;\n    []\n\n    count()  返回有多少个1\n    \n    any()  判断是否至少有一个1\n    none()  判断是否全为0\n    \n    set()  把所有位置成1\n    set(k, v)  将第k位变成v\n    reset()  把所有位变成0\n    flip()  等价于~\n    flip(k) 把第k位取反\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;404&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<hr>\n<h1 id=\"《常用代码模板3——搜索与图论》\"><a href=\"#《常用代码模板3——搜索与图论》\" class=\"headerlink\" title=\"《常用代码模板3——搜索与图论》\"></a>《常用代码模板3——搜索与图论》</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">算法基础课相关代码模板\n活动链接 —— 算法基础课\n树与图的存储\n树是一种特殊的图，与图的存储方式相同。\n对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。\n因此我们可以只考虑有向图的存储。\n\n(1) 邻接矩阵：g[a][b] 存储边a-&gt;b\n\n(2) 邻接表：\n\n&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n\n&#x2F;&#x2F; 添加一条边a-&gt;b\nvoid add(int a, int b)\n&#123;\n    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 初始化\nidx &#x3D; 0;\nmemset(h, -1, sizeof h);\n树与图的遍历\n时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\n(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心\n\nint dfs(int u)\n&#123;\n    st[u] &#x3D; true; &#x2F;&#x2F; st[u] 表示点u已经被遍历过\n\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j]) dfs(j);\n    &#125;\n&#125;\n(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次\n\nqueue&lt;int&gt; q;\nst[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())\n&#123;\n    int t &#x3D; q.front();\n    q.pop();\n\n    for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true; &#x2F;&#x2F; 表示点j已经被遍历过\n            q.push(j);\n        &#125;\n    &#125;\n&#125;\n拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列\n时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort()\n&#123;\n    int hh &#x3D; 0, tt &#x3D; -1;\n\n    &#x2F;&#x2F; d[i] 存储点i的入度\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (!d[i])\n            q[ ++ tt] &#x3D; i;\n\n    while (hh &lt;&#x3D; tt)\n    &#123;\n        int t &#x3D; q[hh ++ ];\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (-- d[j] &#x3D;&#x3D; 0)\n                q[ ++ tt] &#x3D; j;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt &#x3D;&#x3D; n - 1;\n&#125;\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I\n时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数\nint g[N][N];  &#x2F;&#x2F; 存储每条边\nint dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离\nbool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt; n - 1; i ++ )\n    &#123;\n        int t &#x3D; -1;     &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        &#x2F;&#x2F; 用t更新其他点的距离\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);\n\n        st[t] &#x3D; true;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II\n时间复杂度 O(mlogn)O(mlogn), nn 表示点数，mm 表示边数\ntypedef pair&lt;int, int&gt; PII;\n\nint n;      &#x2F;&#x2F; 点的数量\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    heap.push(&#123;0, 1&#125;);      &#x2F;&#x2F; first存储距离，second存储节点编号\n\n    while (heap.size())\n    &#123;\n        auto t &#x3D; heap.top();\n        heap.pop();\n\n        int ver &#x3D; t.second, distance &#x3D; t.first;\n\n        if (st[ver]) continue;\n        st[ver] &#x3D; true;\n\n        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; distance + w[i])\n            &#123;\n                dist[j] &#x3D; distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\nBellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路\n时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数\n注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\n\nint n, m;       &#x2F;&#x2F; n表示点数，m表示边数\nint dist[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离\n\nstruct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重\n&#123;\n    int a, b, w;\n&#125;edges[M];\n\n&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    &#x2F;&#x2F; 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        for (int j &#x3D; 0; j &lt; m; j ++ )\n        &#123;\n            int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] &#x3D; dist[a] + w;\n        &#125;\n    &#125;\n\n    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;\n    return dist[n];\n&#125;\nspfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路\n时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] &#x3D; true;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                if (!st[j])     &#x2F;&#x2F; 如果队列中已存在j，则不需要将j重复插入\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\nspfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环\n时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。\nbool spfa()\n&#123;\n    &#x2F;&#x2F; 不需要初始化dist数组\n    &#x2F;&#x2F; 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue&lt;int&gt; q;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        q.push(i);\n        st[i] &#x3D; true;\n    &#125;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                cnt[j] &#x3D; cnt[t] + 1;\n                if (cnt[j] &gt;&#x3D; n) return true;       &#x2F;&#x2F; 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\nfloyd算法 —— 模板题 AcWing 854. Floyd求最短路\n时间复杂度是 O(n3)O(n3), nn 表示点数\n初始化：\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;\n            else d[i][j] &#x3D; INF;\n\n&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n&#123;\n    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);\n&#125;\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树\n时间复杂度是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数\nint n;      &#x2F;&#x2F; n表示点数\nint g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边\nint dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中\n\n\n&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n\n    int res &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        int t &#x3D; -1;\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        if (i &amp;&amp; dist[t] &#x3D;&#x3D; INF) return INF;\n\n        if (i) res +&#x3D; dist[t];\n        st[t] &#x3D; true;\n\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) dist[j] &#x3D; min(dist[j], g[t][j]);\n    &#125;\n\n    return res;\n&#125;\nKruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树\n时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数\nint n, m;       &#x2F;&#x2F; n是点数，m是边数\nint p[N];       &#x2F;&#x2F; 并查集的父节点数组\n\nstruct Edge     &#x2F;&#x2F; 存储边\n&#123;\n    int a, b, w;\n\n    bool operator&lt; (const Edge &amp;W)const\n    &#123;\n        return w &lt; W.w;\n    &#125;\n&#125;edges[M];\n\nint find(int x)     &#x2F;&#x2F; 并查集核心操作\n&#123;\n    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n    return p[x];\n&#125;\n\nint kruskal()\n&#123;\n    sort(edges, edges + m);\n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;    &#x2F;&#x2F; 初始化并查集\n\n    int res &#x3D; 0, cnt &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; m; i ++ )\n    &#123;\n        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;\n\n        a &#x3D; find(a), b &#x3D; find(b);\n        if (a !&#x3D; b)     &#x2F;&#x2F; 如果两个连通块不连通，则将这两个连通块合并\n        &#123;\n            p[a] &#x3D; b;\n            res +&#x3D; w;\n            cnt ++ ;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1) return INF;\n    return res;\n&#125;\n染色法判别二分图 —— 模板题 AcWing 860. 染色法判定二分图\n时间复杂度是 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nint n;      &#x2F;&#x2F; n表示点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图\nint color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n\n&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n&#123;\n    color[u] &#x3D; c;\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (color[j] &#x3D;&#x3D; -1)\n        &#123;\n            if (!dfs(j, !c)) return false;\n        &#125;\n        else if (color[j] &#x3D;&#x3D; c) return false;\n    &#125;\n\n    return true;\n&#125;\n\nbool check()\n&#123;\n    memset(color, -1, sizeof color);\n    bool flag &#x3D; true;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (color[i] &#x3D;&#x3D; -1)\n            if (!dfs(i, 0))\n            &#123;\n                flag &#x3D; false;\n                break;\n            &#125;\n    return flag;\n&#125;\n匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配\n时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过\n\nbool find(int x)\n&#123;\n    for (int i &#x3D; h[x]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true;\n            if (match[j] &#x3D;&#x3D; 0 || find(match[j]))\n            &#123;\n                match[j] &#x3D; x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\nint res &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )\n&#123;\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;405&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<hr>\n<h1 id=\"《常用代码模板4——数学知识》\"><a href=\"#《常用代码模板4——数学知识》\" class=\"headerlink\" title=\"《常用代码模板4——数学知识》\"></a>《常用代码模板4——数学知识》</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">算法基础课相关代码模板\n活动链接 —— 算法基础课\n试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数\nbool is_prime(int x)\n&#123;\n    if (x &lt; 2) return false;\n    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )\n        if (x % i &#x3D;&#x3D; 0)\n            return false;\n    return true;\n&#125;\n试除法分解质因数 —— 模板题 AcWing 867. 分解质因数\nvoid divide(int x)\n&#123;\n    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )\n        if (x % i &#x3D;&#x3D; 0)\n        &#123;\n            int s &#x3D; 0;\n            while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i, s ++ ;\n            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; endl;\n        &#125;\n    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1 &lt;&lt; endl;\n    cout &lt;&lt; endl;\n&#125;\n朴素筛法求素数 —— 模板题 AcWing 868. 筛质数\nint primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数\nbool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n&#123;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        if (st[i]) continue;\n        primes[cnt ++ ] &#x3D; i;\n        for (int j &#x3D; i + i; j &lt;&#x3D; n; j +&#x3D; i)\n            st[j] &#x3D; true;\n    &#125;\n&#125;\n线性筛法求素数 —— 模板题 AcWing 868. 筛质数\nint primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数\nbool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n&#123;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        if (!st[i]) primes[cnt ++ ] &#x3D; i;\n        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )\n        &#123;\n            st[primes[j] * i] &#x3D; true;\n            if (i % primes[j] &#x3D;&#x3D; 0) break;\n        &#125;\n    &#125;\n&#125;\n试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数\nvector&lt;int&gt; get_divisors(int x)\n&#123;\n    vector&lt;int&gt; res;\n    for (int i &#x3D; 1; i &lt;&#x3D; x &#x2F; i; i ++ )\n        if (x % i &#x3D;&#x3D; 0)\n        &#123;\n            res.push_back(i);\n            if (i !&#x3D; x &#x2F; i) res.push_back(x &#x2F; i);\n        &#125;\n    sort(res.begin(), res.end());\n    return res;\n&#125;\n约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和\n如果 N &#x3D; p1^c1 * p2^c2 * ... *pk^ck\n约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)\n约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\n欧几里得算法 —— 模板题 AcWing 872. 最大公约数\nint gcd(int a, int b)\n&#123;\n    return b ? gcd(b, a % b) : a;\n&#125;\n求欧拉函数 —— 模板题 AcWing 873. 欧拉函数\nint phi(int x)\n&#123;\n    int res &#x3D; x;\n    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )\n        if (x % i &#x3D;&#x3D; 0)\n        &#123;\n            res &#x3D; res &#x2F; i * (i - 1);\n            while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i;\n        &#125;\n    if (x &gt; 1) res &#x3D; res &#x2F; x * (x - 1);\n\n    return res;\n&#125;\n筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数\nint primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数\nint euler[N];           &#x2F;&#x2F; 存储每个数的欧拉函数\nbool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉\n\n\nvoid get_eulers(int n)\n&#123;\n    euler[1] &#x3D; 1;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        if (!st[i])\n        &#123;\n            primes[cnt ++ ] &#x3D; i;\n            euler[i] &#x3D; i - 1;\n        &#125;\n        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )\n        &#123;\n            int t &#x3D; primes[j] * i;\n            st[t] &#x3D; true;\n            if (i % primes[j] &#x3D;&#x3D; 0)\n            &#123;\n                euler[t] &#x3D; euler[i] * primes[j];\n                break;\n            &#125;\n            euler[t] &#x3D; euler[i] * (primes[j] - 1);\n        &#125;\n    &#125;\n&#125;\n快速幂 —— 模板题 AcWing 875. 快速幂\n求 m^k mod p，时间复杂度 O(logk)。\n\nint qmi(int m, int k, int p)\n&#123;\n    int res &#x3D; 1 % p, t &#x3D; m;\n    while (k)\n    &#123;\n        if (k&amp;1) res &#x3D; res * t % p;\n        t &#x3D; t * t % p;\n        k &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;\n扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法\n&#x2F;&#x2F; 求x, y，使得ax + by &#x3D; gcd(a, b)\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n&#123;\n    if (!b)\n    &#123;\n        x &#x3D; 1; y &#x3D; 0;\n        return a;\n    &#125;\n    int d &#x3D; exgcd(b, a % b, y, x);\n    y -&#x3D; (a&#x2F;b) * x;\n    return d;\n&#125;\n高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组\n&#x2F;&#x2F; a[N][N]是增广矩阵\nint gauss()\n&#123;\n    int c, r;\n    for (c &#x3D; 0, r &#x3D; 0; c &lt; n; c ++ )\n    &#123;\n        int t &#x3D; r;\n        for (int i &#x3D; r; i &lt; n; i ++ )   &#x2F;&#x2F; 找到绝对值最大的行\n            if (fabs(a[i][c]) &gt; fabs(a[t][c]))\n                t &#x3D; i;\n\n        if (fabs(a[t][c]) &lt; eps) continue;\n\n        for (int i &#x3D; c; i &lt;&#x3D; n; i ++ ) swap(a[t][i], a[r][i]);      &#x2F;&#x2F; 将绝对值最大的行换到最顶端\n        for (int i &#x3D; n; i &gt;&#x3D; c; i -- ) a[r][i] &#x2F;&#x3D; a[r][c];      &#x2F;&#x2F; 将当前行的首位变成1\n        for (int i &#x3D; r + 1; i &lt; n; i ++ )       &#x2F;&#x2F; 用当前行将下面所有的列消成0\n            if (fabs(a[i][c]) &gt; eps)\n                for (int j &#x3D; n; j &gt;&#x3D; c; j -- )\n                    a[i][j] -&#x3D; a[r][j] * a[i][c];\n\n        r ++ ;\n    &#125;\n\n    if (r &lt; n)\n    &#123;\n        for (int i &#x3D; r; i &lt; n; i ++ )\n            if (fabs(a[i][n]) &gt; eps)\n                return 2; &#x2F;&#x2F; 无解\n        return 1; &#x2F;&#x2F; 有无穷多组解\n    &#125;\n\n    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )\n        for (int j &#x3D; i + 1; j &lt; n; j ++ )\n            a[i][n] -&#x3D; a[i][j] * a[j][n];\n\n    return 0; &#x2F;&#x2F; 有唯一解\n&#125;\n递归法求组合数 —— 模板题 AcWing 885. 求组合数 I\n&#x2F;&#x2F; c[a][b] 表示从a个苹果中选b个的方案数\nfor (int i &#x3D; 0; i &lt; N; i ++ )\n    for (int j &#x3D; 0; j &lt;&#x3D; i; j ++ )\n        if (!j) c[i][j] &#x3D; 1;\n        else c[i][j] &#x3D; (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II\n首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]\n如果取模的数是质数，可以用费马小定理求逆元\nint qmi(int a, int k, int p)    &#x2F;&#x2F; 快速幂模板\n&#123;\n    int res &#x3D; 1;\n    while (k)\n    &#123;\n        if (k &amp; 1) res &#x3D; (LL)res * a % p;\n        a &#x3D; (LL)a * a % p;\n        k &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;\n\n&#x2F;&#x2F; 预处理阶乘的余数和阶乘逆元的余数\nfact[0] &#x3D; infact[0] &#x3D; 1;\nfor (int i &#x3D; 1; i &lt; N; i ++ )\n&#123;\n    fact[i] &#x3D; (LL)fact[i - 1] * i % mod;\n    infact[i] &#x3D; (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;\n&#125;\nLucas定理 —— 模板题 AcWing 887. 求组合数 III\n若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：\n    C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)\n\nint qmi(int a, int k, int p)  &#x2F;&#x2F; 快速幂模板\n&#123;\n    int res &#x3D; 1 % p;\n    while (k)\n    &#123;\n        if (k &amp; 1) res &#x3D; (LL)res * a % p;\n        a &#x3D; (LL)a * a % p;\n        k &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;\n\nint C(int a, int b, int p)  &#x2F;&#x2F; 通过定理求组合数C(a, b)\n&#123;\n    if (a &lt; b) return 0;\n\n    LL x &#x3D; 1, y &#x3D; 1;  &#x2F;&#x2F; x是分子，y是分母\n    for (int i &#x3D; a, j &#x3D; 1; j &lt;&#x3D; b; i --, j ++ )\n    &#123;\n        x &#x3D; (LL)x * i % p;\n        y &#x3D; (LL) y * j % p;\n    &#125;\n\n    return x * (LL)qmi(y, p - 2, p) % p;\n&#125;\n\nint lucas(LL a, LL b, int p)\n&#123;\n    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);\n    return (LL)C(a % p, b % p, p) * lucas(a &#x2F; p, b &#x2F; p, p) % p;\n&#125;\n分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV\n当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\n    1. 筛法求出范围内的所有质数\n    2. 通过 C(a, b) &#x3D; a! &#x2F; b! &#x2F; (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n &#x2F; p + n &#x2F; p^2 + n &#x2F; p^3 + ...\n    3. 用高精度乘法将所有质因子相乘\n\nint primes[N], cnt;     &#x2F;&#x2F; 存储所有质数\nint sum[N];     &#x2F;&#x2F; 存储每个质数的次数\nbool st[N];     &#x2F;&#x2F; 存储每个数是否已被筛掉\n\n\nvoid get_primes(int n)      &#x2F;&#x2F; 线性筛法求素数\n&#123;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        if (!st[i]) primes[cnt ++ ] &#x3D; i;\n        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )\n        &#123;\n            st[primes[j] * i] &#x3D; true;\n            if (i % primes[j] &#x3D;&#x3D; 0) break;\n        &#125;\n    &#125;\n&#125;\n\n\nint get(int n, int p)       &#x2F;&#x2F; 求n！中的次数\n&#123;\n    int res &#x3D; 0;\n    while (n)\n    &#123;\n        res +&#x3D; n &#x2F; p;\n        n &#x2F;&#x3D; p;\n    &#125;\n    return res;\n&#125;\n\n\nvector&lt;int&gt; mul(vector&lt;int&gt; a, int b)       &#x2F;&#x2F; 高精度乘低精度模板\n&#123;\n    vector&lt;int&gt; c;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; a.size(); i ++ )\n    &#123;\n        t +&#x3D; a[i] * b;\n        c.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    while (t)\n    &#123;\n        c.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    return c;\n&#125;\n\nget_primes(a);  &#x2F;&#x2F; 预处理范围内的所有质数\n\nfor (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 求每个质因数的次数\n&#123;\n    int p &#x3D; primes[i];\n    sum[i] &#x3D; get(a, p) - get(b, p) - get(a - b, p);\n&#125;\n\nvector&lt;int&gt; res;\nres.push_back(1);\n\nfor (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 用高精度乘法将所有质因子相乘\n    for (int j &#x3D; 0; j &lt; sum[i]; j ++ )\n        res &#x3D; mul(res, primes[i]);\n\n卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列\n给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) &#x3D; C(2n, n) &#x2F; (n + 1)\nNIM游戏 —— 模板题 AcWing 891. Nim游戏\n给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\n\n我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。\n所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。\nNIM博弈不存在平局，只有先手必胜和先手必败两种情况。\n\n定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An !&#x3D; 0\n\n公平组合游戏ICG\n若一个游戏满足：\n\n由两名玩家交替行动；\n在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\n不能行动的玩家判负；\n则称该游戏为一个公平组合游戏。\nNIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。\n\n有向图游戏\n给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。\n任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\n\nMex运算\n设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：\nmex(S) &#x3D; min&#123;x&#125;, x属于自然数，且x不属于S\n\nSG函数\n在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：\nSG(x) &#x3D; mex(&#123;SG(y1), SG(y2), …, SG(yk)&#125;)\n特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) &#x3D; SG(s)。\n\n有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏\n设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。\n有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：\nSG(G) &#x3D; SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\n\n定理\n有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。\n有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;406&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n\n\n\n<hr>\n","text":"日本信奥网站 Atcoder AGC 思维难度 训练思维 Complexity:AGC 的 D 题《计算概论》，华东师范大学第二附属中学 chen_zhehzwer 发起的的 shareOI、OI Wiki、Loj 与 Uoj、洛谷的集训队 50 题用洛谷的RemoteJudge...","link":"","photos":[],"count_time":{"symbolsCount":"45k","symbolsTime":"41 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8AC-%E4%B9%8B-unordered-map%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%8B\"><span class=\"toc-text\">《C++ 之 unordered_map——哈希表》</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9%E3%80%8B\"><span class=\"toc-text\">《由数据范围反推算法复杂度以及算法内容》</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E6%B1%82%E8%A7%A3%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%96%B9%E6%B3%95%E3%80%8B\"><span class=\"toc-text\">《求解斐波那契数列的若干方法》</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF1%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%8B\"><span class=\"toc-text\">《常用代码模板1——基础算法》</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF2%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B\"><span class=\"toc-text\">《常用代码模板2——数据结构》</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF3%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA%E3%80%8B\"><span class=\"toc-text\">《常用代码模板3——搜索与图论》</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF4%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%8B\"><span class=\"toc-text\">《常用代码模板4——数学知识》</span></a></li></ol>","author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"PEToolKit","uid":"a1e4caef696c9dadabec86ca767b0052","slug":"PEToolKit","date":"2020-08-14T15:41:26.000Z","updated":"2022-08-22T07:52:21.331Z","comments":true,"path":"api/articles/PEToolKit.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/960_593_0/t016c300191cf22c2f0.jpg","text":"&#x2F;&#x2F;PE课后作业参考代码（含测试代码） &#x2F;&#x2F;https:&#x2F;&#x2F;blog.csdn.net&#x2F;Kwansy&#x2F;article&#x2F;details&#x2F;106234264 #include &quo...","link":"","photos":[],"count_time":{"symbolsCount":"60k","symbolsTime":"54 mins."},"categories":[{"name":"逆向","slug":"逆向","count":5,"path":"api/categories/逆向.json"}],"tags":[{"name":"逆向","slug":"逆向","count":4,"path":"api/tags/逆向.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}