{"title":"学Netty-黑马满哥","uid":"ab3568622c7f6e7ae567a8af8514c4cd","slug":"学Netty-黑马满哥","date":"2022-04-26T14:11:41.000Z","updated":"2022-08-22T08:05:45.171Z","comments":true,"path":"api/articles/学Netty-黑马满哥.json","keywords":null,"cover":"http://p9.qhimg.com/bdm/960_593_0/t01747d916d50e11a77.jpg","content":"<p>黑马Netty：<a href=\"https://www.bilibili.com/video/BV1py4y1E7oA\">https://www.bilibili.com/video/BV1py4y1E7oA</a></p>\n<p>学Netty，建议看黑马Netty教程。然后尚硅谷Netty课的Protobuf, DubboRPC等案例就可以了。</p>\n<p>尚硅谷-韩顺平：<a href=\"https://www.bilibili.com/video/BV1DJ411m7NR?p=1\">https://www.bilibili.com/video/BV1DJ411m7NR?p=1</a></p>\n<p>学习Netty建议一定要看 《Netty in Action》（Ntty实战）， 网上有大神也翻译了 ： <a href=\"https://waylau.com/essential-netty-in-action/index.html\">https://waylau.com/essential-netty-in-action/index.html</a><br>别人的学习文档，持续更新：<a href=\"https://github.com/guang19/framework-learning\">https://github.com/guang19/framework-learning</a></p>\n<h1 id=\"一-NIO-基础\"><a href=\"#一-NIO-基础\" class=\"headerlink\" title=\"一. NIO 基础\"></a>一. NIO 基础</h1><p>non-blocking io 非阻塞 IO</p>\n<h2 id=\"1-三大组件\"><a href=\"#1-三大组件\" class=\"headerlink\" title=\"1. 三大组件\"></a>1. 三大组件</h2><h3 id=\"1-1-Channel-amp-Buffer\"><a href=\"#1-1-Channel-amp-Buffer\" class=\"headerlink\" title=\"1.1 Channel &amp; Buffer\"></a>1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph LR\nchannel --&gt; buffer\nbuffer --&gt; channel</code></pre>\n\n<p>常见的 Channel 有</p>\n<ul>\n<li>FileChannel</li>\n<li>DatagramChannel    UDP</li>\n<li>SocketChannel    C&#x2F;S</li>\n<li>ServerSocketChannel    S</li>\n</ul>\n<p>buffer 则用来缓冲读写数据，常见的 buffer 有</p>\n<ul>\n<li>ByteBuffer 抽象类<ul>\n<li>MappedByteBuffer</li>\n<li>DirectByteBuffer</li>\n<li>HeapByteBuffer</li>\n</ul>\n</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n<li>CharBuffer</li>\n</ul>\n<h3 id=\"1-2-Selector\"><a href=\"#1-2-Selector\" class=\"headerlink\" title=\"1.2 Selector\"></a>1.2 Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p>\n<h4 id=\"多线程版设计\"><a href=\"#多线程版设计\" class=\"headerlink\" title=\"多线程版设计\"></a>多线程版设计</h4><pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph TD\nsubgraph 多线程版\nt1(thread) --&gt; s1(socket1)\nt2(thread) --&gt; s2(socket2)\nt3(thread) --&gt; s3(socket3)\nend</code></pre>\n\n<h4 id=\"⚠️-多线程版缺点\"><a href=\"#⚠️-多线程版缺点\" class=\"headerlink\" title=\"⚠️ 多线程版缺点\"></a>⚠️ 多线程版缺点</h4><ul>\n<li>内存占用高</li>\n<li>线程上下文切换成本高</li>\n<li>只适合连接数少的场景</li>\n</ul>\n<h4 id=\"线程池版设计\"><a href=\"#线程池版设计\" class=\"headerlink\" title=\"线程池版设计\"></a>线程池版设计</h4><pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph TD\nsubgraph 线程池版\nt4(thread) --&gt; s4(socket1)\nt5(thread) --&gt; s5(socket2)\nt4(thread) -.-&gt; s6(socket3)\nt5(thread) -.-&gt; s7(socket4)\nend</code></pre>\n\n<h4 id=\"⚠️-线程池版缺点\"><a href=\"#⚠️-线程池版缺点\" class=\"headerlink\" title=\"⚠️ 线程池版缺点\"></a>⚠️ 线程池版缺点</h4><ul>\n<li>阻塞模式下，线程仅能处理一个 socket 连接</li>\n<li>仅适合短连接场景：因为阻塞模式！resp后尽快断开处理其他socket</li>\n</ul>\n<p>TH利用率不高</p>\n<h4 id=\"selector-版设计\"><a href=\"#selector-版设计\" class=\"headerlink\" title=\"selector 版设计\"></a>selector 版设计</h4><p>selector 的作用就是【配合一个线程来管理多个】 channel，获取这些 channel 上发生的【事件】，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。<strong>适合连接数特别多，但流量低[非频繁请求]的场景（low traffic）</strong></p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph TD\nsubgraph selector 版\nthread --&gt; selector\nselector --&gt; c1(channel)\nselector --&gt; c2(channel)\nselector --&gt; c3(channel)\nend</code></pre>\n\n<p>可连接|R|W的event</p>\n<p>调用 selector 的 <strong>select() 会阻塞直到 channel 发生了读写就绪事件</strong>，这些事件发生，select 方法就会<strong>返回这些事件交给 thread 来处理</strong></p>\n<h2 id=\"2-ByteBuffer\"><a href=\"#2-ByteBuffer\" class=\"headerlink\" title=\"2. ByteBuffer\"></a>2. ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1234567890abcd</code></pre>\n\n<p>使用 FileChannel 来读取文件内容\t&#x3D;&#x3D;twr：try-with-resources&#x3D;&#x3D;</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class TestByteBuffer &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; FileChannel\n        &#x2F;&#x2F; 1. 输入输出流， 2. RandomAccessFile\n        try (FileChannel channel &#x3D; new FileInputStream(&quot;data.txt&quot;).getChannel()) &#123;\n            &#x2F;&#x2F; 准备缓冲区\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);\n            while (true) &#123;\n                &#x2F;&#x2F; 从channel读取数据，写到buffer\n                int len &#x3D; channel.read(buffer);\n                log.debug(&quot;读取到的字节数 &#123;&#125;&quot;, len);\n                if(len &#x3D;&#x3D; -1) break;&#x2F;&#x2F;没有内容了\n                &#x2F;&#x2F;print\n                buffer.flip(); &#x2F;&#x2F;切换到读buffer模式\n                while(buffer.hasRemaining()) &#123;\n                    byte b &#x3D; buffer.get();&#x2F;&#x2F;读1B\n                    log.debug(&quot;实际字节数 &#123;&#125;&quot;, (char) b);\n                &#125;\n                buffer.clear(); &#x2F;&#x2F;切换到写buffer模式\n            &#125;\n\n        &#125; catch (IOException e) &#123;\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</code></pre>\n\n\n\n<h3 id=\"2-1-ByteBuffer-正确使用姿势\"><a href=\"#2-1-ByteBuffer-正确使用姿势\" class=\"headerlink\" title=\"2.1  ByteBuffer 正确使用姿势\"></a>2.1  ByteBuffer 正确使用姿势</h3><ol>\n<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>\n<li>调用 flip() 切换至<strong>读模式</strong></li>\n<li>从 buffer 读取数据，例如调用 buffer.get()</li>\n<li>调用 clear() 或 compact() 【R一部分，压缩掉已读部分继续W】切换至<strong>写模式</strong></li>\n<li>重复 1~4 步骤</li>\n</ol>\n<h3 id=\"2-2-ByteBuffer-结构\"><a href=\"#2-2-ByteBuffer-结构\" class=\"headerlink\" title=\"2.2 ByteBuffer 结构\"></a>2.2 ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p>\n<ul>\n<li>capacity</li>\n<li>position curW&#x2F;R位置</li>\n<li>limit W&#x2F;R限制</li>\n</ul>\n<p>一开始</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0021.png\"></p>\n<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0018.png\"></p>\n<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0019.png\"></p>\n<p>读取 4 个字节后，状态</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0020.png\"></p>\n<p>clear 动作发生后，状态</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0021.png\"></p>\n<p>compact 方法，是把**[未读完]的部分向前压缩，然后切换至写(继续W)**模式</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0022.png\"></p>\n<h4 id=\"💡-调试工具类\"><a href=\"#💡-调试工具类\" class=\"headerlink\" title=\"💡 调试工具类\"></a>💡 调试工具类</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufferUtil &#123;\n    private static final char[] BYTE2CHAR &#x3D; new char[256];\n    private static final char[] HEXDUMP_TABLE &#x3D; new char[256 * 4];\n    private static final String[] HEXPADDING &#x3D; new String[16];\n    private static final String[] HEXDUMP_ROWPREFIXES &#x3D; new String[65536 &gt;&gt;&gt; 4];\n    private static final String[] BYTE2HEX &#x3D; new String[256];\n    private static final String[] BYTEPADDING &#x3D; new String[16];\n\n    static &#123;\n        final char[] DIGITS &#x3D; &quot;0123456789abcdef&quot;.toCharArray();\n        for (int i &#x3D; 0; i &lt; 256; i++) &#123;\n            HEXDUMP_TABLE[i &lt;&lt; 1] &#x3D; DIGITS[i &gt;&gt;&gt; 4 &amp; 0x0F];\n            HEXDUMP_TABLE[(i &lt;&lt; 1) + 1] &#x3D; DIGITS[i &amp; 0x0F];\n        &#125;\n\n        int i;\n\n        &#x2F;&#x2F; Generate the lookup table for hex dump paddings\n        for (i &#x3D; 0; i &lt; HEXPADDING.length; i++) &#123;\n            int padding &#x3D; HEXPADDING.length - i;\n            StringBuilder buf &#x3D; new StringBuilder(padding * 3);\n            for (int j &#x3D; 0; j &lt; padding; j++) &#123;\n                buf.append(&quot;   &quot;);\n            &#125;\n            HEXPADDING[i] &#x3D; buf.toString();\n        &#125;\n\n        &#x2F;&#x2F; Generate the lookup table for the start-offset header in each row (up to 64KiB).\n        for (i &#x3D; 0; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;\n            StringBuilder buf &#x3D; new StringBuilder(12);\n            buf.append(NEWLINE);\n            buf.append(Long.toHexString(i &lt;&lt; 4 &amp; 0xFFFFFFFFL | 0x100000000L));\n            buf.setCharAt(buf.length() - 9, &#39;|&#39;);\n            buf.append(&#39;|&#39;);\n            HEXDUMP_ROWPREFIXES[i] &#x3D; buf.toString();\n        &#125;\n\n        &#x2F;&#x2F; Generate the lookup table for byte-to-hex-dump conversion\n        for (i &#x3D; 0; i &lt; BYTE2HEX.length; i++) &#123;\n            BYTE2HEX[i] &#x3D; &#39; &#39; + StringUtil.byteToHexStringPadded(i);\n        &#125;\n\n        &#x2F;&#x2F; Generate the lookup table for byte dump paddings\n        for (i &#x3D; 0; i &lt; BYTEPADDING.length; i++) &#123;\n            int padding &#x3D; BYTEPADDING.length - i;\n            StringBuilder buf &#x3D; new StringBuilder(padding);\n            for (int j &#x3D; 0; j &lt; padding; j++) &#123;\n                buf.append(&#39; &#39;);\n            &#125;\n            BYTEPADDING[i] &#x3D; buf.toString();\n        &#125;\n\n        &#x2F;&#x2F; Generate the lookup table for byte-to-char conversion\n        for (i &#x3D; 0; i &lt; BYTE2CHAR.length; i++) &#123;\n            if (i &lt;&#x3D; 0x1f || i &gt;&#x3D; 0x7f) &#123;\n                BYTE2CHAR[i] &#x3D; &#39;.&#39;;\n            &#125; else &#123;\n                BYTE2CHAR[i] &#x3D; (char) i;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 打印所有内容\n     * @param buffer\n     *&#x2F;\n    public static void debugAll(ByteBuffer buffer) &#123;\n        int oldlimit &#x3D; buffer.limit();\n        buffer.limit(buffer.capacity());\n        StringBuilder origin &#x3D; new StringBuilder(256);\n        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());\n        System.out.println(&quot;+--------+-------------------- all ------------------------+----------------+&quot;);\n        System.out.printf(&quot;position: [%d], limit: [%d]\\n&quot;, buffer.position(), oldlimit);\n        System.out.println(origin);\n        buffer.limit(oldlimit);\n    &#125;\n\n    &#x2F;**\n     * 打印可读取内容\n     * @param buffer\n     *&#x2F;\n    public static void debugRead(ByteBuffer buffer) &#123;\n        StringBuilder builder &#x3D; new StringBuilder(256);\n        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());\n        System.out.println(&quot;+--------+-------------------- read -----------------------+----------------+&quot;);\n        System.out.printf(&quot;position: [%d], limit: [%d]\\n&quot;, buffer.position(), buffer.limit());\n        System.out.println(builder);\n    &#125;\n\n    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) &#123;\n        if (isOutOfBounds(offset, length, buf.capacity())) &#123;\n            throw new IndexOutOfBoundsException(\n                    &quot;expected: &quot; + &quot;0 &lt;&#x3D; offset(&quot; + offset + &quot;) &lt;&#x3D; offset + length(&quot; + length\n                            + &quot;) &lt;&#x3D; &quot; + &quot;buf.capacity(&quot; + buf.capacity() + &#39;)&#39;);\n        &#125;\n        if (length &#x3D;&#x3D; 0) &#123;\n            return;\n        &#125;\n        dump.append(\n                &quot;         +-------------------------------------------------+&quot; +\n                        NEWLINE + &quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot; +\n                        NEWLINE + &quot;+--------+-------------------------------------------------+----------------+&quot;);\n\n        final int startIndex &#x3D; offset;\n        final int fullRows &#x3D; length &gt;&gt;&gt; 4;\n        final int remainder &#x3D; length &amp; 0xF;\n\n        &#x2F;&#x2F; Dump the rows which have 16 bytes.\n        for (int row &#x3D; 0; row &lt; fullRows; row++) &#123;\n            int rowStartIndex &#x3D; (row &lt;&lt; 4) + startIndex;\n\n            &#x2F;&#x2F; Per-row prefix.\n            appendHexDumpRowPrefix(dump, row, rowStartIndex);\n\n            &#x2F;&#x2F; Hex dump\n            int rowEndIndex &#x3D; rowStartIndex + 16;\n            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            &#125;\n            dump.append(&quot; |&quot;);\n\n            &#x2F;&#x2F; ASCII dump\n            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            &#125;\n            dump.append(&#39;|&#39;);\n        &#125;\n\n        &#x2F;&#x2F; Dump the last row which has less than 16 bytes.\n        if (remainder !&#x3D; 0) &#123;\n            int rowStartIndex &#x3D; (fullRows &lt;&lt; 4) + startIndex;\n            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);\n\n            &#x2F;&#x2F; Hex dump\n            int rowEndIndex &#x3D; rowStartIndex + remainder;\n            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            &#125;\n            dump.append(HEXPADDING[remainder]);\n            dump.append(&quot; |&quot;);\n\n            &#x2F;&#x2F; Ascii dump\n            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            &#125;\n            dump.append(BYTEPADDING[remainder]);\n            dump.append(&#39;|&#39;);\n        &#125;\n\n        dump.append(NEWLINE +\n                &quot;+--------+-------------------------------------------------+----------------+&quot;);\n    &#125;\n\n    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) &#123;\n        if (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;\n            dump.append(HEXDUMP_ROWPREFIXES[row]);\n        &#125; else &#123;\n            dump.append(NEWLINE);\n            dump.append(Long.toHexString(rowStartIndex &amp; 0xFFFFFFFFL | 0x100000000L));\n            dump.setCharAt(dump.length() - 9, &#39;|&#39;);\n            dump.append(&#39;|&#39;);\n        &#125;\n    &#125;\n\n    public static short getUnsignedByte(ByteBuffer buffer, int index) &#123;\n        return (short) (buffer.get(index) &amp; 0xFF);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"2-3-ByteBuffer-常见方法-nio-c2\"><a href=\"#2-3-ByteBuffer-常见方法-nio-c2\" class=\"headerlink\" title=\"2.3 ByteBuffer 常见方法-nio.c2\"></a>2.3 ByteBuffer 常见方法-nio.c2</h3><h4 id=\"分配空间TestByteBufferAllocate\"><a href=\"#分配空间TestByteBufferAllocate\" class=\"headerlink\" title=\"分配空间\tTestByteBufferAllocate\"></a>分配空间\tTestByteBufferAllocate</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Bytebuffer buf &#x3D; ByteBuffer.allocate(16);\n\nSystem.out.println(ByteBuffer.allocateDirect(16).getClass());\n&#x2F;*\n        零拷贝:allocateDirect(16)\n        class java.nio.HeapByteBuffer    - java 堆内存，读写效率较低，受到 GC copy的影响\n        class java.nio.DirectByteBuffer  - 直接内存，读写效率高（少一次拷贝），不会受 GC 影响，调OSsys函数：分配的效率低\n        【优化-Netty对象池：减少bytebuffer分配频率，并回收】\n         *&#x2F;</code></pre>\n\n\n\n<h4 id=\"向-buffer-写入数据TestByteBufferReadWrite\"><a href=\"#向-buffer-写入数据TestByteBufferReadWrite\" class=\"headerlink\" title=\"向 buffer 写入数据\tTestByteBufferReadWrite\"></a>向 buffer 写入数据\tTestByteBufferReadWrite</h4><p>有两种办法</p>\n<ul>\n<li>调用 channel 的 read 方法</li>\n<li>调用 buffer 自己的 put 方法</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int readBytes &#x3D; channel.read(buf);</code></pre>\n\n<p>和</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buf.put((byte)127);</code></pre>\n\n\n\n<h4 id=\"从-buffer-读取数据TestByteBufferRead\"><a href=\"#从-buffer-读取数据TestByteBufferRead\" class=\"headerlink\" title=\"从 buffer 读取数据\tTestByteBufferRead\"></a>从 buffer 读取数据\tTestByteBufferRead</h4><p>同样有两种办法</p>\n<ul>\n<li>调用 channel 的 write 方法</li>\n<li>调用 buffer 自己的 get 方法</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int writeBytes &#x3D; channel.write(buf);</code></pre>\n\n<p>和</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">byte b &#x3D; buf.get();</code></pre>\n\n<p><strong>get 方法会让 position 读指针向后走</strong>，如果<strong>想重复读取</strong>数据</p>\n<ul>\n<li>可以调用 <strong>rewind 方法将 position 重新置为 0</strong></li>\n<li>或者调用 <strong>get(int i)</strong> 方法获取索引 i 的内容，它<strong>不会移动读指针</strong></li>\n</ul>\n<h4 id=\"mark-和-reset\"><a href=\"#mark-和-reset\" class=\"headerlink\" title=\"mark 和 reset\"></a>mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong></p>\n<p>rewind 和 flip 都会清除 mark 位置！</p></blockquote>\n<h4 id=\"字符串与-ByteBuffer-互转TestByteBufferString\"><a href=\"#字符串与-ByteBuffer-互转TestByteBufferString\" class=\"headerlink\" title=\"字符串与 ByteBuffer 互转\tTestByteBufferString\"></a>字符串与 ByteBuffer 互转\tTestByteBufferString</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">        &#x2F;&#x2F; 1. 字符串转为 ByteBuffer allocate+put:W\n        ByteBuffer buffer1 &#x3D; ByteBuffer.allocate(16);\n        buffer1.put(&quot;hello&quot;.getBytes());&#x2F;&#x2F;\n        debugAll(buffer1);\n\n        &#x2F;&#x2F; 2. Charset R\n        ByteBuffer buffer2 &#x3D; StandardCharsets.UTF_8.encode(&quot;你好&quot;);\n        debugAll(buffer2);\n\n        &#x2F;&#x2F; 3. wrap R\n        ByteBuffer buffer3 &#x3D; ByteBuffer.wrap(&quot;hello&quot;.getBytes());\n        debugAll(buffer3);\n\nByteBuffer buffer1 &#x3D; StandardCharsets.UTF_8.encode(&quot;你好&quot;);\nByteBuffer buffer2 &#x3D; Charset.forName(&quot;utf-8&quot;).encode(&quot;你好&quot;);\n\ndebug(buffer1);\ndebug(buffer2);\n\nbuffer1.flip();&#x2F;&#x2F;W-&gt;R\nCharBuffer buffer3 &#x3D; StandardCharsets.UTF_8.decode(buffer1);\nSystem.out.println(buffer3.getClass());&#x2F;&#x2F;HeapCharBuffer\nSystem.out.println(buffer3.toString());&#x2F;&#x2F;</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\nclass java.nio.HeapCharBuffer\n你好</code></pre>\n\n\n\n<h4 id=\"⚠️-Buffer-的线程安全\"><a href=\"#⚠️-Buffer-的线程安全\" class=\"headerlink\" title=\"⚠️ Buffer 的线程安全\"></a>⚠️ Buffer 的线程安全</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Buffer 是<strong>非线程安全的</strong></p></blockquote>\n<h3 id=\"2-4-Scattering-Reads\"><a href=\"#2-4-Scattering-Reads\" class=\"headerlink\" title=\"2.4 Scattering Reads\"></a>2.4 Scattering Reads</h3><p>分散读取，有一个文本文件 3parts.txt</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">onetwothree</code></pre>\n\n<p>使用如下方式读取，可以将数据【填充至多个 buffer】</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try (RandomAccessFile file &#x3D; new RandomAccessFile(&quot;helloword&#x2F;3parts.txt&quot;, &quot;rw&quot;)) &#123;\n    FileChannel channel &#x3D; file.getChannel();\n    ByteBuffer a &#x3D; ByteBuffer.allocate(3);\n    ByteBuffer b &#x3D; ByteBuffer.allocate(3);\n    ByteBuffer c &#x3D; ByteBuffer.allocate(5);\n    channel.read(new ByteBuffer[]&#123;a, b, c&#125;);&#x2F;&#x2F;增强read([])\n    a.flip();\n    b.flip();\n    c.flip();\n    debug(a);\n    debug(b);\n    debug(c);\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;</code></pre>\n\n<p>结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6f 6e 65                                        |one             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 77 6f                                        |two             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 68 72 65 65                                  |three           |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n<h3 id=\"2-5-Gathering-Writes\"><a href=\"#2-5-Gathering-Writes\" class=\"headerlink\" title=\"2.5 Gathering Writes\"></a>2.5 Gathering Writes</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try (RandomAccessFile file &#x3D; new RandomAccessFile(&quot;helloword&#x2F;3parts.txt&quot;, &quot;rw&quot;)) &#123;\n    FileChannel channel &#x3D; file.getChannel();\n    ByteBuffer d &#x3D; ByteBuffer.allocate(4);\n    ByteBuffer e &#x3D; ByteBuffer.allocate(4);\n    channel.position(11);&#x2F;&#x2F;\n\n    d.put(new byte[]&#123;&#39;f&#39;, &#39;o&#39;, &#39;u&#39;, &#39;r&#39;&#125;);\n    e.put(new byte[]&#123;&#39;f&#39;, &#39;i&#39;, &#39;v&#39;, &#39;e&#39;&#125;);\n    d.flip();\n    e.flip();\n    debug(d);\n    debug(e);\n    channel.write(new ByteBuffer[]&#123;d, e&#125;);&#x2F;&#x2F;\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 6f 75 72                                     |four            |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 69 76 65                                     |five            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>文件内容</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">onetwothreefourfive</code></pre>\n\n\n\n<h3 id=\"2-6-练习TestByteBufferExam\"><a href=\"#2-6-练习TestByteBufferExam\" class=\"headerlink\" title=\"2.6 练习\tTestByteBufferExam\"></a>2.6 练习\tTestByteBufferExam</h3><p>网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>\n<ul>\n<li>Hello,world\\n</li>\n<li>I’m zhangsan\\n</li>\n<li>How are you?\\n</li>\n</ul>\n<p>变成了下面的两个 byteBuffer (黏包，半包)</p>\n<ul>\n<li>Hello,world\\nI’m zhangsan\\nHo</li>\n<li>w are you?\\n</li>\n</ul>\n<p>现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    ByteBuffer source &#x3D; ByteBuffer.allocate(32);\n    &#x2F;&#x2F;                     11            24\n    source.put(&quot;Hello,world\\nI&#39;m zhangsan\\nHo&quot;.getBytes());\n    split(source);\n\n    source.put(&quot;w are you?\\nhaha!\\n&quot;.getBytes());\n    split(source);\n&#125;\n\n    private static void split(ByteBuffer source) &#123;\n        source.flip();\n        for (int i &#x3D; 0; i &lt; source.limit(); i++) &#123;\n            &#x2F;&#x2F; 找到一条完整消息\n            if (source.get(i) &#x3D;&#x3D; &#39;\\n&#39;) &#123;\n                int length &#x3D; i + 1 - source.position();\n                &#x2F;&#x2F; 把这条完整消息存入新的 ByteBuffer\n                ByteBuffer target &#x3D; ByteBuffer.allocate(length);\n                &#x2F;&#x2F; 从 source 读，向 target 写\n                for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                    target.put(source.get());&#x2F;&#x2F;\n                &#125;\n                debugAll(target);\n            &#125;\n        &#125;\n        source.compact();&#x2F;&#x2F;Ho copy覆盖,待拼接ne！\n    &#125;</code></pre>\n\n\n\n<h2 id=\"3-文件编程\"><a href=\"#3-文件编程\" class=\"headerlink\" title=\"3. 文件编程\"></a>3. 文件编程</h2><h3 id=\"3-1-FileChannel\"><a href=\"#3-1-FileChannel\" class=\"headerlink\" title=\"3.1 FileChannel\"></a>3.1 FileChannel</h3><h4 id=\"⚠️-FileChannel-工作模式\"><a href=\"#⚠️-FileChannel-工作模式\" class=\"headerlink\" title=\"⚠️ FileChannel 工作模式\"></a>⚠️ FileChannel 工作模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>FileChannel 只能工作在阻塞模式下，不能select非阻塞！</strong></p></blockquote>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><p>不能直接打开 FileChannel，必须【通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们<strong>都有 getChannel 方法</strong>】</p>\n<ul>\n<li>通过 FileInputStream 获取的 channel 只能读</li>\n<li>通过 FileOutputStream 获取的 channel 只能写</li>\n<li>通过 RandomAccessFile 是否能读写根据<strong>构造 RandomAccessFile 时的读写模式决定</strong></li>\n</ul>\n<h4 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int readBytes &#x3D; channel.read(buffer);</code></pre>\n\n\n\n<h4 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuffer buffer &#x3D; ...;\nbuffer.put(...); &#x2F;&#x2F; 存入数据\nbuffer.flip();   &#x2F;&#x2F; 切换读模式\n\nwhile(buffer.hasRemaining()) &#123;\n    channel.write(buffer);\n&#125;</code></pre>\n\n<p>在 while 中调用 channel.write 是因为 <strong>write 方法并不能保证一次将 buffer 中的内容全部写入 channel</strong></p>\n<h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>获取当前位置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long pos &#x3D; channel.position();</code></pre>\n\n<p>设置当前位置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long newPos &#x3D; ...;\nchannel.position(newPos);</code></pre>\n\n<p>设置当前位置时，如果设置为文件的末尾</p>\n<ul>\n<li>这时读取会返回 -1 </li>\n<li>这时写入，会追加内容，但要<strong>注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</strong></li>\n</ul>\n<h4 id=\"大小\"><a href=\"#大小\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>使用 size 方法获取文件的大小</p>\n<h4 id=\"强制写入\"><a href=\"#强制写入\" class=\"headerlink\" title=\"强制写入\"></a>强制写入</h4><p>【操作系统出于性能的考虑，会将数据缓存】，不是立刻写入磁盘。可以调用 <strong>force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</strong></p>\n<h3 id=\"3-2-两个-Channel-传输数据-nio-c3\"><a href=\"#3-2-两个-Channel-传输数据-nio-c3\" class=\"headerlink\" title=\"3.2 两个 Channel 传输数据-nio.c3\"></a>3.2 两个 Channel 传输数据-nio.c3</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String FROM &#x3D; &quot;helloword&#x2F;data.txt&quot;;\nString TO &#x3D; &quot;helloword&#x2F;to.txt&quot;;\nlong start &#x3D; System.nanoTime();\ntry (FileChannel from &#x3D; new FileInputStream(FROM).getChannel();\n     FileChannel to &#x3D; new FileOutputStream(TO).getChannel();\n    ) &#123;\n    from.transferTo(0, from.size(), to);&#x2F;&#x2F;\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\nlong end &#x3D; System.nanoTime();\nSystem.out.println(&quot;transferTo 用时：&quot; + (end - start) &#x2F; 1000_000.0);</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">transferTo 用时：8.2011</code></pre>\n\n\n\n<p>超过 2g 大小的文件传输\tTestFileChannelTransferTo</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestFileChannelTransferTo &#123;\n    public static void main(String[] args) &#123;\n        try (\n                FileChannel from &#x3D; new FileInputStream(&quot;data.txt&quot;).getChannel();\n                FileChannel to &#x3D; new FileOutputStream(&quot;to.txt&quot;).getChannel();\n        ) &#123;\n            &#x2F;&#x2F; 效率高，底层会利用操作系统的零拷贝进行优化\n            long size &#x3D; from.size();\n            &#x2F;&#x2F; left 变量代表【还剩余多少字节】\n            for (long left &#x3D; size; left &gt; 0; ) &#123;\n                System.out.println(&quot;position:&quot; + (size - left) + &quot; left:&quot; + left);\n                left -&#x3D; from.transferTo((size - left), left, to);&#x2F;&#x2F;[sz-left ...-&gt;sz]\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>实际传输一个超大文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">position:0 left:7769948160\nposition:2147483647 left:5622464513\nposition:4294967294 left:3474980866\nposition:6442450941 left:1327497219</code></pre>\n\n\n\n<h3 id=\"3-3-Path\"><a href=\"#3-3-Path\" class=\"headerlink\" title=\"3.3 Path\"></a>3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p>\n<ul>\n<li>Path 用来表示文件路径</li>\n<li>Paths 是工具类，用来获取 Path 实例</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;1.txt&quot;); &#x2F;&#x2F; 相对路径 使用 user.dir 环境变量来定位 1.txt\n\nPath source &#x3D; Paths.get(&quot;d:\\\\1.txt&quot;); &#x2F;&#x2F; 绝对路径 代表了  d:\\1.txt\n\nPath source &#x3D; Paths.get(&quot;d:&#x2F;1.txt&quot;); &#x2F;&#x2F; 绝对路径 同样代表了  d:\\1.txt\n\nPath projects &#x3D; Paths.get(&quot;d:\\\\data&quot;, &quot;projects&quot;); &#x2F;&#x2F; 代表了  d:\\data\\projects</code></pre>\n\n<ul>\n<li><code>.</code> 代表了当前路径</li>\n<li><code>..</code> 代表了上一级路径</li>\n</ul>\n<p>例如目录结构如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">d:\n\t|- data\n\t\t|- projects\n\t\t\t|- a\n\t\t\t|- b</code></pre>\n\n<p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;);\nSystem.out.println(path);\nSystem.out.println(path.normalize()); &#x2F;&#x2F; 正常化路径</code></pre>\n\n<p>会输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">d:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b</code></pre>\n\n\n\n<h3 id=\"3-4-Files\"><a href=\"#3-4-Files\" class=\"headerlink\" title=\"3.4 Files\"></a>3.4 Files</h3><p>检查文件是否存在</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nSystem.out.println(Files.exists(path));&#x2F;&#x2F;</code></pre>\n\n\n\n<p>创建一级目录</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\nFiles.createDirectory(path);&#x2F;&#x2F;</code></pre>\n\n<ul>\n<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>\n<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>\n</ul>\n<p>创建多级目录用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&#x2F;d2&quot;);\nFiles.createDirectories(path);&#x2F;&#x2F;</code></pre>\n\n\n\n<p>拷贝文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\n\nFiles.copy(source, target);&#x2F;&#x2F;</code></pre>\n\n<ul>\n<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>\n</ul>\n<p>如果<strong>希望用 source 覆盖掉 target</strong>，需要用 StandardCopyOption 来控制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);&#x2F;&#x2F;REPLACE_EXISTING</code></pre>\n\n\n\n<p>移动文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);&#x2F;&#x2F;ATOMIC_MOVE</code></pre>\n\n<ul>\n<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>\n</ul>\n<p>删除文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\n\nFiles.delete(target);</code></pre>\n\n<ul>\n<li>如果文件不存在，会抛异常 NoSuchFileException</li>\n</ul>\n<p>删除目录</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path target &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\n\nFiles.delete(target);</code></pre>\n\n<ul>\n<li>如果目录还有内容，会抛异常 <strong>DirectoryNotEmptyException</strong></li>\n</ul>\n<h4 id=\"TestFilesWalkFileTree\"><a href=\"#TestFilesWalkFileTree\" class=\"headerlink\" title=\"TestFilesWalkFileTree\"></a>TestFilesWalkFileTree</h4><p>&#x3D;&#x3D;!Extract Method:ctrl+alt+M&#x3D;&#x3D;</p>\n<p>遍历目录文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;    !Extract Method:ctrl+alt+M\n    private static void m1() throws IOException &#123;\n        AtomicInteger dirCount &#x3D; new AtomicInteger();&#x2F;&#x2F;法一\n        AtomicInteger fileCount &#x3D; new AtomicInteger();\n&#x2F;&#x2F;        不是多线程，匿名类里不能使用非final的，所以你必须用对象去做，换成个数组也行【Integer是不可变类！不能++！】\n&#x2F;&#x2F;        因为原子类是引用类型，放到内部类当中【将引用复制到内部类对象所在的堆当中，使用基本数据类型复制会有数据不一致的问题】\n&#x2F;&#x2F;        final int[] cnt &#x3D; &#123;0&#125;;&#x2F;&#x2F;法二\n&#x2F;&#x2F;        SimpleFileVisitor内部类  visitor访问者模式！！！\n        Files.walkFileTree(Paths.get(&quot;D:\\\\Software\\\\Program Files\\\\Java\\\\jdk1.8.0_162&quot;), new SimpleFileVisitor&lt;Path&gt;()&#123;\n            @Override\n            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;\n                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;+dir);\n                dirCount.incrementAndGet();\n&#x2F;&#x2F;                cnt[0]++;\n                return super.preVisitDirectory(dir, attrs);\n            &#125;\n\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n                System.out.println(file);\n                fileCount.incrementAndGet();\n                return super.visitFile(file, attrs);\n            &#125;\n        &#125;);\n        System.out.println(&quot;dir count:&quot; +dirCount);\n        System.out.println(&quot;file count:&quot; +fileCount);\n    &#125;</code></pre>\n\n\n\n<p>统计 jar 的数目</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static void m2() throws IOException &#123;\n    AtomicInteger jarCount &#x3D; new AtomicInteger();\n    Files.walkFileTree(Paths.get(&quot;D:\\\\Software\\\\Program Files\\\\Java\\\\jdk1.8.0_162&quot;), new SimpleFileVisitor&lt;Path&gt;()&#123;\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n            if (file.toString().endsWith(&quot;.jar&quot;)) &#123;&#x2F;&#x2F;\n                System.out.println(file);\n                jarCount.incrementAndGet();\n            &#125;\n            return super.visitFile(file, attrs);\n        &#125;\n    &#125;);\n    System.out.println(&quot;jar count:&quot; +jarCount);\n&#125;</code></pre>\n\n\n\n<p>删除多级目录</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">    public static void main(String[] args) throws IOException &#123;\n\n&#x2F;&#x2F;        m1();\n&#x2F;&#x2F;        m2();\n\n        &#x2F;&#x2F;删除多级目录\n        Files.delete(Paths.get(&quot;D:\\\\Snipaste-1.16.2-x64 - 副本&quot;));&#x2F;&#x2F;DirectoryNotEmptyException!!!\n        &#x2F;&#x2F;先删文件，再删目录\n        Files.walkFileTree(Paths.get(&quot;D:\\\\Snipaste-1.16.2-x64 - 副本&quot;), new SimpleFileVisitor&lt;Path&gt;() &#123;\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n                Files.delete(file);&#x2F;&#x2F;\n                return super.visitFile(file, attrs);\n            &#125;\n            @Override\n            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123;\n                Files.delete(dir);&#x2F;&#x2F;\n                return super.postVisitDirectory(dir, exc);\n            &#125;\n        &#125;);\n    &#125;\n</code></pre>\n\n\n\n<h4 id=\"⚠️-删除很危险\"><a href=\"#⚠️-删除很危险\" class=\"headerlink\" title=\"⚠️ 删除很危险\"></a>⚠️ 删除很危险</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p></blockquote>\n<p>拷贝多级目录\tTestFilesCopy</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long start &#x3D; System.currentTimeMillis();\nString source &#x3D; &quot;D:\\\\Snipaste-1.16.2-x64&quot;;\nString target &#x3D; &quot;D:\\\\Snipaste-1.16.2-x64aaa&quot;;\n\nFiles.walk(Paths.get(source)).forEach(path -&gt; &#123;\n    try &#123;\n        String targetName &#x3D; path.toString().replace(source, target);\n        &#x2F;&#x2F; 是目录\n        if (Files.isDirectory(path)) &#123;\n            Files.createDirectory(Paths.get(targetName));\n        &#125;\n        &#x2F;&#x2F; 是普通文件\n        else if (Files.isRegularFile(path)) &#123;\n            Files.copy(path, Paths.get(targetName));\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;);\nlong end &#x3D; System.currentTimeMillis();\nSystem.out.println(end - start);</code></pre>\n\n\n\n\n\n<h2 id=\"4-网络编程-nio-c4\"><a href=\"#4-网络编程-nio-c4\" class=\"headerlink\" title=\"4. 网络编程-nio.c4\"></a>4. 网络编程-nio.c4</h2><h3 id=\"4-1-非阻塞-vs-阻塞\"><a href=\"#4-1-非阻塞-vs-阻塞\" class=\"headerlink\" title=\"4.1 非阻塞 vs 阻塞\"></a>4.1 非阻塞 vs 阻塞</h3><h4 id=\"1、阻塞\"><a href=\"#1、阻塞\" class=\"headerlink\" title=\"1、阻塞\"></a>1、阻塞</h4><ul>\n<li>阻塞模式下，相关方法都会导致线程暂停<ul>\n<li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li>\n<li>SocketChannel.read 会在<strong>没有数据可读时</strong>让线程暂停</li>\n<li>阻塞的表现其实就是线程暂停了，<strong>暂停期间不会占用 cpu，但线程相当于闲置</strong></li>\n</ul>\n</li>\n<li><strong>单线程下，阻塞方法之间相互影响，几乎不能正常工作</strong>，需要多线程支持</li>\n<li>但多线程下，有新的问题，体现在以下方面<ul>\n<li>32 位 jvm 一个线程 320k，<strong>64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</strong></li>\n<li>可以采用&#x3D;&#x3D;<strong>线程池技术来减少线程数和线程上下文切换，但治标不治本，如果【有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程】，因此不适合长连接，【只适合短连接】</strong>&#x3D;&#x3D;</li>\n</ul>\n</li>\n</ul>\n<p>服务器端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用 nio 来理解阻塞模式, 单线程\n&#x2F;&#x2F; 0. ByteBuffer\nByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F; 1. 创建了服务器\nServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n\n&#x2F;&#x2F; 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n\n&#x2F;&#x2F; 3. 连接集合\nList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();\nwhile (true) &#123;\n    &#x2F;&#x2F; 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    log.debug(&quot;connecting...&quot;);\n    SocketChannel sc &#x3D; ssc.accept(); &#x2F;&#x2F; 阻塞方法，线程停止运行\n    log.debug(&quot;connected... &#123;&#125;&quot;, sc);\n    channels.add(sc);\n    for (SocketChannel channel : channels) &#123;\n        &#x2F;&#x2F; 5. 接收客户端发送的数据\n        log.debug(&quot;before read... &#123;&#125;&quot;, channel);\n        channel.read(buffer); &#x2F;&#x2F; 阻塞方法，线程停止运行\n        buffer.flip();\n        debugRead(buffer);\n        buffer.clear();\n        log.debug(&quot;after read...&#123;&#125;&quot;, channel);\n    &#125;\n&#125;</code></pre>\n\n<p>客户端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        SocketAddress address &#x3D; sc.getLocalAddress();\n        System.out.println(&quot;waiting...&quot;);\n&#x2F;&#x2F;        sc.close();</code></pre>\n\n\n\n<p>S：run\tconnecting\tbefore read()</p>\n<p><strong>C:debug sc-右键evaluate expression</strong>：sc.write(Charset.defaultCharset().encode(“hello”));</p>\n<p>再发“hi”，没反应！需要建立新连接！</p>\n<p>&#x3D;&#x3D;Client-edit conf-勾选Alow parallel run：debug 新C&#x3D;&#x3D;</p>\n<p>sc.write(Charset.defaultCharset().encode(“hi”));</p>\n<p>单线程处理多个连接：accept() read()均阻塞！</p>\n<h4 id=\"2、非阻塞\"><a href=\"#2、非阻塞\" class=\"headerlink\" title=\"2、非阻塞\"></a>2、非阻塞</h4><ul>\n<li>非阻塞模式下，相关方法都不会让线程暂停<ul>\n<li>在 ServerSocketChannel.accept 在没有连接建立时，<strong>会返回 null，继续运行</strong></li>\n<li>SocketChannel.read 在没有数据可读时，<strong>会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept</strong> </li>\n<li>写数据时，线程<strong>只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</strong></li>\n</ul>\n</li>\n<li>但&#x3D;&#x3D;非阻塞模式下，<strong>即使没有</strong>连接建立，和可读数据，<strong>线程仍然在不断运行，白白浪费了 cpu！！！&#x3D;&#x3D;</strong></li>\n<li>&#x3D;&#x3D;<strong>数据【复制】</strong>过程中，<strong>线程实际还是阻塞的（AIO[异步！] 改进</strong>的地方）&#x3D;&#x3D;</li>\n</ul>\n<p>服务器端，客户端代码不变</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用 nio 来理解非阻塞模式, 单线程\n&#x2F;&#x2F; 0. ByteBuffer\nByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F; 1. 创建了服务器\nServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\nssc.configureBlocking(false); &#x2F;&#x2F; 非阻塞模式\n&#x2F;&#x2F; 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n&#x2F;&#x2F; 3. 连接集合\nList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();\nwhile (true) &#123;\n    &#x2F;&#x2F; 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    SocketChannel sc &#x3D; ssc.accept(); &#x2F;&#x2F; 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null\n    if (sc !&#x3D; null) &#123;\n        log.debug(&quot;connected... &#123;&#125;&quot;, sc);\n        sc.configureBlocking(false); &#x2F;&#x2F; 非阻塞模式\n        channels.add(sc);\n    &#125;\n    for (SocketChannel channel : channels) &#123;\n        &#x2F;&#x2F; 5. 接收客户端发送的数据\n        int read &#x3D; channel.read(buffer);&#x2F;&#x2F; 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n        if (read &gt; 0) &#123;\n            buffer.flip();\n            debugRead(buffer);\n            buffer.clear();\n            log.debug(&quot;after read...&#123;&#125;&quot;, channel);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>单线程处理多个连接</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">12:39:32 [DEBUG] [main] c.i.nio.c4.Server - connected... java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:11261]\n12:39:40 [DEBUG] [main] c.i.nio.c4.Server - connected... java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:11268]\n12:39:47 [DEBUG] [main] c.i.nio.c4.Server - connected... java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:11284]</code></pre>\n\n\n\n<h3 id=\"实战：nio-c4！！！\"><a href=\"#实战：nio-c4！！！\" class=\"headerlink\" title=\"实战：nio.c4！！！\"></a>实战：nio.c4！！！</h3><p>Client</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        SocketAddress address &#x3D; sc.getLocalAddress();\n        System.out.println(&quot;waiting...&quot;);\n&#x2F;&#x2F;        sc.close();\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>Server</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.nio.c4;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static cn.itcast.nio.c2.ByteBufferUtil.debugRead;\n\n@Slf4j\npublic class Server &#123;\n\n    public static void main(String[] args) throws IOException &#123;\n&#x2F;&#x2F;&#x2F;&#x2F; 使用 nio 来理解非阻塞模式, 单线程\n&#x2F;&#x2F;&#x2F;&#x2F; 0. ByteBuffer\n&#x2F;&#x2F;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F;&#x2F;&#x2F; 1. 创建了服务器\n&#x2F;&#x2F;        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n&#x2F;&#x2F;        ssc.configureBlocking(false); &#x2F;&#x2F; 非阻塞模式\n&#x2F;&#x2F;&#x2F;&#x2F; 2. 绑定监听端口\n&#x2F;&#x2F;        ssc.bind(new InetSocketAddress(8080));\n&#x2F;&#x2F;&#x2F;&#x2F; 3. 连接集合\n&#x2F;&#x2F;        List&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();\n&#x2F;&#x2F;        while (true) &#123;\n&#x2F;&#x2F;            &#x2F;&#x2F; 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n&#x2F;&#x2F;            SocketChannel sc &#x3D; ssc.accept(); &#x2F;&#x2F; 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null\n&#x2F;&#x2F;            if (sc !&#x3D; null) &#123;\n&#x2F;&#x2F;                log.debug(&quot;connected... &#123;&#125;&quot;, sc);\n&#x2F;&#x2F;                sc.configureBlocking(false); &#x2F;&#x2F; 非阻塞模式\n&#x2F;&#x2F;                channels.add(sc);\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;            for (SocketChannel channel : channels) &#123;\n&#x2F;&#x2F;                &#x2F;&#x2F; 5. 接收客户端发送的数据\n&#x2F;&#x2F;                int read &#x3D; channel.read(buffer);&#x2F;&#x2F; 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n&#x2F;&#x2F;                if (read &gt; 0) &#123;\n&#x2F;&#x2F;                    buffer.flip();\n&#x2F;&#x2F;                    debugRead(buffer);\n&#x2F;&#x2F;                    buffer.clear();\n&#x2F;&#x2F;                    log.debug(&quot;after read...&#123;&#125;&quot;, channel);\n&#x2F;&#x2F;                &#125;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;        &#125;\n\n\n        &#x2F;&#x2F; 1. 创建 selector, 管理多个 channel\n        Selector selector &#x3D; Selector.open();\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        &#x2F;&#x2F; 2. 建立 selector 和 channel 的联系（&lt;-注册）\n        &#x2F;&#x2F; SelectionKey 就是将来事件发生后，通过它可以知道当前是哪个事件和哪个channel的事件\n        SelectionKey sscKey &#x3D; ssc.register(selector, 0, null);\n        &#x2F;&#x2F; key 只关注 accept 事件：监听新的连接请求\n        sscKey.interestOps(SelectionKey.OP_ACCEPT);\n        log.debug(&quot;sscKey:&#123;&#125;&quot;, sscKey);\n\n        &#x2F;&#x2F;观察者模式？？？\n        ssc.bind(new InetSocketAddress(8080));\n        while (true) &#123;\n            &#x2F;&#x2F; 3. 【select 方法： 没有事件发生，线程阻塞，有事件，线程才会恢复运行】\n            &#x2F;&#x2F; select 在【事件未处理时，它不会阻塞】, 事件发生后要么处理，要么取消key.cancel()，不能置之不理！他会继续让你处理cur，非阻塞死循环！\n            selector.select();\n            &#x2F;&#x2F; 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n            &#x2F;&#x2F; 边遍历边删除：不要用增强for遍历，用iter遍历！iter.remove();！\n            Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator(); &#x2F;&#x2F; accept, read\n            while (iter.hasNext()) &#123;\n                SelectionKey key &#x3D; iter.next();\n                &#x2F;&#x2F; 处理key 时，要从 selectedKeys(只+不-) 集合中主动删除，否则下次处理(没事件)就会有问题:NullPointerException!!!\n                iter.remove();\n                log.debug(&quot;key: &#123;&#125;&quot;, key);\n\n                &#x2F;&#x2F; 5. 区分事件类型\n                if (key.isAcceptable()) &#123; &#x2F;&#x2F; 如果是 accept\n                    ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();\n                    SocketChannel sc &#x3D; channel.accept();&#x2F;&#x2F;if(处理完，ssckey不删):下次再accept()会NullPointerException! 故要主动iter.remove()!\n                    sc.configureBlocking(false);\n\n                    SelectionKey scKey &#x3D; sc.register(selector, 0, null);\n                    scKey.interestOps(SelectionKey.OP_READ);&#x2F;&#x2F;accept后注册到read上！\n                    log.debug(&quot;&#123;&#125;&quot;, sc);\n                    log.debug(&quot;scKey:&#123;&#125;&quot;, scKey);\n                &#125; else if (key.isReadable()) &#123; &#x2F;&#x2F; 如果是 read\n                    try &#123;\n                        SocketChannel channel &#x3D; (SocketChannel) key.channel(); &#x2F;&#x2F; 拿到触发事件的channel\n                        ByteBuffer buffer &#x3D; ByteBuffer.allocate(4);\n                        int read &#x3D; channel.read(buffer); &#x2F;&#x2F; 如果是正常断开，read 的方法的返回值是 -1\n                        if(read &#x3D;&#x3D; -1) &#123;\n                            key.cancel();&#x2F;&#x2F;取消!!!sc.close()正常断开！\n                        &#125; else &#123;\n                            buffer.flip();\n&#x2F;&#x2F;                            debugAll(buffer);\n                            System.out.println(Charset.defaultCharset().decode(buffer));\n                        &#125;\n                    &#125; catch (IOException e) &#123;\n                        e.printStackTrace();\n                        &#x2F;&#x2F; 因为客户端(异常)断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）处理异常，accept()阻塞：否则死循环抛异常！\n                        key.cancel();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<p>iter.remove();</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220422154114082.png\" alt=\"image-20220422154114082\"></p>\n<p>异常断开：try-catch:cancel()\tsc.close()正常断开:read&#x3D;&#x3D;-1:cancel()\t否则死循环！</p>\n<p>utf8:中文3B</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220422155300433.png\" alt=\"image-20220422155300433\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sc.write(Charset.defaultCharset().encode(&quot;中国&quot;));</code></pre>\n\n<p>半包现象！</p>\n<h3 id=\"【分步讲解】4-2-Selector\"><a href=\"#【分步讲解】4-2-Selector\" class=\"headerlink\" title=\"【分步讲解】4.2 Selector\"></a>【分步讲解】4.2 Selector</h3><pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph TD\nsubgraph selector 版\nthread --&gt; selector\nselector --&gt; c1(channel)\nselector --&gt; c2(channel)\nselector --&gt; c3(channel)\nend</code></pre>\n\n\n\n<h4 id=\"3、多路复用\"><a href=\"#3、多路复用\" class=\"headerlink\" title=\"3、多路复用\"></a>3、多路复用</h4><p><strong>单线程可以配合 Selector 完成对多个 Channel 可读写【事件】的监控</strong>，这称之为多路复用</p>\n<ul>\n<li><strong>多路复用仅针对网络 IO</strong>、普通文件 IO 没法利用多路复用</li>\n<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>\n<li><strong>有可</strong>连接<strong>事件时才去</strong>连接</li>\n<li>有可读事件才去读取</li>\n<li>有可写事件才去写入<ul>\n<li><strong>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>好处</p>\n<ul>\n<li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>\n<li>让这个线程能够被充分利用</li>\n<li>节约了线程的数量</li>\n<li>减少了线程上下文切换</li>\n</ul>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Selector selector &#x3D; Selector.open();</code></pre>\n\n\n\n<h4 id=\"绑定-Channel-事件\"><a href=\"#绑定-Channel-事件\" class=\"headerlink\" title=\"绑定 Channel 事件\"></a>绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心 </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">channel.configureBlocking(false);\nSelectionKey key &#x3D; channel.register(selector, 绑定事件);</code></pre>\n\n<ul>\n<li>channel 必须工作在非阻塞模式</li>\n<li><strong>FileChannel 没有非阻塞模式</strong>，因此不能配合 selector 一起使用</li>\n<li>绑定的事件类型可以有<ul>\n<li>【connect - 客户端连接成功】时触发</li>\n<li>accept - 服务器端成功接受连接时触发</li>\n<li>read - 数据可读入时触发，有因为S接收能力弱，数据暂不能读入的情况</li>\n<li>write - 数据可写出时触发，有因为S发送能力弱，数据暂不能写出的情况</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"监听-Channel-事件\"><a href=\"#监听-Channel-事件\" class=\"headerlink\" title=\"监听 Channel 事件\"></a>监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p>\n<p>方法1，阻塞直到绑定事件发生</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int count &#x3D; selector.select();</code></pre>\n\n\n\n<p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int count &#x3D; selector.select(long timeout);</code></pre>\n\n\n\n<p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值(事件数)检查是否有事件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int count &#x3D; selector.selectNow();</code></pre>\n\n\n\n<h4 id=\"💡-select-何时不阻塞\"><a href=\"#💡-select-何时不阻塞\" class=\"headerlink\" title=\"💡 select 何时不阻塞\"></a>💡 select 何时不阻塞</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>事件发生时<ul>\n<li>客户端发起连接请求，会触发 accept 事件</li>\n<li>【客户端发送数据过来，客户端正常、异常关闭时】，都会触发 read 事件，另外如果客户端发送的数据<strong>大于 buffer 缓冲区，会触发多次读取</strong>事件</li>\n<li>channel 可写，会触发 write 事件</li>\n<li>在 <strong>linux 下 nio bug 发生</strong>时</li>\n</ul>\n</li>\n<li>调用 <strong>selector.wakeup()</strong></li>\n<li>调用 <strong>selector.close()</strong></li>\n<li>selector 所在<strong>线程 interrupt</strong></li>\n</ul></blockquote>\n<h3 id=\"4-3-处理-accept-事件\"><a href=\"#4-3-处理-accept-事件\" class=\"headerlink\" title=\"4.3 处理 accept 事件\"></a>4.3 处理 accept 事件</h3><p>客户端代码为</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Client &#123;\n    public static void main(String[] args) &#123;\n        try (Socket socket &#x3D; new Socket(&quot;localhost&quot;, 8080)) &#123;\n            System.out.println(socket);\n            socket.getOutputStream().write(&quot;world&quot;.getBytes());\n            System.in.read();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>服务器端代码为</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class ChannelDemo6 &#123;\n    public static void main(String[] args) &#123;\n        try (ServerSocketChannel channel &#x3D; ServerSocketChannel.open()) &#123;\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector &#x3D; Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) &#123;\n                int count &#x3D; selector.select();\n&#x2F;&#x2F;                int count &#x3D; selector.selectNow();\n                log.debug(&quot;select count: &#123;&#125;&quot;, count);\n&#x2F;&#x2F;                if(count &lt;&#x3D; 0) &#123;\n&#x2F;&#x2F;                    continue;\n&#x2F;&#x2F;                &#125;\n\n                &#x2F;&#x2F; 获取所有事件\n                Set&lt;SelectionKey&gt; keys &#x3D; selector.selectedKeys();\n\n                &#x2F;&#x2F; 遍历所有事件，逐一处理\n                Iterator&lt;SelectionKey&gt; iter &#x3D; keys.iterator();\n                while (iter.hasNext()) &#123;\n                    SelectionKey key &#x3D; iter.next();\n                    &#x2F;&#x2F; 判断事件类型\n                    if (key.isAcceptable()) &#123;\n                        ServerSocketChannel c &#x3D; (ServerSocketChannel) key.channel();\n                        &#x2F;&#x2F; 必须处理\n                        SocketChannel sc &#x3D; c.accept();\n                        log.debug(&quot;&#123;&#125;&quot;, sc);\n                    &#125;\n                    &#x2F;&#x2F; 处理完毕，必须将事件移除\n                    iter.remove();\n                &#125;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"💡-事件发生后能否不处理\"><a href=\"#💡-事件发生后能否不处理\" class=\"headerlink\" title=\"💡 事件发生后能否不处理\"></a>💡 事件发生后能否不处理</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 【nio 底层使用的是水平触发？？？】</p></blockquote>\n<h3 id=\"4-4-处理-read-事件\"><a href=\"#4-4-处理-read-事件\" class=\"headerlink\" title=\"4.4 处理 read 事件\"></a>4.4 处理 read 事件</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class ChannelDemo6 &#123;\n    public static void main(String[] args) &#123;\n        try (ServerSocketChannel channel &#x3D; ServerSocketChannel.open()) &#123;\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector &#x3D; Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) &#123;\n                int count &#x3D; selector.select();\n&#x2F;&#x2F;                int count &#x3D; selector.selectNow();\n                log.debug(&quot;select count: &#123;&#125;&quot;, count);\n&#x2F;&#x2F;                if(count &lt;&#x3D; 0) &#123;\n&#x2F;&#x2F;                    continue;\n&#x2F;&#x2F;                &#125;\n\n                &#x2F;&#x2F; 获取所有事件\n                Set&lt;SelectionKey&gt; keys &#x3D; selector.selectedKeys();\n\n                &#x2F;&#x2F; 遍历所有事件，逐一处理\n                Iterator&lt;SelectionKey&gt; iter &#x3D; keys.iterator();\n                while (iter.hasNext()) &#123;\n                    SelectionKey key &#x3D; iter.next();\n                    &#x2F;&#x2F; 判断事件类型\n                    if (key.isAcceptable()) &#123;\n                        ServerSocketChannel c &#x3D; (ServerSocketChannel) key.channel();\n                        &#x2F;&#x2F; 必须处理\n                        SocketChannel sc &#x3D; c.accept();\n                        sc.configureBlocking(false);\n                        sc.register(selector, SelectionKey.OP_READ);\n                        log.debug(&quot;连接已建立: &#123;&#125;&quot;, sc);\n                    &#125; else if (key.isReadable()) &#123;\n                        SocketChannel sc &#x3D; (SocketChannel) key.channel();\n                        ByteBuffer buffer &#x3D; ByteBuffer.allocate(128);\n                        int read &#x3D; sc.read(buffer);\n                        if(read &#x3D;&#x3D; -1) &#123;\n                            key.cancel();\n                            sc.close();\n                        &#125; else &#123;\n                            buffer.flip();\n                            debug(buffer);\n                        &#125;\n                    &#125;\n                    &#x2F;&#x2F; 处理完毕，必须将事件移除\n                    iter.remove();\n                &#125;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>开启两个客户端，修改一下发送文字，输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sun.nio.ch.ServerSocketChannelImpl[&#x2F;0:0:0:0:0:0:0:0:8080]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60367]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60378]\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 6f 72 6c 64                                  |world           |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n<h4 id=\"💡-为何要-iter-remove\"><a href=\"#💡-为何要-iter-remove\" class=\"headerlink\" title=\"💡 为何要 iter.remove()\"></a>💡 为何要 iter.remove()</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>因为 select 在事件发生后，就[会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除]。例如</p>\n<ul>\n<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li>\n<li>第二次<strong>触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</strong></li>\n</ul></blockquote>\n<h4 id=\"💡-cancel-的作用\"><a href=\"#💡-cancel-的作用\" class=\"headerlink\" title=\"💡 cancel 的作用\"></a>💡 cancel 的作用</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>cancel 会<strong>取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</strong></p></blockquote>\n<h4 id=\"⚠️-不处理边界的问题\"><a href=\"#⚠️-不处理边界的问题\" class=\"headerlink\" title=\"⚠️  不处理边界的问题\"></a>⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Server &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket ss&#x3D;new ServerSocket(9000);\n        while (true) &#123;\n            Socket s &#x3D; ss.accept();\n            InputStream in &#x3D; s.getInputStream();\n            &#x2F;&#x2F; 这里这么写，有没有问题\n            byte[] arr &#x3D; new byte[4];\n            while(true) &#123;\n                int read &#x3D; in.read(arr);\n                &#x2F;&#x2F; 这里这么写，有没有问题\n                if(read &#x3D;&#x3D; -1) &#123;\n                    break;\n                &#125;\n                System.out.println(new String(arr, 0, read));\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>客户端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Socket max &#x3D; new Socket(&quot;localhost&quot;, 9000);\n        OutputStream out &#x3D; max.getOutputStream();\n        out.write(&quot;hello&quot;.getBytes());\n        out.write(&quot;world&quot;.getBytes());\n        out.write(&quot;你好&quot;.getBytes());\n        max.close();\n    &#125;\n&#125;</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">hell\nowor\nld�\n�好\n</code></pre>\n\n<p>为什么？</p>\n<h4 id=\"处理消息的边界！！！\"><a href=\"#处理消息的边界！！！\" class=\"headerlink\" title=\"处理消息的边界！！！\"></a>处理消息的边界！！！</h4><p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0023.png\"></p>\n<ul>\n<li>一种思路是<strong>固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</strong></li>\n<li>另一种思路是<strong>按分隔符拆分，缺点是效率低</strong></li>\n<li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，<strong>缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量</strong><ul>\n<li>Http 1.1 是 TLV 格式 content-type\tcontent-length</li>\n<li>Http 2.0 是 LTV 格式</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220422160404090.png\" alt=\"image-20220422160404090\"></p>\n<p>if不扩容，会分成两次，局部变量buffer被覆盖：</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220422162229473.png\" alt=\"image-20220422162229473\"></p>\n<p>buffer扩容：</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">sequenceDiagram \nparticipant c1 as 客户端1\nparticipant s as 服务器\nparticipant b1 as ByteBuffer1\nparticipant b2 as ByteBuffer2\nc1 -&gt;&gt; s: 发送 01234567890abcdef3333\\r\ns -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef\ns -&gt;&gt; b2: 扩容\nb1 -&gt;&gt; b2: 拷贝 01234567890abcdef\ns -&gt;&gt; b2: 第二次 read 存入 3333\\r\nb2 -&gt;&gt; b2: 01234567890abcdef3333\\r</code></pre>\n\n<p>服务器端Server\tTestByteBufferExam.split\t分隔符匹配拆分法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static void split(ByteBuffer source) &#123;\n    source.flip();\n    for (int i &#x3D; 0; i &lt; source.limit(); i++) &#123;\n        &#x2F;&#x2F; 找到一条完整消息\n        if (source.get(i) &#x3D;&#x3D; &#39;\\n&#39;) &#123;\n            int length &#x3D; i + 1 - source.position();\n            &#x2F;&#x2F; 把这条完整消息存入新的 ByteBuffer\n            ByteBuffer target &#x3D; ByteBuffer.allocate(length);\n            &#x2F;&#x2F; 从 source 读，向 target 写\n            for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                target.put(source.get());\n            &#125;\n            debugAll(target);\n        &#125;\n    &#125;\n    source.compact(); &#x2F;&#x2F; 0123456789abcdef  position 16 limit 16\n&#125;\n\npublic static void main(String[] args) throws IOException &#123;\n    &#x2F;&#x2F; 1. 创建 selector, 管理多个 channel\n    Selector selector &#x3D; Selector.open();\n    ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    &#x2F;&#x2F; 2. 建立 selector 和 channel 的联系（注册）\n    &#x2F;&#x2F; SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件\n    SelectionKey sscKey &#x3D; ssc.register(selector, 0, null);\n    &#x2F;&#x2F; key 只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    log.debug(&quot;sscKey:&#123;&#125;&quot;, sscKey);\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) &#123;\n        &#x2F;&#x2F; 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行\n        &#x2F;&#x2F; select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理\n        selector.select();\n        &#x2F;&#x2F; 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n        Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator(); &#x2F;&#x2F; accept, read\n        while (iter.hasNext()) &#123;\n            SelectionKey key &#x3D; iter.next();\n            &#x2F;&#x2F; 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题\n            iter.remove();\n            log.debug(&quot;key: &#123;&#125;&quot;, key);\n            &#x2F;&#x2F; 5. 区分事件类型\n            if (key.isAcceptable()) &#123; &#x2F;&#x2F; 如果是 accept\n                ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();\n                SocketChannel sc &#x3D; channel.accept();\n                sc.configureBlocking(false);\n                ByteBuffer buffer &#x3D; ByteBuffer.allocate(16); &#x2F;&#x2F; attachment\n                &#x2F;&#x2F; 将一个 byteBuffer 作为附件关联到 selectionKey 上\n                SelectionKey scKey &#x3D; sc.register(selector, 0, buffer);\n                scKey.interestOps(SelectionKey.OP_READ);\n                log.debug(&quot;&#123;&#125;&quot;, sc);\n                log.debug(&quot;scKey:&#123;&#125;&quot;, scKey);\n            &#125; else if (key.isReadable()) &#123; &#x2F;&#x2F; 如果是 read\n                try &#123;\n                    SocketChannel channel &#x3D; (SocketChannel) key.channel(); &#x2F;&#x2F; 拿到触发事件的channel\n                    &#x2F;&#x2F; 获取 selectionKey 上关联的附件\n                    ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();\n                    int read &#x3D; channel.read(buffer); &#x2F;&#x2F; 如果是正常断开，read 的方法的返回值是 -1\n                    if(read &#x3D;&#x3D; -1) &#123;\n                        key.cancel();\n                    &#125; else &#123;\n                        split(buffer);&#x2F;&#x2F;\n                        &#x2F;&#x2F; 需要扩容\n                        if (buffer.position() &#x3D;&#x3D; buffer.limit()) &#123;\n                            ByteBuffer newBuffer &#x3D; ByteBuffer.allocate(buffer.capacity() * 2);\n                            buffer.flip();\n                            newBuffer.put(buffer); &#x2F;&#x2F; 0123456789abcdef3333\\n\n                            key.attach(newBuffer);\n                        &#125;\n                    &#125;\n\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                    key.cancel();  &#x2F;&#x2F; 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>客户端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SocketChannel sc &#x3D; SocketChannel.open();\nsc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\nSocketAddress address &#x3D; sc.getLocalAddress();\n&#x2F;&#x2F; sc.write(Charset.defaultCharset().encode(&quot;hello\\nworld\\n&quot;));\nsc.write(Charset.defaultCharset().encode(&quot;0123\\n456789abcdef\\n&quot;));\nsc.write(Charset.defaultCharset().encode(&quot;0123456789abcdef3333\\n&quot;));\nSystem.in.read();</code></pre>\n\n\n\n<p>netty则可自适应扩缩容buffer大小，更加精细~</p>\n<h4 id=\"ByteBuffer-大小分配\"><a href=\"#ByteBuffer-大小分配\" class=\"headerlink\" title=\"ByteBuffer 大小分配\"></a>ByteBuffer 大小分配</h4><ul>\n<li>每个 channel 都需要记录可能被切分的消息，<strong>因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer【关联附件 attchment() attach(newBuffer)】</strong></li>\n<li>ByteBuffer 不能太大，比如<strong>一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</strong><ul>\n<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer <strong>内容拷贝</strong>至 8k buffer，<strong>优点是消息连续容易处理，缺点是数据拷贝耗费性能</strong>【上例】，参考实现 <a href=\"http://tutorials.jenkov.com/java-performance/resizable-array.html\">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>\n<li>另一种思路是<strong>用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</strong>【eg：Netty中的CompositeByteBuffer！】</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-5-处理-write-事件WriteServer-x2F-Client\"><a href=\"#4-5-处理-write-事件WriteServer-x2F-Client\" class=\"headerlink\" title=\"4.5 处理 write 事件\tWriteServer&#x2F;Client\"></a>4.5 处理 write 事件\tWriteServer&#x2F;Client</h3><p>while处理该sc，其他sc来了处理不了！！！效率不高！</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220422170133644.png\" alt=\"image-20220422170133644\"></p>\n<p>一堆0：写缓冲区满了【转去：读】，没被消费，因为写不了！</p>\n<h4 id=\"一次无法写完例子\"><a href=\"#一次无法写完例子\" class=\"headerlink\" title=\"一次无法写完例子\"></a>一次无法写完例子</h4><ul>\n<li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>\n<li><strong>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多</strong>，就有<strong>两阶段策略</strong><ul>\n<li>当消息处理器<strong>第一次写入消息时，才将 channel 注册</strong>到 selector 上</li>\n<li>selector <strong>检查 channel 上的可写事件，如果所有的数据写完了，就取消</strong> channel 的<strong>注册</strong></li>\n<li>如果<strong>不取消，会每次可写均会触发 write 事件</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class WriteServer &#123;\n\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        ssc.bind(new InetSocketAddress(8080));\n\n        Selector selector &#x3D; Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true) &#123;\n            selector.select();\n\n            Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\n            while (iter.hasNext()) &#123;\n                SelectionKey key &#x3D; iter.next();\n                iter.remove();\n                if (key.isAcceptable()) &#123;\n                    SocketChannel sc &#x3D; ssc.accept();\n                    sc.configureBlocking(false);\n                    SelectionKey sckey &#x3D; sc.register(selector, SelectionKey.OP_READ);\n                    &#x2F;&#x2F; 1. 向客户端发送内容\n                    StringBuilder sb &#x3D; new StringBuilder();\n                    for (int i &#x3D; 0; i &lt; 3000000; i++) &#123;\n                        sb.append(&quot;a&quot;);\n                    &#125;\n                    ByteBuffer buffer &#x3D; Charset.defaultCharset().encode(sb.toString());\n                    int write &#x3D; sc.write(buffer);\n                    &#x2F;&#x2F; 3. write 表示实际写了多少字节\n                    System.out.println(&quot;实际写入字节:&quot; + write);\n                    &#x2F;&#x2F; 4. 如果有剩余未读字节，才需要关注写事件\n                    if (buffer.hasRemaining()) &#123;\n                        &#x2F;&#x2F; read 1  write 4\n                        &#x2F;&#x2F; 在原有关注事件的基础上，多关注 写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        &#x2F;&#x2F; 把 buffer 作为附件加入 sckey\n                        sckey.attach(buffer);\n                    &#125;\n                &#125; else if (key.isWritable()) &#123;\n                    ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();\n                    SocketChannel sc &#x3D; (SocketChannel) key.channel();\n                    int write &#x3D; sc.write(buffer);\n                    System.out.println(&quot;实际写入字节:&quot; + write);\n                    if (!buffer.hasRemaining()) &#123; &#x2F;&#x2F; 写完了\n                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);\n                        key.attach(null);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>客户端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class WriteClient &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Selector selector &#x3D; Selector.open();\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.configureBlocking(false);\n        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        int count &#x3D; 0;\n        while (true) &#123;\n            selector.select();\n            Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\n            while (iter.hasNext()) &#123;\n                SelectionKey key &#x3D; iter.next();\n                iter.remove();\n                if (key.isConnectable()) &#123;\n                    System.out.println(sc.finishConnect());\n                &#125; else if (key.isReadable()) &#123;\n                    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024 * 1024);\n                    count +&#x3D; sc.read(buffer);\n                    buffer.clear();\n                    System.out.println(count);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"💡-write-为何要取消\"><a href=\"#💡-write-为何要取消\" class=\"headerlink\" title=\"💡 write 为何要取消\"></a>💡 write 为何要取消</h4><p>只要向 channel 发送数据时，[socket 缓冲可写，这个事件会频繁触发]，因此<strong>应当[只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注]</strong></p>\n<h3 id=\"4-6-更进一步\"><a href=\"#4-6-更进一步\" class=\"headerlink\" title=\"4.6 更进一步\"></a>4.6 更进一步</h3><h4 id=\"💡-利用多线程优化\"><a href=\"#💡-利用多线程优化\" class=\"headerlink\" title=\"💡 利用多线程优化\"></a>💡 利用多线程优化</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p></blockquote>\n<p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p>\n<p>分两组选择器</p>\n<ul>\n<li><strong>单线程配一个选择器，专门处理 accept</strong> 事件</li>\n<li>创建 <strong>cpu 核心数的线程，每个线程配一个选择器，轮流处理 read</strong> 事件</li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220423172400956.png\" alt=\"image-20220423172400956\"></p>\n<p>duplicate line: ctrl+D</p>\n<p>move line down: alt+shift+下</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220424095453950.png\" alt=\"image-20220424095453950\"></p>\n<p>新C又被阻，不可读！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.nio.c4;\n\nimport javafx.concurrent.Worker;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static cn.itcast.nio.c2.ByteBufferUtil.debugAll;\n\n@Slf4j\npublic class MultiThreadServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Thread.currentThread().setName(&quot;boss&quot;);\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        Selector boss &#x3D; Selector.open();\n        SelectionKey bossKey &#x3D; ssc.register(boss, 0, null);\n        bossKey.interestOps(SelectionKey.OP_ACCEPT);\n        ssc.bind(new InetSocketAddress(8080));\n\n        &#x2F;&#x2F;static方法不能调用非static(成员)内部类！（还不存在！）\n        &#x2F;&#x2F; 1. 创建固定数量的 worker 并初始化\n        Worker[] workers &#x3D; new Worker[Runtime.getRuntime().availableProcessors()];\n        for (int i &#x3D; 0; i &lt; workers.length; i++) &#123;\n            workers[i] &#x3D; new Worker(&quot;worker-&quot; + i);\n        &#125;\n        AtomicInteger index &#x3D; new AtomicInteger();&#x2F;&#x2F;\n\n        while(true) &#123;\n            boss.select();\n            Iterator&lt;SelectionKey&gt; iter &#x3D; boss.selectedKeys().iterator();\n            while (iter.hasNext()) &#123;\n                SelectionKey key &#x3D; iter.next();\n                iter.remove();\n                if (key.isAcceptable()) &#123;\n                    SocketChannel sc &#x3D; ssc.accept();\n                    sc.configureBlocking(false);\n\n                    log.debug(&quot;connected...&#123;&#125;&quot;, sc.getRemoteAddress());\n                    &#x2F;&#x2F; 2. 关联 selector\n                    log.debug(&quot;before register...&#123;&#125;&quot;, sc.getRemoteAddress());\n                    &#x2F;&#x2F; round robin 轮询\n                    workers[index.getAndIncrement() % workers.length].register(sc); &#x2F;&#x2F;[1] boss 调用 初始化 selector , 启动 worker-0\n                    &#x2F;&#x2F; worker.register(sc);\n                    &#x2F;&#x2F; sc.register(worker.selector, SelectionKey.OP_READ, null); &#x2F;&#x2F; boss--&gt;应该下移到worker中！跨worker先后顺序不可控！\n                    log.debug(&quot;after register...&#123;&#125;&quot;, sc.getRemoteAddress());\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    static class Worker implements Runnable&#123;\n        private Thread thread;\n        private Selector selector;\n        private String name;\n        private volatile boolean start &#x3D; false; &#x2F;&#x2F; 还未初始化\n        private ConcurrentLinkedQueue&lt;Runnable&gt; queue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();\n        public Worker(String name) &#123;\n            this.name &#x3D; name;\n        &#125;\n\n        &#x2F;&#x2F; 初始化线程，和 selector\n        public void register(SocketChannel sc) throws IOException &#123;\n            if(!start) &#123;\n                selector &#x3D; Selector.open();\n                thread &#x3D; new Thread(this, name);\n                thread.start();\n                start &#x3D; true;\n            &#125;\n            selector.wakeup(); &#x2F;&#x2F; （1）唤醒 select 方法 boss  【(卖票)一次性，可先后，等fd】 goto-implement：WindowsSelectorImpl\n            sc.register(selector, SelectionKey.OP_READ, null); &#x2F;&#x2F; （2）boss   select不阻塞才能reg成功\n        &#125;\n\n        @Override\n        public void run() &#123;\n            while(true) &#123;\n                try &#123;\n                    selector.select(); &#x2F;&#x2F; （3）worker-0  阻塞 【(1、2)(3)3句顺序均OK！！！】\n                    Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\n                    while (iter.hasNext()) &#123;\n                        SelectionKey key &#x3D; iter.next();\n                        iter.remove();\n                        if (key.isReadable()) &#123;\n                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n                            SocketChannel channel &#x3D; (SocketChannel) key.channel();\n                            log.debug(&quot;read...&#123;&#125;&quot;, channel.getRemoteAddress());\n                            channel.read(buffer);\n                            buffer.flip();\n                            debugAll(buffer);\n                        &#125;\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n\n&#x2F;&#x2F;    static class Worker implements Runnable &#123;\n&#x2F;&#x2F;        private Thread thread;\n&#x2F;&#x2F;        private Selector selector;\n&#x2F;&#x2F;        private String name;\n&#x2F;&#x2F;        private volatile boolean start &#x3D; false; &#x2F;&#x2F;还未初始化\n&#x2F;&#x2F;        private ConcurrentLinkedQueue&lt;Runnable&gt; queue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();&#x2F;&#x2F;两线程间传递数据：ConcurrentLinkedQueue解耦！见P161！同netty做法！\n&#x2F;&#x2F;\n&#x2F;&#x2F;        public Worker(String name) &#123;\n&#x2F;&#x2F;            this.name &#x3D; name;\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;        &#x2F;&#x2F;[1] 初始化线程，和selector\n&#x2F;&#x2F;        public void register(SocketChannel sc) throws IOException &#123;\n&#x2F;&#x2F;            if(!start) &#123;&#x2F;&#x2F;first time!\n&#x2F;&#x2F;                selector &#x3D; Selector.open();\n&#x2F;&#x2F;                thread &#x3D; new Thread(this, name);\n&#x2F;&#x2F;                thread.start();&#x2F;&#x2F;[2]\n&#x2F;&#x2F;                start &#x3D; true;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;            &#x2F;&#x2F;[3.2] boss：向队列里添加了任务，但此任务并没有立刻执行！\n&#x2F;&#x2F;            queue.add(()-&gt;&#123;\n&#x2F;&#x2F;                try &#123;\n&#x2F;&#x2F;                    sc.register(selector, SelectionKey.OP_READ, null); &#x2F;&#x2F; 仍然是boss里执行！用ConcurrentLinkedQueue解耦\n&#x2F;&#x2F;                &#125; catch (ClosedChannelException e) &#123;\n&#x2F;&#x2F;                    e.printStackTrace();\n&#x2F;&#x2F;                &#125;\n&#x2F;&#x2F;            &#125;);\n&#x2F;&#x2F;            selector.wakeup(); &#x2F;&#x2F;[4] 唤醒 run()里的 selector.select() 方法\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;        @Override\n&#x2F;&#x2F;        public void run() &#123;&#x2F;&#x2F;[2]worker: new start!\n&#x2F;&#x2F;            while(true) &#123;\n&#x2F;&#x2F;                try &#123;\n&#x2F;&#x2F;                    selector.select();&#x2F;&#x2F;[3.1] worker-0 阻塞:等到事件发生(first:还没reg(read),等别的事件发生:晚) 被wakeup()主动唤醒:reg(read)\n&#x2F;&#x2F;                    Runnable task &#x3D; queue.poll();\n&#x2F;&#x2F;                    if(task !&#x3D; null) &#123;\n&#x2F;&#x2F;                        task.run();&#x2F;&#x2F;[5] worker:执行了 sc.register(selector, SelectionKey.OP_READ, null);\n&#x2F;&#x2F;                    &#125;\n&#x2F;&#x2F;                    Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\n&#x2F;&#x2F;                    while(iter.hasNext()) &#123;\n&#x2F;&#x2F;                        SelectionKey key &#x3D; iter.next();\n&#x2F;&#x2F;                        iter.remove();\n&#x2F;&#x2F;                        if(key.isReadable()) &#123;\n&#x2F;&#x2F;                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F;                            SocketChannel channel &#x3D; (SocketChannel) key.channel();\n&#x2F;&#x2F;                            log.debug(&quot;read...&#123;&#125;&quot;, channel.getRemoteAddress());\n&#x2F;&#x2F;                            channel.read(buffer);\n&#x2F;&#x2F;                            buffer.flip();\n&#x2F;&#x2F;                            debugAll(buffer);\n&#x2F;&#x2F;                            &#x2F;&#x2F; 细节：粘包半包，捉异常退出cancel，可多次写...\n&#x2F;&#x2F;                        &#125;\n&#x2F;&#x2F;                    &#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;                &#125; catch (IOException e) &#123;\n&#x2F;&#x2F;                    e.printStackTrace();\n&#x2F;&#x2F;                &#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;    &#125;\n\n&#125;\n</code></pre>\n\n<p>数组Worker[].length &#x2F;&#x2F;字段！！！\tstr.length()！！！</p>\n<p>① 对于Object中wait和notify：必须在锁中使用，这里指synchronized，并且wait方法要先于notify，否则wait方法会一直阻塞该该线程。</p>\n<p>② Lock中lock.newCondition:condition.await()和condition.signal()：必须在锁中使用，这里指lock.lock()之后，并且await方法要先于singnal，否则await方法会一直阻塞该该线程。</p>\n<p>为我们提供了一种方便的基于同一个锁， 实现多个条件的 wait() 和 notify() 操作。<code>Condition</code>接口把<code>Object</code>中的<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>分解到了不同对象中，搭配上任意一种Lock使用，使得一个对象可以存在于多个<strong>等待集</strong>。</p>\n<p><img src=\"https://img-blog.csdn.net/20170923153729093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVuZ3hpYW8xOTkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast#pic_center\" alt=\"图片来源于https://blog.csdn.net/lengxiao1993/article/details/81482410\"></p>\n<p>③ LockSupport优势，优势1：类静态方法，不需要在锁中进行；优势二：<strong>park方法可以不先于unpark方法。</strong></p>\n<p><a href=\"https://blog.csdn.net/weixin_44601714/article/details/100081131\">https://blog.csdn.net/weixin_44601714/article/details/100081131</a></p>\n<p>其他线程如果因为调用了selector.select()或者selector.select(long)这两个方法而阻塞， 调用了selector.wakeup()之后，就会立即返回结果，并且返回的值!&#x3D;0， <strong>如果当前Selector没有阻塞在select方法上， 那么本次 wakeup调用会在下一次select阻塞(可以不先于)的时候生效。</strong></p>\n<p>select()方法会阻塞，是因为<strong>用户态将socket的文件描述符和感兴趣的事件传递给操作系统底层的pipe？，底层函数【执行完成，触发事件之后底层就会向用户态返回数据】，这样才会打破阻塞</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200403141222532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FjY2VsZXJhdGluZw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Selector wakeup() &#123;\n    synchronized(this.interruptLock) &#123;\n        if (!this.interruptTriggered) &#123;\n            this.setWakeupSocket();\n            this.interruptTriggered &#x3D; true;\n        &#125;\n\n        return this;\n    &#125;\n&#125;\n&#x2F;&#x2F;这里追到了native方法\nprivate native void setWakeupSocket0(int var1);</code></pre>\n\n<p>setWakeupSocket()方法 会直接<strong>向pipe中添加wakeupSinkFD，这个FD会立即执行完成并且返回数据，这样底层就会给用户态数据，然后结束阻塞</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChannelDemo7 &#123;\n    public static void main(String[] args) throws IOException &#123;\n        new BossEventLoop().register();\n    &#125;\n\n\n    @Slf4j\n    static class BossEventLoop implements Runnable &#123;\n        private Selector boss;\n        private WorkerEventLoop[] workers;\n        private volatile boolean start &#x3D; false;\n        AtomicInteger index &#x3D; new AtomicInteger();\n\n        public void register() throws IOException &#123;\n            if (!start) &#123;\n                ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n                ssc.bind(new InetSocketAddress(8080));\n                ssc.configureBlocking(false);\n                boss &#x3D; Selector.open();\n                SelectionKey ssckey &#x3D; ssc.register(boss, 0, null);\n                ssckey.interestOps(SelectionKey.OP_ACCEPT);\n                workers &#x3D; initEventLoops();\n                new Thread(this, &quot;boss&quot;).start();\n                log.debug(&quot;boss start...&quot;);\n                start &#x3D; true;\n            &#125;\n        &#125;\n\n        public WorkerEventLoop[] initEventLoops() &#123;\n&#x2F;&#x2F;        EventLoop[] eventLoops &#x3D; new EventLoop[Runtime.getRuntime().availableProcessors()];\n            WorkerEventLoop[] workerEventLoops &#x3D; new WorkerEventLoop[2];\n            for (int i &#x3D; 0; i &lt; workerEventLoops.length; i++) &#123;\n                workerEventLoops[i] &#x3D; new WorkerEventLoop(i);\n            &#125;\n            return workerEventLoops;\n        &#125;\n\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                try &#123;\n                    boss.select();\n                    Iterator&lt;SelectionKey&gt; iter &#x3D; boss.selectedKeys().iterator();\n                    while (iter.hasNext()) &#123;\n                        SelectionKey key &#x3D; iter.next();\n                        iter.remove();\n                        if (key.isAcceptable()) &#123;\n                            ServerSocketChannel c &#x3D; (ServerSocketChannel) key.channel();\n                            SocketChannel sc &#x3D; c.accept();\n                            sc.configureBlocking(false);\n                            log.debug(&quot;&#123;&#125; connected&quot;, sc.getRemoteAddress());\n                            workers[index.getAndIncrement() % workers.length].register(sc);\n                        &#125;\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    @Slf4j\n    static class WorkerEventLoop implements Runnable &#123;\n        private Selector worker;\n        private volatile boolean start &#x3D; false;\n        private int index;\n\n        private final ConcurrentLinkedQueue&lt;Runnable&gt; tasks &#x3D; new ConcurrentLinkedQueue&lt;&gt;();\n\n        public WorkerEventLoop(int index) &#123;\n            this.index &#x3D; index;\n        &#125;\n\n        public void register(SocketChannel sc) throws IOException &#123;\n            if (!start) &#123;\n                worker &#x3D; Selector.open();\n                new Thread(this, &quot;worker-&quot; + index).start();\n                start &#x3D; true;\n            &#125;\n            tasks.add(() -&gt; &#123;\n                try &#123;\n                    SelectionKey sckey &#x3D; sc.register(worker, 0, null);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    worker.selectNow();&#x2F;&#x2F;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;);\n            worker.wakeup();\n        &#125;\n\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                try &#123;\n                    worker.select();\n                    Runnable task &#x3D; tasks.poll();\n                    if (task !&#x3D; null) &#123;\n                        task.run();\n                    &#125;\n                    Set&lt;SelectionKey&gt; keys &#x3D; worker.selectedKeys();\n                    Iterator&lt;SelectionKey&gt; iter &#x3D; keys.iterator();\n                    while (iter.hasNext()) &#123;\n                        SelectionKey key &#x3D; iter.next();\n                        if (key.isReadable()) &#123;\n                            SocketChannel sc &#x3D; (SocketChannel) key.channel();\n                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(128);\n                            try &#123;\n                                int read &#x3D; sc.read(buffer);\n                                if (read &#x3D;&#x3D; -1) &#123;\n                                    key.cancel();\n                                    sc.close();\n                                &#125; else &#123;\n                                    buffer.flip();\n                                    log.debug(&quot;&#123;&#125; message:&quot;, sc.getRemoteAddress());\n                                    debugAll(buffer);\n                                &#125;\n                            &#125; catch (IOException e) &#123;\n                                e.printStackTrace();\n                                key.cancel();\n                                sc.close();\n                            &#125;\n                        &#125;\n                        iter.remove();\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"💡-如何拿到-cpu-个数\"><a href=\"#💡-如何拿到-cpu-个数\" class=\"headerlink\" title=\"💡 如何拿到 cpu 个数\"></a>💡 如何拿到 cpu 个数</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li><strong>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</strong>\tjdk8下部署，最好手动指定几核！</li>\n<li>这个问题直到 <strong>jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</strong></li>\n</ul></blockquote>\n<p>CPU计算密集型：核心数、IO密集型：THs&gt;核数 Amdahl定律：<img src=\"https://www.zhihu.com/equation?tex=Time+=+s+++%5Cfrac%7Bf%7D%7Bp%7D\" alt=\"[公式]\"></p>\n<ul>\n<li><img src=\"https://www.zhihu.com/equation?tex=s\" alt=\"[公式]\"> 串行部分</li>\n<li><img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"[公式]\"> 并行部分</li>\n<li><img src=\"https://www.zhihu.com/equation?tex=p\" alt=\"[公式]\"> 核数</li>\n</ul>\n<h3 id=\"4-7-UDP\"><a href=\"#4-7-UDP\" class=\"headerlink\" title=\"4.7 UDP\"></a>4.7 UDP</h3><ul>\n<li>UDP 是<strong>无连接的，client 发送数据不会管 server 是否开启</strong></li>\n<li>server 这边的 <strong>receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</strong></li>\n</ul>\n<p>首先启动服务器端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UdpServer &#123;\n    public static void main(String[] args) &#123;\n        try (DatagramChannel channel &#x3D; DatagramChannel.open()) &#123;\n            channel.socket().bind(new InetSocketAddress(9999));&#x2F;&#x2F;\n            System.out.println(&quot;waiting...&quot;);\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(32);\n            channel.receive(buffer);&#x2F;&#x2F;\n            buffer.flip();\n            debug(buffer);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">waiting...</code></pre>\n\n\n\n<p>运行客户端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UdpClient &#123;\n    public static void main(String[] args) &#123;\n        try (DatagramChannel channel &#x3D; DatagramChannel.open()) &#123;\n            ByteBuffer buffer &#x3D; StandardCharsets.UTF_8.encode(&quot;hello&quot;);\n            InetSocketAddress address &#x3D; new InetSocketAddress(&quot;localhost&quot;, 9999);\n            channel.send(buffer, address);&#x2F;&#x2F;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>接下来服务器端输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n\n\n<h2 id=\"5-NIO-vs-BIO\"><a href=\"#5-NIO-vs-BIO\" class=\"headerlink\" title=\"5. NIO vs BIO\"></a>5. NIO vs BIO</h2><h3 id=\"5-1-stream-vs-channel\"><a href=\"#5-1-stream-vs-channel\" class=\"headerlink\" title=\"5.1 stream vs channel\"></a>5.1 stream vs channel</h3><ul>\n<li><strong>stream 不会自动缓冲</strong>数据，<strong>channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</strong></li>\n<li>stream 仅支持阻塞 API，<strong>channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</strong></li>\n<li>二者<strong>均为全双工，即读写可以同时</strong>进行？？？</li>\n</ul>\n<h3 id=\"5-2-IO-模型\"><a href=\"#5-2-IO-模型\" class=\"headerlink\" title=\"5.2 IO 模型\"></a>5.2 IO 模型</h3><p>&#x3D;&#x3D;同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞&#x3D;&#x3D;</p>\n<ul>\n<li>同步：<strong>线程自己去获取结果</strong>（一个线程）</li>\n<li>异步：线程自己不去获取结果，而是<strong>由其它线程送结果（至少两个线程）</strong></li>\n</ul>\n<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>\n<ul>\n<li>等待数据阶段</li>\n<li>复制数据阶段</li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0033.png\"></p>\n<ul>\n<li><p>阻塞 IO</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0039.png\"></p>\n</li>\n<li><p>非阻塞  IO    两态切换过于频繁</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0035.png\"></p>\n</li>\n<li><p>多路复用</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0038.png\"></p>\n</li>\n<li><p>阻塞 IO[串行] vs 多路复用[一次性拿到一批events，循环分类处理]</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0034.png\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0036.png\"></p>\n<ul>\n<li><p>信号驱动</p>\n</li>\n<li><p>异步 IO    th1定义了回调直接返回，th2调用回调函数，填入参，送结果</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0037.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"🔖-参考\"><a href=\"#🔖-参考\" class=\"headerlink\" title=\"🔖 参考\"></a>🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p>\n<h3 id=\"5-3-零拷贝\"><a href=\"#5-3-零拷贝\" class=\"headerlink\" title=\"5.3 零拷贝\"></a>5.3 零拷贝</h3><h4 id=\"传统-IO-问题\"><a href=\"#传统-IO-问题\" class=\"headerlink\" title=\"传统 IO 问题\"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File f &#x3D; new File(&quot;helloword&#x2F;data.txt&quot;);\nRandomAccessFile file &#x3D; new RandomAccessFile(file, &quot;r&quot;);\n\nbyte[] buf &#x3D; new byte[(int)f.length()];\nfile.read(buf);&#x2F;&#x2F;12\n\nSocket socket &#x3D; ...;\nsocket.getOutputStream().write(buf);&#x2F;&#x2F;34</code></pre>\n\n<p>内部工作流程是这样的：</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0024.png\"></p>\n<ol>\n<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间【用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu】</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p></blockquote>\n</li>\n<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>\n</li>\n<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>\n</li>\n<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，【使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu】</p>\n</li>\n</ol>\n<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>\n<ul>\n<li>用户态与内核<strong>态的切换发生了 3 次</strong>，这个操作比较重量级</li>\n<li>数据<strong>拷贝了共 4 次</strong></li>\n</ul>\n<h4 id=\"NIO-优化\"><a href=\"#NIO-优化\" class=\"headerlink\" title=\"NIO 优化\"></a>NIO 优化</h4><p>通过 &#x3D;&#x3D;DirectByteBuf&#x3D;&#x3D;</p>\n<ul>\n<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>\n<li><strong>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</strong></li>\n</ul>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0025.png\"></p>\n<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使&#x3D;&#x3D;<strong>用 DirectByteBuf 将【堆外内存映射到 jvm 内存中来直接访问】使用</strong>&#x3D;&#x3D;</p>\n<ul>\n<li>&#x3D;&#x3D;这块内存<strong>不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</strong>&#x3D;&#x3D;</li>\n<li>java 中的 &#x3D;&#x3D;<strong>DirectByteBuf 对象仅维护了此内存的虚引用</strong>&#x3D;&#x3D;，内存回收分成两步<ul>\n<li>DirectByteBuf <strong>对象被垃圾回收，将[虚引用加入引用队列]</strong></li>\n<li>通过&#x3D;&#x3D;专门线程访问引用队列，根据虚引用释放堆外内存&#x3D;&#x3D;</li>\n</ul>\n</li>\n<li><strong>只减少了一次数据拷贝</strong>，用户态与内核<strong>态的切换次数没有减少</strong></li>\n</ul>\n<p>进一步优化（底层采用了 &#x3D;&#x3D;linux 2.1&#x3D;&#x3D; 后提供的 <strong>sendFile 方法</strong>），java 中对应着<strong>两个 channel 调用 transferTo&#x2F;transferFrom 方法拷贝数据</strong></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0026.png\"></p>\n<ol>\n<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>\n<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，【cpu 会参与拷贝】</li>\n<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>\n</ol>\n<p>可以看到</p>\n<ul>\n<li>只发生了一次用户态与内核态的切换</li>\n<li>数据拷贝了 3 次</li>\n</ul>\n<p>进一步优化&#x3D;&#x3D;（linux 2.4）&#x3D;&#x3D;</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0027.png\"></p>\n<ol>\n<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>\n<li>只会将一些&#x3D;&#x3D;【offset 和 length 信息】拷入 <strong>socket 缓冲区</strong>，几乎无消耗&#x3D;&#x3D;</li>\n<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>\n</ol>\n<p>整个过程&#x3D;&#x3D;仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次&#x3D;&#x3D;。所谓的【零拷贝】，并不是真正无拷贝，而是【不会再拷贝重复数据到 jvm 内存中】，零拷贝的优点有</p>\n<ul>\n<li>更少的用户态与内核【态的切换】</li>\n<li>【不利用 cpu 计算】，&#x3D;&#x3D;减少 cpu 缓存伪共享&#x3D;&#x3D;</li>\n<li>零拷贝<strong>适合小文件传</strong>输【缓冲区，反复RW：小文件！】</li>\n</ul>\n<h3 id=\"5-3-AIO\"><a href=\"#5-3-AIO\" class=\"headerlink\" title=\"5.3 AIO\"></a>5.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p>\n<ul>\n<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于[闲置]</li>\n<li>异步意味着，在进行读写操作时，线程[不必等待]结果，而是[将来由操作系统来通过回调方式由另外的线程来获得结果]</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>异步模型需要底层操作系统（Kernel）提供支持</p>\n<ul>\n<li>&#x3D;&#x3D;Windows 系统通过 IOCP 实现了真正的异步 IO？？？&#x3D;&#x3D;(I&#x2F;O Completion Port,I&#x2F;O完成端口) 线程池。。。</li>\n<li>Linux 系统异步 IO 在 【2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势，且引入不必要的复杂性。】 Netty5基于此的API也被废弃了，目前最新就用Netty4！</li>\n</ul></blockquote>\n<h4 id=\"文件-AIO\"><a href=\"#文件-AIO\" class=\"headerlink\" title=\"文件 AIO\"></a>文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class AioDemo1 &#123;\n    public static void main(String[] args) throws IOException &#123;\n        try&#123;\n            AsynchronousFileChannel s &#x3D; \n                AsynchronousFileChannel.open(\n                \tPaths.get(&quot;1.txt&quot;), StandardOpenOption.READ);\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(2);\n            log.debug(&quot;begin...&quot;);\n            s.read(buffer, 0, null, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) &#123;\n                    log.debug(&quot;read completed...&#123;&#125;&quot;, result);\n                    buffer.flip();\n                    debug(buffer);\n                &#125;\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) &#123;\n                    log.debug(&quot;read failed...&quot;);\n                &#125;\n            &#125;);\n\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        log.debug(&quot;do other things...&quot;);\n        System.in.read();&#x2F;&#x2F;\n    &#125;\n&#125;</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...\n13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0d                                           |a.              |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>可以看到</p>\n<ul>\n<li>响应文件读取成功的是另一个线程 Thread-5</li>\n<li>主线程并没有 IO 操作阻塞</li>\n</ul>\n<h4 id=\"💡-守护线程\"><a href=\"#💡-守护线程\" class=\"headerlink\" title=\"💡 守护线程\"></a>💡 守护线程</h4><p>&#x3D;&#x3D;&#x3D;默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束&#x3D;&#x3D;</p>\n<h4 id=\"网络-AIO\"><a href=\"#网络-AIO\" class=\"headerlink\" title=\"网络 AIO\"></a>网络 AIO</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AioServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        AsynchronousServerSocketChannel ssc &#x3D; AsynchronousServerSocketChannel.open();\n        ssc.bind(new InetSocketAddress(8080));\n        ssc.accept(null, new AcceptHandler(ssc));\n        System.in.read();\n    &#125;\n\n    private static void closeChannel(AsynchronousSocketChannel sc) &#123;\n        try &#123;\n            System.out.printf(&quot;[%s] %s close\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());\n            sc.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    private static class ReadHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;\n        private final AsynchronousSocketChannel sc;\n\n        public ReadHandler(AsynchronousSocketChannel sc) &#123;\n            this.sc &#x3D; sc;\n        &#125;\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) &#123;\n            try &#123;\n                if (result &#x3D;&#x3D; -1) &#123;\n                    closeChannel(sc);\n                    return;\n                &#125;\n                System.out.printf(&quot;[%s] %s read\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());\n                attachment.flip();\n                System.out.println(Charset.defaultCharset().decode(attachment));\n                attachment.clear();\n                &#x2F;&#x2F; 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件\n                sc.read(attachment, attachment, this);\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) &#123;\n            closeChannel(sc);\n            exc.printStackTrace();\n        &#125;\n    &#125;\n\n    private static class WriteHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;\n        private final AsynchronousSocketChannel sc;\n\n        private WriteHandler(AsynchronousSocketChannel sc) &#123;\n            this.sc &#x3D; sc;\n        &#125;\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) &#123;\n            &#x2F;&#x2F; 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容\n            if (attachment.hasRemaining()) &#123;\n                sc.write(attachment);\n            &#125;\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) &#123;\n            exc.printStackTrace();\n            closeChannel(sc);\n        &#125;\n    &#125;\n\n    private static class AcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; &#123;\n        private final AsynchronousServerSocketChannel ssc;\n\n        public AcceptHandler(AsynchronousServerSocketChannel ssc) &#123;\n            this.ssc &#x3D; ssc;\n        &#125;\n\n        @Override\n        public void completed(AsynchronousSocketChannel sc, Object attachment) &#123;\n            try &#123;\n                System.out.printf(&quot;[%s] %s connected\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n            &#x2F;&#x2F; 读事件由 ReadHandler 处理\n            sc.read(buffer, buffer, new ReadHandler(sc));\n            &#x2F;&#x2F; 写事件由 WriteHandler 处理\n            sc.write(Charset.defaultCharset().encode(&quot;server hello!&quot;), ByteBuffer.allocate(16), new WriteHandler(sc));\n            &#x2F;&#x2F; 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件\n            ssc.accept(null, this);\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, Object attachment) &#123;\n            exc.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"二-Netty-入门\"><a href=\"#二-Netty-入门\" class=\"headerlink\" title=\"二. Netty 入门\"></a>二. Netty 入门</h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><h3 id=\"1-1-Netty-是什么？\"><a href=\"#1-1-Netty-是什么？\" class=\"headerlink\" title=\"1.1 Netty 是什么？\"></a>1.1 Netty 是什么？</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Netty is an asynchronous event-driven network application framework\nfor rapid development of maintainable high performance protocol servers &amp; clients.</code></pre>\n\n<p>Netty 是一个[调用时]异步的[用多线程将方法调用与处理结果相分离]、基于事件驱动[IO模型还是selector多路复用]的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>\n<h3 id=\"1-2-Netty-的作者\"><a href=\"#1-2-Netty-的作者\" class=\"headerlink\" title=\"1.2 Netty 的作者\"></a>1.2 Netty 的作者</h3><p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0005.png\"></p>\n<p>他还是另一个著名网络应用框架 Apache Mina 的重要贡献者</p>\n<h3 id=\"1-3-Netty-的地位\"><a href=\"#1-3-Netty-的地位\" class=\"headerlink\" title=\"1.3 Netty 的地位\"></a>1.3 Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>\n<p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p>\n<ul>\n<li>Cassandra - nosql 数据库</li>\n<li>Spark - 大数据分布式[计算]框架</li>\n<li>Hadoop - 大数据分布式[存储]框架</li>\n<li>RocketMQ - ali 开源的消息队列</li>\n<li>ElasticSearch - 搜索引擎</li>\n<li>gRPC - rpc 框架</li>\n<li>Dubbo - rpc 框架</li>\n<li>Spring 5.x - flux api (WebFlux) 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>\n<li>Zookeeper - 分布式协调框架</li>\n</ul>\n<h3 id=\"1-4-Netty-的优势\"><a href=\"#1-4-Netty-的优势\" class=\"headerlink\" title=\"1.4 Netty 的优势\"></a>1.4 Netty 的优势</h3><ul>\n<li>Netty vs NIO，工作量大，bug 多<ul>\n<li>需要自己构建协议</li>\n<li>解决 TCP 传输问题，如粘包、半包</li>\n<li>epoll 空轮询导致 CPU 100%</li>\n<li>对 API 进行增强，使之更易用，如 [FastThreadLocal] &#x3D;&gt; ThreadLocal，[ByteBuf] &#x3D;&gt; ByteBuffer</li>\n</ul>\n</li>\n<li>Netty vs 其它网络应用框架<ul>\n<li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li>\n<li>久经考验，16年，Netty 版本<ul>\n<li>2.x 2004</li>\n<li>3.x 2008</li>\n<li>4.x 2013</li>\n<li>5.x 已废弃（没有明显的性能提升，维护成本高）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Hello-World\"><a href=\"#2-Hello-World\" class=\"headerlink\" title=\"2. Hello World\"></a>2. Hello World</h2><h3 id=\"2-1-目标\"><a href=\"#2-1-目标\" class=\"headerlink\" title=\"2.1 目标\"></a>2.1 目标</h3><p>开发一个简单的服务器端和客户端</p>\n<ul>\n<li>客户端向服务器端发送 hello, world</li>\n<li>服务器仅接收，不返回</li>\n</ul>\n<p>加入依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.1.39.Final&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n\n\n\n\n<h3 id=\"2-2-服务器端\"><a href=\"#2-2-服务器端\" class=\"headerlink\" title=\"2.2 服务器端\"></a>2.2 服务器端</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new ServerBootstrap()\n    .group(new NioEventLoopGroup()) &#x2F;&#x2F; 1\n    .channel(NioServerSocketChannel.class) &#x2F;&#x2F; 2\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; &#x2F;&#x2F; 3\n        protected void initChannel(NioSocketChannel ch) &#123;\n            ch.pipeline().addLast(new StringDecoder()); &#x2F;&#x2F; 5\n            ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123; &#x2F;&#x2F; 6\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;\n                    System.out.println(msg);\n                &#125;\n            &#125;);\n        &#125;\n    &#125;)\n    .bind(8080); &#x2F;&#x2F; 4</code></pre>\n\n<p>代码解读</p>\n<ul>\n<li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p>\n</li>\n<li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0006.png\"></p>\n</li>\n<li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>\n</li>\n<li><p>4 处，ServerSocketChannel 绑定的监听端口</p>\n</li>\n<li><p>5 处，SocketChannel 的处理器，解码 ByteBuf &#x3D;&gt; String</p>\n</li>\n<li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p>\n</li>\n</ul>\n<h3 id=\"2-3-客户端\"><a href=\"#2-3-客户端\" class=\"headerlink\" title=\"2.3 客户端\"></a>2.3 客户端</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new Bootstrap()\n    .group(new NioEventLoopGroup()) &#x2F;&#x2F; 1\n    .channel(NioSocketChannel.class) &#x2F;&#x2F; 2\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123; &#x2F;&#x2F; 3\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder()); &#x2F;&#x2F; 8\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080) &#x2F;&#x2F; 4\n    .sync() &#x2F;&#x2F; 5\n    .channel() &#x2F;&#x2F; 6\n    .writeAndFlush(new Date() + &quot;: hello world!&quot;); &#x2F;&#x2F; 7</code></pre>\n\n<p>代码解读</p>\n<ul>\n<li><p>1 处，创建 NioEventLoopGroup，同 Server</p>\n</li>\n<li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0007.png\"></p>\n</li>\n<li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>\n</li>\n<li><p>4 处，指定要连接的服务器和端口</p>\n</li>\n<li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</p>\n</li>\n<li><p>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</p>\n</li>\n<li><p>7 处，写入消息并清空缓冲区</p>\n</li>\n<li><p>8 处，消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 发出</p>\n</li>\n<li><p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p>\n</li>\n</ul>\n<h3 id=\"2-4-流程梳理\"><a href=\"#2-4-流程梳理\" class=\"headerlink\" title=\"2.4 流程梳理\"></a>2.4 流程梳理</h3><p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0040.png\"></p>\n<p>filter、interceptor、handler\t责任链</p>\n<h4 id=\"💡-提示\"><a href=\"#💡-提示\" class=\"headerlink\" title=\"💡 提示\"></a>💡 提示</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一开始需要树立正确的观念</p>\n<ul>\n<li>把 channel 理解为数据的通道</li>\n<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>\n<li>把 handler 理解为数据的处理工序<ul>\n<li>工序有多道，合在一起就是 pipeline，<strong>pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写</strong>了相应事件处理方法）</li>\n<li>handler 分 Inbound (-&gt;mem)和 Outbound (-&gt;C)两类</li>\n</ul>\n</li>\n<li>把 eventLoop 理解为处理数据的<strong>工人</strong>【单th池】<ul>\n<li><strong>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定</strong>：TH安全）</li>\n<li>工人既可以执行 <strong>io 操作</strong>，也可以进行<strong>任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</strong></li>\n<li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以<strong>为每道工序（非IO操作的任务）指定不同的工人</strong></li>\n</ul>\n</li>\n</ul></blockquote>\n<h2 id=\"3-组件\"><a href=\"#3-组件\" class=\"headerlink\" title=\"3. 组件\"></a>3. 组件</h2><h3 id=\"3-1-EventLoop-x3D-包装的Selector\"><a href=\"#3-1-EventLoop-x3D-包装的Selector\" class=\"headerlink\" title=\"3.1 EventLoop&#x3D;包装的Selector\"></a>3.1 EventLoop&#x3D;包装的Selector</h3><p>事件循环对象</p>\n<p>EventLoop 本质是一个&#x3D;&#x3D;单线程执行器[任务队列]（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 【io】 事件。&#x3D;&#x3D;</p>\n<p>它的继承关系比较复杂</p>\n<ul>\n<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\n<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，【保证 io 顺序】<ul>\n<li>提供了 boolean inEventLoop(Thread thread) 方法【判断一个线程是否属于此 EventLoop】</li>\n<li>提供了 parent 方法来看看【自己属于哪个 EventLoopGroup】</li>\n</ul>\n</li>\n</ul>\n<p>事件循环组</p>\n<p>EventLoopGroup 是一组 EventLoop，&#x3D;&#x3D;【Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）】&#x3D;&#x3D;</p>\n<ul>\n<li>继承自 netty 自己的 EventExecutorGroup<ul>\n<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>\n<li>另有 next 方法获取集合中下一个 EventLoop</li>\n</ul>\n</li>\n</ul>\n<p>以一个简单的实现为例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程\nDefaultEventLoopGroup group &#x3D; new DefaultEventLoopGroup(2);\nSystem.out.println(group.next());\nSystem.out.println(group.next());\nSystem.out.println(group.next());</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">io.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\nio.netty.channel.DefaultEventLoop@60f82f98</code></pre>\n\n<p>也可以使用 for 循环</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DefaultEventLoopGroup group &#x3D; new DefaultEventLoopGroup(2);\nfor (EventExecutor eventLoop : group) &#123;\n    System.out.println(eventLoop);\n&#125;</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">io.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6</code></pre>\n\n\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static final int DEFAULT_EVENT_LOOP_THREADS &#x3D; Math.max(1, SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));&#x2F;&#x2F;默认线程数：配置，2倍核数，0-&gt;1</code></pre>\n\n\n\n<h4 id=\"演示-NioEventLoop-处理-io-事件\"><a href=\"#演示-NioEventLoop-处理-io-事件\" class=\"headerlink\" title=\"演示 NioEventLoop 处理 io 事件\"></a>演示 NioEventLoop 处理 io 事件</h4><p>服务器端两个 nio worker 工人\tnetty.c3.EventLoopServer</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(NioSocketChannel ch) &#123;\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    ByteBuf byteBuf &#x3D; msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf !&#x3D; null) &#123;\n                        byte[] buf &#x3D; new byte[16];\n                        ByteBuf len &#x3D; byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    &#125;\n                &#125;\n            &#125;);\n        &#125;\n    &#125;).bind(8080).sync();</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220425225312737.png\" alt=\"image-20220425225312737\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220425225832275.png\" alt=\"image-20220425225832275\"></p>\n<p>EventLoopClient</p>\n<p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException &#123;\n    Channel channel &#x3D; new Bootstrap()\n            .group(new NioEventLoopGroup(1))\n            .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n                    System.out.println(&quot;init...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                &#125;\n            &#125;)\n            .channel(NioSocketChannel.class).connect(&quot;localhost&quot;, 8080)\n            .sync()\n            .channel();\n\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;wangwu&quot;.getBytes()));\n    Thread.sleep(2000);\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;wangwu&quot;.getBytes()));</code></pre>\n\n<p>最后输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        \n22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </code></pre>\n\n<p>可以看到两个EventLoop工人轮流处理 channel，但工人与 channel 之间进行了绑定</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0042.png\"></p>\n<p>handler…</p>\n<p>再增加两个非 nio 工人\tEventLoopServer</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DefaultEventLoopGroup normalWorkers &#x3D; new DefaultEventLoopGroup(2);&#x2F;&#x2F;非nio\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))&#x2F;&#x2F;\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(NioSocketChannel ch)  &#123;\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));&#x2F;&#x2F;\n            ch.pipeline().addLast(normalWorkers,&quot;myhandler&quot;,\n              new ChannelInboundHandlerAdapter() &#123;&#x2F;&#x2F;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    ByteBuf byteBuf &#x3D; msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf !&#x3D; null) &#123;\n                        byte[] buf &#x3D; new byte[16];\n                        ByteBuf len &#x3D; byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    &#125;\n                &#125;\n            &#125;);\n        &#125;\n    &#125;).bind(8080).sync();\n\n\n\n\n\n\n\npackage cn.itcast.netty.c3;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.nio.charset.Charset;\n\n@Slf4j\npublic class EventLoopServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 细分2：创建一个独立的 EventLoopGroup\n        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();\n        new ServerBootstrap()\n                &#x2F;&#x2F; boss 和 worker\n                &#x2F;&#x2F; 细分1：boss 只负责 ServerSocketChannel 上 accept 事件     worker 只负责 socketChannel 上的读写\n                .group(new NioEventLoopGroup(), new NioEventLoopGroup(2))&#x2F;&#x2F;默认2*CPUs\n                .channel(NioServerSocketChannel.class)&#x2F;&#x2F;only one!\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n                        ch.pipeline().addLast(&quot;handler1&quot;, new ChannelInboundHandlerAdapter() &#123;&#x2F;&#x2F;io事件\n                            @Override                                         &#x2F;&#x2F; ByteBuf\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                log.debug(buf.toString(Charset.defaultCharset()));\n                                ctx.fireChannelRead(msg); &#x2F;&#x2F; 让消息传递给下一个handler！\n                            &#125;\n                        &#125;);\n                        &#x2F;*.addLast(group, &quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;&#x2F;&#x2F;普通任务\n                            @Override                                         &#x2F;&#x2F; ByteBuf\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                log.debug(buf.toString(Charset.defaultCharset()));\n                            &#125;\n                        &#125;);*&#x2F;\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;\n</code></pre>\n\n<p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] REGISTERED\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] ACTIVE\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] READ COMPLETE\n22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] READ COMPLETE\n22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] REGISTERED\n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] ACTIVE\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] READ COMPLETE\n22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] READ COMPLETE\n22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] REGISTERED\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] ACTIVE\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] READ COMPLETE\n22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] READ COMPLETE\n22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </code></pre>\n\n<p>可以看到，<strong>nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</strong></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0041.png\"></p>\n<p>一个长channelRead会拖慢绑定在worker上监测的其他所有channel的io处理！</p>\n<p>创建独立的DefaultEventLoopGroup：只处理普通&#x2F;定时任务，不处理io事件！</p>\n<h4 id=\"💡-handler-执行中如何换人？\"><a href=\"#💡-handler-执行中如何换人？\" class=\"headerlink\" title=\"💡 handler 执行中如何换人？\"></a>💡 handler 执行中如何换人？</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;\n    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);\n    &#x2F;&#x2F; 下一个 handler 的事件循环是否与当前的事件循环是同一个线程\n    EventExecutor executor &#x3D; next.executor();\n    \n    &#x2F;&#x2F; 是，直接调用\n    if (executor.inEventLoop()) &#123;\n        next.invokeChannelRead(m);\n    &#125; \n    &#x2F;&#x2F; 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）\n    else &#123;\n        executor.execute(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                next.invokeChannelRead(m);\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>如果<strong>两个 handler 绑定的是同一个线程，那么就直接调用</strong></li>\n<li>否则，<strong>把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</strong></li>\n</ul>\n<h4 id=\"演示-NioEventLoop-处理普通任务\"><a href=\"#演示-NioEventLoop-处理普通任务\" class=\"headerlink\" title=\"演示 NioEventLoop 处理普通任务\"></a>演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">NioEventLoopGroup nioWorkers &#x3D; new NioEventLoopGroup(2);\n\nlog.debug(&quot;server start...&quot;);\nThread.sleep(2000);\nnioWorkers.execute(()-&gt;&#123; &#x2F;&#x2F; 或submit\n    log.debug(&quot;normal task...&quot;);\n&#125;);</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以用来执行耗时较长的任务</p></blockquote>\n<h4 id=\"演示-NioEventLoop-处理定时任务\"><a href=\"#演示-NioEventLoop-处理定时任务\" class=\"headerlink\" title=\"演示 NioEventLoop 处理定时任务\"></a>演示 NioEventLoop 处理定时任务</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">NioEventLoopGroup nioWorkers &#x3D; new NioEventLoopGroup(2);\n\nlog.debug(&quot;server start...&quot;);\nThread.sleep(2000);\nnioWorkers.scheduleAtFixedRate(() -&gt; &#123;&#x2F;&#x2F;\n    log.debug(&quot;running...&quot;);\n&#125;, 0, 1, TimeUnit.SECONDS);</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n...</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以用来执行定时任务</p></blockquote>\n<h3 id=\"3-2-Channel！！！\"><a href=\"#3-2-Channel！！！\" class=\"headerlink\" title=\"3.2 Channel！！！\"></a>3.2 Channel！！！</h3><p>channel 的主要作用</p>\n<ul>\n<li>close() 可以用来关闭 channel</li>\n<li>closeFuture() 用来处理 channel 的关闭<ul>\n<li><strong>sync 方法作用是同步等待 channel 关闭</strong></li>\n<li><strong>而 addListener 方法是异步等待 channel 关闭</strong></li>\n</ul>\n</li>\n<li>pipeline() 方法添加处理器</li>\n<li>write() 方法将数据写入</li>\n<li>writeAndFlush() 方法将数据写入并刷出：C-&gt;S</li>\n</ul>\n<h4 id=\"ChannelFuture\"><a href=\"#ChannelFuture\" class=\"headerlink\" title=\"ChannelFuture\"></a>ChannelFuture</h4><p>这时刚才的客户端代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080)\n    .sync()\n    .channel()\n    .writeAndFlush(new Date() + &quot;: hello world!&quot;);</code></pre>\n\n<p>现在把它拆开来看</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ChannelFuture channelFuture &#x3D; new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080); &#x2F;&#x2F; 1\n\nchannelFuture.sync().channel().writeAndFlush(new Date() + &quot;: hello world!&quot;);</code></pre>\n\n<ul>\n<li>1 处返回的是 ChannelFuture 对象，它的作用是<strong>利用 channel() 方法来获取 Channel 对象</strong></li>\n</ul>\n<p><strong>注意</strong> &#x3D;&#x3D;connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象&#x3D;&#x3D;</p>\n<p>实验如下：<strong>sync</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ChannelFuture channelFuture &#x3D; new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080);\n\nSystem.out.println(channelFuture.channel()); &#x2F;&#x2F; 1\nchannelFuture.sync(); &#x2F;&#x2F; 2\nSystem.out.println(channelFuture.channel()); &#x2F;&#x2F; 3</code></pre>\n\n<ul>\n<li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li>\n<li>执行到 2 时，&#x3D;&#x3D;sync 方法是同步等待连接建立完成&#x3D;&#x3D;</li>\n<li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>\n</ul>\n<h4 id=\"x3D-x3D-！！！除了用-sync-方法可以让connect异步操作同步以外，还可以使用回调的方式：-x3D-x3D\"><a href=\"#x3D-x3D-！！！除了用-sync-方法可以让connect异步操作同步以外，还可以使用回调的方式：-x3D-x3D\" class=\"headerlink\" title=\"&#x3D;&#x3D;！！！除了用 sync 方法可以让connect异步操作同步以外，还可以使用回调的方式：&#x3D;&#x3D;\"></a>&#x3D;&#x3D;！！！除了用 sync 方法可以让connect异步操作同步以外，还可以使用<strong>回调</strong>的方式：&#x3D;&#x3D;</h4><p><a href=\"https://zhuanlan.zhihu.com/p/386837957\">https://zhuanlan.zhihu.com/p/386837957</a></p>\n<p>一个ChannelHandler可以简单的理解为一个回调方法，在Netty内部使用【回调来处理事件】；当一个事件被触发时，与事件相关的ChannelHandler将被调用来响应这个事件的处理</p>\n<p>在Netty中，Future提供了一种在【操作完成时[通知]应用程序】的方式。这个对象可以看作是一个异步操作结果的占位符；它将在未来某个时刻完成并提供【对结果的访问】。</p>\n<p>ChannelHandler和Future是【相互补充】的机制；它们相互结合使用构成了Netty本身的关键构件之一。</p>\n<hr>\n<p>虽然可以通过ChannelFuture的get()方法获取异步操作的结果,但完成时间是无法预测的,若不设置超时时间则有可能导致线程长时间被阻塞;若是不能精确的设置超时时间则可能导致I&#x2F;O操作中断.因此,Netty建议通过GenericFutureListener接口执行异步操作结束后的回调.</p>\n<p>ChannelFuture接口额外提供了注册一个或者多个GenericFutureListener实例的方法，监听器的回调方法<code>operationComplete()</code>将会在对应的操作完成时被调用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ChannelFuture channelFuture &#x3D; new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080);\nSystem.out.println(channelFuture.channel()); &#x2F;&#x2F; 1\nchannelFuture.addListener((ChannelFutureListener) future -&gt; &#123;\n    System.out.println(future.channel()); &#x2F;&#x2F; 2\n&#125;);</code></pre>\n\n<ul>\n<li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li>\n<li>&#x3D;&#x3D;ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了&#x3D;&#x3D;，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code></li>\n</ul>\n<h4 id=\"CloseFuture\"><a href=\"#CloseFuture\" class=\"headerlink\" title=\"CloseFuture\"></a>CloseFuture</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class CloseFutureClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        NioEventLoopGroup group new NioEventLoopGroup();\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override &#x2F;&#x2F; 在连接建立后被调用  也是异步回调！相互补充！\n                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        ch.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        Channel channel &#x3D; channelFuture.sync().channel();&#x2F;&#x2F;\n        log.debug(&quot;&#123;&#125;&quot;, channel);\n        new Thread(()-&gt;&#123;&#x2F;&#x2F;\n            Scanner scanner &#x3D; new Scanner(System.in);\n            while (true) &#123;\n                String line &#x3D; scanner.nextLine();\n                if (&quot;q&quot;.equals(line)) &#123;\n                    channel.close(); &#x2F;&#x2F; close 异步操作: 1s 之后【非阻塞！】\n&#x2F;&#x2F;                    log.debug(&quot;处理关闭之后的操作&quot;); &#x2F;&#x2F; 不能在这里善后！可能还没close！\n                    break;\n                &#125;\n                channel.writeAndFlush(line);\n            &#125;\n        &#125;, &quot;input&quot;).start();\n\n        &#x2F;&#x2F; 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭\n        ChannelFuture closeFuture &#x3D; channel.closeFuture();\n        &#x2F;*log.debug(&quot;waiting close...&quot;);\n        closeFuture.sync();\n        log.debug(&quot;处理关闭之后的操作&quot;);*&#x2F;\n        &#x2F;*\n        closeFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                log.debug(&quot;处理关闭之后的操作&quot;);\n                group.shutdownGracefully();&#x2F;&#x2F;\n            &#125;\n        &#125;);*&#x2F;\n        &#x2F;&#x2F;@FunctionalInterface函数式接口&#x2F;功能性接口(单抽象方法接口) 可使用 Lambda 表达式,方法引用和构造函数引用来表示\n        &#x2F;&#x2F;new ChannelFutureListener()&#123;只有一个待重写的单抽象方法：operationComplete&#125;可用lambda表达式简化 alt+enter！！！\n        closeFuture.addListener((ChannelFutureListener) future -&gt; &#123;\n            log.debug(&quot;处理关闭之后的操作&quot;);\n            group.shutdownGracefully();&#x2F;&#x2F;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p>logback.xml</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 用来控制查看那个类的日志内容（对mybatis name 代表命名空间） --&gt;\n&lt;logger name&#x3D;&quot;cn.itcast&quot; level&#x3D;&quot;DEBUG&quot; additivity&#x3D;&quot;false&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt;\n&lt;&#x2F;logger&gt;\n\n&lt;logger name&#x3D;&quot;io.netty.handler.logging.LoggingHandler&quot; level&#x3D;&quot;DEBUG&quot; additivity&#x3D;&quot;false&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt;\n&lt;&#x2F;logger&gt;\n\n&lt;root level&#x3D;&quot;ERROR&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt;\n&lt;&#x2F;root&gt;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220426165553101.png\" alt=\"image-20220426165553101\"></p>\n<h4 id=\"💡-优雅关闭\"><a href=\"#💡-优雅关闭\" class=\"headerlink\" title=\"💡 优雅关闭\"></a>💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会&#x3D;&#x3D;【首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入】，然后【在任务队列的任务都处理完成后，停止线程的运行】&#x3D;&#x3D;。从而【确保整体应用是在正常有序的状态下退出】的</p>\n<p>异常处理中也要<code>shutdownGracefully</code> ！</p>\n<p>&#x3D;&#x3D;Java8 Lambda表达式：@FunctionalInterface函数式接口&#x2F;功能性接口(单抽象方法接口) 可使用 Lambda 表达式,方法引用和构造函数引用来表示&#x3D;&#x3D;</p>\n<h4 id=\"💡-异步提升的是什么！！！\"><a href=\"#💡-异步提升的是什么！！！\" class=\"headerlink\" title=\"💡 异步提升的是什么！！！\"></a>💡 异步提升的是什么！！！</h4><ul>\n<li><p>有些同学看到这里会有疑问：【为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的<strong>异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</strong>】</p>\n</li>\n<li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p>\n</li>\n</ul>\n<h3 id=\"x3D-x3D-【异步-多核多线程！-任务拆分！-流水线pipeline！-响应变慢-协作时间-，吞吐变高！】-x3D-x3D\"><a href=\"#x3D-x3D-【异步-多核多线程！-任务拆分！-流水线pipeline！-响应变慢-协作时间-，吞吐变高！】-x3D-x3D\" class=\"headerlink\" title=\"&#x3D;&#x3D;【异步+多核多线程！ 任务拆分！ 流水线pipeline！ 响应变慢(+协作时间)，吞吐变高！】&#x3D;&#x3D;\"></a>&#x3D;&#x3D;【异步+多核多线程！ 任务拆分！ 流水线pipeline！ 响应变慢(+协作时间)，吞吐变高！】&#x3D;&#x3D;</h3><p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0044.png\"></p>\n<p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0048.png\"></p>\n<p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0047.png\"></p>\n<p>要点</p>\n<ul>\n<li>单线程没法异步提高效率，<strong>必须配合多线程、多核 cpu 才能发挥异步的优势</strong></li>\n<li>&#x3D;&#x3D;异步并没有缩短<strong>响应时间，反而有所增加【提高的是吞吐量：单位时间内处理任务的速度！】</strong>&#x3D;&#x3D;</li>\n<li><strong>合理进行任务拆分</strong>，也是利用异步的关键</li>\n</ul>\n<h3 id=\"3-3-Future-amp-Promise\"><a href=\"#3-3-Future-amp-Promise\" class=\"headerlink\" title=\"3.3 Future &amp; Promise\"></a>3.3 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p>\n<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，<strong>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</strong>\tjdk Future &lt;- Netty Future &lt;- netty Promise</p>\n<ul>\n<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>\n<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要<strong>等任务结束</strong></li>\n<li>netty Promise 不仅有 netty Future 的功能，而且<strong>脱离了任务独立存在，只作为两个线程间传递结果的容器</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能&#x2F;名称</th>\n<th>jdk Future</th>\n<th>netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isCanceled</td>\n<td>任务是否取消</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>任务是否完成，不能区分成功失败</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取任务结果，<strong>阻塞等待</strong>[别的th填结果]  同步</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>getNow</td>\n<td>-</td>\n<td>获取任务结果，非阻塞，<strong>还未产生结果时返回 null</strong></td>\n<td>-</td>\n</tr>\n<tr>\n<td>await</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 <strong>isSuccess</strong> 判断</td>\n<td>-</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>-</td>\n<td>等待任务结束，如果<strong>任务失败，抛出异常</strong>       阻塞，不获取结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isSuccess</td>\n<td>-</td>\n<td>判断任务是否成功</td>\n<td>-</td>\n</tr>\n<tr>\n<td>cause</td>\n<td>-</td>\n<td>获取失败信息，非阻塞，如果【没有失败，返回null】</td>\n<td>-</td>\n</tr>\n<tr>\n<td>addLinstener</td>\n<td>-</td>\n<td>添加【回调，异步接收】结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>setSuccess</td>\n<td>-</td>\n<td>-</td>\n<td>【不等任务结束】self设置成功结果</td>\n</tr>\n<tr>\n<td>setFailure</td>\n<td>-</td>\n<td>-</td>\n<td>设置失败结果</td>\n</tr>\n</tbody></table>\n<p>execute(Runnable)</p>\n<p>submit(Callable 有返回结果！) 配合Future拿结果</p>\n<p>向线程池中提交任务，get返回结果–&gt;主动创建 promise 结果容器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class TestJdkFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 1. 线程池\n        ExecutorService service &#x3D; Executors.newFixedThreadPool(2);\n        &#x2F;&#x2F; 2. 提交任务\n        Future&lt;Integer&gt; future &#x3D; service.submit(new Callable&lt;Integer&gt;() &#123;&#x2F;&#x2F;\n            @Override\n            public Integer call() throws Exception &#123;\n                log.debug(&quot;执行计算&quot;);\n                Thread.sleep(1000);\n                return 50;&#x2F;&#x2F;\n            &#125;\n        &#125;);\n        &#x2F;&#x2F; 3. 主线程通过 future 来同步获取结果\n        log.debug(&quot;等待结果&quot;);\n        log.debug(&quot;结果是 &#123;&#125;&quot;, future.get());&#x2F;&#x2F;\n    &#125;\n&#125;\n\n\n@Slf4j\npublic class TestNettyFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        EventLoop eventLoop &#x3D; group.next();\n        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;\n            @Override\n            public Integer call() throws Exception &#123;\n                log.debug(&quot;执行计算&quot;);\n                Thread.sleep(1000);\n                return 70;\n            &#125;\n        &#125;);\n&#x2F;&#x2F;        log.debug(&quot;等待结果&quot;);\n&#x2F;&#x2F;        log.debug(&quot;结果是 &#123;&#125;&quot;, future.get());\n        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;()&#123;&#x2F;&#x2F;\n            @Override\n            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;\n                log.debug(&quot;接收结果:&#123;&#125;&quot;, future.getNow());&#x2F;&#x2F;\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n\n@Slf4j\npublic class TestNettyPromise &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 1. 准备 EventLoop 对象\n        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();\n        &#x2F;&#x2F; 2. 可以主动创建 promise：结果容器\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);\n        new Thread(() -&gt; &#123;\n            &#x2F;&#x2F; 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果\n            log.debug(&quot;开始计算...&quot;);\n            try &#123;\n                int i &#x3D; 1 &#x2F; 0;\n                Thread.sleep(1000);\n                promise.setSuccess(80);&#x2F;&#x2F;result&#x3D;80\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n                promise.setFailure(e);&#x2F;&#x2F;\n            &#125;\n\n        &#125;).start();\n        &#x2F;&#x2F; 4. 接收结果的线程\n        log.debug(&quot;等待结果...&quot;);\n        log.debug(&quot;结果是: &#123;&#125;&quot;, promise.get());&#x2F;&#x2F;\n    &#125;\n\n&#125;</code></pre>\n\n<h4 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h4><p>同步处理任务成功</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\neventExecutors.execute(()-&gt;&#123;\n    try &#123;\n        Thread.sleep(1000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    log.debug(&quot;set success, &#123;&#125;&quot;,10);\n    promise.setSuccess(10);\n&#125;);\n\nlog.debug(&quot;start...&quot;);\nlog.debug(&quot;&#123;&#125;&quot;,promise.getNow()); &#x2F;&#x2F; 还没有结果\nlog.debug(&quot;&#123;&#125;&quot;,promise.get());</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10</code></pre>\n\n\n\n<h4 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h4><p>异步处理任务成功</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\n&#x2F;&#x2F; 设置回调，异步接收结果\npromise.addListener(future -&gt; &#123;\n    &#x2F;&#x2F; 这里的 future 就是上面的 promise\n    log.debug(&quot;&#123;&#125;&quot;,future.getNow());\n&#125;);\n\n&#x2F;&#x2F; 等待 1000 后设置成功结果\neventExecutors.execute(()-&gt;&#123;\n    try &#123;\n        Thread.sleep(1000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    log.debug(&quot;set success, &#123;&#125;&quot;,10);\n    promise.setSuccess(10);\n&#125;);\n\nlog.debug(&quot;start...&quot;);</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10</code></pre>\n\n\n\n<h4 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h4><p>同步处理任务失败 - sync &amp; get</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\n        eventExecutors.execute(() -&gt; &#123;\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            RuntimeException e &#x3D; new RuntimeException(&quot;error...&quot;);\n            log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());\n            promise.setFailure(e);\n        &#125;);\n\n        log.debug(&quot;start...&quot;);\n        log.debug(&quot;&#123;&#125;&quot;, promise.getNow());\n        promise.get(); &#x2F;&#x2F; sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\nException in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...\n\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)\n\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)\nCaused by: java.lang.RuntimeException: error...\n\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)</code></pre>\n\n\n\n<h4 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h4><p>同步处理任务失败 - await</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\neventExecutors.execute(() -&gt; &#123;\n    try &#123;\n        Thread.sleep(1000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    RuntimeException e &#x3D; new RuntimeException(&quot;error...&quot;);\n    log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());\n    promise.setFailure(e);\n&#125;);\n\nlog.debug(&quot;start...&quot;);\nlog.debug(&quot;&#123;&#125;&quot;, promise.getNow());\npromise.await(); &#x2F;&#x2F; 与 sync 和 get 区别在于，不会抛异常\nlog.debug(&quot;result &#123;&#125;&quot;, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());&#x2F;&#x2F;！！！</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</code></pre>\n\n\n\n<h4 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h4><p>异步处理任务失败</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\npromise.addListener(future -&gt; &#123;\n    log.debug(&quot;result &#123;&#125;&quot;, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());&#x2F;&#x2F;\n&#125;);\n\neventExecutors.execute(() -&gt; &#123;\n    try &#123;\n        Thread.sleep(1000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    RuntimeException e &#x3D; new RuntimeException(&quot;error...&quot;);\n    log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());\n    promise.setFailure(e);\n&#125;);\n\nlog.debug(&quot;start...&quot;);</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</code></pre>\n\n\n\n<h4 id=\"例6\"><a href=\"#例6\" class=\"headerlink\" title=\"例6\"></a>例6</h4><p>await 死锁检查？？？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\neventExecutors.submit(()-&gt;&#123;\n    System.out.println(&quot;1&quot;);\n    try &#123;\n        promise.await();\n        &#x2F;&#x2F; 注意不能仅捕获 InterruptedException 异常\n        &#x2F;&#x2F; 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播\n        &#x2F;&#x2F; 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出\n    &#125; catch (Exception e) &#123; \n        e.printStackTrace();\n    &#125;\n    System.out.println(&quot;2&quot;);\n&#125;);\neventExecutors.submit(()-&gt;&#123;\n    System.out.println(&quot;3&quot;);\n    try &#123;\n        promise.await();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    System.out.println(&quot;4&quot;);\n&#125;);</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n2\n3\n4\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n</code></pre>\n\n\n\n\n\n<h3 id=\"3-4-Handler-amp-Pipeline\"><a href=\"#3-4-Handler-amp-Pipeline\" class=\"headerlink\" title=\"3.4 Handler &amp; Pipeline\"></a>3.4 Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>\n<ul>\n<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来<strong>读取客户端数据，写回结果</strong></li>\n<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要<strong>对写回结果进行加工</strong></li>\n</ul>\n<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道[工序]，而后面要讲的 [ByteBuf 是原材料]，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p>\n<p>先搞清楚顺序，服务端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        protected void initChannel(NioSocketChannel ch) &#123;\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    System.out.println(1);\n                    ctx.fireChannelRead(msg); &#x2F;&#x2F; 1\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    System.out.println(2);\n                    ctx.fireChannelRead(msg); &#x2F;&#x2F; 2\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    System.out.println(3);\n                    ctx.channel().write(msg); &#x2F;&#x2F; 3\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) &#123;\n                    System.out.println(4);\n                    ctx.write(msg, promise); &#x2F;&#x2F; 4\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) &#123;\n                    System.out.println(5);\n                    ctx.write(msg, promise); &#x2F;&#x2F; 5\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) &#123;\n                    System.out.println(6);\n                    ctx.write(msg, promise); &#x2F;&#x2F; 6 &#x3D;super.write(ctx, msg, promise);\n                &#125;\n            &#125;);\n        &#125;\n    &#125;)\n    .bind(8080);</code></pre>\n\n<p>客户端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080)\n    .addListener((ChannelFutureListener) future -&gt; &#123;\n        future.channel().writeAndFlush(&quot;hello,world&quot;);\n    &#125;);</code></pre>\n\n<p>服务器端打印：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n2\n3\n6\n5\n4</code></pre>\n\n<p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0008.png\"></p>\n<ul>\n<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul>\n<li>如果注释掉 1 处代码，则仅会打印 1</li>\n<li>如果注释掉 2 处代码，则仅会打印 1 2</li>\n</ul>\n</li>\n<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul>\n<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>\n</ul>\n</li>\n<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul>\n<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>\n</ul>\n</li>\n<li>ctx.channel().write(msg) vs ctx.write(msg)<ul>\n<li>都是触发出站处理器的执行</li>\n<li><strong>ctx.channel().write(msg) 从尾部开始查找出站处理器</strong></li>\n<li><strong>ctx.write(msg) 是从当前节点找上一个出站处理器</strong></li>\n<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>\n<li><strong>6 处</strong>的 ctx.write(msg, promise) 如果<strong>改为</strong> ctx.channel().write(msg) <strong>会打印 1 2 3 6 6 6…死循环！</strong> 因为 <strong>ctx.channel().write() 是从尾部</strong>开始查找，结果<strong>又是节点6 自己</strong>【应避免！！！】</li>\n</ul>\n</li>\n</ul>\n<p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0009.png\"></p>\n<h4 id=\"x3D-x3D-in-包装-转换-channel-tail倒-out-处理-ctx-x2F-super-cur倒-x3D-x3D\"><a href=\"#x3D-x3D-in-包装-转换-channel-tail倒-out-处理-ctx-x2F-super-cur倒-x3D-x3D\" class=\"headerlink\" title=\"&#x3D;&#x3D;in(包装 转换)-channel(tail倒)\tout(处理)-ctx&#x2F;super(cur倒)&#x3D;&#x3D;\"></a>&#x3D;&#x3D;in(包装 转换)-channel(tail倒)\tout(处理)-ctx&#x2F;super(cur倒)&#x3D;&#x3D;</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.netty.c3;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\n@Slf4j\npublic class TestPipeline &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n                        &#x2F;&#x2F; 1. 通过 channel 拿到 pipeline\n                        ChannelPipeline pipeline &#x3D; ch.pipeline();\n                        &#x2F;&#x2F; 2. 添加处理器 head -&gt;  h1 -&gt; h2 -&gt;  h4 -&gt; h3 -&gt; h5 -&gt; h6 -&gt; tail\n                        pipeline.addLast(&quot;h1&quot;, new ChannelInboundHandlerAdapter()&#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                log.debug(&quot;1&quot;);\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                String name &#x3D; buf.toString(Charset.defaultCharset());&#x2F;&#x2F;ByteBuf2str\n                                super.channelRead(ctx, name);\n                            &#125;\n                        &#125;);\n\n                        pipeline.addLast(&quot;h2&quot;, new ChannelInboundHandlerAdapter()&#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object name) throws Exception &#123;\n                                log.debug(&quot;2&quot;);\n                                Student student &#x3D; new Student(name.toString());\n                                super.channelRead(ctx, student); &#x2F;&#x2F; 将数据传递给下个 Inboundhandler，如果不调用，调用链会断开 或者调用 ctx.fireChannelRead(student);\n                            &#125;\n                        &#125;);\n                        &#x2F;&#x2F;只有向channel里写了数据writeAndFlush，才会触发 出站Handler 【处理数据】 123 | 654\n                        pipeline.addLast(&quot;h4&quot;, new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                log.debug(&quot;4&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n\n                        pipeline.addLast(&quot;h3&quot;, new ChannelInboundHandlerAdapter()&#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                log.debug(&quot;3, 结果&#123;&#125;, class:&#123;&#125;&quot;, msg, msg.getClass());\n&#x2F;&#x2F;                                ctx.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;server...&quot;.getBytes()));&#x2F;&#x2F;从【当前handler开始倒着找out：1243】\n                                ch.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;server...&quot;.getBytes()));&#x2F;&#x2F;从tail开始倒着找out     str2ByteBuf\n                            &#125;\n                        &#125;);\n\n                        pipeline.addLast(&quot;h5&quot;, new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                log.debug(&quot;5&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                        pipeline.addLast(&quot;h6&quot;, new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                log.debug(&quot;6&quot;);\n                                super.write(ctx, msg, promise);&#x2F;&#x2F;&#x3D;ctx.write(msg, promise); 从cur\n&#x2F;&#x2F;                                ctx.channel().write(msg, promise); &#x2F;&#x2F; 从tail： 12366666...死循环！避免out用channel写！！！\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n    @Data\n    @AllArgsConstructor\n    static class Student &#123;\n        private String name;\n    &#125;\n&#125;\n</code></pre>\n\n<p>TestEmbeddedChannel</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">EmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);&#x2F;&#x2F;用于快捷测试handler效果！\n        &#x2F;&#x2F; 模拟入站操作 12\n&#x2F;&#x2F;        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes()));\n        &#x2F;&#x2F; 模拟出站操作 43\n        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;world&quot;.getBytes()));</code></pre>\n\n\n\n<h3 id=\"3-5-ByteBuf\"><a href=\"#3-5-ByteBuf\" class=\"headerlink\" title=\"3.5 ByteBuf\"></a>3.5 ByteBuf</h3><p>是对字节数据的封装</p>\n<h4 id=\"1）创建\"><a href=\"#1）创建\" class=\"headerlink\" title=\"1）创建\"></a>1）创建</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(10);\nlog(buffer);</code></pre>\n\n<p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p>\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">read index:0 write index:0 capacity:10</code></pre>\n\n<p>其中 log 方法参考如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static void log(ByteBuf buffer) &#123;\n    int length &#x3D; buffer.readableBytes();\n    int rows &#x3D; length &#x2F; 16 + (length % 15 &#x3D;&#x3D; 0 ? 0 : 1) + 4;\n    StringBuilder buf &#x3D; new StringBuilder(rows * 80 * 2)\n        .append(&quot;read index:&quot;).append(buffer.readerIndex())\n        .append(&quot; write index:&quot;).append(buffer.writerIndex())\n        .append(&quot; capacity:&quot;).append(buffer.capacity())\n        .append(NEWLINE);\n    appendPrettyHexDump(buf, buffer);\n    System.out.println(buf.toString());\n&#125;</code></pre>\n\n\n\n<h4 id=\"2）直接内存-vs-堆内存\"><a href=\"#2）直接内存-vs-堆内存\" class=\"headerlink\" title=\"2）直接内存 vs 堆内存\"></a>2）直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(10);</code></pre>\n\n<p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(10);</code></pre>\n\n<ul>\n<li>&#x3D;&#x3D;<strong>直接内存创建和销毁的代价昂贵，但读写性能高</strong>（少一次内存复制），<strong>适合配合池化功能一起用</strong>&#x3D;&#x3D;</li>\n<li>直接内存<strong>对 GC 压力小</strong>，因为这部分内存不受 JVM 垃圾回收的管理，但也要<strong>注意及时主动释放</strong></li>\n</ul>\n<h4 id=\"3）池化-vs-非池化\"><a href=\"#3）池化-vs-非池化\" class=\"headerlink\" title=\"3）池化 vs 非池化\"></a>3）池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>\n<ul>\n<li><strong>没有池化</strong>，则【每次都得创建新的 ByteBuf 实例】，这个操作【对直接内存<strong>代价昂贵</strong>，就算是堆内存，也会<strong>增加 GC 压力</strong>】</li>\n<li>有了池化，则可以<strong>重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</strong></li>\n<li><strong>高并发</strong>时，池化功能<strong>更节约内存，减少内存溢出的可能</strong></li>\n</ul>\n<p>池化功能是否开启，可以通过下面的<strong>系统环境变量</strong>来设置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125;</code></pre>\n\n<ul>\n<li><strong>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</strong></li>\n<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestByteBuf &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;VM option:-Dio.netty.allocator.type&#x3D;unpooled\n        ByteBuf buf &#x3D; ByteBufAllocator.DEFAULT.buffer();&#x2F;&#x2F;默认256 ByteBuf可扩容\n        System.out.println(buf.getClass());&#x2F;&#x2F;\n        System.out.println(buf.maxCapacity());&#x2F;&#x2F;2^31-1&#x3D;Integer.Max_VALUE\n        log(buf);\n        StringBuilder sb &#x3D; new StringBuilder();\n        for (int i &#x3D; 0; i &lt; 257; i++) &#123;&#x2F;&#x2F;\n            sb.append(&quot;a&quot;);\n        &#125;\n        buf.writeBytes(sb.toString().getBytes());\n        log(buf);\n    &#125;\n&#125;\n\nclass io.netty.buffer.PooledUnsafeDirectByteBuf\n2147483647\nread index:0 write index:0 capacity:256\nread index:0 write index:257 capacity:512</code></pre>\n\n\n\n<h4 id=\"4）组成\"><a href=\"#4）组成\" class=\"headerlink\" title=\"4）组成\"></a>4）组成</h4><p>ByteBuf 由四部分组成</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0010.png\"></p>\n<p>最开始读写指针都在 0 位置</p>\n<p>flip compact–&gt;Ridx Widx 可扩容</p>\n<h4 id=\"5）写入\"><a href=\"#5）写入\" class=\"headerlink\" title=\"5）写入\"></a>5）写入</h4><p>方法列表，省略一些不重要的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法签名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>writeBoolean(boolean value)</td>\n<td>写入 boolean 值</td>\n<td>用一字节 01|00 代表 true|false</td>\n</tr>\n<tr>\n<td>writeByte(int value)</td>\n<td>写入 byte 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeShort(int value)</td>\n<td>写入 short 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeInt(int value)</td>\n<td>写入 int 值</td>\n<td>Big Endian，即 0x250，写入后 00 00 02 50 【高-低】</td>\n</tr>\n<tr>\n<td><strong>writeIntLE</strong>(int value)</td>\n<td>写入 int 值</td>\n<td><strong>Little Endian</strong>，即 0x250，写入后 50 02 00 00</td>\n</tr>\n<tr>\n<td>writeLong(long value)</td>\n<td>写入 long 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeChar(int value)</td>\n<td>写入 char 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeFloat(float value)</td>\n<td>写入 float 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeDouble(double value)</td>\n<td>写入 double 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuf src)</td>\n<td>写入 netty 的 ByteBuf</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(byte[] src)</td>\n<td>写入 byte[]</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuffer src)</td>\n<td>写入 nio 的 ByteBuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>\n<td>写入字符串</td>\n<td>String StringBuffer StringBuilder 的父类！</td>\n</tr>\n</tbody></table>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 注意</p>\n<ul>\n<li>这些方法的未指明返回值的，其<strong>返回值都是 ByteBuf，意味着可以链式调用</strong></li>\n<li><strong>网络传输，默认习惯是 Big Endian</strong></li>\n</ul></blockquote>\n<p>先写入 4 个字节</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\nlog(buffer);</code></pre>\n\n<p>结果是</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">read index:0 write index:4 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>再写入一个 <strong>int 整数，也是 4 个字节</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buffer.writeInt(5);\nlog(buffer);</code></pre>\n\n<p>结果是</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">read index:0 write index:8 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n<p>还有一类方法是 <strong>set 开头的一系列方法，也可以写入</strong>数据，<strong>但不会改变写指针位置</strong></p>\n<h4 id=\"6）扩容\"><a href=\"#6）扩容\" class=\"headerlink\" title=\"6）扩容\"></a>6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buffer.writeInt(6);\nlog(buffer);</code></pre>\n\n<p>扩容规则是</p>\n<ul>\n<li>如果<strong>写入后数据大小未超过 512，则选择下一个 16 的整数倍</strong>，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>\n<li>如果<strong>写入后数据大小超过 512，则选择下一个 2^n</strong>，例如写入后大小为 513，则扩容后 capacity 是 2^10&#x3D;1024（2^9&#x3D;512 已经不够了）</li>\n<li>扩容不能<strong>超过 max capacity 会报错</strong></li>\n</ul>\n<p>结果是</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">read index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n<h4 id=\"7）读取\"><a href=\"#7）读取\" class=\"headerlink\" title=\"7）读取\"></a>7）读取</h4><p>例如读了 4 次，每次一个字节</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">System.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nlog(buffer);</code></pre>\n\n<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n2\n3\n4\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>如果<strong>需要重复读取 int 整数 5</strong>，怎么办？</p>\n<p>可以在 read 前先做个标记 <strong>mark</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buffer.markReaderIndex();&#x2F;&#x2F;\nSystem.out.println(buffer.readInt());\nlog(buffer);</code></pre>\n\n<p>结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">5\nread index:8 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 06                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>这时要重复读取的话，重置到标记位置 <strong>reset</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buffer.resetReaderIndex();&#x2F;&#x2F;\nlog(buffer);</code></pre>\n\n<p>这时</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">read index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>还有种办法是<strong>采用 get 开头的一系列方法，这些方法不会改变 read index</strong></p>\n<p>&#x3D;&#x3D;write read &#x2F; set get&#x3D;&#x3D;</p>\n<h4 id=\"8）retain-amp-release\"><a href=\"#8）retain-amp-release\" class=\"headerlink\" title=\"8）retain &amp; release\"></a>8）retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>\n<ul>\n<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需<strong>等 GC</strong> 回收内存即可</li>\n<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要<strong>特殊的方法来回收</strong>内存</li>\n<li>PooledByteBuf 和它的子类使用了池化机制，需要<strong>更复杂的规则来回收</strong>内存【还回内存池！】</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>回收内存的源码实现，请关注下面方法的不同实现</p>\n<p><code>protected abstract void deallocate()</code></p></blockquote>\n<p>Netty 这里采用了**&#x3D;&#x3D;引用计数法&#x3D;&#x3D;来控制回收**内存，每个 <strong>ByteBuf 都实现了 ReferenceCounted 接口</strong></p>\n<ul>\n<li>每个 ByteBuf 对象的<strong>初始计数为 1</strong></li>\n<li>调用 <strong>release</strong> 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>\n<li>调用 <strong>retain</strong> 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>\n<li>当计数为 <strong>0 时，【底层内存会被回收：见&#x3D;&#x3D;deallocate()不同实现方式&#x3D;&#x3D;】，这时即使 ByteBuf 对象还在，其各个【方法均无法正常使用】</strong></li>\n</ul>\n<p>谁来负责 release 呢？</p>\n<p>不是我们想象的（一般情况下）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buf &#x3D; ...\ntry &#123;\n    ...\n&#125; finally &#123;\n    buf.release();\n&#125;</code></pre>\n\n<p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>\n<p>基本规则是，**谁是&#x3D;&#x3D;最后使用者，谁负责 release&#x3D;&#x3D;**，详细分析如下</p>\n<ul>\n<li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li>\n<li>入站 ByteBuf 处理原则<ul>\n<li>对原始 ByteBuf 【不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release】</li>\n<li>将原始 ByteBuf <strong>&#x3D;&#x3D;转换为其它类型的 Java 对象&#x3D;&#x3D;，这时 ByteBuf 就没用了，必须 release</strong></li>\n<li>如果<strong>不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li>\n<li>注意<strong>各种异常</strong>，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>\n<li>假设消息一直向后传，那么 <strong>TailContext 会负责释放未处理消息（原始的 ByteBuf）</strong></li>\n</ul>\n</li>\n<li>出站 ByteBuf 处理原则<ul>\n<li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前</strong>传，由 <strong>HeadContext flush 后 release</strong></li>\n</ul>\n</li>\n<li>异常处理原则<ul>\n<li>有时候【不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong>】</li>\n</ul>\n</li>\n</ul>\n<p>传到了首尾，head&#x2F;tail才释放；传不到或不用了，就要自己释放！！！</p>\n<p>TailContext 释放未处理消息逻辑：引用计数ed_msg.release()</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)\nprotected void onUnhandledInboundMessage(Object msg) &#123;\n    try &#123;\n        logger.debug(\n            &quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot; +\n            &quot;Please check your pipeline configuration.&quot;, msg);\n    &#125; finally &#123;\n        ReferenceCountUtil.release(msg);\n    &#125;\n&#125;</code></pre>\n\n<p>具体代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; io.netty.util.ReferenceCountUtil#release(java.lang.Object)\npublic static boolean release(Object msg) &#123;\n    if (msg instanceof ReferenceCounted) &#123;\n        return ((ReferenceCounted) msg).release();\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<p>HeadContext:</p>\n<p>ctrl+F12 write  ctrl+alt+鼠标左键：implement\trelease() &#x2F; -&gt;<strong>outboundBuffer</strong>！！！</p>\n<h4 id=\"9）slice\"><a href=\"#9）slice\" class=\"headerlink\" title=\"9）slice\"></a>9）slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</strong></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0011.png\"></p>\n<p>例，原始 ByteBuf 进行一些初始操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf origin &#x3D; ByteBufAllocator.DEFAULT.buffer(10);\norigin.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\norigin.readByte();&#x2F;&#x2F;\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>这时调用 slice 进行切片，<strong>无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，【切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write】</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf slice &#x3D; origin.slice();\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n&#x2F;&#x2F; slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常\n带参构造：\nbuf.slice(index, length);</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">origin.readByte();&#x2F;&#x2F;\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 04                                           |..              |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>这时的 <strong>slice 不受影响，因为它有独立的读写指针</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">System.out.println(ByteBufUtil.prettyHexDump(slice));</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>如果 slice 的内容发生了更改 setByte</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">slice.setByte(2, 5);&#x2F;&#x2F;\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 05                                        |...             |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>这时，<strong>原始 ByteBuf 也会受影响，因为底层都是同一块内存</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">System.out.println(ByteBufUtil.prettyHexDump(origin));</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 05                                           |..              |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>slice.retain();&#x2F;&#x2F;refCnt+1</p>\n<p>release();&#x2F;&#x2F;refCnt-1</p>\n<h4 id=\"10）duplicate-浅拷贝\"><a href=\"#10）duplicate-浅拷贝\" class=\"headerlink\" title=\"10）duplicate 浅拷贝\"></a>10）duplicate 浅拷贝</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf <strong>所有内容，并且没有 max capacity 的限制</strong>，也是与原始 ByteBuf 使<strong>用同一块底层内存，只是读写指针是独立的</strong></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0012.png\"></p>\n<h4 id=\"11）copy深拷贝\"><a href=\"#11）copy深拷贝\" class=\"headerlink\" title=\"11）copy深拷贝\"></a>11）copy深拷贝</h4><p>会将底层内存数据进行<strong>深拷贝</strong>，因此无论读写，都与原始 ByteBuf <strong>无关</strong></p>\n<h4 id=\"12）CompositeByteBuf\"><a href=\"#12）CompositeByteBuf\" class=\"headerlink\" title=\"12）CompositeByteBuf\"></a>12）CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>\n<p>有两个 ByteBuf 如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buf1 &#x3D; ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]&#123;1, 2, 3, 4, 5&#125;);\nByteBuf buf2 &#x3D; ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]&#123;6, 7, 8, 9, 10&#125;);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf1));\nSystem.out.println(ByteBufUtil.prettyHexDump(buf2));</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p>\n<p>方法1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buf3 &#x3D; ByteBufAllocator.DEFAULT\n    .buffer(buf1.readableBytes()+buf2.readableBytes());&#x2F;&#x2F;\nbuf3.writeBytes(buf1);&#x2F;&#x2F;\nbuf3.writeBytes(buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));</code></pre>\n\n<p>结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>这种方法好不好？回答是不太好，因为进行了[数据的内存复制]操作</p>\n<p>方法2：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CompositeByteBuf buf3 &#x3D; ByteBufAllocator.DEFAULT.compositeBuffer();\n&#x2F;&#x2F; true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0\nbuf3.addComponents(true, buf1, buf2);&#x2F;&#x2F;默认不增Widx！+入参true！</code></pre>\n\n<p>结果是一样的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>CompositeByteBuf 是一个<strong>组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</strong></p>\n<ul>\n<li>优点，<strong>对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</strong></li>\n<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>\n</ul>\n<h4 id=\"13）Unpooled\"><a href=\"#13）Unpooled\" class=\"headerlink\" title=\"13）Unpooled\"></a>13）Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>\n<p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buf1 &#x3D; ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]&#123;1, 2, 3, 4, 5&#125;);\nByteBuf buf2 &#x3D; ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]&#123;6, 7, 8, 9, 10&#125;);\n\n&#x2F;&#x2F; 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf\nByteBuf buf3 &#x3D; Unpooled.wrappedBuffer(buf1, buf2);&#x2F;&#x2F;\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buf4 &#x3D; Unpooled.wrappedBuffer(new byte[]&#123;1, 2, 3&#125;, new byte[]&#123;4, 5, 6&#125;);&#x2F;&#x2F;\nSystem.out.println(buf4.getClass());\nSystem.out.println(ByteBufUtil.prettyHexDump(buf4));</code></pre>\n\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class io.netty.buffer.CompositeByteBuf\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06                               |......          |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n<h4 id=\"💡-ByteBuf-优势\"><a href=\"#💡-ByteBuf-优势\" class=\"headerlink\" title=\"💡 ByteBuf 优势\"></a>💡 ByteBuf 优势</h4><ul>\n<li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>\n<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>\n<li>可以自动扩容</li>\n<li>支持链式调用，使用更流畅</li>\n<li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li>\n</ul>\n<h2 id=\"4-双向通信\"><a href=\"#4-双向通信\" class=\"headerlink\" title=\"4. 双向通信\"></a>4. 双向通信</h2><h3 id=\"4-1-练习\"><a href=\"#4-1-练习\" class=\"headerlink\" title=\"4.1 练习\"></a>4.1 练习</h3><p>实现一个 echo server</p>\n<p>编写 server</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(NioSocketChannel ch) &#123;\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    ByteBuf buffer &#x3D; (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    &#x2F;&#x2F; 建议使用 ctx.alloc() 创建 ByteBuf\n                    ByteBuf response &#x3D; ctx.alloc().buffer();\n                    response.writeBytes(buffer);\n                    ctx.writeAndFlush(response);\n\n                    &#x2F;&#x2F; 思考：需要释放 buffer 吗\n                    &#x2F;&#x2F; 思考：需要释放 response 吗\n                &#125;\n            &#125;);\n        &#125;\n    &#125;).bind(8080);</code></pre>\n\n<p>编写 client</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\nChannel channel &#x3D; new Bootstrap()\n    .group(group)\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n            ch.pipeline().addLast(new StringEncoder());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    ByteBuf buffer &#x3D; (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    &#x2F;&#x2F; 思考：需要释放 buffer 吗\n                &#125;\n            &#125;);\n        &#125;\n    &#125;).connect(&quot;127.0.0.1&quot;, 8080).sync().channel();\n\nchannel.closeFuture().addListener(future -&gt; &#123;\n    group.shutdownGracefully();\n&#125;);\n\nnew Thread(() -&gt; &#123;\n    Scanner scanner &#x3D; new Scanner(System.in);\n    while (true) &#123;\n        String line &#x3D; scanner.nextLine();\n        if (&quot;q&quot;.equals(line)) &#123;\n            channel.close();\n            break;\n        &#125;\n        channel.writeAndFlush(line);\n    &#125;\n&#125;).start();</code></pre>\n\n\n\n<h3 id=\"💡-读和写的误解\"><a href=\"#💡-读和写的误解\" class=\"headerlink\" title=\"💡 读和写的误解\"></a>💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，<strong>Java Socket 是【全双工】的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用【读线程和写线程】即可，读不会阻塞写、写也不会阻塞读</strong></p>\n<p>例如</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket ss &#x3D; new ServerSocket(8888);\n        Socket s &#x3D; ss.accept();\n\n        new Thread(() -&gt; &#123;\n            try &#123;\n                BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(s.getInputStream()));&#x2F;&#x2F;\n                while (true) &#123;\n                    System.out.println(reader.readLine());\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n\n        new Thread(() -&gt; &#123;\n            try &#123;\n                BufferedWriter writer &#x3D; new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));&#x2F;&#x2F;\n                &#x2F;&#x2F; 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据\n                for (int i &#x3D; 0; i &lt; 100; i++) &#123;\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;</code></pre>\n\n<p>客户端</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestClient &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Socket s &#x3D; new Socket(&quot;localhost&quot;, 8888);\n\n        new Thread(() -&gt; &#123;\n            try &#123;\n                BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) &#123;\n                    System.out.println(reader.readLine());\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n\n        new Thread(() -&gt; &#123;\n            try &#123;\n                BufferedWriter writer &#x3D; new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                for (int i &#x3D; 0; i &lt; 100; i++) &#123;\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;</code></pre>\n\n\n\n<h1 id=\"三-Netty-进阶\"><a href=\"#三-Netty-进阶\" class=\"headerlink\" title=\"三. Netty 进阶\"></a>三. Netty 进阶</h1><h2 id=\"1-粘包与半包\"><a href=\"#1-粘包与半包\" class=\"headerlink\" title=\"1. 粘包与半包\"></a>1. 粘包与半包</h2><h3 id=\"1-1-粘包现象\"><a href=\"#1-1-粘包现象\" class=\"headerlink\" title=\"1.1 粘包现象\"></a>1.1 粘包现象</h3><p>服务端代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloWorldServer &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldServer.class);\n    void start() &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            &#x2F;&#x2F;serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);&#x2F;&#x2F;半包\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());\n                            super.channelActive(ctx);\n                        &#125;\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());\n                            super.channelInactive(ctx);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);\n            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());\n            channelFuture.sync();&#x2F;&#x2F;\n            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());\n            channelFuture.channel().closeFuture().sync();&#x2F;&#x2F;\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug(&quot;stoped&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new HelloWorldServer().start();\n    &#125;\n&#125;</code></pre>\n\n<p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connected...&quot;);\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            Random r &#x3D; new Random();\n                            char c &#x3D; &#39;a&#39;;\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n                                ctx.writeAndFlush(buffer);&#x2F;&#x2F;160B 粘包\n                            &#125;\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:&#x2F;0:0:0:0:0:0:0:0:8080] bound...\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177] REGISTERED\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177] ACTIVE\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177]\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177] READ COMPLETE</code></pre>\n\n\n\n<h3 id=\"1-2-半包现象\"><a href=\"#1-2-半包现象\" class=\"headerlink\" title=\"1.2 半包现象\"></a>1.2 半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuf buffer &#x3D; ctx.alloc().buffer();\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n&#125;\nctx.writeAndFlush(buffer);</code></pre>\n\n<p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);&#x2F;&#x2F;</code></pre>\n\n<p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:&#x2F;0:0:0:0:0:0:0:0:8080] bound...\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] REGISTERED\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] ACTIVE\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221]\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] READ: 20B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] READ COMPLETE\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] READ: 140B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] READ COMPLETE</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong></p>\n<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, <strong>10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 【netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍】</strong></p></blockquote>\n<p>&#x3D;&#x3D;only TCP&#x3D;&#x3D;</p>\n<h3 id=\"1-3-现象分析\"><a href=\"#1-3-现象分析\" class=\"headerlink\" title=\"1.3 现象分析\"></a>1.3 现象分析</h3><p>粘包</p>\n<ul>\n<li>现象，发送 abc def，接收 abcdef</li>\n<li>原因<ul>\n<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>\n<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>\n<li>Nagle 算法：会造成粘包</li>\n</ul>\n</li>\n</ul>\n<p>半包</p>\n<ul>\n<li>现象，发送 abcdef，接收 abc def</li>\n<li>原因<ul>\n<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>\n<li>滑动窗口：假设<strong>接收方的窗口只剩了 128 bytes</strong>，发送方的报文大小是 256 bytes，这时放不下了，<strong>只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li>\n<li>MSS 限制：当<strong>发送的数据超过 MSS 限制后，会将数据切分发送</strong>，就会造成半包</li>\n</ul>\n</li>\n</ul>\n<p>【 IP分片与重组：if大TCP报文被IP层MTU分片:1500B，&#x3D;&#x3D;只有第一个分片才具有<code>TCP</code>头部&#x3D;&#x3D;，重组才认为是TCP给上层】</p>\n<p>如果一个<strong>大的<code>TCP</code>报文被<code>MSS</code>分片，那么所有分片都具有<code>TCP</code>头部</strong>，因为每个<code>MSS</code>分片的是具有<code>TCP</code>头部的<code>TCP</code>报文，其中一个<code>MSS</code>分片丢失，就只需要重传这一个分片就可以。</p>\n<p>本质是因为 <strong>TCP 是流式协议，消息无边界</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>滑动窗口</p>\n<ul>\n<li><p>TCP 以一个段（segment）为单位[MSS]，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是 包的往返时间RTT越长性能就越差</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0049.png\"></p>\n</li>\n<li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了<strong>无需等待应答而可以继续发送的数据最大值</strong></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0051.png\"></p>\n</li>\n<li><p>窗口实际就起到一个<strong>缓冲区</strong>的作用，同时也能起到<strong>流量控制</strong>的作用</p>\n<ul>\n<li>图中深色的部分即要发送的数据，高亮的部分即窗口</li>\n<li>窗口内的数据才允许被发送，当 应答未到达前，窗口必须停止滑动</li>\n<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>\n<li>接收方也会维护 一个窗口，只有落在窗口内的数据才能 允许接收</li>\n</ul>\n</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> MSS 限制</p>\n<ul>\n<li><p><strong>链路层</strong>对一次能够发送的最大数据有限制，这个限制称之为 <strong>MTU</strong>（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p>\n</li>\n<li><p><strong>以太网的 MTU 是 1500</strong></p>\n</li>\n<li><p><strong>FDDI（光纤分布式</strong>数据接口）的 MTU 是 <strong>4352</strong></p>\n</li>\n<li><p><strong>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</strong></p>\n</li>\n<li><p><strong>MSS</strong> 是最大段长度（maximum segment size），它是 <strong>MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</strong></p>\n</li>\n<li><p><strong>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 &#x3D; 1460</strong></p>\n</li>\n<li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p>\n</li>\n<li><p>MSS 的值在&#x3D;&#x3D;三次<strong>握手时通知</strong>对方自己 MSS 的值，然后在<strong>两者之间选择一个小值</strong>作为 MSS&#x3D;&#x3D;</p>\n</li>\n</ul>\n<p> <img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0031.jpg\"></p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>Nagle 算法</strong></p>\n<ul>\n<li>【即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据】，这就是 Nagle 算法产生的缘由</li>\n<li>该算法是指发送端<strong>即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送</strong><ul>\n<li>如果 <strong>SO_SNDBUF 的数据达到 MSS</strong>，则需要发送</li>\n<li>如果 <strong>SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</strong></li>\n<li>如果 <strong>TCP_NODELAY &#x3D; true</strong>，则需要发送</li>\n<li><strong>已发送的数据都收到 ack</strong> 时，则需要发送</li>\n<li>上述条件<strong>不满足，但发生超时（一般为 200ms）则需要发</strong>送</li>\n<li></li>\n<li><strong>除上述情况，延迟发</strong>送</li>\n</ul>\n</li>\n</ul></blockquote>\n<h3 id=\"1-4-解决方案\"><a href=\"#1-4-解决方案\" class=\"headerlink\" title=\"1.4 解决方案\"></a>1.4 解决方案</h3><ol>\n<li><strong>短链接，发一个包建立一次连接</strong>，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>\n<li>每一条消息采用<strong>固定长度，缺点浪费空间</strong></li>\n<li>每一条消息采用<strong>分隔符，例如 \\n，缺点需要转义</strong></li>\n<li>每一条消息<strong>分为 head 和 body，head 中包含 body 的长度</strong></li>\n</ol>\n<h4 id=\"方法1，短链接\"><a href=\"#方法1，短链接\" class=\"headerlink\" title=\"方法1，短链接\"></a>方法1，短链接</h4><p>以解决粘包为例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 分 10 次发送\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            send();\n        &#125;\n    &#125;\n\n    private static void send() &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;conneted...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                            buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n                            ctx.writeAndFlush(buffer);\n                            &#x2F;&#x2F; 发完即关\n                            ctx.close();&#x2F;&#x2F;\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>输出，略</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>半包用这种办法还是不好解决</strong>，因为接收方的缓冲区大小是有限的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloWorldServer &#123;\n static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldServer.class);\n void start() &#123;\n     NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);\n     NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n     try &#123;\n         ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n         serverBootstrap.channel(NioServerSocketChannel.class);\n         &#x2F;&#x2F;调整系统的接收缓冲区（滑动窗口）\n         &#x2F;&#x2F;serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);&#x2F;&#x2F;半包\n         &#x2F;&#x2F;调整netty额接收缓冲区（byteBuf）\n         serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, new AdaptiveRecvByteBufAllocator(16, 16, 16));\n\n\n         serverBootstrap.group(boss, worker);\n         serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n             @Override\n             protected void initChannel(SocketChannel ch) throws Exception &#123;\n                 ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                 ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                     @Override\n                     public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                         log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());\n                         super.channelActive(ctx);\n                     &#125;\n\n                     @Override\n                     public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n                         log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());\n                         super.channelInactive(ctx);\n                     &#125;\n                 &#125;);\n             &#125;\n         &#125;);\n         ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);\n         log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());\n         channelFuture.sync();&#x2F;&#x2F;\n         log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());\n         channelFuture.channel().closeFuture().sync();&#x2F;&#x2F;\n     &#125; catch (InterruptedException e) &#123;\n         log.error(&quot;server error&quot;, e);\n     &#125; finally &#123;\n         boss.shutdownGracefully();\n         worker.shutdownGracefully();\n         log.debug(&quot;stoped&quot;);\n     &#125;\n &#125;\n\n public static void main(String[] args) &#123;\n     new HelloWorldServer().start();\n &#125;\n&#125;</code></pre>\n\n</blockquote>\n<p>16B 2B 16 2 ……</p>\n<h4 id=\"方法2，固定长度-FixedLengthFrameDecoder\"><a href=\"#方法2，固定长度-FixedLengthFrameDecoder\" class=\"headerlink\" title=\"方法2，固定长度 FixedLengthFrameDecoder\"></a>方法2，固定长度 FixedLengthFrameDecoder</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ch.pipeline().addLast(new FixedLengthFrameDecoder(8));</code></pre>\n\n<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connetted...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            &#x2F;&#x2F; 发送内容随机的数据包\n                            Random r &#x3D; new Random();\n                            char c &#x3D; &#39;a&#39;;\n                            ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                byte[] bytes &#x3D; new byte[8];\n                                for (int j &#x3D; 0; j &lt; r.nextInt(8); j++) &#123;\n                                    bytes[j] &#x3D; (byte) c;\n                                &#125;\n                                c++;\n                                buffer.writeBytes(bytes);\n                            &#125;\n                            ctx.writeAndFlush(buffer);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>客户端输出 【粘包】</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: &#x2F;192.168.0.103:9090\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:&#x2F;192.168.0.103:53155 - R:&#x2F;192.168.0.103:9090] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:&#x2F;192.168.0.103:53155 - R:&#x2F;192.168.0.103:9090] WRITE: 80B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|\n|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|\n|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|\n|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|\n|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:&#x2F;192.168.0.103:53155 - R:&#x2F;192.168.0.103:9090] FLUSH</code></pre>\n\n<p>服务端输出 【正确接收】</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:&#x2F;192.168.0.103:9090] bound...\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155]\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 00 00 00 00 00 00 00                         |b.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00                         |cc......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 00 00 00 00 00 00 00                         |d.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 00 00 00 00 00                         |........        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 00 00 00 00 00 00 00                         |h.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ COMPLETE</code></pre>\n\n<p>缺点是，数据包的大小不好把握</p>\n<ul>\n<li>长度定的太大，浪费</li>\n<li>长度定的太小，对某些数据包又显得不够</li>\n</ul>\n<h4 id=\"方法3，固定分隔符-LineBasedFrameDecoder\"><a href=\"#方法3，固定分隔符-LineBasedFrameDecoder\" class=\"headerlink\" title=\"方法3，固定分隔符 LineBasedFrameDecoder\"></a>方法3，固定分隔符 LineBasedFrameDecoder</h4><p>服务端加入，默认以 \\n 或 \\r\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ch.pipeline().addLast(new LineBasedFrameDecoder(1024));&#x2F;&#x2F; linux&#39;\\n&#39; win&#39;\\r\\n&#39;\n\n&#x2F;&#x2F;ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();\n&#x2F;&#x2F;buffer.writeBytes(&quot;\\n&quot;.getBytes());\n&#x2F;&#x2F;ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buffer));&#x2F;&#x2F;delimiter分隔符</code></pre>\n\n<p>客户端在每条消息之后，加入 \\n 分隔符</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connetted...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            Random r &#x3D; new Random();\n                            char c &#x3D; &#39;a&#39;;\n                            ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                for (int j &#x3D; 1; j &lt;&#x3D; r.nextInt(16)+1; j++) &#123;\n                                    buffer.writeByte((byte) c);\n                                &#125;\n                                buffer.writeByte(10);&#x2F;&#x2F;\n                                c++;\n                            &#125;\n                            ctx.writeAndFlush(buffer);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>客户端输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: &#x2F;192.168.0.103:9090\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:&#x2F;192.168.0.103:63641 - R:&#x2F;192.168.0.103:9090] ACTIVE\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:&#x2F;192.168.0.103:63641 - R:&#x2F;192.168.0.103:9090] WRITE: 60B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|\n|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|\n|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|\n|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:&#x2F;192.168.0.103:63641 - R:&#x2F;192.168.0.103:9090] FLUSH</code></pre>\n\n\n\n<p>服务端输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641]\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 1B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61                                              |a               |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63                                        |ccc             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64                                           |dd              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66                                           |ff              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 67 67 67 67                            |ggggggg         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68 68 68                                     |hhhh            |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ COMPLETE</code></pre>\n\n<p>缺点，<strong>处理字符数据比较合适，但【如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误】</strong></p>\n<h4 id=\"方法4，预设长度-LengthFieldBasedFrameDecoder-max-len前中后-S收去尾\"><a href=\"#方法4，预设长度-LengthFieldBasedFrameDecoder-max-len前中后-S收去尾\" class=\"headerlink\" title=\"方法4，预设长度 LengthFieldBasedFrameDecoder(max,len前中后,S收去尾)\"></a>方法4，预设长度 LengthFieldBasedFrameDecoder(max,len前中后,S收去尾)</h4><p>server：在发送消息前，先<strong>约定 用定长字节表示接下来数据的长度</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 最大长度，长度偏移(长度前)，长度占用字节(长度长)，长度调整(长度后|内容前)，剥离字节数(S接收端：去首)\nch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));</code></pre>\n\n<p>客户端代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connetted...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            Random r &#x3D; new Random();\n                            char c &#x3D; &#39;a&#39;;\n                            ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                byte length &#x3D; (byte) (r.nextInt(16) + 1);\n                                &#x2F;&#x2F; 先写入长度\n                                buffer.writeByte(length);&#x2F;&#x2F;\n                                &#x2F;&#x2F; 再\n                                for (int j &#x3D; 1; j &lt;&#x3D; length; j++) &#123;&#x2F;&#x2F;\n                                    buffer.writeByte((byte) c);&#x2F;&#x2F;\n                                &#125;\n                                c++;\n                            &#125;\n                            ctx.writeAndFlush(buffer);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>客户端输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: &#x2F;192.168.0.103:9090\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:&#x2F;192.168.0.103:49979 - R:&#x2F;192.168.0.103:9090] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:&#x2F;192.168.0.103:49979 - R:&#x2F;192.168.0.103:9090] WRITE: 97B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|\n|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|\n|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|\n|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|\n|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|\n|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|\n|00000060| 6a                                              |j               |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:&#x2F;192.168.0.103:49979 - R:&#x2F;192.168.0.103:9090] FLUSH</code></pre>\n\n\n\n<p>服务端输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...\n14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:&#x2F;192.168.0.103:9090] bound...\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979]\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63 63 63 63                               |cccccc          |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 15B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 13B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67                                           |gg              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68                                           |hh              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ COMPLETE\n</code></pre>\n\n\n\n<h2 id=\"2-协议设计与解析\"><a href=\"#2-协议设计与解析\" class=\"headerlink\" title=\"2. 协议设计与解析\"></a>2. 协议设计与解析</h2><h3 id=\"2-1-为什么需要协议？\"><a href=\"#2-1-为什么需要协议？\" class=\"headerlink\" title=\"2.1 为什么需要协议？\"></a>2.1 为什么需要协议？</h3><p>TCP&#x2F;IP 中消息传输  基于流的方式，没有边界。</p>\n<p>协议的目的就是：划定消息的边界，制定通信双方要共同遵守的通信规则</p>\n<p>例如：在网络上传输</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">下雨天留客天留我不留</code></pre>\n\n<p>是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性</p>\n<p>一种解读</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">下雨天留客，天留，我不留</code></pre>\n\n<p>另一种解读</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">下雨天，留客天，留我不？留</code></pre>\n\n\n\n<p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。<strong>但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。</strong>因此，下面一种协议较为常用</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">定长字节表示内容长度 + 实际内容</code></pre>\n\n<p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0f下雨天留客06天留09我不留</code></pre>\n\n\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>小故事</p>\n<p>很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“<strong>无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金</strong>”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。</p>\n<p>年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——<strong>无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。</strong>这白纸黑字明摆着的，你有什么要说的呢？”</p>\n<p>私塾先生据理力争：“协议是这样的——<strong>无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。</strong>”</p>\n<p>双方唇枪舌战，你来我往，真个是不亦乐乎！</p>\n<p>这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬</p></blockquote>\n<h3 id=\"2-2-redis-协议举例\"><a href=\"#2-2-redis-协议举例\" class=\"headerlink\" title=\"2.2 redis 协议举例\"></a>2.2 redis 协议举例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\nbyte[] LINE &#x3D; &#123;13, 10&#125;;&#x2F;&#x2F; 回车+换行 win:\\r\\n\ntry &#123;\n    Bootstrap bootstrap &#x3D; new Bootstrap();\n    bootstrap.channel(NioSocketChannel.class);\n    bootstrap.group(worker);\n    bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(SocketChannel ch) &#123;\n            ch.pipeline().addLast(new LoggingHandler());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                &#x2F;&#x2F; 会在连接 channel 建立成功后，会触发 active 事件\n                @Override\n                public void channelActive(ChannelHandlerContext ctx) &#123;\n                    set(ctx);\n                    get(ctx);\n                &#125;\n                private void get(ChannelHandlerContext ctx) &#123;\n                    ByteBuf buf &#x3D; ctx.alloc().buffer();\n                    buf.writeBytes(&quot;*2&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;get&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;aaa&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                &#125;\n                private void set(ChannelHandlerContext ctx) &#123;\n                    ByteBuf buf &#x3D; ctx.alloc().buffer();\n                    buf.writeBytes(&quot;*3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;set&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;aaa&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;bbb&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                &#125;\n\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                    ByteBuf buf &#x3D; (ByteBuf) msg;\n                    System.out.println(buf.toString(Charset.defaultCharset()));\n                &#125;\n            &#125;);\n        &#125;\n    &#125;);\n    ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;localhost&quot;, 6379).sync();&#x2F;&#x2F;\n    channelFuture.channel().closeFuture().sync();\n&#125; catch (InterruptedException e) &#123;\n    log.error(&quot;client error&quot;, e);\n&#125; finally &#123;\n    worker.shutdownGracefully();\n&#125;</code></pre>\n\n<p>起redis:【run】 get aaa</p>\n<h3 id=\"2-3-http-协议举例\"><a href=\"#2-3-http-协议举例\" class=\"headerlink\" title=\"2.3 http 协议举例\"></a>2.3 http 协议举例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\nNioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\ntry &#123;\n    ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.group(boss, worker);\n    serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception &#123;\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(new HttpServerCodec());&#x2F;&#x2F;\n            ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception &#123;\n                    &#x2F;&#x2F; 获取请求\n                    log.debug(msg.uri());&#x2F;&#x2F;-&#x2F;bxl.html\n\n                    &#x2F;&#x2F; 返回响应\n                    DefaultFullHttpResponse response &#x3D;\n                            new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n\n                    byte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;&quot;.getBytes();\n\n                    response.headers().setInt(CONTENT_LENGTH, bytes.length);&#x2F;&#x2F;&#x2F;&#x2F;k,v 否则浏览器一直转圈读！！！\n                    response.content().writeBytes(bytes);\n\n                    &#x2F;&#x2F; 写回响应\n                    ctx.writeAndFlush(response);\n                &#125;\n            &#125;);\n            &#x2F;*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());\n\n                    if (msg instanceof HttpRequest) &#123; &#x2F;&#x2F; 请求行，请求头\n\n                    &#125; else if (msg instanceof HttpContent) &#123; &#x2F;&#x2F;请求体\n\n                    &#125;\n                &#125;\n            &#125;);*&#x2F;\n        &#125;\n    &#125;);\n    ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080).sync();\n    channelFuture.channel().closeFuture().sync();\n&#125; catch (InterruptedException e) &#123;\n    log.error(&quot;server error&quot;, e);\n&#125; finally &#123;\n    boss.shutdownGracefully();\n    worker.shutdownGracefully();\n&#125;</code></pre>\n\n<p><a href=\"http://localhost:8080/bxl.html\">http://localhost:8080/bxl.html</a></p>\n<h3 id=\"x3D-x3D-2-4-自定义协议要素-x3D-x3D-【紧凑，高效，省带宽】\"><a href=\"#x3D-x3D-2-4-自定义协议要素-x3D-x3D-【紧凑，高效，省带宽】\" class=\"headerlink\" title=\"&#x3D;&#x3D;2.4 自定义协议要素&#x3D;&#x3D;【紧凑，高效，省带宽】\"></a>&#x3D;&#x3D;2.4 自定义协议要素&#x3D;&#x3D;【紧凑，高效，省带宽】</h3><ul>\n<li>魔数cafebaby，用来在<strong>第一时间判定是否是无效数据包</strong></li>\n<li>版本号，可以支持协议的<strong>升级</strong> 新增消息…</li>\n<li>序列化算法，消息正文到底采用哪种<strong>序列化反序列化方式，可以由此扩展，例如：json、xml、protobuf(bin)、hessian(bin)、jdk(不跨平台|性能低)</strong></li>\n<li><strong>指令类型，是登录、注册、单聊、群聊… 跟业务相关</strong></li>\n<li>[请求序号]，为了[双工通信]，提供[异步]能力</li>\n<li>正文长度</li>\n<li>消息正文 username,pwd…    json&#x2F;xml&#x2F;bin对象流…</li>\n</ul>\n<h4 id=\"msg编解码器【netty-demo项目】\"><a href=\"#msg编解码器【netty-demo项目】\" class=\"headerlink\" title=\"msg编解码器【netty-demo项目】\"></a>msg编解码器【netty-demo项目】</h4><p>根据上面的要素，设计一个<strong>登录请求消息和登录响应消息，并使用 Netty 完成收发</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;\n        &#x2F;&#x2F; 1. 4 字节的魔数\n        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        &#x2F;&#x2F; 2. 1 字节的版本,\n        out.writeByte(1);\n        &#x2F;&#x2F; 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        &#x2F;&#x2F; 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 无意义，对齐填充\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 6. 获取内容的字节数组\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n        &#x2F;&#x2F; 7. 长度\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 8. 写入内容\n        out.writeBytes(bytes);\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        int magicNum &#x3D; in.readInt();\n        byte version &#x3D; in.readByte();\n        byte serializerType &#x3D; in.readByte();\n        byte messageType &#x3D; in.readByte();\n        int sequenceId &#x3D; in.readInt();\n        in.readByte();\n        int length &#x3D; in.readInt();\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(&quot;&#123;&#125;&quot;, message);\n        out.add(message);\n    &#125;\n&#125;</code></pre>\n\n<p>测试\tprotocol.TestMessageCodec类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">EmbeddedChannel channel &#x3D; new EmbeddedChannel(\n    new LoggingHandler(),\n    new LengthFieldBasedFrameDecoder(\n        1024, 12, 4, 0, 0),\n    new MessageCodec()\n);\n&#x2F;&#x2F; encode\nLoginRequestMessage message &#x3D; new LoginRequestMessage(&quot;zhangsan&quot;, &quot;123&quot;, &quot;张三&quot;);\n&#x2F;&#x2F;        channel.writeOutbound(message);&#x2F;&#x2F;ByteBuf&lt;-msg out编码\n&#x2F;&#x2F; decode    ByteBuf-&gt;msg in解码\nByteBuf buf &#x3D; ByteBufAllocator.DEFAULT.buffer();\nnew MessageCodec().encode(null, message, buf);\n\nByteBuf s1 &#x3D; buf.slice(0, 100);\nByteBuf s2 &#x3D; buf.slice(100, buf.readableBytes() - 100);\ns1.retain(); &#x2F;&#x2F; 引用计数 2\nchannel.writeInbound(s1); &#x2F;&#x2F; release 1\n&#x2F;&#x2F;ByteBuf有限[半包问题！不完整,无法反序列化为msg]\n&#x2F;&#x2F;       报错： java.lang.IndexOutOfBoundsException: readerIndex(16) + length(198) exceeds writerIndex(100)\n\n        &#x2F;&#x2F;+new LengthFieldBasedFrameDecoder(),：发现数据不完整，不会传递给下一个handler，而是等待接下来的数据\nchannel.writeInbound(s2);</code></pre>\n\n\n\n<p>解读</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0013.png\"></p>\n<h4 id=\"💡-什么时候可以加-Sharable\"><a href=\"#💡-什么时候可以加-Sharable\" class=\"headerlink\" title=\"💡 什么时候可以加 @Sharable\"></a>💡 什么时候可以加 @Sharable</h4><ul>\n<li>当 handler <strong>不保存状态时，就可以@Sharable</strong>安全地在多线程下被共享</li>\n<li>但要注意<strong>对于编解码器类(S)：不能继承 ByteToMessageCodec(需拼凑,有状态!S) 或 CombinedChannelDuplexHandler 父类(!S)，他们的构造方法对 @Sharable 有限制：报错</strong></li>\n<li>如果&#x3D;&#x3D;【能确保编解码器不会保存状态(S)，可以继承 MessageToMessageCodec 父类】&#x3D;&#x3D;</li>\n</ul>\n<p>MessageCodecSharable【对标MessageCodec】    父类不同！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\n@ChannelHandler.Sharable&#x2F;&#x2F;\n&#x2F;**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，[确保]接到的 ByteBuf 消息是[完整]的\n *&#x2F;\npublic class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;&#x2F;&#x2F;S\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        ByteBuf out &#x3D; ctx.alloc().buffer();\n        &#x2F;&#x2F; 1. 4 字节的魔数\n        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        &#x2F;&#x2F; 2. 1 字节的版本,\n        out.writeByte(1);\n        &#x2F;&#x2F; 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        &#x2F;&#x2F; 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 无意义，对齐填充\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 6. 获取内容的字节数组\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n        &#x2F;&#x2F; 7. 长度\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        int magicNum &#x3D; in.readInt();\n        byte version &#x3D; in.readByte();\n        byte serializerType &#x3D; in.readByte();\n        byte messageType &#x3D; in.readByte();\n        int sequenceId &#x3D; in.readInt();\n        in.readByte();\n        int length &#x3D; in.readInt();\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(&quot;&#123;&#125;&quot;, message);\n        out.add(message);\n    &#125;\n&#125;</code></pre>\n\n\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestMessageCodec &#123;\n    public static void main(String[] args) throws Exception &#123;\n\n        &#x2F;&#x2F;[无状态]线程安全：加了@Sharable\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler();&#x2F;&#x2F;可抽取到外面被共享！\n\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(\n                LOGGING_HANDLER,\n                &#x2F;&#x2F;被多个EventLoop用到，记录多次msg间的状态，[有状态]线程不安全:需要每次new！！！\n                &#x2F;&#x2F;worker1ch 1234\n                &#x2F;&#x2F;worker2ch 1234\n                new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0),\n                new MessageCodec());&#x2F;&#x2F;or FRAME_DECODER+MessageCodecSharable?\n</code></pre>\n\n\n\n<h2 id=\"3-x3D-x3D-【QQ】聊天室案例-x3D-x3D\"><a href=\"#3-x3D-x3D-【QQ】聊天室案例-x3D-x3D\" class=\"headerlink\" title=\"3. &#x3D;&#x3D;【QQ】聊天室案例&#x3D;&#x3D;\"></a>3. &#x3D;&#x3D;【QQ】聊天室案例&#x3D;&#x3D;</h2><h3 id=\"3-1-聊天室业务介绍\"><a href=\"#3-1-聊天室业务介绍\" class=\"headerlink\" title=\"3.1 聊天室业务介绍\"></a>3.1 聊天室业务介绍</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 用户管理接口\n *&#x2F;\npublic interface UserService &#123;\n\n    &#x2F;**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     *&#x2F;\n    boolean login(String username, String password);\n&#125;</code></pre>\n\n\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 会话管理接口\n *&#x2F;\npublic interface Session &#123;\n\n    &#x2F;**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     *&#x2F;\n    void bind(Channel channel, String username);\n\n    &#x2F;**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     *&#x2F;\n    void unbind(Channel channel);\n\n    &#x2F;**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     *&#x2F;\n    Object getAttribute(Channel channel, String name);\n\n    &#x2F;**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     *&#x2F;\n    void setAttribute(Channel channel, String name, Object value);\n\n    &#x2F;**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     *&#x2F;\n    Channel getChannel(String username);\n&#125;</code></pre>\n\n\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 聊天组会话管理接口\n *&#x2F;\npublic interface GroupSession &#123;\n\n    &#x2F;**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     *&#x2F;\n    Group createGroup(String name, Set&lt;String&gt; members);\n\n    &#x2F;**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group joinMember(String name, String member);\n\n    &#x2F;**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeMember(String name, String member);\n\n    &#x2F;**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeGroup(String name);\n\n    &#x2F;**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 没有成员会返回 empty set\n     *&#x2F;\n    Set&lt;String&gt; getMembers(String name);\n\n    &#x2F;**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     *&#x2F;\n    List&lt;Channel&gt; getMembersChannel(String name);\n&#125;</code></pre>\n\n\n\n<h3 id=\"3-2-聊天室业务-登录\"><a href=\"#3-2-聊天室业务-登录\" class=\"headerlink\" title=\"3.2 聊天室业务-登录\"></a>3.2 聊天室业务-登录</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class ChatServer &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;() &#123;&#x2F;&#x2F;待抽取出来！LoginRequestMessageHandler\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;\n                            String username &#x3D; msg.getUsername();\n                            String password &#x3D; msg.getPassword();\n                            boolean login &#x3D; UserServiceFactory.getUserService().login(username, password);\n                            LoginResponseMessage message;\n                            if(login) &#123;\n                                message &#x3D; new LoginResponseMessage(true, &quot;登录成功&quot;);\n                            &#125; else &#123;\n                                message &#x3D; new LoginResponseMessage(false, &quot;用户名或密码不正确&quot;);\n                            &#125;\n                            ctx.writeAndFlush(message);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class ChatClient &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN &#x3D; new CountDownLatch(1);&#x2F;&#x2F;\n        AtomicBoolean LOGIN &#x3D; new AtomicBoolean(false);&#x2F;&#x2F;\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n&#x2F;&#x2F;                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(&quot;client handler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                        &#x2F;&#x2F; 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                            log.debug(&quot;msg: &#123;&#125;&quot;, msg);\n                            if ((msg instanceof LoginResponseMessage)) &#123;\n                                LoginResponseMessage response &#x3D; (LoginResponseMessage) msg;\n                                if (response.isSuccess()) &#123;\n                                    &#x2F;&#x2F; 如果登录成功\n                                    LOGIN.set(true);\n                                &#125;\n                                &#x2F;&#x2F; 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            &#125;\n                        &#125;\n\n                        &#x2F;&#x2F; 在连接建立后触发 active 事件\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            &#x2F;&#x2F; 负责接收用户在控制台的输入，负责向服务器发送各种消息\n                            new Thread(() -&gt; &#123;\n                                Scanner scanner &#x3D; new Scanner(System.in);\n                                System.out.println(&quot;请输入用户名:&quot;);\n                                String username &#x3D; scanner.nextLine();\n                                System.out.println(&quot;请输入密码:&quot;);\n                                String password &#x3D; scanner.nextLine();\n                                &#x2F;&#x2F; 构造消息对象\n                                LoginRequestMessage message &#x3D; new LoginRequestMessage(username, password);\n                                &#x2F;&#x2F; 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println(&quot;等待后续操作...&quot;);\n                                try &#123;\n                                    WAIT_FOR_LOGIN.await();\n                                &#125; catch (InterruptedException e) &#123;\n                                    e.printStackTrace();\n                                &#125;\n                                &#x2F;&#x2F; 如果登录失败\n                                if (!LOGIN.get()) &#123;\n                                    ctx.channel().close();\n                                    return;\n                                &#125;\n                                while (true) &#123;\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    System.out.println(&quot;send [username] [content]&quot;);\n                                    System.out.println(&quot;gsend [group name] [content]&quot;);\n                                    System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);\n                                    System.out.println(&quot;gmembers [group name]&quot;);\n                                    System.out.println(&quot;gjoin [group name]&quot;);\n                                    System.out.println(&quot;gquit [group name]&quot;);\n                                    System.out.println(&quot;quit&quot;);\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    String command &#x3D; scanner.nextLine();\n                                    String[] s &#x3D; command.split(&quot; &quot;);\n                                    switch (s[0])&#123;\n                                        case &quot;send&quot;:\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gsend&quot;:\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gcreate&quot;:\n                                            Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(s[2].split(&quot;,&quot;)));\n                                            set.add(username); &#x2F;&#x2F; 加入自己！易忘！\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case &quot;gmembers&quot;:\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case &quot;gjoin&quot;:\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;gquit&quot;:\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;quit&quot;:\n                                            ctx.channel().close();\n                                            return;\n                                    &#125;\n                                &#125;\n                            &#125;, &quot;system in&quot;).start();\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"3-3-聊天室业务-单聊\"><a href=\"#3-3-聊天室业务-单聊\" class=\"headerlink\" title=\"3.3 聊天室业务-单聊\"></a>3.3 聊天室业务-单聊</h3><p>服务器端将 handler 独立出来：利用idea的重构功能</p>\n<p>SimpleChannelInboundHandler  右键refactor、convert anonymous to inner…【F6】</p>\n<p>private static class LoginRequestMessageHandler：右键refactor、move inner class【选first：move to upper level】 到server.handler包中,main.下的</p>\n<p>无状态：@Sharable</p>\n<p>登录 handler</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;\n        String username &#x3D; msg.getUsername();\n        String password &#x3D; msg.getPassword();\n        boolean login &#x3D; UserServiceFactory.getUserService().login(username, password);&#x2F;&#x2F;\n        LoginResponseMessage message;\n        if(login) &#123;\n            SessionFactory.getSession().bind(ctx.channel(), username);&#x2F;&#x2F;name&lt;-&gt;channel双向ConcurrentHashMap\n            message &#x3D; new LoginResponseMessage(true, &quot;登录成功&quot;);\n        &#125; else &#123;\n            message &#x3D; new LoginResponseMessage(false, &quot;用户名或密码不正确&quot;);\n        &#125;\n        ctx.writeAndFlush(message);\n    &#125;\n&#125;</code></pre>\n\n<p>单聊 handler</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\npublic class ChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;ChatRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception &#123;\n        String to &#x3D; msg.getTo();\n        Channel channel &#x3D; SessionFactory.getSession().getChannel(to);&#x2F;&#x2F;\n        &#x2F;&#x2F; 在线\n        if(channel !&#x3D; null) &#123;\n            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));\n        &#125;\n        &#x2F;&#x2F; 不在线\n        else &#123;\n            ctx.writeAndFlush(new ChatResponseMessage(false, &quot;对方用户不存在或者不在线&quot;));\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>1Server 2Client：  zhangsan123  lisi123</p>\n<p>send lisi 你好         send zhangsan hello！</p>\n<h3 id=\"3-4-聊天室业务-群聊\"><a href=\"#3-4-聊天室业务-群聊\" class=\"headerlink\" title=\"3.4 聊天室业务-群聊\"></a>3.4 聊天室业务-群聊</h3><p>创建群聊</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\npublic class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupCreateRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception &#123;\n        String groupName &#x3D; msg.getGroupName();\n        Set&lt;String&gt; members &#x3D; msg.getMembers();\n        &#x2F;&#x2F; 群管理器\n        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();\n        Group group &#x3D; groupSession.createGroup(groupName, members);&#x2F;&#x2F;ConcurrentHashMap groupMap.putIfAbsent()\n        if (group &#x3D;&#x3D; null) &#123;\n            &#x2F;&#x2F; 发送成功消息\n            ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + &quot;创建成功&quot;));\n            &#x2F;&#x2F; 群发拉群消息\n            List&lt;Channel&gt; channels &#x3D; groupSession.getMembersChannel(groupName);&#x2F;&#x2F;Java8 过滤出nonNull_members!!!\n            for (Channel channel : channels) &#123;\n                channel.writeAndFlush(new GroupCreateResponseMessage(true, &quot;您已被拉入&quot; + groupName));\n            &#125;\n        &#125; else &#123;\n            ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + &quot;已经存在&quot;));\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<p>1Server 3Client：  zhangsan123  lisi123  wangwu123</p>\n<p>zhangsan发：gcreate 群聊1 lisi,wangwu</p>\n<p>群聊</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\npublic class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupChatRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception &#123;\n        List&lt;Channel&gt; channels &#x3D; GroupSessionFactory.getGroupSession()\n                .getMembersChannel(msg.getGroupName());\n\n        for (Channel channel : channels) &#123;\n            channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));&#x2F;&#x2F;群内成员：收到来自from的msg_content\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>1Server 3Client：  zhangsan123  lisi123  wangwu123 zhaoliu123</p>\n<p>zhangsan发：gcreate 群聊1 lisi,wangwu</p>\n<p>gsend 群聊1 大家好</p>\n<p>【作业】</p>\n<p>加入群聊</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\npublic class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupJoinRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception &#123;\n        Group group &#x3D; GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());\n        if (group !&#x3D; null) &#123;\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群加入成功&quot;));\n        &#125; else &#123;\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群不存在&quot;));\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>gjoin 群聊1</p>\n<p>退出群聊</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\npublic class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupQuitRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception &#123;\n        Group group &#x3D; GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());\n        if (group !&#x3D; null) &#123;\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, &quot;已退出群&quot; + msg.getGroupName()));\n        &#125; else &#123;\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群不存在&quot;));\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>gquit 群聊1</p>\n<p>查看成员</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\npublic class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupMembersRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception &#123;\n        Set&lt;String&gt; members &#x3D; GroupSessionFactory.getGroupSession()\n                .getMembers(msg.getGroupName());&#x2F;&#x2F;getOrDefault！\n        ctx.writeAndFlush(new GroupMembersResponseMessage(members));\n    &#125;\n&#125;</code></pre>\n\n<p>gmembers 群聊1</p>\n<h3 id=\"3-5-聊天室业务-退出\"><a href=\"#3-5-聊天室业务-退出\" class=\"headerlink\" title=\"3.5 聊天室业务-退出\"></a>3.5 聊天室业务-退出</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\n@ChannelHandler.Sharable\npublic class QuitHandler extends ChannelInboundHandlerAdapter &#123;\n\n    &#x2F;&#x2F; 当连接断开时触发 inactive 事件  [quit]ctx.channel().close();\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(&quot;&#123;&#125; 已经断开&quot;, ctx.channel());\n    &#125;\n\n    &#x2F;&#x2F; 当出现异常时触发 直接关闭！\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;&#x2F;&#x2F;\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;, ctx.channel(), cause.getMessage());\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h3 id=\"3-6-聊天室业务-空闲检测\"><a href=\"#3-6-聊天室业务-空闲检测\" class=\"headerlink\" title=\"3.6 聊天室业务-空闲检测\"></a>3.6 聊天室业务-空闲检测</h3><h4 id=\"连接假死-心跳\"><a href=\"#连接假死-心跳\" class=\"headerlink\" title=\"连接假死-心跳\"></a>连接假死-心跳</h4><p>原因</p>\n<ul>\n<li><strong>网络设备出现故障</strong>，例如网卡，机房等，<strong>底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</strong></li>\n<li>公网网络不稳定，出现丢包。如果<strong>连续出现丢包</strong>，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么<strong>一直耗着</strong></li>\n<li>应用程序<strong>线程阻塞，无法进行数据读写</strong></li>\n</ul>\n<p>问题</p>\n<ul>\n<li><strong>假死的连接占用的资源不能自动释放</strong></li>\n<li>向假死的连接发送数据，得到的<strong>反馈是发送超时</strong></li>\n</ul>\n<p>S服务器端解决</p>\n<ul>\n<li>怎么判断客户端连接是否假死呢？如果<strong>能收到客户端数据，说明没有假死</strong>。因此策略就可以定为，<strong>每隔一段时间就[空闲检测]检查这段时间内是否接收到</strong>客户端数据，没有就可以判定为连接假死</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n&#x2F;&#x2F; 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件（属于自定义的特殊事件！）\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));&#x2F;&#x2F;R,W,all  太小不好测，就断了，10s\n&#x2F;&#x2F; ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n    &#x2F;&#x2F; 用来触发【非io】特殊事件，例如IdleState#READER_IDLE 事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception&#123;\n        IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n        &#x2F;&#x2F; 触发了读空闲事件\n        if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE) &#123;\n            log.debug(&quot;已经 5s 没有读到数据了&quot;);\n            ctx.channel().close();\n        &#125;\n    &#125;\n&#125;);</code></pre>\n\n\n\n<p>C客户端定时心跳</p>\n<ul>\n<li>客户端可以<strong>定时向服务器端[发送心跳]数据，只要这个时间间隔[小于服务器定义的空闲检测]的时间间隔，那么就能防止前面提到的误判</strong>，客户端可以定义如下心跳处理器</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n&#x2F;&#x2F; 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n&#x2F;&#x2F; ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n    &#x2F;&#x2F; 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception&#123;\n        IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n        &#x2F;&#x2F; 触发了写空闲事件\n        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;\n            &#x2F;&#x2F;log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);&#x2F;&#x2F;注释掉，避免打断输入！\n            ctx.writeAndFlush(new PingMessage());\n        &#125;\n    &#125;\n&#125;);</code></pre>\n\n<h1 id=\"四-优化与源码\"><a href=\"#四-优化与源码\" class=\"headerlink\" title=\"四. 优化与源码\"></a>四. 优化与源码</h1><h2 id=\"1-优化\"><a href=\"#1-优化\" class=\"headerlink\" title=\"1. 优化\"></a>1. 优化</h2><h3 id=\"1-1-扩展序列化算法\"><a href=\"#1-1-扩展序列化算法\" class=\"headerlink\" title=\"1.1 扩展序列化算法\"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p>\n<ul>\n<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>\n<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>\n</ul>\n<p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 反序列化\nbyte[] body &#x3D; new byte[bodyLength];\nbyteByf.readBytes(body);\nObjectInputStream in &#x3D; new ObjectInputStream(new ByteArrayInputStream(body));\nMessage message &#x3D; (Message) in.readObject();\nmessage.setSequenceId(sequenceId);\n\n&#x2F;&#x2F; 序列化\nByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();\nnew ObjectOutputStream(out).writeObject(message);\nbyte[] bytes &#x3D; out.toByteArray();</code></pre>\n\n<p>为了支持更多序列化算法，抽象一个 Serializer 接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Serializer &#123;\n\n    &#x2F;&#x2F; 反序列化方法\n    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);\n\n    &#x2F;&#x2F; 序列化方法\n    &lt;T&gt; byte[] serialize(T object);\n\n&#125;</code></pre>\n\n<p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">enum SerializerAlgorithm implements Serializer &#123;\n\t&#x2F;&#x2F; Java 实现\n    Java &#123;\n        @Override\n        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n            try &#123;\n                ObjectInputStream in &#x3D; \n                    new ObjectInputStream(new ByteArrayInputStream(bytes));\n                Object object &#x3D; in.readObject();\n                return (T) object;\n            &#125; catch (IOException | ClassNotFoundException e) &#123;\n                throw new RuntimeException(&quot;SerializerAlgorithm.Java 反序列化错误&quot;, e);\n            &#125;\n        &#125;\n\n        @Override\n        public &lt;T&gt; byte[] serialize(T object) &#123;\n            try &#123;\n                ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();\n                new ObjectOutputStream(out).writeObject(object);\n                return out.toByteArray();\n            &#125; catch (IOException e) &#123;\n                throw new RuntimeException(&quot;SerializerAlgorithm.Java 序列化错误&quot;, e);\n            &#125;\n        &#125;\n    &#125;, \n    &#x2F;&#x2F; Json 实现(引入了 Gson 依赖)\n    Json &#123;\n        @Override\n        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n            return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz);&#x2F;&#x2F;\n        &#125;\n\n        @Override\n        public &lt;T&gt; byte[] serialize(T object) &#123;\n            return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8);&#x2F;&#x2F;\n        &#125;\n    &#125;;\n\n    &#x2F;&#x2F; 需要从协议的字节中得到是哪种序列化算法【弃用，有API！】\n    public static SerializerAlgorithm getByInt(int type) &#123;\n        SerializerAlgorithm[] array &#x3D; SerializerAlgorithm.values();\n        if (type &lt; 0 || type &gt; array.length - 1) &#123;\n            throw new IllegalArgumentException(&quot;超过 SerializerAlgorithm 范围&quot;);\n        &#125;\n        return array[type];\n    &#125;\n&#125;</code></pre>\n\n<p>我的做法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.protocol;\n\nimport com.google.gson.*;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.nio.charset.StandardCharsets;\n\n&#x2F;**\n * 用于扩展序列化、反序列化算法\n *&#x2F;\npublic interface Serializer &#123;\n\n    &#x2F;&#x2F; 反序列化方法\n    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);\n\n    &#x2F;&#x2F; 序列化方法\n    &lt;T&gt; byte[] serialize(T object);\n\n    enum Algorithm implements Serializer &#123;\n\n        Java &#123;\n            @Override\n            public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n                try &#123;\n                    ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));&#x2F;&#x2F;ois-bis-byt[]\n                    return (T) ois.readObject();&#x2F;&#x2F;(T)\n                &#125; catch (IOException | ClassNotFoundException e) &#123;&#x2F;&#x2F;|\n                    throw new RuntimeException(&quot;反序列化失败&quot;, e);\n                &#125;\n            &#125;\n\n            @Override\n            public &lt;T&gt; byte[] serialize(T object) &#123;\n                try &#123;\n                    ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n                    ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n                    oos.writeObject(object);&#x2F;&#x2F;oos-bos-obj  bos-&gt;byte[]\n                    return bos.toByteArray();\n                &#125; catch (IOException e) &#123;\n                    throw new RuntimeException(&quot;序列化失败&quot;, e);\n                &#125;\n            &#125;\n        &#125;,\n\n        Json &#123;\n            @Override\n            public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;+ClassCodec\n                String json &#x3D; new String(bytes, StandardCharsets.UTF_8);\n&#x2F;&#x2F;                return new Gson().fromJson(json, clazz);&#x2F;&#x2F;\n                return gson.fromJson(json, clazz);\n            &#125;\n\n            @Override\n            public &lt;T&gt; byte[] serialize(T object) &#123;\n                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;+ClassCodec\n                String json &#x3D; gson.toJson(object);\n&#x2F;&#x2F;                String json &#x3D; new Gson().toJson(object);\n                return json.getBytes(StandardCharsets.UTF_8);\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;自定义ClassCodec\n    class ClassCodec implements JsonSerializer&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;\n\n        @Override\n        public Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123;\n            try &#123;\n                String str &#x3D; json.getAsString();\n                return Class.forName(str);\n            &#125; catch (ClassNotFoundException e) &#123;\n                throw new JsonParseException(e);\n            &#125;\n        &#125;\n\n        @Override             &#x2F;&#x2F;   String.class\n        public JsonElement serialize(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context) &#123;\n            &#x2F;&#x2F; class -&gt; json\n            return new JsonPrimitive(src.getName());\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>registerTypeAdapter(java.lang.reflect.Type type, java.lang.Object typeAdapter) 为type类型字段，指定特殊的类型适配器<br>例子01：格式化日期类型</p>\n<p>@JsonAdapter 一样的方式<br>可以支持 <strong>JsonDeserializer,JsonSerializer</strong>,InstanceCreator,TypeAdapter四种适配器类型<br>————————————————<br>版权声明：本文为CSDN博主「向上小蚂蚁」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/jieandan/article/details/109774650\">https://blog.csdn.net/jieandan/article/details/109774650</a></p>\n<p>增加配置类和配置文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class Config &#123;\n    static Properties properties;\n    static &#123;\n        try (InputStream in &#x3D; Config.class.getResourceAsStream(&quot;&#x2F;application.properties&quot;)) &#123;\n            properties &#x3D; new Properties();\n            properties.load(in);\n        &#125; catch (IOException e) &#123;\n            throw new ExceptionInInitializerError(e);\n        &#125;\n    &#125;\n    public static int getServerPort() &#123;\n        String value &#x3D; properties.getProperty(&quot;server.port&quot;);\n        if(value &#x3D;&#x3D; null) &#123;\n            return 8080;\n        &#125; else &#123;\n            return Integer.parseInt(value);\n        &#125;\n    &#125;\n    public static Serializer.Algorithm getSerializerAlgorithm() &#123;\n        String value &#x3D; properties.getProperty(&quot;serializer.algorithm&quot;);\n        if(value &#x3D;&#x3D; null) &#123;\n            return Serializer.Algorithm.Java;\n        &#125; else &#123;\n            return Serializer.Algorithm.valueOf(value);&#x2F;&#x2F;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>配置文件</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">serializer.algorithm&#x3D;Json</code></pre>\n\n\n\n<p>修改编解码器</p>\n<p>out.writeByte(Config.getSerializerAlgorithm().ordinal());&#x2F;&#x2F;Java-&gt;0</p>\n<p>&#x2F;&#x2F; 找到反序列化算法<br>        Serializer.Algorithm algorithm &#x3D; Serializer.Algorithm.values()[serializerAlgorithm];&#x2F;&#x2F;.values()[0]&#x3D;Java 枚举类对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n *&#x2F;\npublic class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;\n    @Override\n    public void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        ByteBuf out &#x3D; ctx.alloc().buffer();\n        &#x2F;&#x2F; 1. 4 字节的魔数\n        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        &#x2F;&#x2F; 2. 1 字节的版本,\n        out.writeByte(1);\n        &#x2F;&#x2F; 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(Config.getSerializerAlgorithm().ordinal());&#x2F;&#x2F;Java-&gt;0\n        &#x2F;&#x2F; 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 无意义，对齐填充\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 6. 获取内容的字节数组\n        byte[] bytes &#x3D; Config.getSerializerAlgorithm().serialize(msg);\n        &#x2F;&#x2F; 7. 长度\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        int magicNum &#x3D; in.readInt();\n        byte version &#x3D; in.readByte();\n        byte serializerAlgorithm &#x3D; in.readByte(); &#x2F;&#x2F; 0 或 1\n        byte messageType &#x3D; in.readByte(); &#x2F;&#x2F; 0,1,2...\n        int sequenceId &#x3D; in.readInt();\n        in.readByte();\n        int length &#x3D; in.readInt();\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n\n&#x2F;&#x2F;        Message msg &#x3D; Serializer.Algorithm.Java.deserialize(Message.class, bytes);&#x2F;&#x2F;不行：1.写死Java 2.Message是抽象类！要确定具体msg.class！\n\n        &#x2F;&#x2F; 找到反序列化算法\n        Serializer.Algorithm algorithm &#x3D; Serializer.Algorithm.values()[serializerAlgorithm];&#x2F;&#x2F;.values()[0]&#x3D;Java 枚举类对象\n        &#x2F;&#x2F; 确定具体消息类型\n        Class&lt;? extends Message&gt; messageClass &#x3D; Message.getMessageClass(messageType);\n        Message message &#x3D; algorithm.deserialize(messageClass, bytes);\n&#x2F;&#x2F;        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);\n&#x2F;&#x2F;        log.debug(&quot;&#123;&#125;&quot;, message);\n        out.add(message);\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic abstract class Message implements Serializable &#123;\n\n    &#x2F;**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     *&#x2F;\n    public static Class&lt;? extends Message&gt; getMessageClass(int messageType) &#123;\n        return messageClasses.get(messageType);\n    &#125;\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage &#x3D; 0;\n    public static final int LoginResponseMessage &#x3D; 1;\n    public static final int ChatRequestMessage &#x3D; 2;\n    public static final int ChatResponseMessage &#x3D; 3;\n    public static final int GroupCreateRequestMessage &#x3D; 4;\n    public static final int GroupCreateResponseMessage &#x3D; 5;\n    public static final int GroupJoinRequestMessage &#x3D; 6;\n    public static final int GroupJoinResponseMessage &#x3D; 7;\n    public static final int GroupQuitRequestMessage &#x3D; 8;\n    public static final int GroupQuitResponseMessage &#x3D; 9;\n    public static final int GroupChatRequestMessage &#x3D; 10;\n    public static final int GroupChatResponseMessage &#x3D; 11;\n    public static final int GroupMembersRequestMessage &#x3D; 12;\n    public static final int GroupMembersResponseMessage &#x3D; 13;\n    public static final int PingMessage &#x3D; 14;\n    public static final int PongMessage &#x3D; 15;\n    private static final Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);\n    &#125;\n&#125;</code></pre>\n\n<p>test.java下netty.c5.TestSerializer：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.netty.c5;\n\npublic class TestSerializer &#123;\n\n    public static void main(String[] args)  &#123;\n        MessageCodecSharable CODEC &#x3D; new MessageCodecSharable();\n        LoggingHandler LOGGING &#x3D; new LoggingHandler();\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(LOGGING, CODEC, LOGGING);&#x2F;&#x2F;(handlers) log编解码前后\n\n        LoginRequestMessage message &#x3D; new LoginRequestMessage(&quot;zhangsan&quot;, &quot;123&quot;);\n        &#x2F;&#x2F;&lt;-out_编码_序列化  前log：Java对象msg-&gt;后log：buf[]_Json串【Jdk序列化：较长，bin看不懂】 ret boolean\n        channel.writeOutbound(message);\n        &#x2F;&#x2F;因为MessageCodecSharable.encode(ctx,)方法不能直接用:ByteBuf out &#x3D; 入参ctx.alloc().buffer();内部分配使用\n        ByteBuf buf &#x3D; messageToByteBuf(message);\n        &#x2F;&#x2F;-&gt;in_解码_反序列化  前log：buf[]_Json串-&gt;后log：Java对象\n        channel.writeInbound(buf);\n    &#125;\n\n    public static ByteBuf messageToByteBuf(Message msg) &#123;&#x2F;&#x2F;Java对象-&gt;ByteBuf\n        int algorithm &#x3D; Config.getSerializerAlgorithm().ordinal();\n        ByteBuf out &#x3D; ByteBufAllocator.DEFAULT.buffer();&#x2F;&#x2F;自己分配ByteBuf\n        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        out.writeByte(1);\n        out.writeByte(algorithm);\n        out.writeByte(msg.getMessageType());\n        out.writeInt(msg.getSequenceId());\n        out.writeByte(0xff);\n        byte[] bytes &#x3D; Serializer.Algorithm.values()[algorithm].serialize(msg);&#x2F;&#x2F;\n        out.writeInt(bytes.length);\n        out.writeBytes(bytes);\n        return out;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h3 id=\"1-2-参数调优\"><a href=\"#1-2-参数调优\" class=\"headerlink\" title=\"1.2 参数调优\"></a>1.2 参数调优</h3><h4 id=\"1）CONNECT-TIMEOUT-MILLIS\"><a href=\"#1）CONNECT-TIMEOUT-MILLIS\" class=\"headerlink\" title=\"1）CONNECT_TIMEOUT_MILLIS\"></a>1）CONNECT_TIMEOUT_MILLIS</h4><ul>\n<li>属于 SocketChannal 参数</li>\n<li>用在<strong>客户端建立连接</strong>时(Server只有accept()接收连接)，如果在<strong>指定毫秒内无法连接，会抛出 timeout 异常</strong></li>\n<li>易混淆：<strong>SO_TIMEOUT 主要用在[传统阻塞 IO]，阻塞 IO 中 accept，read 等都是无限等待的</strong>，如果不希望永远阻塞，使用它调整超时时间【不用在nio、netty编程！】</li>\n</ul>\n<p>test下的source包下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class TestConnectionTimeout &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1. 客户端通过 .option() 方法配置参数 给 SocketChannel 配置参数\n\n        &#x2F;&#x2F; 2. 服务器端\n&#x2F;&#x2F;        new ServerBootstrap().option() &#x2F;&#x2F; 是给 ServerSocketChannel 配置参数\n&#x2F;&#x2F;        new ServerBootstrap().childOption() &#x2F;&#x2F; 给 SocketChannel 配置参数\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap()\n                    .group(group)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)&#x2F;&#x2F;3000ms超时:等不到\n                    .channel(NioSocketChannel.class)\n                    .handler(new LoggingHandler());\n            ChannelFuture future &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080);\n            future.sync().channel().closeFuture().sync(); &#x2F;&#x2F; 断点1\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            log.debug(&quot;timeout&quot;);\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>2s就确认Server端没开，连接拒绝。不等超时就报错</p>\n<p>Caused by: java.net.ConnectException: Connection refused: no further information</p>\n<p>1.future.sync().channel().closeFuture().sync();</p>\n<p>2.抛异常处(AbstractNioChannel.java:263) </p>\n<p>两处+端点【右键，类型必须是：Thread类型！】，debug：</p>\n<p>future 右键mark object</p>\n<p>换nioTH：</p>\n<p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p>\n<p>eventLoop-监测nio事件 内有nioth &#x2F; th：提交(定时)任务 schedule 连接超时</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic final void connect(\n        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; Schedule connect timeout.\n    int connectTimeoutMillis &#x3D; config().getConnectTimeoutMillis();&#x2F;&#x2F;\n    if (connectTimeoutMillis &gt; 0) &#123;\n        connectTimeoutFuture &#x3D; eventLoop().schedule(new Runnable() &#123;\n            @Override\n            public void run() &#123;                \n                ChannelPromise connectPromise &#x3D; AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause &#x3D;\n                    new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress); &#x2F;&#x2F; 断点2 异常\n                if (connectPromise !&#x3D; null &amp;&amp; connectPromise.tryFailure(cause)) &#123;&#x2F;&#x2F;异常cause-唤醒主sync() catch...\n                    close(voidPromise());\n                &#125;\n            &#125;\n        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    &#125;\n\t&#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p>Promise  定时任务</p>\n<h4 id=\"2）SO-BACKLOG\"><a href=\"#2）SO-BACKLOG\" class=\"headerlink\" title=\"2）SO_BACKLOG\"></a>2）SO_BACKLOG</h4><ul>\n<li>属于 ServerSocketChannal 参数（建立连接时设置）</li>\n</ul>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">sequenceDiagram\n\nparticipant c as client\nparticipant s as server\nparticipant sq as sync queue\nparticipant aq as accept queue\n\ns -&gt;&gt; s : bind()\ns -&gt;&gt; s : listen()\nc -&gt;&gt; c : connect()\nc -&gt;&gt; s : 1. SYN\nNote left of c : SYN_SEND\ns -&gt;&gt; sq : put\nNote right of s : SYN_RCVD\ns -&gt;&gt; c : 2. SYN + ACK\nNote left of c : ESTABLISHED\nc -&gt;&gt; s : 3. ACK\nsq -&gt;&gt; aq : put\nNote right of s : ESTABLISHED\naq --&gt;&gt; s : \ns -&gt;&gt; s : accept()</code></pre>\n\n<ol>\n<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>\n<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>\n<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue(半连接队列) 放入 accept queue(全连接队列)</li>\n</ol>\n<p>其中</p>\n<ul>\n<li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>\n</li>\n<li><p>sync queue - 半连接队列</p>\n<ul>\n<li>大小通过 <strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog</strong> 指定，在 <strong><code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</strong></li>\n</ul>\n</li>\n<li><p>accept queue - 全连接队列</p>\n<ul>\n<li>其大小通过 <strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</strong> 指定，在使<strong>用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong>      </li>\n<li>min(nio程序中bind(8080, backlog); , somaxconn)</li>\n<li>如果 accpet queue <strong>队列满了，server 将发送一个【拒绝连接】的错误信息到 client</strong></li>\n</ul>\n</li>\n</ul>\n<p>netty 中</p>\n<p>可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小  &#x2F;&#x2F; 全队列满了</p>\n<p>netty处理能力强，处理不了了才会堆积到全连接队列里</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220502112651966.png\" alt=\"image-20220502112651966\"></p>\n<p>打断点，不让调accept()从全连接队列里取，造成堆积！</p>\n<p>queue&#x3D;2  debug_server、run3个Client（Allow parallel run）：报错ConnectException: Connection refused</p>\n<p>可以通过下面源码查看默认大小</p>\n<p>ServerSocketChannel中bind()被调用，backlog被赋值：find usage</p>\n<p>netty中的，doBind()：javaChannel().bind(localAddress, config.getBacklog());</p>\n<p>ServerSocketChannelConfig：Ctrl_Alt_B看实现：DefaultServerSocketChannelConfig</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DefaultServerSocketChannelConfig extends DefaultChannelConfig\n                                              implements ServerSocketChannelConfig &#123;\n\n    private volatile int backlog &#x3D; NetUtil.SOMAXCONN;&#x2F;&#x2F;\n    &#x2F;&#x2F; ...\n&#125;\n\n\nNetUtil:\n        SOMAXCONN &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Integer&gt;() &#123;\n            @Override\n            public Integer run() &#123;\n                &#x2F;&#x2F; Determine the default somaxconn (server socket backlog) value of the platform.\n                &#x2F;&#x2F; The known defaults:\n                &#x2F;&#x2F; - Windows NT Server 4.0+: 200\n                &#x2F;&#x2F; - Linux and Mac OS X: 128\n                int somaxconn &#x3D; PlatformDependent.isWindows() ? 200 : 128;&#x2F;&#x2F;\n                File file &#x3D; new File(&quot;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn&quot;);&#x2F;&#x2F;\n                BufferedReader in &#x3D; null;\n                try &#123;\n                    &#x2F;&#x2F; file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the\n                    &#x2F;&#x2F; try &#x2F; catch block.\n                    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;4936\n                    if (file.exists()) &#123;\n                        in &#x3D; new BufferedReader(new FileReader(file));\n                        somaxconn &#x3D; Integer.parseInt(in.readLine());&#x2F;&#x2F;</code></pre>\n\n\n\n<p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>\n<p>oio 中更容易说明，不用 debug 模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Server &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket ss &#x3D; new ServerSocket(8888, 2);\n        Socket accept &#x3D; ss.accept();&#x2F;&#x2F;oio accept阻塞！\n        System.out.println(accept);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p>客户端启动 4 个</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        try &#123;\n            Socket s &#x3D; new Socket();\n            System.out.println(new Date()+&quot; connecting...&quot;);\n            s.connect(new InetSocketAddress(&quot;localhost&quot;, 8888),1000);\n            System.out.println(new Date()+&quot; connected...&quot;);\n            s.getOutputStream().write(1);\n            System.in.read();\n        &#125; catch (IOException e) &#123;\n            System.out.println(new Date()+&quot; connecting timeout...&quot;);\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>第 1，2，3 个客户端都打印，但<strong>除了第一个处于 accpet 外，其它两个都处于 accept queue 中</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Tue Apr 21 20:30:28 CST 2020 connecting...\nTue Apr 21 20:30:28 CST 2020 connected...</code></pre>\n\n<p><strong>第 4 个客户端连接时</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Tue Apr 21 20:53:58 CST 2020 connecting...\nTue Apr 21 20:53:59 CST 2020 connecting timeout...\njava.net.SocketTimeoutException: connect timed out</code></pre>\n\n\n\n\n\n<h4 id=\"3）ulimit-n\"><a href=\"#3）ulimit-n\" class=\"headerlink\" title=\"3）ulimit -n\"></a>3）ulimit -n</h4><ul>\n<li>属于操作系统参数</li>\n</ul>\n<p>一个thread能打开的fd(文件描述符)的最大数量【too many open file】，避免进程打开的文件&#x2F;Socket数太多</p>\n<p><strong>应对高并发，临时调高，建议放在启动脚本中！</strong></p>\n<h4 id=\"4）TCP-NODELAY\"><a href=\"#4）TCP-NODELAY\" class=\"headerlink\" title=\"4）TCP_NODELAY\"></a>4）TCP_NODELAY</h4><ul>\n<li><p>属于 SocketChannal 参数</p>\n<p>false：开启了Nagle，攒一批发有延迟\t建议改为true，用childOption</p>\n</li>\n</ul>\n<h4 id=\"5）SO-SNDBUF-amp-SO-RCVBUF-滑动窗口上限\"><a href=\"#5）SO-SNDBUF-amp-SO-RCVBUF-滑动窗口上限\" class=\"headerlink\" title=\"5）SO_SNDBUF &amp; SO_RCVBUF[滑动窗口上限]\"></a>5）SO_SNDBUF &amp; SO_RCVBUF[滑动窗口上限]</h4><ul>\n<li>SO_SNDBUF 属于 SocketChannal 参数</li>\n<li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）</li>\n</ul>\n<p>[mem占用高了，OS自动会将其自适应调小] 不用调！</p>\n<h4 id=\"6）ALLOCATOR\"><a href=\"#6）ALLOCATOR\" class=\"headerlink\" title=\"6）ALLOCATOR\"></a>6）ALLOCATOR</h4><ul>\n<li><p>属于 SocketChannal 参数</p>\n</li>\n<li><p>用来分配 ByteBuf， ctx.alloc()</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>测试类：TestByteBuf  TestBacklogClient</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n* ctx.alloc().buffer()    PooledUnsafeDirectByteBuf\n\nChannelConfig  DefaultChannelConfig  ByteBufAllocator.DEFAULT;\n\n...ByteBufUtil：\n\n&#96;&#96;&#96;java\nstatic &#123;\n        String allocType &#x3D; SystemPropertyUtil.get(\n                &quot;io.netty.allocator.type&quot;, PlatformDependent.isAndroid() ? &quot;unpooled&quot; : &quot;pooled&quot;);&#x2F;&#x2F;\n        allocType &#x3D; allocType.toLowerCase(Locale.US).trim();\n\n        ByteBufAllocator alloc;\n        if (&quot;unpooled&quot;.equals(allocType)) &#123;\n            alloc &#x3D; UnpooledByteBufAllocator.DEFAULT;&#x2F;&#x2F;DEFAULT\n            logger.debug(&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;, allocType);\n   \n    public static final UnpooledByteBufAllocator DEFAULT &#x3D;\n            new UnpooledByteBufAllocator(PlatformDependent.directBufferPreferred());\n       \n            \n    public static boolean directBufferPreferred() &#123;\n        return DIRECT_BUFFER_PREFERRED;\n    &#125;\n            \nDIRECT_BUFFER_PREFERRED\n\n被使用处：\n&#x2F;&#x2F; We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.\nDIRECT_BUFFER_PREFERRED &#x3D; CLEANER !&#x3D; NOOP\n                          &amp;&amp; !SystemPropertyUtil.getBoolean(&quot;io.netty.noPreferDirect&quot;, false);</code></pre></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">TestByteBuf    VM option: \n-Dio.netty.allocator.type&#x3D;unpooled -Dio.netty.noPreferDirect&#x3D;true</code></pre>\n\n<p>InstrumentedUnpooledUnsafeHeapByteBuf</p>\n<h4 id=\"7）RCVBUF-ALLOCATOR\"><a href=\"#7）RCVBUF-ALLOCATOR\" class=\"headerlink\" title=\"7）RCVBUF_ALLOCATOR\"></a>7）RCVBUF_ALLOCATOR</h4><ul>\n<li>属于 SocketChannal 参数</li>\n<li>控制 netty <strong>接收缓冲区大小</strong></li>\n<li>负责入站数据的分配，<strong>决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存</strong>，具体池化还是非池化由 上一个参数:6）allocator 决定</li>\n</ul>\n<p>io数据RW操作：统一direct</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">测试类：TestByteBuf  TestBacklogClient\n\nTestByteBuf    VM option: \n-Dio.netty.allocator.type&#x3D;unpooled -Dio.netty.noPreferDirect&#x3D;true\n\nlog.debug(&quot;receive buf &#123;&#125;&quot;, msg);&#x2F;&#x2F;\nSystem.out.println(&quot;&quot;);&#x2F;&#x2F;打断点 debug\n</code></pre>\n\n<p>Debugger：黄色区域is该线程的堆栈调用链</p>\n<p>Handler、pipeline、找到AbstractNioByteChannel</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">byteBuf &#x3D; allocHandle.allocate(allocator);\n\nfinal ChannelPipeline pipeline &#x3D; pipeline();\n            final ByteBufAllocator allocator &#x3D; config.getAllocator();&#x2F;&#x2F;byteBuf的分配器，(非)池化  ctrl+Alt+B:implement   ---&gt;   ByteBufAllocator.DEFAULT; 读VM参数\n            final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();&#x2F;&#x2F;\n\n            allocHandle.reset(config);\n\n            ByteBuf byteBuf &#x3D; null;\n            boolean close &#x3D; false;\n            try &#123;\n                do &#123;\n                    byteBuf &#x3D; allocHandle.allocate(allocator);&#x2F;&#x2F;是RecvByteBufAllocator的内部类，allocate方法（implement MaxMessageHandle），决定byte的大小和direct\n                    allocHandle.lastBytesRead(doReadBytes(byteBuf));</code></pre>\n\n<p>allocate方法（implement MaxMessageHandle）–&gt;DefaultMaxMessagesRecvByteBufAllocator</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic ByteBuf allocate(ByteBufAllocator alloc) &#123;\n    return alloc.ioBuffer(guess());&#x2F;&#x2F;ioBuf强制Direct  这次发送多，ByteBuf分配更多\n&#125;</code></pre>\n\n<p>AbstractNioByteChannel类：</p>\n<p>allocHandle &#x3D; recvBufAllocHandle();&#x2F;&#x2F;</p>\n<p>getRecvByteBufAllocator()–&gt;implement</p>\n<p>setRecvByteBufAllocator(allocator);</p>\n<p>外层函数调用者：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public DefaultChannelConfig(Channel channel) &#123;\n    this(channel, new AdaptiveRecvByteBufAllocator());&#x2F;&#x2F;\n&#125;\n\n    &#x2F;**\n     * Creates a new predictor with the default parameters.  With the default\n     * parameters, the expected buffer size starts from &#123;@code 1024&#125;, does not\n     * go down below &#123;@code 64&#125;, and does not go up above &#123;@code 65536&#125;.\n     *&#x2F;\n    public AdaptiveRecvByteBufAllocator() &#123;\n        this(DEFAULT_MINIMUM, DEFAULT_INITIAL, DEFAULT_MAXIMUM);&#x2F;&#x2F;64~1024~65536\n    &#125;</code></pre>\n\n\n\n<h3 id=\"1-3-x3D-x3D-典型应用-RPC-框架-基于聊天室ChatSC-【远程方法调用-反射：str-gt-JavaClass】-x3D-x3D\"><a href=\"#1-3-x3D-x3D-典型应用-RPC-框架-基于聊天室ChatSC-【远程方法调用-反射：str-gt-JavaClass】-x3D-x3D\" class=\"headerlink\" title=\"1.3 &#x3D;&#x3D;典型应用-RPC 框架(基于聊天室ChatSC)【远程方法调用 反射：str-&gt;JavaClass】&#x3D;&#x3D;\"></a>1.3 &#x3D;&#x3D;典型应用-RPC 框架(基于聊天室ChatSC)【远程方法调用 反射：str-&gt;JavaClass】&#x3D;&#x3D;</h3><h4 id=\"1）准备工作\"><a href=\"#1）准备工作\" class=\"headerlink\" title=\"1）准备工作\"></a>1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p>\n<p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic abstract class Message implements Serializable &#123;\n\n    &#x2F;&#x2F; 省略旧的代码\n\n    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;\n\n    static &#123;\n        &#x2F;&#x2F; ...\n        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    &#125;\n\n&#125;</code></pre>\n\n<p>请求消息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Getter\n@ToString(callSuper &#x3D; true)\npublic class RpcRequestMessage extends Message &#123;\n\n    &#x2F;**\n     * 调用的接口全限定名，服务端根据它找到实现\n     *&#x2F;\n    private String interfaceName;\n    &#x2F;**\n     * 调用接口中的方法名\n     *&#x2F;\n    private String methodName;\n    &#x2F;**\n     * 方法返回类型\n     *&#x2F;\n    private Class&lt;?&gt; returnType;\n    &#x2F;**\n     * 方法参数类型数组\n     *&#x2F;\n    private Class[] parameterTypes;\n    &#x2F;**\n     * 方法参数值数组\n     *&#x2F;\n    private Object[] parameterValue;\n\n    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue) &#123;\n        super.setSequenceId(sequenceId);\n        this.interfaceName &#x3D; interfaceName;\n        this.methodName &#x3D; methodName;\n        this.returnType &#x3D; returnType;\n        this.parameterTypes &#x3D; parameterTypes;\n        this.parameterValue &#x3D; parameterValue;\n    &#125;\n\n    @Override\n    public int getMessageType() &#123;\n        return RPC_MESSAGE_TYPE_REQUEST;\n    &#125;\n&#125;</code></pre>\n\n<p>响应消息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@ToString(callSuper &#x3D; true)\npublic class RpcResponseMessage extends Message &#123;\n    &#x2F;**\n     * 返回值\n     *&#x2F;\n    private Object returnValue;\n    &#x2F;**\n     * 异常值\n     *&#x2F;\n    private Exception exceptionValue;\n\n    @Override\n    public int getMessageType() &#123;\n        return RPC_MESSAGE_TYPE_RESPONSE;\n    &#125;\n&#125;</code></pre>\n\n<p>服务器架子</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class RpcServer &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        \n        &#x2F;&#x2F; rpc 请求消息处理器，待实现\n        RpcRequestMessageHandler RPC_HANDLER &#x3D; new RpcRequestMessageHandler();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>客户端架子</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RpcClient &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        \n        &#x2F;&#x2F; rpc 响应消息处理器，待实现\n        RpcResponseMessageHandler RPC_HANDLER &#x3D; new RpcResponseMessageHandler();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>服务器端的 service 获取</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ServicesFactory &#123;\n\n    static Properties properties;\n    static Map&lt;Class&lt;?&gt;, Object&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    static &#123;\n        try (InputStream in &#x3D; Config.class.getResourceAsStream(&quot;&#x2F;application.properties&quot;)) &#123;\n            properties &#x3D; new Properties();\n            properties.load(in);\n            Set&lt;String&gt; names &#x3D; properties.stringPropertyNames();\n            for (String name : names) &#123;\n                if (name.endsWith(&quot;Service&quot;)) &#123;\n                    Class&lt;?&gt; interfaceClass &#x3D; Class.forName(name);\n                    Class&lt;?&gt; instanceClass &#x3D; Class.forName(properties.getProperty(name));\n                    map.put(interfaceClass, instanceClass.newInstance());\n                &#125;\n            &#125;\n        &#125; catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;\n            throw new ExceptionInInitializerError(e);\n        &#125;\n    &#125;\n\n    public static &lt;T&gt; T getService(Class&lt;T&gt; interfaceClass) &#123;\n        return (T) map.get(interfaceClass);\n    &#125;\n&#125;</code></pre>\n\n<p>相关配置 application.properties</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">serializer.algorithm&#x3D;Json\ncn.itcast.server.service.HelloService&#x3D;cn.itcast.server.service.HelloServiceImpl</code></pre>\n\n\n\n<h4 id=\"！2）服务器-handler\"><a href=\"#！2）服务器-handler\" class=\"headerlink\" title=\"！2）服务器 handler\"></a>！2）服务器 handler</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\n@ChannelHandler.Sharable\npublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) &#123;\n        RpcResponseMessage response &#x3D; new RpcResponseMessage();\n        response.setSequenceId(message.getSequenceId());&#x2F;&#x2F;\n        try &#123;\n            &#x2F;&#x2F; 获取真正的实现对象\n            HelloService service &#x3D; (HelloService)\n                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n            \n            &#x2F;&#x2F; 获取要调用的方法\n            Method method &#x3D; service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n            \n            &#x2F;&#x2F; 调用方法\n            Object invoke &#x3D; method.invoke(service, message.getParameterValue());\n            &#x2F;&#x2F; 调用成功\n            response.setReturnValue(invoke);&#x2F;&#x2F;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            &#x2F;&#x2F; 调用异常\n            response.setExceptionValue(e);&#x2F;&#x2F;\n        &#125;\n        &#x2F;&#x2F; 返回结果\n        ctx.writeAndFlush(response);&#x2F;&#x2F;\n    &#125;\n    &#x2F;*\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;\n        RpcRequestMessage message &#x3D; new RpcRequestMessage(\n                1,\n                &quot;cn.itcast.server.service.HelloService&quot;,\n                &quot;sayHello&quot;,\n                String.class,\n                new Class[]&#123;String.class&#125;,\n                new Object[]&#123;&quot;张三&quot;&#125;\n        );\n        HelloService service &#x3D; (HelloService)\n                ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n        Method method &#x3D; service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n        Object invoke &#x3D; method.invoke(service, message.getParameterValue());\n        System.out.println(invoke);\n    &#125;*&#x2F;\n&#125;</code></pre>\n\n\n\n\n\n<h4 id=\"3）客户端代码第一版【写死msg对象！自定义处理Handler！自己转换封装obj】\"><a href=\"#3）客户端代码第一版【写死msg对象！自定义处理Handler！自己转换封装obj】\" class=\"headerlink\" title=\"3）客户端代码第一版【写死msg对象！自定义处理Handler！自己转换封装obj】\"></a>3）客户端代码第一版【写死msg对象！自定义处理Handler！自己转换封装obj】</h4><p>只发消息 C：channel 向上出站-&gt;S：向下入站 RpcReqMsgHandler【接口-实现obj-反射调用】 ret-resp S-&gt;C RpcRespMsgHandler_log.debug</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class RpcClient &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER &#x3D; new RpcResponseMessageHandler();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();&#x2F;&#x2F;\n            &#x2F;&#x2F;channel里手写msg：writeAndFlush异步执行，成功还是失败，看返回值future。异步addListener\n            ChannelFuture future &#x3D; channel.writeAndFlush(new RpcRequestMessage(\n                    1,\n                    &quot;cn.itcast.server.service.HelloService&quot;,\n                    &quot;sayHello&quot;,\n                    String.class,\n                    new Class[]&#123;String.class&#125;,\n                    new Object[]&#123;&quot;张三&quot;&#125;\n            )).addListener(promise -&gt; &#123;\n                if (!promise.isSuccess()) &#123;&#x2F;&#x2F;\n                    Throwable cause &#x3D; promise.cause();&#x2F;&#x2F;\n                    log.error(&quot;error&quot;, cause);\n                &#125;\n            &#125;);\n\n            channel.closeFuture().sync();&#x2F;&#x2F;阻塞！！！待改！！！\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"4）客户端-handler-第一版\"><a href=\"#4）客户端-handler-第一版\" class=\"headerlink\" title=\"4）客户端 handler 第一版\"></a>4）客户端 handler 第一版</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;\n        log.debug(&quot;&#123;&#125;&quot;, msg);\n    &#125;\n&#125;</code></pre>\n\n<p>run RpcServer、RpcClient</p>\n<p>现象：active后，不log，不报错</p>\n<p>future &#x3D; channel.writeAndFlush</p>\n<p>.addListener(log：promise.cause();)</p>\n<p>打印异常信息：UnsupportedException</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505131057909.png\" alt=\"image-20220505131057909\"></p>\n<p>修复Gson的Java.Class类型-&gt;Json字符串 的不支持报错：registerTypeAdapter</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestGson &#123;\n    public static void main(String[] args) &#123;\n        Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;重构Serializer！！！\n        System.out.println(gson.toJson(String.class));&#x2F;&#x2F;class类型-&gt;toJson\n        &#x2F;&#x2F;System.out.println(new Gson().toJson(String.class));&#x2F;&#x2F;class类型-&gt;toJson UnsupportedException!\n    &#125;\n&#125;\n\n\n\n\nprotocol包：\n&#x2F;**\n * 用于扩展序列化、反序列化算法\n *&#x2F;\npublic interface Serializer &#123;\n\n    &#x2F;&#x2F; 反序列化方法\n    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);\n\n    &#x2F;&#x2F; 序列化方法\n    &lt;T&gt; byte[] serialize(T object);\n\n    enum Algorithm implements Serializer &#123;\n\n        Java &#123;\n            @Override\n            public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n                try &#123;\n                    ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));&#x2F;&#x2F;ois-bis-byte[]\n                    return (T) ois.readObject();&#x2F;&#x2F;(T)\n                &#125; catch (IOException | ClassNotFoundException e) &#123;&#x2F;&#x2F;|\n                    throw new RuntimeException(&quot;反序列化失败&quot;, e);\n                &#125;\n            &#125;\n\n            @Override\n            public &lt;T&gt; byte[] serialize(T object) &#123;\n                try &#123;\n                    ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n                    ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n                    oos.writeObject(object);&#x2F;&#x2F;oos-bos-obj  bos-&gt;byte[]\n                    return bos.toByteArray();\n                &#125; catch (IOException e) &#123;\n                    throw new RuntimeException(&quot;序列化失败&quot;, e);\n                &#125;\n            &#125;\n        &#125;,\n\n        Json &#123;\n            @Override\n            public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;+ClassCodec    registerTypeAdapter\n                String json &#x3D; new String(bytes, StandardCharsets.UTF_8);\n&#x2F;&#x2F;                return new Gson().fromJson(json, clazz);&#x2F;&#x2F;\n                return gson.fromJson(json, clazz);\n            &#125;\n\n            @Override\n            public &lt;T&gt; byte[] serialize(T object) &#123;\n                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;+ClassCodec\n                String json &#x3D; gson.toJson(object);\n&#x2F;&#x2F;                String json &#x3D; new Gson().toJson(object);\n                return json.getBytes(StandardCharsets.UTF_8);\n            &#125;\n        &#125;\n    &#125;\n    class ClassCodec implements JsonSerializer&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;\n\n        @Override\n        public Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123;&#x2F;&#x2F;\n            try &#123;\n                String str &#x3D; json.getAsString();&#x2F;&#x2F;\n                return Class.forName(str);&#x2F;&#x2F;\n            &#125; catch (ClassNotFoundException e) &#123;\n                throw new JsonParseException(e);&#x2F;&#x2F;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;自定义ClassCodec\n        @Override             &#x2F;&#x2F;   String.class基本类型\n        public JsonElement serialize(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context) &#123;\n            &#x2F;&#x2F; class -&gt; json\n            return new JsonPrimitive(src.getName());&#x2F;&#x2F;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<p>通信ok！</p>\n<h4 id=\"5）客户端代码-第二版【RpcClientManager版：异步网络结果用同步方式】\"><a href=\"#5）客户端代码-第二版【RpcClientManager版：异步网络结果用同步方式】\" class=\"headerlink\" title=\"5）客户端代码 第二版【RpcClientManager版：异步网络结果用同步方式】\"></a>5）客户端代码 第二版【RpcClientManager版：异步网络结果用同步方式】</h4><h4 id=\"包括-x3D-x3D-channel-管理-单例-，-JDK-Proxy-代理，接收结果-promise-await-异步网络结果同步等待，不抛异常-x3D-x3D\"><a href=\"#包括-x3D-x3D-channel-管理-单例-，-JDK-Proxy-代理，接收结果-promise-await-异步网络结果同步等待，不抛异常-x3D-x3D\" class=\"headerlink\" title=\"包括 &#x3D;&#x3D;channel 管理(单例)，(JDK Proxy)代理，接收结果(promise.await();异步网络结果同步等待，不抛异常)&#x3D;&#x3D;\"></a>包括 &#x3D;&#x3D;channel 管理(单例)，(JDK Proxy)代理，接收结果(promise.await();异步网络结果同步等待，不抛异常)&#x3D;&#x3D;</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protocol包：\npublic abstract class SequenceIdGenerator &#123;\n    private static final AtomicInteger id &#x3D; new AtomicInteger();\n\n    public static int nextId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>nio线程间通信：空promise对象类似于空书包，Client端mainTH-&gt;nio线程RespMsgHandler，接到S端响应msg，装入书包-&gt;mainTH拿出</p>\n<p>promise是个容器，用来在多THs间交换结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\npublic class RpcClientManager &#123;\n\n    public static void main(String[] args) &#123;\n        HelloService service &#x3D; getProxyService(HelloService.class);&#x2F;&#x2F;代理对象\n        System.out.println(service.sayHello(&quot;zhangsan&quot;));\n&#x2F;&#x2F;        System.out.println(service.sayHello(&quot;lisi&quot;));\n&#x2F;&#x2F;        System.out.println(service.sayHello(&quot;wangwu&quot;));\n\n    &#125;\n\n    &#x2F;&#x2F;创建代理类：将用户的方法调用转换成底层消息发送，屏蔽细节！\n    public static &lt;T&gt; T getProxyService(Class&lt;T&gt; serviceClass) &#123;\n        &#x2F;&#x2F;JDK Proxy:实现接口\n        ClassLoader loader &#x3D; serviceClass.getClassLoader();\n        Class&lt;?&gt;[] interfaces &#x3D; new Class[]&#123;serviceClass&#125;;\n        &#x2F;&#x2F;                                                           sayHello &quot;张三&quot;\n        Object o &#x3D; Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;\n            &#x2F;&#x2F; 1.将方法调用转换为 消息对象\n            int sequenceId &#x3D; SequenceIdGenerator.nextId();&#x2F;&#x2F;！！！\n            RpcRequestMessage msg &#x3D; new RpcRequestMessage(\n                    sequenceId,\n                    serviceClass.getName(),\n                    method.getName(),\n                    method.getReturnType(),\n                    method.getParameterTypes(),\n                    args\n            );\n            &#x2F;&#x2F; 2.将消息对象发送出去\n            getChannel().writeAndFlush(msg);\n\n            &#x2F;&#x2F; 3.准备一个空 Promise 对象，来接收结果                   指定Promise对象【异步】接收结果的线程\n            DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());&#x2F;&#x2F;父接口是EventExecutor，内有TH\n            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);\n\n&#x2F;&#x2F;            promise.addListener(future -&gt; &#123;\n&#x2F;&#x2F;                &#x2F;&#x2F;TH:Promise对象异步接收结果的线程\n&#x2F;&#x2F;            &#125;);\n\n            &#x2F;&#x2F; 4.mainTH等待 promise 结果\n            promise.await();&#x2F;&#x2F;相比sync(),await()不会抛异常,isSuccess()自己检查！\n            if(promise.isSuccess()) &#123;\n                &#x2F;&#x2F; 调用正常\n                return promise.getNow();\n            &#125; else &#123;\n                &#x2F;&#x2F; 调用失败\n                throw new RuntimeException(promise.cause());\n            &#125;\n        &#125;);\n        return (T)o;&#x2F;&#x2F;\n    &#125;\n\n\n    private static Channel channel &#x3D; null;\n    private static final Object LOCK &#x3D; new Object();\n\n    &#x2F;&#x2F; 获取唯一的 channel 对象\n    public static Channel getChannel() &#123;&#x2F;&#x2F;DCL单例\n        if(channel !&#x3D; null) &#123;\n            return channel;\n        &#125;\n        synchronized (LOCK) &#123;&#x2F;&#x2F;高效\n            if(channel !&#x3D; null) &#123; &#x2F;&#x2F;only one\n                return channel;\n            &#125;\n            initChannel();\n            return channel;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 初始化 channel 方法\n    private static void initChannel() &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER &#x3D; new RpcResponseMessageHandler();\n        Bootstrap bootstrap &#x3D; new Bootstrap();\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.group(group);\n        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception &#123;\n                ch.pipeline().addLast(new ProcotolFrameDecoder());\n                ch.pipeline().addLast(LOGGING_HANDLER);\n                ch.pipeline().addLast(MESSAGE_CODEC);\n                ch.pipeline().addLast(RPC_HANDLER);\n            &#125;\n        &#125;);\n        try &#123;\n            channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();&#x2F;&#x2F;阻塞等channel连接建立好了，才可用\n            channel.closeFuture().addListener(future -&gt; &#123;&#x2F;&#x2F;改异步：否则getChannel()一直阻塞,等关闭\n                group.shutdownGracefully();\n            &#125;);\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505164858588.png\" alt=\"image-20220505164858588\"></p>\n<h4 id=\"6）客户端-handler-第二版\"><a href=\"#6）客户端-handler-第二版\" class=\"headerlink\" title=\"6）客户端 handler 第二版\"></a>6）客户端 handler 第二版</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;\n\n    &#x2F;&#x2F;@Sharable:需要自己保证线程安全 [多次记录promises]有状态：ConcurrentHashMap且单步操作！OK！\n    &#x2F;&#x2F;                       序号id      用来接收结果的 promise 对象\n    public static final Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    @Override\n\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;\n        log.debug(&quot;&#123;&#125;&quot;, msg);\n        &#x2F;&#x2F; 拿到空的 promise\n        Promise&lt;Object&gt; promise &#x3D; PROMISES.remove(msg.getSequenceId());&#x2F;&#x2F;&lt;Object&gt; remove用过即弃！\n        if (promise !&#x3D; null) &#123;\n            Object returnValue &#x3D; msg.getReturnValue();\n            Exception exceptionValue &#x3D; msg.getExceptionValue();\n            if(exceptionValue !&#x3D; null) &#123;\n                promise.setFailure(exceptionValue);&#x2F;&#x2F;&lt;?&gt;只能get，不能set 例外：set(null)\n            &#125; else &#123;\n                promise.setSuccess(returnValue);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>&#x3D;&#x3D;&lt;?&gt;泛型通配符：只能get取，不能set设置！！！应改为<Object>，不过set(null)是例外&#x3D;&#x3D;</p>\n<h4 id=\"Client端-异常调用\"><a href=\"#Client端-异常调用\" class=\"headerlink\" title=\"Client端-异常调用\"></a>Client端-异常调用</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.server.service;\n\npublic class HelloServiceImpl implements HelloService &#123;\n    @Override\n    public String sayHello(String msg) &#123;\n        int i &#x3D; 1 &#x2F; 0;&#x2F;&#x2F;\n        return &quot;你好, &quot; + msg;\n    &#125;\n&#125;</code></pre>\n\n<p>RpcClientManager：报错 报错帧太长了【冗余信息过多】</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505183238887.png\" alt=\"image-20220505183238887\"></p>\n<p>RpcServer</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">java.lang.reflect.InvocationTargetException\n\tat cn.itcast.server.handler.RpcRequestMessageHandler.channelRead0(RpcRequestMessageHandler.java:27)\n\t...\n\tCaused by: java.lang.ArithmeticException: &#x2F; by zero\n\tat cn.itcast.server.service.HelloServiceImpl.sayHello(HelloServiceImpl.java:6)\n\t\n\t\n改RpcRequestMessageHandler:\n\t            Object invoke &#x3D; method.invoke(service, message.getParameterValue());\n            response.setReturnValue(invoke);&#x2F;&#x2F;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            &#x2F;&#x2F;response.setExceptionValue(e);\n            String msg &#x3D; e.getCause().getMessage();&#x2F;&#x2F;\n            response.setExceptionValue(new Exception(&quot;远程调用出错:&quot; + msg));\n        &#125;</code></pre>\n\n<p>RpcClientManager:</p>\n<p>Exception in thread “main” java.lang.RuntimeException: java.lang.Exception: 远程调用出错:&#x2F; by zero</p>\n<h2 id=\"2-源码分析-侧重netty执行流程\"><a href=\"#2-源码分析-侧重netty执行流程\" class=\"headerlink\" title=\"2. 源码分析 [侧重netty执行流程]\"></a>2. 源码分析 [侧重netty执行流程]</h2><h3 id=\"2-1-启动剖析\"><a href=\"#2-1-启动剖析\" class=\"headerlink\" title=\"2.1 启动剖析\"></a>2.1 启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector &#x3D; Selector.open(); \n\n&#x2F;&#x2F;2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment &#x3D; new NioServerSocketChannel();\n\n&#x2F;&#x2F;3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n&#x2F;&#x2F;4 启动 nio boss 线程执行接下来的操作\n\n&#x2F;&#x2F;5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey &#x3D; serverSocketChannel.register(selector, 0, attachment);\n\n&#x2F;&#x2F;6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor\n\n&#x2F;&#x2F;7 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n&#x2F;&#x2F;8 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);</code></pre>\n\n\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505190005899.png\" alt=\"image-20220505190005899\"></p>\n<p>test下source：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestSourceServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())&#x2F;&#x2F;selector：监听事件、单th执行器：事件处理&amp;执行异步(定时)任务\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) &#123;\n                        ch.pipeline().addLast(new LoggingHandler());\n                    &#125;\n                &#125;).bind(8080);&#x2F;&#x2F;打断点\n    &#125;\n&#125;\n</code></pre>\n\n<p>debug</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505202631876.png\" alt=\"image-20220505202631876\"></p>\n<p>【init：ssc.open(); |  register: selectionKey &#x3D; ssc.register(selector,0,nettySsc)；| dobind：8080】</p>\n<p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p>\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private ChannelFuture doBind(final SocketAddress localAddress) &#123;\n\t&#x2F;&#x2F; 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码\n    final ChannelFuture regFuture &#x3D; initAndRegister();\n    final Channel channel &#x3D; regFuture.channel();\n    if (regFuture.cause() !&#x3D; null) &#123;\n        return regFuture;\n    &#125;\n\n    &#x2F;&#x2F; 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分\n    &#x2F;&#x2F; 2.1 如果已经完成\n    if (regFuture.isDone()) &#123;\n        ChannelPromise promise &#x3D; channel.newPromise();\n        &#x2F;&#x2F; 3.1 立刻调用 doBind0\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    &#125; \n    &#x2F;&#x2F; 2.2 还没有完成\n    else &#123;\n        final PendingRegistrationPromise promise &#x3D; new PendingRegistrationPromise(channel);\n        &#x2F;&#x2F; 3.2 回调 doBind0\n        regFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                Throwable cause &#x3D; future.cause();\n                if (cause !&#x3D; null) &#123;\n                    &#x2F;&#x2F; 处理异常...\n                    promise.setFailure(cause);\n                &#125; else &#123;\n                    promise.registered();\n\t\t\t\t\t&#x2F;&#x2F; 3. 由注册线程去执行 doBind0\n                    doBind0(regFuture, channel, localAddress, promise);\n                &#125;\n            &#125;\n        &#125;);\n        return promise;\n    &#125;\n&#125;</code></pre>\n\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final ChannelFuture initAndRegister() &#123;\n    Channel channel &#x3D; null;\n    try &#123;\n        &#x2F;&#x2F;constructor:搜NioServerSocketChannel()-&gt; this(newSocket(DEFAULT_SELECTOR_PROVIDER));-&gt; return provider.openServerSocketChannel();&lt;-原生ServerSocketChannel.open()\n        channel &#x3D; channelFactory.newChannel();\n        &#x2F;&#x2F; 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer\n        init(channel);\n    &#125; catch (Throwable t) &#123;\n        &#x2F;&#x2F; 处理异常...\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    &#125;\n\n    &#x2F;&#x2F; 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上\n    ChannelFuture regFuture &#x3D; config().group().register(channel);\n    if (regFuture.cause() !&#x3D; null) &#123;\n        &#x2F;&#x2F; 处理异常...\n    &#125;\n    return regFuture;\n&#125;</code></pre>\n\n<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 这里 channel 实际上是 NioServerSocketChannel\nvoid init(Channel channel) throws Exception &#123;\n    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options &#x3D; options0();\n    synchronized (options) &#123;\n        setChannelOptions(channel, options, logger);\n    &#125;\n\n    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs &#x3D; attrs0();\n    synchronized (attrs) &#123;\n        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;\n            @SuppressWarnings(&quot;unchecked&quot;)\n            AttributeKey&lt;Object&gt; key &#x3D; (AttributeKey&lt;Object&gt;) e.getKey();\n            channel.attr(key).set(e.getValue());\n        &#125;\n    &#125;\n\n    ChannelPipeline p &#x3D; channel.pipeline();\n\n    final EventLoopGroup currentChildGroup &#x3D; childGroup;\n    final ChannelHandler currentChildHandler &#x3D; childHandler;\n    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;\n    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;\n    synchronized (childOptions) &#123;\n        currentChildOptions &#x3D; childOptions.entrySet().toArray(newOptionArray(0));\n    &#125;\n    synchronized (childAttrs) &#123;\n        currentChildAttrs &#x3D; childAttrs.entrySet().toArray(newAttrArray(0));\n    &#125;\n\t\n    &#x2F;&#x2F; 为 NioServerSocketChannel 添加初始化器\n    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        public void initChannel(final Channel ch) throws Exception &#123;&#x2F;&#x2F;1.2.2:register后真正调用\n            final ChannelPipeline pipeline &#x3D; ch.pipeline();\n            ChannelHandler handler &#x3D; config.handler();\n            if (handler !&#x3D; null) &#123;\n                pipeline.addLast(handler);\n            &#125;\n\n            &#x2F;&#x2F; 初始化器的职责是将 ServerBootstrapAcceptor handler(在accept事件发生后建立连接) 加入至 NioServerSocketChannel\n            ch.eventLoop().execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                &#125;\n            &#125;);\n        &#125;\n    &#125;);\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505205144375.png\" alt=\"image-20220505205144375\"></p>\n<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    &#x2F;&#x2F; 一些检查，略...\n\n    AbstractChannel.this.eventLoop &#x3D; eventLoop;\n\n    if (eventLoop.inEventLoop()) &#123;&#x2F;&#x2F;是main不是nioTH，走else！\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            &#x2F;&#x2F; 首次执行 execute 方法时，会启动 nio 线程（懒加载~），之后注册等操作在 nio 线程上执行\n            &#x2F;&#x2F; 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程\n            &#x2F;&#x2F; 这行代码完成的事实是 main -&gt; nio boss 线程的切换\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    register0(promise);&#x2F;&#x2F;\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n            &#x2F;&#x2F; 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void register0(ChannelPromise promise) &#123;\n    try &#123;\n        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;\n            return;\n        &#125;\n        boolean firstRegistration &#x3D; neverRegistered;\n        &#x2F;&#x2F; 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel\n        doRegister();&#x2F;&#x2F;selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n        neverRegistered &#x3D; false;\n        registered &#x3D; true;\n\n        &#x2F;&#x2F; 1.2.2 [真正调用]执行 NioServerSocketChannel 初始化器的 [initChannel]\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        &#x2F;&#x2F; 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0\n        safeSetSuccess(promise);&#x2F;&#x2F;向【同一个】promise里填结果！\n        pipeline.fireChannelRegistered();\n        \n        &#x2F;&#x2F; 对应 server socket channel 还未绑定，isActive 为 false\n        if (isActive()) &#123;\n            if (firstRegistration) &#123;\n                pipeline.fireChannelActive();\n            &#125; else if (config().isAutoRead()) &#123;\n                beginRead();\n            &#125;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        &#x2F;&#x2F; Close the channel directly to avoid FD leak.\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505210646539.png\" alt=\"image-20220505210646539\"></p>\n<p>&#x2F;&#x2F; 初始化器的职责是将 ServerBootstrapAcceptor handler(在accept事件发生后建立连接) 加入至 NioServerSocketChannel</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505211236724.png\" alt=\"image-20220505211236724\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505212344302.png\" alt=\"image-20220505212344302\"></p>\n<p>断点右键All、F9： Mark object：regFuture@1837</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505212607163.png\" alt=\"image-20220505212607163\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505213040038.png\" alt=\"image-20220505213040038\"></p>\n<p>F9：operationComplete内 doBind0</p>\n<p>。。。</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505214038700.png\" alt=\"image-20220505214038700\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505213952627.png\" alt=\"image-20220505213952627\"></p>\n<p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;\n    if (initMap.add(ctx)) &#123; &#x2F;&#x2F; Guard against re-entrance.\n        try &#123;\n            &#x2F;&#x2F; 1.2.2.1 执行初始化\n            initChannel((C) ctx.channel());\n        &#125; catch (Throwable cause) &#123;\n            exceptionCaught(ctx, cause);\n        &#125; finally &#123;\n            &#x2F;&#x2F; 1.2.2.2 移除初始化器\n            ChannelPipeline pipeline &#x3D; ctx.pipeline();\n            if (pipeline.context(this) !&#x3D; null) &#123;\n                pipeline.remove(this);\n            &#125;\n        &#125;\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n\n\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 3.1 或 3.2 执行 doBind0\nprivate static void doBind0(\n        final ChannelFuture regFuture, final Channel channel,\n        final SocketAddress localAddress, final ChannelPromise promise) &#123;\n\n    channel.eventLoop().execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            if (regFuture.isSuccess()) &#123;\n                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n            &#125; else &#123;\n                promise.setFailure(regFuture.cause());\n            &#125;\n        &#125;\n    &#125;);\n&#125;</code></pre>\n\n<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123;\n    assertEventLoop();\n\n    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;\n        return;\n    &#125;\n\n    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;\n        localAddress instanceof InetSocketAddress &amp;&amp;\n        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;\n        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;\n        &#x2F;&#x2F; 记录日志...\n    &#125;\n\n    boolean wasActive &#x3D; isActive();\n    try &#123;\n        &#x2F;&#x2F; 3.3 执行端口绑定\n        doBind(localAddress);\n    &#125; catch (Throwable t) &#123;\n        safeSetFailure(promise, t);\n        closeIfClosed();\n        return;\n    &#125;\n\n    if (!wasActive &amp;&amp; isActive()) &#123;\n        invokeLater(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                &#x2F;&#x2F; 3.4 触发 active 事件\n                pipeline.fireChannelActive();&#x2F;&#x2F;[head]-&gt;Acceptor-&gt;tail\n            &#125;\n        &#125;);\n    &#125;\n\n    safeSetSuccess(promise);\n&#125;</code></pre>\n\n<p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doBind(SocketAddress localAddress) throws Exception &#123;\n    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;\n        javaChannel().bind(localAddress, config.getBacklog());&#x2F;&#x2F;\n    &#125; else &#123;\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>\n<p>打断点！F9</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void channelActive(ChannelHandlerContext ctx) &#123;\n    ctx.fireChannelActive();\n\t&#x2F;&#x2F; 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)\n    readIfIsAutoRead();&#x2F;&#x2F;【selectionKey.interestOps(SelectionKey.OP_ACCEPT&#x3D;1&lt;&lt;&lt;4&#x3D;16)】\n&#125;</code></pre>\n\n<p>F7。。。</p>\n<p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doBeginRead() throws Exception &#123;\n    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey &#x3D; this.selectionKey;\n    if (!selectionKey.isValid()) &#123;\n        return;\n    &#125;\n\n    readPending &#x3D; true;\n\n    final int interestOps &#x3D; selectionKey.interestOps();\n    &#x2F;&#x2F; readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件\n    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;\n        selectionKey.interestOps(interestOps | readInterestOp);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505215312463.png\" alt=\"image-20220505215312463\"></p>\n<h3 id=\"2-2-NioEventLoop-剖析-重量级-900-lines\"><a href=\"#2-2-NioEventLoop-剖析-重量级-900-lines\" class=\"headerlink\" title=\"2.2 NioEventLoop 剖析[重量级 900+lines]\"></a>2.2 NioEventLoop 剖析[重量级 900+lines]</h3><p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220505215603229.png\" alt=\"image-20220505215603229\"></p>\n<p>本类selector、祖父类、曾祖父类scheduledTaskQueue</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506161150036.png\" alt=\"image-20220506161150036\"></p>\n<p>构造里创建selector：final SelectorTuple selectorTuple &#x3D; openSelector();</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506161600716.png\" alt=\"image-20220506161600716\"></p>\n<p>7.SelectedKeys优化：</p>\n<p>原生unwrappedSelector中的SelectionKeys集合底层基于HashSet（Hash表）拉链法遍历效率不高，仍保留。</p>\n<p>换为Selector，其中的SelectionKeys底层基于数组，遍历效率高！遍历key时用！！！</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506162616596.png\" alt=\"image-20220506162616596\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506162759185.png\" alt=\"image-20220506162759185\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package cn.itcast.source;\n\nimport io.netty.channel.EventLoop;\nimport io.netty.channel.nio.NioEventLoopGroup;\n\npublic class TestEventLoop &#123;\n    public static void main(String[] args) &#123;\n        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();\n        eventLoop.execute(()-&gt;&#123;&#x2F;&#x2F;断点 debug\n            System.out.println(&quot;hello&quot;);\n        &#125;);\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p>\n<p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void execute(Runnable task) &#123;\n    if (task &#x3D;&#x3D; null) &#123;\n        throw new NullPointerException(&quot;task&quot;);\n    &#125;\n\n    boolean inEventLoop &#x3D; inEventLoop();&#x2F;&#x2F;\n    &#x2F;&#x2F; 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列\n    addTask(task);\n    if (!inEventLoop) &#123;\n        &#x2F;&#x2F; inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread\n        startThread();\n        if (isShutdown()) &#123;\n            &#x2F;&#x2F; 如果已经 shutdown，做拒绝逻辑，代码略...\n        &#125;\n    &#125;\n\n    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;\n        &#x2F;&#x2F; 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程\n        wakeup(inEventLoop);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506163236905.png\" alt=\"image-20220506163236905\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506164224177.png\" alt=\"image-20220506164224177\"></p>\n<p>private volatile int state &#x3D; ST_NOT_STARTED;</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506164251139.png\" alt=\"image-20220506164251139\"></p>\n<p>doStartThread()的run()死循环里：</p>\n<p>select()：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int selectedKeys &#x3D; selector.select(timeoutMillis);&#x2F;&#x2F;有超时的阻塞，一旦有任务就唤醒wakeup()</code></pre>\n\n<p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void wakeup(boolean inEventLoop) &#123;\n    if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;&#x2F;&#x2F;\n        selector.wakeup();&#x2F;&#x2F;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final AtomicBoolean wakenUp &#x3D; new AtomicBoolean();</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506170128464.png\" alt=\"image-20220506170128464\"></p>\n<p>没事件没任务，应该进select阻塞一会儿，别空转！</p>\n<p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void doStartThread() &#123;\n    assert thread &#x3D;&#x3D; null;\n    executor.execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            &#x2F;&#x2F; 将线程池的当前线程保存在成员变量中，以便后续使用\n            thread &#x3D; Thread.currentThread();\n            if (interrupted) &#123;\n                thread.interrupt();\n            &#125;\n\n            boolean success &#x3D; false;\n            updateLastExecutionTime();\n            try &#123;\n                &#x2F;&#x2F; 调用外部类 SingleThreadEventExecutor 的 [run 方法，进入死循环]，run 方法见下\n                SingleThreadEventExecutor.this.run();\n                success &#x3D; true;\n            &#125; catch (Throwable t) &#123;\n                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);\n            &#125; finally &#123;\n\t\t\t\t&#x2F;&#x2F; 清理工作，代码略...\n            &#125;\n        &#125;\n    &#125;);\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506184156309.png\" alt=\"image-20220506184156309\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506184246479.png\" alt=\"image-20220506184246479\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506171019252.png\" alt=\"image-20220506171019252\"></p>\n<p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void run() &#123;\n    for (;;) &#123;\n        try &#123;\n            try &#123;\n                &#x2F;&#x2F; calculateStrategy 的逻辑如下：\n                &#x2F;&#x2F; 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch\n                &#x2F;&#x2F; 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;\n                    case SelectStrategy.CONTINUE:\n                        continue;\n\n                    case SelectStrategy.BUSY_WAIT:\n\n                    case SelectStrategy.SELECT:\n                        &#x2F;&#x2F; 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒\n                        &#x2F;&#x2F; 进行 select 阻塞，并设置唤醒状态为 false\n                        boolean oldWakenUp &#x3D; wakenUp.getAndSet(false);\n                        \n                        &#x2F;&#x2F; 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup\n                        &#x2F;&#x2F; 下面的 select 方法不会阻塞\n                        &#x2F;&#x2F; 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?\n                        &#x2F;&#x2F; 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时\n                        &#x2F;&#x2F; 才能执行，让 select 方法 无谓阻塞？\n                        select(oldWakenUp);\n\n                        if (wakenUp.get()) &#123;\n                            selector.wakeup();\n                        &#125;\n                    default:\n                &#125;\n            &#125; catch (IOException e) &#123;\n                rebuildSelector0();\n                handleLoopException(e);\n                continue;\n            &#125;\n\n            cancelledKeys &#x3D; 0;\n            needsToSelectAgain &#x3D; false;\n            &#x2F;&#x2F; ioRatio 默认是 50\n            final int ioRatio &#x3D; this.ioRatio;\n            if (ioRatio &#x3D;&#x3D; 100) &#123;\n                try &#123;\n                    processSelectedKeys();&#x2F;&#x2F;处理io事件！！！7.keys[i] 8.区分事件类型 unsafe.read()!\n                &#125; finally &#123;\n                    &#x2F;&#x2F; 【ioRatio 为 100】 时，【总是运行完所有！】【非 IO 任务】\n                    runAllTasks();&#x2F;&#x2F;并不好！finally，不超时！\n                &#125;\n            &#125; else &#123;                \n                final long ioStartTime &#x3D; System.nanoTime();\n                try &#123;\n                    processSelectedKeys();&#x2F;&#x2F;\n                &#125; finally &#123;\n                    &#x2F;&#x2F; 记录 【io 事件处理】耗时\n                    final long ioTime &#x3D; System.nanoTime() - ioStartTime;\n                    &#x2F;&#x2F; 运行非 IO 任务，一旦超时会退出 runAllTasks,下一次循环 【普通任务！】\n                    &#x2F;&#x2F; io时间*(非io)&#x2F;(io)&#x3D;非io任务超时时间:8s*20&#x2F;80&#x3D;2s\n                    runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);\n                &#125;\n            &#125;\n        &#125; catch (Throwable t) &#123;\n            handleLoopException(t);\n        &#125;\n        try &#123;\n            if (isShuttingDown()) &#123;\n                closeAll();\n                if (confirmShutdown()) &#123;\n                    return;\n                &#125;\n            &#125;\n        &#125; catch (Throwable t) &#123;\n            handleLoopException(t);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506193501592.png\" alt=\"image-20220506193501592\"></p>\n<h4 id=\"⚠️-注意\"><a href=\"#⚠️-注意\" class=\"headerlink\" title=\"⚠️ 注意\"></a>⚠️ 注意</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p>\n<ul>\n<li>由<strong>非 EventLoop 线程调</strong>用，会**[唤醒当前]在执行 select 阻塞的 EventLoop 线程**</li>\n<li>由 <strong>EventLoop 自己调</strong>用，会<strong>本次的 wakeup 会[取消下一次的 select] 操作</strong></li>\n</ul></blockquote>\n<p>参考下图</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/0032.png\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506190850519.png\" alt=\"image-20220506190850519\"></p>\n<p><code>io.netty.channel.nio.NioEventLoop#select</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void select(boolean oldWakenUp) throws IOException &#123;\n    Selector selector &#x3D; this.selector;\n    try &#123;\n        int selectCnt &#x3D; 0;\n        long currentTimeNanos &#x3D; System.nanoTime();\n        &#x2F;&#x2F; 计算等待时间\n        &#x2F;&#x2F; * 没有 scheduledTask，超时时间为 1s\n        &#x2F;&#x2F; * 有 scheduledTask，超时时间为 &#96;下一个定时任务执行时间 - 当前时间&#96;\n        long selectDeadLineNanos &#x3D; currentTimeNanos + delayNanos(currentTimeNanos);\n\n        for (;;) &#123;\n            long timeoutMillis &#x3D; (selectDeadLineNanos - currentTimeNanos + 500000L) &#x2F; 1000000L;\n            &#x2F;&#x2F; 如果超时，退出循环\n            if (timeoutMillis &lt;&#x3D; 0) &#123;\n                if (selectCnt &#x3D;&#x3D; 0) &#123;\n                    selector.selectNow();\n                    selectCnt &#x3D; 1;\n                &#125;\n                break;\n            &#125;\n\n            &#x2F;&#x2F; 如果期间又有 task: 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行\n            &#x2F;&#x2F; wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup\n            if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;\n                selector.selectNow();\n                selectCnt &#x3D; 1;\n                break;\n            &#125;\n\n            &#x2F;&#x2F; select 有限时阻塞\n            &#x2F;&#x2F; 注意【 (JDK)nio 有 bug】，当 bug 出现时，【select 方法即使没有事件发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%】\n            int selectedKeys &#x3D; selector.select(timeoutMillis);\n            &#x2F;&#x2F; 计数加 1\n            selectCnt ++;\n\n            &#x2F;&#x2F; 醒来后，如果【有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务：退出循环】\n            if (selectedKeys !&#x3D; 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;\n                break;\n            &#125;\n            if (Thread.interrupted()) &#123;\n               \t&#x2F;&#x2F; [线程被打断]，退出循环\n                &#x2F;&#x2F; 记录日志\n                selectCnt &#x3D; 1;\n                break;\n            &#125;\n\n            long time &#x3D; System.nanoTime();\n            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;&#x3D; currentTimeNanos) &#123;\n                &#x2F;&#x2F; 如果[超时]，[计数重置为 1，下次循环就会 break]\n                selectCnt &#x3D; 1;\n            &#125; \n            &#x2F;&#x2F; 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512\n            &#x2F;&#x2F; 这是为了解决 【nio 空轮询 bug】(不可修复，以新换旧)\n            else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;\n                    selectCnt &gt;&#x3D; SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;&#x2F;&#x2F;&gt;&#x3D;512\n                &#x2F;&#x2F; 重建 selector,替换旧的selector(selectionKey等信息复制过去)\n                selector &#x3D; selectRebuildSelector(selectCnt);\n                selectCnt &#x3D; 1;\n                break;\n            &#125;\n\n            currentTimeNanos &#x3D; time;\n        &#125;\n\n        if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;\n            &#x2F;&#x2F; 记录日志\n        &#125;\n    &#125; catch (CancelledKeyException e) &#123;\n        &#x2F;&#x2F; 记录日志\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506191120761.png\" alt=\"image-20220506191120761\"></p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506191602799.png\" alt=\"image-20220506191602799\"></p>\n<p>linux下jdk nio支持有bug。法2：完全重写selector的实现。。。</p>\n<p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void processSelectedKeys() &#123;\n    if (selectedKeys !&#x3D; null) &#123;\n        &#x2F;&#x2F; 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet \n        &#x2F;&#x2F; SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）\n        processSelectedKeysOptimized();&#x2F;&#x2F;\n    &#125; else &#123;\n        processSelectedKeysPlain(selector.selectedKeys());\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void processSelectedKeysOptimized() &#123;\n        for (int i &#x3D; 0; i &lt; selectedKeys.size; ++i) &#123;\n            final SelectionKey k &#x3D; selectedKeys.keys[i];\n            &#x2F;&#x2F; null out entry in the array to allow to have it GC&#39;ed once the Channel close\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363\n            selectedKeys.keys[i] &#x3D; null;&#x2F;&#x2F;\n\n            final Object a &#x3D; k.attachment();&#x2F;&#x2F;key关联的附件：NIO的channel (pipeline-handlers)\n\n            if (a instanceof AbstractNioChannel) &#123;\n                processSelectedKey(k, (AbstractNioChannel) a);&#x2F;&#x2F;！！！\n            &#125; else &#123;\n                @SuppressWarnings(&quot;unchecked&quot;)\n                NioTask&lt;SelectableChannel&gt; task &#x3D; (NioTask&lt;SelectableChannel&gt;) a;\n                processSelectedKey(k, task);\n            &#125;\n\n            if (needsToSelectAgain) &#123;\n                &#x2F;&#x2F; null out entries in the array to allow to have it GC&#39;ed once the Channel close\n                &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363\n                selectedKeys.reset(i + 1);\n\n                selectAgain();\n                i &#x3D; -1;\n            &#125;\n        &#125;\n    &#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506194541725.png\" alt=\"image-20220506194541725\"></p>\n<p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;\n    final AbstractNioChannel.NioUnsafe unsafe &#x3D; ch.unsafe();\n    &#x2F;&#x2F; 当 key 取消或关闭时会导致这个 key 无效\n    if (!k.isValid()) &#123;\n        &#x2F;&#x2F; 无效时处理...\n        return;\n    &#125;\n\n    try &#123;\n        int readyOps &#x3D; k.readyOps();&#x2F;&#x2F;\n        &#x2F;&#x2F; 连接事件\n        if ((readyOps &amp; SelectionKey.OP_CONNECT) !&#x3D; 0) &#123;\n            int ops &#x3D; k.interestOps();\n            ops &amp;&#x3D; ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        &#125;\n\n        &#x2F;&#x2F; 可写事件\n        if ((readyOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;\n            ch.unsafe().forceFlush();\n        &#125;\n\n        &#x2F;&#x2F; 可读或可接入事件\n        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\n            &#x2F;&#x2F; 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read\n            unsafe.read();&#x2F;&#x2F;【后两节:accept&#x2F;read】打断点，debug：TestSourceServer！！！\n        &#125;\n    &#125; catch (CancelledKeyException ignored) &#123;\n        unsafe.close(unsafe.voidPromise());\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"2-3-accept-剖析\"><a href=\"#2-3-accept-剖析\" class=\"headerlink\" title=\"2.3 accept 剖析\"></a>2.3 accept 剖析</h3><p>nio 中如下代码，在 netty 中的流程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;1 阻塞直到事件发生\nselector.select();\n\nIterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\nwhile (iter.hasNext()) &#123;    \n    &#x2F;&#x2F;2 拿到一个事件\n    SelectionKey key &#x3D; iter.next();\n    \n    &#x2F;&#x2F;3 如果是 accept 事件\n    if (key.isAcceptable()) &#123;\n        \n        &#x2F;&#x2F;4 执行 accept\n        SocketChannel channel &#x3D; serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        &#x2F;&#x2F;5 关注 read 事件\n        channel.register(selector, SelectionKey.OP_READ);\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506194824870.png\" alt=\"image-20220506194824870\"></p>\n<p>debug TestSourceServer, run TestBacklogClient：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;readyOps&#x3D;16：accept (&#x3D;1：read)\nif ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n    unsafe.read();&#x2F;&#x2F;456)\n&#125;</code></pre>\n\n<p>&#x3D;&#x3D;run to cursor:Alt+F9&#x3D;&#x3D;</p>\n<p>先来看可接入事件处理（accept）</p>\n<p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void read() &#123;\n    assert eventLoop().inEventLoop();\n    final ChannelConfig config &#x3D; config();\n    final ChannelPipeline pipeline &#x3D; pipeline();    \n    final RecvByteBufAllocator.Handle allocHandle &#x3D; unsafe().recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    boolean closed &#x3D; false;\n    Throwable exception &#x3D; null;\n    try &#123;\n        try &#123;\n            do &#123;\n\t\t\t\t&#x2F;&#x2F;4) doReadMessages 中执行了 accept 并[创建 NioSocketChannel 作为消息放入 readBuf]\n                &#x2F;&#x2F; readBuf 是一个 ArrayList 用来缓存消息\n                int localRead &#x3D; doReadMessages(readBuf);&#x2F;&#x2F;4)\n                if (localRead &#x3D;&#x3D; 0) &#123;\n                    break;\n                &#125;\n                if (localRead &lt; 0) &#123;\n                    closed &#x3D; true;\n                    break;\n                &#125;\n\t\t\t\t&#x2F;&#x2F; localRead 为 1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            &#125; while (allocHandle.continueReading());\n        &#125; catch (Throwable t) &#123;\n            exception &#x3D; t;\n        &#125;\n\n        int size &#x3D; readBuf.size();\n        for (int i &#x3D; 0; i &lt; size; i ++) &#123;\n            readPending &#x3D; false;\n            &#x2F;&#x2F; 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理\n            &#x2F;&#x2F; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\n            pipeline.fireChannelRead(readBuf.get(i));&#x2F;&#x2F;channelRead()+断点\n        &#125;\n        readBuf.clear();\n        allocHandle.readComplete();\n        pipeline.fireChannelReadComplete();\n\n        if (exception !&#x3D; null) &#123;\n            closed &#x3D; closeOnReadError(exception);\n\n            pipeline.fireExceptionCaught(exception);\n        &#125;\n\n        if (closed) &#123;\n            inputShutdown &#x3D; true;\n            if (isOpen()) &#123;\n                close(voidPromise());\n            &#125;\n        &#125;\n    &#125; finally &#123;\n        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;\n            removeReadOp();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;\n    &#x2F;&#x2F;4) -&gt;serverSocketChannel.accept();\n    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());\n    \n    try &#123;\n        if (ch !&#x3D; null) &#123;\n            buf.add(new NioSocketChannel(this, ch));&#x2F;&#x2F;设置非阻塞\n            return 1;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        ...</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506200712839.png\" alt=\"image-20220506200712839\"></p>\n<p>head-&gt;【ServerBootstrapAcceptor类】acceptor-&gt;tail</p>\n<p>channelRead()方法打断点：</p>\n<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n    &#x2F;&#x2F; 这时的 msg 是 NioSocketChannel\n    final Channel child &#x3D; (Channel) msg;\n\n    &#x2F;&#x2F; NioSocketChannel 添加  childHandler 即初始化器\n    child.pipeline().addLast(childHandler);\n\n    &#x2F;&#x2F; 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;\n        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());\n    &#125;\n\n    try &#123;\n        &#x2F;&#x2F; 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程\n        childGroup.register(child).addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                if (!future.isSuccess()) &#123;\n                    forceClose(child, future.cause());\n                &#125;\n            &#125;\n        &#125;);\n    &#125; catch (Throwable t) &#123;\n        forceClose(child, t);\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    &#x2F;&#x2F; 一些检查，略...\n\n    AbstractChannel.this.eventLoop &#x3D; eventLoop;\n\n    if (eventLoop.inEventLoop()) &#123;\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            &#x2F;&#x2F; 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    register0(promise);&#x2F;&#x2F;\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n            &#x2F;&#x2F; 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li>doReadMessages()</li>\n</ol>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506202850401.png\" alt=\"image-20220506202850401\"></p>\n<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void register0(ChannelPromise promise) &#123;\n    try &#123;\n        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;\n            return;\n        &#125;\n        boolean firstRegistration &#x3D; neverRegistered;\n        doRegister();&#x2F;&#x2F; 5) selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n        neverRegistered &#x3D; false;\n        registered &#x3D; true;\n\t\t\n        &#x2F;&#x2F; 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail\n        pipeline.invokeHandlerAddedIfNeeded();&#x2F;&#x2F;\n        &#x2F;&#x2F; 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) &#123;\n            if (firstRegistration) &#123;\n                &#x2F;&#x2F; 6) 触发 pipeline 上 active 事件，关注selectionKey的read事件\n                pipeline.fireChannelActive();&#x2F;&#x2F;\n            &#125; else if (config().isAutoRead()) &#123;\n                beginRead();\n            &#125;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506202410914.png\" alt=\"image-20220506202410914\"></p>\n<p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void channelActive(ChannelHandlerContext ctx) &#123;\n    ctx.fireChannelActive();\n\t&#x2F;&#x2F; 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();&#x2F;&#x2F;F7。。。\n&#125;</code></pre>\n\n<p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doBeginRead() throws Exception &#123;\n    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey &#x3D; this.selectionKey;\n    if (!selectionKey.isValid()) &#123;\n        return;\n    &#125;\n\n    readPending &#x3D; true;\n\t&#x2F;&#x2F; 这时候 interestOps 是 0\n    final int interestOps &#x3D; selectionKey.interestOps();\n    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 6) 关注 read 事件！\n        selectionKey.interestOps(interestOps | readInterestOp);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506204034188.png\" alt=\"image-20220506204034188\"></p>\n<h3 id=\"2-4-read-剖析\"><a href=\"#2-4-read-剖析\" class=\"headerlink\" title=\"2.4 read 剖析\"></a>2.4 read 剖析</h3><p>NioEventLoop下：unsafe.read()加断点</p>\n<p>F9两次：readOps&#x3D;16:accept事件，  &#x3D;1:read事件 </p>\n<p>F7进：</p>\n<p><img src=\"http://cache.itzy8.top/%E5%AD%A6Netty-%E9%BB%91%E9%A9%AC%E6%BB%A1%E5%93%A5/image-20220506210125483.png\" alt=\"image-20220506210125483\"></p>\n<p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意<strong>发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void read() &#123;\n    final ChannelConfig config &#x3D; config();\n    if (shouldBreakReadReady(config)) &#123;\n        clearReadPending();\n        return;\n    &#125;\n    final ChannelPipeline pipeline &#x3D; pipeline();\n    &#x2F;&#x2F; io.netty.allocator.type 决定 allocator 的实现：(非)池化\n    final ByteBufAllocator allocator &#x3D; config.getAllocator();\n    &#x2F;&#x2F; 用来分配 byteBuf，确定单次读取大小【io事件强制用deirectIOBuf】\n    final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf &#x3D; null;\n    boolean close &#x3D; false;\n    try &#123;\n        do &#123;\n            byteBuf &#x3D; allocHandle.allocate(allocator);\n            &#x2F;&#x2F; 读取\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));&#x2F;&#x2F;&quot;hello!&quot; widx&#x3D;0变6\n            if (allocHandle.lastBytesRead() &lt;&#x3D; 0) &#123;\n                byteBuf.release();\n                byteBuf &#x3D; null;\n                close &#x3D; allocHandle.lastBytesRead() &lt; 0;\n                if (close) &#123;\n                    readPending &#x3D; false;\n                &#125;\n                break;\n            &#125;\n\n            allocHandle.incMessagesRead(1);\n            readPending &#x3D; false;\n            &#x2F;&#x2F; 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler\n            pipeline.fireChannelRead(byteBuf);&#x2F;&#x2F;head、logging、tail\n            byteBuf &#x3D; null;\n        &#125; \n        &#x2F;&#x2F; 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        &#x2F;&#x2F; 触发 read complete 事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) &#123;\n            closeOnRead(pipeline);\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    &#125; finally &#123;\n        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;\n            removeReadOp();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) &#123;\n    return \n           &#x2F;&#x2F; 一般为 true\n           config.isAutoRead() &amp;&amp;\n           &#x2F;&#x2F; respectMaybeMoreData 默认为 true\n           &#x2F;&#x2F; maybeMoreDataSupplier 的逻辑是【如果预期读取字节与实际读取字节相等，返回 true】\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;\n           &#x2F;&#x2F; 小于最大次数，maxMessagePerRead 默认 16\n           totalMessages &lt; maxMessagePerRead &amp;&amp;\n           &#x2F;&#x2F; 实际读到了数据\n           totalBytesRead &gt; 0;\n&#125;</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","text":"黑马Netty：https://www.bilibili.com/video/BV1py4y1E7oA 学Netty，建议看黑马Netty教程。然后尚硅谷Netty课的Protobuf, DubboRPC等案例就可以了。 尚硅谷-韩顺平：https://www.bilibili....","link":"","photos":[],"count_time":{"symbolsCount":"317k","symbolsTime":"4:48"},"categories":[{"name":"Netty","slug":"Netty","count":1,"path":"api/categories/Netty.json"}],"tags":[{"name":"Netty","slug":"Netty","count":1,"path":"api/tags/Netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-NIO-%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">一. NIO 基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">1. 三大组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-Channel-amp-Buffer\"><span class=\"toc-text\">1.1 Channel &amp; Buffer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-Selector\"><span class=\"toc-text\">1.2 Selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">多线程版设计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%9A%A0%EF%B8%8F-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">⚠️ 多线程版缺点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">线程池版设计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%9A%A0%EF%B8%8F-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">⚠️ 线程池版缺点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#selector-%E7%89%88%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">selector 版设计</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-ByteBuffer\"><span class=\"toc-text\">2. ByteBuffer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-ByteBuffer-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF\"><span class=\"toc-text\">2.1  ByteBuffer 正确使用姿势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-ByteBuffer-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.2 ByteBuffer 结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">💡 调试工具类</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-ByteBuffer-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95-nio-c2\"><span class=\"toc-text\">2.3 ByteBuffer 常见方法-nio.c2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4TestByteBufferAllocate\"><span class=\"toc-text\">分配空间\tTestByteBufferAllocate</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%91-buffer-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AETestByteBufferReadWrite\"><span class=\"toc-text\">向 buffer 写入数据\tTestByteBufferReadWrite</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8E-buffer-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AETestByteBufferRead\"><span class=\"toc-text\">从 buffer 读取数据\tTestByteBufferRead</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mark-%E5%92%8C-reset\"><span class=\"toc-text\">mark 和 reset</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E-ByteBuffer-%E4%BA%92%E8%BD%ACTestByteBufferString\"><span class=\"toc-text\">字符串与 ByteBuffer 互转\tTestByteBufferString</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%9A%A0%EF%B8%8F-Buffer-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">⚠️ Buffer 的线程安全</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-Scattering-Reads\"><span class=\"toc-text\">2.4 Scattering Reads</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-Gathering-Writes\"><span class=\"toc-text\">2.5 Gathering Writes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-6-%E7%BB%83%E4%B9%A0TestByteBufferExam\"><span class=\"toc-text\">2.6 练习\tTestByteBufferExam</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">3. 文件编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-FileChannel\"><span class=\"toc-text\">3.1 FileChannel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%9A%A0%EF%B8%8F-FileChannel-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">⚠️ FileChannel 工作模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">获取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">读取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%85%A5\"><span class=\"toc-text\">写入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">关闭</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">位置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">大小</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E5%88%B6%E5%86%99%E5%85%A5\"><span class=\"toc-text\">强制写入</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E4%B8%A4%E4%B8%AA-Channel-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE-nio-c3\"><span class=\"toc-text\">3.2 两个 Channel 传输数据-nio.c3</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-Path\"><span class=\"toc-text\">3.3 Path</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-Files\"><span class=\"toc-text\">3.4 Files</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TestFilesWalkFileTree\"><span class=\"toc-text\">TestFilesWalkFileTree</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%9A%A0%EF%B8%8F-%E5%88%A0%E9%99%A4%E5%BE%88%E5%8D%B1%E9%99%A9\"><span class=\"toc-text\">⚠️ 删除很危险</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-nio-c4\"><span class=\"toc-text\">4. 网络编程-nio.c4</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E9%9D%9E%E9%98%BB%E5%A1%9E-vs-%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">4.1 非阻塞 vs 阻塞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">1、阻塞</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">2、非阻塞</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%98%EF%BC%9Anio-c4%EF%BC%81%EF%BC%81%EF%BC%81\"><span class=\"toc-text\">实战：nio.c4！！！</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E3%80%90%E5%88%86%E6%AD%A5%E8%AE%B2%E8%A7%A3%E3%80%914-2-Selector\"><span class=\"toc-text\">【分步讲解】4.2 Selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">3、多路复用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%91%E5%AE%9A-Channel-%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">绑定 Channel 事件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%91%E5%90%AC-Channel-%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">监听 Channel 事件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-select-%E4%BD%95%E6%97%B6%E4%B8%8D%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">💡 select 何时不阻塞</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E5%A4%84%E7%90%86-accept-%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">4.3 处理 accept 事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%E8%83%BD%E5%90%A6%E4%B8%8D%E5%A4%84%E7%90%86\"><span class=\"toc-text\">💡 事件发生后能否不处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-%E5%A4%84%E7%90%86-read-%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">4.4 处理 read 事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E4%B8%BA%E4%BD%95%E8%A6%81-iter-remove\"><span class=\"toc-text\">💡 为何要 iter.remove()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-cancel-%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">💡 cancel 的作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%9A%A0%EF%B8%8F-%E4%B8%8D%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">⚠️  不处理边界的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E8%BE%B9%E7%95%8C%EF%BC%81%EF%BC%81%EF%BC%81\"><span class=\"toc-text\">处理消息的边界！！！</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ByteBuffer-%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D\"><span class=\"toc-text\">ByteBuffer 大小分配</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-%E5%A4%84%E7%90%86-write-%E4%BA%8B%E4%BB%B6WriteServer-x2F-Client\"><span class=\"toc-text\">4.5 处理 write 事件\tWriteServer&#x2F;Client</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E5%86%99%E5%AE%8C%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">一次无法写完例子</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-write-%E4%B8%BA%E4%BD%95%E8%A6%81%E5%8F%96%E6%B6%88\"><span class=\"toc-text\">💡 write 为何要取消</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5\"><span class=\"toc-text\">4.6 更进一步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">💡 利用多线程优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0-cpu-%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">💡 如何拿到 cpu 个数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-UDP\"><span class=\"toc-text\">4.7 UDP</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-NIO-vs-BIO\"><span class=\"toc-text\">5. NIO vs BIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-stream-vs-channel\"><span class=\"toc-text\">5.1 stream vs channel</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-IO-%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">5.2 IO 模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%94%96-%E5%8F%82%E8%80%83\"><span class=\"toc-text\">🔖 参考</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">5.3 零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">传统 IO 问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#NIO-%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">NIO 优化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-AIO\"><span class=\"toc-text\">5.3 AIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6-AIO\"><span class=\"toc-text\">文件 AIO</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">💡 守护线程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C-AIO\"><span class=\"toc-text\">网络 AIO</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-Netty-%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">二. Netty 入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. 概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-Netty-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.1 Netty 是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-Netty-%E7%9A%84%E4%BD%9C%E8%80%85\"><span class=\"toc-text\">1.2 Netty 的作者</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-Netty-%E7%9A%84%E5%9C%B0%E4%BD%8D\"><span class=\"toc-text\">1.3 Netty 的地位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-Netty-%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">1.4 Netty 的优势</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Hello-World\"><span class=\"toc-text\">2. Hello World</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">2.1 目标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF\"><span class=\"toc-text\">2.2 服务器端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">2.3 客户端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86\"><span class=\"toc-text\">2.4 流程梳理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E6%8F%90%E7%A4%BA\"><span class=\"toc-text\">💡 提示</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3. 组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-EventLoop-x3D-%E5%8C%85%E8%A3%85%E7%9A%84Selector\"><span class=\"toc-text\">3.1 EventLoop&#x3D;包装的Selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA-NioEventLoop-%E5%A4%84%E7%90%86-io-%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">演示 NioEventLoop 处理 io 事件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-handler-%E6%89%A7%E8%A1%8C%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8D%A2%E4%BA%BA%EF%BC%9F\"><span class=\"toc-text\">💡 handler 执行中如何换人？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA-NioEventLoop-%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">演示 NioEventLoop 处理普通任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA-NioEventLoop-%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">演示 NioEventLoop 处理定时任务</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-Channel%EF%BC%81%EF%BC%81%EF%BC%81\"><span class=\"toc-text\">3.2 Channel！！！</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ChannelFuture\"><span class=\"toc-text\">ChannelFuture</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x3D-x3D-%EF%BC%81%EF%BC%81%EF%BC%81%E9%99%A4%E4%BA%86%E7%94%A8-sync-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%AE%A9connect%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%A4%96%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A-x3D-x3D\"><span class=\"toc-text\">&#x3D;&#x3D;！！！除了用 sync 方法可以让connect异步操作同步以外，还可以使用回调的方式：&#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CloseFuture\"><span class=\"toc-text\">CloseFuture</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">💡 优雅关闭</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E5%BC%82%E6%AD%A5%E6%8F%90%E5%8D%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%81%EF%BC%81%EF%BC%81\"><span class=\"toc-text\">💡 异步提升的是什么！！！</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x3D-x3D-%E3%80%90%E5%BC%82%E6%AD%A5-%E5%A4%9A%E6%A0%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%81-%E4%BB%BB%E5%8A%A1%E6%8B%86%E5%88%86%EF%BC%81-%E6%B5%81%E6%B0%B4%E7%BA%BFpipeline%EF%BC%81-%E5%93%8D%E5%BA%94%E5%8F%98%E6%85%A2-%E5%8D%8F%E4%BD%9C%E6%97%B6%E9%97%B4-%EF%BC%8C%E5%90%9E%E5%90%90%E5%8F%98%E9%AB%98%EF%BC%81%E3%80%91-x3D-x3D\"><span class=\"toc-text\">&#x3D;&#x3D;【异步+多核多线程！ 任务拆分！ 流水线pipeline！ 响应变慢(+协作时间)，吞吐变高！】&#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-Future-amp-Promise\"><span class=\"toc-text\">3.3 Future &amp; Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B1\"><span class=\"toc-text\">例1</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B2\"><span class=\"toc-text\">例2</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B3\"><span class=\"toc-text\">例3</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B4\"><span class=\"toc-text\">例4</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B5\"><span class=\"toc-text\">例5</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B6\"><span class=\"toc-text\">例6</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-Handler-amp-Pipeline\"><span class=\"toc-text\">3.4 Handler &amp; Pipeline</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x3D-x3D-in-%E5%8C%85%E8%A3%85-%E8%BD%AC%E6%8D%A2-channel-tail%E5%80%92-out-%E5%A4%84%E7%90%86-ctx-x2F-super-cur%E5%80%92-x3D-x3D\"><span class=\"toc-text\">&#x3D;&#x3D;in(包装 转换)-channel(tail倒)\tout(处理)-ctx&#x2F;super(cur倒)&#x3D;&#x3D;</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-ByteBuf\"><span class=\"toc-text\">3.5 ByteBuf</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">1）创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-vs-%E5%A0%86%E5%86%85%E5%AD%98\"><span class=\"toc-text\">2）直接内存 vs 堆内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E6%B1%A0%E5%8C%96-vs-%E9%9D%9E%E6%B1%A0%E5%8C%96\"><span class=\"toc-text\">3）池化 vs 非池化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E7%BB%84%E6%88%90\"><span class=\"toc-text\">4）组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%EF%BC%89%E5%86%99%E5%85%A5\"><span class=\"toc-text\">5）写入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%EF%BC%89%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">6）扩容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%EF%BC%89%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">7）读取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8%EF%BC%89retain-amp-release\"><span class=\"toc-text\">8）retain &amp; release</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9%EF%BC%89slice\"><span class=\"toc-text\">9）slice</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10%EF%BC%89duplicate-%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">10）duplicate 浅拷贝</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11%EF%BC%89copy%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">11）copy深拷贝</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12%EF%BC%89CompositeByteBuf\"><span class=\"toc-text\">12）CompositeByteBuf</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#13%EF%BC%89Unpooled\"><span class=\"toc-text\">13）Unpooled</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-ByteBuf-%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">💡 ByteBuf 优势</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">4. 双向通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">4.1 练习</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E8%AF%BB%E5%92%8C%E5%86%99%E7%9A%84%E8%AF%AF%E8%A7%A3\"><span class=\"toc-text\">💡 读和写的误解</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89-Netty-%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">三. Netty 进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%B2%98%E5%8C%85%E4%B8%8E%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">1. 粘包与半包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">1.1 粘包现象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">1.2 半包现象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E7%8E%B0%E8%B1%A1%E5%88%86%E6%9E%90\"><span class=\"toc-text\">1.3 现象分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">1.4 解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%951%EF%BC%8C%E7%9F%AD%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">方法1，短链接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%952%EF%BC%8C%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6-FixedLengthFrameDecoder\"><span class=\"toc-text\">方法2，固定长度 FixedLengthFrameDecoder</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%953%EF%BC%8C%E5%9B%BA%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6-LineBasedFrameDecoder\"><span class=\"toc-text\">方法3，固定分隔符 LineBasedFrameDecoder</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%954%EF%BC%8C%E9%A2%84%E8%AE%BE%E9%95%BF%E5%BA%A6-LengthFieldBasedFrameDecoder-max-len%E5%89%8D%E4%B8%AD%E5%90%8E-S%E6%94%B6%E5%8E%BB%E5%B0%BE\"><span class=\"toc-text\">方法4，预设长度 LengthFieldBasedFrameDecoder(max,len前中后,S收去尾)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">2. 协议设计与解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8D%8F%E8%AE%AE%EF%BC%9F\"><span class=\"toc-text\">2.1 为什么需要协议？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-redis-%E5%8D%8F%E8%AE%AE%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">2.2 redis 协议举例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-http-%E5%8D%8F%E8%AE%AE%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">2.3 http 协议举例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x3D-x3D-2-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%B4%A0-x3D-x3D-%E3%80%90%E7%B4%A7%E5%87%91%EF%BC%8C%E9%AB%98%E6%95%88%EF%BC%8C%E7%9C%81%E5%B8%A6%E5%AE%BD%E3%80%91\"><span class=\"toc-text\">&#x3D;&#x3D;2.4 自定义协议要素&#x3D;&#x3D;【紧凑，高效，省带宽】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#msg%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E3%80%90netty-demo%E9%A1%B9%E7%9B%AE%E3%80%91\"><span class=\"toc-text\">msg编解码器【netty-demo项目】</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%F0%9F%92%A1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E5%8A%A0-Sharable\"><span class=\"toc-text\">💡 什么时候可以加 @Sharable</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-x3D-x3D-%E3%80%90QQ%E3%80%91%E8%81%8A%E5%A4%A9%E5%AE%A4%E6%A1%88%E4%BE%8B-x3D-x3D\"><span class=\"toc-text\">3. &#x3D;&#x3D;【QQ】聊天室案例&#x3D;&#x3D;</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">3.1 聊天室业务介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E7%99%BB%E5%BD%95\"><span class=\"toc-text\">3.2 聊天室业务-登录</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E5%8D%95%E8%81%8A\"><span class=\"toc-text\">3.3 聊天室业务-单聊</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E7%BE%A4%E8%81%8A\"><span class=\"toc-text\">3.4 聊天室业务-群聊</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E9%80%80%E5%87%BA\"><span class=\"toc-text\">3.5 聊天室业务-退出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">3.6 聊天室业务-空闲检测</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E5%81%87%E6%AD%BB-%E5%BF%83%E8%B7%B3\"><span class=\"toc-text\">连接假死-心跳</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">四. 优化与源码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">1. 优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%89%A9%E5%B1%95%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">1.1 扩展序列化算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">1.2 参数调优</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%EF%BC%89CONNECT-TIMEOUT-MILLIS\"><span class=\"toc-text\">1）CONNECT_TIMEOUT_MILLIS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%EF%BC%89SO-BACKLOG\"><span class=\"toc-text\">2）SO_BACKLOG</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%EF%BC%89ulimit-n\"><span class=\"toc-text\">3）ulimit -n</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%EF%BC%89TCP-NODELAY\"><span class=\"toc-text\">4）TCP_NODELAY</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%EF%BC%89SO-SNDBUF-amp-SO-RCVBUF-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8A%E9%99%90\"><span class=\"toc-text\">5）SO_SNDBUF &amp; SO_RCVBUF[滑动窗口上限]</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%EF%BC%89ALLOCATOR\"><span class=\"toc-text\">6）ALLOCATOR</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7%EF%BC%89RCVBUF-ALLOCATOR\"><span class=\"toc-text\">7）RCVBUF_ALLOCATOR</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-x3D-x3D-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8-RPC-%E6%A1%86%E6%9E%B6-%E5%9F%BA%E4%BA%8E%E8%81%8A%E5%A4%A9%E5%AE%A4ChatSC-%E3%80%90%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%E5%8F%8D%E5%B0%84%EF%BC%9Astr-gt-JavaClass%E3%80%91-x3D-x3D\"><span class=\"toc-text\">1.3 &#x3D;&#x3D;典型应用-RPC 框架(基于聊天室ChatSC)【远程方法调用 反射：str-&gt;JavaClass】&#x3D;&#x3D;</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">1）准备工作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%812%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8-handler\"><span class=\"toc-text\">！2）服务器 handler</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%AC%AC%E4%B8%80%E7%89%88%E3%80%90%E5%86%99%E6%AD%BBmsg%E5%AF%B9%E8%B1%A1%EF%BC%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86Handler%EF%BC%81%E8%87%AA%E5%B7%B1%E8%BD%AC%E6%8D%A2%E5%B0%81%E8%A3%85obj%E3%80%91\"><span class=\"toc-text\">3）客户端代码第一版【写死msg对象！自定义处理Handler！自己转换封装obj】</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF-handler-%E7%AC%AC%E4%B8%80%E7%89%88\"><span class=\"toc-text\">4）客户端 handler 第一版</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81-%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%90RpcClientManager%E7%89%88%EF%BC%9A%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%9C%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E3%80%91\"><span class=\"toc-text\">5）客户端代码 第二版【RpcClientManager版：异步网络结果用同步方式】</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%85%E6%8B%AC-x3D-x3D-channel-%E7%AE%A1%E7%90%86-%E5%8D%95%E4%BE%8B-%EF%BC%8C-JDK-Proxy-%E4%BB%A3%E7%90%86%EF%BC%8C%E6%8E%A5%E6%94%B6%E7%BB%93%E6%9E%9C-promise-await-%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%9C%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%EF%BC%8C%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8-x3D-x3D\"><span class=\"toc-text\">包括 &#x3D;&#x3D;channel 管理(单例)，(JDK Proxy)代理，接收结果(promise.await();异步网络结果同步等待，不抛异常)&#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF-handler-%E7%AC%AC%E4%BA%8C%E7%89%88\"><span class=\"toc-text\">6）客户端 handler 第二版</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Client%E7%AB%AF-%E5%BC%82%E5%B8%B8%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">Client端-异常调用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BE%A7%E9%87%8Dnetty%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">2. 源码分析 [侧重netty执行流程]</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%90%AF%E5%8A%A8%E5%89%96%E6%9E%90\"><span class=\"toc-text\">2.1 启动剖析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-NioEventLoop-%E5%89%96%E6%9E%90-%E9%87%8D%E9%87%8F%E7%BA%A7-900-lines\"><span class=\"toc-text\">2.2 NioEventLoop 剖析[重量级 900+lines]</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">⚠️ 注意</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-accept-%E5%89%96%E6%9E%90\"><span class=\"toc-text\">2.3 accept 剖析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-read-%E5%89%96%E6%9E%90\"><span class=\"toc-text\">2.4 read 剖析</span></a></li></ol></li></ol></li></ol>","author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2022-08-18T15:39:21.726Z","updated":"2022-08-22T08:06:14.544Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":"http://p1.qhimg.com/bdm/480_296_0/t01f3d12d8647407337.jpg","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ...","link":"","photos":[],"count_time":{"symbolsCount":440,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"sgg大数据高频面试题","uid":"128485c0403ac0ca82c74aaa720458ad","slug":"sgg大数据高频面试题","date":"2021-12-26T12:18:53.000Z","updated":"2022-08-22T07:56:11.565Z","comments":true,"path":"api/articles/sgg大数据高频面试题.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/480_296_0/t015eb817c1c36a6fc1.jpg","text":"尚硅谷大数据技术之高频面试题 （作者：尚硅谷大数据研发部） 版本：V8.0.15 目录项目涉及技术1.1 Linux&amp;Shell1.1.1 Linux常用高级命令 序号 命令 命令解释 1 top 查看内存 2 df -h 查看磁盘存储情况 3 iotop 查看磁盘IO读...","link":"","photos":[],"count_time":{"symbolsCount":"143k","symbolsTime":"2:10"},"categories":[{"name":"大数据","slug":"大数据","count":2,"path":"api/categories/大数据.json"}],"tags":[{"name":"大数据","slug":"大数据","count":2,"path":"api/tags/大数据.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}