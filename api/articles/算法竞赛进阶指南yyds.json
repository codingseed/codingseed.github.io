{"title":"算法竞赛进阶指南yyds","uid":"fdecd5d933e92063c33253528b945c35","slug":"算法竞赛进阶指南yyds","date":"2020-06-08T14:31:57.000Z","updated":"2022-08-22T08:37:30.254Z","comments":true,"path":"api/articles/算法竞赛进阶指南yyds.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/960_593_0/t018d8dbbf84fd9beef.jpg","content":"<h1 id=\"0x00基本算法\"><a href=\"#0x00基本算法\" class=\"headerlink\" title=\"0x00基本算法\"></a>0x00基本算法</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;&#x2F;a^b %p\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a, b, p;\n\n&#x2F;&#x2F;快速幂\nint power(int a,int b,int p)&#123;&#x2F;&#x2F;(a^b)%p\n\tint ans &#x3D; 1 % p;&#x2F;&#x2F;b&#x3D;&#x3D;0会跳过for，a^0&#x3D;1%1&#x3D;0 而不是1，故先1%p !!!!! \n\tfor(;b;b &gt;&gt;&#x3D; 1)&#123;\n\t\tif(b &amp; 1) ans &#x3D; ans * 1ll * a % p;&#x2F;&#x2F; (long long)\n\t\ta &#x3D; a * 1ll * a % p;&#x2F;&#x2F;a a^2 a^4 a^8\n\t&#125;\n\treturn ans;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n\tcout &lt;&lt; power(a, b, p) &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;64位整数乘法\n#include&lt;iostream&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nULL a, b, p;\n&#x2F;&#x2F;快速乘\nULL mul(ULL a,ULL b,ULL p) &#123;\n\tULL ans &#x3D; 0;\n\tfor(;b;b &gt;&gt;&#x3D; 1)&#123;\n\t\tif(b &amp; 1) ans &#x3D; (ans + a) % p;\n\t\ta &#x3D; a * 2 % p;\n\t&#125;\n\treturn ans;\n&#125;\n&#x2F;*\nULL mul(ULL a,ULL b,ULL p) &#123;\n\ta %&#x3D; p , b %&#x3D; p;\n\tULL c &#x3D; (long double) a * b &#x2F; p;\n\tULL ans &#x3D; a * b - c * p;\n\tif(ans &lt; 0) ans +&#x3D; p;\n\telse if(ans &gt;&#x3D; p) ans -&#x3D; p;\n\treturn ans;\n&#125;\n*&#x2F;\nint main() &#123;\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n\tcout &lt;&lt; mul(a, b, p) &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;bin状压DP：最短Hamilton路径\n\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 20,M &#x3D; 1 &lt;&lt; 20;\n\nint n;\nint f[M][N],weight[N][N];\n\nint hamilton(int n,int weight[N][N]) &#123;\n\tmemset(f,0x3f,sizeof(f));\n\tf[1][0] &#x3D; 0;\n\tfor(int i &#x3D; 1;i &lt; 1 &lt;&lt; n;i++)\n\t\tfor(int j &#x3D; 0; j &lt; n; j++) if(i &gt;&gt; j &amp; 1)&#x2F;&#x2F;i的j位&#x3D;&#x3D;1\n\t\t\tfor(int k &#x3D; 0; k &lt; n; k++) if((i ^ 1 &lt;&lt; j) &gt;&gt; k &amp; 1)\n\t\t\t&#x2F;&#x2F;i的j位取反为0时，k位&#x3D;&#x3D;1\n\t\t\t\tf[i][j] &#x3D; min(f[i][j],f[i ^ 1 &lt;&lt; j][k] + weight[k][j]);\n\treturn f[(1 &lt;&lt; n) - 1][n-1];\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n;\n\tfor(int i &#x3D; 0;i &lt; n; i++)\n\t\tfor(int j &#x3D; 0;j &lt; n; j++)\n\t\t\tcin &gt;&gt; weight[i][j];\n\t\t\t\n\tint ans &#x3D; hamilton(n,weight);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;acwing 998. 起床困难综合症\n#include &lt;iostream&gt;\n\nusing namespace std;\nint n, m;\npair&lt;string, int&gt; a[100010];\n\nint calc(int bit,int now)&#123; &#x2F;&#x2F;遍历门(对bit位做n次位运算)\n\tfor(int i &#x3D; 1;i &lt;&#x3D; n;i++)&#123;\n\t\tint x &#x3D; a[i].second &gt;&gt; bit &amp; 1;&#x2F;&#x2F;取bit位\n\t\tif(a[i].first &#x3D;&#x3D; &quot;AND&quot;) now &amp;&#x3D; x;\n\t\telse if(a[i].first &#x3D;&#x3D; &quot;OR&quot;) now |&#x3D; x;\n\t\telse now ^&#x3D; x;\n\t&#125;\n\treturn now;\n&#125;\n\nint main()&#123;\n\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#123;\n\t\tchar str[5];int x;\n\t\t&#x2F;&#x2F; cin &gt;&gt; str &gt;&gt; x;\n\t\tscanf(&quot;%s%d&quot;, str, &amp;x);\n\t\ta[i] &#x3D; make_pair(str,x);\n\t&#125;\n\tint val &#x3D; 0,ans &#x3D; 0;\n\tfor(int bit &#x3D; 29; bit &gt;&#x3D; 0; bit--)&#123;&#x2F;&#x2F;10^9~~2^30 遍历每一bit\n\t\tint res0 &#x3D; calc(bit,0);\n\t\tint res1 &#x3D; calc(bit,1);\n\t\tif(val + (1&lt;&lt;bit) &lt;&#x3D; m  &amp;&amp; res0 &lt; res1)&#x2F;&#x2F; 0&lt;1\n\t\t\tval +&#x3D; 1 &lt;&lt; bit, ans +&#x3D; res1 &lt;&lt; bit;\n\t\telse\n\t\t\tans +&#x3D; res0 &lt;&lt; bit;\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;*\n位运算：\n1.用异或实现配偶（最后一位取反）\n\n0^1&#x3D;1,1^1&#x3D;0\n4^1&#x3D;5,5^1&#x3D;4\n\n最小费用流：实现成对的正向&#x2F;反向边\ne[idx]\ne[idx^1]\n\n2. lowbit运算 （树状数组）\n一个num的最后一位1\nlowbit(n) &#x3D; n&amp;(~n+1) &#x3D; n&amp;(-n)\n\n\tint H[37];&#x2F;&#x2F;0&lt;&#x3D;n&lt;&#x3D;35\n\tfor(int i &#x3D; 0; i &lt; 36; i++) H[(1ll &lt;&lt; i) % 37] &#x3D; i;\n\twhile(cin &gt;&gt; n)&#123;\n\twhile(n &gt; 0)&#123;\n\t\tcout &lt;&lt; H[(n &amp; (-n) % 37)] &lt;&lt; &#39; &#39;;\n\t\tn -&#x3D; n &amp; -n;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\n*&#x2F;\n\n&#x2F;&#x2F;递归枚举 2^n\n#include &lt;iostream&gt;\n\nusing namespace std;\nint n;\n\nvoid dfs(int u, int state)&#123;\n\tif(u &#x3D;&#x3D; n)&#123;\n&#x2F;&#x2F;        int H[37];&#x2F;&#x2F;0&lt;&#x3D;n&lt;&#x3D;35\n&#x2F;&#x2F;        for(int i &#x3D; 0; i &lt; 36; i++) H[(1ll &lt;&lt; i) % 37] &#x3D; i;\n&#x2F;&#x2F;        while(state &gt; 0)&#123;\n&#x2F;&#x2F;            cout &lt;&lt; H[(state &amp; (-state) % 37)] + 1 &lt;&lt; &#39; &#39;;\n&#x2F;&#x2F;            state -&#x3D; state &amp; -state;\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;\t\tcout &lt;&lt; endl;\n\n\t\tfor(int i &#x3D; 0; i &lt; n;i++)\n\t\t\tif(state &gt;&gt; i &amp; 1)\n\t\t\t\tcout &lt;&lt; i + 1 &lt;&lt; &#39; &#39;;&#x2F;&#x2F;1的所有位置(被选的数字)\n\t\tcout &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tdfs(u+1,state);&#x2F;&#x2F;不选\n\tdfs(u+1,state | 1 &lt;&lt; u);&#x2F;&#x2F;选: u位置1\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n;\n\tdfs(0, 0);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;递归枚举C(n,m)\n#include &lt;iostream&gt;\n\nusing namespace std;\nint n, m;\n\nvoid dfs(int u, int sum, int state)&#123;\n\tif(sum + n - u &lt; m) return;&#x2F;&#x2F;已选+余下所有 &lt; m:不可能了\n\tif(sum &#x3D;&#x3D; m)&#123;&#x2F;&#x2F;等价于 sum&gt;m : return  + 上述情况 --&gt;   x&#x3D;&#x3D;n :cout\n\t\tfor(int i &#x3D; 0; i &lt; n;i++)\n\t\t\tif(state &gt;&gt; i &amp; 1)\n\t\t\t\tcout &lt;&lt; i + 1 &lt;&lt; &#39; &#39;;&#x2F;&#x2F;1的所有位置(被选的数字)\n\t\tcout &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tif(u &#x3D;&#x3D; n) return;&#x2F;&#x2F;还没选够m但已经递归到n了，结束\n\n\tdfs(u+1, sum+1, state | 1 &lt;&lt; u);&#x2F;&#x2F;选: u位置1(字典序优先:能选就先选)\n\tdfs(u+1, sum, state);&#x2F;&#x2F;不选\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tdfs(0, 0, 0);&#x2F;&#x2F;cur第几个数，选了几个数，选了哪些数1&#x2F;0\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;递归枚举P(10) 全排列n!\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n;\nvector&lt;int&gt; path;\n\nvoid dfs(int u, int state)&#123;\n\tif(u &#x3D;&#x3D; n)&#123;\n\t\tfor(auto x : path) cout &lt;&lt; x &lt;&lt; &#39; &#39;;&#x2F;&#x2F;!!!!!!!\n\t\tcout &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t\tif(!(state &gt;&gt; i &amp; 1))&#123;&#x2F;&#x2F;没有:不选分支\n\t\t\tpath.push_back(i+1);\n\t\t\tdfs(u+1,state | (1 &lt;&lt; i));\n\t\t\tpath.pop_back();\n\t\t&#125;\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n;\n\tdfs(0, 0);&#x2F;&#x2F;cur,state\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;费解的开关\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int INF &#x3D; 100000; \nchar g[10][10];\nint dx[5] &#x3D; &#123;0, -1, 0, 1, 0&#125;, dy[5] &#x3D; &#123;0, 0, 1, 0, -1&#125;;&#x2F;&#x2F;上右下左\n\nvoid turn(int x,int y)\n&#123;\n\tfor(int i &#x3D; 0; i &lt; 5; i++)\n\t&#123;\n\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n\t\tif(a &gt;&#x3D; 0 &amp;&amp; a &lt; 5 &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; 5)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; g[a][b] &#x3D; &#39;0&#39; + (&#39;1&#39; - g[a][b]);\n\t\t\tg[a][b] ^&#x3D; 1;&#x2F;&#x2F; +1&#x2F;-1 &#39;0&#39;&lt;---&gt;&#39;1&#39;\n\t\t&#125;\n\t&#125;\n&#125;\nint work()\n&#123;&#x2F;&#x2F;--&gt;全1\n\tint ans &#x3D; INF;\n\tfor(int k &#x3D; 0; k &lt; 1 &lt;&lt; 5; k++)\n\t&#123;\n\t\tint res &#x3D; 0;\n\t\tchar backup[10][10];\n\t\tmemcpy(backup, g, sizeof g);\n&#x2F;*\n下面for循环这里不是在枚举第一行灯的所有状态，使第1行全1。\n而是在《枚举》对第一行的《所有操作方式!!!》（与给出局面无关!）。该位为1就点击该位。\n最终得到针对给出局面的合法点击方案，取点击min次的。\n*&#x2F;\n\t\tfor(int j &#x3D; 0; j &lt; 5; j++)\n\t\t\tif(k &gt;&gt; j &amp; 1)&#123;\n\t\t\t\tres++;\n\t\t\t\tturn(0,j);&#x2F;&#x2F;点击0行j位\n\t\t\t&#125;\n\t\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; 5; j++)\n\t\t\t\tif(g[i][j] &#x3D;&#x3D; &#39;0&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tres++;\n\t\t\t\t\tturn(i+1,j);\n\t\t\t\t&#125;\n\t\tbool is_successful &#x3D; true;\n\t\tfor(int j &#x3D; 0; j &lt; 5; j++)\n\t\t\tif(g[4][j] &#x3D;&#x3D; &#39;0&#39;)&#123;\n\t\t\t\tis_successful &#x3D; false;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\n\t\tif(is_successful) ans &#x3D; min(ans, res);\n\t\tmemcpy(g, backup,sizeof backup);\n\t&#125;\n\tif(ans &gt; 6) return -1;\n\treturn ans;\n&#125;\n\nint main()&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile(T--)&#123;\n\t\tfor(int i &#x3D; 0; i &lt; 5; i++) cin &gt;&gt; g[i];&#x2F;&#x2F;一次一行\n\t\tcout &lt;&lt; work() &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;96. 奇怪的汉诺塔\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nint main()&#123;\n\tint d[15],f[15];&#x2F;&#x2F;d:3塔,f:4塔\n\t\n\td[1] &#x3D; 1;\n\tfor(int i &#x3D;2; i &lt;&#x3D; 12; i++)\n\t\td[i] &#x3D; 1 + d[i-1] * 2;\n\t\n\tmemset(f, 0x3f, sizeof f);\n\tf[0] &#x3D; 0;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; 12; i++)\n\t\tfor(int j &#x3D; 0; j &lt; i; j++)\n\t\t\tf[i] &#x3D; min(f[i], 2 * f[j] + d[i-j]);\n\t\t\n\tfor(int i &#x3D; 1; i &lt;&#x3D; 12; i++) cout &lt;&lt; f[i] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;王道机试4.8\n&#x2F;&#x2F;A^B约数之和\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int mod &#x3D; 9901;\n\nint qmi(int a, int k)&#123;&#x2F;&#x2F;sum保证k!&#x3D;0,否则res &#x3D; 1%mod\n\ta %&#x3D; mod;\n\tint res &#x3D; 1;\n\twhile(k)&#123;\n\t\tif(k &amp; 1) res &#x3D; res * a % mod;\n\t\ta &#x3D; a * a % mod;\n\t\tk &gt;&gt;&#x3D; 1;\n\t&#125;\n\treturn res;\n&#125;\n\nint sum(int p,int k)&#123;\n\tif(k &#x3D;&#x3D; 0) return 1;\n\tif(k % 2 &#x3D;&#x3D; 0) return (p % mod * sum(p,k-1) + 1) % mod;&#x2F;&#x2F;偶数：递归\n\treturn (1 + qmi(p, k&#x2F;2+1)) * sum(p, k&#x2F;2) % mod;&#x2F;&#x2F;奇数：分治\n&#125;\n\nint main()&#123;\n\tint A, B;\n\tcin &gt;&gt; A &gt;&gt; B;\n\tint res &#x3D; 1;\n\tfor(int i &#x3D; 2;i &lt;&#x3D; A;i++)&#123;\n\t\tint s &#x3D; 0;\n\t\twhile(A % i &#x3D;&#x3D; 0)&#123;\n\t\t\ts++;\n\t\t\tA &#x2F;&#x3D; i;\n\t\t&#125; \n\t\tif(s) res &#x3D; res * sum(i,s * B) % mod;\n\t&#125;\n\tif(!A) res &#x3D; 0;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;前缀和与2D部分和\n&#x2F;&#x2F;激光炸弹\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 5010;\n\nint g[N][N];\n\nint main()&#123;\n\tint N, R;\n\tcin &gt;&gt; N &gt;&gt; R;&#x2F;&#x2F;地图上的目标数目,正方形的边长\n\tint n &#x3D; R, m &#x3D; R;\n\tfor(int i &#x3D; 0, x, y, w; i &lt; N; i++)&#123;\n\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n\t\tx++; y++;&#x2F;&#x2F;前缀和：从1开始\n\t\tn &#x3D; max(n, x); m &#x3D; max(m, y);&#x2F;&#x2F;坐标上界\n\t\tg[x][y] +&#x3D; w;&#x2F;&#x2F;A[i][j]\n\t&#125;\n\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor(int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t\tg[i][j] +&#x3D; g[i-1][j] + g[i][j-1] -g[i-1][j-1];\n\t&#x2F;&#x2F;枚举边长为r的正方形的右下角坐标[i,j],从[r,r]开始\n\tint res &#x3D; 0;\n\tfor(int i &#x3D; R; i &lt;&#x3D; n; i++)\n\t\tfor(int j &#x3D; R; j &lt;&#x3D; m; j++)\n\t\t\tres &#x3D;  max(res, g[i][j] - g[i-R][j] - g[i][j-R] + g[i-R][j-R]);\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;差分 区间op-&gt;单点op\n&#x2F;&#x2F;InDec Seq\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 100010;\n\nint a[N];\n\nint main() &#123;\n\tint n;\n\tcin &gt;&gt; n;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n ; i++) cin &gt;&gt; a[i];\n\tfor(int i &#x3D; n; i &gt; 1; i--) a[i] -&#x3D; a[i-1];\n\t\n\tLL pos &#x3D; 0, neg &#x3D; 0;\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n ; i++) \n\t\tif(a[i] &gt; 0) pos +&#x3D; a[i];\n\t\telse neg -&#x3D; a[i];&#x2F;&#x2F;负数之和的绝对值\n\t\n\tcout &lt;&lt; max(pos, neg) &lt;&lt; endl;\n\tcout &lt;&lt; abs(pos - neg) + 1 &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;最高的牛\n&#x2F;&#x2F;必须双端判重，故用set&lt;pair&lt;int, int&gt;&gt;,不用set&lt;int&gt; hash单端check\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n&#x2F;&#x2F; #include &lt;unordered_set&gt;&#x2F;&#x2F;hash\n\nusing namespace std;\n\nconst int N &#x3D; 10010;\n\nint height[N];\n\nint main()&#123;\n\tint n, p, h, m;\n\tcin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m;\n\theight[1] &#x3D; h;&#x2F;&#x2F;+&#x3D;,h+C[i],h做初值 \n\t\n\tset&lt;pair&lt;int, int&gt;&gt; existed;\n\tfor(int i &#x3D; 0, a, b; i &lt; m; i++)&#123;\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\tif(a &gt; b) swap(a,b);\n\t\tif(!existed.count(&#123;a,b&#125;))&#123;\n\t\t\texisted.insert(&#123;a,b&#125;);\n\t\t\theight[a+1]--; height[b]++;&#x2F;&#x2F;得到D\n\t\t&#125;\n\t&#125;\n\t\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n\t\theight[i] +&#x3D; height[i-1];&#x2F;&#x2F;求C:D的前缀和\n\t\tcout &lt;&lt; height[i] &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;二分\n&#x2F;&#x2F;最佳牛围栏\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n, m;&#x2F;&#x2F;子段长度&gt;&#x3D;m\nint cows[N];\ndouble sum[N];\n\nbool check(double avg)&#123;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) sum[i] &#x3D; sum[i-1] + cows[i] - avg;\n\t\n\tdouble minv &#x3D; 0;\n\tfor(int i &#x3D; 0, j &#x3D; m; j &lt;&#x3D; n; j++, i++)&#123;&#x2F;&#x2F;i小j大\n\t\tminv &#x3D; min(minv, sum[i]);\n\t\tif(sum[j] &gt;&#x3D; minv) return true;&#x2F;&#x2F;不用max,存在子段和非负即可\n\t&#125;\n\treturn false;\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; cows[i];\n\tdouble l &#x3D; 0, r &#x3D; 2000;\n\twhile(r - l &gt; 1e-5)&#123;\n\t\tdouble mid &#x3D; (l + r) &#x2F; 2;\n\t\tif(check(mid)) l &#x3D; mid;\n\t\telse r &#x3D; mid;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, int(r * 1000));\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;max子段和\n\n\n&#x2F;&#x2F;113. 特殊排序  在线交互题\n&#x2F;&#x2F; Forward declaration of compare API.\n&#x2F;&#x2F; bool compare(int a, int b);\n&#x2F;&#x2F; return bool means whether a is less than b.\n\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; specialSort(int N) &#123;\n\t\tvector&lt;int&gt; res;\n\t\tres.push_back(1);\n\t\tfor(int i &#x3D; 2; i &lt;&#x3D; N; i++)&#123;\n\t\t\tint l &#x3D; 0, r &#x3D; res.size() - 1;\n\t\t\twhile(l &lt; r)&#123;\n\t\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;&#x2F;&#x2F;mid入右半,2分模板2\n\t\t\t\tif(compare(res[mid], i)) l &#x3D; mid;\n\t\t\t\telse r &#x3D; mid - 1;\n\t\t\t&#125;&#x2F;&#x2F;res[l&#x3D;&#x3D;r]  &#x3D;&#x3D;  &lt;&#x3D;i的max\n\t\t\tres.push_back(i);\n\t\t\tfor(int j &#x3D; res.size() - 2; j &gt; r; j--) swap(res[j], res[j+1]);\n\t\t\tif(compare(i, res[r])) swap(res[r],res[r+1]);&#x2F;&#x2F;i&#x3D;&#x3D;res[r+1]\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\nvim：\nG:至结尾\ngg：至开始\nv：选择\nv G：全选\nd：删\nu：撤回\n\n&#x2F;&#x2F;05排序\n&#x2F;&#x2F;离散化\n&#x2F;&#x2F;电影\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 200006;\nint n, m, a[N], x[N], y[N], cinema[N*3], tot &#x3D; 0, k, ans[N*3];\n\nint find(int f) &#123;&#x2F;&#x2F;找语言在cinema[]中的下标pos\n\treturn lower_bound(cinema + 1, cinema + k + 1, f) - cinema;\n&#125;\n\nint main() &#123;\n\t&#x2F;&#x2F;离散化\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;a[i]);\n\t\tcinema[++tot] &#x3D; a[i];&#x2F;&#x2F;人\n\t&#125;\n\tcin &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;x[i]);\n\t\tcinema[++tot] &#x3D; x[i];&#x2F;&#x2F;语音\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;y[i]);\n\t\tcinema[++tot] &#x3D; y[i];&#x2F;&#x2F;字幕\n\t&#125;\n\tsort(cinema + 1, cinema + tot + 1);\n\tk &#x3D; unique(cinema + 1, cinema + tot + 1) - (cinema + 1);\n\t\n\tmemset(ans, 0, sizeof(ans));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) ans[find(a[i])]++;&#x2F;&#x2F;会lan的人计数\n\tint ans0 &#x3D; 1, ans1 &#x3D; 0, ans2 &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;&#x2F;&#x2F;找会该lan的人数最多的lan\n\t\tint ansx &#x3D; ans[find(x[i])], ansy &#x3D; ans[find(y[i])];\n\t\tif (ansx &gt; ans1 || (ansx &#x3D;&#x3D; ans1 &amp;&amp; ansy &gt; ans2)) &#123;\n\t\t\tans0 &#x3D; i;\n\t\t\tans1 &#x3D; ansx;\n\t\t\tans2 &#x3D; ansy;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; ans0 &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;中位数\n&#x2F;&#x2F;货仓选址\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100100;\nint a[N], n, ans;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; a[i];\n\tsort(a+1, a+1+n);\n\n\t&#x2F;&#x2F; int md &#x3D; a[n&#x2F;2+1];\n\t&#x2F;&#x2F; for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#x2F;&#x2F;     ans +&#x3D; abs(a[i] - md);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; 2; i++)\n\t\tans +&#x3D; a[n-i+1] - a[i];\n\t&#x2F;&#x2F;12345,md&#x3D;3,(a3-a2)+(a3-a1)+(a4-a3)+(a5-a3)\n\t&#x2F;&#x2F;&#x3D;&#x3D;(a4-a2)+(a5-a1)\n\tcout &lt;&lt; ans;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;七夕祭\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 100006;\nint n, m, t, x[N], y[N], a[N], s[N];\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; t;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) scanf(&quot;%d %d&quot;, &amp;x[i], &amp;y[i]);\n\t&#x2F;&#x2F;感兴趣摊点数能整除行数(列数)，则能使各行(列)中感兴趣摊点数一样多\n\tbool row &#x3D; !(t % n), column &#x3D; !(t % m);\n\tif (row) &#123;\n\t\tif (column) cout &lt;&lt; &quot;both &quot;;\n\t\telse cout &lt;&lt; &quot;row &quot;;\n\t&#125; else &#123;\n\t\tif (column) cout &lt;&lt; &quot;column &quot;;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;\n\t\t\treturn 0;\n\t\t&#125;\n\t&#125;\n\n\tll ans &#x3D; 0;\n\tif (row) &#123;\n\t\tint num &#x3D; t &#x2F; n;\n\t\tmemset(a, 0, sizeof(a));\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) a[x[i]]++;&#x2F;&#x2F;行摊点计数\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i] -&#x3D; num;&#x2F;&#x2F;1.-avg\n\t\ts[0] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) s[i] &#x3D; s[i-1] + a[i];&#x2F;&#x2F;2.前缀和\n\t\tsort(s + 1, s + n + 1);&#x2F;&#x2F;3.环形均分纸牌，k处剪开，ans +&#x3D;（si-sk）最小\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; 2; i++) ans +&#x3D; s[n-i+1] - s[i];&#x2F;&#x2F;3.sk为si中位数\n\t&#125;\n\tif (column) &#123;\n\t\tint num &#x3D; t &#x2F; m;\n\t\tmemset(a, 0, sizeof(a));\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) a[y[i]]++;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) a[i] -&#x3D; num;\n\t\ts[0] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) s[i] &#x3D; s[i-1] + a[i];\n\t\tsort(s + 1, s + m + 1);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m &#x2F; 2; i++) ans +&#x3D; s[m-i+1] - s[i];\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;running median  对顶堆\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\nusing namespace std;\npriority_queue&lt;int&gt; q1, q2;\n&#x2F;&#x2F; priority_queue&lt;int , vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;\nvoid Running_Median() &#123;&#x2F;&#x2F;小q1--&gt;大q2\n\twhile (q1.size()) q1.pop();&#x2F;&#x2F;默认大根堆 少\n\twhile (q2.size()) q2.pop();&#x2F;&#x2F;小根堆(元素取负) 多1：top2&#x3D;&#x3D;median\n\tint num, n;\n\tcin &gt;&gt; num &gt;&gt; n;\n\tcout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; (n + 1) &#x2F; 2 &lt;&lt; endl;\n\tint a;\n\tcin &gt;&gt; a;\n\tcout &lt;&lt; a &lt;&lt; &quot; &quot;;\n\tq2.push(-a);\n\tint cnt &#x3D; 1;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;a);\n\t\tif (a &lt; -q2.top()) q1.push(a);\n\t\telse q2.push(-a);\n\t\tint s &#x3D; q1.size();\n\t\tif (s &gt; i &#x2F; 2) &#123;\n\t\t\tq2.push(-q1.top());\n\t\t\tq1.pop();\n\t\t&#125;\n\t\tif (s &lt; i &#x2F; 2) &#123;\n\t\t\tq1.push(-q2.top());\n\t\t\tq2.pop();\n\t\t&#125;\n\t\tif (i % 2) &#123;\n\t\t\tcout&lt;&lt; -q2.top() &lt;&lt; &quot; &quot;;\n\t\t\tif (++cnt % 10 &#x3D;&#x3D; 0 &amp;&amp; cnt &lt; (n + 1) &#x2F; 2) cout &lt;&lt; endl;&#x2F;&#x2F;坑!!!!!\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint t;\n\tcin &gt;&gt; t;\n\twhile (t--) Running_Median();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;归并sort求逆序对\n&#x2F;&#x2F;超级快排\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N&#x3D;501000;\n\n#define ll long long\n\nll n,m,i,j,k,a[N],b[N],cnt;\n\nvoid merge(ll a[], ll l, ll r)\n&#123;\n\tif (l &#x3D;&#x3D; r) return;\n\tll mid &#x3D; (l + r) &gt;&gt; 1;\n\tmerge(a, l, mid);\n\tmerge(a, mid+1, r);\n\t\n\tll i &#x3D; l, j &#x3D; mid + 1;\n\tfor (ll k &#x3D; l; k &lt;&#x3D; r; k++)\n\t&#123;\n\t\tif (j &gt; r || i &lt;&#x3D; mid &amp;&amp; a[i] &lt;&#x3D; a[j])\n\t\t\tb[k] &#x3D; a[i++];\n\t\telse\n\t\t&#123;\n\t\t\tcnt +&#x3D; mid - i + 1;&#x2F;&#x2F;顺便求\n\t\t\tb[k] &#x3D; a[j++];\n\t\t&#125;\n\t&#125;\n\tfor (ll k &#x3D; l; k &lt;&#x3D; r; k++)\n\t\ta[k] &#x3D; b[k];\n&#125;\n\nint main()\n&#123;\n\tios::sync_with_stdio(false);\n\twhile(cin &gt;&gt; n &amp;&amp; n)\n\t&#123;\n\t\tfor(i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tcin &gt;&gt; a[i];\n\t\tcnt &#x3D; 0;\n\t\tmerge(a, 1, n);\n\t\tcout &lt;&lt; cnt &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;奇数码问题\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nint n;\nlong long ans;&#x2F;&#x2F;逆序对数过大！\nvector&lt;int&gt; a[2];&#x2F;&#x2F;vector&lt;int&gt; a[n]: n个动态数组\nint c[250010];\n\n\nvoid merge(int k, int l, int mid, int r)\n&#123;\n\tint x &#x3D; l, y &#x3D; mid + 1;\n\tfor (int i &#x3D; l; i &lt;&#x3D; r; i++)\n\t&#123;\n\t\tif (y &gt; r || x &lt;&#x3D; mid &amp;&amp; a[k][x] &lt; a[k][y])\n\t\t\tc[i] &#x3D; a[k][x++];\n\t\telse ans +&#x3D; mid - x + 1, c[i] &#x3D; a[k][y++];\n\t&#125;\n\tfor (int i &#x3D; l; i &lt;&#x3D; r; i++) a[k][i] &#x3D; c[i];\n&#125;\n\nvoid mergesort(int k, int l, int r)\n&#123;\n\tif (l &#x3D;&#x3D; r) return;\n\tint mid &#x3D; (l + r) &#x2F; 2;\n\tmergesort(k, l, mid);\n\tmergesort(k, mid + 1, r);\n\tmerge(k, l, mid, r);\n&#125;\n\nlong long calc(int k)&#x2F;&#x2F;a[k]的逆序对数\n&#123;\n\tans &#x3D; 0;\n\tmergesort(k, 0, n*n - 1);\n\treturn ans;\n&#125;\n\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n)\n\t&#123;\n\t\ta[0].clear();\n\t\ta[1].clear();\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t&#123;\n\t\t\t\tint x; \n\t\t\t\tscanf(&quot;%d&quot;, &amp;x); \n\t\t\t\tif(x) a[0].push_back(x);\n\t\t\t&#125;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t&#123;\n\t\t\t\tint x; \n\t\t\t\tscanf(&quot;%d&quot;, &amp;x); \n\t\t\t\tif(x) a[1].push_back(x);\n\t\t\t&#125;\n\t\tputs(a[0].size() &amp;&amp; (calc(1) - calc(0) &amp; 1) ? &quot;NIE&quot; : &quot;TAK&quot;);\n\t&#125;&#x2F;&#x2F;(calc(1)&amp;1)!&#x3D;(calc(0)&amp;1) &#x2F;&#x2F;std::abs(calc(1) - calc(0)) % 2\n&#125;\n\n\n&#x2F;&#x2F;0x06 倍增+bin划分\n&#x2F;&#x2F;天才ACM\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 500006;\nint n, m, w;\nll k, a[N], b[N], c[N];\n\nvoid gb(int l, int mid, int r) &#123;&#x2F;&#x2F;merge\n\tint i &#x3D; l, j &#x3D; mid + 1;\n\tfor (int k &#x3D; l; k &lt;&#x3D; r; k++)\n\t\tif (j &gt; r || (i &lt;&#x3D; mid &amp;&amp; b[i] &lt;&#x3D; b[j])) c[k] &#x3D; b[i++];\n\t\telse c[k] &#x3D; b[j++];\n&#125;\n\nll f(int l, int r) &#123;&#x2F;&#x2F;[l,r]段的校验值\n\tif (r &gt; n) r &#x3D; n;\n\tint t &#x3D; min(m, (r - l + 1) &gt;&gt; 1);&#x2F;&#x2F;m对数,取到不能取为止\n\tfor (int i &#x3D; w + 1; i &lt;&#x3D; r; i++) b[i] &#x3D; a[i];\n\tsort(b + w + 1, b + r + 1);&#x2F;&#x2F;新段部分排序\n\tgb(l, w, r);&#x2F;&#x2F;合并新旧两段\n\tll ans &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; t; i++)\n\t\tans +&#x3D; (c[r-i] - c[l+i]) * (c[r-i] - c[l+i]);\n\treturn ans;\n&#125;\n\nvoid Genius_ACM() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tcin &gt;&gt; k; &#x2F;&#x2F;满足每段check &lt;&#x3D; k\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%lld&quot;, &amp;a[i]);\n\tint ans &#x3D; 0, l &#x3D; 1, r &#x3D; 1;\n\tw &#x3D; 1;\n\tb[1] &#x3D; a[1];\n\twhile (l &lt;&#x3D; n) &#123;\n\t\tint p &#x3D; 1;\n\t\twhile (p) &#123;\n\t\t\tll check &#x3D; f(l, r + p);\n\t\t\tif (check &lt;&#x3D; k) &#123;\n\t\t\t\tw &#x3D; r &#x3D; min(r + p, n);&#x2F;&#x2F;新段起点w&#x3D;旧段终点r&#x3D;r+p，不超过n\n\t\t\t\tfor (int i &#x3D; l; i &lt;&#x3D; r; i++) b[i] &#x3D; c[i];\n\t\t\t\tif (r &#x3D;&#x3D; n) break;\n\t\t\t\tp &lt;&lt;&#x3D; 1;\n\t\t\t&#125; else p &gt;&gt;&#x3D; 1;\n\t\t&#125;  \n\t\tans++;&#x2F;&#x2F;求最少需要分几段\n\t\tl &#x3D; r + 1;\n\t&#125;\n\t&#x2F;&#x2F;由于val不同，根据不同的check &lt;&#x3D; k 来倍增r即段长，故段长不等 \n\t&#x2F;&#x2F;故必须一段一段while，不能直接算ans &#x3D; (n % (r-l+1)) n &#x2F; (r-l+1) + 1 : n &#x2F; (r-l+1);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint t;\n\tcin &gt;&gt; t;\n\twhile (t--) Genius_ACM();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;RMQ-ST\n\n\n&#x2F;&#x2F;0x07 贪心\n&#x2F;&#x2F;防晒？？？？？？？？？？？？\n&#x2F;&#x2F; pair 天然按第一第二关键字排序 map&lt;int, int&gt; spfs; spfs[spf] +&#x3D; cover;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int,int&gt; PII;\nconst int N &#x3D; 2510;\n\nint n, m;\nPII cows[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second;\n\tsort(cows, cows + n); &#x2F;&#x2F;min升序？？？？\n\n\tmap&lt;int, int&gt; spfs;&#x2F;&#x2F;下标，数量\n\tfor (int i &#x3D; 0; i &lt; m; i ++ )&#123;\n\t\tint spf, cover;\n\t\tcin &gt;&gt; spf &gt;&gt; cover;\n\t\tspfs[spf] +&#x3D; cover;&#x2F;&#x2F; 注意这里要写 +&#x3D;，因为数据中存在spf值相同的防晒霜\n\t&#125;\n\tint res &#x3D; 0;\n\tspfs[0] &#x3D; spfs[1001] &#x3D; n;&#x2F;&#x2F;哨兵,让upper_bound一句不为空\n\tfor (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )&#x2F;&#x2F;max降序???\n\t&#123;&#x2F;&#x2F;auto spf &#x3D;&#x3D; map&lt;int, int&gt; :: iterator it，泛类型\n\t\tauto spf &#x3D; spfs.upper_bound(cows[i].second);&#x2F;&#x2F; &gt;max的最小spf ？？？？\n\t\tspf --;&#x2F;&#x2F;????\n\t\tif (spf-&gt;first &gt;&#x3D; cows[i].first) &#x2F;&#x2F;spf&gt;&#x3D;min\n\t\t&#123;\n\t\t\tres ++ ;\n\t\t\tif (--spf-&gt;second &#x3D;&#x3D; 0)\n\t\t\t\tspfs.erase(spf);\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;畜栏预定\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\n\nusing namespace std;\n\ntypedef pair&lt;int,int&gt; PII;\nconst int N &#x3D; 50010;\n\nint n;\npair&lt;PII, int&gt; cows[N];&#x2F;&#x2F;&#123;&#123;起点,终点&#125;,ID&#125;\nint id[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n\t\tcin &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second;\n\t\tcows[i].second &#x3D; i;\n\t&#125;\n\t\n\tsort(cows, cows + n);\n\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;&#x2F;&#x2F;stall&#123;终点，ID&#125;,以终点升序的小根堆\n\t\n\tfor(int i &#x3D; 0; i &lt; n; i++)&#123;\n\t\tauto cow &#x3D; cows[i].first;\n\t\tif(heap.empty() || heap.top().first &gt;&#x3D; cow.first)&#123;&#x2F;&#x2F;end牛&#123;终点,ID&#125;的终点 &gt;&#x3D; cur牛的起点\n\t\t\tPII stall &#x3D; &#123;cow.second, heap.size() + 1&#125;;&#x2F;&#x2F;&#123;终点，ID&#125;\n\t\t\tid[cows[i].second] &#x3D; stall.second;&#x2F;&#x2F;id[i]\n\t\t\theap.push(stall);\n\t\t&#125;\n\t\telse&#123;\n\t\t\tauto stall &#x3D; heap.top();\n\t\t\theap.pop();\n\t\t\tstall.first &#x3D; cow.second;&#x2F;&#x2F;end牛的终点\n\t\t\tid[cows[i].second] &#x3D; stall.second;\n\t\t\theap.push(stall);&#x2F;&#x2F;cow入堆顶：pop，更新top，push\n\t\t&#125;\n\t&#125;\n\t\n\tcout &lt;&lt; heap.size() &lt;&lt; endl;\n\tfor(int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; id[i] &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;雷达设备\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\ntypedef pair&lt;double, double&gt; PDD;\nconst int N &#x3D; 1010;\nconst double eps &#x3D; 1e-6, INF &#x3D; 1e10;&#x2F;&#x2F;误差&lt;1e-6,认为相等\n\nint n, R;&#x2F;&#x2F;整数n,d\nPDD segs[N];\n\nint main()\n&#123;\n\tbool success &#x3D; true;\n\tcin &gt;&gt; n &gt;&gt; R;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n\t\tint x, y;\n\t\tcin &gt;&gt; x &gt;&gt; y;\n\t\tif(y &gt; R)&#123;\n\t\t\tsuccess &#x3D; false;\n\t\t\tbreak;\n\t\t&#125; \n\t\tdouble len &#x3D; sqrt(R * R - y * y);\n\t\tsegs[i] &#x3D; &#123;x + len, x - len&#125;;&#x2F;&#x2F;终点，起点\n\t&#125;\n\t\n\tif(!success) puts(&quot;-1&quot;);\n\telse&#123;\n\t\tsort(segs,segs + n);\n\t\tint res &#x3D; 0;\n\t\tdouble last &#x3D; -INF;&#x2F;&#x2F;last:最后一个雷达pos(double型)\n\t\tfor(int i &#x3D; 0; i &lt; n; i++)&#123;\n\t\t\tauto seg &#x3D;  segs[i];\n\t\t\tif(seg.second &gt; last + eps)&#123;\n\t\t\t\tres++;\n\t\t\t\tlast &#x3D; seg.first;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; res &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;国王游戏\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 1010;\n\nint n;\nPII ps[N];\n\n&#x2F;&#x2F; 大*小\nvector&lt;int&gt; mul(vector&lt;int&gt; a, int b)&#123;\n\tvector&lt;int&gt; c;\n\tint t &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; a.size(); i++)&#123;\n\t\tt +&#x3D; a[i] * b;\n\t\tc.push_back(t % 10);\n\t\tt &#x2F;&#x3D; 10;&#x2F;&#x2F;进位\n\t&#125;\n\twhile(t) c.push_back(t % 10), t &#x2F;&#x3D; 10;\n\treturn c;\n&#125;\n&#x2F;&#x2F; 大&#x2F;小\nvector&lt;int&gt; div(vector&lt;int&gt; a, int b)&#123;\n\tvector&lt;int&gt; c;\n\tbool is_first &#x3D; false;\n\tfor(int i &#x3D; a.size() - 1, t &#x3D; 0; i &gt;&#x3D; 0; i--)&#123;\n\t\tt &#x3D; t * 10 + a[i];&#x2F;&#x2F;被除数\n\t\tint x &#x3D; t &#x2F; b;&#x2F;&#x2F;商x\n\t\tif(x || is_first)&#123;&#x2F;&#x2F;去掉商的前导零\n\t\t\tis_first &#x3D; true;\n\t\t\tc.push_back(x);&#x2F;&#x2F;高到低\n\t\t&#125;\n\t\tt %&#x3D; b;&#x2F;&#x2F;余数\n\t&#125;\n\treturn vector&lt;int&gt;(c.rbegin(),c.rend());&#x2F;&#x2F;低到高\n&#125;\n\nvector&lt;int&gt; max_vec(vector&lt;int&gt; a, vector&lt;int&gt; b)&#123;&#x2F;&#x2F;比大小，不比字典序\n\tif(a.size() &gt; b.size()) return a;\n\tif(a.size() &lt; b.size()) return b;\n\tif(vector&lt;int&gt;(a.rbegin(), a.rend()) &gt; vector&lt;int&gt;(b.rbegin(), b.rend()))\n\t&#x2F;&#x2F;构造新的逆序a,b(高--&gt;低) 位数相等比大小：按字典序比\n\t\treturn a;\n\treturn b;\n&#125;\n\nvoid output(vector&lt;int&gt; a)&#123;&#x2F;&#x2F;低位先输入，高位先输出\n\tfor(int i &#x3D; a.size() - 1;i &gt;&#x3D; 0; i--) cout &lt;&lt; a[i];\n\tcout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor(int i &#x3D; 0; i &lt;&#x3D; n; i++)&#123;\n\t\tint a, b;\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\tps[i] &#x3D; &#123;a * b, a&#125;;\n\t&#125;\n\tsort(ps + 1, ps + n + 1);\n\n\tvector&lt;int&gt; product(1, 1);&#x2F;&#x2F;之前的人的左手累乘\n\tvector&lt;int&gt; res(1, 0);&#x2F;&#x2F;vector构造(元素个数，初值)！！！！！！！！\n\t\n\tfor(int i &#x3D; 0; i &lt;&#x3D; n; i++)&#123;&#x2F;&#x2F;0,1-n king不给自己发奖金\n\t\tif(i) res &#x3D; max_vec(res, div(product, ps[i].first &#x2F; ps[i].second));\n\t\tproduct &#x3D; mul(product, ps[i].second);\n\t&#125;\n\toutput(res);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;给树染色\n&#x2F;*\n反序和≤乱序和≤顺序和\n染色代价：反序和最小\n如果直接按上述算法做的话，最终的分值不太容易计算，我们可以在将点合并的时候，\n实时更新当前的权值和：\n\n最初所有点各自为一组，总分值是 S&#x3D;∑i&#x3D;1nai*1；\n接下来每次会将两组点合并，将其中一组点接在另一组点的后面。比如两组点分别\n是 xi 和 yi，我们将 yi 接在 xi 之后，则 yi 中每个点所乘的系数均会增加一个相\n同的偏移量，这个偏移量就是 xi 中点的个数，假设是 k，\n则合并之后，总的权值直接加上 k*∑yi 即可；\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace  std;\n\nconst int N &#x3D; 1010;\n\nstruct node&#123;\n\tint fa, size, sum;\n\tdouble avg;\n&#125;nodes[N];\n\nint n, root;\n\nint find()&#123;&#x2F;&#x2F;找最大权值非根节点\n\tdouble avg &#x3D; 0;\n\tint res &#x3D; -1;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif(i !&#x3D; root &amp;&amp; avg &lt; nodes[i].avg)&#123;\n\t\t\tavg &#x3D; nodes[i].avg;\n\t\t\tres &#x3D; i;\n\t\t&#125;\n\treturn res;\n&#125;    \n\nint main()&#123;\n\tcin &gt;&gt; n &gt;&gt; root;\n\tint res &#x3D; 0;\n\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n\t\tauto &amp;nd &#x3D; nodes[i];\n\t\tcin &gt;&gt; nd.sum;\n\t\tnd.size &#x3D; 1;\n\t\tnd.avg &#x3D; nd.sum;\n\t\tres +&#x3D; nd.sum;\n\t&#125;\n\tfor(int i &#x3D; 0, a, b; i &lt; n - 1; i++)&#123;&#x2F;&#x2F;n-1对父子关系\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\tnodes[b].fa &#x3D; a;\n\t&#125;\n\t\n\tfor(int i &#x3D; 0; i &lt; n - 1; i++)&#123;&#x2F;&#x2F;n-1对合并\n\t\tint cur &#x3D; find();\n\t\tint f &#x3D; nodes[cur].fa;\n\t\tres +&#x3D; nodes[cur].sum * nodes[f].size ;&#x2F;&#x2F;s[n]+(s[i-1]*a[i])+()+()...迭代,不断合并!!!\n\t\tnodes[cur].avg &#x3D; -1;\n\t\tfor(int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tif(nodes[j].fa &#x3D;&#x3D; cur)&#x2F;&#x2F;忽略cur\n\t\t\t\tnodes[j].fa &#x3D; f;\n\t\tnodes[f].sum +&#x3D; nodes[cur].sum;\n\t\tnodes[f].size +&#x3D; nodes[cur].size;\n\t\tnodes[f].avg &#x3D; (double) nodes[f].sum &#x2F; nodes[f].size; \n\t&#125;\n\t\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;飞行员兄弟\n&#x2F;&#x2F;位运算\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace  std;\nint change[4][4];\ntypedef pair&lt;int, int&gt; PII;\n\nint get(int x, int y)\n&#123;\n\treturn x * 4 + y;\n&#125;\n\nint main()&#123;\n\tint state &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t&#123;\n\t\tstring line;\n\t\tcin &gt;&gt; line;\n\t\tfor(int j &#x3D; 0; j &lt; 4; j++)\n\t\t\tif(line[j] &#x3D;&#x3D; &#39;+&#39;) \n\t\t\t\tstate +&#x3D; 1 &lt;&lt; get(i, j);&#x2F;&#x2F;16位局面\n\t&#125;\n\tfor(int i &#x3D; 0; i &lt; 4; i++)&#x2F;&#x2F;同行同列op\n\t\tfor(int j &#x3D; 0; j &lt; 4; j++)\n\t\t&#123;\n\t\t\tfor(int k &#x3D; 0; k &lt; 4; k++)\n\t\t\t&#123;\n\t\t\t\tchange[i][j] +&#x3D; 1 &lt;&lt; get(i,k);\n\t\t\t\tchange[i][j] +&#x3D; 1 &lt;&lt; get(k,j);\n\t\t\t&#125;\n\t\t\tchange[i][j] -&#x3D; 1 &lt;&lt; get(i,j);&#x2F;&#x2F;只减[i][j],for(k)外!!!!!!!\n\t\t&#125;\n\t\n\tvector&lt;PII&gt; res;\n\tfor(int k &#x3D; 0; k &lt; 1 &lt;&lt; 16; k++)\n\t&#123;\n\t\tint now &#x3D; state;\n\t\tvector&lt;PII&gt; path;\n\t\tfor(int i &#x3D; 0; i &lt; 16; i++)\n\t\t\tif(k &gt;&gt; i &amp; 1)\n\t\t\t&#123;\n\t\t\t\tint x &#x3D; i &#x2F; 4, y &#x3D; i % 4;\n\t\t\t\tnow ^&#x3D; change[x][y];&#x2F;&#x2F;改局面\n\t\t\t\tpath.push_back(&#123;x, y&#125;);&#x2F;&#x2F;cur方案加入op\n\t\t\t&#125;\n&#x2F;&#x2F;达到全0(合法) &amp;&amp; (还没合法方案 || 有更小op次数的合法方案path) : 更新res\n\t\tif(!now &amp;&amp; (res.empty() || res.size() &gt; path.size())) res &#x3D; path;\n\t&#125;\n\t\n\tcout &lt;&lt; res.size() &lt;&lt; endl;\n\tfor(auto p : res) cout &lt;&lt; p.first + 1 &lt;&lt; &#39; &#39; &lt;&lt; p.second + 1 &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;占卜DIY  模拟\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 14;\n\nvector&lt;int&gt; cards[N];&#x2F;&#x2F;反1-13\nint open[14];&#x2F;&#x2F;正\n\nint get(char c)\n&#123;\n\tif(c &#x3D;&#x3D; &#39;A&#39;) return 1;\n\tif(c &gt;&#x3D; &#39;2&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) return c - &#39;0&#39;;\n\tif(c &#x3D;&#x3D; &#39;0&#39;) return 10;\n\tif(c &#x3D;&#x3D; &#39;J&#39;) return 11;\n\tif(c &#x3D;&#x3D; &#39;Q&#39;) return 12;\n\treturn 13;\n&#125;\n\nint main()\n&#123;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; 13; i++) \n\t&#123;\n\t\tfor(int j &#x3D; 0; j &lt; 4; j++) \n\t\t&#123;\n\t\t\tchar s[2];&#x2F;&#x2F;&#39;A &#39;!!!!!!\n\t\t\tcin &gt;&gt; s;\n\t\t\tcards[i].push_back(get(*s));&#x2F;&#x2F;*s &#x3D;&#x3D; s[0]\n\t\t&#125;\n\t&#125;\n\t\n\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t&#123;\n\t\tint t &#x3D;  cards[13][i];\n\t\twhile(t !&#x3D; 13)\n\t\t&#123;\n\t\t\topen[t]++;\n\t\t\tint r &#x3D; cards[t].back();&#x2F;&#x2F;rear\n\t\t\tcards[t].pop_back();\n\t\t\tt &#x3D; r;\n\t\t&#125;\n\t&#125;\n\tint res &#x3D; 0;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; 12; i++) res +&#x3D; open[i] &gt;&#x3D; 4;&#x2F;&#x2F;-4*K 12堆，+&#x3D;1or0\n\tcout &lt;&lt; res &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n \n\n&#x2F;&#x2F;分形\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nchar g[N][N];\n\nvoid dfs(int n)\n&#123;\n\tif(n &#x3D;&#x3D; 1)\n\t&#123;\n\t\tg[0][0] &#x3D; &#39;X&#39;;\n\t\treturn;\n\t&#125;\n\t\n\tdfs(n - 1);&#x2F;&#x2F;构造n-1级图形\n\tint len &#x3D; 1;\n\tfor(int i &#x3D; 0; i &lt; n - 2; i++) len *&#x3D; 3;&#x2F;&#x2F;n-1级边长&#x3D;&#x3D;3^(n-2)\n\t&#x2F;&#x2F;用n-1级图画n级图\n\tint sx[4] &#x3D; &#123;0, 1, 2, 2&#125;, sy[4] &#x3D; &#123;2, 1, 0, 2&#125;;\n\tfor(int k &#x3D; 0; k &lt; 4; k++)\n\t\tfor(int i &#x3D; 0; i &lt; len; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; len; j++)\n\t\t\t\tg[sx[k] * len + i][sy[k] * len + j] &#x3D; g[i][j];\n&#125;\n\nint main()\n&#123;\n\tdfs(7);\n\t\n\tint n;\n\twhile(cin &gt;&gt; n, n !&#x3D; -1)\n\t&#123;\n\t\tint len &#x3D; 1;\n\t\twhile(--n) len *&#x3D; 3;&#x2F;&#x2F;n-1次\n\t\tfor(int i &#x3D; 0; i &lt; len; i++)\n\t\t&#123;\n\t\t\tfor(int j &#x3D; 0; j &lt; len; j++)\n\t\t\t\tif(g[i][j]) cout &lt;&lt; &#39;X&#39;;\n\t\t\t\telse cout &lt;&lt; &#39; &#39;;\n\t\t\tcout &lt;&lt; endl;\n\t\t&#125;\n\t\tcout &lt;&lt; &#39;-&#39; &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;袭击：分治 平面最近点对 预处理排序，递归内划分O(n)优化DAC\n&#x2F;&#x2F;1类点--&gt;2类点:同类点距离&#x3D;&#x3D;+INF\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 200010;\nconst double INF &#x3D; 1e10;\n\nstruct Point\n&#123;\n\tdouble x, y;\n\tbool type;\n\tbool operator &lt; (const Point &amp;W) const\n\t&#123;\n\t\treturn x &lt; W.x;\n\t&#125;\n&#125;points[N], temp[N];\n\ndouble dist(Point a, Point b)\n&#123;\n\tif(a.type &#x3D;&#x3D; b.type) return INF;\n\tdouble dx &#x3D; a.x - b.x, dy &#x3D; a.y - b.y;\n\treturn sqrt(dx * dx + dy * dy);\n&#125;\n\ndouble dfs(int l, int r)\n&#123;\n\tif(l &gt;&#x3D; r) return INF;\n\n\tint mid &#x3D; l + r &gt;&gt; 1;\n\tdouble mid_x &#x3D; points[mid].x;\n\tdouble res &#x3D; min(dfs(l, mid),dfs(mid + 1, r));&#x2F;&#x2F;归并排序-递归\n\t&#x2F;&#x2F;l和r的y有序性在递归步中merge掉，每层递归O(nlogn)-&gt;O(n) ！！！！\n\t&#123;&#x2F;&#x2F;归并排序-merge O(n)  y-sorted的l和r，代码块,临时变量\n\t\tint k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;\n\t\twhile(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n\t\t\tif(points[i].y &lt;&#x3D; points[j].y) temp[k++] &#x3D; points[i++];\n\t\t\telse temp[k++] &#x3D; points[j++];\n\t\twhile(i &lt;&#x3D; mid) temp[k++] &#x3D; points[i++];\n\t\twhile(j &lt;&#x3D; r) temp[k++] &#x3D; points[j++];\n\t\tfor(i &#x3D; 0, j &#x3D; l; i &lt; k; i++, j++) points[j] &#x3D; temp[i];\n\t&#125;\n\n\tint k &#x3D; 0;\n\tfor(int i &#x3D; l; i &lt;&#x3D; r; i++)\n\t\tif(points[i].x &gt;&#x3D; mid_x - res &amp;&amp; points[i].x &lt;&#x3D; mid_x + res)\n\t\t\ttemp[k++] &#x3D; points[i];\n\t&#x2F;&#x2F;条带内任意两点间找min距离, i&gt;j\n\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\tfor(int j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; temp[i].y - temp[j].y &lt;&#x3D; res; j--)\n\t\t\tres &#x3D; min(res, dist(temp[i], temp[j]));\n\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tint T, n;\n\tcin &gt;&gt; T;\n\twhile(T--)\n\t&#123;\n\t\tcin &gt;&gt; n;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; points[i].x &gt;&gt; points[i].y;\n\t\t\tpoints[i].type &#x3D; 0;\n\t\t&#125;\n\t\tfor (int i &#x3D; n; i &lt; n * 2; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; points[i].x &gt;&gt; points[i].y;\n\t\t\tpoints[i].type &#x3D; 1;\n\t\t&#125;\n\n\t\tsort(points, points + n * 2);\n\t\tprintf(&quot;%.3lf\\n&quot;, dfs(0, n * 2 - 1));\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;防线\n&#x2F;&#x2F;秦腾与教学评估 二分\n&#x2F;&#x2F;利用奇数最多就一个的限制。如果坐标0到当前枚举到的坐标ans间有奇数个人，\n&#x2F;&#x2F;那么那个奇数点一定在这中间。然后再迭代验证。注意要用int64来二分。\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 200010;\n\nstruct Seq\n&#123;\n\tint s, e, d;\n&#125;seqs[N];\n\nint n;&#x2F;&#x2F;n组防线\n\nLL get_sum(int x)&#x2F;&#x2F;防卫数的前缀和\n&#123;\n\tLL res &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; n; i++)&#x2F;&#x2F;第i组防线\n\t\tif(seqs[i].s &lt;&#x3D; x)\n\t\t\tres +&#x3D; (min(seqs[i].e, x) - seqs[i].s) &#x2F; seqs[i].d + 1;&#x2F;&#x2F;区间数+1&#x3D;端点数\n\treturn res;\n&#125;\n\n&#x2F;&#x2F; 用时cin &gt; ios::sync_with_stdio(false); + cin.tie(0),cout.tie(0) &gt; scanf\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\n\twhile (T -- )\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;n);\n\t\tint l &#x3D; 0, r &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\t&#123;\n\t\t\tint s, e, d;\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;s, &amp;e, &amp;d);\n\t\t\tseqs[i] &#x3D; &#123;s, e, d&#125;;\n\t\t\tr &#x3D; max(r, e);\n\t\t&#125;\n\t\t&#x2F;&#x2F;二分\n\t\twhile (l &lt; r)\n\t\t&#123;\n\t\t\tint mid &#x3D; (LL)l + r &gt;&gt; 1;\n\t\t\tif (get_sum(mid) &amp; 1) r &#x3D; mid;\n\t\t\telse l &#x3D; mid + 1;\n\t\t&#125;\n\n\t\tauto sum &#x3D; get_sum(r) - get_sum(r - 1);\n\n\t\tif (sum % 2 &#x3D;&#x3D; 0) puts(&quot;There&#39;s no weakness.&quot;);\n\t\telse printf(&quot;%d %lld\\n&quot;, r, sum);&#x2F;&#x2F;Linux:lld win:I64d\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;赶牛入圈\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 1010;\n\nint n, C;&#x2F;&#x2F;max点数&gt;&#x3D;C\nPII points[N];\nvector&lt;int&gt; numbers;&#x2F;&#x2F;离散化后的数\nint sum[N][N];&#x2F;&#x2F;前缀和\n\nint get(int x)&#x2F;&#x2F;2分找值为x的numbers[下标!!!]\n&#123;\n\tint l &#x3D; 0, r &#x3D; numbers.size() - 1;\n\twhile(l &lt; r)\n\t&#123;\n\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\tif(numbers[mid] &gt;&#x3D; x) r &#x3D; mid;&#x2F;&#x2F;&gt;&#x3D;x:左半,&lt;x:右半\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\treturn r;\n&#125;\n\nbool check(int len)&#x2F;&#x2F;边长为len的窗口在所有点坐标域滑动,num[下标]&#x3D;(映射为)&#x3D;原x,y值, 判断窗口内点数部分和&gt;&#x3D;C否\n&#123;\n\tfor(int x1 &#x3D; 0, x2 &#x3D; 1; x2 &lt; numbers.size(); x2++)\n\t&#123;\n\t\twhile(numbers[x2] - numbers[x1 + 1] + 1 &gt; len) x1++;&#x2F;&#x2F;x1是&lt;len区间左端点的第一个(max)点\n\t\tfor(int y1 &#x3D; 0, y2 &#x3D; 1; y2 &lt; numbers.size(); y2++)\n\t\t&#123;\n\t\t\twhile(numbers[y2] - numbers[y1 + 1] + 1 &gt; len) y1++;\n\t\t\tif(sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1] &gt;&#x3D; C)\n\t\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; C &gt;&gt; n;\n\tnumbers.push_back(0);\n\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tint x, y;\n\t\tcin &gt;&gt; x &gt;&gt; y;\n\t\tpoints[i] &#x3D; &#123;x, y&#125;;\n\t\tnumbers.push_back(x);\n\t\tnumbers.push_back(y);\n\t&#125;\n\t\n\tsort(numbers.begin(), numbers.end());\n\t&#x2F;&#x2F;去重：unique将重复元素至尾，返回last非重元素pos，erase去掉末尾重复元素\n\tnumbers.erase(unique(numbers.begin(), numbers.end()), numbers.end());\n\t\n\t&#x2F;&#x2F;离散化x,y 得到i,j点的sum[i][j]\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tint x &#x3D; get(points[i].first), y &#x3D; get(points[i].second);\n\t\tsum[x][y]++;\n\t&#125;\n\t&#x2F;&#x2F;前缀和\n\tfor (int i &#x3D; 1; i &lt; numbers.size(); i++)\n\t\tfor (int j &#x3D; 1; j &lt; numbers.size(); j++)\n\t\t\tsum[i][j] +&#x3D; sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n\t&#x2F;&#x2F;2分找min_len\n\tint l &#x3D; 1, r &#x3D; 10000;\n\twhile(l &lt; r)\n\t&#123;\n\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\tif(check(mid)) r &#x3D; mid;&#x2F;&#x2F;满足&gt;&#x3D;C,继续缩小\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\tcout &lt;&lt; r &lt;&lt; endl;&#x2F;&#x2F;点数&gt;&#x3D;C的min_len\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;糖果传递\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 1000010;\n\nint n;\nLL a[N];\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tLL sum &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tscanf(&quot;%lld&quot;, &amp;a[i]);\n\t\tsum +&#x3D; a[i];\n\t&#125;\n\tsum &#x2F;&#x3D; n;\n\tfor (int i &#x3D; n; i &gt; 1; i--)&#x2F;&#x2F;x[i] &#x3D; x1-a[i]\n\t&#123;\n\t\ta[i] &#x3D; sum - a[i] + a[i+1];&#x2F;&#x2F;a[i]&#x3D;a[i+1]+(avg-a[i]) &lt;---a[n+1]&#x3D;0\n\t&#125;\n\ta[1] &#x3D; 0;&#x2F;&#x2F;x1 &#x3D; x1-(a[i]&#x3D;0)\n\n\tsort(a + 1, a + n + 1);\n\tLL res &#x3D; 0;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) res +&#x3D; abs(a[i] - a[(n + 1) &#x2F; 2]);\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;士兵\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 10010;\n\nint n;\nint x[N], y[N];\n\nint work(int *q)\n&#123;\n\tint res &#x3D; 0;\n\tsort(q, q+n);\n\tfor(int i &#x3D; 0; i &lt; n; i++) res +&#x3D; abs(q[i] - q[i&#x2F;2]);&#x2F;&#x2F;0+1+1+2+2 \n\t&#x2F;&#x2F;或&#x3D;&#x3D; 2+1+0+1+2: res +&#x3D; abs(q[i] - q[n&#x2F;2]);\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; x[i] &gt;&gt; y[i];\n\tsort(x, x + n);\n\tfor(int i &#x3D; 0; i &lt; n; i++) x[i] -&#x3D; i;\n\t\n\tcout &lt;&lt; work(y) + work(x) &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数的进制转换\n&#x2F;&#x2F;进制a---&gt;10---%b---&gt;b   &#x2F;b%b ,  a--直接-&gt;b\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile(T--)\n\t&#123;\n\t\tint a, b;\n\t\tstring a_line, b_line;\n\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; a_line;\n\t\t\n\t\tvector&lt;int&gt; number;\n\t\tfor(auto c : a_line)\n\t\t&#123;\n\t\t\tif(c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) number.push_back(c - &#39;0&#39;);\n\t\t\tif(c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39;) number.push_back(c - &#39;A&#39; + 10);\n\t\t\tif(c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) number.push_back(c - &#39;a&#39; + 36);\n\t\t&#125;\n\t\treverse(number.begin(), number.end());&#x2F;&#x2F;低到高\n\t\t\n\t\tvector&lt;int&gt; res;\n\t\twhile(number.size())&#x2F;&#x2F;直到商&#x3D;&#x3D;0\n\t\t&#123;\n\t\t\tint r &#x3D; 0;\n\t\t\tfor(int i &#x3D; number.size() - 1; i &gt;&#x3D; 0; i--)\n\t\t\t&#123;\n\t\t\t\tnumber[i] +&#x3D; r * a;&#x2F;&#x2F; cur位 +&#x3D; 高位余数 * a进制\n\t\t\t\tr &#x3D; number[i] % b;&#x2F;&#x2F;余数\n\t\t\t\tnumber[i] &#x2F;&#x3D; b;&#x2F;&#x2F;商\n\t\t\t&#125;\n\t\t\tres.push_back(r);\n\t\t\t&#x2F;&#x2F;去掉末尾的高位前导零\n\t\t\twhile(number.size() &amp;&amp; number.back() &#x3D;&#x3D; 0) number.pop_back();\n\t\t&#125;\n\t\treverse(res.begin(), res.end());\n\t\t\n\t\tfor(auto x : res)\n\t\t&#123;\n\t\t\tif(x &lt;&#x3D; 9) b_line +&#x3D; char(x + &#39;0&#39;);\n\t\t\tif(x &gt;&#x3D; 10 &amp;&amp; x &lt;&#x3D; 35) b_line +&#x3D; char(x - 10 + &#39;A&#39;);\n\t\t\tif(x &gt;&#x3D; 36) b_line +&#x3D; char(x - 36 + &#39;a&#39;);\n\t\t&#125;\n\t\tcout &lt;&lt; a &lt;&lt; &#39; &#39; &lt;&lt; a_line &lt;&lt; endl;\n\t\tcout &lt;&lt; b &lt;&lt; &#39; &#39; &lt;&lt; b_line &lt;&lt; endl;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;耍杂技的牛  国王游戏 贪心   pair可比大小，vector字典序比较 \n#include &lt;limits.h&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 50010;\n\nint n;\nPII cows[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tint  w, s;\n\t\tcin &gt;&gt; w &gt;&gt; s;\n\t\tcows[i] &#x3D; &#123;w + s, w&#125;;&#x2F;&#x2F;！！！！！！\n\t&#125;\n\tsort(cows, cows + n);\n\n\tint sum &#x3D; 0, res &#x3D; INT_MIN;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tint w &#x3D; cows[i].second, s &#x3D; cows[i].first - w;\n\t\tres &#x3D; max(res, sum - s);\n\t\tsum +&#x3D; w;\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;最大子矩阵的和\n#include &lt;limits.h&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110;\n\nint n;\nint g[N][N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; g[i][j];\n\t\t\tg[i][j] +&#x3D; g[i-1][j];\n\t\t&#125;&#x2F;&#x2F;g:一列值的前缀和\n\n\tint res &#x3D; INT_MIN;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; i; j &lt;&#x3D; n; j++)&#x2F;&#x2F;j &gt;&#x3D; i\n\t\t&#123;\n\t\t\tint last &#x3D; 0;\n\t\t\tfor (int k &#x3D; 1; k &lt;&#x3D; n; k++)\n\t\t\t&#123;\n\t\t\t\tlast &#x3D; max(last, 0) + g[j][k] - g[i-1][k];\n\t\t\t\t&#x2F;&#x2F;第k列第i行到第j行的竖条 求max子和\n\t\t\t\tres &#x3D; max(res, last);\n\t\t\t&#125;\n\t\t&#125;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;任务 排序贪心\n&#x2F;&#x2F;首先考虑了所有的任务，然后尽可能的在可行的机器中选择来适配它，并且又尽量选择能力较差的机器，使得剩余的机器能够匹配的任务数量的期望更大，从而保证了任务数量尽量多。\n&#x2F;&#x2F;最大价值和（点权max match）：500x+2y 先time后prio降序遍历\n&#x2F;&#x2F; 如果x范围开大点，就只能离散化或者用set了\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nPII mchs[N], tasks[N];\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; mchs[i].first &gt;&gt; mchs[i].second;\n\t\tfor (int i &#x3D; 0; i &lt; m; i ++ ) cin &gt;&gt; tasks[i].first &gt;&gt; tasks[i].second;\n\t\tsort(mchs, mchs + n);\n\t\tsort(tasks, tasks + m);\n\t\tmultiset&lt;int&gt; ys;&#x2F;&#x2F;不去重\n\t\tLL cnt &#x3D; 0, res &#x3D; 0;\n\t\tfor (int i &#x3D; m - 1, j &#x3D; n - 1; i &gt;&#x3D; 0; i -- )&#x2F;&#x2F;i:task j:machine\n\t\t&#123;\n\t\t\tint x &#x3D; tasks[i].first, y &#x3D; tasks[i].second;\n\t\t\twhile (j &gt;&#x3D; 0 &amp;&amp; mchs[j].first &gt;&#x3D; x) ys.insert(mchs[j -- ].second);\n\t\t\tauto it &#x3D; ys.lower_bound(y);\n\t\t\tif (it !&#x3D; ys.end())\n\t\t\t&#123;\n\t\t\t\tcnt ++ ;\n\t\t\t\tres +&#x3D; 500 * x + 2 * y;\n\t\t\t\tys.erase(it);\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; cnt &lt;&lt; &#39; &#39; &lt;&lt; res &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\nyxc\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;27694&#x2F;\n秦淮岸\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;868&#x2F;\n&#x2F;*\n#define fir(i,a,b) for (ll i&#x3D;a;i&lt;&#x3D;b;i++)\nSTL慢：new动态开内存\n优化：-o2\nvector&lt;int&gt; a(100000);\na.resize(1000);\n*&#x2F;\n\n-----------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>\n\n\n\n<h1 id=\"0x10基本数据结构\"><a href=\"#0x10基本数据结构\" class=\"headerlink\" title=\"0x10基本数据结构\"></a>0x10基本数据结构</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;0x11 栈\n&#x2F;&#x2F;编辑器  对顶栈\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;limits.h&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint stkl[N], stkr[N], tl, tr;\nint s[N], f[N];\n\nvoid push_left(int x)\n&#123;\n\tstkl[++tl] &#x3D; x;\n\ts[tl] &#x3D; s[tl - 1] + x;\n\tf[tl] &#x3D; max(f[tl-1], s[tl]);\n&#125;\n\nint main()\n&#123;\n\tint n;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tf[0] &#x3D; INT_MIN;\n\twhile(n--)\n\t&#123;\n\t\tchar str[2];\n\t\tint x;\n\t\tscanf(&quot;%s&quot;, str);\n\t\tif(*str &#x3D;&#x3D; &#39;I&#39;)\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\tpush_left(x);\n\t\t&#125;\n\t\telse if(*str &#x3D;&#x3D; &#39;D&#39;)\n\t\t&#123;\n\t\t\tif(tl &gt; 0) tl--;&#x2F;&#x2F;tl，tr: &gt;0才能-- ！！！！！！！！\n\t\t&#125;\n\t\telse if(*str &#x3D;&#x3D; &#39;L&#39;)\n\t\t&#123;\n\t\t\tif(tl &gt; 0) stkr[++tr] &#x3D; stkl[tl--];\n\t\t&#125;\n\t\telse if(*str &#x3D;&#x3D; &#39;R&#39;)\n\t\t&#123;\n\t\t\tif(tr &gt; 0) push_left(stkr[tr--]);   \n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\tprintf(&quot;%d\\n&quot;, f[x]);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;火车进栈 递归枚举\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint n, cnt &#x3D; 20;&#x2F;&#x2F;字典序前20的ans\nvector&lt;int&gt; state1;\nstack&lt;int&gt; state2;\nint state3 &#x3D; 1;&#x2F;&#x2F;（小到大 1-&gt;n）未入3-&gt;栈2-&gt;出1\nvoid dfs()\n&#123;\n\tif(!cnt) return;\n\tif(state1.size() &#x3D;&#x3D; n)&#x2F;&#x2F;输出\n\t&#123;\n\t\tcnt--;\n\t\tfor(auto x : state1) cout &lt;&lt; x;\n\t\tcout &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tif(state2.size())&#x2F;&#x2F;每一步：先出栈\n\t&#123;\n\t\tstate1.push_back(state2.top());&#x2F;&#x2F;op\n\t\tstate2.pop();\n\t\tdfs();&#x2F;&#x2F;递归\n\t\tstate2.push(state1.back());&#x2F;&#x2F;还原\n\t\tstate1.pop_back();\n\t&#125;\n\n\tif(state3 &lt;&#x3D; n)&#x2F;&#x2F;后入栈\n\t&#123;\n\t\tstate2.push(state3);\n\t\tstate3++;\n\t\tdfs();\n\t\tstate3--;\n\t\tstate2.pop();\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tdfs();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;第一版 高精度求Catalan(n) 1s内：上限37000+\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 6000010;\nLL res[N], tt;\n\nvoid multi(int b)\n&#123;\n\tLL t &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt;&#x3D; tt; i++)\n\t&#123;\n\t\tres[i] &#x3D; res[i] * b + t;\n\t\tt &#x3D; res[i] &#x2F; 1000000000;\n\t\tres[i] %&#x3D; 1000000000;\n\t&#125;\n\twhile(t)\n\t&#123;\n\t\tres[++tt] &#x3D; t % 1000000000;\n\t\tt &#x2F;&#x3D; 1000000000;\n\t&#125;\n&#125;\n\nvoid div(int b)\n&#123;\n\tLL t &#x3D; 0;\n\tfor(int i &#x3D; tt; i &gt;&#x3D; 0; i--)\n\t&#123;\n\t\tres[i] +&#x3D; t * 1000000000;\n\t\tt &#x3D; res[i] % b;\n\t\tres[i] &#x2F;&#x3D; b;\n\t&#125;\n\twhile(!res[tt]) tt--;\n&#125;\n\nint main()\n&#123;\n\tint n;\n\tcin &gt;&gt; n;\n\ttt &#x3D; 0;\n\tres[0] &#x3D; 1;\n\tfor(int i &#x3D; n * 2, j &#x3D; n; j &gt; 0; i--, j--)\n\t&#123;\n\t\tmulti(i);\n\t\tdiv(j);\n\t&#125;&#x2F;&#x2F;1*(2n*...*n&#x2F;1*...*n)\n\tdiv(n+1);\n\t\n\tprintf(&quot;%lld&quot;, res[tt]);\n\tfor(int i &#x3D; tt - 1; i &gt;&#x3D; 0; i--) printf(&quot;%09lld&quot;, res[i]);\n\tcout &lt;&lt; endl;\n\treturn 0;\n&#125;\n&#x2F;* \nint类型占32bit 可表示范围： [-2147483648，2147483647] \nlong long类型 64bit可表示范围：[-9223372036854775808，9223372036854775807]\n\nint可以完整表达9位数字，long long可以完整表达18位。\n所谓高精度就是用数组来充当数字的容器。开辟若干个空间，每个单元内存放固定数目的数据。\n\n高精度常用的方法主要有：不压缩法、压缩4位法、和压缩9位的方法。\n为什么是四位呢？因为int类型能完整表达9位以内的任何数字。而存储四位数字是因为在进行《乘法运算时，很可能会存在四位×四位的情况，而其结果不会超过八位。》int类型完全可以存储。如果存放四位以上的数字的时候，int不能完整的存放其结果，因而无法正确计算。\n三种方式归根结底都是进制的转换问题：普通不压缩法相当于十进制，四位压缩法相当于一万进制，九位压缩法相当于十亿进制。\n\n三种方法的时间效率不同：假设两个数进行四则运算。运用普通法存储拥有最多的单位，其次是四位压缩法，最少是九位压缩法。进行加法运算时，两个数组中，以其中一个数组为起点，使其各个单元与另一个数组的各个单元进行相加运算。其时间复杂度为O（n^2）级。因此压缩9位存储法开辟的单元少，所以消耗的时间最少。\n*&#x2F;\n&#x2F;&#x2F;第二版 素因数分解求 Catalan(n) n&#x3D;60000  1s\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 120010;\n\nint powers[N];&#x2F;&#x2F;pi的次数\nint primes[N], cnt;\nbool st[N];\n\nvoid get_primes(int n)&#x2F;&#x2F;埃氏筛法\n&#123;\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t\tif(!st[i])&#x2F;&#x2F;st[i]是质数 \n\t\t&#123;\n\t\t\tprimes[cnt++] &#x3D; i;\n\t\t\tfor(int j &#x3D; i * 2; j &lt;&#x3D; n; j +&#x3D; i)\n\t\t\t\tst[j] &#x3D; true;\n\t\t&#125;\n&#125;\n\nint get(int n, int p)&#x2F;&#x2F;n!中质因子p的个数\n&#123;\n\tint s &#x3D; 0;\n\twhile(n) s +&#x3D; n &#x2F; p, n &#x2F;&#x3D; p;\n\treturn s;\n&#125;\n\n\nvoid multi(vector&lt;LL&gt; &amp;a, int b)&#x2F;&#x2F;大*小\n&#123;\n\tint t &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; a.size(); i++)\n\t&#123;\n\t\ta[i] &#x3D; a[i] * b + t;\n\t\tt &#x3D; a[i] &#x2F; 1000000000;\n\t\ta[i] %&#x3D; 1000000000;\n\t&#125;\n\twhile(t)\n\t&#123;\n\t\ta.push_back(t % 1000000000);\n\t\tt &#x2F;&#x3D; 1000000000;\n\t&#125;\n&#125;\n\nvoid out(vector&lt;LL&gt; &amp;a)\n&#123;&#x2F;&#x2F;高到低倒取\n\tprintf(&quot;%lld&quot;, a.back());&#x2F;&#x2F;first不用补0\n\tfor(int i &#x3D; a.size() - 2; i &gt;&#x3D; 0; i--) printf(&quot;%09lld&quot;, a[i]);&#x2F;&#x2F;补0\n\tcout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n\tint n;\n\tcin &gt;&gt; n;\n\tget_primes(n * 2);\n\t\n\tfor(int i &#x3D; 0; i &lt; cnt; i++)\n\t&#123;\n\t\tint p &#x3D; primes[i];\n\t\tpowers[p] &#x3D; get(n * 2, p) - get(n, p) * 2;\n\t&#125;\n\t&#x2F;&#x2F; (2n!)&#x2F;(n!n!)&#x2F;(n+1)\n\tint k &#x3D; n + 1;\n\tfor(int i &#x3D; 0; i &lt; cnt &amp;&amp; primes[i] &lt;&#x3D; k; i++)&#x2F;&#x2F;n很小，2n内p只有cnt个\n\t&#x2F;&#x2F;i &lt; cnt，否则 float point exception除0错误\n\t&#123;\n\t\tint p &#x3D; primes[i], s &#x3D; 0;\n\t\twhile(k % p &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\ts++;\n\t\t\tk &#x2F;&#x3D; p;\n\t\t&#125;\n\t\tpowers[p] -&#x3D; s;\n\t&#125;\n\tvector&lt;LL&gt; res;\n\tres.push_back(1);\n\t\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n * 2; i++)\n\t\tfor(int j &#x3D; 0; j &lt; powers[i]; j ++)\n\t\t\tmulti(res, i);&#x2F;&#x2F;低到高存\n\t\n\tout(res);\n\treturn 0;\n&#125;\n--------------------------------------------------------------------\n&#x2F;&#x2F;直方图中最大的矩形  单调栈(递增) O(N)\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 100010;\n\nint n;\nint h[N], q[N], l[N], r[N];\n\nvoid get(int bound[N])&#x2F;&#x2F;单调栈模板 栈顶q[tt] 记录第一个比它矮的下标\n&#123;\n\tint tt &#x3D; 0;\n\th[0] &#x3D; -1;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\twhile(h[q[tt]] &gt;&#x3D; h[i]) tt--;\n\t\tbound[i] &#x3D; q[tt];\n\t\tq[++tt] &#x3D; i;\n\t&#125;\n\t\n&#125;\n\nint main()\n&#123;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; h[i];\n\t\tget(l);\n\t\treverse(h + 1, h + 1 + n);\n\t\tget(r);\n\n\t\t&#x2F;&#x2F;修正\n\t\treverse(h + 1, h + 1 + n);&#x2F;&#x2F;3315412\n\t\treverse(r + 1, r + 1 + n);&#x2F;&#x2F;0003306 \n\t\t&#x2F;&#x2F;r顺序对了，值不对!!!!把终点n+1当起点0了\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tr[i] &#x3D; n + 1 - r[i];\n\t\t\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tres &#x3D; max(res, h[i] * (r[i] - l[i] - 1ll));\n&#x2F;*      &#x2F;&#x2F;yxc\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; 1, j &#x3D; n; i &lt;&#x3D; n; i++, j--)\n\t\t\tres &#x3D; max(res, h[i] * (n + 1 - l[j] - r[i] - 1ll));\n*&#x2F;\n&#x2F;* \n\t\treverse(h + 1, h+ 1 + n);\n\t\treverse(r + 1, r + 1 + n);\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tres &#x3D; max(res, h[i] * (n + 1 - r[i] - l[i] - 1ll));\n*&#x2F;\n\t\tcout &lt;&lt; res &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n&#x2F;*\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\n&#x2F;&#x2F;l[i], r[i]表示第i个矩形的高度可向两侧扩展的左右边界\nint h[N], q[N], l[N], r[N];\n\ntypedef long long LL;\n\nint main()\n&#123;\n\tint n;\n\twhile(scanf(&quot;%d&quot;, &amp;n), n)\n\t&#123;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i ++)  scanf(&quot;%d&quot;, &amp;h[i]);\n\t\th[0] &#x3D; h[n + 1] &#x3D; -1;\n\n\t\tint tt &#x3D; -1;\n\t\tq[++ tt] &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i ++)\n\t\t&#123;\n\t\t\twhile(h[q[tt]] &gt;&#x3D; h[i])  tt --;\n\t\t\tl[i] &#x3D; i - q[tt];\n\t\t\tq[++ tt] &#x3D; i;\n\t\t&#125;\n\n\t\ttt &#x3D; -1;\n\t\tq[++ tt] &#x3D; n + 1;\n\t\tfor(int i &#x3D; n; i; i --)\n\t\t&#123;\n\t\t\twhile(h[q[tt]] &gt;&#x3D; h[i])  tt --;\n\t\t\tr[i] &#x3D; q[tt] - i;\n\t\t\tq[++ tt] &#x3D; i;\n\t\t&#125;\n\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i ++)  res &#x3D; max(res, (LL)h[i] * (l[i] + r[i] - 1));\n\t\tprintf(&quot;%lld\\n&quot;, res);\n\t&#125;\n\treturn 0;\n&#125;\n*&#x2F;\n\n&#x2F;&#x2F;官方标程\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt; \n#include&lt;algorithm&gt;\nusing namespace std;\nint n,p;\nint a[100010];\nint s[100010],w[100010];\nlong long ans;\n\nint main()\n&#123;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tans &#x3D; 0; p &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\t\ta[n+1] &#x3D; 0;&#x2F;&#x2F;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n+1; i++)\n\t\t&#123;\n\t\t\tif(a[i] &gt; s[p]) s[++p] &#x3D; a[i], w[p] &#x3D; 1;\n\t\t\telse&#123;\n\t\t\t\tint width &#x3D; 0;\n\t\t\t\twhile(s[p] &gt; a[i])\n\t\t\t\t&#123;\n\t\t\t\t\twidth +&#x3D; w[p];&#x2F;&#x2F;\n\t\t\t\t\tans &#x3D; max(ans, (long long)width * s[p]);\n\t\t\t\t\tp--;\n\t\t\t\t&#125;\n\t\t\t\ts[++p] &#x3D; a[i], w[p] &#x3D; width + 1;&#x2F;&#x2F; w[p]:top以左降序块宽度\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n&#125;\n--------------------------------------------------------------------\n&#x2F;&#x2F;0x12 队列\n&#x2F;&#x2F;小组队列\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010, M &#x3D; 1000010;\n&#x2F;&#x2F; 需注意：测试用例最多可包含200000（20万）个命令，1000组\n&#x2F;&#x2F; 因此小组队列的实现应该是高效的:入队和出队都需要使用常数时间。\nint teamid[M];&#x2F;&#x2F;teamid[人num] &#x3D; 组id!!!!!!\n\nint main()\n&#123;\n\tint n, C &#x3D; 1;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tprintf(&quot;Scenario #%d\\n&quot;, C++);\n\t\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tint cnt;\n\t\t\tcin &gt;&gt; cnt;\n\t\t\twhile(cnt--)\n\t\t\t&#123;\n\t\t\t\tint x;\n\t\t\t\tcin &gt;&gt; x;\n\t\t\t\tteamid[x] &#x3D; i;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tqueue&lt;int&gt; team;&#x2F;&#x2F;组间 循环队列\n\t\tqueue&lt;int&gt; person[N];&#x2F;&#x2F;&lt;N个组内queue\n\n\t\tstring command;\n\t\twhile(cin &gt;&gt; command, command !&#x3D; &quot;STOP&quot;)\n\t\t&#123;\n\t\t\tif(command &#x3D;&#x3D; &quot;ENQUEUE&quot;)\n\t\t\t&#123;\n\t\t\t\tint x;\n\t\t\t\tcin &gt;&gt; x;\n\t\t\t\tint tid &#x3D; teamid[x];\n\t\t\t\tif(person[tid].empty()) team.push(tid);\n\t\t\t\tperson[tid].push(x);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tint tid &#x3D; team.front();\n\t\t\t\tauto &amp;q &#x3D; person[tid];\n\t\t\t\tcout &lt;&lt; q.front() &lt;&lt; endl;\n\t\t\t\tq.pop();\n\t\t\t\tif(q.empty()) team.pop();\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;蚯蚓\n&#x2F;&#x2F;puts(str);向标准输出设备（屏幕）输出字符串并换行，具体为：把字符串输出到标准输出设备，将&#39;\\0&#39;转换为回车换行。\n&#x2F;&#x2F;puts(&quot;&quot;); &#x3D;&#x3D; cout &lt;&lt; endl;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits.h&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010, M &#x3D; 7000010;\n\nint n, m, q, u, v, t;\nint q1[N], q2[M], q3[M];\nint hh1, hh2, hh3, tt1, tt2 &#x3D; -1, tt3 &#x3D; -1;\nint delta;\n\nint get_max()\n&#123;\n\tint x &#x3D; INT_MIN;\n\tif (hh1 &lt;&#x3D; tt1) x &#x3D; max(x, q1[hh1]);&#x2F;&#x2F;get_max\n\tif (hh2 &lt;&#x3D; tt2) x &#x3D; max(x, q2[hh2]);\n\tif (hh3 &lt;&#x3D; tt3) x &#x3D; max(x, q3[hh3]);\n\tif (hh1 &lt;&#x3D; tt1 &amp;&amp; x &#x3D;&#x3D; q1[hh1]) hh1 ++ ;&#x2F;&#x2F;delete_max\n\telse if (hh2 &lt;&#x3D; tt2 &amp;&amp; x &#x3D;&#x3D; q2[hh2]) hh2 ++ ;\n\telse hh3 ++ ;\n\treturn x;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t);\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q1[i]);\n\tsort(q1, q1 + n);\n\treverse(q1, q1 + n);\n\ttt1 &#x3D; n - 1;\n\t\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\tint x &#x3D; get_max();\n\t\tx +&#x3D; delta;&#x2F;&#x2F;1!!!\n\t\tif (i % t &#x3D;&#x3D; 0) printf(&quot;%d &quot;, x);\n\t\tint left &#x3D; x * 1ll * u &#x2F; v;\n\t\tint right &#x3D; x - left;\n\t\tdelta +&#x3D; q;&#x2F;&#x2F;2!!!\n\t\tq2[ ++ tt2] &#x3D; left - delta, q3[ ++ tt3] &#x3D; right - delta;&#x2F;&#x2F;3!!!\n\t&#125;\n\tputs(&quot;&quot;);\n\t\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n + m; i ++ )&#x2F;&#x2F;!!!\n\t&#123;\n\t\tint x &#x3D; get_max();\n\t\tif (i % t&#x3D;&#x3D; 0) printf(&quot;%d &quot;, x + delta);\n\t&#125;\n\tputs(&quot;&quot;);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;双端队列\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits.h&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 200010;\n\nint n;\nPII a[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; a[i].first;\n\t\ta[i].second &#x3D; i;\n\t&#125;\n\tsort(a, a + n);\n\t\n\tint res &#x3D; 1, last &#x3D; INT_MAX, dir &#x3D; -1;\n\tfor(int i &#x3D; 0; i &lt; n;)\n\t&#123;\n\t\tint j &#x3D; i;\n\t\twhile(j &lt; n &amp;&amp; a[j].first &#x3D;&#x3D; a[i].first) j++;&#x2F;&#x2F; val&#x3D; 的一段[i,j-1]\n\t\t\n\t\tint minp &#x3D; a[i].second, maxp &#x3D; a[j-1].second;\n\t\tif(dir &#x3D;&#x3D; -1)\n\t\t&#123;\n\t\t\tif(last &gt; maxp) last &#x3D; minp;&#x2F;&#x2F;下续\n\t\t\telse dir &#x3D; 1, last &#x3D; maxp;&#x2F;&#x2F;上拐\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tif(last &lt; minp) last &#x3D; maxp;&#x2F;&#x2F;上续\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tres ++ ;\n\t\t\t\tdir &#x3D; -1;\n\t\t\t\tlast &#x3D; minp;&#x2F;&#x2F;下拐\n\t\t\t&#125;\n\t\t&#125;\n\t\ti &#x3D; j;\n\t&#125;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;最大子序和  单调队列(递减)\n#include &lt;iostream&gt;\n#include &lt;limits.h&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 300010;\n\nint n, m;\nint q[N];\nLL s[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; s[i];\n\t\ts[i] +&#x3D; s[i-1];\n\t&#125;\n\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\tLL res &#x3D; INT_MIN;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tif(i - q[hh] &gt; m) hh++;\n\t\tres &#x3D; max(res, s[i] - s[q[hh]]);\n\t\twhile(hh &lt;&#x3D; tt &amp;&amp; s[q[tt]] &gt;&#x3D; s[i]) tt--;\n\t\tq[++tt] &#x3D; i;\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x13 链表 邻接表\n&#x2F;&#x2F;邻值查找\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 100010;\n\nint n;\nint p[N], l[N], r[N];&#x2F;&#x2F;l r&#x3D;&#x3D;prev next指针\nPII a[N], ans[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; a[i].first;\n\t\ta[i].second &#x3D; i;\n\t&#125;\n\tsort(a + 1, a + 1 + n);\n\n\ta[0].first &#x3D; 1e9, a[n+1].first &#x3D; -1e9;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tl[i] &#x3D; i - 1, r[i] &#x3D; i + 1;\n\t\tp[a[i].second] &#x3D; i;&#x2F;&#x2F;p[原pos]&#x3D;新pos\n\t&#125;\n\n\tfor (int i &#x3D; n; i &gt; 1; i--)\n\t&#123;\n\t\tint j &#x3D; p[i], left &#x3D; l[j], right &#x3D; r[j];\n\t\tint lv &#x3D; abs(a[j].first - a[left].first);\n\t\tint rv &#x3D; abs(a[j].first - a[right].first);\n\t\tif(lv &lt;&#x3D; rv) ans[i] &#x3D; &#123;lv, a[left].second&#125;;\n\t\telse ans[i] &#x3D; &#123;rv, a[right].second&#125;;&#x2F;&#x2F;min_abs&#x3D;&#x3D;时,A[j]&#x3D;val:min\n\t\t&#x2F;&#x2F;而不是j&#x3D;下标:min\n\t\t&#x2F;&#x2F; else if(lv &gt; rv) ans[i] &#x3D; &#123;rv, a[right].second&#125;;\n\t\t&#x2F;&#x2F; else ans[i] &#x3D; &#123;lv, min(a[left].second,a[right].second)&#125;;\n\n\t\tr[left] &#x3D; right, l[right] &#x3D; left;\n\t&#125;\n\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t\tcout &lt;&lt; ans[i].first &lt;&lt; &#39; &#39; &lt;&lt; ans[i].second &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;解法二: set版        ！！！！！！！！！！！！！！！！！！！！！！！！！\n#include &lt;set&gt;\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int INF &#x3D; 0x7f7f7f7f;\nset&lt;pair&lt;int, int&gt; &gt; s;\n\nint main() &#123;\n\tint n, a;\n\tcin &gt;&gt; n &gt;&gt; a;\n\ts.insert(&#123;a, 1&#125;);\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;a);\n\t\ts.insert(&#123;a, i&#125;);\n\t\tset&lt;pair&lt;int, int&gt; &gt;::iterator it &#x3D; s.find(&#123;a, i&#125;);\n\t\tpair&lt;int, int&gt; ans;\n\t\tans.first &#x3D; INF;\n\t\tif (++it !&#x3D; s.end())\n\t\t\tans &#x3D; &#123;(*it).first - a, (*it).second&#125;;\n\t\tit &#x3D; s.find(&#123;a, i&#125;);\n\t\tif (it-- !&#x3D; s.begin() &amp;&amp; ans.first &gt;&#x3D; a - (*it).first)\n\t\t\tans &#x3D; &#123;a - (*it).first, (*it).second&#125;;\n\t\tcout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x14 hash表\n&#x2F;&#x2F;雪花雪花雪花\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n;\nint snows[N][6], idx[6];\n\nbool cmp_array(int a[], int b[])\n&#123;\n\tfor (int i &#x3D; 0; i &lt; 6; i++)\n\t\t&#x2F;&#x2F; if(a[i] &gt; b[i]) return false;\n\t\treturn (a[i] &lt; b[i]) ? true : false;\n\t&#x2F;&#x2F; return false;\n&#125;\n\nbool cmp(int a, int b)\n&#123;\n\treturn cmp_array(snows[a], snows[b]);\n&#125;\n\nvoid get_min(int a[])\n&#123;\n\tstatic int b[12];\n\tfor (int i &#x3D; 0; i &lt; 12; i++) b[i] &#x3D; a[i % 6];\n\n\tint i &#x3D; 0, j &#x3D; 1, k;\n\twhile(i &lt; 6 &amp;&amp; j &lt; 6)\n\t&#123;\n\t\tfor (k &#x3D; 0; k &lt; 6 &amp;&amp; b[i+k] &#x3D;&#x3D; b[j+k]; k++);\n\t\t\tif(k &#x3D;&#x3D; 6) break;\n\t\tif(b[i + k] &gt; b[j + k])\n\t\t&#123;\n\t\t\ti +&#x3D; k + 1;\n\t\t\tif(i &#x3D;&#x3D; j) i++;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tj +&#x3D; k + 1;\n\t\t\tif(i &#x3D;&#x3D; j) j++;\n\t\t&#125;\n\t&#125;\n\tk &#x3D; min(i, j);\n\tfor(i &#x3D; 0; i &lt; 6; i++) a[i] &#x3D; b[i + k];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tint snow[6], isnow[6];\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0, k &#x3D; 5; j &lt; 6; j++, k--)\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;snow[j]);\n\t\t\tisnow[k] &#x3D; snow[j];\n\t\t&#125;\n\t\tget_min(snow);\n\t\tget_min(isnow);\n\t\t\n\t\tif(cmp_array(snow, isnow)) memcpy(snows[i], snow, sizeof snow);\n\t\telse memcpy(snows[i], isnow, sizeof isnow);\n\n\t\tidx[i] &#x3D; i;\n\t&#125;\n\tsort(idx, idx + n, cmp);\n\n\tbool flag &#x3D; false;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tif(!cmp(idx[i-1], idx[i]) &amp;&amp; !cmp(idx[i], idx[i-1]))\n\t\t&#123;\n\t\t\tflag &#x3D; true;\n\t\t\tbreak;\n\t\t&#125;\n\tif(flag) puts(&quot;Twin snowflakes found.&quot;);\n\telse puts(&quot;No two snowflakes are alike.&quot;);\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x15 字符串\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n;\nint snows[N][6], idx[N];\n\nbool cmp_array(int a[], int b[])\n&#123;\n\tfor (int i &#x3D; 0; i &lt; 6; i++)&#x2F;&#x2F;[i]&#x3D;&#x3D; 不作处理\n\t\tif(a[i] &gt; b[i]) return false;\n\t\telse if(a[i] &lt; b[i]) return true;\n\treturn false;&#x2F;&#x2F;全&#x3D; false\n\n&#x2F;&#x2F; 逻辑错误!!!&#x3D;&#x3D;就false：return (a[i] &lt; b[i]) ? true : false;\n&#125;\n\nbool cmp(int a, int b)\n&#123;\n\treturn cmp_array(snows[a], snows[b]);\n&#125;\n\nvoid get_min(int a[])&#x2F;&#x2F;求串的最小表示\n&#123;\n\tstatic int b[12];\n\tfor (int i &#x3D; 0; i &lt; 12; i++) b[i] &#x3D; a[i % 6];&#x2F;&#x2F;b[0-&gt;11]&#x3D;a[0-&gt;5,0-&gt;5]\n\n\tint i &#x3D; 0, j &#x3D; 1, k;\n\twhile(i &lt; 6 &amp;&amp; j &lt; 6)\n\t&#123;\n\t\tfor (k &#x3D; 0; k &lt; 6 &amp;&amp; b[i+k] &#x3D;&#x3D; b[j+k]; k++);\n\t\t\tif(k &#x3D;&#x3D; 6) break;\n\t\tif(b[i + k] &gt; b[j + k])\n\t\t&#123;\n\t\t\ti +&#x3D; k + 1;\n\t\t\tif(i &#x3D;&#x3D; j) i++;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tj +&#x3D; k + 1;\n\t\t\tif(i &#x3D;&#x3D; j) j++;\n\t\t&#125;\n\t&#125;\n\tk &#x3D; min(i, j);\n\tfor(i &#x3D; 0; i &lt; 6; i++) a[i] &#x3D; b[i + k];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tint snow[6], isnow[6];\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0, k &#x3D; 5; j &lt; 6; j++, k--)\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;snow[j]);\n\t\t\tisnow[k] &#x3D; snow[j];\n\t\t&#125;\n\t\tget_min(snow);\n\t\tget_min(isnow);\n\t\t&#x2F;&#x2F;循环同构串的最小表示snows[i] &#x3D; min(正串的最小表示，反串的最小表示);\n\t\tif(cmp_array(snow, isnow)) memcpy(snows[i], snow, sizeof snow);\n\t\telse memcpy(snows[i], isnow, sizeof isnow);\n\n\t\tidx[i] &#x3D; i;&#x2F;&#x2F;2D数组排序:用索引idx\n\t&#125;\n\tsort(idx, idx + n, cmp);\n\n\tbool flag &#x3D; false;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tif(!cmp(idx[i-1], idx[i]) &amp;&amp; !cmp(idx[i], idx[i-1]))&#x2F;&#x2F;最小表示&#x3D;&#x3D;\n\t\t&#123;\n\t\t\tflag &#x3D; true;\n\t\t\tbreak;\n\t\t&#125;\n\tif(flag) puts(&quot;Twin snowflakes found.&quot;);\n\telse puts(&quot;No two snowflakes are alike.&quot;);\n\n\treturn 0;\n&#125;\n&#x2F;&#x2F;兔子与兔子   string hash\n&#x2F;&#x2F;ULL h[N]; --&gt; printf(&quot;%llu\\n&quot;, h[i]);\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int N &#x3D; 1000010, base &#x3D; 131;\n\nchar str[N];\nULL h[N], p[N];\n\nULL get(int l, int r)&#x2F;&#x2F;子串hash\n&#123;\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%s&quot;, str + 1);\n\tint n &#x3D; strlen(str + 1);\n\n\tp[0] &#x3D; 1;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\th[i] &#x3D; h[i - 1] * base + str[i] - &#39;a&#39; + 1;&#x2F;&#x2F;前缀hash\n\t\tp[i] &#x3D; p[i-1] * base;\n\t&#125;\n\t\n\tint m;\n\tcin &gt;&gt; m;\n\twhile(m--)\n\t&#123;\n\t\tint l1, r1, l2, r2;\n\t\tscanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);\n\t\tif(get(l1, r1) &#x3D;&#x3D;  get(l2, r2)) puts(&quot;Yes&quot;);\n\t\telse puts(&quot;No&quot;);\n\t&#125;\n\t\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;139.回文子串的最大长度  O(nlogn):str_hash(Karp_Rabin)+枚举中点+二分半径(&#x3D;否)\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;906&#x2F;\nhash的O(n)解法:\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;893&#x2F;\n&#x2F;&#x2F; 还有Manacher算法 O(n)\n\n&#x2F;&#x2F;if(str[i - l] &lt;&#x3D; &#39;z&#39;) res &#x3D; max(res, l + 1);   搞不懂？？？？？？？？？\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int N &#x3D; 2000010, base &#x3D; 131;&#x2F;&#x2F;2n\n\nchar str[N];\nULL hl[N], hr[N], p[N];\n\nULL get(ULL h[], int l, int r)&#x2F;&#x2F;[hl~hr]子串hash:前缀和（idx从1开始!!!）相减\n&#123;\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main()\n&#123;\n\tint T &#x3D; 1;\n\twhile(scanf(&quot;%s&quot;, str + 1), strcmp(str + 1, &quot;END&quot;))\n\t&#123;\n\t\tint n &#x3D; strlen(str + 1);\n\t\t\n\t\tfor(int i &#x3D; n * 2; i &gt; 0; i -&#x3D; 2)&#x2F;&#x2F;奇偶统一处理!!!\n\t\t&#123;\n\t\t\tstr[i] &#x3D; str[i &#x2F; 2];\n\t\t\tstr[i - 1] &#x3D; &#39;z&#39; + 1;&#x2F;&#x2F;插入额外字符@之类的\n\t\t&#125;\n\t\t\n\t\tn *&#x3D; 2;&#x2F;&#x2F;!!!\n\t\tp[0] &#x3D; 1;\n\t\tfor(int i &#x3D; 1, j &#x3D; n; i &lt;&#x3D; n; i++, j--)\n\t\t&#123;\n\t\t\thl[i] &#x3D; hl[i - 1] * base + str[i] - &#39;a&#39; + 1;\n\t\t\thr[i] &#x3D; hr[i - 1] * base + str[j] - &#39;a&#39; + 1;&#x2F;&#x2F;区别只在str[j]!!! 倒着存:后缀hash\n\t\t\tp[i] &#x3D; p[i - 1] * base;\n\t\t&#125;\n\t\t\n\t\tint res &#x3D; 0;&#x2F;&#x2F;《枚举中点i，二分半径mid  (mid)i(mid)  》\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\tint l &#x3D; 0, r &#x3D; min(i - 1, n - i);&#x2F;&#x2F;i两边的min半径长度r-l!!!!\n\t\t\twhile(l &lt; r)\n\t\t\t&#123;\n\t\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\t\t\t&#x2F;&#x2F;半径&#x3D;mid,1--&gt;n 2--&gt;n-1: 故坐标x--&gt;n-x+1  ， 逆序\n\t\t\t\tif(get(hl, i - mid, i - 1) !&#x3D; get(hr, n - (i + mid) + 1, n - (i + 1) + 1)) r &#x3D; mid - 1;&#x2F;&#x2F;半径过大\n\t\t\t\telse l &#x3D; mid;&#x2F;&#x2F;求max半径（版本2）\n\t\t\t&#125;&#x2F;&#x2F;l&#x3D;r&#x3D;mid\n\t\t\t&#x2F;&#x2F;2*len的pivot: ceil((2*l+1)&#x2F;2)&#x3D;l+1  eg:(01)-&gt;(0123) 1-2-3 pivot&#x3D;2\n\t\t\tif(str[i - l] &lt;&#x3D; &#39;z&#39;) res &#x3D; max(res, l + 1);&#x2F;&#x2F;字母多一个  0总是&#39;&#123;&#39;\n\t\t\telse res &#x3D; max(res, l);&#x2F;&#x2F;插入字符&#39;&#123;&#39;多一\n\t\t&#125;\n\t\tprintf(&quot;Case %d: %d\\n&quot;, T++, res);\n\t&#125;\n\t\n\treturn 0;\n&#125;\n\n&#x2F;*hash的O(n)解法:\n直接带入上一个位置的回文串长度，用 Hash 检验是否能达到这个长度，如果可以，再进行延长。\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\n#define boost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fo(v,a,b) for(int v&#x3D;(a); v&lt;&#x3D;(b); v++)\n#define fr(v,a,b) for(int v&#x3D;(a); v&gt;&#x3D;(b); v--)\n#define rng(v,a,b) for(int v&#x3D;(a); v&lt;(b); v++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate&lt;typename T&gt; T&amp; chmax(T&amp; a, T b) &#123; a &#x3D; a &gt; b ? a : b; return a;&#125;\ntemplate&lt;typename T&gt; T&amp; chmin(T&amp; a, T b) &#123; a &#x3D; a &lt; b ? a : b; return a;&#125;\nconst int maxn&#x3D;1e6+6,P&#x3D;131;\nchar s[maxn],a[maxn*2];\null H1[maxn*2],H2[maxn*2],g[maxn*2];\nint main()\n&#123;\n\tint T&#x3D;0;\n\twhile(cin &gt;&gt; (s+1) &amp;&amp; strcmp(s+1, &quot;END&quot;)) &#123;\n\t\tcout &lt;&lt; &quot;Case &quot; &lt;&lt; ++T &lt;&lt; &quot;: &quot;;\n\t\tint len &#x3D; strlen(s+1), tl&#x3D;0;\n\t\ta[++tl] &#x3D; &#39;#&#39;;\n\t\tfo(i,1,len) &#123;\n\t\t\ta[++tl] &#x3D; s[i]; a[++tl] &#x3D; &#39;#&#39;;\n\t\t&#125;\n\t\ta[tl+1] &#x3D; &#39;\\0&#39;; len&#x3D;tl;\n\n\t\tg[0] &#x3D; 1;\n\t\tfo(i,1,len) &#123;\n\t\t\tH1[i] &#x3D; H1[i-1]*P+a[i]; g[i] &#x3D; g[i-1]*P;\n\t\t&#125;\n\t\tfr(i,len,1) H2[i] &#x3D; H2[i+1]*P+a[i];\n\n\t\tint ans&#x3D;0,l;\n\t\tfo(i,1,len) &#123;\n\t\t\tl&#x3D;ans;\n\t\t\tif(i+l&gt;&#x3D;len || i-l&lt;1) break;\n\t\t\tif(H1[i+l]-H1[i-1]*g[l+1] !&#x3D; H2[i-l]-H2[i+1]*g[l+1]) continue;\n\t\t\twhile(a[i+l+1] &#x3D;&#x3D; a[i-l-1] &amp;&amp; i+l+1&lt;&#x3D;len &amp;&amp; i-l-1&gt;0) l++;\n\t\t\tchmax(ans,l);\n\t\t&#125;\n\t\tcout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：春晖のHigherSY\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;893&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;后缀数组 O(n*(logn)^2): 快排+hash+二分\n&#x2F;&#x2F;倍增，DC3 实现？？？？？\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits.h&gt;\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int N &#x3D; 300010, base &#x3D; 131;\n\nint n;\nchar str[N];\nULL h[N], p[N];\nint sa[N];\n\nint get(int l, int r)\n&#123;\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint get_max_common_prefix(int a, int b)&#x2F;&#x2F;二分模板\n&#123;\n\tint l &#x3D; 0, r &#x3D; min(n - a + 1, n - b + 1);\n\twhile(l &lt; r)\n\t&#123;\n\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\tif(get(a, a + mid - 1) !&#x3D; get(b, b + mid - 1)) r &#x3D; mid - 1;\n\t\telse l &#x3D; mid;\n\t&#125;\n&#125;\n\nbool cmp(int a, int b)\n&#123;\n\tint l &#x3D; get_max_common_prefix(a, b);\n\tint av &#x3D; a + l &gt; n ? INT_MIN : str[a + l];&#x2F;&#x2F;空字符&lt;all字符:负无穷\n\tint bv &#x3D; b + l &gt; n ? INT_MIN : str[b + l];\n\treturn av &lt; bv;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%s&quot;, str + 1);&#x2F;&#x2F;str:1--n\n\tn &#x3D; strlen(str + 1);\n\n\tp[0] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\th[i] &#x3D; h[i - 1] * base + str[i] - &#39;a&#39; + 1;\n\t\tp[i] &#x3D; p[i - 1] * base;\n\t\tsa[i] &#x3D; i;\n\t&#125;\n\n\tsort(sa + 1, sa + 1 + n, cmp);\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) printf(&quot;%d &quot;, sa[i] - 1);&#x2F;&#x2F;0-9\n\tputs(&quot;&quot;);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif(i &#x3D;&#x3D; 1) printf(&quot;0 &quot;);\n\t\telse printf(&quot;%d &quot;, get_max_common_prefix(sa[i - 1], sa[i]));\n\tputs(&quot;&quot;);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;周期 KMP  out:前缀长 前缀的max循环节个数\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint n, T &#x3D; 1;\nchar str[N];\nint Next[N];\n\nvoid get_next()&#x2F;&#x2F;KMP next数组模板\n&#123;\n\tfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\twhile(j &gt; 0 &amp;&amp; str[i] !&#x3D; str[j + 1]) j &#x3D; Next[j];\n\t\tif(str[i] &#x3D;&#x3D; str[j + 1]) j++;\n\t\tNext[i] &#x3D; j;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\twhile(scanf(&quot;%d&quot;, &amp;n), n)\n\t&#123;\n\t\tscanf(&quot;%s&quot;, str + 1);\n\t\tget_next();\n\n\t\tprintf(&quot;Test case #%d\\n&quot;, T++);\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\tint t &#x3D; i - Next[i];&#x2F;&#x2F;t&#x3D;i-Next[i]：前缀的最小循环节长度\n\t\t\tif(t !&#x3D; i &amp;&amp; i % t &#x3D;&#x3D; 0) printf(&quot;%d %d\\n&quot;, i, i &#x2F; t);\n\t\t&#125;\n\t\tputs(&quot;&quot;);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x16 Trie字典树\n&#x2F;&#x2F;前缀统计  &gt;100w:用scanf\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010, M &#x3D; 500000;\n\nint n, m;\nint son[M][26], cnt[N], idx;\nchar str[N];\n\n&#x2F;*struct Node\n&#123;\n\tint son[26];\n\tint cnt;\n&#125;;*&#x2F;\n\nvoid insert()\n&#123;\n\tint p &#x3D; 0;\n\tfor (int i &#x3D; 0; str[i]; i++)\n\t&#123;\n\t\tint &amp;s &#x3D; son[p][str[i] - &#39;a&#39;];\n\t\tif(!s) s &#x3D; ++ idx;\n\t\tp &#x3D; s;\n\t&#125;\n\tcnt[p]++;\n&#125;\n\nint query()\n&#123;\n\tint p &#x3D; 0, res &#x3D; 0;\n\tfor (int i &#x3D; 0; str[i]; i++)\n\t&#123;\n\t\tint &amp;s &#x3D; son[p][str[i] - &#39;a&#39;];\n\t\tif(!s) break;\n\t\tp &#x3D; s;\n\t\tres +&#x3D; cnt[p];\n\t&#125;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\twhile(n--)\n\t&#123;\n\t\tscanf(&quot;%s&quot;, str);\n\t\tinsert();\n\t&#125;\n\twhile(m--)\n\t&#123;\n\t\tscanf(&quot;%s&quot;, str);\n\t\tprintf(&quot;%d\\n&quot;, query());\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;最大异或对\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010, M &#x3D; 3000000;\n\nint n;\nint son[M][2], idx;\nint a[N];\n\nint insert(int x)\n&#123;\n\tint p &#x3D; 0;\n\tfor (int i &#x3D; 30; ~i; i--)&#x2F;&#x2F;~i &#x3D;&#x3D; i&gt;&#x3D;0, -1:全1 ~:全0\n\t&#123;\n\t\tint &amp;s &#x3D; son[p][x &gt;&gt; i &amp; 1];&#x2F;&#x2F;x高位到低位&#x3D;1or0\n\t\tif(!s) s &#x3D; ++ idx;&#x2F;&#x2F;新建节点\n\t\tp &#x3D; s;\n\t&#125;\n&#125;\n\nint query(int x)\n&#123;\n\tint res &#x3D; 0, p &#x3D; 0;\n\tfor (int i &#x3D; 30; ~i; i--)\n\t&#123;\n\t\tint s &#x3D; x &gt;&gt; i &amp; 1;\n\t\tif(son[p][!s]) \n\t\t&#123;\n\t\t\tres +&#x3D; 1 &lt;&lt; i;&#x2F;&#x2F;不同：该位为1\n\t\t\tp &#x3D; son[p][!s];\n\t\t&#125;\n\t\telse p &#x3D; son[p][s];&#x2F;&#x2F;&#x3D;&#x3D; 0\n\t&#125;\n\treturn res;&#x2F;&#x2F;就是^结果！\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; a[i];\n\t\tinsert(a[i]);\n\t&#125;\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, query(a[i]));\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;最长异或值路径\n&#x2F;&#x2F;链式前向星  http:&#x2F;&#x2F;www.mamicode.com&#x2F;info-detail-2368742.html\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010, M &#x3D; 3000000;\n\nint n;\nint h[N], e[N * 2], c[N * 2], ne[N * 2], cnt;\n&#x2F;&#x2F;数组模拟无向图邻接表（链式前向星:省排序），\n&#x2F;&#x2F; h[u]:目前为止起点为u的最后一条边编号,\n&#x2F;&#x2F; e边，c边权，ne:next ne[cur_edge] &#x3D; 同起点prev_edge\nint son[M][2], idx;\nint a[N];\n\nvoid add(int u, int v, int w)\n&#123;\n\te[cnt] &#x3D; v, c[cnt] &#x3D; w, ne[cnt] &#x3D; h[u], h[u] &#x3D; cnt++;\n&#125;&#x2F;&#x2F; ne[cnt] &#x3D; h[u]:ne[cur_edge]&#x3D;prev_edge&#x3D;同起点u的上一条边编号h[u]\n\nvoid dfs(int u, int fa, int sum)\n&#123;\n\ta[u] &#x3D; sum;&#x2F;&#x2F;存root--&gt;u的path上的所有边权xor值\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])&#x2F;&#x2F;遍历起点为u的所有边\n\t&#123;\n\t\tint j &#x3D; e[i];&#x2F;&#x2F;u-(边i)-&gt;j\n\t\tif(j !&#x3D; fa) dfs(j, u, sum ^ c[i]);&#x2F;&#x2F;c[i]:边i的权重\n\t&#125;\n&#125;\n\nint insert(int x)&#x2F;&#x2F;x:a[u] 即root--&gt;u的path所有边权xor值D[u]\n&#123;\n\tint p &#x3D; 0;\n\tfor (int i &#x3D; 30; ~i; i--)&#x2F;&#x2F;~i &#x3D;&#x3D; i&gt;&#x3D;0, -1:全1 ~:全0\n\t&#123;\n\t\tint &amp;s &#x3D; son[p][x &gt;&gt; i &amp; 1];&#x2F;&#x2F;x高位到低位&#x3D;1or0\n\t\tif(!s) s &#x3D; ++ idx;&#x2F;&#x2F;新建节点\n\t\tp &#x3D; s;\n\t&#125;\n&#125;\n\nint query(int x)&#x2F;&#x2F;求x:D[u]的最大xor对的xor值\n&#123;\n\tint res &#x3D; 0, p &#x3D; 0;\n\tfor (int i &#x3D; 30; ~i; i--)\n\t&#123;\n\t\tint s &#x3D; x &gt;&gt; i &amp; 1;\n\t\tif(son[p][!s]) \n\t\t&#123;\n\t\t\tres +&#x3D; 1 &lt;&lt; i;\n\t\t\tp &#x3D; son[p][!s];\n\t\t&#125;\n\t\telse p &#x3D; son[p][s];\n\t&#125;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tmemset(h, -1, sizeof h);\n\tfor (int i &#x3D; 0; i &lt; n - 1; i++)\n\t&#123;\n\t\tint u, v, w;\n\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n\t\tadd(u, v, w);\n\t\tadd(v, u, w);\n\t&#125;&#x2F;&#x2F;建立邻接表\n\t\n\tdfs(0, -1, 0);&#x2F;&#x2F;-1 无向图遍历:出边&#x3D;&#x3D;fa父节点，就不回去\n\t&#x2F;&#x2F; 遍历邻接表，维护a[u] &#x3D; sum;存root--&gt;u的path上的所有边权xor值D[u]\n\tfor (int i &#x3D; 0; i &lt; n; i++) insert(a[i]);&#x2F;&#x2F;建trie\n\t&#x2F;&#x2F;(x,y)的path边权xor &#x3D;&#x3D; D[x] xor D[y]\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, query(a[i]));\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;* 注意! while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF 或者 -1) 可能超时原因：input结尾有ctrl+z非数字,scanf返回0\n建议改为 while(cin &gt;&gt; n)\n*&#x2F;\n\n&#x2F;&#x2F;0x17 二叉堆\n&#x2F;&#x2F;超市\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nint main()\n&#123;\n\tint n;\n\twhile(cin &gt;&gt; n)\n\t&#123;\n\t\tvector&lt;PII&gt; products(n);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) \n\t\t\tcin &gt;&gt; products[i].second &gt;&gt; products[i].first;\n\t\t\t&#x2F;&#x2F;利润小根堆 过期时间sort\n\t\tsort(products.begin(), products.end());\n\t\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\n\t\tfor (auto p : products)\n\t\t&#123;\n\t\t\theap.push(p.second);&#x2F;&#x2F;先push\n\t\t\tif(heap.size() &gt; p.first) heap.pop();&#x2F;&#x2F;if(size &gt; t) pop();\n\t\t&#125;\n\n\t\tint res &#x3D; 0;\n\t\twhile(heap.size()) res +&#x3D; heap.top(), heap.pop();\n\t\t\n\t\tcout &lt;&lt; res &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;序列  学2-&gt;n-seq合并框架: a&#x3D;,b变 merge(a,b)\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 2010;\n\nint m, n;\nint a[N], b[N], c[N];\n\nvoid merge()\n&#123;\n\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n\tfor (int i &#x3D; 0; i &lt; n; i++) heap.push(&#123;a[0] + b[i], 0&#125;);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\t\tint s &#x3D; t.first, p &#x3D; t.second;&#x2F;&#x2F;sum, p下标\n\t\tc[i] &#x3D; s;\n\t\theap.push(&#123;s - a[p] + a[p + 1], p + 1&#125;);&#x2F;&#x2F; (--&gt;)入队\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; n; i++) a[i] &#x3D; c[i];\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;m, &amp;n);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\n\t\tsort(a, a + n);\n\t\tfor (int i &#x3D; 0; i &lt; m - 1; i++)\n\t\t&#123;\n\t\t\tfor (int j &#x3D; 0; j &lt; n; j++) scanf(&quot;%d&quot;, &amp;b[j]);\n\t\t\tmerge();\n\t\t&#125;\n\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) printf(&quot;%d &quot;, a[i]);\n\t\tputs(&quot;&quot;);\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数据备份  min的两侧同时(不)选\n&#x2F;&#x2F; 双链表(prev,next):l[]r[]模拟 + 堆(修改elems)用set红黑树 ++:O(logn)\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;LL, int&gt; PLI;\n\nconst int N &#x3D; 100010;\n\nint n, k;\nint l[N], r[N];\nLL d[N];\n\nvoid delete_node(int p)\n&#123;\n\tr[l[p]] &#x3D; r[p];\n\tl[r[p]] &#x3D; l[p];\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; k;&#x2F;&#x2F;楼数 电缆数\n\tfor (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; d[i];\n\tfor (int i &#x3D; n - 1; ~i; i--) d[i] -&#x3D; d[i - 1];\n\n\tset&lt;PLI&gt; S;\n\td[0] &#x3D; d[n] &#x3D; 1e15;&#x2F;&#x2F;哨兵\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tl[i] &#x3D; i - 1;\n\t\tr[i] &#x3D; i + 1;\n\t\tif(i &gt;&#x3D; 1 &amp;&amp; i &lt; n) S.insert(&#123;d[i], i&#125;);\n\t&#125;\n\n\tLL res &#x3D; 0;\n\twhile(k--)\n\t&#123;\n\t\tauto it &#x3D; S.begin();\n\t\tLL v &#x3D; it -&gt; first;\n\t\tint p &#x3D; it -&gt; second, left &#x3D; l[p], right &#x3D; r[p];\n\t\t&#x2F;&#x2F;!!!\n\t\tres +&#x3D; v;\n\t\tS.erase(it);\n\t\tS.erase(&#123;d[left], left&#125;), S.erase(&#123;d[right], right&#125;); \n\t\tdelete_node(left), delete_node(right);\n\t\t\n\t\td[p] &#x3D; d[left] + d[right] - d[p];\n\t\tS.insert(&#123;d[p], p&#125;);\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;&#x2F;&#x2F;k-dist最小总长\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;Huffman树\n&#x2F;&#x2F;合并果子\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n, x, res;\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; x, heap.push(x);\n\t\n\twhile(heap.size() &gt;&#x3D; 2)\n\t&#123;\n\t\tint a &#x3D; heap.top(); heap.pop();\n\t\tint b &#x3D; heap.top(); heap.pop();\n\t\tres +&#x3D; a + b;\n\t\theap.push(a + b);\n\t&#125;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;荷马史诗\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;LL, int&gt; PLI;&#x2F;&#x2F;&#123;出现次数,深度&#125;sort\n\nint main()\n&#123;\n\tint n, k;\n\tcin &gt;&gt; n &gt;&gt; k;\n\n\tpriority_queue&lt;PLI, vector&lt;PLI&gt;, greater&lt;PLI&gt;&gt; heap;\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tLL x;&#x2F;&#x2F;!!!\n\t\tcin &gt;&gt; x;\n\t\theap.push(&#123;x, 0&#125;);\n\t&#125;\n\twhile((n - 1) % (k - 1)) heap.push(&#123;0, 0&#125;), n++;&#x2F;&#x2F;先补0\n\n\tLL res &#x3D; 0;\n\twhile(heap.size() &gt; 1)\n\t&#123;\n\t\tLL s &#x3D; 0;\n\t\tint depth &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\t&#123;\n\t\t\tauto t &#x3D; heap.top();\n\t\t\ts +&#x3D; t.first;\n\t\t\tdepth &#x3D; max(depth, t.second);&#x2F;&#x2F;!!!\n\t\t\theap.pop();\n\t\t&#125;\n\t\tres +&#x3D; s;\n\t\theap.push(&#123;s, depth + 1&#125;);\n\t&#125;\n\t&#x2F;&#x2F;最小总长度，最长si的最短长度\n\tcout &lt;&lt; res &lt;&lt; endl &lt;&lt; heap.top().second &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;0x1.8 总结与练习\n\n&#x2F;&#x2F;  150 括号画家\n&#x2F;*\n()[]&#123;&#125;\n找出其中连续的一段，满足这段子序列是美观的（括号匹配的），并且长度尽量大。\n求max_len\n右)]&#125; 匹配成对删 不匹入栈\n\nDP：决策不唯一时，枚举各种决策\n贪心：不需要做决策 only one\n从最左合法位置开始扫，就能得到最优解：因为\n两合法连续序列有交集，则并集合法。\n（证区间可加性 L:cnt+1 R:cnt-1 任意前缀和cnt&gt;0 整段cnt&#x3D;&#x3D;0）xy yz两段：x&#x3D;y&#x3D;z&#x3D;0\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint main()\n&#123;\n\tstring str;\n\tcin &gt;&gt; str;\n\tstack&lt;int&gt; stk;\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; str.size(); i ++ )\n\t&#123;\n\t\tchar c &#x3D; str[i];\n\t\tif(stk.size())\n\t\t&#123;\n\t\t\tchar t &#x3D; str[stk.top()];\n\t\t\tif (c &#x3D;&#x3D; &#39;)&#39; &amp;&amp; t &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;]&#39; &amp;&amp; t &#x3D;&#x3D; &#39;[&#39; || c &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; t &#x3D;&#x3D; &#39;&#123;&#39;) stk.pop();&#x2F;&#x2F;匹\n\t\t\telse stk.push(i);&#x2F;&#x2F;不匹\n\t\t&#125;\n\t\telse stk.push(i);&#x2F;&#x2F;stk空\n\n\t\tif (stk.size()) res &#x3D; max(res, i - stk.top());&#x2F;&#x2F;匹配就被pop\n\t\telse res &#x3D; max(res, i + 1);&#x2F;&#x2F;0~i\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F; 151 表达式计算4  39.58%  中等\n&#x2F;*\n+,-,*,&#x2F;,^,(,) 有多余括号  二叉树递归定义：stk\n\n处理多余右括号str&#x3D;&#x3D;))) -&gt; ((((str) 保证&#39;(&#39; &gt;&#x3D; &#39;)&#39;\ni-1非数字非&#39;)&#39;则c(i)&#x3D;&#39;-&#39;负号\ntop&gt;&#x3D;cur_priority 可先算\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nstack&lt;int&gt; nums;\nstack&lt;char&gt; ops;\n\nint qmi(int a, int k)\n&#123;\n\tint res &#x3D; 1;\n\twhile (k -- ) res *&#x3D; a;\n\treturn res;\n&#125;\n\nvoid cal()\n&#123;\n\tint a &#x3D; nums.top(); nums.pop();\n\tint b &#x3D; nums.top(); nums.pop();\n\tchar c &#x3D; ops.top(); ops.pop();\n\tint d;\n\n\tif (c &#x3D;&#x3D; &#39;+&#39;) d &#x3D; b + a;\n\telse if (c &#x3D;&#x3D; &#39;-&#39;) d &#x3D; b - a;\n\telse if (c &#x3D;&#x3D; &#39;*&#39;) d &#x3D; b * a;\n\telse if (c &#x3D;&#x3D; &#39;&#x2F;&#39;) d &#x3D; b &#x2F; a;\n\telse d &#x3D; qmi(b, a);\n\n\tnums.push(d);\n&#125;\n\nint main()\n&#123;\n\tstring str;\n\tcin &gt;&gt; str;\n\n\t&#x2F;&#x2F;if (str[0] &#x3D;&#x3D; &#39;-&#39;) str &#x3D; &#39;0&#39; + str;&#x2F;&#x2F; -? &#x3D;&#x3D; 0-?\n\n\t&#x2F;&#x2F; 处理多余右括号str&#x3D;&#x3D;))) -&gt; ((((str) 保证&#39;(&#39; &gt;&#x3D; &#39;)&#39;\n\tstring left;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; str.size(); i ++ ) left +&#x3D; &#39;(&#39;;\n\tstr &#x3D; left + str + &#39;)&#39;;\n\n\tfor (int i &#x3D; 0; i &lt; str.size(); i ++ )\n\t&#123;\n\t\tif (str[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;9&#39;) &#x2F;&#x2F; toInt\n\t\t&#123;\n\t\t\tint j &#x3D; i, t &#x3D; 0;\n\t\t\twhile (str[j] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[j] &lt;&#x3D; &#39;9&#39;)\n\t\t\t&#123;\n\t\t\t\tt &#x3D; t * 10 + str[j] - &#39;0&#39;;\n\t\t\t\tj ++ ;\n\t\t\t&#125;\n\t\t\tnums.push(t);\n\t\t\ti &#x3D; j - 1;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tchar c &#x3D; str[i];\n\t\t\tif (c &#x3D;&#x3D; &#39;(&#39;) ops.push(c);\n\t\t\telse if (c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tif (c &#x3D;&#x3D; &#39;-&#39; &amp;&amp; i &amp;&amp; !(str[i - 1] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i - 1] &lt;&#x3D; &#39;9&#39;) &amp;&amp; str[i - 1] !&#x3D; &#39;)&#39;)&#x2F;&#x2F;i-1非数字非&#39;)&#39;则c(i)&#x3D;&#39;-&#39;负号\n\t\t\t\t&#123;\n\t\t\t\t\tint j &#x3D; i + 1, t &#x3D; 0;\n\t\t\t\t\twhile (str[j] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[j] &lt;&#x3D; &#39;9&#39;)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tt &#x3D; t * 10 + str[j] - &#39;0&#39;;\n\t\t\t\t\t\tj ++ ;\n\t\t\t\t\t&#125;\n\t\t\t\t\tnums.push(-t);&#x2F;&#x2F;-t\n\t\t\t\t\ti &#x3D; j - 1;\n\t\t\t\t&#125;\n\t\t\t\telse&#x2F;&#x2F;c&#x3D;加减号\n\t\t\t\t&#123;\n\t\t\t\t\twhile (ops.top() !&#x3D; &#39;(&#39;) cal();\n\t\t\t\t\tops.push(c);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\telse if (c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;)\n\t\t\t&#123;\n\t\t\t\twhile (ops.top() &#x3D;&#x3D; &#39;*&#39; || ops.top() &#x3D;&#x3D; &#39;&#x2F;&#39; || ops.top() &#x3D;&#x3D; &#39;^&#39;) cal();&#x2F;&#x2F; top&gt;&#x3D;cur_priority 可先算\n\t\t\t\tops.push(c);\n\t\t\t&#125;\n\t\t\telse if (c &#x3D;&#x3D; &#39;^&#39;)\n\t\t\t&#123;\n\t\t\t\twhile (ops.top() &#x3D;&#x3D; &#39;^&#39;) cal();\n\t\t\t\tops.push(c);\n\t\t\t&#125;\n\t\t\telse if (c &#x3D;&#x3D; &#39;)&#39;)\n\t\t\t&#123;\n\t\t\t\twhile (ops.top() !&#x3D; &#39;(&#39;) cal();&#x2F;&#x2F;prio_increment\n\t\t\t\tops.pop(); &#x2F;&#x2F; pop&#39;(&#39;\n\t\t\t&#125;\n\t\t\telse cout &lt;&lt; &quot;invalid operator!&quot; &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; nums.top() &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 152 城市游戏    52.47%  中等\n&#x2F;*\nAcwing131.直方图中最大的矩形 单调栈 变形题\n面积最大的F子矩阵\n\ncin自动过滤空白字符！！！\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nint n, m;\nchar g[N][N];\nint h[N][N]; &#x2F;&#x2F; [cur以上有多少个连续F\nint q[N], l[N], r[N];&#x2F;&#x2F; &gt;&#x3D;i的[l,i,r]边界\n\nvoid cal(int a[], int l[])\n&#123;\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\ta[0] &#x3D; -1;&#x2F;&#x2F;哨兵\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\twhile (a[q[tt]] &gt;&#x3D; a[i]) tt -- ;\n\t\tl[i] &#x3D; q[tt] + 1; &#x2F;&#x2F; [l,r]&gt;&#x3D;a[i]\n\t\tq[ ++ tt] &#x3D; i;\n\t&#125;\n&#125;\n\nint work(int a[])\n&#123;\n\tcal(a, l);\n\treverse(a + 1, a + 1 + m);\n\tcal(a, r);\n\treverse(a + 1, a + 1 + m);\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\tint left &#x3D; l[i];\n\t\tint right &#x3D; m + 1 - r[m + 1 - i]; &#x2F;&#x2F; ！！！！！！！！！！！！！！\n\t\tres &#x3D; max(res, a[i] * (right - left + 1));\n\t&#125;\n\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )\n\t\t&#123;\n\t\t\tcin &gt;&gt; g[i][j];\n\t\t\tif (g[i][j] &#x3D;&#x3D; &#39;F&#39;) h[i][j] &#x3D; h[i - 1][j] + 1;\n\t\t\telse h[i][j] &#x3D; 0;\n\t\t&#125;\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) res &#x3D; max(res, work(h[i]));\n\n\tcout &lt;&lt; res * 3 &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 153 双栈排序    31.17%  困难\n&#x2F;*\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;3710&#x2F;\n两个数 i,j(i≤j) 不能被放入同一个栈中，当且仅当存在 k, k&gt;j 且 q[k]&lt;q[i]&lt;q[j]。\nq[i]&#x3D;2、q[j]&#x3D;3、q[k]&#x3D;1\n如果i, j满足条件(231)，则在i和j之间连一条边。然后判断是否是二分图即可。\njudge二分图：染色法【无奇环】\n\ncur-&gt;(大)-&gt;小\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;stack&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nint n;\nint a[N], f[N];\nint color[N];\nbool g[N][N];\n\nbool dfs(int u, int c)\n&#123;\n\tcolor[u] &#x3D; c;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (g[u][i])&#x2F;&#x2F;u-i相邻\n\t\t&#123;\n\t\t\tif (color[i] &#x3D;&#x3D; c) return false;\n\t\t\tif (color[i] &#x3D;&#x3D; -1 &amp;&amp; !dfs(i, !c)) return false;\n\t\t&#125;\n\n\treturn true;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; a[i];\n\tf[n + 1] &#x3D; n + 1;\n\tmemset(g, false, sizeof g);\n\tfor (int i &#x3D; n; i; i--) f[i] &#x3D; min(f[i + 1], a[i]);&#x2F;&#x2F;f[i]&#x3D;[i后min_a\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; i + 1; j &lt;&#x3D; n; j++)\n\t\t\tif (a[i] &lt; a[j] &amp;&amp; f[j + 1] &lt; a[i])\n\t\t\t\tg[i][j] &#x3D; g[j][i] &#x3D; true;\n\n\tmemset(color, -1, sizeof color);\n\n\tbool flag &#x3D; true;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (color[i] &#x3D;&#x3D; -1 &amp;&amp; !dfs(i, 0))&#x2F;&#x2F;i未染,(01)优先染0,染色不成功\n\t\t&#123;\n\t\t\tflag &#x3D; false;\n\t\t\tbreak;\n\t\t&#125;\n\n\tif (!flag)\n\t&#123;\n\t\tcout &lt;&lt; 0 &lt;&lt; endl;\n\t\treturn 0;\n\t&#125;\n\n\tstack&lt;int&gt; stk1, stk2;\n\n\tint now &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tif (color[i] &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 要入第一个栈了，第一个栈该出的(小)现在必须要出掉\n\t\t\t&#x2F;&#x2F; 为了使字典序最小，第二个栈可以再等等\n\t\t\twhile (stk1.size() &amp;&amp; stk1.top() &#x3D;&#x3D; now)\n\t\t\t&#123;\n\t\t\t\tstk1.pop();\n\t\t\t\tcout &lt;&lt; &quot;b &quot;;\n\t\t\t\tnow++;\n\t\t\t&#125;\n\t\t\tstk1.push(a[i]);\n\t\t\tcout &lt;&lt; &quot;a &quot;;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 要入第二个栈了，第二个栈该出的(小)现在必须要出掉\n\t\t\t&#x2F;&#x2F; 然而由于b比c字典序小，第一个栈可以出的(小)也应该出掉\n\t\t\twhile (true)\n\t\t\t\tif (stk1.size() &amp;&amp; stk1.top() &#x3D;&#x3D; now)\n\t\t\t\t&#123;\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tcout &lt;&lt; &quot;b &quot;;\n\t\t\t\t\tnow++;\n\t\t\t\t&#125;\n\t\t\t\telse if (stk2.size() &amp;&amp; stk2.top() &#x3D;&#x3D; now)\n\t\t\t\t&#123;\n\t\t\t\t\tstk2.pop();\n\t\t\t\t\tcout &lt;&lt; &quot;d &quot;;\n\t\t\t\t\tnow++;\n\t\t\t\t&#125;\n\t\t\t\telse break;\n\t\t\tstk2.push(a[i]);\n\t\t\tcout &lt;&lt; &quot;c &quot;;\n\t\t&#125;\n\n\t&#125;\n\t&#x2F;&#x2F; 最后出栈剩余的\n\twhile (true)\n\t\tif (stk1.size() &amp;&amp; stk1.top() &#x3D;&#x3D; now)\n\t\t&#123;\n\t\t\tstk1.pop();\n\t\t\tcout &lt;&lt; &quot;b &quot;;\n\t\t\tnow++;\n\t\t&#125;\n\t\telse if (stk2.size() &amp;&amp; stk2.top() &#x3D;&#x3D; now)\n\t\t&#123;\n\t\t\tstk2.pop();\n\t\t\tcout &lt;&lt; &quot;d &quot;;\n\t\t\tnow++;\n\t\t&#125;\n\t\telse break;\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 154 滑动窗口    49.84%  简单\n&#x2F;*\n确定滑动窗口位于每个位置时，窗口中的最大值和最小值。\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint n, m;\nint a[N];\nint q[N];\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);\n\n\tint hh &#x3D; 0, tt &#x3D; -1;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tif (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt;&#x3D; i - m) hh ++ ;\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &gt;&#x3D; a[i]) tt -- ;\n\t\tq[ ++ tt] &#x3D; i;\n\t\tif (i &gt;&#x3D; m - 1) printf(&quot;%d &quot;, a[q[hh]]);\n\t&#125;\n\tputs(&quot;&quot;);\n\n\thh &#x3D; 0, tt &#x3D; -1;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tif (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt;&#x3D; i - m) hh ++ ;\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) tt -- ;&#x2F;&#x2F;\n\t\tq[ ++ tt] &#x3D; i;\n\t\tif (i &gt;&#x3D; m - 1) printf(&quot;%d &quot;, a[q[hh]]);\n\t&#125;\n\tputs(&quot;&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; 155 内存分配    40.05%  困难模拟\n&#x2F;*\n数据结构：\n等待队列：(内存长度, 占用时间)：queue\n内存使用情况：(起始下标，长度)\n线性扫描、删除、插入：set(RBTree):O(log)级别的插入,删除,求前驱,求后继等\n小根堆：（释放时间key，[mem_index]起始下标），priority_queue\n算法流程：\n新来一个请求：（T,M,P)\n\n释放掉所有&quot;释放时间&lt;&#x3D;T&quot;的内存，每次释放之后，都要判断等待队列的队头是否可以满足\n判断（T，M，P)是否可以满足，如果不可以，则插入等待队列\n\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;1840&#x2F;\n*&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nint n;\nqueue&lt;PII&gt; waits;       &#x2F;&#x2F; (first: 内存长度M，second: 占用时间P)\nset&lt;PII&gt; runs;          &#x2F;&#x2F; (first: 起始下标，second：长度)\npriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; endts;       &#x2F;&#x2F; (first: 释放时间，second: 起始下标)\nint tm, cnt;    &#x2F;&#x2F; terminate_time, waits_max_size\n\nbool give(int t, int m, int p)&#x2F;&#x2F;判断TMP是否可以满足，满足则分配\n&#123;\n\tfor (auto it &#x3D; runs.begin(); it !&#x3D; runs.end(); it ++ )&#x2F;&#x2F;枚举used_mem\n\t&#123;\n\t\tauto jt &#x3D; it;\n\t\tjt ++ ;&#x2F;&#x2F; jt &#x3D;&#x3D; it+1\n\t\tif (jt !&#x3D; runs.end())\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;m &lt;&#x3D; j_start_idx - it_end_idx - 1 ([it]~[jt]之间缝隙)\n\t\t\tif (m &lt;&#x3D; jt-&gt;first - (it-&gt;first + it-&gt;second - 1) - 1)\n\t\t\t&#123;\n\t\t\t\tint start &#x3D; it-&gt;first + it-&gt;second;\n\t\t\t\truns.insert(&#123;start, m&#125;);&#x2F;&#x2F;起始下标，长度\n\t\t\t\tendts.push(&#123;t + p, start&#125;);&#x2F;&#x2F;释放时间，起始下标\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\treturn false;\n&#125;\n\nvoid finish(int t) &#x2F;&#x2F; 释放掉所有&quot;释放时间&lt;&#x3D;T&quot;的内存\n&#123;\n\twhile (endts.size() &amp;&amp; endts.top().first &lt;&#x3D; t)\n\t&#123;\n\t\tint f &#x3D; endts.top().first;\n\t\twhile (endts.size() &amp;&amp; endts.top().first &#x3D;&#x3D; f)&#x2F;&#x2F;endts&#x3D;&#x3D; 一并删除\n\t\t&#123;\n\t\t\tauto top &#x3D; endts.top();\n\t\t\tendts.pop();\n\t\t\tauto it &#x3D; runs.lower_bound(&#123;top.second, 0&#125;);&#x2F;&#x2F; &gt;&#x3D;起始下标的min\n\t\t\truns.erase(it);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 每次释放之后，都要判断等待队列的队头是否可以满足\n\t\ttm &#x3D; f;\n\t\twhile (waits.size())\n\t\t&#123;\n\t\t\tauto front &#x3D; waits.front();\n\t\t\tif (give(f, front.first, front.second))&#x2F;&#x2F;队头分配成功\n\t\t\t&#123;\n\t\t\t\twaits.pop();\n\t\t\t&#125;\n\t\t\telse break;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tint t, m, p;\n\n\truns.insert(&#123;-1, 1&#125;), runs.insert(&#123;n, 1&#125;);&#x2F;&#x2F;内存使用情况哨兵\n\n\twhile (cin &gt;&gt; t &gt;&gt; m &gt;&gt; p, t || m || p)\n\t&#123;\n\t\tfinish(t);\n\t\tif (!give(t, m, p))&#x2F;&#x2F;判断TMP是否可以满足，如果不可以，则插入等待队列\n\t\t&#123;\n\t\t\twaits.push(&#123;m, p&#125;);\n\t\t\tcnt ++ ;\n\t\t&#125;\n\t&#125;\n\n\tfinish(2e9);&#x2F;&#x2F;\n\n\tcout &lt;&lt; tm &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 156 矩阵  33.52%  中等\n&#x2F;*\nQ次询问，每次询问给出一个A行B列的01矩阵，求该矩阵是否在原矩阵中出现过\n2D str_hash:\n32高位\n10低位\n1&lt;~A行 -&gt; 2&lt;~A+1行：S*p^B-hash1*p^(A*B)+hash(A+1行)\n\n预处理all A*B子矩阵 str_hash-&gt;unordered _set哈希表S , S.count 即可\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_set&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nconst int N &#x3D; 1010, M &#x3D; N * N, P &#x3D; 131;\n\nint n, m, a, b;\nULL hashv[N][N], p[M];\nchar str[N];\n\nULL calc(ULL f[], int l, int r)&#x2F;&#x2F;strLR_hash\n&#123;\n\treturn f[r] - f[l - 1] * p[r - l + 1];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;a, &amp;b);\n\n\tp[0] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n * m; i ++ ) p[i] &#x3D; p[i - 1] * P;&#x2F;&#x2F;p^i\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F;suffix_sum\n\t&#123;\n\t\tscanf(&quot;%s&quot;, str + 1);\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) hashv[i][j] &#x3D; hashv[i][j - 1] * P + str[j] - &#39;0&#39;;\n\t&#125;\n\n\tunordered_set&lt;ULL&gt; S;\n\tfor (int i &#x3D; b; i &lt;&#x3D; m; i ++ )&#x2F;&#x2F;一列一列\n\t&#123;\n\t\tULL s &#x3D; 0;\n\t\tint l &#x3D; i - b + 1, r &#x3D; i;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )&#x2F;&#x2F;S*p^B-hash1*p^(A*B)+hash(A+1行)\n\t\t&#123;\n\t\t\ts &#x3D; s * p[b] + calc(hashv[j], l, r);&#x2F;&#x2F;1~A行\n\t\t\t&#x2F;&#x2F;A+j行：-hashj*p^(A*B)\n\t\t\tif (j - a &gt; 0) s -&#x3D; calc(hashv[j - a], l, r) * p[a * b];\n\t\t\tif (j &gt;&#x3D; a) S.insert(s);\n\t\t&#125;\n\t&#125;\n\n\tint Q;\n\tscanf(&quot;%d&quot;, &amp;Q);\n\twhile (Q -- )\n\t&#123;\n\t\tULL s &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; a; i ++ )\n\t\t&#123;\n\t\t\tscanf(&quot;%s&quot;, str);\n\t\t\tfor (int j &#x3D; 0; j &lt; b; j ++ ) s &#x3D; s * P + str[j] - &#39;0&#39;;\n\t\t&#125;\n\t\tif (S.count(s)) puts(&quot;1&quot;);\n\t\telse puts(&quot;0&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 157 树形地铁系统  62.41%  简单\n&#x2F;*\n每个测试用例，如果两个字符串描述的探索路线 “树同构”：child无LR，则输出same。否则，输出different。\n\n1,2都-&gt;树的最小表示(与这棵树同构的最小的dfs序) &#x3D;&#x3D;就same\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstring dfs(string &amp;seq, int &amp;u)&#x2F;&#x2F;子树的最小表示\n&#123;\n\tu ++ ;&#x2F;&#x2F;root-&gt;sub_root\n\tvector&lt;string&gt; seqs;\n\twhile (seq[u] &#x3D;&#x3D; &#39;0&#39;) seqs.push_back(dfs(seq, u));&#x2F;&#x2F;递归出子树seq\n\tu ++ ;&#x2F;&#x2F;sub_root-&gt;root\n\t\n\tsort(seqs.begin(), seqs.end());\n\tstring res &#x3D; &quot;0&quot;;\n\tfor (auto &amp;s : seqs) res +&#x3D; s; &#x2F;&#x2F; 0+sorted(子seqs)+1\n\tres +&#x3D; &#39;1&#39;;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile (T -- )\n\t&#123;\n\t\tstring a, b;\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\ta &#x3D; &#39;0&#39; + a + &#39;1&#39;;&#x2F;&#x2F;root哨兵\n\t\tb &#x3D; &#39;0&#39; + b + &#39;1&#39;;\n\t\tint ua &#x3D; 0, ub &#x3D; 0;\n\t\tif (dfs(a, ua) &#x3D;&#x3D; dfs(b, ub)) puts(&quot;same&quot;);\n\t\telse puts(&quot;different&quot;);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; 158 项链  57.17%  简单\n&#x2F;*\n一个对于项链的表示就是从项链的某个宝石开始，顺指针绕一圈，沿途记下经过的宝石，比如项链： 0-1-2-3 ，它的可能的四种表示是0123、1230、2301、3012。旋转不变！\n项链不会翻转，给定两个项链的表示，判断他们是否可能是一条项链。\nYes 循环同构串的最小表示法 P76\n环-&gt;链：n*2法 n_window滑动 cmp 1.i&#x3D;2.j i+k&gt;j+k : 1.jump_to_i+k+1 if(i&#x3D;&#x3D;j)i++\nans_start&#x3D;B[min(i,j)]\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 2000000;\n\nint n;\nchar a[N], b[N];\n\nint get_min(char str[])\n&#123;\n\tint i &#x3D; 0, j &#x3D; 1;\n\twhile (i &lt; n &amp;&amp; j &lt; n)\n\t&#123;\n\t\tint k &#x3D; 0;\n\t\twhile (k &lt; n &amp;&amp; str[i + k] &#x3D;&#x3D; str[j + k]) k ++ ;\n\t\tif (k &#x3D;&#x3D; n) break;&#x2F;&#x2F;全等\n\t\tif (str[i + k] &gt; str[j + k]) i +&#x3D; k + 1;\n\t\telse j +&#x3D; k + 1;\n\t\tif (i &#x3D;&#x3D; j) i ++ ;\n\t&#125;\n\tint res &#x3D; min(i, j);\n\tstr[res + n] &#x3D; 0;&#x2F;&#x2F;&#39;\\0&#39;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%s%s&quot;, a, b);\n\tn &#x3D; strlen(a);\n\n\tmemcpy(a + n, a, n);&#x2F;&#x2F;void *memcpy(void*dest, const void *src, size_t n);\n\tmemcpy(b + n, b, n);\n\n\tint ia &#x3D; get_min(a), ib &#x3D; get_min(b);&#x2F;&#x2F;min(i, j)\n\n\tif (strcmp(a + ia, b + ib)) puts(&quot;No&quot;);\n\telse\n\t&#123;\n\t\tputs(&quot;Yes&quot;);\n\t\tputs(a + ia);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 159 奶牛矩阵    40.53%  中等\n&#x2F;*\n最小覆盖窗口面积\n\n串完美循环时：KMP求min循环节长度 \n行上min循环节长度W&#x3D;n-next[n]  max,公倍数 都不对！only爆搜O(n)\nW看做elem，列上做KMP求循环节长度h\nmin_w-&gt;min_h(w+ 原本&#x3D;的循环节变!&#x3D; 为了再&#x3D;&#x3D; h也+)\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 10010, M &#x3D; 80;\n\nint n, m;\nchar str[N][M];\nbool st[M];\nint ne[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F;行i\n\t&#123;\n\t\tcin &gt;&gt; str[i];\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )&#x2F;&#x2F;循环节长度j\n\t\t&#123;\n\t\t\tbool is_match &#x3D; true;\n\t\t\tfor (int k &#x3D; j; k &lt; m; k +&#x3D; j)&#x2F;&#x2F;start k\n\t\t\t&#123;\n\t\t\t\tfor (int u &#x3D; 0; u &lt; j &amp;&amp; k + u &lt; m; u ++ )&#x2F;&#x2F;cur\n\t\t\t\t\tif (str[i][u] !&#x3D; str[i][k + u])&#x2F;&#x2F;第k个!&#x3D;first\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tis_match &#x3D; false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\tif (!is_match) break;\n\t\t\t&#125;\n\t\t\tif (!is_match) st[j] &#x3D; true;&#x2F;&#x2F;不可取\n\t\t&#125;\n\t&#125;\n\n\tint width;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t\tif (!st[i])&#x2F;&#x2F;可取\n\t\t&#123;\n\t\t\twidth &#x3D; i;\n\t\t\tbreak;\n\t\t&#125;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) str[i][width] &#x3D; 0;&#x2F;&#x2F; w+&#39;\\0&#39;-&gt;elem\n\t&#x2F;&#x2F;kmp_ne[]模板\n\tfor (int j &#x3D; 0, i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\twhile (j &amp;&amp; strcmp(str[j + 1], str[i])) j &#x3D; ne[j];\n\t\tif (!strcmp(str[j + 1], str[i])) j ++ ;\n\t\tne[i] &#x3D; j;\n\t&#125;\n\n\tint height &#x3D; n - ne[n];\n\n\tcout &lt;&lt; width * height &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 160 匹配统计    46.76%  中等\n&#x2F;*\n给定你一个整数x，请你告诉他有多少个位置，满足“字符串A从该位置开始的后缀子串”与B匹配的长度恰好为x。\nA&#x3D;aabcde，B&#x3D;ab，则A有aabcde、abcde、bcde、cde、de、e这6个后缀子串，它们与B&#x3D;ab的匹配长度分别是1、2、0、0、0、0。\n因此A与B的匹配长度恰好为0有4个位置，匹配长度恰好为1有1个位置，匹配长度恰好为2有1个位置。\n\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;15841&#x2F;\n法一：str_hash\n法二:kmp\n*&#x2F;\n\n算法1\n(哈希) O(NlogN+M+Q)\n先分别求出 A 与 B 的哈希数组，对于 a 中的每一个后缀，二分求一下能匹配的 B 的最大前缀即可。\n详见代码注释\n\n时间复杂度\n求出 A 的哈希数组，时间复杂度是 O(N)\n求出 B 的哈希数组，时间复杂度是 O(M)\n一共要二分 N 次，每次二分的时间复杂度是 O(log⁡N)，所以二分的总时间复杂度是 O(NlogN)\n要处理 Q 次询问，每次询问的时间复杂度是 O(1)，处理所有询问的时间复杂度就是 O(Q)\n所以总的时间复杂度为 O(Nlog⁡N+M+Q)\nC++ 代码\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef unsigned long long ULL;\nconst int N &#x3D; 200005;\nconst ULL P &#x3D; 131;\n\nint n, m, q;                    &#x2F;&#x2F; 题目中 N, M, Q\nchar A[N], B[N];                &#x2F;&#x2F; 题目中 A, B\nULL hash_A[N], hash_B[N], p[N]; &#x2F;&#x2F; hash_A, hash_B 分别存 A, B 的哈希值。p 存 P 的 i 次幂，用于求出每个子串的哈希值。\nint cnt[N];                     &#x2F;&#x2F; 二分预处理的 A 中每个后缀与 B 匹配的最长长度，存入 cnt\n\nULL get(ULL h[], int l, int r)  &#x2F;&#x2F; 返回 h 中 [l, r] 的哈希值\n&#123;\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d\\n&quot;, &amp;n, &amp;m, &amp;q);\n\tscanf(&quot;%s\\n%s&quot;, A + 1, B + 1); &#x2F;&#x2F; 由于要处理哈希，从 1 开始输入会方便一些\n\tp[0] &#x3D; 1;                      &#x2F;&#x2F; 根据定义，P 的 0 次幂为 1\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; p[i - 1] * P;                  &#x2F;&#x2F; 预处理 p\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) hash_A[i] &#x3D; hash_A[i - 1] * P + A[i]; &#x2F;&#x2F; 预处理 hash_A\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) hash_B[i] &#x3D; hash_B[i - 1] * P + B[i]; &#x2F;&#x2F; 预处理 hash_B\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#x2F;&#x2F; 二分预处理 cnt\n\t&#123;\n\t\tint l &#x3D; i, r &#x3D; i + m, mid; &#x2F;&#x2F; 二分左边界为 i，右边界为 i + m\n\t\tif (r &gt; n + 1) r &#x3D; n + 1;  &#x2F;&#x2F; 如果右边界不在 A 中，让其指向 A 的右边界\n\t\twhile (l &lt; r)              &#x2F;&#x2F; 二分板子\n\t\t&#123;\n\t\t\tmid &#x3D; l + r &gt;&gt; 1;\n\t\t\tif (get(hash_A, i, mid) !&#x3D; get(hash_B, 1, mid - i + 1)) r &#x3D; mid;\n\t\t\telse    l &#x3D; mid + 1;\n\t\t&#125;\n\t\tcnt[r - i] ++ ; &#x2F;&#x2F; 二分之后，r 表示的是 B 与 A 匹配的最靠后的位置（从 i 开始），r - i 是 A 从 i 开始的后缀与 B 匹配的最长长度\n\t&#125;\n\twhile (q -- )       &#x2F;&#x2F; 处理询问\n\t&#123;\n\t\tint x;\n\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\tprintf(&quot;%d\\n&quot;, cnt[x]);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n算法2 【题解至少读两遍！！！】\n(KMP) O(N+M+Q)\n这个解法的确比较难想。。需要对 KMP 足够的熟悉。。\n先对 B 求 KMP，得到 B 的 next 数组。\n然后对 A 做一遍匹配，回忆一下匹配的代码：\n\nfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )\n&#123;\n\twhile (j &amp;&amp; a[i] !&#x3D; b[j + 1]) j &#x3D; ne[j];\n\tif (a[i] &#x3D;&#x3D; b[j + 1]) j ++ ;\n\t&#x2F;&#x2F; blablabla\n&#125;\n我们发现，在 blablabla 那个位置，j 正好是 B 能匹配 A 的以 i 为终点的最长字符串长度。\n也就是说，字符串 A 中，以 i−j+1 为起点的与 B 匹配的长度最小为 j\n但是，以 ii 为终点的，与 B 匹配的字符串只有 A[i−j+1∼i] 嘛？\n不一定，我们发现 A[i−next[j]+1∼i] 也是与 B 的前缀匹配的字符串\n同理，A[i−next[next[j]]+1∼i] 也是与 B 的前缀匹配的字符串...\n\n那么，我们在让 cnt[j] ++ 时，就还需要让 cnt[next[j]] ++，还需要让 cnt[next[next[j]]] ++...\n那我们匹配的时间复杂度就会退化为 O(NM) 了，显然是过不了这道题的。\n观察下我们操作 cnt[x] 的过程，每次都会让 cnt[next[x]] ++，也就是说，cnt[x] ++了多少次，cnt[next[x]] ++也就要相应的执行多少次。\n那么我们就可以先只操作 cnt[j] ++，最后从 m 到 1 循环枚举一遍 cnt[i]，让 cnt[next[i]] +&#x3D; cnt[i] 即可。\n注意最后 cnt[i] 存的是满足匹配的前缀至少为 x 的后缀数量，而题目中所要求的满足匹配的前缀恰好为 x 的答案的应为匹配的前缀至少为 x 的后缀数量 减去 匹配的前缀至少为 x + 1 的后缀数量，即 cnt[x] - cnt[x + 1]（后缀和思想），\n\n时间复杂度\n求 BB 的 nextnext 数组，时间复杂度为 O(M)\n将 AA 与 BB 做匹配，时间复杂度为 O(N)\n处理询问，时间复杂度为 O(Q)\n故总的时间复杂度为 O(N+M+Q)\nC++ 代码\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nconst int N &#x3D; 200005;\n\nint n, m, q;\nchar A[N], B[N];\nint ne[N], cnt[N];  &#x2F;&#x2F; ne 存 B 的 next 数组，cnt 即上述 cnt 数组\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d\\n&quot;, &amp;n, &amp;m, &amp;q);\n\tscanf(&quot;%s\\n%s&quot;, A + 1, B + 1);\n\n\tfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ ) &#x2F;&#x2F; KMP 模板\n\t&#123;\n\t\twhile (j &amp;&amp; B[i] !&#x3D; B[j + 1]) j &#x3D; ne[j];\n\t\tif (B[i] &#x3D;&#x3D; B[j + 1]) j ++ ;\n\t\tne[i] &#x3D; j;\n\t&#125;\n\n\tfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#x2F;&#x2F; 将 A 与 B 做匹配\n\t&#123;\n\t\twhile (j &amp;&amp; A[i] !&#x3D; B[j + 1]) j &#x3D; ne[j];\n\t\tif (A[i] &#x3D;&#x3D; B[j + 1]) j ++ ;\n\t\tcnt[j] ++ ;                       &#x2F;&#x2F; 先只将 cnt[j] ++ \n\t&#125;\n\tfor (int i &#x3D; m; i; i -- ) cnt[ne[i]] +&#x3D; cnt[i]; &#x2F;&#x2F; 从 m 到 1 枚举 cnt[i]，处理出所有的 cnt[next[i]]\n\n\twhile (q -- )\n\t&#123;\n\t\tint x;\n\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\tprintf(&quot;%d\\n&quot;, cnt[x] - cnt[x + 1]); &#x2F;&#x2F; 输出的结果应为 cnt[x] - cnt[x + 1]\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：垫底抽风\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;15841&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;kmp\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N &#x3D; 200010;\n\nint n, m, q;\nchar a[N], b[N];\nint nxt[N];\nint f[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n\tscanf(&quot;%s%s&quot;, a + 1, b + 1);\n\n\tfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\twhile (j &amp;&amp; b[i] !&#x3D; b[j + 1]) j &#x3D; nxt[j];\n\t\tif (b[i] &#x3D;&#x3D; b[j + 1]) j ++ ;\n\t\tnxt[i] &#x3D; j;\n\t&#125;\n\n\tfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\twhile (j &amp;&amp; a[i] !&#x3D; b[j + 1]) j &#x3D; nxt[j];\n\t\tif (a[i] &#x3D;&#x3D; b[j + 1]) j ++ ;\n\t\tf[j] ++ ;\n\t&#125;\n\n\tfor (int i &#x3D; m; i; i -- ) f[nxt[i]] +&#x3D; f[i];\n\n\twhile (q -- )\n\t&#123;\n\t\tint x;\n\t\tcin &gt;&gt; x;\n\t\tcout &lt;&lt; f[x] - f[x + 1] &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; 161 电话列表    29.58%  简单\n&#x2F;*\nTrie 非前缀码\ncur有前缀...：遍历路径中有str_end(leaf) \ncur是...的前缀：insert时没有新建node\n否则return true: has_new_node &amp;&amp; !has_found\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n;\nint son[N][10], idx;\nbool f[N];\n\nbool insert(char *str)\n&#123;\n\tint p &#x3D; 0;\n\tbool has_new_node &#x3D; false;\n\tbool has_found &#x3D; false;\n\tfor (int i &#x3D; 0; str[i]; i ++ )\n\t&#123;\n\t\tint u &#x3D; str[i] - &#39;0&#39;;\n\t\tif (!son[p][u])\n\t\t&#123;\n\t\t\tson[p][u] &#x3D; ++ idx;\n\t\t\thas_new_node &#x3D; true;\n\t\t&#125;\n\t\tp &#x3D; son[p][u];\n\t\tif (f[p]) has_found &#x3D; true;&#x2F;&#x2F;f[p]:遍历路径中有str_end\n\t&#125;\n\n\tf[p] &#x3D; true;&#x2F;&#x2F;!!!\n\n\treturn has_new_node &amp;&amp; !has_found;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile (T -- )\n\t&#123;\n\t\tcin &gt;&gt; n;\n\t\tmemset(son, 0, sizeof son);\n\t\tmemset(f, false, sizeof f);\n\t\tidx &#x3D; 0;\n\n\t\tbool res &#x3D; true;\n\n\t\tchar str[20];\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\t&#123;\n\t\t\tcin &gt;&gt; str;\n\t\t\tif (!insert(str)) res &#x3D; false;\n\t\t&#125;\n\n\t\tif (res) puts(&quot;YES&quot;);\n\t\telse puts(&quot;NO&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;hash做法\n# include &lt;iostream&gt;\n# include &lt;string&gt;\n# include &lt;unordered_set&gt;\n# include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int maxn &#x3D; 1e4 + 5, Hash &#x3D; 131;\nstring phone[maxn];\nULL h[maxn];\nunordered_set&lt;ULL&gt; F;\n\nbool check(string &amp;number)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; number.size(); i++) &#123;\n\t\th[i + 1] &#x3D; h[i] * Hash + number[i] - &#39;0&#39; + 1;  &#x2F;&#x2F; + 1 为了防止 012  与  12 这种情况\n\t\tif (i + 1 &#x3D;&#x3D; number.size() &amp;&amp; F.count(h[i + 1]))\n\t\t\treturn true;\n\t\tF.insert(h[i + 1]);\n\t&#125;\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin &gt;&gt; T;\n\twhile (T--) &#123;\n\t\tF.clear();\n\t\tint n;\n\t\tcin &gt;&gt; n;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tcin &gt;&gt; phone[i];\n\t\tsort(phone + 1, phone + n + 1);\n\t\tbool success &#x3D; true;\n\t\tfor (int i &#x3D; n; i; i--) &#123;\n\t\t\tif (check(phone[i])) &#123;\n\t\t\t\tsuccess &#x3D; false;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (success)\n\t\t\tcout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n\t\telse\n\t\t\tcout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：逆乾\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;1947&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n&#x2F;&#x2F; 162 黑盒子 66.97%  中等\n&#x2F;*\nfind第k大：对顶堆O(nlogn) -&gt;BFPRT:O(n)\noutput升序排序后的第i个数: 对顶堆algo\n保持L:1~i-1\nget i++: Ltop&lt;-Rtop\t\t\t\t\t输出小根堆顶A[i]:right.top\nadd(x): x&gt;&#x3D;A[i]时 toR\t\t\t\tx&lt;A[i] toL,Ltop-&gt;R\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 30010;\n\nint n, m;\nint a[N], b[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; a[i];&#x2F;&#x2F;元素按加入顺序排列\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) cin &gt;&gt; b[i];&#x2F;&#x2F;第i次GET操作时盒子内元素数\n\n\tpriority_queue&lt;int&gt; down;\n\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;\n\n\tint k &#x3D; 0;\n\tfor (int i &#x3D; 1, j &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\twhile (j &lt;&#x3D; b[i])&#x2F;&#x2F;add\n\t\t&#123;\n\t\t\tif (down.empty() || a[j] &gt;&#x3D; down.top()) up.push(a[j]);\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tup.push(down.top());\n\t\t\t\tdown.pop();\n\t\t\t\tdown.push(a[j]);\n\t\t\t&#125;\n\t\t\tj ++ ;\n\t\t&#125;\n\t\t&#x2F;&#x2F;add j次 &#x3D;&#x3D; 盒子内元素数 时: get\n\t\tdown.push(up.top());\n\t\tup.pop();\n\t\tcout &lt;&lt; down.top() &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 163 生日礼物\n&#x2F;*\n首先，我们要使m段的和尽量大，首先需要选m段，并使得m段尽量都为整数。如果整数段数cnt≤m的话，那么我们全部选上即可，而如果cnt&gt;m 的话，那么我们则需要删除部分段，而对于删除我们则有下面两个操作可选：\n\n设k&#x3D;cnt−m\n而现在我们的问题可以转化为，使我们删除的k段尽量地小。\n\n1.删除1段整数\n2.合并j段整数与j−1段负数(+负 &#x3D;&#x3D; -|负|)\n而对于操作一来说相当于减去ai，对于操作二来说相当于减去|ai|。\n且我们选择的两段肯定不相连（如果选了两端相连的相当于选一段正一段负，一定不会是答案）。\n\n而到此这个问题可以转化为P3620 【[APIO&#x2F;CTSC 2007]数据备份】\n我们就可以通过数据备份这道题的做法去处理这个子问题。\n\n作者：wxy_\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;12794&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nint a[N], l[N], r[N];\nbool st[N];\n\nvoid remove(int p)\n&#123;\n\t&#x2F;&#x2F; 从链表中删去\n\tl[r[p]] &#x3D; l[p];\n\tr[l[p]] &#x3D; r[p];\n\n\t&#x2F;&#x2F; 从heap里删去\n\tst[p] &#x3D; true;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\n\tint k &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint x;\n\t\tcin &gt;&gt; x;\n\t\tif ((long long)a[k] * x &lt; 0) a[ ++ k] &#x3D; x;&#x2F;&#x2F;new一段\n\t\telse a[k] +&#x3D; x;\n\t&#125;\n\n\tn &#x3D; k;\n\t&#x2F;&#x2F;正段数 sum\n\tint cnt &#x3D; 0, res &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tif (a[i] &gt; 0)\n\t\t&#123;\n\t\t\tcnt ++ ;\n\t\t\tres +&#x3D; a[i];\n\t\t&#125;\n\n\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n\t&#x2F;&#x2F;建双链表\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tl[i] &#x3D; i - 1;\n\t\tr[i] &#x3D; i + 1;\n\n\t\theap.push(&#123;abs(a[i]), i&#125;); &#x2F;&#x2F; abs\n\t&#125;\n\n\twhile (cnt &gt; m)\n\t&#123;\n\t\twhile (st[heap.top().second]) heap.pop();\n\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\n\t\tint v &#x3D; t.first, p &#x3D; t.second; &#x2F;&#x2F; value pos\n\n\t\tif (l[p] !&#x3D; 0 &amp;&amp; r[p] !&#x3D; n + 1 || a[p] &gt; 0)\n\t\t&#123;\n\t\t\tcnt -- ;\n\t\t\tres -&#x3D; v;\n\t\t\t&#x2F;&#x2F; 3合1\n\t\t\tint left &#x3D; l[p], right &#x3D; r[p];\n\t\t\ta[p] +&#x3D; a[left] + a[right];\n\n\t\t\theap.push(&#123;abs(a[p]), p&#125;);\n\t\t\tremove(left);\n\t\t\tremove(right);\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;38861&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n</code></pre>\n\n\n\n<h1 id=\"0x20搜索\"><a href=\"#0x20搜索\" class=\"headerlink\" title=\"0x20搜索\"></a>0x20搜索</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;&#x2F;可达性统计  topsort(BFS) + 状压bitset |\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;bitset&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 30010;\n\nint n, m;&#x2F;&#x2F; v e\nint h[N], e[N], ne[N], idx;\nint d[N], seq[N];&#x2F;&#x2F;入度 topo-seq\n\nbitset&lt;N&gt; f[N];&#x2F;&#x2F;f[i]:i的可达点!!!\n\nvoid add(int a, int b)\n&#123;\n\te[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid topsort()\n&#123;\n\tqueue&lt;int&gt; q;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tif(!d[i]) q.push(i);\n\t\n\tint k &#x3D; 0;\n\twhile(q.size())\n\t&#123;\n\t\tint t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tseq[k++] &#x3D; t;\n\t\tfor(int i &#x3D; h[t]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif(--d[j] &#x3D;&#x3D; 0) q.push(j);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\n\tmemset(h, -1, sizeof h);\n\tfor (int i &#x3D; 0; i &lt; m; i++)\n\t&#123;\n\t\tint a, b;\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\tadd(a, b);\n\t\td[b] ++ ;\n\t&#125;\n\ttopsort();\n\n\tfor (int i &#x3D; n - 1; ~i; i--)\n\t&#123;\n\t\tint j &#x3D; seq[i];\n\t\tf[j][j] &#x3D; 1;&#x2F;&#x2F; f[x][i](f[x]第i位) &#x3D; 1 or 0: x--&gt;i是否可达\n\n\t\tfor(int p &#x3D; h[j]; ~p; p &#x3D; ne[p])\n\t\t\tf[j] |&#x3D; f[e[p]];&#x2F;&#x2F;!!!\n\t&#125;\n\t&#x2F;&#x2F;f[i].count返回有多少位为1\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; f[i].count() &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x22 DFS\n&#x2F;&#x2F;子集和问题\n\n&#x2F;&#x2F;全排列问题\n\n&#x2F;&#x2F;N皇后问题\n\n\n&#x2F;&#x2F;小猫爬山\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 20;\n\nint n, m;\nint cat[N], sum[N];\nint ans &#x3D; N;\n\nvoid dfs(int u, int k)&#x2F;&#x2F;u:cur cat, 已租用k车\n&#123;\n\tif(k &gt;&#x3D; ans) return;\n\tif(u &#x3D;&#x3D; n)\n\t&#123;\n\t\tans &#x3D; k;\n\t\treturn;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\tif(cat[u] + sum[i] &lt;&#x3D; m)\n\t\t&#123;\n\t\t\tsum[i] +&#x3D; cat[u];\n\t\t\tdfs(u + 1, k);\n\t\t\tsum[i] -&#x3D; cat[u];\n\t\t&#125;\n\tsum[k] &#x3D; cat[u];\n\tdfs(u + 1, k + 1);\n\tsum[k] &#x3D; 0;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 0;i &lt; n; i++) cin &gt;&gt; cat[i];\n\n\tsort(cat, cat + n);\n\treverse(cat, cat + n);\n\n\tdfs(0, 0);\n\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数独\n&#x2F;&#x2F; 递归函数不加inline!!!!!!!\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 9;\n\nint ones[1 &lt;&lt; N], map[1 &lt;&lt; N];\nint row[N], col[N], cell[3][3];\nchar str[100];\n\ninline int lowbit(int x)\n&#123;\n\treturn x &amp; -x;\n&#125;\n\nvoid init()\n&#123;\n\tfor(int i &#x3D; 0; i &lt; N; i++) row[i] &#x3D; col[i] &#x3D; (1 &lt;&lt; N) - 1;\n\tfor(int i &#x3D; 0; i &lt; 3; i++)\n\t\tfor(int j &#x3D; 0; j &lt; 3; j++)\n\t\t\tcell[i][j] &#x3D; (1 &lt;&lt; N) - 1;\n&#125;\n\ninline int get(int x, int y)\n&#123;\n\treturn row[x] &amp; col[y] &amp; cell[x &#x2F; 3][y &#x2F; 3];\n&#125;\n\nbool dfs(int cnt)\n&#123;\n\tif(!cnt) return true;\n\n\t&#x2F;&#x2F;找出可选方案数(可填数字)最少的空格\n\tint minv &#x3D; 10;\n\tint x, y;\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\tif(str[i * 9 + j] &#x3D;&#x3D; &#39;.&#39;)&#x2F;&#x2F;可填\n\t\t\t&#123;\n\t\t\t\tint t &#x3D; ones[get(i, j)];\n\t\t\t\tif(t &lt; minv)\n\t\t\t\t&#123;\n\t\t\t\t\tminv &#x3D; t;\n\t\t\t\t\tx &#x3D; i, y &#x3D; j;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\tfor(int i &#x3D; get(x, y); i; i -&#x3D; lowbit(i))\n\t&#123;\n\t\tint t &#x3D; map[lowbit(i)];\n\n\t\trow[x] -&#x3D; 1 &lt;&lt; t;\n\t\tcol[y] -&#x3D; 1 &lt;&lt; t;\n\t\tcell[x &#x2F; 3][y &#x2F; 3] -&#x3D; 1 &lt;&lt; t;\n\t\tstr[x * 9 + y] &#x3D; &#39;1&#39; + t;&#x2F;&#x2F;填上\n\t\t&#x2F;&#x2F;递归更新答案\n\t\tif(dfs(cnt - 1)) return true;&#x2F;&#x2F;cnt倒序\n\t\t&#x2F;&#x2F;行不通：回溯\n\t\trow[x] +&#x3D; 1 &lt;&lt; t;\n\t\tcol[y] +&#x3D; 1 &lt;&lt; t;\n\t\tcell[x &#x2F; 3][y &#x2F; 3] +&#x3D; 1 &lt;&lt; t;\n\t\tstr[x * 9 + y] &#x3D; &#39;.&#39;;&#x2F;&#x2F;还原\n\t&#125;\n\treturn false;\n&#125;\n\n\nint main()\n&#123;\n\t&#x2F;&#x2F;预处理\n\tfor(int i &#x3D; 0; i &lt; N; i++) map[1 &lt;&lt; i] &#x3D; i;\n\tfor(int i &#x3D; 0; i &lt; 1 &lt;&lt; N; i++) \n\t&#123;\n\t\tint s &#x3D; 0;\n\t\tfor (int j &#x3D; i; j; j -&#x3D; lowbit(j)) s++;\n\t\tones[i] &#x3D; s;&#x2F;&#x2F; i的二进制表示中有s个1\n\t&#125;\n\n\twhile(cin &gt;&gt; str, str[0] !&#x3D; &#39;e&#39;)\n\t&#123;\n\t\tinit();&#x2F;&#x2F;全1，筛掉不能填的 置0\n\n\t\tint cnt &#x3D; 0;\n\t\tfor (int i &#x3D; 0, k &#x3D; 0; i &lt; N; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt; N; j++, k++)\n\t\t\t\tif(str[k] !&#x3D; &#39;.&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tint t &#x3D; str[k] - &#39;1&#39;;\n\t\t\t\t\trow[i] -&#x3D; 1 &lt;&lt; t;\n\t\t\t\t\tcol[j] -&#x3D; 1 &lt;&lt; t;\n\t\t\t\t\tcell[i &#x2F; 3][j &#x2F; 3] -&#x3D; 1 &lt;&lt; t;\n\t\t\t\t&#125;\n\t\t\t\telse cnt++;\n\n\t\tdfs(cnt);&#x2F;&#x2F;cnt倒序\n\n\t\tcout &lt;&lt; str &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;剪枝\n&#x2F;&#x2F;木棒 yxc版\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 64;\n\nint n, sum, length;\nint sticks[N];\nbool st[N];&#x2F;&#x2F;visited\n\nbool dfs(int u, int cur, int start)&#x2F;&#x2F;第u根已长cur\n&#123;\n\tif(u * length &#x3D;&#x3D; sum) return true;\n\n\tif(cur &#x3D;&#x3D; length) return dfs(u + 1, 0, 0);\n\n\tfor(int i &#x3D; start; i &lt; n; i++)\n\t&#123;\n\t\tif(st[i]) continue;&#x2F;&#x2F;访问过\n\t\tint l &#x3D; sticks[i];\n\t\tif(cur + l &gt; length) continue;\n\n\t\tst[i] &#x3D; true;\n\t\tif(dfs(u, cur + l, i + 1)) return true;\n\t\tst[i] &#x3D; false;&#x2F;&#x2F;还原\n\n\t\t&#x2F;&#x2F; 剪枝3 如果是第一个木棒失败，则一定失败\n\t\tif(!cur) return false;\n\t\t&#x2F;&#x2F; 剪枝4 如果是最后一个木棒失败，则一定失败\n\t\tif(cur + l &#x3D;&#x3D; length) return false;\n\t\t&#x2F;&#x2F; 剪枝2 跳过相同木棒\n\t\tint j &#x3D; i;\n\t\twhile(j &lt; n &amp;&amp; sticks[j] &#x3D;&#x3D; l) j++;\n\t\ti &#x3D; j - 1;\n\t&#125;\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tsum &#x3D; 0, length &#x3D; 0;\n\t\tmemset(st, false, sizeof st);\n\t\t\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; sticks[i];\n\t\t\tif(sticks[i] &gt; 50) continue;\n\t\t\tsum +&#x3D; sticks[i];\n\t\t\tlength &#x3D; max(length, sticks[i]);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 剪枝：优化搜索顺序\n\t\tsort(sticks, sticks + n);\n\t\treverse(sticks, sticks + n);\n\t\t\n\t\t&#x2F;&#x2F; for(int i &#x3D; 0; i &lt; n; i++)\n\t\t&#x2F;&#x2F; \tif(sticks[i] &gt; 50) st[i] &#x3D; true;\n\t\t\n\t\twhile(true)&#x2F;&#x2F;!!!\n\t\t&#123;\n\t\t\tif(sum % length &#x3D;&#x3D; 0 &amp;&amp; dfs(0, 0, 0))\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; length &lt;&lt; endl;\n\t\t\t\tbreak;&#x2F;&#x2F;!!!\n\t\t\t&#125;\n\t\t\tlength++;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;木棒\tAuthor:XuHt    \n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 70;&#x2F;&#x2F;大一点！！！\nint n, a[N], len, sum, val;\nbool v[N];\n\nbool dfs(int stick, int cab, int last) &#123;\n\tif (stick * len &gt; sum) return 1;\n\tif (cab &#x3D;&#x3D; len) return dfs(stick + 1, 0, 1);\n\tint fail &#x3D; 0;\n\tfor (int i &#x3D; last; i &lt;&#x3D; n; i++)&#x2F;&#x2F; 1\n\t\tif (!v[i] &amp;&amp; cab + a[i] &lt;&#x3D; len &amp;&amp; fail !&#x3D; a[i]) &#123;&#x2F;&#x2F; 2\n\t\t\tv[i] &#x3D; 1;\n\t\t\tif (dfs(stick, cab + a[i], i + 1)) return 1;\n\t\t\tfail &#x3D; a[i];\n\t\t\tv[i] &#x3D; 0;\n\t\t\tif (!cab || cab + a[i] &#x3D;&#x3D; len) return 0;&#x2F;&#x2F; 3 4\n\t\t&#125;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &amp;&amp; n) &#123;\n\t\tsum &#x3D; 0, val &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\t\tcin &gt;&gt; a[i];\n\t\t\tif(a[i] &gt; 50) continue;\n\t\t\tsum +&#x3D; a[i];\n\t\t\tval &#x3D; max(val, a[i]);\n\t\t\tv[i] &#x3D; 0;&#x2F;&#x2F;！！！\n\t\t&#125;\n\t\tsort(a + 1, a + n + 1);&#x2F;&#x2F; 0\n\t\treverse(a + 1, a + n + 1);\n\t\tfor (len &#x3D; val; len &lt;&#x3D; sum; len++) &#123;\n\t\t\tif (sum % len) continue;\n\t\t\t&#x2F;&#x2F; memset(v, 0, sizeof(v));&#x2F;&#x2F;循环内memset耗时!!!\n\t\t\tif (dfs(1, 0, 1)) break;\n\t\t&#125;\n\t\tcout &lt;&lt; len &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;生日蛋糕 yxc版\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 25, INF &#x3D; 1e9;\n\nint n, m;\nint R[N], H[N];\nint minv[N], mins[N];\nint ans &#x3D; INF;\n\nvoid dfs(int u, int v, int s)&#x2F;&#x2F;从下往上搜,上u层待定，已有v,s侧\n&#123;\n\t&#x2F;&#x2F;剪枝\n\tif(v + minv[u] &gt; n) return;&#x2F;&#x2F;已有+待定min\n\tif(s + mins[u] &gt;&#x3D; ans) return;\n\tif(s + 2 * (n - v) &#x2F; R[u + 1] &gt;&#x3D; ans) return;\n\n\tif(!u)\n\t&#123;\n\t\tif(n &#x3D;&#x3D; v) ans &#x3D; s;\n\t\treturn;\n\t&#125;\n\t&#x2F;&#x2F;range,倒序\n\tfor (int r &#x3D; min((int)sqrt(n - v), R[u + 1] - 1); r &gt;&#x3D; u; r--)\n\t\tfor (int h &#x3D; min((n - v) &#x2F; r &#x2F; r, H[u + 1] - 1); h &gt;&#x3D; u; h--)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; if(v + minv[u - 1] &gt; n) continue;&#x2F;&#x2F;FPE + 看不懂？？？\n\t\t\t&#x2F;&#x2F; if(s + mins[u - 1] &gt;&#x3D; ans) continue;\n\t\t\t&#x2F;&#x2F; if(s + 2 * (n - v) &#x2F; R[u] &gt;&#x3D; ans) continue;\n\n\t\t\tint t &#x3D; 0;\n\t\t\tif(u &#x3D;&#x3D;  m) t &#x3D; r * r;&#x2F;&#x2F;上表面积之和\n\t\t\tR[u] &#x3D; r, H[u] &#x3D; h;&#x2F;&#x2F;初始化R[u]、H[u]，用于定u-1层的rh-range!!!\n\t\t\tdfs(u - 1, v + r * r * h, s + 2 * r * h + t);\n\t\t\t&#x2F;&#x2F;v,h不变(不是+&#x3D;)，不用(-&#x3D;)还原现场!\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t&#123;\n\t\tminv[i] &#x3D; minv[i - 1] + i * i * i;&#x2F;&#x2F;rrh\n\t\tmins[i] &#x3D; mins[i - 1] + 2 * i * i;&#x2F;&#x2F;2rh\n\t&#125;\n\n\tR[m + 1] &#x3D; H[m + 1] &#x3D; INF;&#x2F;&#x2F;哨兵,求min()!!!!\n\tdfs(m, 0, 0);&#x2F;&#x2F;从下往上\n\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;书上标程 ？？？？？？？？？\n#include &lt;cmath&gt; \n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int INF &#x3D; 0x7fffffff;\nint n, m;\nint minv[30], mins[30], ans &#x3D; INF;\nint h[30], r[30], s &#x3D; 0, v &#x3D; 0;\n\nvoid dfs(int dep) &#123;\n\n\tif (v + minv[dep] &gt; n) return;\n\tif (s + mins[dep] &gt;&#x3D; ans) return;\n\tif (s + 2 * (n - v) &#x2F; r[dep+1] &gt;&#x3D; ans) return;\n\n\tif (!dep) &#123;\n\t\tif (v &#x3D;&#x3D; n) ans &#x3D; min(ans, s);\n\t\treturn;\n\t&#125;\n\n\tfor (r[dep] &#x3D; min((int)sqrt(n - v), r[dep + 1] - 1); r[dep] &gt;&#x3D; dep; r[dep]--)\n\t\tfor (h[dep] &#x3D; min((int)((double)(n-v) &#x2F; r[dep] &#x2F; r[dep]), h[dep+1] - 1); h[dep] &gt;&#x3D; dep; h[dep]--) \n\t\t&#123;   &#x2F;&#x2F;与循环外剪枝等效!!!\n\t\t\tif (v + minv[dep-1] &gt; n) continue;\n\t\t\t&#x2F;&#x2F;v&#x3D;&#x3D;(dep+1)~m层总体积,为什么+minv[dep-1]??????????\n\t\t\tif (s + mins[dep-1] &gt;&#x3D; ans) continue;\n\t\t\tif (s + 2 * (n - v) &#x2F; r[dep] &gt;&#x3D; ans) continue;\n\n\t\t\tif (dep &#x3D;&#x3D; m) s +&#x3D; r[dep] * r[dep];\n\t\t\ts +&#x3D; 2 * r[dep] * h[dep];\n\t\t\tv +&#x3D; r[dep] * r[dep] * h[dep];\n\t\t\tdfs(dep - 1); \n\t\t\tif (dep &#x3D;&#x3D; m) s -&#x3D; r[dep] * r[dep];\n\t\t\ts -&#x3D; 2 * r[dep] * h[dep];\n\t\t\tv -&#x3D; r[dep] * r[dep] * h[dep];\n\t\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tminv[0] &#x3D; mins[0] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tminv[i] &#x3D; minv[i-1] + i * i * i;\n\t\tmins[i] &#x3D; mins[i-1] + i * i;\n\t&#125;\n\th[m+1] &#x3D; r[m+1] &#x3D; INF;\n\tdfs(m);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数独2\n#include &lt;cstring&gt; \n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 16, M &#x3D; N * N + 1;\nint ones[1 &lt;&lt; N], log[1 &lt;&lt; N];\nint state[N][N];\nchar str[N][N + 1];\n\nint bstate[M][N][N], bstate2[M][N][N];&#x2F;&#x2F;M层搜索的备份\nchar bstr[M][N][N + 1];\n\ninline int lowbit(int x)\n&#123;\n\treturn x &amp; -x;\n&#125;\n\nvoid draw(int x, int y, int c)\n&#123;\n\tstr[x][y] &#x3D; c + &#39;A&#39;;&#x2F;&#x2F;填字母\n\t&#x2F;&#x2F;改状态\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t&#123;\n\t\tstate[x][i] &amp;&#x3D; ~(1 &lt;&lt; c);&#x2F;&#x2F;c位置0 ，或-&#x3D; (1 &lt;&lt; c)\n\t\tstate[i][y] &amp;&#x3D; ~(1 &lt;&lt; c);\n\t&#125;\n\n\tint sx &#x3D; x &#x2F; 4 * 4, sy &#x3D; y &#x2F; 4 * 4;\n\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t\tfor(int j &#x3D; 0; j &lt; 4; j++)\n\t\t\tstate[sx + i][sy + j] &amp;&#x3D; ~(1 &lt;&lt; c);\n\n\tstate[x][y] &#x3D; 1 &lt;&lt; c;&#x2F;&#x2F;!!!\n&#125;\n\nbool dfs(int cnt)\n&#123;\n\tif(!cnt) return true;\n\t&#x2F;&#x2F;备份\n\tint kcnt &#x3D; cnt;\n\tmemcpy(bstate[kcnt], state, sizeof state);\n\tmemcpy(bstr[kcnt], str, sizeof str);\n\n\t&#x2F;&#x2F;剪枝1:位置填字母\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\tif(str[i][j] &#x3D;&#x3D; &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tint s &#x3D; state[i][j];\n\t\t\t\tif(!s)&#x2F;&#x2F;无字母可填：无解\n\t\t\t\t&#123;\n\t\t\t\t\tmemcpy(state, bstate[kcnt], sizeof state);\n\t\t\t\t\tmemcpy(str, bstr[kcnt], sizeof str);\n\t\t\t\t\treturn false;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;只能填一个字母：直接填\n\t\t\t\tif(ones[s] &#x3D;&#x3D; 1)\n\t\t\t\t&#123;\n\t\t\t\t\tdraw(i, j, log[s]);\n\t\t\t\t\tcnt--;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t&#x2F;&#x2F;剪枝2:字母的合法位置 每行\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t&#123;\n\t\tint sor &#x3D; 0, sand &#x3D; (1 &lt;&lt; N) - 1;\n\t\tint drawn &#x3D; 0;\n\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t&#123;\n\t\t\tint s &#x3D; state[i][j];\n\t\t\tsand &amp;&#x3D; ~(s &amp; sor);&#x2F;&#x2F;多于一处可填字母置0 \n\t\t\tsor |&#x3D; s; &#x2F;&#x2F; 该行能填字母的并集\n\n\t\t\tif(str[i][j] !&#x3D; &#39;-&#39;) drawn |&#x3D; state[i][j];&#x2F;&#x2F;该行drawn的字母\n\t\t&#125;\n\n\t\tif(sor !&#x3D; (1 &lt;&lt; N) - 1)&#x2F;&#x2F;(非全1)有字母不能填在该行\n\t\t&#123;\n\t\t\tmemcpy(state, bstate[kcnt], sizeof state);\n\t\t\tmemcpy(str, bstr[kcnt], sizeof str);\n\t\t\treturn false;\n\t\t&#125;\n\t\tfor(int j &#x3D; sand; j; j -&#x3D; lowbit(j))\n\t\t&#123;\n\t\t\tint t &#x3D; lowbit(j);\n\t\t\tif(!(drawn &amp; t))&#x2F;&#x2F;该字母没被drawn过\n\t\t\t&#123;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; N; k++)\n\t\t\t\t\tif(state[i][k] &amp; t)&#x2F;&#x2F;该位可填t\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tdraw(i, k, log[t]);\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;2 每列\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t&#123;\n\t\tint sor &#x3D; 0, sand &#x3D; (1 &lt;&lt; N) - 1;\n\t\tint drawn &#x3D; 0;\n\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t&#123;\n\t\t\tint s &#x3D; state[j][i];\n\t\t\tsand &amp;&#x3D; ~(s &amp; sor);&#x2F;&#x2F;多于一处可填字母置0 \n\t\t\tsor |&#x3D; s; &#x2F;&#x2F; 该行能填字母的并集\n\n\t\t\tif(str[j][i] !&#x3D; &#39;-&#39;) drawn |&#x3D; state[j][i];&#x2F;&#x2F;该列drawn的字母\n\t\t&#125;\n\n\t\tif(sor !&#x3D; (1 &lt;&lt; N) - 1)&#x2F;&#x2F;(非全1)有字母不能填在该行\n\t\t&#123;\n\t\t\tmemcpy(state, bstate[kcnt], sizeof state);\n\t\t\tmemcpy(str, bstr[kcnt], sizeof str);\n\t\t\treturn false;\n\t\t&#125;\n\t\tfor(int j &#x3D; sand; j; j -&#x3D; lowbit(j))\n\t\t&#123;\n\t\t\tint t &#x3D; lowbit(j);\n\t\t\tif(!(drawn &amp; t))&#x2F;&#x2F;该字母没被drawn过\n\t\t\t&#123;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; N; k++)\n\t\t\t\t\tif(state[k][i] &amp; t)&#x2F;&#x2F;该位可填t\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tdraw(k, i, log[t]);\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;2 每16宫格 [i][j]:第i(0~15)个16宫格的第j(0~15)格  \n\t&#x2F;&#x2F; state[sx + dx][sy + dy] 遍历的是每个4*4的16宫格做剪枝，与state[i][j]无映射关系，只是每行每列每16宫格遍历元素不同罢了。!!!!!!!\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t&#123;\n\t\tint sor &#x3D; 0, sand &#x3D; (1 &lt;&lt; N) - 1;\n\t\tint drawn &#x3D; 0;\n\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;[s0 4 8 12 + d0 1 2 3]   [大16&#x2F;][小16%]\n\t\t\tint sx &#x3D; i &#x2F; 4 * 4, sy &#x3D; i % 4 * 4;\n\t\t\tint dx &#x3D; j &#x2F; 4, dy &#x3D; j % 4;\n\t\t\tint s &#x3D; state[sx + dx][sy + dy];\n\t\t\tsand &amp;&#x3D; ~(s &amp; sor);&#x2F;&#x2F;多于一处可填字母置0 \n\t\t\tsor |&#x3D; s; &#x2F;&#x2F; 该行能填字母的并集\n\n\t\t\tif(str[sx + dx][sy + dy] !&#x3D; &#39;-&#39;) drawn |&#x3D; state[sx + dx][sy + dy];&#x2F;&#x2F;drawn的字母\n\t\t&#125;\n\n\t\tif(sor !&#x3D; (1 &lt;&lt; N) - 1)&#x2F;&#x2F;(非全1)有字母不能填在该行\n\t\t&#123;\n\t\t\tmemcpy(state, bstate[kcnt], sizeof state);\n\t\t\tmemcpy(str, bstr[kcnt], sizeof str);\n\t\t\treturn false;\n\t\t&#125;\n\t\tfor(int j &#x3D; sand; j; j -&#x3D; lowbit(j))\n\t\t&#123;\n\t\t\tint t &#x3D; lowbit(j);\n\t\t\tif(!(drawn &amp; t))&#x2F;&#x2F;该字母没被drawn过\n\t\t\t&#123;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; N; k++)\n\t\t\t\t&#123;\n\t\t\t\t\tint sx &#x3D; i &#x2F; 4 * 4, sy &#x3D; i % 4 * 4;\n\t\t\t\t\tint dx &#x3D; k &#x2F; 4, dy &#x3D; k % 4;\n\t\t\t\t\tif(state[sx + dx][sy + dy] &amp; t)&#x2F;&#x2F;该位可填t\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tdraw(sx + dx, sy + dy, log[t]);\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;剪枝0\n\tif(!cnt) return true;\n\n\tint x, y, s &#x3D; 100;\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\tif(str[i][j] &#x3D;&#x3D; &#39;-&#39; &amp;&amp; ones[state[i][j]] &lt; s)\n\t\t\t&#123;\n\t\t\t\ts &#x3D; ones[state[i][j]];\n\t\t\t\tx &#x3D; i, y &#x3D; j;\n\t\t\t&#125;\n\n\tmemcpy(bstate2[kcnt], state, sizeof state);\n\tfor(int i &#x3D; state[x][y]; i; i -&#x3D; lowbit(i))\n\t&#123;\n\t\tmemcpy(state, bstate2[kcnt], sizeof state);\n\t\tdraw(x, y, log[lowbit(i)]);\n\n\t\tif(dfs(cnt - 1)) return true;\n\t&#125;\n\t&#x2F;&#x2F;恢复现场\n\tmemcpy(state, bstate[kcnt], sizeof state);\n\tmemcpy(str, bstr[kcnt], sizeof str);\n\treturn false; \n&#125;\n\nint main()\n&#123;\n\tfor(int i &#x3D; 0; i &lt; N; i++) log[1 &lt;&lt; i] &#x3D; i;\n\tfor(int i &#x3D; 0; i &lt; 1 &lt;&lt; N; i++)\n\t\tfor(int j &#x3D; i; j; j -&#x3D; lowbit(j)) ones[i]++;\n\t\n\twhile(cin &gt;&gt; str[0])\n\t&#123;\n\t\tfor(int i &#x3D; 1; i &lt; N; i++) cin &gt;&gt; str[i];\n\n\t\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\t\tstate[i][j] &#x3D; (1 &lt;&lt; N) - 1;\n\n\t\tint cnt &#x3D; 0;\t&#x2F;&#x2F; 存储空格的个数\n\t\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\t\tif(str[i][j] !&#x3D; &#39;-&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tdraw(i, j, str[i][j] - &#39;A&#39;);\n\t\t\t\t&#125;\n\t\t\t\telse cnt++;\n\n\t\tdfs(cnt);\n\n\t\tfor(int i &#x3D; 0; i &lt; N; i++) cout &lt;&lt; str[i] &lt;&lt; endl;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数独2 （Dancing Links版）待填坑。。。。。。。。。。。。\n\n&#x2F;&#x2F;0x24迭代加深DFS\n&#x2F;&#x2F;加成序列\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110;\n\nint n;\nint path[N];\n\nbool dfs(int u, int depth)\n&#123;\n\tif(u &#x3D;&#x3D; depth) return path[u - 1] &#x3D;&#x3D; n;\n\t&#x2F;&#x2F;判重\n\tbool st[N] &#x3D; &#123;false&#125;;\n\t&#x2F;&#x2F;从大到小枚举\n\tfor(int i &#x3D; u - 1; i &gt;&#x3D; 0; i--)\n\t\tfor(int j &#x3D; i; j &gt;&#x3D; 0; j--)&#x2F;&#x2F; 0 &lt;&#x3D; j &lt;&#x3D; i &lt;&#x3D; u - 1\n\t\t&#123;\n\t\t\tint s &#x3D; path[i] + path[j];\n\t\t\tif(s &gt;&#x3D; path[u - 1] &amp;&amp; s &lt;&#x3D; n &amp;&amp; !st[s])&#x2F;&#x2F;s递增\n\t\t\t&#123;\n\t\t\t\tst[s] &#x3D; true;\n\t\t\t\tpath[u] &#x3D; s;\n\t\t\t\tif(dfs(u + 1, depth)) return true;\n\t\t\t&#125;\n\t\t&#125;\n\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tint depth &#x3D; 1;\n\t\tpath[0] &#x3D; 1;\n\t\twhile(!dfs(1, depth)) depth++;&#x2F;&#x2F;cur_d max_d\n\n\t\tfor(int i &#x3D; 0; i &lt; depth; i++) cout &lt;&lt; path[i] &lt;&lt; &#39; &#39;;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;双向DFS\n&#x2F;&#x2F;送礼物\n&#x2F;*\n二分模板\n版本1 求min mid在左\n版本2 求max mid在右 +1原因:lr相邻时mid&#x3D;&#x3D;l(+1让mid&#x3D;&#x3D;r), l&#x3D;mid;即l&#x3D;l;死循环!!!\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N &#x3D; 45;\n\nint n, m, k;\nint g[N];\nint weights[1 &lt;&lt; 24], cnt;\nint ans;\n\nvoid dfs_1(int u, int s)\n&#123;\n\tif(u &#x3D;&#x3D; k)\n\t&#123;\n\t\tweights[cnt++] &#x3D; s;\n\t\treturn;\n\t&#125;\n\tif((LL)s + g[u] &lt;&#x3D; m) dfs_1(u + 1, s + g[u]);\n\tdfs_1(u + 1, s);\n&#125;\n\nvoid dfs_2(int u, int s)\n&#123;\n\tif(u &#x3D;&#x3D; n)&#x2F;&#x2F;二分模板 求max 版本2\n\t&#123;\n\t\tint l &#x3D; 0, r &#x3D; cnt - 1;\n\t\twhile(l &lt; r)\n\t\t&#123;\n\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;&#x2F;&#x2F;mid&#x3D;&#x3D;r\n\t\t\tif((LL)weights[mid] + s &lt;&#x3D; m) l &#x3D; mid;&#x2F;&#x2F;&lt;&#x3D;m的max  防溢出\n\t\t\telse r &#x3D; mid - 1;\n\t\t&#125;\n\t\tif((LL)weights[r] + s &lt;&#x3D; m) ans &#x3D; max(ans, weights[r] + s);&#x2F;&#x2F;+会溢出！！！\n\n\t\treturn;\n\t&#125;\n\n\tif((LL)s + g[u] &lt;&#x3D; m) dfs_2(u + 1, s + g[u]);\n\tdfs_2(u + 1, s);\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; m &gt;&gt; n;&#x2F;&#x2F;m:重量上限\n\tfor (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; g[i];\n\n\tsort(g, g + n);\n\treverse(g, g + n);\n\n\tk &#x3D; n &#x2F; 2 + 2;&#x2F;&#x2F;!!!!\n\tdfs_1(0, 0);&#x2F;&#x2F;cur sum\n\n\tsort(weights, weights + cnt);\n\tcnt &#x3D; unique(weights, weights + cnt) - weights;\n\n\tdfs_2(k, 0);\n\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x25 BFS\n&#x2F;&#x2F;立体推箱子 Bloxorz推木头 http:&#x2F;&#x2F;www.4399.com&#x2F;flash&#x2F;13071_1.htm\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 510;\n\nstruct State\n&#123;\n\tint x, y, lie;\n&#125;;\n\nint n, m;\nchar g[N][N];\nint dist[N][N][3];\n\nbool check(int x, int y)\n&#123;\n\tif(x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; m) return false;&#x2F;&#x2F;出界\n\treturn g[x][y] !&#x3D; &#39;#&#39;;\n&#125;\n\nint bfs(State start, State end)\n&#123;\n\tmemset(dist, -1, sizeof dist);\n\tdist[start.x][start.y][start.lie] &#x3D; 0;\n\tqueue&lt;State&gt; q;\n\tq.push(start);\n\t&#x2F;&#x2F;state012 direction上右下左 &#123;x,y,lie&#125;\n\tint d[3][4][3] &#x3D; &#123;\n\t\t&#123;&#123;-2, 0, 2&#125;, &#123;0, 1, 1&#125;, &#123;1, 0, 2&#125;, &#123;0, -2, 1&#125;&#125;,   &#x2F;&#x2F;0 立着\n\t\t&#123;&#123;-1, 0, 1&#125;, &#123;0, 2, 0&#125;, &#123;1, 0, 1&#125;, &#123;0, -1, 0&#125;&#125;,   &#x2F;&#x2F;1 横躺\n\t\t&#123;&#123;-1, 0, 0&#125;, &#123;0, 1, 2&#125;, &#123;2, 0, 0&#125;, &#123;0, -1, 2&#125;&#125;,   &#x2F;&#x2F;2 竖躺\n\t&#125;;\n\t\n\twhile(q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\t\t\n\t\t&#x2F;&#x2F;扩展t\n\t\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t\t&#123;\n\t\t\tState next &#x3D; &#123;t.x + d[t.lie][i][0], t.y + d[t.lie][i][1], d[t.lie][i][2]&#125;;&#x2F;&#x2F;!!!\n\t\t\t\n\t\t\tint x &#x3D; next.x, y &#x3D; next.y;\n\t\t\tif(!check(x, y)) continue;\n\t\t\t\n\t\t\tif(next.lie &#x3D;&#x3D; 0 &amp;&amp; g[x][y] &#x3D;&#x3D; &#39;E&#39;) continue;&#x2F;&#x2F;太重\n\t\t\tif(next.lie &#x3D;&#x3D; 1 &amp;&amp; !check(x, y + 1)) continue;&#x2F;&#x2F;出界 撞墙\n\t\t\tif(next.lie &#x3D;&#x3D; 2 &amp;&amp; !check(x + 1, y)) continue;\n\t\t\t\n\t\t\tif(dist[x][y][next.lie] &#x3D;&#x3D; -1)\n\t\t\t&#123;\n\t\t\t\tdist[x][y][next.lie] &#x3D; dist[t.x][t.y][t.lie] + 1;\n\t\t\t\tq.push(next);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;算出从st出发到所有能走的点的dist，只取dist[end]\n\treturn dist[end.x][end.y][end.lie];\n&#125;\n\nint main()\n&#123;\n\twhile(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)\n\t&#123;\n\t\tfor(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; g[i];\n\t\t\n\t\tState start &#x3D; &#123;-1&#125;, end;\n\t\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; m; j++)\n\t\t\t\tif(g[i][j] &#x3D;&#x3D; &#39;X&#39; &amp;&amp; start.x &#x3D;&#x3D; -1)&#x2F;&#x2F;第一次遍历起点\n\t\t\t\t&#123;\n\t\t\t\t\tif(g[i][j + 1] &#x3D;&#x3D; &#39;X&#39;) start &#x3D; &#123;i, j, 1&#125;;\n\t\t\t\t\telse if(g[i + 1][j] &#x3D;&#x3D; &#39;X&#39;) start &#x3D; &#123;i, j, 2&#125;;\n\t\t\t\t\telse start &#x3D; &#123;i, j, 0&#125;;\n\t\t\t\t&#125;\n\t\t\t\telse if(g[i][j] &#x3D;&#x3D; &#39;O&#39;) end &#x3D; &#123;i, j, 0&#125;;\n\t\t\n\t\tint res &#x3D; bfs(start, end);\n\t\tif(res &#x3D;&#x3D; -1) puts(&quot;Impossible&quot;);\n\t\telse printf(&quot;%d\\n&quot;, res);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;矩阵距离\tBFS多源最短路 +虚拟远点&#x3D;dijkstra\t类似flood fill\n&#x2F;&#x2F;puts()函数用来向标准输出设备（屏幕）输出字符串并换行，具体为：把字符串输出到标准输出设备，将&#39;\\0&#39;转换为回车换行。\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 1010;\n\nint n, m;\nchar g[N][N];\nint d[N][N];\n\nint bfs()\n&#123;\n\tmemset(d, -1, sizeof d);\n\tqueue&lt;PII&gt; q;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; m; j++)\n\t\t\tif(g[i][j] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tq.push(&#123;i, j&#125;);\n\t\t\t\td[i][j] &#x3D; 0;\n\t\t\t&#125;\n\n\tint dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\twhile(q. size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\tfor (int i &#x3D; 0; i &lt; 4; i++)\n\t\t&#123;\n\t\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n\t\t\tif(a &gt;&#x3D; 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; d[a][b] &#x3D;&#x3D; -1)\n\t\t\t&#123;\n\t\t\t\td[a][b] &#x3D; d[x][y] + 1;\n\t\t\t\tq.push(&#123;a, b&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]);\n\n\tbfs();\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; m; j++)\n\t\t\tprintf(&quot;%d &quot;, d[i][j]);\n\t\tputs(&quot;&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;推箱子 S推B到T  yxc版\n&#x2F;*\n1.箱子移动次数最少\n2.人移动次数最少\n3.N、S、W、E的顺序优先选择箱子的移动方向（即先上下推，再左右推）\n4.按照n、s、w、e的顺序优先选择人的移动方向（即先上下动，再左右动）\n\n如果把箱子和人看做整体更新状态只能保证整体总步数最小，而题中首先要使箱子移动次数最小。\n\n首先假设有一只手可以直接推箱子，每个格子之间仍然可以看做是权值为1的两个点，整个矩阵就一个无向图，可以bfs求最短路（宽搜的本质是迪杰斯特拉算法）\n\n但是当箱子在某个点时，还要存储这个箱子是从哪个方向被推过来的，将箱子的位置和方向一起看做一个点，进行宽搜，再看人从上一个状态到这个状态最短路是多长，同样是宽搜。\n\n在箱子的队列中，步数单调增加，但是，在箱子的步数增加1时，按照题目给出的顺序，不同的加1路径对应的人增加的步数不一定是单调增加的。但只要根据队列中的元素依次扩展节点，每次扩展都更新人的步数即可\n\n一定要注意箱子和人的位置对方向的加减！注意状态的更新，不要漏记录某个值！\n*&#x2F;\n&#x2F;*\n如果按箱子移动次数来分层的话，这道题目本质上是求分层图的最短路。上面的代码会一层一层来做，从前一层推后一层的时候，会求出从前一层的每个起点出发，到达下一层每个终点的最短距离，因此这样求出的每层之间人走过的距离一定是最短的，但这只是一个局部最优解。然后我们发现每层之间的状态是完全独立的，因此当所有层都取到最小值的时候，得到的结果一定也是全局最优解。所以上面的代码可以在保证层数最少的情况下，人走过的步数也最少。\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 25;\n\nstruct Node\n&#123;\n\tint x, y, dir;\n&#125;;\n\nint n, m;\nchar g[N][N];   &#x2F;&#x2F; 存储游戏地图\nbool st[N][N][4], used[N][N];   &#x2F;&#x2F; BFS的判重数组，为了防止BFS遍历相同状态\nint dx[4] &#x3D; &#123;1, -1, 0, 0&#125;, dy[4] &#x3D; &#123;0, 0, 1, -1&#125;;  &#x2F;&#x2F;(-)依次表示下、上、右、左四个方向\nPII dist[N][N][4];  &#x2F;&#x2F;前缀！ dist[j][k][i]是表示【从初始状态】到达j,k,i状态所需要的箱子最短路程和人行走最短路程\nvector&lt;int&gt; path[N][N][4];  &#x2F;&#x2F; path[j][k][i] 表示人从推(j,k,i)的上一个状态的位置，走到推(j,k,i)这个状态的位置的行走路径\nNode pre[N][N][4];  &#x2F;&#x2F; 表示箱子在(x, y)，上一个格子在i(+)方向上的状态，即上一个状态是(x + dx[i], y + dy[i]) ---i---&gt;(x,y)\nint pre_man[N][N];  &#x2F;&#x2F;(-)dir!!! pre_man[x][y]表示人从哪个方向【(-)dir】走到(x, y)，如果pre_man[x][y] &#x3D; i(-), 那么上一个状态是(x - dx[i], y - dy[i]) -(-)(-)\n\nbool check(int x, int y)    &#x2F;&#x2F; 判断(x, y)是否在地图内，且是空地\n&#123;\n\treturn x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] !&#x3D; &#39;#&#39;;\n&#125;\n\n\n&#x2F;&#x2F; 求人从start走到end，中间不经过box的最短路径，行走序列保存在seq中(&amp;！！！)\nint bfs_man(PII start, PII end, PII box, vector&lt;int&gt; &amp;seq)\n&#123;\n\tmemset(used, false, sizeof used);\n\tmemset(pre_man, -1, sizeof pre_man);\n\n\tqueue&lt;PII&gt; q;&#x2F;&#x2F;从start扩展时临时记录&#123;x,y&#125;用的队列\n\tq.push(start);\n\tused[start.first][start.second] &#x3D; true;\n\tused[box.first][box.second] &#x3D; true;\n\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tif (t &#x3D;&#x3D; end)\n\t\t&#123;\n\t\t\tseq.clear();\n\t\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t\twhile (pre_man[x][y] !&#x3D; -1)\n\t\t\t&#123;\n\t\t\t\tint dir &#x3D; pre_man[x][y] ^ 1;&#x2F;&#x2F;(+)取反&#x3D;&#x3D;(-)\n\t\t\t\tseq.push_back(dir);&#x2F;&#x2F;seq倒序\n\t\t\t\tx +&#x3D; dx[dir], y +&#x3D; dy[dir];&#x2F;&#x2F;沿着seq回退(-)\n\t\t\t&#125;\n\n\t\t\treturn seq.size();\n\t\t&#125;\n\n\t\tfor (int ii &#x3D; 0; ii &lt; 4; ii ++ )&#x2F;&#x2F;0123\n\t\t&#123;\n\t\t\tint i &#x3D; ii ^ 1;&#x2F;&#x2F;1032\n\t\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];&#x2F;&#x2F;dy(-) i(-) dy[i](+):nswe (x,y)-ii-&gt;(a,b)\n\t\t\tif (check(a, b) &amp;&amp; !used[a][b])\n\t\t\t&#123;\n\t\t\t\tused[a][b] &#x3D; true;\n\t\t\t\tpre_man[a][b] &#x3D; i;\n\t\t\t\tq.push(&#123;a, b&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\treturn -1;\n&#125;\n\nbool bfs_box(PII man, PII box, Node &amp;end)\n&#123;\n\tmemset(st, false, sizeof st);\n\t&#x2F;&#x2F;初态init\n\tqueue&lt;Node&gt; q;\n\tfor (int i &#x3D; 0; i &lt; 4; i ++ )\n\t&#123;\n\t\tint x &#x3D; box.first, y &#x3D; box.second;&#x2F;&#x2F;人 箱子(ab)(x,y:box初值)-&gt;(xy)(jk)\n\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];&#x2F;&#x2F;dy(-)\n\t\tint j &#x3D; x - dx[i], k &#x3D; y - dy[i];\n\t\tvector&lt;int&gt; seq;\n\n\t\tif (check(a, b) &amp;&amp; check(j, k) &amp;&amp; bfs_man(man, &#123;a, b&#125;, box, seq) !&#x3D; -1)\n\t\t&#123;\n\t\t\tst[j][k][i] &#x3D; true;\n\t\t\tq.push(&#123;j, k, i&#125;);\n\t\t\tdist[j][k][i] &#x3D; &#123;1, seq.size()&#125;;&#x2F;&#x2F;初态前缀&#x3D;&#x3D;部分\n\t\t\tpath[j][k][i] &#x3D; seq;\n\t\t\tpre[j][k][i] &#x3D; &#123;x, y, -1&#125;;\n\t\t&#125;\n\t&#125;\n\n\tbool success &#x3D; false;\n\tPII man_d &#x3D; &#123;1e9, 1e9&#125;;\n\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\t\t&#x2F;&#x2F;处理终点\n\t\tif (g[t.x][t.y] &#x3D;&#x3D; &#39;T&#39;)\n\t\t&#123;\n\t\t\tsuccess &#x3D; true;\n\n\t\t\tif (dist[t.x][t.y][t.dir] &lt; man_d)\n\t\t\t&#123;\n\t\t\t\tman_d &#x3D; dist[t.x][t.y][t.dir];&#x2F;&#x2F;min_dist  为了找min_path(best_t)服务\n\t\t\t\tend &#x3D; t;&#x2F;&#x2F;取pos到end时多个t中的最佳Node状态best_t\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;扩展（记录前缀）\n\t\tfor (int i &#x3D; 0; i &lt; 4; i ++ )\n\t\t&#123;\n\t\t\tint a &#x3D; t.x + dx[i], b &#x3D; t.y + dy[i];&#x2F;&#x2F;人 箱子(ab)(t.x,t.y)-&gt;(t.x,t.y)(jk)\n\t\t\tint j &#x3D; t.x - dx[i], k &#x3D; t.y - dy[i];&#x2F;&#x2F;-(-(+))&#x3D;&#x3D;(+)\n\t\t\tif (check(a, b) &amp;&amp; check(j, k))\n\t\t\t&#123;\n\t\t\t\tvector&lt;int&gt; seq;\n\t\t\t\tauto &amp;p &#x3D; dist[j][k][i];\n\t\t\t\tint distance &#x3D; bfs_man(&#123;t.x + dx[t.dir], t.y + dy[t.dir]&#125;, &#123;a, b&#125;, &#123;t.x, t.y&#125;, seq);\n\t\t\t\tif (distance !&#x3D; -1)\n\t\t\t\t&#123;\n\t\t\t\t\tPII td &#x3D; &#123;dist[t.x][t.y][t.dir].first + 1, dist[t.x][t.y][t.dir].second + distance&#125;;\n\t\t\t\t\tif (!st[j][k][i])\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tst[j][k][i] &#x3D; true;\n\t\t\t\t\t\tq.push(&#123;j, k, i&#125;);\n\t\t\t\t\t\tp &#x3D; td;&#x2F;&#x2F;前缀\n\t\t\t\t\t\tpath[j][k][i] &#x3D; seq;&#x2F;&#x2F;部分\n\t\t\t\t\t\tpre[j][k][i] &#x3D; t;\n\t\t\t\t\t&#125;\n&#x2F;* 这里不是在比较推箱子的次数，而是在比较当推箱子次数相同时，人所走过的\n总距离。当第一次访问某个状态时只能保证推箱子次数最少，但并不能保证人的\n次数也最少。所以这条分支不能去掉。*&#x2F;\n\t\t\t\t\telse if (p &gt; td)&#x2F;&#x2F;更新min_man\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tp &#x3D; td;\n\t\t\t\t\t\tpath[j][k][i] &#x3D; seq;\n\t\t\t\t\t\tpre[j][k][i] &#x3D; t;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\treturn success;\n&#125;\n\nvoid output(Node end)\n&#123;\n\tchar ops[] &#x3D; &quot;nswe&quot;;\n\tstring res;\n\twhile (end.dir !&#x3D; -1)&#x2F;&#x2F;ops[dir]路径回溯\n\t&#123;\n\t\tres +&#x3D; ops[end.dir] - 32;&#x2F;&#x2F;NSWE\n\t\tfor (auto dir : path[end.x][end.y][end.dir]) res +&#x3D; ops[dir];&#x2F;&#x2F;path倒序串起来\n\t\tend &#x3D; pre[end.x][end.y][end.dir];\n\t&#125;\n\t\n\treverse(res.begin(), res.end());\n\tcout &lt;&lt; res &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n\tint T &#x3D; 1;\n\twhile (cin &gt;&gt; n &gt;&gt; m, n || m)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];\n\n\t\tprintf(&quot;Maze #%d\\n&quot;, T ++ );\n\t\t&#x2F;&#x2F;定man box初值\n\t\tPII man, box;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\t\tfor (int j &#x3D; 0; j &lt; m; j ++ )\n\t\t\t\tif (g[i][j] &#x3D;&#x3D; &#39;S&#39;) man &#x3D; &#123;i, j&#125;;\n\t\t\t\telse if (g[i][j] &#x3D;&#x3D; &#39;B&#39;) box &#x3D; &#123;i, j&#125;;\n\n\t\tNode end;\n\n\t\tif (!bfs_box(man, box, end)) puts(&quot;Impossible.&quot;);\n\t\telse output(end);\n\t\tputs(&quot;&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;推箱子 蓝书标程版\t\t慢一倍\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 26, INF &#x3D; 0x3f3f3f3f;\nchar A[4] &#x3D; &#123;&#39;N&#39;,&#39;S&#39;,&#39;W&#39;,&#39;E&#39;&#125;;\nchar a[4] &#x3D; &#123;&#39;n&#39;,&#39;s&#39;,&#39;w&#39;,&#39;e&#39;&#125;;\nint r, c, num &#x3D; 0;\nint d[4][2]&#x3D; &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;&#x2F;&#x2F;NSWE\nchar s[N][N];&#x2F;&#x2F;地图\nstring tmp;\n\nstruct P &#123;\n\tint x, y, px, py;&#x2F;&#x2F;箱子x y, 人px py\n\tstring ans;&#x2F;&#x2F;移动方案\n&#125;;\n\nbool pd(int x, int y) &#123;\n\treturn x &gt; 0 &amp;&amp; x &lt;&#x3D; r &amp;&amp; y &gt; 0 &amp;&amp; y &lt;&#x3D; c &amp;&amp; s[x][y] !&#x3D; &#39;#&#39;;\n&#125;\n\nbool bfs2(P p1, P p2) &#123;\n\ttmp &#x3D; &quot;&quot;;\n\tP st;\n\tst.x &#x3D; p1.px, st.y &#x3D; p1.py;&#x2F;&#x2F;xy代替人pos移动 (不用管px py,只记录ans)\n\tst.ans &#x3D; &quot;&quot;;\n\tqueue&lt;P&gt; q;\n\tq.push(st);\n\tbool v[N][N];\n\tmemset(v, 0, sizeof(v));\n\twhile (q.size()) &#123;\n\t\tP now &#x3D; q.front(), nxt;\n\t\tq.pop();\n\t\tif (now.x &#x3D;&#x3D; p1.x &amp;&amp; now.y &#x3D;&#x3D; p1.y) &#123;&#x2F;&#x2F;人走到p1虚拟箱子处（终点）\n\t\t\ttmp &#x3D; now.ans;\n\t\t\treturn 1;\n\t\t&#125;\n\t\tfor (int i &#x3D; 0; i &lt; 4; i++) &#123;\n\t\t\tnxt &#x3D; now;\n\t\t\tnxt.x &#x3D; now.x + d[i][0];\n\t\t\tnxt.y &#x3D; now.y + d[i][1];\n\t\t\tif (!pd(nxt.x, nxt.y)) continue;\n\t\t\tif (v[nxt.x][nxt.y]) continue;\n\t\t\tif (nxt.x &#x3D;&#x3D; p2.x &amp;&amp; nxt.y &#x3D;&#x3D; p2.y) continue;&#x2F;&#x2F;不能经过箱子\n\t\t\tv[nxt.x][nxt.y] &#x3D; 1;\n\t\t\tnxt.ans &#x3D; now.ans + a[i];&#x2F;&#x2F;人走1步\n\t\t\tq.push(nxt);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nstring bfs1() &#123;\n\tP st;\n\tst.x &#x3D; st.y &#x3D; st.px &#x3D; st.py &#x3D; -1;\n\tst.ans &#x3D; &quot;&quot;;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; r &amp;&amp; (st.x &#x3D;&#x3D; -1 || st.px &#x3D;&#x3D; -1); i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; c &amp;&amp; (st.x &#x3D;&#x3D; -1 || st.px &#x3D;&#x3D; -1); j++)\n\t\t\tif (s[i][j] &#x3D;&#x3D; &#39;B&#39;) &#123;\n\t\t\t\tst.x &#x3D; i, st.y &#x3D; j;\n\t\t\t\ts[i][j] &#x3D; &#39;.&#39;;\n\t\t\t&#125; else if (s[i][j] &#x3D;&#x3D; &#39;S&#39;) &#123;\n\t\t\t\tst.px &#x3D; i, st.py &#x3D; j;\n\t\t\t\ts[i][j] &#x3D; &#39;.&#39;;&#x2F;&#x2F;\n\t\t\t&#125;\n\tqueue&lt;P&gt; q;\n\tq.push(st);\n\tbool v[N][N][4];&#x2F;&#x2F;visited\n\tmemset(v, 0, sizeof(v));\n\tstring ans &#x3D; &quot;Impossible.&quot;;\n\tunsigned int cntans &#x3D; INF, cnt &#x3D; INF;&#x2F;&#x2F;箱子长，总长\n\twhile (q.size()) &#123;\n\t\tP prv, now &#x3D; q.front(), nxt;\n\t\tq.pop();\n\t\t&#x2F;&#x2F;处理终点\n\t\tif (s[now.x][now.y] &#x3D;&#x3D; &#39;T&#39;) &#123;\n\t\t\tunsigned int cntnow &#x3D; 0;\n\t\t\tfor (unsigned int i &#x3D; 0; i &lt; now.ans.length(); i++)\n\t\t\t\tif (now.ans[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; now.ans[i] &lt;&#x3D; &#39;Z&#39;) ++cntnow;&#x2F;&#x2F;箱子动\n\t\t\tif (cntnow &lt; cntans || (cntnow &#x3D;&#x3D; cntans &amp;&amp; now.ans.length() &lt; cnt)) &#123;&#x2F;&#x2F;保持步数二元组(step_box:cntans, step_man:cnt)单调性！！\n\t\t\t\tans &#x3D; now.ans;&#x2F;&#x2F;总seq\n\t\t\t\tcntans &#x3D; cntnow;&#x2F;&#x2F;箱子长\n\t\t\t\tcnt &#x3D; now.ans.length();&#x2F;&#x2F;总长\n\t\t\t&#125;\n\t\t\tcontinue;\n\t\t&#125;\n\t\t&#x2F;&#x2F;扩展\n\t\tfor (int i &#x3D; 0; i &lt; 4; i++) &#123;\n\t\t\tnxt &#x3D; now;&#x2F;&#x2F;nxt人覆盖\n\t\t\tnxt.x &#x3D; now.x + d[i][0];&#x2F;&#x2F;箱子变\n\t\t\tnxt.y &#x3D; now.y + d[i][1];\n\t\t\tif (!pd(nxt.x, nxt.y)) continue;&#x2F;&#x2F;位置无效\n\t\t\tif (v[nxt.x][nxt.y][i]) continue;&#x2F;&#x2F;访问过\n\t\t\t\n\t\t\tprv &#x3D; now;\n\t\t\tprv.x &#x3D; now.x - d[i][0];&#x2F;&#x2F;箱子虚拟移动到bfs2人的终点\n\t\t\tprv.y &#x3D; now.y - d[i][1];\n\t\t\tif (!bfs2(prv, now)) continue;\n\t\t\tv[nxt.x][nxt.y][i] &#x3D; 1;\n\t\t\tnxt.ans &#x3D; now.ans + tmp;&#x2F;&#x2F;前缀+bfs2_seq(记录量较大)\n\t\t\tnxt.ans +&#x3D; A[i];&#x2F;&#x2F;箱推1\n\t\t\tnxt.px &#x3D; now.x;&#x2F;&#x2F;人变\n\t\t\tnxt.py &#x3D; now.y;\n\t\t\tq.push(nxt);\n\t\t&#125;\n\t&#125;\n\treturn ans;&#x2F;&#x2F;总seq\n&#125;\n\nvoid Pushing_Boxes() &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; r; i++) cin &gt;&gt; (s[i] + 1);\n\tcout &lt;&lt; &quot;Maze #&quot; &lt;&lt; ++num &lt;&lt; endl &lt;&lt; bfs1() &lt;&lt; endl &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; r &gt;&gt; c, r || c) Pushing_Boxes();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x26 BFS变形\n&#x2F;&#x2F;双端队列BFS\n&#x2F;&#x2F;电路维修\n&#x2F;* \n题目中给定的方格是 n*m 的，所以格点共有 (n+1)*(m+1) 个。\n左上角格点编号是 (0,0)，右下角格点编号是 (n,m)。！！！！！！！\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 510;\n\nint n, m;\nchar g[N][N];\nint d[N][N];\nbool st[N][N];\n\nint bfs()\n&#123;\n\tmemset(st, 0, sizeof st);\n\tmemset(d, 0x3f, sizeof d);\n\t\n\tdeque&lt;PII&gt; dq;\n\tdq.push_back(&#123;0, 0&#125;);\n\td[0][0] &#x3D; 0;\n\t&#x2F;&#x2F; d:4角格点  i:4周方格编号(左上角)\n\tint dx[4] &#x3D; &#123;-1, -1, 1, 1&#125;, dy[4] &#x3D; &#123;-1, 1, 1, -1&#125;;\n\tint ix[4] &#x3D; &#123;-1, -1, 0, 0&#125;, iy[4] &#x3D; &#123;-1, 0, 0, -1&#125;;\n\tchar cs[] &#x3D; &quot;\\\\&#x2F;\\\\&#x2F;&quot;;\n\n\twhile(dq.size())\n\t&#123;\n\t\tauto t &#x3D; dq.front();\n\t\tdq.pop_front();\n\n\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t&#x2F;&#x2F; 每个点虽然可能入队多次，但第一次出来的时候就已经取到最小值了（dijkstra算法的性质），因此后面重复出队的点应该直接忽略。\n\t\tif (st[x][y]) continue;\n\t\tst[x][y] &#x3D; true;\n\t\t\n\t\tfor (int i &#x3D; 0; i &lt; 4; i++)\n\t\t&#123;\n\t\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n\t\t\tint j &#x3D; x + ix[i], k &#x3D; y + iy[i];\n\t\t\tif(a &gt;&#x3D; 0 &amp;&amp; a &lt;&#x3D; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt;&#x3D; m)\n\t\t\t&#123;\n\t\t\t\tint w &#x3D; 0;\n\t\t\t\tif(g[j][k] !&#x3D; cs[i]) w &#x3D; 1;&#x2F;&#x2F;格点与t(x,y)不连通\n\t\t\t\tif(d[a][b] &gt; d[x][y] + w)&#x2F;&#x2F;d(00-&gt;xy-&gt;ab) &lt; d(00-&gt;ab)\n\t\t\t\t&#123;\n\t\t\t\t\td[a][b] &#x3D; d[x][y] + w;&#x2F;&#x2F;更新d(ab)\n\t\t\t\t\tif (w) dq.push_back(&#123;a, b&#125;);&#x2F;&#x2F;1入队尾\n\t\t\t\t\telse dq.push_front(&#123;a, b&#125;);&#x2F;&#x2F;0入队头\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif(d[n][m] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n\treturn d[n][m];\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]);\n\n\t\tint t &#x3D; bfs();\n\t\tif(t &#x3D;&#x3D; -1) puts(&quot;NO SOLUTION&quot;);\n\t\telse printf(&quot;%d\\n&quot;, t);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;优先队列BFS(Dijkstra)\n&#x2F;&#x2F;装满的油箱\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010, M &#x3D; 20010, C &#x3D; 1010;\n\nint n, m;\nint h[N], e[M], w[M], ne[M], idx;&#x2F;&#x2F;w:edge_cost\nint price[N];\nint dist[N][C];&#x2F;&#x2F;从&#123;start,0&#125;到 &#123;N点，油剩余c&#125; 的最少money花费\nint st[N][C];\n\n\nstruct Ver\n&#123;\n\tint d, u, c;&#x2F;&#x2F;dist cur_city contains_oil\n\tbool operator &lt; (const Ver &amp;W) const\n\t&#123;\n\t\treturn d &gt; W.d;\n\t&#125;\n&#125;;\n\nvoid add(int a, int b, int c)\n&#123;\n\te[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;\n&#125;\n\nint dijkstra(int c, int start, int end)&#x2F;&#x2F;容量c s-&gt;e\n&#123;\n\tpriority_queue&lt;Ver&gt; heap;&#x2F;&#x2F;小根堆\n\tmemset(dist, 0x3f, sizeof dist);&#x2F;&#x2F;dist&#x3D;正无穷\n\tmemset(st, false, sizeof st);\n\theap.push(&#123;0, start, 0&#125;);&#x2F;&#x2F;d[start] &#x3D; 0;\n\n\twhile(heap.size())\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\n\t\tif(t.u &#x3D;&#x3D; end) return t.d;\n\t\t\n\t\tif(st[t.u][t.c]) continue;\n\t\tst[t.u][t.c] &#x3D; true;&#x2F;&#x2F;cur_city contains_oil\n\t\t&#x2F;&#x2F;1. oil+1\n\t\tif(t.c &lt; c)&#x2F;&#x2F;duc:dist cur_city contains_oil\n\t\t&#123;\n\t\t\tif(dist[t.u][t.c + 1] &gt; t.d + price[t.u])\n\t\t\t&#123;\n\t\t\t\tdist[t.u][t.c + 1] &#x3D; t.d + price[t.u];&#x2F;&#x2F;花钱price[t.u]\n\t\t\t\theap.push(&#123;dist[t.u][t.c + 1], t.u, t.c + 1&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;2. 遍历邻边\n\t\tfor(int i &#x3D; h[t.u]; ~i; i &#x3D; ne[i])&#x2F;&#x2F;~i &#x3D;&#x3D; i&gt;&#x3D;0, -1:全1 ~:全0\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif(t.c &gt;&#x3D; w[i])\n\t\t\t&#123;\n\t\t\t\tif(dist[j][t.c - w[i]] &gt; t.d)\n\t\t\t\t&#123;\n\t\t\t\t\tdist[j][t.c - w[i]] &#x3D; t.d;&#x2F;&#x2F;不花钱 耗油可到,直接用d更新\n\t\t\t\t\theap.push(&#123;t.d, j, t.c - w[i]&#125;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;price[i]);&#x2F;&#x2F;城市油价\n\tmemset(h, -1, sizeof h);\n\twhile(m--)\n\t&#123;\n\t\tint a, b, c;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n\t\tadd(a, b, c), add(b, a, c);&#x2F;&#x2F;a-&gt;b cost\n\t&#125;\n\n\tint query;\n\tscanf(&quot;%d&quot;, &amp;query);\n\twhile(query--)\n\t&#123;\n\t\tint c, s, e;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;c, &amp;s, &amp;e);&#x2F;&#x2F;容量c s-&gt;e\n\t\tint t &#x3D; dijkstra(c, s, e);\n\t\tif(t &#x3D;&#x3D; -1) puts(&quot;impossible&quot;);\n\t\telse printf(&quot;%d\\n&quot;, t);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;双向BFS  2d-&gt;1d\n&#x2F;&#x2F;噩梦\n&#x2F;&#x2F; 每一秒鬼会先扩展，扩展完毕后男孩和女孩才可以移动。\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 810;\n\nint n, m;\nchar g[N][N];\nint st[N][N];\nPII ghost[2], boy, girl;\n\nbool check(int x, int y, int step)\n&#123;\n\tif(x &lt; 0 || x &gt;&#x3D;n || y &lt; 0 || y &gt;&#x3D;m || g[x][y] &#x3D;&#x3D; &#39;X&#39;) return false;\n\tfor (int i &#x3D; 0; i &lt; 2; i++)\n\t\tif(abs(x - ghost[i].first) + abs(y - ghost[i].second) &lt;&#x3D; step * 2) return false;\n\treturn true;\n&#125;\n\nint bfs()\n&#123;\n\tint dx[] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n\tint cnt &#x3D; 0;\n\tmemset(st, 0, sizeof st);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; m; j++)\n\t\t\tif(g[i][j] &#x3D;&#x3D; &#39;M&#39;) boy &#x3D; &#123;i, j&#125;;\n\t\t\telse if(g[i][j] &#x3D;&#x3D; &#39;G&#39;) girl &#x3D; &#123;i, j&#125;;\n\t\t\telse if(g[i][j] &#x3D;&#x3D; &#39;Z&#39;) ghost[cnt++] &#x3D; &#123;i, j&#125;;\n\t\n\tint step &#x3D; 0;&#x2F;&#x2F;秒数\n\tqueue&lt;PII&gt; qb, qg;\n\tqb.push(boy), qg.push(girl);\n\twhile(qb.size() || qg.size())\n\t&#123;\n\t\tstep ++;\n\t\t&#x2F;&#x2F;男走3\n\t\tfor (int i &#x3D; 0; i &lt; 3; i++)\n\t\t\tfor (int j &#x3D; 0, len &#x3D; qb.size(); j &lt; len; j++)\n\t\t\t&#123;\n\t\t\t\tauto t &#x3D; qb.top();\n\t\t\t\tqb.pop();\n\t\t\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t\t\tif(!check(x, y, step)) continue;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; 4; k++)\n\t\t\t\t&#123;\n\t\t\t\t\tint a &#x3D; x + dx[k], b &#x3D; y + dy[k];\n\t\t\t\t\tif(check(a, b, step))\n\t\t\t\t\t&#123;&#x2F;&#x2F;st&#x3D;0没走过 1男走过 2女走过\n\t\t\t\t\t\tif(st[a][b] &#x3D;&#x3D; 2) return step;\n\t\t\t\t\t\tif(!st[a][b])\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tst[a][b] &#x3D; 1;\n\t\t\t\t\t\t\tqb.push(&#123;a, b&#125;);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#x2F;&#x2F;女走1\n\t\tfor (int i &#x3D; 0; i &lt; 1; i++)\n\t\t\tfor (int j &#x3D; 0, len &#x3D; qg.size(); j &lt; len; j++)\n\t\t\t&#123;\n\t\t\t\tauto t &#x3D; qg.top();\n\t\t\t\tqg.pop();\n\t\t\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t\t\tif(!check(x, y, step)) continue;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; 4; k++)\n\t\t\t\t&#123;\n\t\t\t\t\tint a &#x3D; x + dx[k], b &#x3D; y + dy[k];\n\t\t\t\t\tif(check(a, b, step))\n\t\t\t\t\t&#123;&#x2F;&#x2F;st&#x3D;0没走过 1男走过 2女走过\n\t\t\t\t\t\tif(st[a][b] &#x3D;&#x3D; 1) return step;\n\t\t\t\t\t\tif(!st[a][b])\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tst[a][b] &#x3D; 2;\n\t\t\t\t\t\t\tqg.push(&#123;a, b&#125;);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\t\tfor(int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]);\n\t\tprintf(&quot;%d\\n&quot;, bfs());\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;auto C++11语法!!!!!!\n\n\n&#x2F;&#x2F;0x27 A* 最短路，边权非负(优先队列BFS + 估价(启发heuristic)函数)\n&#x2F;&#x2F;第k短路\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\ntypedef pair&lt;int, PII&gt; PIII;\n\nconst int N &#x3D; 1010, M &#x3D; 200010;\n\nint n, m;\nint h[N], rh[N], e[M], w[M], ne[M], idx;&#x2F;&#x2F;正反head\nint dist[N], f[N], st[N];&#x2F;&#x2F;st:出队次数\nint S, T, K;&#x2F;&#x2F;S-&gt;T K短\n\nvoid add(int *h, int a, int b, int c)\n&#123;\n\te[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;\n&#125;\n\nint dijkstra()\n&#123;\n\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n\tmemset(dist, 0x3f, sizeof dist);\n\tdist[T] &#x3D; 0;\n\theap.push(&#123;0, T&#125;);\n\n\twhile(heap.size())\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\t\t\n\t\tint ver &#x3D; t.second;&#x2F;&#x2F;&#123;dist[t], t&#125;\n\t\tif(st[ver]) continue;\n\t\tst[ver] &#x3D; 1;\n\n\t\tfor (int i &#x3D; rh[ver]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif(dist[j] &gt; dist[ver] + w[i])\n\t\t\t&#123;\n\t\t\t\tdist[j] &#x3D; dist[ver] + w[i];\n\t\t\t\theap.push(&#123;dist[j], j&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tmemcpy(f, dist, sizeof f);&#x2F;&#x2F;f:估价函数\n&#125;\n\nint a_star()\n&#123;\n\tpriority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap;\n\theap.push(&#123;f[S], &#123;0, S&#125;&#125;);&#x2F;&#x2F; f[i],&#123;dist[i],i&#125;\n\tmemset(st, 0, sizeof st);\n\n\twhile(heap.size())\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\n\t\tint ver &#x3D; t.second.second, distance &#x3D; t.second.first;\n\t\tif(st[ver] &gt;&#x3D; K) continue; &#x2F;&#x2F;优化!!!\n\t\tst[ver]++;\n\t\tif(ver &#x3D;&#x3D; T &amp;&amp; st[ver] &#x3D;&#x3D; K) return distance;\n\n\t\tfor (int i &#x3D; h[ver]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif(st[j] &lt; K)\n\t\t\t\theap.push(&#123;distance + w[i] + f[j], &#123;distance + w[i], j&#125;&#125;);\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tmemset(h, -1, sizeof h);\n\tmemset(rh, -1, sizeof rh);\n\twhile(m--)\n\t&#123;\n\t\tint a, b, c;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n\t\tadd(h, a, b, c), add(rh, b, a, c);\n\t&#125;\n\tscanf(&quot;%d%d%d&quot;, &amp;S, &amp;T, &amp;K);\n\tif(S &#x3D;&#x3D; T) K++;&#x2F;&#x2F; 每条最短路中至少要包含一条边。\n\n\tdijkstra();\n\n\tprintf(&quot;%d\\n&quot;, a_star());\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;八数码  prev: 记录+逆推\tpriority_queue不改元素:st\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010, M &#x3D; 200010;\n\nint f(string state)\n&#123;\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; state.size(); i++)\n\t\tif(state[i] !&#x3D; &#39;x&#39;)\n\t\t&#123;\n\t\t\tint t &#x3D; state[i] - &#39;1&#39;;\n\t\t\tres +&#x3D; abs(i &#x2F; 3 - t &#x2F; 3) + abs(i % 3 - t % 3);&#x2F;&#x2F;真实-cur dx+dy\n\t\t&#125;\n\treturn res;\n&#125;\nstring bfs(string start)\n&#123;\n\tint dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\tchar op[4] &#x3D; &#123;&#39;u&#39;, &#39;r&#39;, &#39;d&#39;, &#39;l&#39;&#125;;\n\n\tstring end &#x3D; &quot;12345678x&quot;;\n\tunordered_map&lt;string, int&gt; dist;\n\tunordered_map&lt;string, bool&gt; st;\n\tunordered_map&lt;string, pair&lt;string, char&gt;&gt; prev;&#x2F;&#x2F;prev_state, to_now_op\n\tpriority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; heap;\n\n\theap.push(&#123;f(start), start&#125;);\n\tdist[start] &#x3D; 0;\n\n\twhile(heap.size())\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\n\t\tstring state &#x3D; t.second;\n\t\tif(state &#x3D;&#x3D; end) break;&#x2F;&#x2F;!!!\n\t\t\n\t\tif(st[state]) continue;\n\t\tst[state] &#x3D; true;\n\n\t\tint step &#x3D; dist[state];\n\t\tint x, y;\n\t\tfor (int i &#x3D; 0; i &lt; state.size(); i++)\n\t\t\tif(state[i] &#x3D;&#x3D; &#39;x&#39;)\n\t\t\t&#123;\n\t\t\t\tx &#x3D; i &#x2F; 3, y &#x3D; i % 3;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\n\t\tstring source &#x3D; state;\n\t\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t\t&#123;\n\t\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n\t\t\tif(a &gt;&#x3D; 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; 3)\n\t\t\t&#123;\n\t\t\t\tswap(state[x * 3 + y], state[a * 3 + b]);&#x2F;&#x2F;备份\n\t\t\t\tif(!dist.count(state) || dist[state] &gt; step + 1)\n\t\t\t\t&#123;&#x2F;&#x2F;走一步\n\t\t\t\t\tdist[state] &#x3D; step + 1;&#x2F;&#x2F;Dijkstra\n\t\t\t\t\tprev[state] &#x3D; &#123;source, op[i]&#125;;\n\t\t\t\t\theap.push(&#123;dist[state] + f(state), state&#125;);\n\t\t\t\t&#125;\n\t\t\t\tswap(state[x * 3 + y], state[a * 3 + b]);&#x2F;&#x2F;还原\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tstring res;\n\twhile(end !&#x3D; start)\n\t&#123;\n\t\tres +&#x3D; prev[end].second;&#x2F;&#x2F;op\n\t\tend &#x3D; prev[end].first;&#x2F;&#x2F;prev\n\t&#125;\n\treverse(res.begin(), res.end());\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tstring g, c, seq;\n\twhile(cin &gt;&gt; c)\n\t&#123;\n\t\tg +&#x3D; c;\n\t\tif(c !&#x3D; &quot;x&quot;) seq +&#x3D; c;\n\t&#125;\n\n\tint t &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; seq.size(); i++)\n\t\tfor (int j &#x3D; i + 1; j &lt; seq.size(); j++)\n\t\t\tif(seq[i] &gt; seq[j])\n\t\t\t\tt++;\n\tif(t &amp; 1) puts(&quot;unsolvable&quot;);\n\telse cout &lt;&lt; bfs(g) &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x28 IDA* (迭代加深DFS + 估价函数)\n&#x2F;*\nID-DFS基本框架:\ndepth &#x3D; 0;\nwhile(!dfs(0, depth)) depth++;\nIDA*:\nif(now_depth + f() &gt; max_depth) return false;\n*&#x2F;\n&#x2F;&#x2F;排书\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 15;\n\nint n;\nint q[N];\nint w[5][N];\n\nint f()\n&#123;\n\tint tot &#x3D; 0;\n\tfor (int i &#x3D; 0; i + 1 &lt; n; i++)\n\t\tif(q[i + 1] !&#x3D; q[i] + 1)\n\t\t\ttot++;\n\treturn (tot + 2) &#x2F; 3;\n&#125;\n\nbool check()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tif(q[i] !&#x3D; i + 1) return false;\n\treturn true;\n&#125;\n\nbool dfs(int depth, int max_depth)\n&#123;\n\tif(depth + f() &gt; max_depth) return false;&#x2F;&#x2F;IDA*\n\tif(check()) return true;\n\n\t&#x2F;&#x2F;搜索每个分支\n\tfor (int len &#x3D; 1; len &lt;&#x3D; n; len++)&#x2F;&#x2F;枚举段长\n\t\tfor (int l &#x3D; 0; l + len - 1 &lt; n; l++)&#x2F;&#x2F;枚举起点\n\t\t&#123;\n\t\t\tint r &#x3D; l + len - 1;\n\t\t\tfor(int k &#x3D; r + 1; k &lt; n; k++)\n\t\t\t&#123;\n\t\t\t\tmemcpy(w[depth], q, sizeof q);\n\n\t\t\t\tint x, y;\n\t\t\t\tfor(x &#x3D; r + 1, y &#x3D; l; x &lt;&#x3D; k; x++, y++) q[y] &#x3D; w[depth][x];\n\t\t\t\t&#x2F;&#x2F;跳过部分[r+1, k]前移\n\t\t\t\tfor(x &#x3D; l; x &lt;&#x3D; r; x++, y++) q[y] &#x3D; w[depth][x];&#x2F;&#x2F;[l,r]移至k后\n\t\t\t\tif(dfs(depth + 1, max_depth)) return true;\n\n\t\t\t\tmemcpy(q, w[depth], sizeof q);\n\t\t\t&#125;\n\n\t\t&#125;\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;n);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]);\n\n\t\tint depth &#x3D; 0;\n\t\twhile(depth &lt; 5 &amp;&amp; !dfs(0, depth)) depth++;&#x2F;&#x2F;迭代加深\n\n\t\tif(depth &gt;&#x3D; 5) puts(&quot;5 or more&quot;);\n\t\telse printf(&quot;%d\\n&quot;, depth);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;回转游戏\n&#x2F;*\n\t  0     1\n\t  2     3\n4  5  6  7  8  9  10\n\t  11    12\n13 14 15 16 17 18 19\n\t  20    21\n\t  22    23\n*&#x2F;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 24;\n\nint op[8][7] &#x3D; &#123;\n\t&#123;0, 2, 6, 11, 15, 20, 22&#125;,\n\t&#123;1, 3, 8, 12, 17, 21, 23&#125;,\n\t&#123;10, 9, 8, 7, 6, 5, 4&#125;,\n\t&#123;19, 18, 17, 16, 15, 14, 13&#125;,\n\t&#123;23, 21, 17, 12, 8, 3, 1&#125;,\n\t&#123;22, 20, 15, 11, 6, 2, 0&#125;,\n\t&#123;13, 14, 15, 16, 17, 18, 19&#125;,\n\t&#123;4, 5, 6, 7, 8, 9, 10&#125;\n&#125;;\nint center[8] &#x3D; &#123;6, 7, 8, 11, 12, 15, 16, 17&#125;;\nint opposite[8] &#x3D; &#123;5, 4, 7, 6, 1, 0, 3, 2&#125;;\n\nint q[N];&#x2F;&#x2F;填充数字 123\nint path[100];\n\nint f()\n&#123;\n\tstatic int sum[4];\n\tmemset(sum, 0, sizeof sum);\n\tfor (int i &#x3D; 0; i &lt; 8; i ++ ) sum[q[center[i]]] ++ ;&#x2F;&#x2F;记录sum\n\tint s &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 3; i ++ ) s &#x3D; max(s, sum[i]);&#x2F;&#x2F;max_sum\n\treturn 8 - s;\n&#125;\n\nbool check()\n&#123;\n\tfor (int i &#x3D; 1; i &lt; 8; i ++ )\n\t\tif (q[center[i]] !&#x3D; q[center[0]])\n\t\t\treturn false;\n\treturn true;\n&#125;\n\nvoid operate(int x)\n&#123;\n\tint t &#x3D; q[op[x][0]];\n\tfor (int i &#x3D; 0; i &lt; 6; i ++ ) q[op[x][i]] &#x3D; q[op[x][i + 1]];\n\tq[op[x][6]] &#x3D; t;\n&#125;\n\nbool dfs(int depth, int max_depth, int last)\n&#123;\n\tif(depth + f() &gt; max_depth) return false;&#x2F;&#x2F;IDA*\n\tif(check()) return true;\n\t&#x2F;&#x2F;扩展其他分支\n\tfor (int i &#x3D; 0; i &lt; 8; i++)\n\t&#123;\n\t\tif(opposite[i] &#x3D;&#x3D; last) continue;\n\t\toperate(i);&#x2F;&#x2F;op-i\n\t\tpath[depth] &#x3D; i;&#x2F;&#x2F;记录op-i\n\t\tif(dfs(depth + 1, max_depth, i)) return true;&#x2F;&#x2F;递归\n\t\toperate(opposite[i]);&#x2F;&#x2F;恢复op-i\n\t&#125;\n\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\twhile (scanf(&quot;%d&quot;, &amp;q[0]), q[0])\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt; N; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);\n\t\tint depth &#x3D; 0;\n\t\twhile (!dfs(0, depth, -1)) depth ++ ;\n\t\t\n\t\tif (!depth) printf(&quot;No moves needed&quot;);\n\t\tfor (int i &#x3D; 0; i &lt; depth; i ++ ) printf(&quot;%c&quot;, &#39;A&#39; + path[i]);\n\t\tprintf(&quot;\\n%d\\n&quot;, q[6]);&#x2F;&#x2F;中间一圈填的数字\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;破坏正方形\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 61;\n\nint n, m;\nvector&lt;int&gt; square[N];\nbool st[N];\n\nbool check(vector&lt;int&gt; &amp;sq)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; sq.size(); i++)\n\t\tif(st[sq[i]]) return false;\n\treturn true;\n&#125;\n\nint f()\n&#123;\n\tstatic bool state[N];\n\tmemcpy(state, st, sizeof st);\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; m; i++)\n\t&#123;\n\t\tvector&lt;int&gt; &amp;sq &#x3D; square[i];\n\t\tif(check(sq))\n\t\t&#123;&#x2F;&#x2F;边全去掉，只记一次\n\t\t\tres ++ ;\n\t\t\tfor (int j &#x3D; 0; j &lt; sq.size(); j++) st[sq[j]] &#x3D; true;\n\t\t&#125;\n\t&#125;\n\tmemcpy(st, state, sizeof st);\n\treturn res;\n&#125;\n\nbool dfs(int depth, int max_depth)\n&#123;\n\tif(depth + f() &gt; max_depth) return false;\n\n\tfor (int i &#x3D; 0; i &lt; m; i++)\n\t&#123;\n\t\tvector&lt;int&gt; &amp;sq &#x3D; square[i];\n\t\tif(check(sq))&#x2F;&#x2F;sq完整\n\t\t&#123;\n\t\t\tfor (int j &#x3D; 0; j &lt; sq.size(); j++)\n\t\t\t&#123;\n\t\t\t\tint x &#x3D; sq[j];\n\t\t\t\tst[x] &#x3D; true;&#x2F;&#x2F;去掉火柴x\n\t\t\t\tif(dfs(depth + 1, max_depth)) return true;\n\t\t\t\tst[x] &#x3D; false;&#x2F;&#x2F;还原\n\t\t\t&#125;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;\n\treturn true;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;n);\n\n\t\tmemset(st, 0, sizeof st);\n\t\tm &#x3D; 0;\n\t\tfor (int len &#x3D; 1; len &lt;&#x3D; n; len++)&#x2F;&#x2F;枚举边长len\n\t\t\tfor (int a &#x3D; 1; a + len - 1 &lt;&#x3D; n; a++)&#x2F;&#x2F;枚举正方形m起点 行a 向下\n\t\t\t\tfor (int b &#x3D; 1; b + len - 1 &lt;&#x3D; n; b++)&#x2F;&#x2F;列b 向右\n\t\t\t\t&#123;\n\t\t\t\t\tauto &amp;sq &#x3D; square[m];\n\t\t\t\t\tsq.clear();\n\t\t\t\t\tint d &#x3D; 2 * n + 1;\n\t\t\t\t\tfor (int i &#x3D; 0; i &lt; len; i++)\n\t\t\t\t\t&#123;&#x2F;&#x2F;nswe\n\t\t\t\t\t\tsq.push_back(1 + (a - 1) * d + b - 1 + i);\n\t\t\t\t\t\tsq.push_back(1 + (a + len - 1) * d + b - 1 + i);\n\t\t\t\t\t\tsq.push_back(n + 1 + (a - 1) * d + b - 1 + i * d);\n\t\t\t\t\t\tsq.push_back(n + 1 + (a - 1) * d + b - 1 + i * d + len);\n\t\t\t\t\t&#125;\n\t\t\t\t\tm++;\n\t\t\t\t&#125;\n\t\tint k &#x3D; 0;\n\t\tscanf(&quot;%d&quot;, &amp;k);\n\t\twhile(k--)\n\t\t&#123;\n\t\t\tint x;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\tst[x] &#x3D; true;\n\t\t&#125;\n\n\t\tint depth &#x3D; 0;\n\t\twhile(!dfs(0, depth)) depth++;\n\t\tprintf(&quot;%d\\n&quot;, depth);&#x2F;&#x2F;去掉?根火柴&#x3D;&#x3D;搜索?层\n\t&#125;\n\n\treturn 0;\n&#125;\n\n------------------------------------------------------------------------------\n\n&#x2F;&#x2F;0x29 总结与练习\n&#x2F;&#x2F;靶形数独 （166数独 + 取最高分）\n&#x2F;&#x2F; 递归函数不加inline\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 9, M &#x3D; 1 &lt;&lt; N;\n\nint ones[M], log[M];\nint row[N], col[N], cell[3][3];\nint g[N][N];\nint ans &#x3D; -1;\n\ninline int lowbit(int x)\n&#123;\n\treturn x &amp; -x;\n&#125;\n\nvoid init()\n&#123;\n\tfor(int i &#x3D; 0; i &lt; N; i++) log[1 &lt;&lt; i] &#x3D; i;\n\tfor(int i &#x3D; 0; i &lt; M; i++)\n\t\tfor (int j &#x3D; i; j; j -&#x3D; lowbit(j)) \n\t\t\tones[i]++;\n\n\tfor(int i &#x3D; 0; i &lt; N; i++) row[i] &#x3D; col[i] &#x3D; cell[i &#x2F; 3][i % 3] &#x3D; M - 1;\n&#125;\n\ninline int get_score(int x, int y)\n&#123;\n\treturn min(min(x, 8 - x), min(y, 8 - y)) + 6;&#x2F;&#x2F;距边界最短距离0~4 + 6\n&#125;\n\ninline void draw(int x, int y, int t)\n&#123;\n\tint s &#x3D; 1;\n\tif(t &gt; 0) g[x][y] &#x3D; t;&#x2F;&#x2F;置0\n\telse &#x2F;&#x2F; t &lt; 0:  draw(x, y, -t);还原现场用\n\t&#123;\n\t\ts &#x3D; -1;&#x2F;&#x2F;抹掉t 置1\n\t\tt &#x3D; -t;&#x2F;&#x2F;使t &gt; 0\n\t\tg[x][y] &#x3D; 0;\n\t&#125;\n\tt--;&#x2F;&#x2F;1~9 -&gt; 0~8\n\trow[x] -&#x3D; s &lt;&lt; t;\n\tcol[y] -&#x3D; s &lt;&lt; t;\n\tcell[x &#x2F; 3][y &#x2F; 3] -&#x3D; s &lt;&lt; t;\n&#125;\n\ninline int get(int x, int y)&#x2F;&#x2F;x,y处可填的数\n&#123;\n\treturn row[x] &amp; col[y] &amp; cell[x &#x2F; 3][y &#x2F; 3];\n&#125;\n\nvoid dfs(int cnt, int score)\n&#123;\n\tif(!cnt)\n\t&#123;\n\t\tans &#x3D; max(ans, score);\n\t\treturn;\n\t&#125;\n\n\t&#x2F;&#x2F;找出可选方案数(可填数字)最少的空格\n\tint x, y, mins &#x3D; 10;\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\tif(!g[i][j])&#x2F;&#x2F;可填\n\t\t\t&#123;\n\t\t\t\tint t &#x3D; ones[get(i, j)];\n\t\t\t\tif(t &lt; mins)\n\t\t\t\t&#123;\n\t\t\t\t\tmins &#x3D; t;\n\t\t\t\t\tx &#x3D; i, y &#x3D; j;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\tfor(int i &#x3D; get(x, y); i; i -&#x3D; lowbit(i))\n\t&#123;\n\t\tint t &#x3D; log[lowbit(i)] + 1;&#x2F;&#x2F;0~8 -&gt; 1~9\n\t\tdraw(x, y, t);&#x2F;&#x2F;填t\n\t\tdfs(cnt - 1, score + t * get_score(x, y));&#x2F;&#x2F;递归\n\t\tdraw(x, y, -t);&#x2F;&#x2F;还原\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tinit();\n\n\tint cnt &#x3D; 0, score &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; N; i++)\n\t\tfor (int j &#x3D; 0; j &lt; N; j++)\n\t\t&#123;\n\t\t\tint x;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\tif(x)\n\t\t\t&#123;\n\t\t\t\tdraw(i, j, x);\n\t\t\t\tscore +&#x3D; x * get_score(i, j);\n\t\t\t&#125;\n\t\t\telse cnt ++;\n\t\t&#125;\n\n\tdfs(cnt, score);\n\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 184\t虫食算\t45.84%\t简单\n&#x2F;*\nN进制竖式加法，算式中三个数都有N位，允许有前导的0\n相同的数字用相同的字母表示\n前N个大写字母来表示这个算式中的0到N-1这N个不同的数字\nN个字母分别至少出现一次\n对于给定的N进制加法算式，【求出N个不同的字母分别代表的数字，使得该加法算式成立。】\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 30;\n\nint n;\nchar e[3][N];\nint q[N], path[N];\t&#x2F;&#x2F;path[q[u]] &#x3D; i; 字母&#x3D;数字\nbool st[N];\t\t\t&#x2F;&#x2F;st[i] &#x3D; true; 数字被用过\n\nbool check()\n&#123;\n\tfor (int i &#x3D; n - 1, t &#x3D; 0; i &gt;&#x3D; 0; i--)&#x2F;&#x2F;进位t只有0、1!!!!!!!!!!!!!!\n\t&#123;\n\t\tint a &#x3D; e[0][i] - &#39;A&#39;, b &#x3D; e[1][i] - &#39;A&#39;, c &#x3D; e[2][i] - &#39;A&#39;;\n\t\tif (path[a] !&#x3D; -1 &amp;&amp; path[b] !&#x3D; -1 &amp;&amp; path[c] !&#x3D; -1)&#x2F;&#x2F;cur列全定(字母全被赋值过)\n\t\t&#123;\n\t\t\ta &#x3D; path[a], b &#x3D; path[b], c &#x3D; path[c];\n\t\t\tif(t !&#x3D; -1)\n\t\t\t&#123;\n\t\t\t\tif((a + b + t) % n !&#x3D; c) return false;\n\t\t\t\tif(!i &amp;&amp; a + b + t &gt;&#x3D; n) return false;&#x2F;&#x2F;最高位无进位\n\t\t\t\tt &#x3D; (a + b + t) &#x2F; n;\n\t\t\t&#125;\n\t\t\telse &#x2F;&#x2F;之前列存在未定\n\t\t\t&#123;\n\t\t\t\tif((a + b + 0) % n !&#x3D; c &amp;&amp; (a + b + 1) % n !&#x3D; c) return false;\n\t\t\t\tif(!i &amp;&amp; a + b &gt;&#x3D; n) return false; &#x2F;&#x2F; if(0&gt;&#x3D;) 1&gt;&#x3D;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse t &#x3D; -1;&#x2F;&#x2F;cur列非全定（有字母未被赋值）\n\t&#125;\n\treturn true;\n&#125;\n\n\nvoid dfs(int u)&#x2F;&#x2F;u个字母已定\n&#123;\n\tif(u &#x3D;&#x3D; n) return true;\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tif(!st[i])\n\t\t&#123;\n\t\t\tst[i] &#x3D; true;\n\t\t\tpath[q[u]] &#x3D; i;\n\t\t\tif(check() &amp;&amp; dfs(u + 1)) return true;\n\t\t\tst[i] &#x3D; false;\n\t\t\tpath[q[u]] &#x3D; -1;\n\t\t&#125;\n\treturn false;\n&#125;\n\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 0; i &lt; 3; i++) scanf(&quot;%s&quot;, e[i]);\n\tfor (int i &#x3D; n - 1, k &#x3D; 0; i &gt;&#x3D; 0; i--) &#x2F;&#x2F;i列 \n\t\tfor (int j &#x3D; 0; j &lt; 3; j++)\n\t\t&#123;\n\t\t\tint t &#x3D; e[j][i] - &#39;A&#39;;\n\t\t\tif(!st[t])\n\t\t\t&#123;\n\t\t\t\tst[t] &#x3D; true;\n\t\t\t\tq[k++] &#x3D; t; \n\t\t\t&#125;\n\n\t\t&#125;\n\n\tmemset(st, 0 , sizeof st);&#x2F;&#x2F;num被用过\n\tmemset(path, -1 , sizeof path);&#x2F;&#x2F;字母被赋值为num\n\tdfs(0);\n\n\tfor (int i &#x3D; 0; i &lt; n; i++) printf(&quot;%d&quot;, path[i]);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 185\t玛雅游戏\t54.04%\t中等\n&#x2F;*\n下落消消乐5*7  I:恰好n步通关(0&lt;n≤5) -&gt; O:每步x,y,g(-1:L 1:R)move&#x2F;swap &gt;&#x3D;3连锁\n颜色不多于10种，从1开始顺序编号，相同数字表示相同颜色\n多组解时:\n按照x为第一关健字，y为第二关健字，1优先于-1，给出一组字典序最小的解。\n没有解决方案 || n &gt; 5，输出-1。\n\nenum:x,y L&#x2F;R \n消掉mark 再judge\n\ncut1:(goal和当前方块颜色相同)这样无意义的操作可能被用来填补操作步数,不能被剪掉\n恰好n步通关：不cut\t\t最少?步通关：cut\ncut2:向左移动时，如果左侧有方块，则直接减掉。这是由于输出的答案要求字典序最小，如果左侧有方块，那么将左侧的方块向右移动的字典序小于将当前方块向左移动的字典序。g&#x3D;1优先于-1\ncut3:当某种颜色的方块数量cnt[]&#x3D;&#x3D;1或2时，一定无解，直接剪枝。\n*&#x2F;\n\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint n;\nint g[5][7], bg[5][5][7];&#x2F;&#x2F; g[列[行]] backup_g\nint cnt[11], bcnt[5][11];&#x2F;&#x2F; num(color)_i个数\nbool st[5][7];&#x2F;&#x2F;state\n\nstruct Move\n&#123;\n\tint x, y, d;\n&#125;path[5];\n\nvoid move(int a, int b, int c) &#x2F;&#x2F; c &#x3D;&#x3D; a+1-1\n&#123;\n\tswap(g[a][b], g[c][b]);\n\n\twhile (true)\n\t&#123;\n\t\tbool flag &#x3D; false;&#x2F;&#x2F;g有无变化\n\t\t&#x2F;&#x2F;处理悬空方格\n\t\tfor (int x &#x3D; 0; x &lt; 5; x++)&#x2F;&#x2F;每列\n\t\t&#123;\n\t\t\tint z &#x3D; 0;\n\t\t\tfor (int y &#x3D; 0; y &lt; 7; y++)\n\t\t\t\tif (g[x][y])\n\t\t\t\t\tg[x][z++] &#x3D; g[x][y];&#x2F;&#x2F;【非空(悬空)才drop(z&#x3D;) z++】\n\t\t\twhile (z &lt; 7) g[x][z++] &#x3D; 0;&#x2F;&#x2F;上方补0\n\t\t&#125;\n\t\t&#x2F;&#x2F;枚举格子T&#x2F;F该删\n\t\tmemset(st, false, sizeof st);\n\t\tfor (int x &#x3D; 0; x &lt; 5; x ++ )\n\t\t\tfor (int y &#x3D; 0; y &lt; 7; y ++ )\n\t\t\t\tif (g[x][y])\n\t\t\t\t&#123;\n\t\t\t\t\tint l &#x3D; x, r &#x3D; x;\n\t\t\t\t\twhile (l - 1 &gt;&#x3D; 0 &amp;&amp; g[l - 1][y] &#x3D;&#x3D; g[x][y]) l--;\n\t\t\t\t\twhile (r + 1 &lt; 5 &amp;&amp; g[r + 1][y] &#x3D;&#x3D; g[x][y]) r++;\n\n\t\t\t\t\tif (r - l + 1 &gt;&#x3D; 3)&#x2F;&#x2F;横连(x,y符合该删条件)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tflag &#x3D; true;\n\t\t\t\t\t\tst[x][y] &#x3D; true;\n\t\t\t\t\t&#125;\n\t\t\t\t\telse\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tl &#x3D; r &#x3D; y;\n\t\t\t\t\t\twhile (l - 1 &gt;&#x3D; 0 &amp;&amp; g[x][l - 1] &#x3D;&#x3D; g[x][y]) l--;\n\t\t\t\t\t\twhile (r + 1 &lt; 7 &amp;&amp; g[x][r + 1] &#x3D;&#x3D; g[x][y]) r++;\n\n\t\t\t\t\t\tif (r - l + 1 &gt;&#x3D; 3)&#x2F;&#x2F;竖连\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tflag &#x3D; true;\n\t\t\t\t\t\t\tst[x][y] &#x3D; true;&#x2F;&#x2F;该删\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\n\t\tif (flag)&#x2F;&#x2F;需要删\n\t\t&#123;\n\t\t\tfor (int x &#x3D; 0; x &lt; 5; x ++ )\n\t\t\t\tfor (int y &#x3D; 0; y &lt; 7; y ++ )\n\t\t\t\t\tif (st[x][y])&#x2F;&#x2F;删他\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tcnt[0] --;\n\t\t\t\t\t\tcnt[g[x][y]] --;\n\t\t\t\t\t\tg[x][y] &#x3D; 0;\n\t\t\t\t\t&#125;\n\t\t&#125;\n\t\telse break;\n\t&#125;\n&#125;\n\nbool dfs(int u)\n&#123;\n\tif (u &#x3D;&#x3D; n) return !cnt[0];&#x2F;&#x2F;0 square\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#x2F;&#x2F;color\n\t\tif (cnt[i] &#x3D;&#x3D; 1 || cnt[i] &#x3D;&#x3D; 2)&#x2F;&#x2F;cut3\n\t\t\treturn false;\n\n\t&#x2F;&#x2F;枚举所有操作\n\tmemcpy(bg[u], g, sizeof g);\n\tmemcpy(bcnt[u], cnt, sizeof cnt);\n\tfor (int x &#x3D; 0; x &lt; 5; x ++ )\n\t\tfor (int y &#x3D; 0; y &lt; 7; y ++ )\n\t\t\tif (g[x][y])\n\t\t\t&#123;\n\t\t\t\tint nx &#x3D; x + 1; &#x2F;&#x2F; -&gt;new_x \n\t\t\t\tif (nx &lt; 5)\n\t\t\t\t&#123;\n\t\t\t\t\tpath[u] &#x3D; &#123; x, y, 1 &#125;;\n\t\t\t\t\tmove(x, y, nx);&#x2F;&#x2F;to:new_x\n\t\t\t\t\tif (dfs(u + 1)) return true;\n\t\t\t\t\tmemcpy(g, bg[u], sizeof g);\n\t\t\t\t\tmemcpy(cnt, bcnt[u], sizeof cnt);\n\t\t\t\t&#125;\n\t\t\t\tnx &#x3D; x - 1; &#x2F;&#x2F; &lt;-new_x\n\t\t\t\tif (nx &gt;&#x3D; 0 &amp;&amp; !g[nx][y])&#x2F;&#x2F;cut1:L必须为空\n\t\t\t\t&#123;\n\t\t\t\t\tpath[u] &#x3D; &#123; x, y, -1 &#125;;\n\t\t\t\t\tmove(x, y, nx);\n\t\t\t\t\tif (dfs(u + 1)) return true;\n\t\t\t\t\tmemcpy(g, bg[u], sizeof g);\n\t\t\t\t\tmemcpy(cnt, bcnt[u], sizeof cnt);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; 5; i++)\n\t&#123;\n\t\tint j &#x3D; 0, y;\n\t\twhile (cin &gt;&gt; y, y)\n\t\t&#123;\n\t\t\tcnt[0] ++;&#x2F;&#x2F;sum of squares\n\t\t\tcnt[y] ++;\n\t\t\tg[i][j++] &#x3D; y;\n\t\t&#125;\n\t&#125;\n\n\tif (dfs(0))\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) printf(&quot;%d %d %d\\n&quot;, path[i].x, path[i].y, path[i].d);\n\t&#125;\n\telse puts(&quot;-1&quot;);\n\n\treturn 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;3428&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F; 186\t巴士\t39.27%\t中等 \n&#x2F;&#x2F;巴士线路的总数量最小是多少ans&lt;&#x3D;17(浅)。 共n辆bus:1≤n≤300(搜索树深)\n&#x2F;*\ndfs 迭代加深 cut:\n首先预处理出所有可能的线路。先枚举起点i，再枚举公差j，则i和j需要满足两个条件：\n1.由于i是起点，因此0 ~ i - 1中不能包含任何该序列的点，所以公差j至少是i + 1；\n2.由于0 ~ 59之间至少要包含两个点，因此i + j一定小于60；\n[d&gt;a , a+d&lt;60]\n再搜:\n最少从合法线路中选出多少条，才可以覆盖所有给定的公交车。\n1.P()-&gt;C()避免重复传入起点start \n2.等差数列降排【搜索顺序cut】\n3.由于剪枝2的存在，当前路线覆盖的点数是最多的，当前路线能覆盖的点数*剩余可选的路径条数+当前已经覆盖的点数&lt;总点数，说明当前方案一定非法，直接回溯\n【可行性cut】\n\n60min内(a,d)定一条路线:C(2,60)&#x3D;60*59&#x2F;2&#x3D;59*30&lt;2000[总路线数N 上限]\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;&#x2F;&#x2F;a d\n\nconst int N &#x3D; 2000, M &#x3D; 60;\n\nint n;\nvector&lt;pair&lt;int, PII&gt;&gt; routes;\nint bus[M]; &#x2F;&#x2F; M时刻bus数\n\nbool is_route(int a, int d)\n&#123;\n\tfor (int i &#x3D; a; i &lt; 60; i +&#x3D; d)\n\t\tif (!bus[i]) return false;\n\treturn true;\n&#125;\n&#x2F;*\nbool dfs(int depth, int u, int sum, int start) &#x2F;&#x2F;sum:cur覆盖?辆 \n&#123;\n\tif (u &#x3D;&#x3D; depth) return sum &#x3D;&#x3D; n;\n\t&#x2F;&#x2F;cut3\n\tif (routes[start].first * (depth - u) + sum &lt; n) return false;\n\t&#x2F;&#x2F;枚举选哪个路线\n\tfor (int i &#x3D; start; i &lt; routes.size(); i ++ )\n\t&#123;\n\t\tauto r &#x3D; routes[i];\n\t\tint a &#x3D; r.second.first, d &#x3D; r.second.second;\n\t\tif (!is_route(a, d)) continue;\n\t\tfor (int j &#x3D; a; j &lt; 60; j +&#x3D; d) bus[j] -- ;&#x2F;&#x2F;路线(a,d)覆盖一遍bus数\n\t\tif (dfs(depth, u + 1, sum + r.first, i)) return true;\n\t\tfor (int j &#x3D; a; j &lt; 60; j +&#x3D; d) bus[j] ++ ;\n\t&#125;\n\treturn false;\n&#125;\n*&#x2F;\nbool dfs(int depth, int sum, int start) &#x2F;&#x2F;depth:剩余?层 sum:cur覆盖?辆 \n&#123;\n\tif (!depth) return sum &#x3D;&#x3D; n;\n\t&#x2F;&#x2F;枚举选哪个路线\n\tfor (int i &#x3D; start; i &lt; routes.size(); i ++ )\n\t&#123;\n\t\tauto r &#x3D; routes[i];\n\t\tint a &#x3D; r.second.first, d &#x3D; r.second.second;\n\t\tif (!is_route(a, d)) continue;\n\t\tif(r.first * depth + sum &lt; n) continue;&#x2F;&#x2F;cut3\n\t\tfor (int j &#x3D; a; j &lt; 60; j +&#x3D; d) bus[j] -- ;&#x2F;&#x2F;路线(a,d)覆盖一遍bus数\n\t\tif (dfs(depth - 1, sum + r.first, i)) return true;\n\t\tfor (int j &#x3D; a; j &lt; 60; j +&#x3D; d) bus[j] ++ ;&#x2F;&#x2F;-- ++\n\t&#125;\n\n\treturn false;\n&#125;\n\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint t;\n\t\tscanf(&quot;%d&quot;, &amp;t);\n\t\tbus[t] ++ ;\n\t&#125;\n\t&#x2F;&#x2F;预处理出所有可能的线路\n\tfor (int a &#x3D; 0; a &lt; 60; a ++ )\n\t\tfor (int d &#x3D; a + 1; a + d &lt; 60; d ++ )&#x2F;&#x2F;d&gt;a a+d&lt;60\n\t\t\tif (is_route(a, d))\n\t\t\t\troutes.push_back(&#123;(59 - a) &#x2F; d + 1, &#123;a, d&#125;&#125;);&#x2F;&#x2F;路线bus数,&#123;a,d&#125;\n\t&#x2F;&#x2F;路线覆盖bus数降排\n\tsort(routes.begin(), routes.end(), greater&lt;pair&lt;int, PII&gt;&gt;());\n\t&#x2F;&#x2F;迭代加深dfs\n\tint depth &#x3D; 0;\n\twhile (!dfs(depth, 0, 0)) depth ++ ;\n\n\tprintf(&quot;%d\\n&quot;, depth);\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 187\t导弹防御系统\t52.00%\t中等\n&#x2F;*\n一套防御系统的导弹拦截高度要么一直严格单调上升要么一直严格单调下降。\n给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。\n\nseq最少拆分为?条严格单调子序列\n搜索顺序分为两个阶段：\n1.从前往后枚举每颗导弹属于某个【上升】子序列，还是下降子序列；\n2.如果属于上升子序列，则枚举属于【哪个上升】子序列（包括新开一个上升子序列）；如果属于下降子序列，可以类似处理。\n因此可以仿照AcWing 896. 最长上升子序列 II， 【分别记录当前每个上升子序列的末尾数up[]，和下降子序列的末尾数down[]。这样在枚举时可以快速判断当前数是否可以接在某个序列的后面。】\n\n贪心cut：\n对于上升子序列而言，我们将当前数接在最大的数后面，一定不会比接在其他数列后面更差。【&gt;&#x3D; 能放在max后，当然也能放在smaller后，反之不行 决策包容性最大:教材P42】\n这是因为处理完当前数后，一定出现一个以当前数结尾的子序列，这是固定不变的，那么此时其他子序列的末尾数越小越好。\n\n常数cut：\n注意到按照这种贪心思路，up[]数组和down[]数组一定是单调的，因此在遍历时找到第一个满足的序列后就可以直接break了。\n\n如何求最小值。因为DFS和BFS不同，第一次搜索到的节点，不一定是步数最短的节点，所以需要进行额外处理。一般有两种处理方式：\n1.ID-DFS\n2.记录全局最小值，不断更新； 这种搜索顺序可以参考@一瞬流年丶涅槃同学的题解；\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 60;\n\nint n;\nint h[N];\nint up[N], down[N];\n\nbool dfs(int depth, int u, int su, int sd)&#x2F;&#x2F;本次迭代层数上限 cur up数 down数 \n&#123;\n\t&#x2F;&#x2F; 如果上升序列个数 + 下降序列个数 &gt; 子序列总个数上限，则回溯\n\tif (su + sd &gt; depth) return false;\n\tif (u &#x3D;&#x3D; n) return true;\n\n\t&#x2F;&#x2F; 枚举放到上升子序列中的情况\n\tbool flag &#x3D; false;  &#x2F;&#x2F; 是否放入某subSeq\n\tfor (int i &#x3D; 1; i &lt;&#x3D; su; i ++ )\n\t\tif (up[i] &lt; h[u])\n\t\t&#123;\n\t\t\tint t &#x3D; up[i];\n\t\t\tup[i] &#x3D; h[u];\n\t\t\tif (dfs(depth, u + 1, su, sd)) return true;\n\t\t\tup[i] &#x3D; t;\n\t\t\tflag &#x3D; true; &#x2F;&#x2F;cur放入\n\t\t\tbreak;  &#x2F;&#x2F; 注意由上述证明的贪心原理，只要找到第一个可以放的序列，就可以结束循环了\n\t\t&#125;\n\tif (!flag)  &#x2F;&#x2F; 如果不能放到任意一个序列后面，则单开一个新的序列\n\t&#123;\n\t\tup[su + 1] &#x3D; h[u];\n\t\tif (dfs(depth, u + 1, su + 1, sd)) return true;\n\t&#125;\n\n\t&#x2F;&#x2F; 枚举放到下降子序列中的情况\n\tflag &#x3D; false;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; sd; i ++ )\n\t\tif (down[i] &gt; h[u])\n\t\t&#123;\n\t\t\tint t &#x3D; down[i];\n\t\t\tdown[i] &#x3D; h[u];\n\t\t\tif (dfs(depth, u + 1, su, sd)) return true;\n\t\t\tdown[i] &#x3D; t;\n\t\t\tflag &#x3D; true;\n\t\t\tbreak;  &#x2F;&#x2F; 注意由上述证明的贪心原理，只要找到第一个可以放的序列，就可以结束循环了\n\t\t&#125;\n\tif (!flag)  &#x2F;&#x2F; 如果不能放到任意一个序列后面，则单开一个新的序列\n\t&#123;\n\t\tdown[sd + 1] &#x3D; h[u];\n\t\tif (dfs(depth, u + 1, su, sd + 1)) return true;\n\t&#125;\n\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n, n)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; h[i];\n\t\t&#x2F;&#x2F; 迭代加深搜索\n\t\tint depth &#x3D; 0;\n\t\twhile (!dfs(depth, 0, 0, 0)) depth ++ ;\n\n\t\tcout &lt;&lt; depth &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n&#x2F;&#x2F;类似题：AcWing 896. 最长上升子序列 II\n&#x2F;&#x2F; 443 贪心 排序+enum\n&#x2F;&#x2F; 1010 seq最少拆分为?条严格单调上升子序列（证）\n\n\n&#x2F;&#x2F; 188\t武士风度的牛\t52.96%\t简单\n&#x2F;&#x2F;马走日，求跳跃的最小次数 求min：bfs\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 155;\n\nint n, m;\nchar g[N][N];\nint dist[N][N];&#x2F;&#x2F;cur_hops\n\nint bfs(PII start, PII end)\n&#123;\n\tqueue&lt;PII&gt; q;\n\tmemset(dist, -1, sizeof dist);\n\tdist[start.x][start.y] &#x3D; 0;\n\n\tq.push(start);\n\t&#x2F;&#x2F;x向下 y向右\n\tint dx[] &#x3D; &#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;;\n\tint dy[] &#x3D; &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;\n\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int i &#x3D; 0; i &lt; 8; i ++ )\n\t\t&#123;\n\t\t\tint x &#x3D; t.x + dx[i], y &#x3D; t.y + dy[i];\n\t\t\tif (x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; m) continue;&#x2F;&#x2F;越界\n\t\t\tif (g[x][y] &#x3D;&#x3D; &#39;*&#39;) continue;&#x2F;&#x2F;障碍\n\t\t\tif (dist[x][y] !&#x3D; -1) continue;&#x2F;&#x2F;已走过\n\t\t\tdist[x][y] &#x3D; dist[t.x][t.y] + 1;\n\n\t\t\tif (make_pair(x, y) &#x3D;&#x3D; end) return dist[x][y];\n\n\t\t\tq.push(&#123;x, y&#125;);\n\t\t&#125;\n\t&#125;\n\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; m &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];\n\n\tPII start, end;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\tfor (int j &#x3D; 0; j &lt; m; j ++ )\n\t\t\tif (g[i][j] &#x3D;&#x3D; &#39;K&#39;) start &#x3D; &#123;i, j&#125;;\n\t\t\telse if (g[i][j] &#x3D;&#x3D; &#39;H&#39;) end &#x3D; &#123;i, j&#125;;\n\n\tcout &lt;&lt; bfs(start, end) &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; 189\t乳草的入侵\t32.87%\t简单\n&#x2F;&#x2F;每次扩一圈  扩?次占满&#x3D;上题dist_max(global)\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 110;\n\nint n, m;\nPII start;\nchar g[N][N];\nint dist[N][N];\n\nint bfs()\n&#123;\n\tmemset(dist, -1, sizeof dist);\n\tqueue&lt;PII&gt; q;\n\tq.push(start);\n\tdist[start.x][start.y] &#x3D; 0;\n\n\tint res &#x3D; 0;\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\t\t&#x2F;&#x2F;扩一圈\n\t\tfor (int x &#x3D; t.x - 1; x &lt;&#x3D; t.x + 1; x ++ )\n\t\t\tfor (int y &#x3D; t.y - 1; y &lt;&#x3D; t.y + 1; y ++ )\n\t\t\t\tif (x !&#x3D; t.x || y !&#x3D; t.y) &#x2F;&#x2F; !(&amp;&amp;)&#x3D;&#x3D;(!)||(!)\n\t\t\t\t&#123;\n\t\t\t\t\tif (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) continue;\n\t\t\t\t\tif (g[x][y] &#x3D;&#x3D; &#39;*&#39; || dist[x][y] !&#x3D; -1) continue;\n\t\t\t\t\tdist[x][y] &#x3D; dist[t.x][t.y] + 1;\n\t\t\t\t\tres &#x3D; max(res, dist[x][y]);&#x2F;&#x2F;\n\t\t\t\t\tq.push(&#123;x, y&#125;);\n\t\t\t\t&#125;\n\t&#125;\n\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; m &gt;&gt; n &gt;&gt; start.y &gt;&gt; start.x;&#x2F;&#x2F;m列n行\n\tstart.x &#x3D; n + 1 - start.x;&#x2F;&#x2F;x向上\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; g[i] + 1;&#x2F;&#x2F; 1,1\n\n\tcout &lt;&lt; bfs() &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 190\t字串变换\t43.45%\t中等\n&#x2F;* \n至多6个规则 所有字符串长度的上限为 20\n（包含 10步）以内能将 A 变换为 B ，则输出最少的变换步数\n\nk^10-&gt;2*k^5 双向bfs：[最优性]不能每次扩展一点，必须每次扩展一层！！！\nBFS的扩展方式是:分别枚举在原字符串中使用替换规则的起点，和所使用的的替换规则。\n*&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 6;\n\nint n;\nstring A, B;\nstring a[N], b[N];&#x2F;&#x2F;变换规则a[]-&gt;b[]\n\nint extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string, int&gt;&amp;da, unordered_map&lt;string, int&gt;&amp; db, \n\tstring a[N], string b[N])\n&#123;\n\tint d &#x3D; da[q.front()];\n\twhile (q.size() &amp;&amp; da[q.front()] &#x3D;&#x3D; d)&#x2F;&#x2F;只扩cur层d，一次扩一层\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )&#x2F;&#x2F;枚举规则i\n\t\t\tfor (int j &#x3D; 0; j &lt; t.size(); j ++ )&#x2F;&#x2F;枚举subSeq起点j\n\t\t\t\tif (t.substr(j, a[i].size()) &#x3D;&#x3D; a[i])\n\t\t\t\t&#123;\n\t\t\t\t\tstring r &#x3D; t.substr(0, j) + b[i] + t.substr(j + a[i].size());&#x2F;&#x2F;片段a[i]-&gt;b[i]\n\t\t\t\t\tif (db.count(r)) return da[t] + db[r] + 1; &#x2F;&#x2F; A~t&lt;-&gt;r~B\n\t\t\t\t\tif (da.count(r)) continue;&#x2F;&#x2F;重复\n\t\t\t\t\tda[r] &#x3D; da[t] + 1;\n\t\t\t\t\tq.push(r);\n\t\t\t\t&#125;\n\t&#125;\n\n\treturn 11;\n&#125;\n\nint bfs()\n&#123;\n\tqueue&lt;string&gt; qa, qb;&#x2F;&#x2F;存中间结果\n\tunordered_map&lt;string, int&gt; da, db;&#x2F;&#x2F;d[str]&#x3D;A(B)到str的-&gt;(&lt;-)变换规则数\n\n\tqa.push(A), qb.push(B);\n\tda[A] &#x3D; db[B] &#x3D; 0;\n\n\tint step &#x3D; 0;\n\twhile (qa.size() &amp;&amp; qb.size())\n\t&#123;\n\t\tint t;\n\t\tif (qa.size() &lt; qb.size()) t &#x3D; extend(qa, da, db, a, b);&#x2F;&#x2F;qa短:正-&gt;扩\n\t\telse t &#x3D; extend(qb, db, da, b, a);&#x2F;&#x2F;反向变换a&lt;-b  扩短的 2选1\n\n\t\tif (t &lt;&#x3D; 10) return t;\n\t\tif ( ++ step &gt; 10) return -1;&#x2F;&#x2F; &lt;&#x3D; 10 steps\n\t&#125;\n\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; A &gt;&gt; B;\n\twhile (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ;&#x2F;&#x2F;【规则数n不定，&lt;&#x3D;N】!!!!!!!!!!\n\n\tint t &#x3D; bfs();\n\tif (t &#x3D;&#x3D; -1) puts(&quot;NO ANSWER!&quot;);\n\telse cout &lt;&lt; t &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;132169&#x2F;\n\n\n\n&#x2F;&#x2F; 191\t天气预报\t29.30%\t中等\n&#x2F;*\n平时可以有足够的雨水，在赶集和过节能够充满阳光。\n四个基本方向（东南西北）之中选取一个方向，将云移动1或2个方格，或将其保持在相同位置。任何地区【s0~s3四个角的状态（最近的一次下雨是什么时候）】都不能连续七天或以上时间都不降雨。\n0表示正常的一天，1表示赶集和过节的一天\n\n可保证:1 or 0\nf(cur_day,x,y,s0,s1,s2,s3) 365*9*(7^4)&#x3D;700w+ 多组数据！！\nDP全集-&gt;dfs bfs子集\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 366;\n\nint n;\nbool st[N][3][3][7][7][7][7]; &#x2F;&#x2F; &#x3D;&#x3D;bool visit[]\nstruct Node\n&#123;\n\tint day, x, y, s0, s1, s2, s3;\n&#125;;\nint state[N][4][4];\n\nint bfs()\n&#123;\n\t&#x2F;&#x2F;init云处不能下雨 st&#x3D;1表示赶集和过节的一天\n\tif (state[1][1][1] || state[1][1][2] || state[1][2][1] || state[1][2][2]) return 0;\n\n\tqueue&lt;Node&gt; q;\n\tmemset(st, 0, sizeof st);&#x2F;&#x2F;多组测试数据\n\tq.push(&#123;1, 1, 1, 1, 1, 1, 1&#125;);\n\tst[1][1][1][1][1][1][1] &#x3D; true;\n\n\tint dx[] &#x3D; &#123;-1, 0, 1, 0, 0&#125;, dy[] &#x3D; &#123;0, 1, 0, -1, 0&#125;;\n\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tif (t.day &#x3D;&#x3D; n) return 1;\n\n\t\tfor (int i &#x3D; 0; i &lt; 5; i ++ )&#x2F;&#x2F;direction\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; 2; j ++ )&#x2F;&#x2F;1、2 steps\n\t\t\t&#123;\n\t\t\t\tint x &#x3D; t.x + dx[i] * j, y &#x3D; t.y + dy[i] * j;&#x2F;&#x2F;左上角xy\n\t\t\t\tif (x &lt; 0 || x &gt;&#x3D; 3 || y &lt; 0 || y &gt;&#x3D; 3) continue;\n\t\t\t\t&#x2F;&#x2F;2*2云处不能下雨\n\t\t\t\tauto&amp; s &#x3D; state[t.day + 1];\n\t\t\t\tif (s[x][y] || s[x][y + 1] || s[x + 1][y] || s[x + 1][y + 1]) continue;\n\n\t\t\t\tint s0 &#x3D; t.s0, s1 &#x3D; t.s1, s2 &#x3D; t.s2, s3 &#x3D; t.s3;\n\t\t\t\tif (!x &amp;&amp; !y) s0 &#x3D; 0;&#x2F;&#x2F;s0久旱逢甘露 置0\n\t\t\t\telse if ( ++ s0 &#x3D;&#x3D; 7) continue;&#x2F;&#x2F;旱死了\n\t\t\t\tif (!x &amp;&amp; y &#x3D;&#x3D; 2) s1 &#x3D; 0;\n\t\t\t\telse if ( ++ s1 &#x3D;&#x3D; 7) continue;\n\t\t\t\tif (x &#x3D;&#x3D; 2 &amp;&amp; !y) s2 &#x3D; 0;\n\t\t\t\telse if ( ++ s2 &#x3D;&#x3D; 7) continue;\n\t\t\t\tif (x &#x3D;&#x3D; 2 &amp;&amp; y &#x3D;&#x3D; 2) s3 &#x3D; 0;\n\t\t\t\telse if ( ++ s3 &#x3D;&#x3D; 7) continue;\n\t\t\t\t&#x2F;&#x2F;重复 记忆化剪枝\n\t\t\t\tif (st[t.day + 1][x][y][s0][s1][s2][s3]) continue;\n\n\t\t\t\tst[t.day + 1][x][y][s0][s1][s2][s3] &#x3D; true;\n\t\t\t\tq.push(&#123;t.day + 1, x, y, s0, s1, s2, s3&#125;);\n\t\t\t&#125;\n\t&#125;\n\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n, n)&#x2F;&#x2F;n天\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\t\tfor (int j &#x3D; 0; j &lt; 4; j ++ )\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 4; k ++ )\n\t\t\t\t\tcin &gt;&gt; state[i][j][k];\n\n\t\tcout &lt;&lt; bfs() &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;*\n记忆化保存每个状态，保证每个状态只被搜一次。具体：开一个 \nvis[dep][(x,y)][(d1,d2,d3,d4)]数组，记录每个状态是否搜过。\n回顾我们的状态，dep 表示天数，(x,y) 可以用公式 x*4+y 表示在哪一个，\nd 就是四个角，我们发现最多离上一次淋雨6天，我们的d就表示离上一次淋雨几天（和上面的搜索状态有所不同），可以用 七进制状态压缩 储存\n*&#x2F;\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ninline int read() &#123;\n\tint x&#x3D;0,f&#x3D;1;\n\tchar ch&#x3D;getchar();\n\twhile(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) &#123; if(ch&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1; ch&#x3D;getchar(); &#125;\n\twhile(ch&gt;&#x3D;&#39;0&#39;&amp;&amp;ch&lt;&#x3D;&#39;9&#39;) &#123; x&#x3D;(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch&#x3D;getchar(); &#125;\n\treturn x * f;\n&#125;\nconst int N &#x3D; 366, M &#x3D; 10, MAXN &#x3D; 2807;\nconst int dx[] &#x3D; &#123;0,-1,1,0,0,-2,2,0,0&#125;;\nconst int dy[] &#x3D; &#123;0,0,0,-1,1,0,0,-2,2&#125;;\nint n;\nint state[N];\nbool vis[N][M][MAXN];\nstruct Node &#123;\n\tint d[4];\n&#125;st;\ninline int Get(int x,int y) &#123;\n\treturn 1&lt;&lt;(x*4+y);\n&#125;\ninline bool check(int now,int x,int y,Node cr) &#123;\n\tfor(int i&#x3D;0;i&lt;4;++i)\n\t\tif(now - cr.d[i] &gt; 6) return false;\n\tint weather &#x3D; Get(x,y) | Get(x,y+1) | Get(x+1,y) | Get(x+1,y+1);\n\tif(weather &amp; state[now]) return false;\n\tint s &#x3D; 0, base &#x3D; 8;\n\tfor(int i&#x3D;0;i&lt;4;++i)\n\t\ts &#x3D; s*base + (now - cr.d[i]);\n\tif(vis[now][x*4+y][s]) return false;    &#x2F;&#x2F;记忆化，剪枝 \n\treturn vis[now][x*4+y][s] &#x3D; true;\n&#125;\ninline bool valid(int x,int y) &#123;\n\treturn (x&gt;&#x3D;0&amp;&amp;x&lt;3&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;3);  &#x2F;&#x2F;注意下标从 0 开始编号 \n&#125;\nbool Dfs(int dep,int x,int y,Node cr) &#123; &#x2F;&#x2F;corner 角落 \n\tif(!check(dep,x,y,cr)) return false;\n\tif(dep &#x3D;&#x3D; n) return true;\n\tfor(int i&#x3D;0;i&lt;9;++i) &#123;\n\t\tint nx &#x3D; x + dx[i], ny &#x3D; y + dy[i]; Node ncr &#x3D; cr;\n\t\tif(!valid(nx,ny)) continue;\n\t\tif(nx&#x3D;&#x3D;0 &amp;&amp; ny&#x3D;&#x3D;0) ncr.d[0] &#x3D; dep + 1;\n\t\tif(nx&#x3D;&#x3D;0 &amp;&amp; ny&#x3D;&#x3D;2) ncr.d[1] &#x3D; dep + 1;\n\t\tif(nx&#x3D;&#x3D;2 &amp;&amp; ny&#x3D;&#x3D;0) ncr.d[2] &#x3D; dep + 1;\n\t\tif(nx&#x3D;&#x3D;2 &amp;&amp; ny&#x3D;&#x3D;2) ncr.d[3] &#x3D; dep + 1;\n\t\tif(Dfs(dep+1,nx,ny,ncr)) return true;\n\t&#125;\n\treturn false;\n&#125;\nvoid work() &#123;\n\tmemset(state, 0, sizeof(state));\n\tmemset(vis, 0, sizeof(vis));\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;++i)\n\t\tfor(int j&#x3D;0;j&lt;16;++j)\n\t\t\tstate[i] |&#x3D; (read()&lt;&lt;j);\n\t&#x2F;&#x2F;for(int i&#x3D;1;i&lt;&#x3D;n;++i) printf(&quot;state[%d] &#x3D; %d\\n&quot;,i,state[i]);\n\t&#x2F;&#x2F;cout &lt;&lt; endl;\n\tst.d[0] &#x3D; st.d[1] &#x3D; st.d[2] &#x3D; st.d[3] &#x3D; 0;\n\tvis[1][1*4+1][0] &#x3D; 1;\n\tprintf(&quot;%d\\n&quot;,Dfs(1,1,1,st));\n\t&#x2F;&#x2F;cout &lt;&lt; endl;\n&#125;\nint main()\n&#123;\n\twhile(true) &#123;\n\t\tn &#x3D; read();\n\t\tif(!n) break;\n\t\twork();\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：扶摇直上九万里\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;7518&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F; 192\t立体推箱子2\t38.46%\t困难\n\n\n&#x2F;&#x2F; 193\t算乘方的牛\t38.42%\t困难\n&#x2F;&#x2F; 194\t涂满它！\t34.29%\t中等\n&#x2F;&#x2F; 195\t骑士精神\n\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n</code></pre>\n\n\n\n<h1 id=\"0x30数学知识\"><a href=\"#0x30数学知识\" class=\"headerlink\" title=\"0x30数学知识\"></a>0x30数学知识</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;0x31质数\n&#x2F;&#x2F;p-judge：试除法 (Miller-Rabin)，筛法，线性筛\n\n&#x2F;&#x2F;A质因数分解：试除法 (Pollard&#39;s Rho)\n&#x2F;&#x2F;质数距离\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint primes[N], cnt;&#x2F;&#x2F;M&#x3D;5w&#x3D;sqrt(R) 不够!\nbool st[N];\n\nvoid get_primes(int n) &#x2F;&#x2F; 线性筛模板\n&#123;\n\tmemset(st, false, sizeof st);\n\tcnt &#x3D; 0;\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tif(!st[i]) primes[cnt++] &#x3D; i;\n\t\tfor(int j &#x3D; 0; primes[j] * i &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tst[primes[j] * i] &#x3D; true;\n\t\t\tif (i % primes[j] &#x3D;&#x3D; 0) break;&#x2F;&#x2F;p[j]&lt;&#x3D;v[i]最小质因子\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tlong long l, r;\n\n\twhile(cin &gt;&gt; l &gt;&gt; r)\n\t&#123;\n\t\tget_primes(50000);\n\n\t\tmemset(st, false, sizeof st);\n\t\tfor (int i &#x3D; 0; i &lt; cnt; i++)\n\t\t&#123;\n\t\t\tint p &#x3D; primes[i];\n\t\t\t&#x2F;&#x2F;筛掉所有[l,r]中p的倍数  (l+p j+&#x3D;p 会超int!!!)\n\t\t\t&#x2F;&#x2F;max((l + p - 1) &#x2F; p * p, 2ll * p)    l较小时!!!!!!!!!!!!\n\t\t\tfor(long long j &#x3D; max((l + p - 1) &#x2F; p * p, 2ll * p); j &lt;&#x3D; r; j +&#x3D; p)\n\t\t\t\tst[j - l] &#x3D; true;\n\t\t&#125;\n\n\t\tcnt &#x3D; 0;\n\t\tfor(int i &#x3D; 0; i &lt;&#x3D; r - l; i++)\n\t\t\tif(!st[i] &amp;&amp; i + l &gt; 1) primes[cnt++] &#x3D; i + l;&#x2F;&#x2F;1不是质数不是合数!\n\t\tif(cnt &lt; 2) puts(&quot;There are no adjacent primes.&quot;);\n\t\telse\n\t\t&#123;\n\t\t\tint minp &#x3D; 0, maxp &#x3D; 0;\n\t\t\tfor (int i &#x3D; 0; i + 1 &lt; cnt; i++)\n\t\t\t&#123;\n\t\t\t\tint d &#x3D; primes[i + 1] - primes[i];\n\t\t\t\tif(d &lt; primes[minp + 1] - primes[minp]) minp &#x3D; i;\n\t\t\t\tif(d &gt; primes[maxp + 1] - primes[maxp]) maxp &#x3D; i;\n\t\t\t&#125;\n\n\t\t\tprintf(&quot;%d,%d are closest, %d,%d are most distant.\\n&quot;, primes[minp],primes[minp + 1], primes[maxp], primes[maxp + 1]);\n\t\t&#125;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;阶乘分解\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint primes[N], cnt;\nbool st[N];\n\nvoid get_primes(int n)\n&#123;\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tif(!st[i]) primes[cnt++] &#x3D; i;\n\t\tfor(int j &#x3D; 0; primes[j] * i &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tst[primes[j] * i] &#x3D; true;\n\t\t\tif(i % primes[j] &#x3D;&#x3D; 0) break;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint n;\n\tcin &gt;&gt; n;\n\n\tget_primes(n);\n\n\tfor (int i &#x3D; 0; i &lt; cnt; i++)\n\t&#123;\n\t\tint p &#x3D; primes[i];\n\t\tint s &#x3D; 0, t &#x3D; n;\n\t\twhile(t) s +&#x3D; t &#x2F; p, t &#x2F;&#x3D; p;\n\n\t\tprintf(&quot;%d %d\\n&quot;, p, s);\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x32约数\n&#x2F;&#x2F;试除法，倍数法\n\n&#x2F;&#x2F;反素数\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nint ps[] &#x3D; &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;\n\nint n;\nint sum &#x3D; 0, minx;&#x2F;&#x2F;ans的约数个数，ans(有sum_max的min_ans)\n&#x2F;&#x2F; cur_pi,last_ci,cur总乘积product,cur约数个数\nvoid dfs(int u, int last, int p, int s)\n&#123;\n\tif(s &gt; sum || s &#x3D;&#x3D; sum &amp;&amp; p &lt; minx)\n\t&#123;\n\t\tsum &#x3D; s;\n\t\tminx &#x3D; p;\n\t&#125;&#x2F;&#x2F;更新minx\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; last; i++)&#x2F;&#x2F;ci单调递减\n\t&#123;\n\t\tif((LL) p * ps[u] &gt; n) break;&#x2F;&#x2F;p &lt;&#x3D; n\n\t\tp *&#x3D; ps[u];&#x2F;&#x2F; 数p &#x3D;&#x3D; pi的连乘！！！\n\t\tdfs(u + 1, i, p, s * (i + 1));&#x2F;&#x2F;正约数个数:(ci+1)连乘\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\t\n\tdfs(0, 30, 1, 1);&#x2F;&#x2F;ci &lt;&#x3D; 30\n\n\tcout &lt;&lt; minx &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;余数之和\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nint n;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\t\n\tcout &lt;&lt; minx &lt;&lt; endl;\n\treturn 0;\n&#125;\n&#x2F;&#x2F;gcd\n&#x2F;&#x2F;200\tHankson的趣味题\n\n&#x2F;&#x2F;欧拉函数\n&#x2F;&#x2F;\t201\t可见的点\n\n&#x2F;&#x2F;积性函数：Dirichlet卷积，Mobius反演  待填坑。。。。。。。\n\n&#x2F;&#x2F;0x33 同余\n&#x2F;&#x2F;费马小定理\n&#x2F;&#x2F;欧拉定理\n&#x2F;&#x2F; 202\t最幸运的数字\n\n\n\n&#x2F;&#x2F;exgcd\n&#x2F;&#x2F;乘法逆元 b * b^(p-2) % p &#x3D; 1\n&#x2F;&#x2F; Sumdiv\n\n\n\n&#x2F;&#x2F;线性同余方程\n&#x2F;&#x2F;203\t同余方程\n\n\n&#x2F;&#x2F;中国剩余定理\n&#x2F;&#x2F;204\t表达整数的奇怪方式\n\n\n&#x2F;&#x2F;高次同余方程: a^x(%p)&#x3D;b型\n&#x2F;&#x2F;x^a(%p)&#x3D;b型：原根 阶 指数 待填坑。。。。。。。\n&#x2F;&#x2F;大小步算法\n\n\n\n&#x2F;&#x2F;0x34 矩阵乘法 矩阵快速幂\n&#x2F;&#x2F;205\t斐波那契\n\n&#x2F;&#x2F;206\t石头游戏\n\n\n&#x2F;&#x2F;0x35 高斯消元\n&#x2F;&#x2F; 207\t球形空间产生器\t76.39%\t中等\n\n&#x2F;&#x2F; 208\t开关问题\n\n\n&#x2F;&#x2F;线性空间\n&#x2F;&#x2F; 209\t装备购买\n\n\n&#x2F;&#x2F; 210\t异或运算\n\n\n&#x2F;&#x2F;0x36 组合计数\n&#x2F;&#x2F;\t211\t计算系数\t53.79%\t简单\n\n\n&#x2F;&#x2F; 212\t计数交换\t39.74%\t简单\n\n\n&#x2F;&#x2F;【Lucas定理】\n&#x2F;&#x2F;213\t古代猪文\t46.33%\t简单\n\n\n&#x2F;&#x2F;0x37 容斥 \n&#x2F;&#x2F;214\tDevu和鲜花\t49.58%\t中等\n\n&#x2F;&#x2F;Mobius函数\n&#x2F;&#x2F;215\t破译密码\t41.94%\t困难\n\n\n&#x2F;&#x2F;0x38 概率 数学期望\n&#x2F;&#x2F;216\tRainbow的信号\t41.31%\t简单\n\n\n\n&#x2F;&#x2F;217\t绿豆蛙的归宿\t66.88%\t简单\n\n\n\n&#x2F;&#x2F; 218\t扑克牌\t62.28%\t中等\n\n\n\n&#x2F;&#x2F;0x39 0&#x2F;1分数规划\n\n&#x2F;&#x2F;0x3A 博弈论之SG函数\n&#x2F;&#x2F;219\t剪纸游戏\t46.63%\t中等\n\n\n---------------------------------------------------------------\n\n&#x2F;&#x2F;0x3B 总结与练习\n&#x2F;&#x2F; 220\t最大公约数\t47.09%\t中等\n&#x2F;&#x2F; 221\t龙哥的问题\t46.58%\t中等\n&#x2F;&#x2F; 222\t青蛙的约会\t46.77%\t困难\n&#x2F;&#x2F; 223\t阿九大战朱最学\t63.87%\t简单\n&#x2F;&#x2F; 224\t计算器\t42.11%\t简单\n&#x2F;&#x2F; 225\t矩阵幂求和\t51.81%\t简单\n&#x2F;&#x2F; 226\t233矩阵\t81.58%\t简单\n&#x2F;&#x2F; 227\t小部件厂\t25.67%\t中等\n&#x2F;&#x2F; 228\t异或\t33.33%\t简单\n&#x2F;&#x2F; 229\t新NIM游戏\t53.61%\t简单\n&#x2F;&#x2F; 230\t排列计数\t56.12%\t简单\n&#x2F;&#x2F; 231\t天码\t48.21%\t困难\n&#x2F;&#x2F; 232\t守卫者的挑战\t60.91%\t简单\n&#x2F;&#x2F; 233\t换教室\t44.49%\t中等\n&#x2F;&#x2F; 234\t放弃测试\t53.37%\t中等\n&#x2F;&#x2F; 235\t魔法珠\t42.08%\t简单\n&#x2F;&#x2F; 236\t格鲁吉亚和鲍勃\t51.69%\t困难\n\n\n\n\n\n\n\n</code></pre>\n\n\n\n<h1 id=\"0x40数据结构进阶\"><a href=\"#0x40数据结构进阶\" class=\"headerlink\" title=\"0x40数据结构进阶\"></a>0x40数据结构进阶</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;&#x2F;0x41 并查集\n&#x2F;&#x2F; 237\t程序自动分析\n\n\n&#x2F;&#x2F;超市（法2）\n\n&#x2F;&#x2F;【扩展域 边带权】\n&#x2F;&#x2F; 238\t银河英雄传说\n\n&#x2F;&#x2F; 239\t奇偶游戏\n\n&#x2F;&#x2F; 240\t食物链\n\n\n&#x2F;&#x2F;0x42 树状数组\n&#x2F;&#x2F; 241\t楼兰图腾\n\n&#x2F;&#x2F; 242\t一个简单的整数问题\n\n&#x2F;&#x2F; 243\t一个简单的整数问题2\t（树状数组）\n\n&#x2F;&#x2F; 244\t谜一样的牛\n\n&#x2F;&#x2F;0x43 线段树\n&#x2F;&#x2F; 245\t你能回答这些问题吗\n\n\n&#x2F;&#x2F; 246\t区间最大公约数\n\n\n&#x2F;&#x2F;【延迟标记】\n&#x2F;&#x2F; 243\t一个简单的整数问题2 （线段树）\n\n\n\n\n&#x2F;&#x2F;0x43.扫描线\n&#x2F;&#x2F;亚特兰蒂斯\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n#define ll long long\nconst int N &#x3D; 20000 + 10;&#x2F;&#x2F;????\nstruct node&#123;\n\tdouble x,y1,y2;\n\tint val;\n\tnode() &#123;&#125;\n\tnode(double x, double y1, double y2,int val)&#123;\n\t\tthis-&gt;x &#x3D; x; this-&gt;val &#x3D; val;\n\t\tthis-&gt;y1 &#x3D; y1; this-&gt;y2 &#x3D; y2;\n\t&#125;\n\tbool operator &lt;(const node &amp;t)const &#123;\n\t\treturn x&lt;t.x;\n\t&#125;\n&#125;;\nstruct Tree&#123;\n\tint l,r,cnt;\n\tdouble len;\n&#125;t[N&lt;&lt;3];\nint n,k&#x3D;1;\nvector&lt;node&gt; a;\nvector&lt;double&gt; y;\nvoid up(int rt) &#123;&#x2F;&#x2F;root\n\tif (t[rt].cnt&gt;0) t[rt].len &#x3D; y[t[rt].r+1] - y[t[rt].l];\n\telse t[rt].len &#x3D; t[rt&lt;&lt;1].len + t[rt&lt;&lt;1|1].len;\n&#125;\nvoid build(int rt,int l,int r) &#123;\n\tt[rt].l &#x3D; l,t[rt].r &#x3D; r; t[rt].cnt &#x3D; 0;\n\tt[rt].len &#x3D; 0;\n\tif (l &#x3D;&#x3D; r) return;\n\tint mid &#x3D; (l+r)&gt;&gt;1;\n\tbuild(rt&lt;&lt;1,l,mid);\n\tbuild(rt&lt;&lt;1|1,mid+1,r);\n&#125;\nvoid update(int rt,int l,int r,int val) &#123;\n\tif (l &lt;&#x3D; t[rt].l &amp;&amp; r &gt;&#x3D; t[rt].r) &#123;\n\t\tt[rt].cnt+&#x3D;val;\n\t\tup(rt);\n\t\treturn;\n\t&#125;\n\tint mid &#x3D; (t[rt].l+t[rt].r)&gt;&gt;1;\n\tif (l &lt;&#x3D; mid) update(rt&lt;&lt;1,l,r,val);\n\tif (r &gt; mid) update(rt&lt;&lt;1|1,l,r,val);\n\tup(rt);\n&#125;\nint main() &#123;\n\twhile (~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123;\n\t\ty.clear();a.clear();\n\t\tfor(int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tdouble x1,x2,y1,y2;\n\t\t\tscanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);\n\t\t\ty.push_back(y1);\n\t\t\ty.push_back(y2);\n\t\t\ta.push_back(node(x1,y2,y1,1));\n\t\t\ta.push_back(node(x2,y2,y1,-1));\n\t\t&#125;\n\t\ty.push_back(-1);\n\t\tsort(a.begin(),a.end());\n\t\tsort(y.begin(),y.end());\n\t\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\tint m &#x3D; y.size(),num &#x3D; a.size();\n\t\tbuild(1,0,m);\n\t\tdouble ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; num; i++) &#123;\n\t\t\tint l &#x3D; lower_bound(y.begin(),y.end(),a[i].y2)-y.begin();\n\t\t\tint r &#x3D; lower_bound(y.begin(),y.end(),a[i].y1) - y.begin()-1;\n\t\t\tupdate(1,l,r,a[i].val);\n\t\t\tans +&#x3D; t[1].len*(a[i+1].x-a[i].x);\n\t\t&#125;\n\t\tprintf(&quot;Test case #%d\\n&quot;,k++);\n\t\tprintf(&quot;Total explored area: %.2f\\n\\n&quot;,ans);\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：19_2\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;92113&#x2F;\n&#x2F;&#x2F;窗内的星星\n\n&#x2F;&#x2F;0x44.分块\n&#x2F;&#x2F;蒲公英\n\n&#x2F;&#x2F;磁力块\n\n&#x2F;&#x2F;小Z的袜子 XuHt注释版\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 50006;\nint n, m, c[N], L[N], R[N], num[N];\nstruct P &#123;\n\tint id, l, r;\n&#125; p[N];\nll ans, Ans[N][2], g;\n\nbool cmp(P a, P b) &#123;\n\treturn a.l &lt; b.l || (a.l &#x3D;&#x3D; b.l &amp;&amp; a.r &lt; b.r);\n&#125;\n\nbool cmp0(P a, P b) &#123;\n\treturn a.r &lt; b.r;\n&#125;\n\nvoid work(int x, int w) &#123;\n\tans -&#x3D; (ll)num[x] * (num[x] - 1);\n\tnum[x] +&#x3D; w;\n\tans +&#x3D; (ll)num[x] * (num[x] - 1);\n&#125;\n\nll gcd(ll a, ll b) &#123;\n\treturn b ? gcd(b, a % b) : a;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;c[i]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d %d&quot;, &amp;p[i].l, &amp;p[i].r);\n\t\tp[i].id &#x3D; i;\n\t&#125;\n\t&#x2F;&#x2F;prework 分段\n\tsort(p + 1, p + m + 1, cmp);\n\tint t &#x3D; sqrt(m);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tL[i] &#x3D; (i - 1) * t + 1;\n\t\tR[i] &#x3D; i * t;\n\t&#125;\n\tif (R[t] &lt; m) &#123;\n\t\tL[t+1] &#x3D; R[t] + 1;\n\t\tR[++t] &#x3D; m;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tsort(p + L[i], p + R[i] + 1, cmp0);&#x2F;&#x2F;段i[)内 r&lt; 排序\n\t\tmemset(num, 0, sizeof(num));\n\t\tans &#x3D; 0;\n\t\tint l &#x3D; p[L[i]].l, r &#x3D; p[L[i]].r;&#x2F;&#x2F;该块第一个询问L[i]的询问区间p:[l,r]\n\t\tfor (int j &#x3D; l; j &lt;&#x3D; r; j++) work(c[j], 1);&#x2F;&#x2F;更新ans\n\t\tAns[p[L[i]].id][0] &#x3D; ans;\n\t\tAns[p[L[i]].id][1] &#x3D; (ll)(r - l) * (r - l + 1);\n\t\tg &#x3D; gcd(Ans[p[L[i]].id][0], Ans[p[L[i]].id][1]);&#x2F;&#x2F;最简分数\n\t\tif (!g) Ans[p[L[i]].id][1] &#x3D; 1;&#x2F;&#x2F;分母为0\n\t\telse &#123;\n\t\t\tAns[p[L[i]].id][0] &#x2F;&#x3D; g;\n\t\t\tAns[p[L[i]].id][1] &#x2F;&#x3D; g;\n\t\t&#125;\n\t\tfor (int j &#x3D; L[i] + 1; j &lt;&#x3D; R[i]; j++) &#123;&#x2F;&#x2F;该块其余询问 \n\t\t\t&#x2F;&#x2F;1p&lt;--&gt;1Ans  询问区间变化，更新ans!!!!!!\n\t\t\twhile (r &lt; p[j].r) work(c[++r], 1);&#x2F;&#x2F;1 4 从next(先+—)开始扩(+1)\n\t\t\twhile (r &gt; p[j].r) work(c[r--], -1);&#x2F;&#x2F;2 3 从self(后+—)开始缩(-1)\n\t\t\twhile (l &lt; p[j].l) work(c[l++], -1);\n\t\t\twhile (l &gt; p[j].l) work(c[--l], 1);\n\t\t\tif (p[j].l &#x3D;&#x3D; p[j].r) &#123;\n\t\t\t\tAns[p[j].id][0] &#x3D; 0;\n\t\t\t\tAns[p[j].id][1] &#x3D; 1;\n\t\t\t&#125; else &#123;\n\t\t\t\tAns[p[j].id][0] &#x3D; ans;\n\t\t\t\tAns[p[j].id][1] &#x3D; (ll)(r - l) * (r - l + 1);\n\t\t\t\tg &#x3D; gcd(Ans[p[j].id][0], Ans[p[j].id][1]);\n\t\t\t\tif (!g) Ans[p[j].id][1] &#x3D; 1;\n\t\t\t\telse &#123;\n\t\t\t\t\tAns[p[j].id][0] &#x2F;&#x3D; g;\n\t\t\t\t\tAns[p[j].id][1] &#x2F;&#x3D; g;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tprintf(&quot;%lld&#x2F;%lld\\n&quot;, Ans[i][0], Ans[i][1]);\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x45.点分治\n&#x2F;&#x2F;Tree\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 10006;\nint n, k, s[N], Ans;\nbool v[N], w[N];&#x2F;&#x2F;&#x2F;&#x2F;访问过 (在之前的递归层)已删除\nint Head[N], Edge[N&lt;&lt;1], Leng[N&lt;&lt;1], Next[N&lt;&lt;1], t;\nint ans, pos;\nint d[N], b[N], a[N], tot, cnt[N];\n\nvoid dfs_find(int S, int x) &#123;&#x2F;&#x2F;子树size:S(传值,非&amp;) 找x所在子树的重心as root\n\tv[x] &#x3D; 1;\n\ts[x] &#x3D; 1;&#x2F;&#x2F;局部变量！\n\tint max_part &#x3D; 0;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;&#x2F;&#x2F;x-i-&gt;y\n\t\tint y &#x3D; Edge[i];\n\t\tif (v[y] || w[y]) continue;&#x2F;&#x2F;w?\n\t\tdfs_find(S, y);\n\t\ts[x] +&#x3D; s[y];&#x2F;&#x2F;向上递推\n\t\tmax_part &#x3D; max(max_part, s[y]);\n\t&#125;\n\tmax_part &#x3D; max(max_part, S - s[x]);&#x2F;&#x2F;!!!\n\tif (max_part &lt; ans) &#123;&#x2F;&#x2F;min化max_part\n\t\tans &#x3D; max_part;\n\t\tpos &#x3D; x;\n\t&#125;\n&#125;\n\nvoid dfs(int x) &#123;\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (v[y] || w[y]) continue;\n\t\t++cnt[b[a[++tot]&#x3D;y]&#x3D;b[x]];&#x2F;&#x2F;子树x加边:x-(z)-&gt;y new点y\n\t\td[y] &#x3D; d[x] + z;\n\t\tdfs(y);\n\t&#125;\n&#125;\n\nbool cmp(int i, int j) &#123;\n\treturn d[i] &lt; d[j];\n&#125;\n\nvoid work(int S, int x) &#123;\n\tmemset(v, 0, sizeof(v));\n\tans &#x3D; S;&#x2F;&#x2F;ans: max_part初值\n\tdfs_find(S, x);&#x2F;&#x2F;1. 重心pos\n\t&#x2F;&#x2F;2. dfs出:d b cnt\n\tmemset(d, 0, sizeof(d));\n\tmemset(cnt, 0, sizeof(cnt));\n\tmemset(v, 0, sizeof(v));\n\tw[a[tot&#x3D;1]&#x3D;b[pos]&#x3D;pos] &#x3D; 1;&#x2F;&#x2F;w&#x3D;1 相当于 (逐递归层)删除根节点！！！\n\t++cnt[pos];&#x2F;&#x2F;cnt:子树size\n\tfor (int i &#x3D; Head[pos]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (v[y] || w[y]) continue;\n\t\t++cnt[a[++tot]&#x3D;b[y]&#x3D;y];&#x2F;&#x2F;new子树(点)y\n\t\td[y] &#x3D; z;\n\t\tdfs(y);\n\t&#125;\n\t&#x2F;&#x2F;3. Calc(P)\n\tsort(a + 1, a + tot + 1, cmp);\n\tint l &#x3D; 1, r &#x3D; tot;\n\t--cnt[b[a[1]]];&#x2F;&#x2F;L:0-&gt;1  cnt[s]:[L+1,R]的s子树size\t\t(L,R]\n\twhile (l &lt; r) &#123;\n\t\twhile (d[a[l]] + d[a[r]] &gt; k) --cnt[b[a[r--]]];&#x2F;&#x2F;while  --cnt(r), r--\n\t\tAns +&#x3D; r - l - cnt[b[a[l]]];\n\t\t--cnt[b[a[++l]]];&#x2F;&#x2F;++l,--cnt(l)\n\t&#125;\n\t&#x2F;&#x2F;4. 递归\n\tint now &#x3D; pos;\n\tfor (int i &#x3D; Head[now]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (w[y]) continue;&#x2F;&#x2F;子树根节点y已删除\n\t\twork(s[y], y);\n\t&#125;\n&#125;\n\nvoid add(int x, int y, int z) &#123;\n\tEdge[++t] &#x3D; y;\n\tLeng[t] &#x3D; z;\n\tNext[t] &#x3D; Head[x];\n\tHead[x] &#x3D; t;\n&#125;\n\nvoid Tree() &#123;\n\tt &#x3D; 0;\n\tmemset(Head, 0, sizeof(Head));\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t&#125;\n\tmemset(w, 0, sizeof(w));\n\tAns &#x3D; 0;\n\twork(n, 1);\n\tcout &lt;&lt; Ans &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; k &amp;&amp; n &amp;&amp; k) Tree();&#x2F;&#x2F;N点无根树，dx+dy&lt;&#x3D;k的路径条数\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x46.BST\n&#x2F;&#x2F;Treap\n&#x2F;&#x2F; 253\t普通平衡树\n\n\n&#x2F;&#x2F;0x47.离线分治算法\n&#x2F;&#x2F;CDQ分治(基于时间)\n&#x2F;&#x2F;天使玩偶   TLE？？？？\n\n&#x2F;&#x2F;天使玩偶 在线KD-Tree\n\n&#x2F;&#x2F;基于值域的整体分治算法\n&#x2F;&#x2F;第K小数 只Q不改\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100010, INF &#x3D; 1e9;\nstruct rec &#123;int op, x, y, z;&#125; q[2 * N], lq[2 * N], rq[2 * N];\nint n, m, t, c[N], ans[N];\n\nint ask(int x) &#123;\n\tint y &#x3D; 0;\n\tfor (; x; x -&#x3D; x &amp; -x) y +&#x3D; c[x];\n\treturn y;\n&#125;\n\nvoid change(int x, int y) &#123;\n\tfor (; x &lt;&#x3D; n; x +&#x3D; x &amp; -x) c[x] +&#x3D; y;\n&#125;\n\nvoid solve(int lval, int rval, int st, int ed) &#123;\n\tif (st &gt; ed) return;\n\tif (lval &#x3D;&#x3D; rval) &#123;\n\t\tfor (int i &#x3D; st; i &lt;&#x3D; ed; i++)\n\t\t\tif (q[i].op &gt; 0) ans[q[i].op] &#x3D; lval;\n\t\treturn;\n\t&#125;\n\tint mid &#x3D; (lval + rval) &gt;&gt; 1;\n\tint lt &#x3D; 0, rt &#x3D; 0;\n\tfor (int i &#x3D; st; i &lt;&#x3D; ed; i++) &#123;\n\t\tif (q[i].op &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 是一次赋值操作\n\t\t\tif (q[i].y &lt;&#x3D; mid) change(q[i].x, 1), lq[++lt] &#x3D; q[i];\n\t\t\telse rq[++rt] &#x3D; q[i];\n\t\t&#125; else &#123; &#x2F;&#x2F; 是一次询问\n\t\t\tint cnt &#x3D; ask(q[i].y) - ask(q[i].x - 1);\n\t\t\tif (cnt &gt;&#x3D; q[i].z) lq[++lt] &#x3D; q[i];\n\t\t\telse q[i].z -&#x3D; cnt, rq[++rt] &#x3D; q[i];\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; ed; i &gt;&#x3D; st; i--) &#123; &#x2F;&#x2F; 还原树状数组\n\t\tif (q[i].op &#x3D;&#x3D; 0 &amp;&amp; q[i].y &lt;&#x3D; mid) change(q[i].x, -1);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; lt; i++) q[st + i - 1] &#x3D; lq[i];\n\tfor (int i &#x3D; 1; i &lt;&#x3D; rt; i++) q[st + lt + i - 1] &#x3D; rq[i];\n\tsolve(lval, mid, st, st + lt - 1);\n\tsolve(mid + 1, rval, st + lt, ed);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint val; scanf(&quot;%d&quot;, &amp;val);\n\t\t&#x2F;&#x2F; a[i]&#x3D;val等价于一次把第i个数赋值为val的操作\n\t\tq[++t].op &#x3D; 0, q[t].x &#x3D; i, q[t].y &#x3D; val;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint l, r, k; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);\n\t\t&#x2F;&#x2F; 记录一次询问\n\t\tq[++t].op &#x3D; i, q[t].x &#x3D; l, q[t].y &#x3D; r, q[t].z &#x3D; k;\n\t&#125;\n\t&#x2F;&#x2F; 基于值域对t&#x3D;n+m个操作进行整体分治\n\tsolve(-INF, INF, 1, t);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) printf(&quot;%d\\n&quot;, ans[i]);\n&#125;\n\n\n&#x2F;&#x2F;Dynamic Ranking\n\n\n&#x2F;&#x2F;0x48.可持久化ds\n&#x2F;&#x2F;可持久化Trie\n&#x2F;&#x2F;最大异或和  ？？？不太理解insert对Trie的构造原因？？？？？？\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\nconst int N &#x3D; 600010;\nint trie[N * 24][2], latest[N * 24]; &#x2F;&#x2F; latest和end可合并为一个数组\nint s[N], root[N], n, m, tot;\n\n&#x2F;&#x2F; 本题需要统计子树latest，故使用递归插入\n&#x2F;&#x2F; 插入s[i]，当前为s[i]的第k位\nvoid insert(int i, int k, int p, int q) &#123;&#x2F;&#x2F;p&#x3D;&#x3D;0：不存在\n\tif (k &lt; 0) &#123;\n\t\tlatest[q] &#x3D; i;&#x2F;&#x2F;节点q是seq s中s[i]的末尾节点\n\t\treturn;\n\t&#125;\n\tint c &#x3D; s[i] &gt;&gt; k &amp; 1;&#x2F;&#x2F;取第k位\n\tif (p) trie[q][c ^ 1] &#x3D; trie[p][c ^ 1];&#x2F;&#x2F;存在，就copy\n\ttrie[q][c] &#x3D; ++tot;&#x2F;&#x2F;？？？\n\tinsert(i, k - 1, trie[p][c], trie[q][c]);&#x2F;&#x2F;？？？\n\tlatest[q] &#x3D; max(latest[trie[q][0]], latest[trie[q][1]]);\n&#125;\n\nint ask(int now, int val, int k, int limit) &#123;\n\tif (k &lt; 0) return s[latest[now]] ^ val;\n\tint c &#x3D; val &gt;&gt; k &amp; 1;\n\tif (latest[trie[now][c ^ 1]] &gt;&#x3D; limit)\n\t\treturn ask(trie[now][c ^ 1], val, k - 1, limit);\n\telse&#x2F;&#x2F; 到底是（先&#x2F;仅）考虑 &gt;&#x3D; l-1????？？？？？？？？？？\n\t\treturn ask(trie[now][c], val, k - 1, limit);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tlatest[0] &#x3D; -1;\n\troot[0] &#x3D; ++tot;\n\tinsert(0, 23, 0, root[0]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x; scanf(&quot;%d&quot;, &amp;x);\n\t\ts[i] &#x3D; s[i - 1] ^ x;\n\t\troot[i] &#x3D; ++tot;\n\t\tinsert(i, 23, root[i - 1], root[i]);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tchar op[2]; scanf(&quot;%s&quot;, op);\n\t\tif (op[0] &#x3D;&#x3D; &#39;A&#39;) &#123;\n\t\t\tint x; scanf(&quot;%d&quot;, &amp;x);\n\t\t\troot[++n] &#x3D; ++tot;\n\t\t\ts[n] &#x3D; s[n - 1] ^ x;\n\t\t\tinsert(n, 23, root[n - 1], root[n]);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tint l, r, x; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;x);\n\t\t\tprintf(&quot;%d\\n&quot;, ask(root[r - 1], x ^ s[n], 23, l - 1));\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;第k小数\n&#x2F;&#x2F;法2. 可持久化SegTree_不带修改\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100010, INF &#x3D; 1e9;\nstruct SegmentTree &#123;\n\tint lc, rc; &#x2F;&#x2F; 左右子节点编号\n\tint sum;\n&#125; tree[N * 20];\nint n, m, t, tot, a[N], b[N], root[N];\n\nint build(int l, int r) &#123;\n\tint p &#x3D; ++tot; &#x2F;&#x2F; 新建一个节点，编号为p，代表当前区间[l,r]\n\ttree[p].sum &#x3D; 0;\n\tif (l &#x3D;&#x3D; r) return p;\n\tint mid &#x3D; (l + r) &gt;&gt; 1;\n\ttree[p].lc &#x3D; build(l, mid);\n\ttree[p].rc &#x3D; build(mid + 1, r);\n\treturn p;\n&#125;\n\nint insert(int now, int l, int r, int x, int delta) &#123;\n\tint p &#x3D; ++tot;\n\ttree[p] &#x3D; tree[now]; &#x2F;&#x2F; 新建一个副本\n\tif (l &#x3D;&#x3D; r) &#123;\n\t\ttree[p].sum +&#x3D; delta; &#x2F;&#x2F; 在副本上修改\n\t\treturn p;\n\t&#125;\n\tint mid &#x3D; (l + r) &gt;&gt; 1;&#x2F;&#x2F;更新lc rc编号\n\tif (x &lt;&#x3D; mid) tree[p].lc &#x3D; insert(tree[now].lc, l, mid, x, delta);\n\telse tree[p].rc &#x3D; insert(tree[now].rc, mid + 1, r, x, delta);\n\ttree[p].sum &#x3D; tree[tree[p].lc].sum + tree[tree[p].rc].sum;\n\treturn p;\n&#125;\n\nint ask(int p, int q, int l, int r, int k) &#123;\n\tif (l &#x3D;&#x3D; r) return l; &#x2F;&#x2F; 找到答案 第k小\n\tint mid &#x3D; (l + r) &gt;&gt; 1;\n\tint lcnt &#x3D; tree[tree[p].lc].sum - tree[tree[q].lc].sum; &#x2F;&#x2F; 值在[l,mid]中的数有多少个\n\tif (k &lt;&#x3D; lcnt) return ask(tree[p].lc, tree[q].lc, l, mid, k);\n\telse return ask(tree[p].rc, tree[q].rc, mid + 1, r, k - lcnt);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;a[i]);\n\t\tb[++t] &#x3D; a[i];\n\t&#125;\n\tsort(b + 1, b + t + 1); &#x2F;&#x2F; 离散化\n\tt &#x3D; unique(b + 1, b + t + 1) - (b + 1);\n\troot[0] &#x3D; build(1, t); &#x2F;&#x2F; 关于离散化后的值域建线段树\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x &#x3D; lower_bound(b + 1, b + t + 1, a[i]) - b; &#x2F;&#x2F; 离散化后的值x\n\t\troot[i] &#x3D; insert(root[i - 1], 1, t, x, 1); &#x2F;&#x2F; 值为x的数增加1个\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint l, r, k; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);\n\t\tint ans &#x3D; ask(root[r], root[l - 1], 1, t, k);&#x2F;&#x2F;离散化后的值&#x3D;&#x3D;下标\n\t\tprintf(&quot;%d\\n&quot;, b[ans]); &#x2F;&#x2F; 从离散化后的值(下标)变回原值\n\t&#125;\n&#125;\n\n-------------------------------------------------------------------\n&#x2F;&#x2F;0x49 总结与练习\n&#x2F;&#x2F; 257\t关押罪犯（法1 法2:0x68 二分图匹配）\n\n&#x2F;&#x2F; 258\t石头剪子布\n\n&#x2F;&#x2F; 259\t真正的骗子\n\n&#x2F;&#x2F; 260\t买票\n\n&#x2F;&#x2F; 261\t旅馆\n\n&#x2F;&#x2F; 262\t海报\n\n\n&#x2F;&#x2F; 263\t作诗\n\n&#x2F;&#x2F; 264\t权值\n\n&#x2F;&#x2F; 265\t营业额统计\n\n&#x2F;&#x2F; 266\t超级备忘录\n\n&#x2F;&#x2F; 267\t莫基亚\n\n&#x2F;&#x2F; 268\t流星\n\n&#x2F;&#x2F; 269\tFotile模拟赛L\n\n&#x2F;&#x2F; 270\t可持久化并查集加强版\n\n\n\n\n</code></pre>\n\n\n\n<h1 id=\"0x50动态规划DP\"><a href=\"#0x50动态规划DP\" class=\"headerlink\" title=\"0x50动态规划DP\"></a>0x50动态规划DP</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;0x51.线性DP\n&#x2F;&#x2F;杨老师的照相排列\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#define ll long long\nusing namespace std;\nint n[6], k;\nconst int N &#x3D; 31;\n&#x2F;&#x2F; ll f[N][N][N][N][N];\n\nvoid work() &#123;\n\tint n[6] &#x3D; &#123;0&#125;;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; k; i++) cin &gt;&gt; n[i];\n\t&#x2F;&#x2F; while (k &lt; 5) n[++k] &#x3D; 0;\n\tll f[n[1]+1][n[2]+1][n[3]+1][n[4]+1][n[5]+1];&#x2F;&#x2F;0~n 各排人数的方案数\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0][0][0] &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; n[1]; i++)\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; n[2]; j++)\n\t\t\tfor (int k &#x3D; 0; k &lt;&#x3D; n[3]; k++)\n\t\t\t\tfor (int l &#x3D; 0; l &lt;&#x3D; n[4]; l++)\n\t\t\t\t\tfor (int m &#x3D; 0; m &lt;&#x3D; n[5]; m++) &#123;\n\t\t\t\t\t\tll &amp;v &#x3D; f[i][j][k][l][m];\n\t\t\t\t\t\tif (i &lt; n[1]) f[i+1][j][k][l][m] +&#x3D; v;\n\t\t\t\t\t\tif (j &lt; n[2] &amp;&amp; i &gt; j) f[i][j+1][k][l][m] +&#x3D; v;\n\t\t\t\t\t\tif (k &lt; n[3] &amp;&amp; j &gt; k) f[i][j][k+1][l][m] +&#x3D; v;\n\t\t\t\t\t\tif (l &lt; n[4] &amp;&amp; k &gt; l) f[i][j][k][l+1][m] +&#x3D; v;\n\t\t\t\t\t\tif (m &lt; n[5] &amp;&amp; l &gt; m) f[i][j][k][l][m+1] +&#x3D; v;\n\t\t\t\t\t&#125;\n\tcout &lt;&lt; f[n[1]][n[2]][n[3]][n[4]][n[5]] &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; k &amp;&amp; k) work();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;yxc版\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#define LL long long\nusing namespace std;\nint n[6], k;\n&#x2F;&#x2F; LL f[N][N][N][N][N];\n\nvoid work() &#123;\n\tint n[6] &#x3D; &#123;0&#125;;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; k; i++) cin &gt;&gt; n[i];\n&#x2F;&#x2F; \twhile (k &lt; 5) n[++k] &#x3D; 0;\n\tLL f[n[1]+1][n[2]+1][n[3]+1][n[4]+1][n[5]+1];&#x2F;&#x2F;0~n 各排人数的方案数\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0][0][0] &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; n[1]; i++)\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; min(i, n[2]); j++)&#x2F;&#x2F;\n\t\t\tfor (int k &#x3D; 0; k &lt;&#x3D; min(j, n[3]); k++)\n\t\t\t\tfor (int l &#x3D; 0; l &lt;&#x3D; min(k, n[4]); l++)\n\t\t\t\t\tfor (int m &#x3D; 0; m &lt;&#x3D; min(l, n[5]); m++) &#123;\n\t\t\t\t\t\tll &amp;v &#x3D; f[i][j][k][l][m];\n\t\t\t\t\t\tif (i &amp;&amp; i &gt; j) v +&#x3D; f[i-1][j][k][l][m];\n\t\t\t\t\t\tif (j &amp;&amp; j &gt; k) v +&#x3D; f[i][j-1][k][l][m];\n\t\t\t\t\t\tif (k &amp;&amp; k &gt; l) v +&#x3D; f[i][j][k-1][l][m];\n\t\t\t\t\t\tif (l &amp;&amp; l &gt; m) v +&#x3D; f[i][j][k][l-1][m];\n\t\t\t\t\t\tif (m) v +&#x3D; f[i][j][k][l][m-1];\n\t\t\t\t\t&#125;\n\tcout &lt;&lt; f[n[1]][n[2]][n[3]][n[4]][n[5]] &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; k &amp;&amp; k) work();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;最长公共上升子序列   LCS套LIS\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 3006;\nint n, a[N], b[N], f[N][N];\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;b[i]);\n&#x2F;*\n\t&#x2F;&#x2F; O(n^3)\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tf[i][j] &#x3D; f[i - 1][j];\n\t\t\tif (a[i] &#x3D;&#x3D; b[j])\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F; int maxv &#x3D; 1;\n\t\t\t\tfor (int k &#x3D; 1; k &lt; j; k++)\n\t\t\t\t\tif (b[k] &lt; a[i]) f[i][j] &#x3D; max(f[i][j], f[i - 1][k] + 1);\n\t\t\t\t\t\t&#x2F;&#x2F; maxv &#x3D; max(maxv, f[i - 1][k] + 1);\n\t\t\t\t&#x2F;&#x2F; f[i][j] &#x3D; max(f[i][j], maxv);\n\t\t\t&#125;\n\t\t&#125;\n*&#x2F;\n\t&#x2F;&#x2F;O(n^2)\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint maxv &#x3D; 1;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tf[i][j] &#x3D; f[i - 1][j];\n\t\t\tif (a[i] &#x3D;&#x3D; b[j]) f[i][j] &#x3D; max(f[i][j], maxv);\n\t\t\t&#x2F;&#x2F; j即将增大为j+1，检查j能否进入新的决策集合\n\t\t\tif (b[j] &lt; a[i]) maxv &#x3D; max(maxv, f[i - 1][j] + 1);\n\t\t&#125;\n\t&#125;\n\n\tint ans &#x3D; 0;\n\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) ans &#x3D; max(ans, f[n][j]);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;分级\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 2010, INF &#x3D; 0x3f3f3f3f;\n\nint n;\nint a[N], b[N];\nint f[N][N];\n\nint dp()\n&#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) b[i] &#x3D; a[i];\n\tsort(b + 1, b + n + 1);\n\t\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint minv &#x3D; INF;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)&#x2F;&#x2F;O(1)状态转移 更新一行f[i]\n\t\t&#123;\n\t\t\tminv &#x3D; min(minv, f[i - 1][j]);\n\t\t\tf[i][j] &#x3D; minv + abs(b[j] - a[i]);&#x2F;&#x2F;f[i][j]:最后一个数是b[j]时...\n\t\t&#125;\n\t&#125;\n\n\tint res &#x3D; INF;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) res &#x3D; min(res, f[n][i]);\n\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\n\tint res &#x3D; dp();\n\treverse(a+1, a+n+1);\n\tres &#x3D; min(res, dp());\n\n\tprintf(&quot;%d\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;移动服务\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1010, M &#x3D; 210, INF &#x3D; 0x3f3f3f3f;\n\nint n, m;\nint w[M][M];\nint p[N];\nint f[N][M][M];\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;m, &amp;n);&#x2F;&#x2F;位置数，请求数\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t\tscanf(&quot;%d&quot;, &amp;w[i][j]);&#x2F;&#x2F;花费 c(p,q)\n\t&#x2F;&#x2F;批量 离线\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;p[i]);&#x2F;&#x2F;每次请求位置\n\t\n\tmemset(f, 0x3f, sizeof f);\n\tp[0] &#x3D; 3;&#x2F;&#x2F;阶段无后效性 不妨先动3\n\tf[0][1][2] &#x3D; 0;\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)&#x2F;&#x2F;0~n-1: i~i+1\n\t\tfor (int x &#x3D; 1; x &lt;&#x3D; m; x++)\n\t\t\tfor (int y &#x3D; 1; y &lt;&#x3D; m; y++)\n\t\t\t&#x2F;&#x2F; if(f[i][x][y] !&#x3D; INF) &#123;\n\t\t\t&#123;\n\t\t\t\tint z &#x3D; p[i], u &#x3D; p[i + 1], v&#x3D; f[i][x][y];\n\t\t\t\tif(x &#x3D;&#x3D; y || x &#x3D;&#x3D; z || y &#x3D;&#x3D; z) continue;\n\t\t\t\tf[i + 1][x][y] &#x3D; min(f[i + 1][x][y], v + w[z][u]);\n\t\t\t\tf[i + 1][z][y] &#x3D; min(f[i + 1][z][y], v + w[x][u]);\n\t\t\t\tf[i + 1][x][z] &#x3D; min(f[i + 1][x][z], v + w[y][u]);\n\t\t\t&#125;\n\t\n\tint res &#x3D; INF;\n\tfor (int x &#x3D; 1; x &lt;&#x3D; m; x++)\n\t\tfor (int y &#x3D; 1; y &lt;&#x3D; m; y++)\n\t\t&#123;\n\t\t\tint z &#x3D; p[n];\n\t\t\tif(x &#x3D;&#x3D; y || x &#x3D;&#x3D; z || y &#x3D;&#x3D; z) continue;\n\t\t\tres &#x3D; min(res, f[n][x][y]);\n\t\t&#125;\n\tprintf(&quot;%d\\n&quot;, res);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;传纸条\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 55;\nint n, m, w[N][N], f[N&lt;&lt;1][N][N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t\tscanf(&quot;%d&quot;, &amp;w[i][j]);\n\t\n\tfor (int k &#x3D; 2; k &lt;&#x3D; n + m; k++)&#x2F;&#x2F;cur_steps\n\t\tfor (int x1 &#x3D; max(1, k - m); x1 &lt;&#x3D; min(k - 1, n); x1++)\n\t\t\tfor (int x2 &#x3D; max(1, k - m); x2 &lt;&#x3D; min(k - 1, n); x2++)\n\t\t\t&#123;\n\t\t\t\tint t &#x3D; w[x1][k - x1];&#x2F;&#x2F;k&#x3D;&#x3D; x&#x3D;&#x3D; (k-x)&#x3D;&#x3D;\n\t\t\t\tif(x2 !&#x3D; x1) t +&#x3D; w[x2][k - x2];\n\t\t\t\tfor (int a &#x3D; 0; a &lt;&#x3D; 1; a++)\n\t\t\t\t\tfor (int b &#x3D; 0; b &lt;&#x3D; 1; b++)\n\t\t\t\t\t\tf[k][x1][x2] &#x3D; max(f[k][x1][x2], f[k - 1][x1 - a][x2 - b] + t);\n\t\t\t&#125;\n\n\tcout &lt;&lt; f[n + m][n][n] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;I-区域\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 16;\n\nint n, m, k;\nint w[N][N];\nint f[N][N * N][N][N][2][2];&#x2F;&#x2F;ij[lr]xy\n\nstruct State\n&#123;\n\tint i, j, l, r, x, y;\n&#125;g[N][N * N][N][N][2][2];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )\n\t\t\tcin &gt;&gt; w[i][j];\n\n\tmemset(f, -0x3f, sizeof f);&#x2F;&#x2F;init不合法，k&#x3D;&#x3D;0\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; k; j ++ )&#x2F;&#x2F;共选k个格子\n\t\t\tfor (int l &#x3D; 1; l &lt;&#x3D; m; l ++ )\n\t\t\t\tfor (int r &#x3D; l; r &lt;&#x3D; m; r ++ )&#x2F;&#x2F;r&gt;&#x3D;l\n\t\t\t\t&#123;\n\t\t\t\t\tif (j &lt; r - l + 1) continue;\n\n\t\t\t\t\t&#x2F;&#x2F; 左扩张，右扩张\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tauto &amp;vf &#x3D; f[i][j][l][r][1][0];&#x2F;&#x2F;ans最大权值和\n\t\t\t\t\t\tauto &amp;vg &#x3D; g[i][j][l][r][1][0];&#x2F;&#x2F;struct&#123;i-1状态&#125;\n\t\t\t\t\t\tif (j &#x3D;&#x3D; r - l + 1) vf &#x3D; 0;&#x2F;&#x2F;起点,已有vf&#x3D;0\n\t\t\t\t\t\tfor (int p &#x3D; l; p &lt;&#x3D; r; p ++ )\n\t\t\t\t\t\t\tfor (int q &#x3D; p; q &lt;&#x3D; r; q ++ )\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tint val &#x3D; f[i - 1][j - (r - l + 1)][p][q][1][0];\n\t\t\t\t\t\t\t\tif (vf &lt; val)&#x2F;&#x2F;max(val) 更新\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tvf &#x3D; val;\n\t\t\t\t\t\t\t\t\tvg &#x3D; &#123;i - 1, j - (r - l + 1), p, q, 1, 0&#125;;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tfor (int u &#x3D; l; u &lt;&#x3D; r; u ++ ) vf +&#x3D; w[i][u];\n\t\t\t\t\t&#125;\n\n\t\t\t\t\t&#x2F;&#x2F; 左扩张，右收缩\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tauto &amp;vf &#x3D; f[i][j][l][r][1][1];\n\t\t\t\t\t\tauto &amp;vg &#x3D; g[i][j][l][r][1][1];\n\t\t\t\t\t\tfor (int p &#x3D; l; p &lt;&#x3D; r; p ++ )&#x2F;&#x2F;\n\t\t\t\t\t\t\tfor (int q &#x3D; r; q &lt;&#x3D; m; q ++ )&#x2F;&#x2F;\n\t\t\t\t\t\t\t\tfor (int y &#x3D; 0; y &lt;&#x3D; 1; y ++ )&#x2F;&#x2F;\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tint val &#x3D; f[i - 1][j - (r - l + 1)][p][q][1][y];&#x2F;&#x2F;\n\t\t\t\t\t\t\t\t\tif (vf &lt; val)\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\tvf &#x3D; val;\n\t\t\t\t\t\t\t\t\t\tvg &#x3D; &#123;i - 1, j - (r - l + 1), p, q, 1, y&#125;;\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tfor (int u &#x3D; l; u &lt;&#x3D; r; u ++ ) vf +&#x3D; w[i][u];\n\t\t\t\t\t&#125;\n\n\t\t\t\t\t&#x2F;&#x2F; 左收缩，右扩张\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tauto &amp;vf &#x3D; f[i][j][l][r][0][0];\n\t\t\t\t\t\tauto &amp;vg &#x3D; g[i][j][l][r][0][0];\n\t\t\t\t\t\tfor (int p &#x3D; 1; p &lt;&#x3D; l; p ++ )\n\t\t\t\t\t\t\tfor (int q &#x3D; l; q &lt;&#x3D; r; q ++ )\n\t\t\t\t\t\t\t\tfor (int x &#x3D; 0; x &lt;&#x3D; 1; x ++ )\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tint val &#x3D; f[i - 1][j - (r - l + 1)][p][q][x][0];\n\t\t\t\t\t\t\t\t\tif (vf &lt; val)\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\tvf &#x3D; val;\n\t\t\t\t\t\t\t\t\t\tvg &#x3D; &#123;i - 1, j - (r - l + 1), p, q, x, 0&#125;;\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tfor (int u &#x3D; l; u &lt;&#x3D; r; u ++ ) vf +&#x3D; w[i][u];\n\t\t\t\t\t&#125;\n\n\t\t\t\t\t&#x2F;&#x2F; 左收缩，右收缩\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tauto &amp;vf &#x3D; f[i][j][l][r][0][1];\n\t\t\t\t\t\tauto &amp;vg &#x3D; g[i][j][l][r][0][1];\n\t\t\t\t\t\tfor (int p &#x3D; 1; p &lt;&#x3D; l; p ++ )\n\t\t\t\t\t\t\tfor (int q &#x3D; r; q &lt;&#x3D; m; q ++ )\n\t\t\t\t\t\t\t\tfor (int x &#x3D; 0; x &lt;&#x3D; 1; x ++ )\n\t\t\t\t\t\t\t\t\tfor (int y &#x3D; 0; y &lt;&#x3D; 1; y ++ )\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\tint val &#x3D; f[i - 1][j - (r - l + 1)][p][q][x][y];\n\t\t\t\t\t\t\t\t\t\tif (vf &lt; val)\n\t\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\t\tvf &#x3D; val;\n\t\t\t\t\t\t\t\t\t\t\tvg &#x3D; &#123;i - 1, j - (r - l + 1), p, q, x, y&#125;;\n\t\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tfor (int u &#x3D; l; u &lt;&#x3D; r; u ++ ) vf +&#x3D; w[i][u];\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\t\n\tint res &#x3D; 0;\n\tState state;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tfor (int l &#x3D; 1; l &lt;&#x3D; m; l ++ )\n\t\t\tfor (int r &#x3D; 1; r &lt;&#x3D; m; r ++ )\n\t\t\t\tfor (int x &#x3D; 0; x &lt;&#x3D; 1; x ++ )\n\t\t\t\t\tfor (int y &#x3D; 0; y &lt;&#x3D; 1; y ++ )\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tint val &#x3D; f[i][k][l][r][x][y];\n\t\t\t\t\t\tif (res &lt; val)\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tres &#x3D; val;\n\t\t\t\t\t\t\tstate &#x3D; &#123;i, k, l, r, x, y&#125;;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\n\tprintf(&quot;Oil : %d\\n&quot;, res);\n\n\twhile (state.j)&#x2F;&#x2F;j:k-&gt;1\n\t&#123;\n\t\tfor (int i &#x3D; state.l; i &lt;&#x3D; state.r; i ++ ) printf(&quot;%d %d\\n&quot;, state.i, i);&#x2F;&#x2F;行 列\n\t\tstate &#x3D; g[state.i][state.j][state.l][state.r][state.x][state.y];\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;饼干\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 31, M &#x3D; 5010;\n\nint n, m;&#x2F;&#x2F;孩子 饼干\nPII g[N];&#x2F;&#x2F;&#123;i的怨气值, i&#125;\nint s[N];&#x2F;&#x2F;怨气值前缀和\nint f[N][M];&#x2F;&#x2F;状态：前i人共分j块饼干\nint ans[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tcin &gt;&gt; g[i].first;\n\t\tg[i].second &#x3D; i;\n\t&#125;\n\tsort(g + 1, g + n + 1);\n\treverse(g + 1, g + n + 1);\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) s[i] &#x3D; s[i - 1] + g[i].first;\n\n\tmemset(f, 0x3f, sizeof f);\n\tf[0][0] &#x3D; 0;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#x2F;&#x2F; 孩子\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) &#x2F;&#x2F; 饼干\n\t\t&#123;\n\t\t\tif(j &lt; i) continue;&#x2F;&#x2F;每人至少一块饼干\n\t\t\tf[i][j] &#x3D; f[i][j - i];\n\t\t\tfor(int k &#x3D; 1; k &lt;&#x3D; i; k++)\n\t\t\t\tf[i][j] &#x3D; min(f[i][j], f[i - k][j - k] + (s[i] - s[i - k]) * (i - k));\n\t\t&#125;\n\t\n\tcout &lt;&lt; f[n][m] &lt;&lt; endl;\n\t\n\tint i &#x3D; n, j &#x3D; m, h &#x3D; 0;&#x2F;&#x2F;h:整体向上偏移量\n\twhile(i)\n\t&#123;\n\t\tif(f[i][j] &#x3D;&#x3D; f[i][j - i]) j -&#x3D; i, h++;\n\t\telse\n\t\t&#123;\n\t\t\tfor(int k &#x3D; 1; k &lt;&#x3D; i; k++)\n&#x2F;*    while (i &amp;&amp; j)\n\t&#123;\n\t\tif (j &gt;&#x3D; i &amp;&amp; f[i][j] &#x3D;&#x3D; f[i][j - i]) j -&#x3D; i, h ++ ;\n\t\telse\n\t\t&#123;\n\t\t\tfor (int k &#x3D; 1; k &lt;&#x3D; i &amp;&amp; k &lt;&#x3D; j; k ++ ) *&#x2F;\n\t\t\t\tif(f[i][j] &#x3D;&#x3D; f[i - k][j - k] + (s[i] - s[i - k]) * (i - k))\n\t\t\t\t&#123;\n\t\t\t\t\tfor(int u &#x3D;  i - k + 1; u &lt;&#x3D; i; u++) ans[g[u].second] &#x3D; 1 + h;\n\t\t\t\t\ti -&#x3D; k, j -&#x3D; k;&#x2F;&#x2F;去掉只拿一块饼干的人\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;\n\tcout &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x52.背包\n&#x2F;&#x2F;0&#x2F;1bag\n&#x2F;&#x2F;数字组合 数字不等\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 10010;\n\nint n, m;\nint f[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tf[0] &#x3D; 1;\n\twhile(n--)\n\t&#123;\n\t\tint v;\n\t\tcin &gt;&gt; v;\n\t\tfor(int i &#x3D; m; i &gt;&#x3D; v; i--) f[i] +&#x3D; f[i - v];\n\t&#125;\n\n\tcout &lt;&lt; f[m] &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;完全bag \n&#x2F;&#x2F;自然数拆分Lunatic版 数字可重复 无序\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 10010;\n\nint n, m;\nunsigned f[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tf[0] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; i; j &lt;&#x3D; n; j++)\n\t\t\tf[j] +&#x3D; f[j - i];\n\t&#x2F;&#x2F;(int)2147483648 &#x3D;&#x3D; -2147483648 溢出为-INF;C++语法 ...%abs()\n\tcout &lt;&lt; (f[n] - 1) % 2147483648u &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;陪审团\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 210, M &#x3D; 810, base &#x3D; 400;\n\nint n, m;\nint p[N], d[N];\nint f[N][21][M];&#x2F;&#x2F;n,取m,差值\nint ans[N];\n\nint main()\n&#123;\n\tint T &#x3D; 1;\n\twhile(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)\n\t&#123;\n\t\tfor(int i &#x3D; 1;i &lt;&#x3D; n; i++) scanf(&quot;%d%d&quot;, &amp;p[i], &amp;d[i]);\n\n\t\tmemset(f, -0x3f, sizeof f);\n\t\tf[0][0][base] &#x3D; 0;\n\t\t\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt;&#x3D; m; j++)\n\t\t\t\tfor (int k &#x3D; 0; k &lt;&#x3D; M; k++)\n\t\t\t\t&#123;\n\t\t\t\t\tf[i][j][k] &#x3D; f[i - 1][j][k];\n\t\t\t\t\tint t &#x3D; k - (p[i] - d[i]);\n\t\t\t\t\tif(t &lt; 0 ||  t &gt;&#x3D; M) continue;&#x2F;&#x2F;差值不合法\n\t\t\t\t\tif(j &lt; 1) continue;&#x2F;&#x2F;j-1&gt;&#x3D;0\n\t\t\t\t\tf[i][j][k] &#x3D; max(f[i][j][k], f[i - 1][j - 1][t] + p[i] + d[i]);&#x2F;&#x2F;选i,不选i\n\t\t\t\t&#125;\n\t\t&#x2F;&#x2F;abs(差值)&#x3D;&#x3D;0时不存在方案f&lt;0，扩大差值v++\n\t\tint v &#x3D; 0;\n\t\twhile(f[n][m][base - v] &lt; 0 &amp;&amp; f[n][m][base + v] &lt; 0) v++;\n\t\t&#x2F;&#x2F;abs(v)&#x3D;&#x3D; , d+p&#x3D;f_max\n\t\tif(f[n][m][base - v] &gt; f[n][m][base + v]) v &#x3D; base - v;\n\t\telse v &#x3D; base + v;\n\n\t\t&#x2F;&#x2F;选了哪些人ans[cnt]\n\t\tint cnt &#x3D; 0;\n\t\tint i &#x3D; n, j &#x3D; m, k &#x3D; v;\n\t\twhile(j)\n\t\t&#123;\n\t\t\tif(f[i][j][k] &#x3D;&#x3D; f[i - 1][j][k]) i--;&#x2F;&#x2F;不选i\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tans[cnt ++ ] &#x3D; i;&#x2F;&#x2F;记录i\n\t\t\t\tk -&#x3D; (p[i] - d[i]);&#x2F;&#x2F;更新\n\t\t\t\ti--, j--;\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;求sum_p sum_d\n\t\tint sp &#x3D; 0, sd &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; cnt; i++)\n\t\t&#123;\n\t\t\tsp +&#x3D; p[ans[i]];\n\t\t\tsd +&#x3D; d[ans[i]];\n\t\t&#125;\n\n\t\tprintf(&quot;Jury #%d\\n&quot;, T++);\n\t\tprintf(&quot;Best jury has value %d for prosecution and value %d for defence:\\n&quot;, sp, sd);\n\t\tfor (int i &#x3D; 0; i &lt; cnt; i++) printf(&quot; %d\\n&quot;, ans[i]);\n\t\tputs(&quot;\\n&quot;);\n\n\t\treturn 0;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;多重bag\n&#x2F;&#x2F;硬币\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110, M &#x3D; 100010;\n\nint n, m;\nint v[N], s[N];\nint f[M], g[M];\n\nint main()\n&#123;\n\twhile(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;v[i]);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;s[i]);\n\t\t\n\t\tmemset(f, 0, sizeof f);\n\n\t\tf[0] &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\tmemset(g, 0, sizeof g);\n\t\t\tfor (int j &#x3D; i; j &lt;&#x3D; m; j++)\n\t\t\t\tif(!f[j] &amp;&amp; f[j - v[i]] &amp;&amp; g[j - v[i]] &lt; s[i])\n\t\t\t\t&#123;\n\t\t\t\t\tf[j] &#x3D; 1;\n\t\t\t\t\tg[j] &#x3D; g[j - v[i]] + 1;\n\t\t\t\t&#125;\n\t\t&#125;\n\n\t\tint res &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) res +&#x3D; f[i];\n\n\t\tprintf(&quot;%d\\n&quot;, res);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;分组bag\n&#x2F;&#x2F;0x53.区间DP\n&#x2F;&#x2F;石子合并\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 310, INF &#x3D; 0x3f3f3f3f;\n\nint n;\nint w[N], s[N];\nint f[N][N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; w[i];\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) s[i] &#x3D; s[i - 1] + w[i];\n\n\tfor (int len &#x3D; 2; len &lt;&#x3D; n; len ++ )&#x2F;&#x2F;阶段:len\n\t\tfor (int l &#x3D; 1; l + len - 1 &lt;&#x3D; n; l ++ )&#x2F;&#x2F;状态l\n\t\t&#123;\n\t\t\tint r &#x3D; l + len - 1;&#x2F;&#x2F;状态r\n\t\t\tf[l][r] &#x3D; INF;\n\t\t\tfor(int k &#x3D; l; k &lt; r; k++)&#x2F;&#x2F;决策:划分点k\n\t\t\t\tf[l][r] &#x3D; min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);\n\t\t&#125;\n\tprintf(&quot;%d\\n&quot;, f[1][n]);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;多边形\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110, INF &#x3D; 32768;&#x2F;&#x2F;N &#x3D; 55 * 2\n\nint n;\nchar c[N];&#x2F;&#x2F;op_char\nint w[N];&#x2F;&#x2F;op_num\nint f[N][N], g[N][N];&#x2F;&#x2F;Max, min\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) \n\t&#123;\n\t\tcin &gt;&gt; c[i] &gt;&gt; w[i];\n\t\tc[i + n] &#x3D; c[i];&#x2F;&#x2F;长度2N的链\n\t\tw[i + n] &#x3D; w[i];\n\t&#125;\n\tfor (int len &#x3D; 1; len &lt;&#x3D; n; len ++ )&#x2F;&#x2F;阶段:len\n\t\tfor (int l &#x3D; 1; l + len - 1 &lt;&#x3D; n * 2; l ++ )&#x2F;&#x2F;状态l\n\t\t&#123;\n\t\t\tint r &#x3D; l + len - 1;&#x2F;&#x2F;状态r\n\t\t\tif(len &#x3D;&#x3D; 1) f[l][r] &#x3D; g[l][r] &#x3D; w[l];\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tf[l][r] &#x3D; -INF, g[l][r] &#x3D; INF;\n\t\t\t\tfor(int k &#x3D; l; k &lt; r; k++)&#x2F;&#x2F;决策:划分点k\n\t\t\t\t&#123;\n\t\t\t\t\tchar op &#x3D; c[k + 1];\n\t\t\t\t\tint minl &#x3D; g[l][k], maxl &#x3D; f[l][k], minr &#x3D; g[k + 1][r], maxr &#x3D; f[k + 1][r];\n\t\t\t\t\tif(op &#x3D;&#x3D; &#39;t&#39;)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tf[l][r] &#x3D; max(f[l][r], maxl + maxr);\n\t\t\t\t\t\tg[l][r] &#x3D; min(g[l][r], minl + minr);\n\t\t\t\t\t&#125;\n\t\t\t\t\telse\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tint x1 &#x3D; minl * minr, x2 &#x3D; minl * maxr, x3 &#x3D; maxl * minr, x4 &#x3D; maxl * maxr;\n\t\t\t\t\t\tf[l][r] &#x3D; max(f[l][r], max(max(x1, x2),max(x3, x4)));\n\t\t\t\t\t\tg[l][r] &#x3D; min(g[l][r], min(min(x1, x2),min(x3, x4)));\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\tint res &#x3D; INF;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) res &#x3D; max(res, f[i][i + n - 1]);\n\tcout &lt;&lt; res &lt;&lt; endl;\n\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif(res &#x3D;&#x3D; f[i][i + n - 1]) cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;金字塔\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef long long LL;\n\nconst int N &#x3D; 310, mod &#x3D; 1e9;\n\nstring str;\nint f[N][N];\n\nint main()\n&#123;\n\tcin &gt;&gt; str;\n\tint n &#x3D; str.size();\n\tif(n % 2 &#x3D;&#x3D; 0) puts(&quot;0&quot;);\n\telse\n\t&#123;\n\t\tfor(int len &#x3D; 1; len &lt;&#x3D; n; len +&#x3D; 2)\n\t\t\tfor(int l &#x3D; 0; l + len - 1 &lt; n; l++)\n\t\t\t&#123;\n\t\t\t\tint r &#x3D; l + len - 1;\n\t\t\t\tif(len &#x3D;&#x3D; 1) f[l][r] &#x3D; 1;\n\t\t\t\telse if (str[l] &#x3D;&#x3D; str[r])\n\t\t\t\t&#123;&#x2F;&#x2F;子树划分决策&#123;(前part子问题f)*(最后一颗子树的f)&#125;求和\n\t\t\t\t\tfor(int k &#x3D; l; k &lt; r; k +&#x3D; 2)\n\t\t\t\t\t\tif(str[k] &#x3D;&#x3D; str[r])\n\t\t\t\t\t\t\tf[l][r] &#x3D; (f[l][r] + (LL)f[l][k] * f[k + 1][r - 1]) % mod;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\tcout &lt;&lt; f[0][n - 1] &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x54.树形DP\n&#x2F;&#x2F;没有上司的舞会\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 6010, INF &#x3D; 0x3f3f3f3f;\n\nint n;\nint h[N], e[N], w[N], ne[N], idx;\nint f[N][2];\nbool st[N];\n\nvoid add(int a, int b)\n&#123;\n\te[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid dfs(int u)\n&#123;\n\tf[u][1] &#x3D; w[u];\n\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])\n\t&#123;\n\t\tint j &#x3D; e[i];\n\t\tdfs(j);\n\t\tf[u][0] +&#x3D; max(f[j][0], f[j][1]);&#x2F;&#x2F;\n\t\tf[u][1] +&#x3D; f[j][0];&#x2F;&#x2F;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);&#x2F;&#x2F;happy值\n\tmemset(h, -1, sizeof h);\n\tfor (int i &#x3D; 0; i &lt; n - 1; i ++ )&#x2F;&#x2F;n-1条边\n\t&#123;\n\t\tint a, b;\n\t\tscanf(&quot;%d%d&quot;, &amp;a, &amp;b);\n\t\tadd(b, a);\n\t\tst[a] &#x3D; true;&#x2F;&#x2F;有父节点\n\t&#125;\n\n\tint root &#x3D; 1;\n\twhile (st[root]) root ++ ;\n\n\tdfs(root);\n\n\tprintf(&quot;%d\\n&quot;, max(f[root][0], f[root][1]));\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;背包类树形DP \n&#x2F;&#x2F;树形背包：必须选择父亲节点才能选择其子节点，求一定体积下的最大点权和\n&#x2F;&#x2F;选课\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 310;\n\nint n, m;\nint h[N], e[N], ne[N], idx;\nint w[N];\nint f[N][N];\n\nvoid add(int a, int b)\n&#123;\n\te[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid dfs(int u)\n&#123;\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])&#x2F;&#x2F;i !&#x3D; -1 子树&#x3D;&#x3D;物品组\n\t&#123;\n\t\tint son &#x3D; e[i];\n\t\tdfs(son);\n\t\t&#x2F;&#x2F;留出fa!!!\n\t\tfor (int j &#x3D; m - 1; j; j -- )&#x2F;&#x2F;先至多选m-1门\n\t\t\tfor (int k &#x3D; 1; k &lt;&#x3D; j; k ++ )\n\t\t\t\tf[u][j] &#x3D; max(f[u][j], f[u][j - k] + f[son][k]);&#x2F;&#x2F;idea同金字塔\n\t&#125;\n\t&#x2F;&#x2F;选上fa&#x3D;&#x3D;u  倒序:保证f[u][i - 1]没改\n\tfor (int i &#x3D; m; i; i -- ) f[u][i] &#x3D; f[u][i - 1] + w[u];\n\t&#x2F;&#x2F;f：自底向上维护！！！\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;&#x2F;&#x2F;n选m\n\n\tmemset(h, -1, sizeof h);&#x2F;&#x2F;init:-1\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tint father;\n\t\tcin &gt;&gt; father &gt;&gt; w[i];\n\t\tadd(father, i);\n\t&#125;\n\n\tm ++ ;&#x2F;&#x2F;虚拟root:0\n\tdfs(0);\n\n\tcout &lt;&lt; f[0][m] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;递归O(NMM)-&gt;可优化至O(NM)\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;5321&#x2F;\n&#x2F;&#x2F;树形背包DP:O(NM)\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;blackjack_&#x2F;article&#x2F;details&#x2F;77652426\n&#x2F;&#x2F;扩展题：ACWing 10. 有依赖的背包问题\n\n\n&#x2F;&#x2F;二次扫描与换根法\n&#x2F;&#x2F;积蓄程度  yxc\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 200010, M &#x3D; N * 2, INF &#x3D; 0x3f3f3f3f;\n\nint n;\nint h[N], e[M], w[M], ne[M], idx;\nint d[N], f[N], deg[N];\n\nvoid add(int x, int y, int z) \n&#123;\n\te[idx] &#x3D; y, w[idx] &#x3D; z, ne[idx] &#x3D; h[x], h[x] &#x3D; idx++;\n&#125;\n\nint dfs_d(int u, int fa)\n&#123;\n\tif (deg[u] &#x3D;&#x3D; 1)&#x2F;&#x2F;叶子结点\n\t&#123;\n\t\td[u] &#x3D; INF;&#x2F;&#x2F;向下流量无limit\n\t\treturn d[u];\n\t&#125;\n\n\td[u] &#x3D; 0;\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])\n\t&#123;\n\t\tint j &#x3D; e[i];\n\t\tif (j &#x3D;&#x3D; fa) continue;\n\t\td[u] +&#x3D; min(dfs_d(j, u), w[i]);\n\t&#125;\n\treturn d[u];\n&#125;\n\nvoid dfs_f(int u, int fa)\n&#123;\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])\n\t&#123;\n\t\tint j &#x3D; e[i];\n\t\tif (j &#x3D;&#x3D; fa) continue;\n\t\tif (deg[j] &#x3D;&#x3D; 1) f[j] &#x3D; min(w[i], f[u] - w[i]);\n\t\telse\n\t\t&#123;\n\t\t\tf[j] &#x3D; d[j] + min(f[u] - min(d[j], w[i]), w[i]);&#x2F;&#x2F;下+上\n\t\t\tdfs_f(j, u);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main() \n&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile (T--) \n\t&#123;\n\t\tcin &gt;&gt; n;\n\n\t\tmemset(h, -1, sizeof h);\n\t\tidx &#x3D; 0;\n\t\tmemset(deg, 0, sizeof deg); \n\n\t\tfor (int i &#x3D; 0; i &lt; n - 1; i++)\n\t\t&#123;\n\t\t\tint x, y, z;\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);\n\t\t\tadd(x, y, z), add(y, x, z);\n\t\t\tdeg[x]++, deg[y]++;\n\t\t&#125;\n&#x2F;*\n如果一开始跑dfs的是出海口，那么dp[u]为0，再减一个数字就变成负数了。\n所以选择一个度数大于1的节点作为根节点；如果所有点的度数均为1，说明是两点一边，特判。\n*&#x2F;\n\t\tint root &#x3D; 1;\n\t\twhile (root &lt;&#x3D; n &amp;&amp; deg[root] &#x3D;&#x3D; 1) root ++ ;\n\n\t\tif (root &gt; n)\n\t\t&#123;\n\t\t\tcout &lt;&lt; w[0] &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tdfs_d(root, -1);\n\n\t\tf[root] &#x3D; d[root];\n\t\tdfs_f(root, -1);\n\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) ans &#x3D; max(ans, f[i]);&#x2F;&#x2F;f_max\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;积蓄程度  标程版\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 200010, M &#x3D; N * 2;\n\nint d[N], v[N], f[N], deg[N];\nint head[N], ver[M], edge[M], Next[M];\nint n, T, tot, root, ans;\n\nvoid add(int x, int y, int z) &#123;\n\tver[++tot] &#x3D; y, edge[tot] &#x3D; z, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid dp(int x) &#123;\n\tv[x] &#x3D; 1; &#x2F;&#x2F; 访问标记\n\td[x] &#x3D; 0;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123; &#x2F;&#x2F; 邻接表存储\n\t\tint y &#x3D; ver[i];\n\t\tif (v[y]) continue;\n\t\tdp(y);\n\t\tif (deg[y] &#x3D;&#x3D; 1) d[x] +&#x3D; edge[i]; &#x2F;&#x2F; edge[i]保存c(x,y),等价于d[y]&#x3D;INF:需加特判\n\t\telse d[x] +&#x3D; min(d[y], edge[i]); \n\t&#125;\n&#125;\n\nvoid dfs(int x) &#123;\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (v[y]) continue;\n\t\tif (deg[x] &#x3D;&#x3D; 1) f[y] &#x3D; d[y] + edge[i];&#x2F;&#x2F;角度不同而已！\n\t\telse f[y] &#x3D; d[y] + min(f[x] - min(d[y], edge[i]), edge[i]);\n\t\tdfs(y);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; T;\n\twhile (T--) &#123;\n\t\ttot &#x3D; 1;\n\t\tcin &gt;&gt; n;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\thead[i] &#x3D; f[i] &#x3D; d[i] &#x3D; deg[i] &#x3D; v[i] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\t\tint x, y, z;\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);\n\t\t\tadd(x, y, z), add(y, x, z);\n\t\t\tdeg[x]++, deg[y]++;\n\t\t&#125;\n\t\tint root &#x3D; 1; &#x2F;&#x2F; 任选一个点为源点\n\t\tdp(root);&#x2F;&#x2F;--&gt;d\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) v[i] &#x3D; 0;\n\t\tf[root] &#x3D; d[root];\n\t\tdfs(root);&#x2F;&#x2F;换根 d--&gt;f\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tans &#x3D; max(ans, f[i]);&#x2F;&#x2F;f_max\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;0x55.环形DP\n&#x2F;&#x2F;休息时间 策略一:分情况\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 4000, INF &#x3D; 0x3f3f3f3f;\n\nint n, m;\nint f[2][N][2];&#x2F;&#x2F;i:滚动数组  滚起来:&amp; 1\nint w[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; w[i];\n\n\tmemset(f, -0x3f, sizeof f);\n\tf[1][0][0] &#x3D; f[1][1][1] &#x3D; 0;\n\t&#x2F;&#x2F; 第n小时不在睡觉\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; m; j ++ )\n\t\t&#123;\n\t\t\tf[i &amp; 1][j][0] &#x3D; max(f[i - 1 &amp; 1][j][0], f[i - 1 &amp; 1][j][1]);\n\t\t\tf[i &amp; 1][j][1] &#x3D; -INF;\n\t\t\tif (j) f[i &amp; 1][j][1] &#x3D; max(f[i - 1 &amp; 1][j - 1][0], f[i - 1 &amp; 1][j - 1][1] + w[i]);\n\t\t&#125;\n\n\tint res &#x3D; f[n &amp; 1][m][0];\n\n\t&#x2F;&#x2F; 第n小时在睡觉\n\tmemset(f, -0x3f, sizeof f);\n\tf[1][1][1] &#x3D; w[1];\n\tf[1][0][0] &#x3D; 0;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; m; j ++ )\n\t\t&#123;\n\t\t\tf[i &amp; 1][j][0] &#x3D; max(f[i - 1 &amp; 1][j][0], f[i - 1 &amp; 1][j][1]);\n\t\t\tf[i &amp; 1][j][1] &#x3D; -INF;\n\t\t\tif (j) f[i &amp; 1][j][1] &#x3D; max(f[i - 1 &amp; 1][j - 1][0], f[i - 1 &amp; 1][j - 1][1] + w[i]);\n\t\t&#125;\n\n\tres &#x3D; max(res, f[n &amp; 1][m][1]);\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;环路运输  策略二:破环成链\n&#x2F;&#x2F;转化为单调队列:滑动窗口求极值\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 2000010;\n\nint n;\nint w[N], q[N];&#x2F;&#x2F;库存 单调队列\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;w[i]);\n\t\tw[i + n] &#x3D; w[i];\n\t&#125;\n\n\tint res &#x3D; 0;\n\t&#x2F;&#x2F; 对于每个i, 寻找一个j, 使 i-j &lt;&#x3D; n&#x2F;2 且 Aj - j 最大\n\tint hh &#x3D; 0, tt &#x3D; -1;&#x2F;&#x2F;单调(递减)队列求max模板\n\tint len &#x3D; n &#x2F; 2;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n * 2; i ++ )\n\t&#123;\n\t\tif (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; i - len) hh ++ ;\n\t\tres &#x3D; max(res, i - q[hh] + w[q[hh]] + w[i]);&#x2F;&#x2F;q[hh] &#x3D;&#x3D; j   先求max\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; w[q[tt]] - q[tt] &lt;&#x3D; w[i] - i) tt -- ;\n\t\tq[ ++ tt] &#x3D; i;&#x2F;&#x2F;再加入\n\t&#125;\n\n\tprintf(&quot;%d\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;有后效性的状态转移方程\n&#x2F;&#x2F;坏掉的机器人  数学期望DP(倒推)套高斯消元\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nint n, m;\nint x, y;\ndouble f[N][N];\ndouble a[N][N];\n\nvoid gauss()\n&#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )&#x2F;&#x2F;每行非零:左中右末 留中&#x3D;&#x3D;1 末\n\t&#123;\n\t\tdouble r &#x3D; a[i][i];&#x2F;&#x2F;主元归一化\n\t\ta[i][i] &#x2F;&#x3D; r, a[i][i + 1] &#x2F;&#x3D; r;&#x2F;&#x2F;中右\n\t\tif(i &lt; m) a[i][m + 1] &#x2F;&#x3D; r;&#x2F;&#x2F;末\n\n\t\tdouble t &#x3D; a[i + 1][i];&#x2F;&#x2F;左\n\n\t\tint d[3] &#x3D; &#123;i, i + 1, m + 1&#125;;\n\t\tfor (int j &#x3D; 0; j &lt; 3; j ++ )\n\t\t\ta[i + 1][d[j]] -&#x3D; t * a[i][d[j]];&#x2F;&#x2F;消左:i+1行 -&#x3D; 左*(a[i][i]&#x3D;&#x3D;1)\n\t&#125;\n\n\tfor (int i &#x3D; m; i; i -- )&#x2F;&#x2F;自下向上: i-1行 -&#x3D; a[i - 1][i] * i行\n\t&#123;\n\t\ta[i - 1][m + 1] -&#x3D; a[i - 1][i] * a[i][m + 1];\n\t\ta[i - 1][i] -&#x3D; a[i - 1][i] * a[i][i];&#x2F;&#x2F;消右\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tcin &gt;&gt; x &gt;&gt; y;\n\n\tif (m &#x3D;&#x3D; 1) printf(&quot;%.4lf\\n&quot;, 2.0 * (n - x));\n\telse\n\t&#123;\n\t\tfor (int i &#x3D; n - 1; i &gt;&#x3D; x; i -- )&#x2F;&#x2F;1~n行 i+1\n\t\t&#123;\n\t\t\ta[1][1] &#x3D; 2.0 &#x2F; 3, a[1][2] &#x3D; -1.0 &#x2F; 3, a[1][m + 1] &#x3D; f[i + 1][1] &#x2F; 3 + 1;\n\t\t\ta[m][m] &#x3D; 2.0 &#x2F; 3, a[m][m - 1] &#x3D; -1.0 &#x2F; 3, a[m][m + 1] &#x3D; f[i + 1][m] &#x2F; 3 + 1;\n\t\t\tfor (int j &#x3D; 2; j &lt; m; j ++ )\n\t\t\t&#123;\n\t\t\t\ta[j][j - 1] &#x3D; -1.0 &#x2F; 4, a[j][j] &#x3D; 3.0 &#x2F; 4, a[j][j + 1] &#x3D; -1.0 &#x2F; 4;\n\t\t\t\ta[j][m + 1] &#x3D; f[i + 1][j] &#x2F; 4 + 1;\n\t\t\t&#125;\n\n\t\t\tgauss();\n\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) f[i][j] &#x3D; a[j][m + 1];&#x2F;&#x2F; 末&#x2F;(中&#x3D;&#x3D;1)\n\t\t&#125;\n\n\t\tprintf(&quot;%.4lf\\n&quot;, f[x][y]);\n\t\t&#x2F;&#x2F; cout.setf(std::ios::fixed);\n\t\t&#x2F;&#x2F; cout &lt;&lt; setprecision(4) &lt;&lt; f[x][y];\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;0x56.状压DP\n&#x2F;&#x2F;蒙德里安的梦想 yxc\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N &#x3D; 12, M &#x3D; 1 &lt;&lt; N;\n\nint n, m;\nLL f[N][M];\n&#x2F;&#x2F; vector&lt;int&gt; state[M];&#x2F;&#x2F;预处理\nbool st[M];&#x2F;&#x2F;是否合法\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m, n || m)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i ++ )\n\t\t&#123;\n\t\t\tint cnt &#x3D; 0;&#x2F;&#x2F;连续0的个数\n\t\t\tbool is_valid &#x3D; true;\n\t\t\tfor(int j &#x3D; 0; j &lt; n; j++)&#x2F;&#x2F;竖切 向右\n\t\t\t\tif(i &gt;&gt; j &amp; 1)&#x2F;&#x2F;遇1\n\t\t\t\t&#123;\n\t\t\t\t\tif(cnt &amp; 1)&#x2F;&#x2F;连续奇数个0\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tis_valid &#x3D; false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t\tcnt &#x3D; 0;\n\t\t\t\t&#125;\n\t\t\t\telse cnt ++;\n\t\t\tif(cnt &amp; 1) is_valid &#x3D; false;\n\t\t\tst[i] &#x3D; is_valid;\n\t\t&#125;\n&#x2F;&#x2F; \t\tfor (int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i ++ )\n&#x2F;&#x2F; \t\t&#123;\n&#x2F;&#x2F; \t\t\tstate[i].clear();\n&#x2F;&#x2F; \t\t\tfor (int j &#x3D; 0; j &lt; 1 &lt;&lt; n; j ++ )\n&#x2F;&#x2F; \t\t\t\tif ((i &amp; j) &#x3D;&#x3D; 0 &amp;&amp; st[i | j])\n&#x2F;&#x2F; \t\t\t\t\tstate[i].push_back(j);\n&#x2F;&#x2F; \t\t&#125;\n\n\t\tmemset(f, 0, sizeof f);\n\t\tf[0][0] &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t\t\tfor (int j &#x3D; 0; j &lt; 1 &lt;&lt; n; j ++ )\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 1 &lt;&lt; n; k ++ )&#x2F;&#x2F;\n\t\t\t\t\tif ((j &amp; k) &#x3D;&#x3D; 0 &amp;&amp; st[j | k])&#x2F;&#x2F;\n\t\t\t\t&#x2F;&#x2F; for (auto k : state[j])\n\t\t\t\t\t\tf[i][j] +&#x3D; f[i - 1][k];\n\n\t\tcout &lt;&lt; f[m][0] &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;标程版\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\nusing namespace std;\nint n, m;\nlong long f[12][1 &lt;&lt; 11];&#x2F;&#x2F;LL\nbool in_s[1 &lt;&lt; 11];\n\nint main()  &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;\n\t\tfor (int i &#x3D; 0; i &lt; 1 &lt;&lt; m; i++) &#123;\n\t\t\tbool cnt &#x3D; 0, has_odd &#x3D; 0;\n\t\t\tfor (int j &#x3D; 0; j &lt; m; j++)\n\t\t\t\tif (i &gt;&gt; j &amp; 1) has_odd |&#x3D; cnt, cnt &#x3D; 0;&#x2F;&#x2F;\n\t\t\t\telse cnt ^&#x3D; 1;&#x2F;&#x2F;\n\t\t\tin_s[i] &#x3D; has_odd | cnt ? 0 : 1;&#x2F;&#x2F;\n\t\t&#125;\n\t\tf[0][0] &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt; 1 &lt;&lt; m; j++) &#123;\n\t\t\t\tf[i][j] &#x3D; 0;\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 1 &lt;&lt; m; k++)\n\t\t\t\t\tif ((j&amp;k) &#x3D;&#x3D; 0 &amp;&amp; in_s[j | k])&#x2F;&#x2F;\n\t\t\t\t\t\tf[i][j] +&#x3D; f[i - 1][k];\n\t\t\t&#125;\n\t\tcout &lt;&lt; f[n][0] &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;炮兵阵地\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110, M &#x3D; 10, S &#x3D; 1 &lt;&lt; M;\n\nint n, m;\nint g[N];\nint f[2][S][S];\nvector&lt;int&gt; state;\nint cnt[S];\n\nbool check(int s)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; m; i ++ )\n\t\tif ((s &gt;&gt; i &amp; 1) &amp;&amp; ((s &gt;&gt; i + 1 &amp; 1) || (s &gt;&gt; i + 2 &amp; 1)))\n\t\t\treturn false;&#x2F;&#x2F;两个1距离&lt;3\n\treturn true;\n&#125;\n\nint count(int s)&#x2F;&#x2F;1的个数\n&#123;\n\tint res &#x3D; 0;\n\twhile (s)\n\t&#123;\n\t\tres +&#x3D; s &amp; 1;\n\t\ts &gt;&gt;&#x3D; 1;\n\t&#125;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; m; j ++ )\n\t\t&#123;\n\t\t\tchar c;\n\t\t\tcin &gt;&gt; c;\n\t\t\tif (c &#x3D;&#x3D; &#39;H&#39;) g[i] +&#x3D; 1 &lt;&lt; j;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;预处理\n\tfor (int i &#x3D; 0; i &lt; 1 &lt;&lt; m; i ++ )\n\t\tif (check(i))\n\t\t&#123;\n\t\t\tstate.push_back(i);\n\t\t\tcnt[i] &#x3D; count(i);\n\t\t&#125;\n\n\tfor (int i &#x3D; 0; i &lt; n + 2; i ++ )&#x2F;&#x2F;0~n-1 n行n+1行全0\n\t\tfor (int j &#x3D; 0; j &lt; state.size(); j ++ )\n\t\t\tfor (int k &#x3D; 0; k &lt; state.size(); k ++ )\n\t\t\t\tfor (int u &#x3D; 0; u &lt; state.size(); u ++ )\n\t\t\t\t&#123;\n\t\t\t\t\tint a &#x3D; state[u], b &#x3D; state[j], c &#x3D; state[k];&#x2F;&#x2F;ujk\n\t\t\t\t\tif ((a &amp; b) || (a &amp; c) || (b &amp; c)) continue;&#x2F;&#x2F;没错开\n\t\t\t\t\tif (g[i] &amp; c) continue;&#x2F;&#x2F;H&amp;炮兵 &#x3D;&#x3D; 1（存在炮兵站在山地上）\n\t\t\t\t\tf[i &amp; 1][j][k] &#x3D; max(f[i &amp; 1][j][k], f[i - 1 &amp; 1][u][j] + cnt[c]);\n\t\t\t\t&#125;\n\n\tcout &lt;&lt; f[n + 1 &amp; 1][0][0] &lt;&lt; endl;&#x2F;&#x2F;n行n+1行全0\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;宝藏\n\n&#x2F;&#x2F;0x57.倍增优化DP\n&#x2F;&#x2F;开车旅行\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;LL, int&gt; PLI;\n\nconst int N &#x3D; 100010, M &#x3D; 17;&#x2F;&#x2F;(1&lt;&lt; M-1) &lt; N\nconst LL INF &#x3D; 1e12;\n\nint n;\nint h[N];\nint ga[N], gb[N];\nint f[M][N][2];\nLL da[M][N][2], db[M][N][2];\n\nvoid init_g()\n&#123;\n\tset&lt;PLI&gt; S;&#x2F;&#x2F;有序集合\n\tS.insert(&#123;INF, 0&#125;), S.insert(&#123;INF + 1, 0&#125;);&#x2F;&#x2F;val,index set:val不等\n\tS.insert(&#123;-INF, 0&#125;), S.insert(&#123;-INF - 1, 0&#125;);\n\n\tfor (int i &#x3D; n; i; i -- )\n\t&#123;\n\t\tPLI t(h[i], i);\n\t\tauto j &#x3D; S.lower_bound(t);&#x2F;&#x2F;&gt;&#x3D;t的min: 3\n\t\tj ++ ;&#x2F;&#x2F;4\n\t\tvector&lt;PLI&gt; cand;\n\t\tfor (int k &#x3D; 0; k &lt; 4; k ++ )\n\t\t&#123;\n\t\t\tcand.push_back(*j);&#x2F;&#x2F;迭代器取val j&#x3D;4321递减\n\t\t\tj -- ;\n\t\t&#125;\n\t\tLL d1 &#x3D; INF, d2 &#x3D; INF;&#x2F;&#x2F;最小次小val\n\t\tint p1 &#x3D; 0, p2 &#x3D; 0;&#x2F;&#x2F;最小次小index\n\t\tfor (int k &#x3D; 3; k &gt;&#x3D; 0; k -- )\n\t\t&#123;\n\t\t\tLL d &#x3D; abs(h[i] - cand[k].first);&#x2F;&#x2F;d&#x3D;abs(hi-hj)\n\t\t\tif (d &lt; d1)&#x2F;&#x2F;!!!\n\t\t\t&#123;\n\t\t\t\td2 &#x3D; d1, d1 &#x3D; d;\n\t\t\t\tp2 &#x3D; p1, p1 &#x3D; cand[k].second;\n\t\t\t&#125;\n\t\t\telse if (d &lt; d2)&#x2F;&#x2F;!!!\n\t\t\t&#123;\n\t\t\t\td2 &#x3D; d;\n\t\t\t\tp2 &#x3D; cand[k].second;\n\t\t\t&#125;\n\t\t&#125;\n\t\tga[i] &#x3D; p2, gb[i] &#x3D; p1;&#x2F;&#x2F;a次小 b最小\n\n\t\tS.insert(t);\n\t&#125;\n&#125;\n\nvoid init_f()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; M; i ++ )\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n\t\t&#123;\n\t\t\tif (!i) f[0][j][0] &#x3D; ga[j], f[0][j][1] &#x3D; gb[j];\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 2; k ++ )\n\t\t\t\t&#123;\n\t\t\t\t\tif (i &#x3D;&#x3D; 1) f[1][j][k] &#x3D; f[0][f[0][j][k]][1 - k];\n\t\t\t\t\telse f[i][j][k] &#x3D; f[i - 1][f[i - 1][j][k]][k];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n\nint get_dist(int a, int b)\n&#123;\n\treturn abs(h[a] - h[b]);\n&#125;\n\nvoid init_d()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; M; i ++ )\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n\t\t&#123;\n\t\t\tif (!i)\n\t\t\t&#123;\n\t\t\t\tda[0][j][0] &#x3D; get_dist(j, ga[j]), da[0][j][1] &#x3D; 0;\n\t\t\t\tdb[0][j][1] &#x3D; get_dist(j, gb[j]), db[0][j][0] &#x3D; 0;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 2; k ++ )\n\t\t\t\t&#123;\n\t\t\t\t\tif (i &#x3D;&#x3D; 1)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tda[1][j][k] &#x3D; da[0][j][k] + da[0][f[0][j][k]][1 - k];\n\t\t\t\t\t\tdb[1][j][k] &#x3D; db[0][j][k] + db[0][f[0][j][k]][1 - k];\n\t\t\t\t\t&#125;\n\t\t\t\t\telse\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tda[i][j][k] &#x3D; da[i - 1][j][k] + da[i - 1][f[i - 1][j][k]][k];\n\t\t\t\t\t\tdb[i][j][k] &#x3D; db[i - 1][j][k] + db[i - 1][f[i - 1][j][k]][k];\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n\nvoid calc(int p, int x, int &amp;la, int &amp;lb)&#x2F;&#x2F;st:p 最多走x\n&#123;\n\tla &#x3D; lb &#x3D; 0;&#x2F;&#x2F;累计行驶路程\n\tfor (int i &#x3D; M - 1; i &gt;&#x3D; 0; i -- )&#x2F;&#x2F;递减倍增 &lt;&#x3D;x就更新\n\t\tif (f[i][p][0] &amp;&amp; la + lb + da[i][p][0] + db[i][p][0] &lt;&#x3D; x)\n\t\t&#123;\n\t\t\tla +&#x3D; da[i][p][0], lb +&#x3D; db[i][p][0];\n\t\t\tp &#x3D; f[i][p][0];\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]);\n\n\tinit_g();&#x2F;&#x2F;next_city\n\tinit_f();\n\tinit_d();\n\n\tint p, x;\n\tscanf(&quot;%d&quot;, &amp;x);\n\tint res &#x3D; 0, max_h &#x3D; 0;\n\tdouble min_ratio &#x3D; INF;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tint la, lb;\n\t\tcalc(i, x, la, lb);\n\t\tdouble ratio &#x3D; lb ? (double)la &#x2F; lb : INF;&#x2F;&#x2F;\n\t\tif (ratio &lt; min_ratio || ratio &#x3D;&#x3D; min_ratio &amp;&amp; h[i] &gt; max_h)&#x2F;&#x2F;\n\t\t&#123;\n\t\t\tmin_ratio &#x3D; ratio;\n\t\t\tmax_h &#x3D; h[i];\n\t\t\tres &#x3D; i;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, res);\n\n\tint m;\n\tscanf(&quot;%d&quot;, &amp;m);\n\twhile (m -- )\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;p, &amp;x);&#x2F;&#x2F;st:p &lt;&#x3D;x\n\t\tint la, lb;\n\t\tcalc(p, x, la, lb);\n\t\tprintf(&quot;%d %d\\n&quot;, la, lb);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;计算重复\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N &#x3D; 110, M &#x3D; 31;&#x2F;&#x2F;0~30\n\nint n1, n2;\nstring s1, s2;\nLL f[N][M];\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; s2 &gt;&gt; n2 &gt;&gt; s1 &gt;&gt; n1)\n\t&#123;\n\t\tbool fail &#x3D; false;\n\n\t\tint sz &#x3D; s1.size();\n\t\tfor (int i &#x3D; 0; i &lt; sz; i ++ )\n\t\t&#123;\n\t\t\tint p &#x3D; i;\n\t\t\tf[i][0] &#x3D; 0;\n\t\t\tfor (int j &#x3D; 0; j &lt; s2.size(); j ++ )\n\t\t\t&#123;\n\t\t\t\tint cnt &#x3D; 0;\n\t\t\t\twhile (s1[p] !&#x3D; s2[j])  &#x2F;&#x2F; 找到下一个s2[j]\n\t\t\t\t&#123;\n\t\t\t\t\tp &#x3D; (p + 1) % sz;\n\t\t\t\t\tif (++cnt &gt;&#x3D; sz)&#x2F;&#x2F; 无解\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tfail &#x3D; true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tif (fail) break;\n\t\t\t\tp &#x3D; (p + 1) % sz;\n\t\t\t\tf[i][0] +&#x3D; cnt + 1;&#x2F;&#x2F; 初值\n\t\t\t&#125;\n\t\t\tif (fail) break;\n\t\t&#125;\n\n\t\tif (fail)&#x2F;&#x2F; 多组数据\n\t\t&#123;\n\t\t\tcout &lt;&lt; 0 &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 预处理\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; 30; j ++ )\n\t\t\tfor (int i &#x3D; 0; i &lt; sz; i ++ )\n\t\t\t\tf[i][j] &#x3D; f[i][j - 1] + f[(i + f[i][j - 1]) % sz][j - 1];\n\n\t\t&#x2F;&#x2F; 拼凑\n\t\tLL res &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; sz; i ++ )\n\t\t&#123;\n\t\t\tLL p &#x3D; i, t &#x3D; 0;&#x2F;&#x2F;st:p t&#x3D;(2^k)求和\n\t\t\tfor (int k &#x3D; 30; k &gt;&#x3D; 0; k -- )\n\t\t\t\tif (p + f[p % sz][k] &lt;&#x3D; sz * n1)\n\t\t\t\t&#123;\n\t\t\t\t\tp +&#x3D; f[p % sz][k];\n\t\t\t\t\tt +&#x3D; 1 &lt;&lt; k;\n\t\t\t\t&#125;\n\t\t\tres &#x3D; max(res, t);&#x2F;&#x2F;m&#39;&#x3D;max_t\n\t\t&#125;\n\n\t\tcout &lt;&lt; res &#x2F; n2 &lt;&lt; endl;&#x2F;&#x2F;m&#x3D;m&#39;&#x2F;n2\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;AcWing907.区间覆盖  贪心\n\n&#x2F;&#x2F;0x58.ds优化DP\n&#x2F;&#x2F;清理班次 \n&#x2F;&#x2F;(可贪心做: sort+scan)\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 1000001;\nint n, m, p &#x3D; 1, ans &#x3D; 0, nxt[N];\nint main() &#123;\n\tscanf(&quot;%d%d&quot;, &amp;m, &amp;n);\n\tfor (int i &#x3D; 0, l, r; i &lt; m; i++) \n\t\tscanf(&quot;%d%d&quot;, &amp;l, &amp;r), nxt[l] &#x3D; max(nxt[l], r);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) nxt[i] &#x3D; max(nxt[i], nxt[i - 1]);\n\twhile(p &lt;&#x3D; n &amp;&amp; nxt[p] &gt;&#x3D; p) p &#x3D; nxt[p] + 1, ans++;\n\tprintf(&quot;%d\\n&quot;, p &lt;&#x3D; n ? -1 : ans);\n\treturn 0;\n&#125;\n&#x2F;*\n作者：墨染空\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;6640&#x2F;\n来源：AcWing\n*&#x2F;\n\n&#x2F;&#x2F;法2：SegTree优化DP\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 25010, T &#x3D; 1000010, INF &#x3D; 1e8;\n\nint n, m;\nstruct Range\n&#123;\n\tint l, r;\n\tbool operator&lt; (const Range &amp;t)const\n\t&#123;\n\t\treturn r &lt; t.r;&#x2F;&#x2F;右端点递增\n\t&#125;\n&#125;range[N];\n\nstruct Node\n&#123;\n\tint l, r, v;\n&#125;tr[T * 4];\n\nvoid build(int u, int l, int r)&#x2F;&#x2F;node_u:[l,r]\n&#123;\n\ttr[u] &#x3D; &#123;l, r, INF&#125;;&#x2F;&#x2F;new_node\n\tif (l &#x3D;&#x3D; r) return;\n\tint mid &#x3D; l + r &gt;&gt; 1;\n\tbuild(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n&#125;\n\nvoid pushup(int u)&#x2F;&#x2F;子info更新父info:min_v\n&#123;\n\ttr[u].v &#x3D; min(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);\n&#125;\n\nvoid update(int u, int k, int v)&#x2F;&#x2F;k&#x3D;&#x3D;r 1~r\n&#123;\n\tif (tr[u].l &#x3D;&#x3D; tr[u].r)\n\t&#123;\n\t\ttr[u].v &#x3D; min(tr[u].v, v);\n\t\treturn;\n\t&#125;\n\tint mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n\tif (k &lt;&#x3D; mid) update(u &lt;&lt; 1, k, v);\n\telse update(u &lt;&lt; 1 | 1, k, v);\n\tpushup(u);&#x2F;&#x2F;向上更新min_v\n&#125;\n\nint query(int u, int l, int r)\n&#123;\n\tif (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].v;\n\tint mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n\tint res &#x3D; INF;\n\tif (l &lt;&#x3D; mid) res &#x3D; query(u &lt;&lt; 1, l, r);\n\tif (r &gt; mid) res &#x3D; min(res, query(u &lt;&lt; 1 | 1, l, r));\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tbuild(1, 0, m);&#x2F;&#x2F;node_u:[0,m]\n\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d%d&quot;, &amp;range[i].l, &amp;range[i].r);\n\tsort(range, range + n);\n\n\tupdate(1, 0, 0);&#x2F;&#x2F;f[0]&#x3D;0\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint l &#x3D; range[i].l, r &#x3D; range[i].r;\n\t\tint v &#x3D; query(1, l - 1, r - 1) + 1;  &#x2F;&#x2F; f[r]&#x3D;min_v[l-1,r) + 1\n\t\tupdate(1, r, v);&#x2F;&#x2F;更新f[r]\n\t&#125;\n\n\tint res &#x3D; query(1, m, m);&#x2F;&#x2F;右端点range[l,r]&#x3D;&#x3D;m f[m]\n\tif (res &#x3D;&#x3D; INF) res &#x3D; -1;\n\n\tprintf(&quot;%d\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;清理班次2\t\tDP法易扩展\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N &#x3D; 10010, M &#x3D; 90000;\nconst LL INF &#x3D; 1e15;&#x2F;&#x2F;&gt;500000*10000\n\nint n, m, e;&#x2F;&#x2F;[m,e]\nstruct Range\n&#123;\n\tint l, r, w;\n\tbool operator&lt; (const Range &amp;t) const\n\t&#123;\n\t\treturn r &lt; t.r;\n\t&#125;\n&#125;range[N];\n\nstruct Node\n&#123;\n\tint l, r;\n\tLL v;\n&#125;tr[M * 4];\n\nvoid pushup(int u)\n&#123;\n\ttr[u].v &#x3D; min(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);\n&#125;\n\nvoid build(int u, int l, int r)\n&#123;\n\ttr[u] &#x3D; &#123;l, r, INF&#125;;\n\tif (l &#x3D;&#x3D; r) return;\n\tint mid &#x3D; l + r &gt;&gt; 1;\n\tbuild(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n&#125;\n\nvoid update(int u, int k, LL v)&#x2F;&#x2F;[l,k]\n&#123;\n\tif (tr[u].l &#x3D;&#x3D; tr[u].r)\n\t&#123;\n\t\ttr[u].v &#x3D; min(tr[u].v, v);\n\t\treturn;\n\t&#125;\n\n\tint mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n\tif (k &lt;&#x3D; mid) update(u &lt;&lt; 1, k, v);\n\telse update(u &lt;&lt; 1 | 1, k, v);\n\tpushup(u);\n&#125;\n\nLL query(int u, int l, int r)\n&#123;\n\tif (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].v;\n\n\tint mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n\tLL res &#x3D; INF;\n\tif (l &lt;&#x3D; mid) res &#x3D; query(u &lt;&lt; 1, l, r);\n\tif (r &gt; mid) res &#x3D; min(res, query(u &lt;&lt; 1 | 1, l, r));\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e);\n\tbuild(1, m - 1, e);&#x2F;&#x2F;[m-1,e] 决定了min_v&#x3D;f[m-1,x]！！！\n\tupdate(1, m - 1, 0);&#x2F;&#x2F;f[m-1]&#x3D;0\n\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint l, r, w;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;w);\n\t\trange[i] &#x3D; &#123;l, r, w&#125;;\n\t&#125;\n\n\tsort(range, range + n);\n\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint l &#x3D; range[i].l, r &#x3D; range[i].r, w &#x3D; range[i].w;\n\t\tLL v &#x3D; query(1, l - 1, r - 1) + w;  &#x2F;&#x2F; f[r]\n\t\tupdate(1, r, v);  &#x2F;&#x2F; f[r]&#x3D;v\n\t&#125;\n\n\tLL res &#x3D; query(1, e, e);&#x2F;&#x2F;f[e]&#x3D;&#x3D;f[m-1,e] 由build+update决定!\n\tif (res &#x3D;&#x3D; INF) res &#x3D; -1;\n\n\tprintf(&quot;%lld\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;赤壁之战:给定一个长度为N的序列A，求A有多少个长度为M的严格递增子序列seq。\n&#x2F;*\n&#x2F;&#x2F; f[i,j] &#x3D; sum(f[k,j-1])\t其中1&lt;&#x3D;k&lt;i, Ak&lt;Ai \t\tf[ed,len]\nfor (int i &#x3D; 1; i &lt;&#x3D; n ; i ++ )\n\tfor (int j &#x3D; 2; j &lt;&#x3D; m ; j ++ )&#x2F;&#x2F;f[i,1]&#x3D;1\n\t\tfor (int k &#x3D; 1; k &lt; i ; k ++ )\n\t\t\tif(a[k] &lt; a[i])\n\t\t\t\tf[i][j] +&#x3D; f[k][j - 1];\n&#x2F;&#x2F;(优化)单点增加,区间查询：splay难实现, 用离散化+树状数组\n&#x2F;&#x2F;改变循环顺序: ijk(会有n棵树状数组) ---&gt; jik(j~j-1)一棵\n*&#x2F;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010, mod &#x3D; 1e9 + 7;\n\nint n, m;\nint a[N];\nint nums[N], cnt;&#x2F;&#x2F;离散化后\nint tr[N];&#x2F;&#x2F;树状数组\nint f[N][N];&#x2F;&#x2F;f[ed,len]:以ed结尾且包含len个数的seq个数\n\nint lowbit(int x)\n&#123;\n\treturn x &amp; -x;\n&#125;\n\nvoid add(int x, int v)\n&#123;\n\tfor (int i &#x3D; x; i &lt;&#x3D; cnt ; i +&#x3D; lowbit(i))&#x2F;&#x2F;向上\n\t\ttr[i] &#x3D; (tr[i] + v) % mod;\n&#125;\n\nint sum(int x)\n&#123;\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; x; i; i -&#x3D; lowbit(i))&#x2F;&#x2F;向左\n\t\tres &#x3D; (res + tr[i]) % mod;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\tfor (int C &#x3D; 1; C &lt;&#x3D; T; C ++ )\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\t\tcnt &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;a[i]);\n\t\t\tnums[cnt ++ ] &#x3D; a[i];\n\t\t&#125;\n\t\tsort(nums, nums + cnt);\n\t\tcnt &#x3D; unique(nums, nums + cnt) - nums;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) \n\t\t\ta[i] &#x3D; lower_bound(nums, nums + cnt, a[i]) - nums + 1;&#x2F;&#x2F;tr_arr[1)\n\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) f[i][1] &#x3D; 1;&#x2F;&#x2F;init\n\t\tfor (int j &#x3D; 2; j &lt;&#x3D; m; j ++ )&#x2F;&#x2F;len\n\t\t&#123;\n\t\t\tfor (int i &#x3D; 1; i &lt;&#x3D; cnt; i ++ ) tr[i] &#x3D; 0;\n\t\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F;ed\n\t\t\t&#123;\n\t\t\t\tf[i][j] &#x3D; sum(a[i] - 1);&#x2F;&#x2F;Q前缀和\n\t\t\t\tadd(a[i], f[i][j - 1]);&#x2F;&#x2F;加入新决策Ai二元组 f[ed,len]\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tint res &#x3D; 0;&#x2F;&#x2F; 不同ed的(len&#x3D;&#x3D;m)seq数求和\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) res &#x3D; (res + f[i][m]) % mod;\n\n\t\tprintf(&quot;Case #%d: %d\\n&quot;, C, res);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x59.单调队列优化DP  （可求解:多重背包问题 见bag_nine）\n&#x2F;&#x2F;围栏 yxc\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 16010, M &#x3D; 110;\n\nint n, m;\nint q[N];\nint f[M][N];\n\nstruct Carpenter\n&#123;\n\tint l, p, s;\n\tbool operator&lt; (const Carpenter&amp; t) const\n\t&#123;\n\t\treturn s &lt; t.s;\n\t&#125;\n&#125;car[M];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) cin &gt;&gt; car[i].l &gt;&gt; car[i].p &gt;&gt; car[i].s;\n\tsort(car + 1, car + m + 1);\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )&#x2F;&#x2F;人\n\t&#123;\n\t\tint hh &#x3D; 0, tt &#x3D; -1;\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; n; j ++ )&#x2F;&#x2F;板\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 不刷k+1~j板时的转移\n\t\t\tf[i][j] &#x3D; f[i - 1][j];\n\t\t\tif (j) f[i][j] &#x3D; max(f[i][j], f[i][j - 1]);&#x2F;&#x2F;j&gt;&#x3D;1\n\t\t\t&#x2F;&#x2F; 刷k+1~j板时的转移\n\t\t\tint l &#x3D; car[i].l, p &#x3D; car[i].p, s &#x3D; car[i].s;\n\t\t\tif (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; j - l) hh ++ ;&#x2F;&#x2F;更新队头\n\t\t\tif (j &gt;&#x3D; s &amp;&amp; hh &lt;&#x3D; tt)&#x2F;&#x2F;队列非空，j &gt;&#x3D; s取队头转移\n\t\t\t&#123;\n\t\t\t\tint k &#x3D; q[hh];&#x2F;&#x2F;q[hh]&#x3D;&#x3D;区间max\n\t\t\t\tf[i][j] &#x3D; max(f[i][j], f[i - 1][k] + (j - k) * p);\n\t\t\t&#125;\n\n\t\t\tif (j &lt; s)&#x2F;&#x2F;j &lt; s入队\n\t\t\t&#123;\n\t\t\t\twhile (hh &lt;&#x3D; tt &amp;&amp; f[i - 1][q[tt]] - q[tt] * p &lt;&#x3D; f[i - 1][j] - j * p) tt -- ;&#x2F;&#x2F;while(&gt;队尾元素) 删队尾\n\t\t\t\tq[ ++ tt] &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; f[m][n] &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;标程版\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\nstruct rec&#123; int L, P, S; &#125; a[110];\nint n, m;\nint f[110][16010], q[16010];\n\nbool operator &lt;(rec a, rec b) &#123;\n\treturn a.S &lt; b.S;\n&#125;\n\nint calc(int i, int k) &#123;\n\treturn f[i - 1][k] - a[i].P * k;\n&#125;\n\nint main()  &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tscanf(&quot;%d%d%d&quot;, &amp;a[i].L, &amp;a[i].P, &amp;a[i].S);&#x2F;&#x2F;&lt;&#x3D;len 报酬 含s\n\tsort(a + 1, a + m + 1);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\t&#x2F;&#x2F; 初始化单调队列\n\t\tint l &#x3D; 1, r &#x3D; 0;\n\t\t&#x2F;&#x2F; 把最初的候选集合插入队列\n\t\tfor (int k &#x3D; max(0, a[i].S - a[i].L); k &lt;&#x3D; a[i].S - 1; k++) &#123;\n\t\t\t&#x2F;&#x2F; 插入新决策，维护队尾单调性\n\t\t\twhile (l &lt;&#x3D; r &amp;&amp; calc(i, q[r]) &lt;&#x3D; calc(i, k)) r--;\n\t\t\tq[++r] &#x3D; k;\n\t\t&#125;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\t&#x2F;&#x2F; 不粉刷时的转移\n\t\t\tf[i][j] &#x3D; max(f[i - 1][j], f[i][j - 1]);\n\t\t\t&#x2F;&#x2F; 粉刷第k+1~j块木板时的转移\n\t\t\tif (j &gt;&#x3D; a[i].S) &#123;\n\t\t\t\t&#x2F;&#x2F; 排除队头不合法决策\n\t\t\t\twhile (l &lt;&#x3D; r &amp;&amp; q[l] &lt; j - a[i].L) l++;\n\t\t\t\t&#x2F;&#x2F; 队列非空时，取队头进行状态转移\n\t\t\t\tif (l &lt;&#x3D; r) f[i][j] &#x3D; max(f[i][j], calc(i, q[l]) + a[i].P * j);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; f[m][n] &lt;&lt; endl;\n&#125;\n\n&#x2F;*\n#include &lt;queue&gt;\nbool st[N];&#x2F;&#x2F;priority_queue无删除，懒标记:pop到st&#x3D;&#x3D;false的top为止 \npriority_queue&lt;PLI, vector&lt;PLI&gt;, greater&lt;PLI&gt;&gt; heap;&#x2F;&#x2F;不支持修改\n改用\nmultiset:有序多重集，RB-Tree\n*&#x2F;\n&#x2F;&#x2F;裁剪序列\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n \nconst int N &#x3D; 100010;\n\nint n;\nLL m;\nint a[N], q[N];\nLL f[N];\n\nmultiset&lt;LL&gt; S;\n\nvoid remove(LL x)\n&#123;\n\tauto it &#x3D; S.find(x);\n\tS.erase(it);&#x2F;&#x2F;只删一个\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%lld&quot;, &amp;n, &amp;m);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;a[i]);\n\t\tif (a[i] &gt; m)\n\t\t&#123;\n\t\t\tputs(&quot;-1&quot;);\n\t\t\treturn 0;\n\t\t&#125;\n\t&#125;\n\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\tLL sum &#x3D; 0;\n\n\tfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F; [j,i]段\n\t&#123;\n\t\tsum +&#x3D; a[i];\n\t\twhile (sum &gt; m) sum -&#x3D; a[ ++ j];&#x2F;&#x2F; sum&lt;&#x3D;m --&gt; 更新j\n&#x2F;*\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; j) h++;\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) tt -- ;\n\t\tq[++tt] &#x3D; i;\n\t\t\n\t\tf[i] &#x3D; f[j] + a[q[hh]];\n\t\tfor(int k &#x3D; hh; k &lt;&#x3D; tt; k++) f[i] &#x3D; min(f[i], f[q[k]] + a[q[k + 1]]);\n*&#x2F;\n\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; j) \n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 多于一个元素(hh+1存在):才在堆S中删hh\n\t\t\tif(hh &lt; tt) remove(f[q[hh]] + a[q[hh + 1]]);\n\t\t\thh++;\n\t\t&#125;\n\t\tint tail &#x3D; tt;\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) \n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 堆S不含q的最后一个元素q[tail]...\n\t\t\tif(tt !&#x3D; tail) remove(f[q[tt]] + a[q[tt + 1]]);\n\t\t\ttt -- ;\n\t\t&#125;\n\t\t&#x2F;&#x2F; tt存在 且 tt被更新过，在堆S中删tt...(s不含q[tt]...)！！！\n\t\tif(hh &lt;&#x3D; tt &amp;&amp; tt !&#x3D; tail) remove(f[q[tt]] + a[q[tt + 1]]);\n\t\tq[++tt] &#x3D; i;\n\t\t&#x2F;&#x2F; q有&gt;1个元素,tt-1...入堆S！！！\n\t\tif(hh &lt; tt) S.insert(f[q[tt - 1]] + a[q[tt]]);\n\t\t\n\t\tf[i] &#x3D; f[j] + a[q[hh]];\n\t\tif (S.size()) f[i] &#x3D; min(f[i], *S.begin());&#x2F;&#x2F;堆头\n\t&#125;\n\n\tprintf(&quot;%lld\\n&quot;, f[n]);\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;0x5A.斜率优化DP\n&#x2F;&#x2F;任务安排1\n&#x2F;&#x2F; 法1: 前i个任务分j批\n&#x2F;&#x2F; f[i][j] &#x3D; min(f[i][j], f[k][j-1] + (s * j + st[i]) * (sc[i] - sc[k]));\n&#x2F;&#x2F; 法2：； 若干批，后续影响提前计算\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 5006;\nint n, s;\nll f[N], st[N], sc[N];\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; s;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%lld %lld&quot;, &amp;st[i], &amp;sc[i]);\n\t\tst[i] +&#x3D; st[i-1];\n\t\tsc[i] +&#x3D; sc[i-1];\n\t&#125;\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; i; j++)\n\t\t\tf[i] &#x3D; min(f[i], f[j] + st[i] * (sc[i] - sc[j]) + s * (sc[n] - sc[j]));&#x2F;&#x2F;\n\tcout &lt;&lt; f[n] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;任务安排2 data增强:斜率优化 Ci,Ti非负\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;string&gt;\nusing namespace std;\nlong long f[300010], sumt[300010], sumc[300010];\nint q[300010], n, s;\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; s;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint t, c;\n\t\tscanf(&quot;%d%d&quot;, &amp;t, &amp;c);\n\t\tsumt[i] &#x3D; sumt[i - 1] + t;\n\t\tsumc[i] &#x3D; sumc[i - 1] + c;\n\t&#125;\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] &#x3D; 0;\n\tint l &#x3D; 1, r &#x3D; 1;\n\tq[1] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\twhile (l &lt; r &amp;&amp; (f[q[l + 1]] - f[q[l]]) \n\t\t\t&lt;&#x3D; (s + sumt[i]) * (sumc[q[l + 1]] - sumc[q[l]])) l++;\n\t\tf[i] &#x3D; f[q[l]] - (s + sumt[i]) * sumc[q[l]]\n\t\t\t+ sumt[i] * sumc[i] + s * sumc[n];\n\t\twhile (l &lt; r &amp;&amp; (f[q[r]] - f[q[r - 1]]) * (sumc[i] - sumc[q[r]])\n\t\t\t&gt;&#x3D; (f[i] - f[q[r]]) * (sumc[q[r]] - sumc[q[r - 1]])) r--;\n\t\tq[++r] &#x3D; i;\n\t&#125;\n\tcout &lt;&lt; f[n] &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;WA!!!!!!\n&#x2F;&#x2F;任务安排3 Ti可负：不去队头，二分搜索【&gt;&#x3D;k的min斜率】的pos\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nlong long sumt[300010], sumc[300010], f[300010];\nint q[300010], n, s, l, r;\n\nint binary_search(int i, int k)\n&#123;\n\tif (l &#x3D;&#x3D; r) return q[l];\n\tint L &#x3D; l, R &#x3D; r;\n\twhile (L &lt; R)\n\t&#123;\n\t\tint mid &#x3D; (L + R) &gt;&gt; 1;\n\t\tif (f[q[mid + 1]] - f[q[mid]] &lt;&#x3D; k *\n\t\t\t(sumc[q[mid + 1]] - sumc[q[mid]])) L &#x3D; mid + 1; \n\t\telse R &#x3D; mid;&#x2F;&#x2F; 求&gt;k的min\t版本1[&lt;-向左]\tmid]\n\t&#125;\n\treturn q[L];&#x2F;&#x2F;求q[L],变为 &gt;&#x3D;k的min  最终q[L,R]:[&#x3D;...&#x3D;&gt;]k\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; s;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint t, c;\n\t\tscanf(&quot;%d%d&quot;, &amp;t, &amp;c);\n\t\tsumt[i] &#x3D; sumt[i - 1] + t, sumc[i] &#x3D; sumc[i - 1] + c;\n\t&#125;\n\tl &#x3D; r &#x3D; 1, q[1] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint p &#x3D; binary_search(i, s + sumt[i]);\n\t\tf[i] &#x3D; f[p] - (s + sumt[i]) * sumc[p]\n\t\t\t+ sumt[i] * sumc[i] + s * sumc[n];\n\t\twhile (l &lt; r &amp;&amp; (f[q[r]] - f[q[r - 1]]) * (sumc[i] - sumc[q[r]])\n\t\t\t&gt;&#x3D; (f[i] - f[q[r]]) * (sumc[q[r]] - sumc[q[r - 1]])) r--;\n\t\tq[++r] &#x3D; i;\n\t&#125;\n\tcout &lt;&lt; f[n] &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;运输小猫\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nlong long f[110][N], s[N], a[N], d[N], q[N], g[N];\nint n, m, p, i, j, k, l, r;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; p;&#x2F;&#x2F;n山m猫p人\n\tfor(i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; j;\n\t\td[i] &#x3D; d[i-1] + j;&#x2F;&#x2F;山1~i距离的前缀和\n\t&#125;\n\tfor(i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t&#123;\n\t\tcin &gt;&gt; j &gt;&gt; k;&#x2F;&#x2F;cat_i-&gt;山Hi 玩到Ti开始等\n\t\ta[i] &#x3D; k - d[j];&#x2F;&#x2F;T玩 &#x3D; Ti - d[Hi]\n\t&#125;\n\n\tsort(a + 1, a + m + 1);\n\tfor(i &#x3D; 1; i &lt;&#x3D; m; i++) s[i] &#x3D; s[i - 1] + a[i];\n\t\n\tmemset(f, 0x3f, sizeof f);\n\tf[0][0] &#x3D; 0;\n\tfor(i &#x3D; 1; i &lt;&#x3D; p; i++)\n\t&#123;\n\t\tfor(j &#x3D; 1; j &lt;&#x3D; m; j++) g[j] &#x3D; f[i - 1][j] + s[j];&#x2F;&#x2F;y\n\t\tq[l &#x3D; r &#x3D; 1]&#x3D;0;\n\t\tfor(j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;队头斜率&lt;&#x3D;k:出队\n\t\t\twhile(l &lt; r &amp;&amp; g[q[l + 1]] - g[q[l]] &lt;&#x3D; a[j] * (q[l + 1] - q[l])) l++;\n\t\t\t&#x2F;&#x2F;用k&#x3D;q[l]转移\n\t\t\tf[i][j] &#x3D; min(f[i - 1][j], g[q[l]]+a[j] * (j - q[l]) - s[j]);\n\t\t\tif(g[j] &gt;&#x3D; 0x3f3f3f3f3f3f3f3fll) continue;&#x2F;&#x2F;best会超LL:忽略！\n\t\t\t&#x2F;&#x2F;入队\n\t\t\twhile(l &lt; r &amp;&amp; (g[j] - g[q[r]]) * (q[r] - q[r - 1]) &lt;&#x3D; (g[q[r]] - g[q[r - 1]]) * (j - q[r])) r--;\n\t\t\tq[++r] &#x3D; j;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; f[p][m] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x5B.四边形不等式\n&#x2F;&#x2F;诗人小G\n\n&#x2F;&#x2F;一个古老的石头游戏    CE????\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 50010, INF &#x3D; 0x3f3f3f3f;\n\nint n, a;\nint s[N];\nint f[N][N];\nint p[N][N];\n\nint main()\n&#123;\n\twhile(scanf(&quot;%d&quot;, &amp;n), n)\n\t&#123;\n\t\tmemset(f, INF , sizeof f);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;a);\n\t\t\ts[i] &#x3D; s[i - 1] + a;\n\t\t&#125;\n\t\t\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\t&#123;\n\t\t\tf[i][i] &#x3D; 0;\n\t\t\tp[i][i] &#x3D; i;&#x2F;&#x2F;p[][]的初始值\n\t\t&#125;\n\t\tfor (int len &#x3D; 2; len &lt;&#x3D; n; len ++ )&#x2F;&#x2F;阶段:len\n\t\t\tfor (int l &#x3D; 1; l + len - 1 &lt;&#x3D; n; l ++ )&#x2F;&#x2F;状态l\n\t\t\t&#123;\n\t\t\t\tint r &#x3D; l + len - 1;&#x2F;&#x2F;状态r\n\t\t\t\tfor(int k &#x3D; p[l][r - 1]; k &lt;&#x3D; p[l + 1][r]; k++)&#x2F;&#x2F;缩小循环范围\n\t\t\t\t&#123;\n\t\t\t\t\tif(f[l][r] &gt; min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]))\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tf[l][r] &#x3D; min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);\n\t\t\t\t\t\tp[l][r] &#x3D; k;&#x2F;&#x2F;更新最佳分割点    \n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\tprintf(&quot;%d\\n&quot;, f[1][n]);\n\t&#125;\n\treturn 0;\n&#125;\n\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;luoyj&#x2F;p&#x2F;12587356.html\n&#x2F;&#x2F;GarsiaWachs算法 O(NlogN)\n\n\n\n\n&#x2F;&#x2F;0x5C.计数类DP\n&#x2F;&#x2F;杰拉尔德和巨型象棋\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;set&gt;\n#include&lt;queue&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\ntypedef long long LL;\n#define x first\n#define y second\nconst int N &#x3D; 2010;\n\npair&lt;int, int&gt; a[N];\nint h, w, n, f[N], mod &#x3D; 1e9 + 7;\nLL jc[200010], jcinv[200010];\n\nint C(int n, int m) &#123;&#x2F;&#x2F;分子*(分母的乘法逆元)\n\treturn jc[n] * jcinv[m] % mod * jcinv[n - m] % mod;\n&#125;\n\nLL power(LL a, int b) &#123;&#x2F;&#x2F;快速幂模板\n\tLL c &#x3D; 1;\n\tfor (; b; b &gt;&gt;&#x3D; 1) &#123;\n\t\tif (b &amp; 1) c &#x3D; c*a%mod;\n\t\ta &#x3D; a * a % mod;\n\t&#125;\n\treturn c;\n&#125;\n\nint main() &#123;\n\tjc[0] &#x3D; 1, jcinv[0] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 200000; i++) &#123;\n\t\tjc[i] &#x3D; jc[i - 1] * i % mod;&#x2F;&#x2F;b&#x3D;i!%p\n\t\tjcinv[i] &#x3D; power(jc[i], mod - 2);&#x2F;&#x2F;乘法逆元b^(p-2)\n\t&#125;\n\tcin &gt;&gt; h &gt;&gt; w &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y);\n\tsort(a + 1, a + n + 1);\n\ta[n + 1].x &#x3D; h, a[n + 1].y &#x3D; w;\n\t\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n + 1; i++) &#123;\n\t\tf[i] &#x3D; C(a[i].x + a[i].y - 2, a[i].x - 1);\n\t\tfor (int j &#x3D; 1; j &lt; i; j++) &#123;\n\t\t\tif (a[j].x &gt; a[i].x || a[j].y &gt; a[i].y) continue;&#x2F;&#x2F;不会走到的点\n\t\t\tf[i] &#x3D; (f[i] - (LL)f[j] * C(a[i].x + a[i].y - a[j].x - a[j].y, a[i].x - a[j].x)) % mod;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; (f[n + 1] + mod) % mod &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;连通图 高精度。。。\n&#x2F;&#x2F;python3版\nimport sys\n\ndef power(k):\n\tres &#x3D; 1\n\tfor i in range(k * (k - 1) &#x2F;&#x2F; 2):\n\t\tres *&#x3D; 2\n\treturn res\n\ndef C(a, b):\n\tres &#x3D; 1\n\tfor i in range(1, a + 1): res *&#x3D; i\n\tfor i in range(1, b + 1): res &#x2F;&#x2F;&#x3D; i\n\tfor i in range(1, a - b + 1): res &#x2F;&#x2F;&#x3D; i\n\treturn res\n\nfor line in sys.stdin:\n\tn &#x3D; int(line)\n\tif n &#x3D;&#x3D; 0:\n\t\tbreak\n\tf &#x3D; [0 for _ in range(n + 1)]\n\tf[1] &#x3D; 1\n\tfor i in range(n + 1):\n\t\tf[i] &#x3D; power(i)\n\t\tfor j in range(1, i):\n\t\t\tf[i] -&#x3D; f[j] * C(i - 1, i - j) * power(i - j)\n\tprint(f[n])\n\n\n\n&#x2F;&#x2F;它们中的多少个  (男人八题之一  出题人:Tourist)\n&#x2F;&#x2F; H[i] 表示i个点组成的连通图个数（可以顺手做做poj1737）\n&#x2F;&#x2F; F[i,j]表示i个点构成的包含j条割边的连通图个数\n&#x2F;&#x2F; G[i,j,k]表示i个点，j条割边，分成k个连通块 的无向图个数。\n&#x2F;*\nfact[i]表示i的阶乘，而infact[i]表示i阶乘的逆元，\n即infact[i] &#x3D; fact[i]^（p - 2） mod p。\n当然具体在预处理时计算fact[i]和infact[i]都可以利用之前计算好的fact[i-1]及infact[i-1]的值，我们知道\nfact[i] &#x3D; fact[i-1] * i；\ninfact[i - 1] * fact[i - 1] mod p &#x3D; 1,设x为i的乘法逆元，故\nfact[i] * infact[i-1] * x mod p &#x3D; fact[i-1] * infact[i-1] * i * x mod p &#x3D; 1，\n故infact[i] &#x3D; infact[i-1] * x mod p，\n即i阶乘的乘法逆元 &#x3D;&#x3D; (i-1)阶乘的乘法逆元 * i的乘法逆元。\n或: infact[i-1] &#x3D; infact[i] * i mod p\n\n(i!)^-1 &#x3D; 1&#x2F;i! &#x3D; (i+1)&#x2F;(i+1)! &#x3D; (i+1) * (i+1)!^-1\n*&#x2F;\n&#x2F;&#x2F;@墨染空 大佬注释版\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\n\nconst int N &#x3D; 55, M &#x3D; 1260, P &#x3D; 1e9 + 7;\nint H[N], F[N][N], G[N][N][N], fact[N], infact[N];\nint n, m;\n\nint power(int a, int b) &#123;\n\tint res &#x3D; 1;\n\twhile (b) &#123;\n\t\tif (b &amp; 1) res &#x3D; (LL)res * a % P;\n\t\ta &#x3D; (LL)a * a % P;\n\t\tb &gt;&gt;&#x3D; 1;\n\t&#125;\n\treturn res;\n&#125;\n\nint C(int a, int b) &#123;\n\treturn (LL) fact[a] * infact[b] % P * infact[a - b] % P;\n&#125;\n\n&#x2F;*\n函数声明！！！ 否则CE： \na.cpp: In function &#39;int g(int, int, int)&#39;:\na.cpp:31:29: error: &#39;f&#39; was not declared in this scope\n*&#x2F;\nint f(int i, int j);\n\nint g(int i, int j, int k) &#123;&#x2F;&#x2F;删掉连通块1以后的图方案数\n\tif (k &gt;&#x3D; i || j &gt; i) return 0;&#x2F;&#x2F;割边数&lt;点数(一条链) 连通块数&lt;&#x3D;(|e|&#x3D;0)点数\n\tif (G[i][j][k] !&#x3D; -1) return G[i][j][k];&#x2F;&#x2F;记忆化\n\tint &amp;v &#x3D; G[i][j][k] &#x3D; 0;\n\t&#x2F;&#x2F;【！！！关键语句！！！】 *i：i点选1点与连通块1相连 与*p同理 \n\tif (j &#x3D;&#x3D; 1) return v &#x3D; (LL)f(i, k) * i % P;\n\tfor (int p &#x3D; 1; p &lt;&#x3D; i; p++)  &#123;&#x2F;&#x2F; 以编号最小点所在块为基准枚举\n\t\tfor (int q &#x3D; 0; q &lt;&#x3D; k; q++) &#123;\n\t\t\t&#x2F;&#x2F; *p:块内p选1与连通块1相连\n\t\t\tv &#x3D; (v + (LL) f(p, q) * C(i - 1, p - 1) % P * p % P * g(i - p, j - 1, k - q)) % P;\n\t\t&#125;\n\t&#125;\n\treturn v;\n&#125;\n\nint f(int i, int j) &#123;\n\tif (j &gt;&#x3D; i) return 0;\n\tif (F[i][j] !&#x3D; -1) return F[i][j];&#x2F;&#x2F;记忆化！！！【trick_2 ~~】\n\tint &amp;v &#x3D; F[i][j] &#x3D; 0;\n\tif (j &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;无割边\n\t\tv &#x3D; H[i];&#x2F;&#x2F;i点无向连通图数\n\t\tfor (int k &#x3D; 1; k &lt;&#x3D; i - 1; k++) v &#x3D; (v - f(i, k) + P) % P;\n\t&#125; else &#123;\n\t\tfor (int k &#x3D; 1; k &lt;&#x3D; i - 1; k++) &#123;\n\t\t\tint s &#x3D; 0;\n\t\t\tfor (int x &#x3D; 1; x &lt;&#x3D; min(i - k, j); x++) &#123;\n\t\t\t\ts &#x3D; (s + (LL)g(i - k, x, j - x) * power(k, x)) % P;\n\t\t\t&#125;\n\t\t\tv &#x3D; (v + (LL)f(k, 0) * C(i - 1, k - 1) % P * s % P) % P;\n\t\t&#125;\n\t&#125;\n\treturn v;\n&#125;\n\nint main() &#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\t&#x2F;&#x2F;O(N)预处理fact infact  【trick_1 ~~】\n\tfact[0] &#x3D; infact[0] &#x3D; H[1] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) fact[i] &#x3D; (LL) fact[i - 1] * i % P;\n\tinfact[n] &#x3D; power(fact[n], P - 2);&#x2F;&#x2F;减少power的次数 n-&gt;1倒推：越算越容易\n\t&#x2F;&#x2F;infact[i-1] &#x3D; infact[i] * i mod p\n\tfor (int i &#x3D; n - 1; i; i--) infact[i] &#x3D; (LL) infact[i + 1] * (i + 1) % P;\n\t&#x2F;&#x2F;Hi\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n\t\tH[i] &#x3D; power(2, i * (i - 1) &#x2F; 2);\n\t\tfor (int j &#x3D; 1; j &lt; i; j++) &#123;\n\t\t\tH[i] &#x3D; ((H[i] - (LL)H[j] * C(i - 1, j - 1) % P * power(2, (i - j) * (i - j - 1) &#x2F; 2)) % P + P) % P;\n\t\t&#125;\n\t&#125;\n\n\tmemset(F, -1, sizeof F);\n\tmemset(G, -1, sizeof G);\n\tF[1][0] &#x3D; 1, G[1][1][0] &#x3D; 1;\n\n\tint ans &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; m; i++) (ans +&#x3D; f(n, i)) %&#x3D; P;\n\n\tprintf(&quot;%d\\n&quot;, ans);\n&#125;\n&#x2F;&#x2F; 作者：墨染空\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;206906&#x2F;\n&#x2F;&#x2F; 含Tarjan暴力做法\n\n\n&#x2F;&#x2F;装饰围栏\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint t, n;\nlong long m, f[21][21][2];&#x2F;&#x2F;k:0低1高\n\nvoid prework() &#123;\n\tf[1][1][0] &#x3D; f[1][1][1] &#x3D; 1;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; 20; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;\n\t\t\tfor (int p &#x3D; j; p &lt;&#x3D; i - 1; p++)\n\t\t\t\tf[i][j][0] +&#x3D; f[i - 1][p][1];\n\t\t\tfor (int p &#x3D; 1; p &lt;&#x3D; j - 1; p++)\n\t\t\t\tf[i][j][1] +&#x3D; f[i - 1][p][0];\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tprework();\n\tcin &gt;&gt; t;\n\twhile (t--) &#123;\n\t\tcin &gt;&gt; n &gt;&gt; m;&#x2F;&#x2F;字典序排名m\n\t\tbool used[21];\n\t\tmemset(used, 0, sizeof(used));\n\t\tint last, k;\n\t\t&#x2F;&#x2F; 第1块木板，既可能处于高位，也可能处于低位，单独处理\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;&#x2F;&#x2F;枚举第1板长度排名\n\t\t\tif (f[n][j][1] &gt;&#x3D; m) &#123;&#x2F;&#x2F;先1后0:因为&#x3D;&#x3D;对2~N板先0后1(字典序)\n\t\t\t\tlast &#x3D; j, k &#x3D; 1;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse m -&#x3D; f[n][j][1];\n\t\t\tif (f[n][j][0] &gt;&#x3D; m) &#123;\n\t\t\t\tlast &#x3D; j, k &#x3D; 0;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse m -&#x3D; f[n][j][0];\n\t\t&#125;\n\t\tused[last] &#x3D; 1;\n\t\tprintf(&quot;%d&quot;, last);\n\t\t&#x2F;&#x2F; 第2~n块木板，高低位置、合法的长度范围与上一块木板有关\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n\t\t\tk ^&#x3D; 1;\n\t\t\t&#x2F;&#x2F; 真实长度为len，在【剩余木板中排名为j！！！！！！】\n\t\t\tint j &#x3D; 0;\n\t\t\tfor (int len &#x3D; 1; len &lt;&#x3D; n; len++) &#123;\n\t\t\t\tif (used[len]) continue;&#x2F;&#x2F;跳过，不j++\n\t\t\t\tj++;&#x2F;&#x2F;j&#x3D;1\n\t\t\t\tif (k &#x3D;&#x3D; 0 &amp;&amp; len &lt; last || k &#x3D;&#x3D; 1 &amp;&amp; len &gt; last) &#123;&#x2F;&#x2F;0低1高\n\t\t\t\t\tif (f[n - i + 1][j][k] &gt;&#x3D; m) &#123;&#x2F;&#x2F;cur试填第i块\n\t\t\t\t\t\tlast &#x3D; len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t\telse m -&#x3D; f[n - i + 1][j][k];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tused[last] &#x3D; 1;\n\t\t\tprintf(&quot; %d&quot;, last);\n\t\t&#125;\n\t\tputs(&quot;&quot;);\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;0x5D.数位统计DP\n&#x2F;&#x2F;启示录\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nlong long f[21][4];\nint t, n, m;\n\nvoid prework() &#123;\n\tf[0][0] &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt; 20; i++) &#123;\n\t\tfor (int j &#x3D; 0; j &lt; 3; j++) &#123;\n\t\t\tf[i + 1][j + 1] +&#x3D; f[i][j];\n\t\t\tf[i + 1][0] +&#x3D; f[i][j] * 9;\n\t\t&#125;\n\t\tf[i + 1][3] +&#x3D; f[i][3] * 10;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tprework();\n\tcin &gt;&gt; t; &#x2F;&#x2F; 数据组数\n\twhile (t--) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;n); &#x2F;&#x2F; 题目中的X\n\t\t&#x2F;&#x2F; 第n个魔鬼数有m位\n\t\tfor (m &#x3D; 3; f[m][3] &lt; n; m++);&#x2F;&#x2F;&gt;&#x3D;n跳出：确定n的位数m\n\t\t&#x2F;&#x2F; 试填第i位，末尾已有k个6（k&#x3D;3也表示已经是魔鬼数）\n\t\tfor (int i &#x3D; m, k &#x3D; 0; i; i--) &#123;\n\t\t\t&#x2F;&#x2F; 从小到大枚举第i位填的数字j\n\t\t\tfor (int j &#x3D; 0; j &lt;&#x3D; 9; j++) &#123;\n\t\t\t\t&#x2F;&#x2F; 求出后边的i-1位有多少(cnt)种填法【能让整个数是魔鬼数】\n\t\t\t\tlong long cnt &#x3D; f[i - 1][3];&#x2F;&#x2F;魔\n\t\t\t\tif (j &#x3D;&#x3D; 6 || k &#x3D;&#x3D; 3)&#x2F;&#x2F;i位填6 || 末尾已有3个6\n\t\t\t\t\tfor (int l &#x3D; max(3 - k - (j &#x3D;&#x3D; 6), 0); l&lt;3; l++)&#x2F;&#x2F;\n\t\t\t\t\t\tcnt +&#x3D; f[i - 1][l];&#x2F;&#x2F;+“合法”非魔\n\t\t\t\t&#x2F;&#x2F; 如果cnt比n小，说明第n个魔鬼数的第i位应该比j更大\n\t\t\t\tif (cnt &lt; n) &#123;\n\t\t\t\t\tn -&#x3D; cnt;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; 否则，第i位就应该是j\n\t\t\t\telse &#123;\n\t\t\t\t\tif (k &lt; 3) &#123;\n\t\t\t\t\t\tif (j &#x3D;&#x3D; 6) k++; else k &#x3D; 0;\n\t\t\t\t\t&#125;\n\t\t\t\t\tprintf(&quot;%d&quot;, j);\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;月之谜\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 200, L &#x3D; 21;\nll f[L][N][N][2];\nint n[L];\n\nll calc(ll x, int P) &#123;&#x2F;&#x2F;x:上限R  P:sum\n\tif (!x) return 0;\n\tmemset(f, 0, sizeof(f));\n\tint t &#x3D; 0;\n\twhile (x) &#123;\n\t\tn[++t] &#x3D; x % 10;&#x2F;&#x2F;n[]:上限\n\t\tx &#x2F;&#x3D; 10;\n\t&#125;\n\tf[t+1][0][0][0] &#x3D; 1;\n\tfor (int i &#x3D; t + 1; i &gt; 1; i--)&#x2F;&#x2F;高位-&gt;低位 cur试填位i\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; P; j++)&#x2F;&#x2F;j:i的高位数字cur_sum\n\t\t\tfor (int k &#x3D; 0; k &lt; P; k++)&#x2F;&#x2F;k:i的高位数cur%P余数\n\t\t\t\tif (f[i][j][k][0] || f[i][j][k][1])&#x2F;&#x2F;记忆化\n\t\t\t\t\tfor (int p &#x3D; 0; p &lt; 10; p++) &#123;&#x2F;&#x2F;枚举第i位数字\n\t\t\t\t\t\tint w &#x3D; (10 * k + p) % P;&#x2F;&#x2F;w:cur&#39;%p\n\t\t\t\t\t\tif (p &lt; n[i-1] &amp;&amp; j + p &lt;&#x3D; P)&#x2F;&#x2F;p&lt;该位上限 &amp;&amp; cur_sum&lt;&#x3D;sum\n\t\t\t\t\t\t\t&#x2F;&#x2F;当前试填i-1-&gt;i j-&#x3D;p w-&gt;k  prev+&#x3D;cur\n\t\t\t\t\t\t\tf[i-1][j+p][w][1] +&#x3D; f[i][j][k][0];&#x2F;&#x2F;【1:高位有&lt;】\n\t\t\t\t\t\telse if (p &#x3D;&#x3D; n[i-1] &amp;&amp; j + p &lt;&#x3D; P)\n\t\t\t\t\t\t\tf[i-1][j+p][w][0] +&#x3D; f[i][j][k][0];&#x2F;&#x2F;【0:都&#x3D;上限】\n\t\t\t\t\t\tif (f[i][j][k][1] &amp;&amp; j + p &lt;&#x3D; P)\n\t\t\t\t\t\t\tf[i-1][j+p][w][1] +&#x3D; f[i][j][k][1];\n\t\t\t\t\t&#125;\n\treturn f[1][P][0][0] + f[1][P][0][1];\n&#125;\n\nint main() &#123;\n\tll a, b, ans &#x3D; 0;\n\tcin &gt;&gt; a &gt;&gt; b;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 9 * 18; i++)&#x2F;&#x2F;枚举sum\n\t\tans +&#x3D; calc(b, i) - calc(a - 1, i);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n------------------------------------------------------------------------------\n\n&#x2F;&#x2F;0x5E.总结与练习\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n</code></pre>\n\n\n\n<h1 id=\"0x60图论\"><a href=\"#0x60图论\" class=\"headerlink\" title=\"0x60图论\"></a>0x60图论</h1><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n学：\n#pragma GCC optimize (&quot;O3&quot;)\n#pragma GCC target (&quot;sse4&quot;)\n#define quick() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)&#x2F;&#x2F;读入优化\n*&#x2F;\n\n\n&#x2F;&#x2F;0x61.最短路 \n&#x2F;&#x2F; 单源最短路 （负权）队列优化的Bellman-Ford:SPFA   (无负权)堆优化的Dijkstra\n&#x2F;&#x2F;340\t通信线路\n&#x2F;&#x2F;法一：分层图最短路\t有后效性DP：SPFA迭代\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1006, P &#x3D; 20006, INF &#x3D; 0x3f3f3f3f;\nint n, p, k, d[N*N];\nint Head[N*N], Edge[N*P], Next[N*P], Leng[N*P], tot &#x3D; 0;\nbool v[N*N];&#x2F;&#x2F;在queue中\nqueue&lt;int&gt; q;\n\ninline void add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n\nvoid spfa() &#123;\n\tmemset(d, 0x3f, sizeof(d));\n\td[1] &#x3D; 0;\n\tv[1] &#x3D; 1;\n\tq.push(1);\n\twhile (q.size()) &#123;&#x2F;&#x2F;直至queue为空\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tv[x] &#x3D; 0;\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\t\tif (d[y] &gt; max(d[x], z)) &#123;\n\t\t\t\td[y] &#x3D; max(d[x], z);&#x2F;&#x2F;\n\t\t\t\tif (!v[y]) &#123;\n\t\t\t\t\tq.push(y);\n\t\t\t\t\tv[y] &#x3D; 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; p &gt;&gt; k;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; p; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\t&#x2F;&#x2F;伪2D节点(x,j):1-&gt;x途中已有j条边(1-&gt;任意v)(&lt;&#x3D;&gt;j列)免费\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; k; j++) &#123;&#x2F;&#x2F;不选xy边免费 \n\t\t\tadd(x + j * n, y + j * n, z);&#x2F;&#x2F;j+1列x行:(x,j)-z-&gt;(y,j)\n\t\t\tadd(y + j * n, x + j * n, z);&#x2F;&#x2F;双向\n\t\t&#125;\n\t\tfor (int j &#x3D; 0; j &lt; k; j++) &#123;&#x2F;&#x2F;j属于[0,k]\n\t\t\tadd(x + j * n, y + (j + 1) * n, 0);&#x2F;&#x2F;(x,j)-0-&gt;(y,j+1) \n\t\t\tadd(y + j * n, x + (j + 1) * n, 0);&#x2F;&#x2F;等价于同一个点,同时更新不用管\n\t\t&#125;\n\t&#125;\n\tspfa();\n\tif (d[(k+1)*n] &#x3D;&#x3D; INF) puts(&quot;-1&quot;);&#x2F;&#x2F;n行k+1列\n\telse cout &lt;&lt; d[(k+1)*n] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;法二:二分ans，deque_BFS\n\n\n&#x2F;&#x2F; 341\t最优贸易\n&#x2F;&#x2F;Author:xht37\n&#x2F;&#x2F; 如果z&#x3D;1，表示这条道路是城市 x 到城市 y 之间的单向道路；\n&#x2F;&#x2F; 如果z&#x3D;2，表示这条道路为城市 x 和城市 y 之间的双向道路。\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1e5 + 6, M &#x3D; 1e6 + 6;\nint n, m, tot, Price[N], Ans;\nint Head[N], Side[M], Next[M], ans[N];\nint fHead[N], fSide[M], fNext[M], fans[N];\npriority_queue&lt;pair&lt;int, int&gt;&gt; q;\npriority_queue&lt;pair&lt;int, int&gt;&gt; fq;\n\nvoid add(int x, int y, int z) &#123;\n\tSide[++tot] &#x3D; y, Next[tot] &#x3D; Head[x], Head[x] &#x3D; tot;\n\t&#x2F;&#x2F;反图:将所有边反向\n\tfSide[tot] &#x3D; x, fNext[tot] &#x3D; fHead[y], fHead[y] &#x3D; tot;\n\t&#x2F;&#x2F;双向边\n\tif (z &#x3D;&#x3D; 2) &#123;\n\t\tSide[++tot] &#x3D; x, Next[tot] &#x3D; Head[y], Head[y] &#x3D; tot;\n\t\tfSide[tot] &#x3D; y, fNext[tot] &#x3D; fHead[x], fHead[x] &#x3D; tot;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;Price[i]);\n\tint x, y, z;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\tadd(x, y, z);\n\t&#125;\n\tmemset(ans, 0x3f, sizeof(ans));\n\tmemset(fans, 0xcf, sizeof(fans));\n\tans[1] &#x3D; Price[1];\n\tfans[n] &#x3D; Price[n];\n\tq.push(&#123;-ans[1], 1&#125;);\n\tfq.push(&#123;fans[n], n&#125;);\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.top().second;\n\t\tq.pop();\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Side[i];\n\t\t\tif (ans[y] &gt; ans[x]) &#123;&#x2F;&#x2F;1~y最小权值\n\t\t\t\tans[y] &#x3D; min(ans[x], Price[y]);\n\t\t\t\tq.push(&#123;-ans[y], y&#125;);&#x2F;&#x2F;-ans:大根堆-&gt;小根堆 求min\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\twhile (fq.size()) &#123;\n\t\tint x &#x3D; fq.top().second;\n\t\tfq.pop();\n\t\tfor (int i &#x3D; fHead[x]; i; i &#x3D; fNext[i]) &#123;\n\t\t\tint y &#x3D; fSide[i];\n\t\t\tif (fans[y] &lt; fans[x]) &#123;&#x2F;&#x2F;y~n最大权值\n\t\t\t\tfans[y] &#x3D; max(fans[x], Price[y]);\n\t\t\t\tfq.push(&#123;fans[y], y&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) Ans &#x3D; max(Ans, fans[i]-ans[i]);\n\tcout &lt;&lt; Ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;yxc\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010, M &#x3D; 2000010;\n\nint n, m;\nint price[N];\nint h[N], rh[N], e[M], ne[M], idx;\nint dmin[N], dmax[N];\nbool st[N];\n\nvoid add(int *h, int a, int b)\n&#123;\n\te[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid spfa(int *d, int start, int *h, bool flag)\n&#123;\n\tqueue&lt;int&gt; q;\n\tmemset(st, 0, sizeof st);\n\n\tif (flag) memset(d, 0x3f, sizeof dmin);\n\n\tq.push(start);\n\tst[start] &#x3D; true;\n\td[start] &#x3D; price[start];\n\n\twhile (q.size())\n\t&#123;\n\t\tint t &#x3D; q.front();\n\t\tq.pop();\n\t\tst[t] &#x3D; false;\n\n\t\tfor (int i &#x3D; h[t]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif (flag &amp;&amp; d[j] &gt; min(d[t], price[j]) || !flag &amp;&amp; d[j] &lt; max(d[t], price[j]))\n\t\t\t&#123;\n\t\t\t\tif (flag) d[j] &#x3D; min(d[t], price[j]);\n\t\t\t\telse d[j] &#x3D; max(d[t], price[j]);\n\n\t\t\t\tif (!st[j])\n\t\t\t\t&#123;\n\t\t\t\t\tst[j] &#x3D; true;\n\t\t\t\t\tq.push(j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\n\tmemset(h, -1, sizeof h);\n\tmemset(rh, -1, sizeof rh);\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) scanf(&quot;%d&quot;, &amp;price[i]);\n\twhile (m -- )\n\t&#123;\n\t\tint a, b, c;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n\t\tadd(h, a, b), add(rh, b, a);&#x2F;&#x2F;h-&gt;rh:idx(正反图)交替\n\t\tif (c &#x3D;&#x3D; 2) add(h, b, a), add(rh, a, b);\n\t&#125;\n\n\tspfa(dmin, 1, h, true);\n\tspfa(dmax, n, rh, false);\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) res &#x3D; max(res, dmax[i] - dmin[i]);\n\n\tprintf(&quot;%d\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n------------------------------------------------------------------------------\n&#x2F;&#x2F; 342\t道路与航线  双向边权非负,只无环单向边可能为负权\n&#x2F;&#x2F; (不同连通块间)拓扑序SPFA 套 (连通块内)堆优化Dijkstra\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int maxT &#x3D; 25006, maxRP &#x3D; 150006, INF &#x3D; 0x3f3f3f3f;\nint T, R, P, S;\nint Head[maxT], Edge[maxRP], Cost[maxRP], Next[maxRP], totS &#x3D; 0;\nint c[maxT], deg[maxT], d[maxT], totc &#x3D; 0;&#x2F;&#x2F;c[]:点所在的连通块 totc:连通块数\nbool v[maxT];\nqueue&lt;int&gt; q;\npriority_queue&lt;pair&lt;int, int&gt;&gt; Q;\n\ninline void add(int A, int B, int C) &#123;\n\tEdge[++totS] &#x3D; B;\n\tCost[totS] &#x3D; C;\n\tNext[totS] &#x3D; Head[A];\n\tHead[A] &#x3D; totS;\n&#125;\n\nvoid dfs(int i) &#123;\n\tfor (int j &#x3D; Head[i]; j; j &#x3D; Next[j])\n\t\tif (!c[Edge[j]]) &#123;\n\t\t\tc[Edge[j]] &#x3D; totc;&#x2F;&#x2F;属于连通块totc\n\t\t\tdfs(Edge[j]);\n\t\t&#125;\n&#125;\n\nint main() &#123;\n\tmemset(d, 0x7f, sizeof(d));\n\tcin &gt;&gt; T &gt;&gt; R &gt;&gt; P &gt;&gt; S;&#x2F;&#x2F;T点 R道路 P航线 S起点\n\tfor (int i &#x3D; 1; i &lt;&#x3D; R; i++) &#123;\n\t\tint A, B, C;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C);\n\t\tadd(A, B, C);\n\t\tadd(B, A, C);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; T; i++)\n\t\tif (!c[i]) &#123;\n\t\t\tc[i] &#x3D; ++totc;&#x2F;&#x2F;属于连通块totc\n\t\t\tdfs(i);\n\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; P; i++) &#123;\n\t\tint A, B, C;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C);\n\t\tadd(A, B, C);\n\t\t++deg[c[B]];&#x2F;&#x2F;B所在连通块的总入度+1\n\t&#125;\n\tq.push(c[S]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; totc; i++) if (!deg[i]) q.push(i);\n\td[S] &#x3D; 0;\n\twhile (q.size()) &#123;\n\t\tint i &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; T; j++)\n\t\t\tif (c[j] &#x3D;&#x3D; i) Q.push(&#123;-d[j], j&#125;);&#x2F;&#x2F;块i所有节点入小根堆Q(-d[j])\n\t\twhile (Q.size()) &#123;\n\t\t\tint x &#x3D; Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif (v[x]) continue;\n\t\t\tv[x] &#x3D; 1;\n\t\t\tfor (int j &#x3D; Head[x]; j; j &#x3D; Next[j]) &#123;\n\t\t\t\tint y &#x3D; Edge[j];\n\t\t\t\tif (d[x] + Cost[j] &lt; d[y]) &#123;\n\t\t\t\t\td[y] &#x3D; d[x] + Cost[j];\n\t\t\t\t\tif (c[x] &#x3D;&#x3D; c[y]) Q.push(&#123;-d[y], y&#125;);\n\t\t\t\t&#125;\n\t\t\t\tif (c[x] !&#x3D; c[y] &amp;&amp; !--deg[c[y]]) q.push(c[y]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; T; i++)\n&#x2F;&#x2F;可能存在某个点被s不能走到的点更新。因此判断无解时不能写成&#x3D;&#x3D;inf\n\t\tif (d[i] &gt; INF) puts(&quot;NO PATH&quot;);\n\t\telse printf(&quot;%d\\n&quot;, d[i]);\n\treturn 0;\n&#125;\n\n\n&#x2F;*\nSLF优化SPFA:\nSLF优化,不同于一般的SPFA算法,它是一种利用双端队列算法处理的问题.\n\n如果说当前点所花费的值少于我们当前队头点的值的话,那么我们就将这个节点插入到队头去,否则我们还是插入到队尾.\n*&#x2F;\n&#x2F;*\n堆优化，LLL优化,容错机制,SLF,SLF+Swap,xay-spfa\n记录一个权值w,w&#x3D;sqrt&#123;sum(w_i)&#125;,当dis_&#123;front&#125;+w&lt;dis_&#123;now&#125;,就把当前点加入队尾\n用前向星的话可以试试双关键字排序，边权小的排前面\n随机化插入\n\nSPFA已死：\nhttps:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;292283275&#x2F;answer&#x2F;484871888\n从原理上分析，所有 spfa 的优化都是为了使队列接近优先队列。然而，我们知道维护一个优先队列在目前来说是需要 log 的复杂度的，所以低于该复杂度的 一定能 Hack。\n*&#x2F;\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N&#x3D;400000 +100;\nint head[N],ver[N],Next[N],edge[N],vis[N],dis[N],tot;\nvoid add_edge(int a,int b,int c)\n&#123;\n\tedge[tot]&#x3D;b;\n\tver[tot]&#x3D;c;\n\tNext[tot]&#x3D;head[a];\n\thead[a]&#x3D;tot++;\n&#125;\nvoid spfa(int s)\n&#123;\n\tmemset(dis,0x3f,sizeof(dis));\n\tmemset(vis,false,sizeof(vis));\n\tdeque&lt;int&gt; q;\n\tdis[s]&#x3D;0;\n\tvis[s]&#x3D;true;\n\tq.push_back(s);\n\twhile(q.size())\n\t&#123;\n\t\tint now&#x3D;q.front();\n\t\tvis[now]&#x3D;false;\n\t\tq.pop_front();\n\t\tfor(int i&#x3D;head[now]; ~i; i&#x3D;Next[i])\n\t\t&#123;\n\t\t\tint j&#x3D;edge[i];\n\t\t\tif (dis[j]&gt;dis[now]+ver[i])\n\t\t\t&#123;\n\t\t\t\tdis[j]&#x3D;dis[now]+ver[i];\n\t\t\t\tif (!vis[j])\n\t\t\t\t&#123;\n\t\t\t\t\tvis[j]&#x3D;true;\n\t\t\t\t\tif (q.size() &amp;&amp; dis[j]&lt;dis[q.front()])&#x2F;&#x2F;SLF优化\n\t\t\t\t\t\tq.push_front(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tq.push_back(j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\nint main()\n&#123;\n\tint t,r,p,s,x,y,z;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin&gt;&gt;t&gt;&gt;r&gt;&gt;p&gt;&gt;s;\n\tmemset(head,-1,sizeof(head));\n\tfor(int i&#x3D;1; i&lt;&#x3D;r; i++)\n\t&#123;\n\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n\t\tadd_edge(x,y,z);\n\t\tadd_edge(y,x,z);\n\t&#125;\n\tfor(int i&#x3D;1; i&lt;&#x3D;p; i++)\n\t&#123;\n\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n\t\tadd_edge(x,y,z);\n\t&#125;\n\tspfa(s);\n\tfor(int i&#x3D;1; i&lt;&#x3D;t; i++)\n\t&#123;\n\t\tif (dis[i]&#x3D;&#x3D;0x3f3f3f3f)\n\t\t\tcout&lt;&lt;&quot;NO PATH&quot;&lt;&lt;endl;\n\t\telse\n\t\t\tcout&lt;&lt;dis[i]&lt;&lt;endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：秦淮岸灯火阑珊\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;2427&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n------------------------------------------------------------------------------\n&#x2F;&#x2F;多源最短路 \n&#x2F;*\nFloyd:\nmemset(d, 0x3f, sizeof d);\nfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) d[i][i] &#x3D; 0;\nd[x][y] &#x3D; min(d[x][y],z);\n&#x2F;&#x2F; for(kij)\nd[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);\n\n传递闭包:\nbool d[N][N];\nfor_i: d[i][i] &#x3D; 1;\nd[x][y] &#x3D; d[y][x] &#x3D; 1;\n&#x2F;&#x2F; for(kij)\nd[i][j] |&#x3D; d[i][k] &amp; d[k][j];\n*&#x2F;\n\n&#x2F;&#x2F;343. 排序\t不等式全部为&lt;关系\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 30;\nint n, m, d[N][N], e[N][N];\n\nint floyd() &#123;\n\tmemcpy(e, d, sizeof(e));\n\tfor (int k &#x3D; 0; k &lt; n; k++)\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt; n; j++) &#123;\n\t\t\t\te[i][j] |&#x3D; e[i][k] &amp; e[k][j];\n\t\t\t\tif (e[i][j] &#x3D;&#x3D; e[j][i] &amp;&amp; e[i][j] &amp;&amp; i !&#x3D; j) return -1;&#x2F;&#x2F;均为1\n\t\t\t&#125;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; n; j++)\n\t\t\tif (e[i][j] &#x3D;&#x3D; e[j][i] &amp;&amp; !e[i][j] &amp;&amp; i !&#x3D; j) return 0;&#x2F;&#x2F;均为0\n\treturn 1;\n&#125;\n\nvoid Sorting_It_All_Out() &#123;\n\tmemset(d, 0, sizeof(d));\n\tbool flag &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tchar s[6];\n\t\tscanf(&quot;%s&quot;, s);\n\t\td[s[0]-&#39;A&#39;][s[2]-&#39;A&#39;] &#x3D; 1;\n\t\tif (flag) &#123;\n\t\t\tint now &#x3D; floyd();&#x2F;&#x2F;-1 0 1\n\t\t\tif (now &#x3D;&#x3D; -1) &#123;\n\t\t\t\tprintf(&quot;Inconsistency found after %d relations.\\n&quot;, i);\n\t\t\t\tflag &#x3D; 0;&#x2F;&#x2F;end\n\t\t\t&#125; else if (now &#x3D;&#x3D; 1) &#123;\n\t\t\t\tprintf(&quot;Sorted sequence determined after %d relations: &quot;, i);\n\t\t\t\tpair&lt;int, char&gt; ans[N];\n\t\t\t\tfor (int j &#x3D; 0; j &lt; n; j++) &#123;\n\t\t\t\t\tans[j].first &#x3D; 0;\n\t\t\t\t\tans[j].second &#x3D; &#39;A&#39; + j;\n\t\t\t\t&#125;&#x2F;&#x2F;&#123;&#123;0,&#39;A&#39;&#125;,&#123;0,&#39;B&#39;&#125;,...&#125;\n\t\t\t\tfor (int j &#x3D; 0; j &lt; n; j++)&#x2F;&#x2F;j&lt;k:ans[j]&#x3D;&#123;0,&#39;A&#39;&#125;-&gt;&#123;1,&#39;A&#39;&#125;\n\t\t\t\t\tfor (int k &#x3D; 0; k &lt; n; k++)\n\t\t\t\t\t\tif (e[j][k]) ++ans[j].first;\n\t\t\t\tsort(ans, ans + n);&#x2F;&#x2F;大-&gt;小：0E 1D 2C 3B 4A\n\t\t\t\tfor (int j &#x3D; n - 1; j &gt;&#x3D; 0; j--) printf(&quot;%c&quot;, ans[j].second);\n\t\t\t\tputs(&quot;.&quot;);\n\t\t\t\tflag &#x3D; 0;&#x2F;&#x2F;end\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif (flag) puts(&quot;Sorted sequence cannot be determined.&quot;);\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) Sorting_It_All_Out();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; AcWing 344. 观光之旅\t\t无向图最小环问题\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint a[310][310], d[310][310], pos[310][310];\nint n, m, ans &#x3D; 0x3f3f3f3f;\nvector&lt;int&gt; path; &#x2F;&#x2F;具体方案\n\nvoid get_path(int x, int y) &#123;\n\tif (pos[x][y] &#x3D;&#x3D; 0) return;\n\tget_path(x, pos[x][y]);\n\tpath.push_back(pos[x][y]);&#x2F;&#x2F;\n\tget_path(pos[x][y], y);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tmemset(a, 0x3f, sizeof(a));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i][i] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);\n\t\ta[y][x] &#x3D; a[x][y] &#x3D; min(a[x][y], z);\n\t&#125;\n\tmemcpy(d, a, sizeof(a));\n\tfor (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;\n\t\tfor (int i &#x3D; 1; i &lt; k; i++)\n\t\t\tfor (int j &#x3D; i + 1; j &lt; k; j++)\n\t\t\t\tif ((long long)d[i][j] + a[j][k] + a[k][i] &lt; ans) &#123;\n\t\t\t\t\tans &#x3D; d[i][j] + a[j][k] + a[k][i];\n\t\t\t\t\tpath.clear();\n\t\t\t\t\tpath.push_back(i);\n\t\t\t\t\tget_path(i, j);\n\t\t\t\t\tpath.push_back(j);\n\t\t\t\t\tpath.push_back(k);\n\t\t\t\t&#125;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif (d[i][j] &gt; d[i][k] + d[k][j]) &#123;\n\t\t\t\t\td[i][j] &#x3D; d[i][k] + d[k][j];\n\t\t\t\t\tpos[i][j] &#x3D; k;\n\t\t\t\t&#125;\n\t&#125;\n\tif (ans &#x3D;&#x3D; 0x3f3f3f3f) &#123;\n\t\tputs(&quot;No solution.&quot;);\n\t\treturn 0;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; path.size(); i++)\n\t\tprintf(&quot;%d &quot;, path[i]);\n\tputs(&quot;&quot;);\n&#125;\n\n\n&#x2F;&#x2F; AcWing 345. 牛站\n&#x2F;&#x2F;Author:XuHt\n#include &lt;map&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 206, INF &#x3D; 0x3f3f3f3f;\nint n, t, s, e, tot &#x3D; 200;\nmap&lt;int, int&gt; m;\nstruct M &#123;&#x2F;&#x2F;图的可达矩阵a~a^n\n\tint a[N][N];\n\tvoid pre() &#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; tot; j++)\n\t\t\t\ta[i][j] &#x3D; INF;\n\t&#125;\n&#125; st, ed;\n\nM mul(M a, M b) &#123;&#x2F;&#x2F;广义矩阵乘法\n\tM c;\n\tc.pre();\n\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; tot; j++)\n\t\t\tfor (int k &#x3D; 1; k &lt;&#x3D; tot; k++)\n\t\t\t\tc.a[i][j] &#x3D; min(c.a[i][j], a.a[i][k] + b.a[k][j]);\n\treturn c;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; t &gt;&gt; s &gt;&gt; e;&#x2F;&#x2F;s~经过n条边~&gt;e 总边数t\n\tst.pre();\n\ttot &#x3D; 0;\n\twhile (t--) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;z, &amp;x, &amp;y);\n\t\tx &#x3D; m[x] ? m[x] : (m[x] &#x3D; ++tot);&#x2F;&#x2F;所有点离散化(重新编号为tot)\n\t\ty &#x3D; m[y] ? m[y] : (m[y] &#x3D; ++tot);\n\t\tst.a[x][y] &#x3D; st.a[y][x] &#x3D; z;\n\t&#125;\n\tmemcpy(ed.a, st.a, sizeof(ed.a));\n\t--n;&#x2F;&#x2F;st[s][e]:经过一条边s-&gt;e \t故ed&#x3D;a^(n-1)\n\twhile (n) &#123;&#x2F;&#x2F;快速幂 求ed\n\t\tif (n &amp; 1) ed &#x3D; mul(ed, st);\n\t\tst &#x3D; mul(st, st);\n\t\tn &gt;&gt;&#x3D; 1;\n\t&#125;\n\tcout &lt;&lt; ed.a[m[s]][m[e]] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x62.最小生成树MST\n&#x2F;&#x2F; AcWing 346. 走廊泼水节\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nstruct rec &#123; int x, y, z; &#125; edge[6010];\nint fa[6010], s[6010], n, T;\nlong long ans;\nbool operator &lt;(rec a, rec b) &#123;\n\treturn a.z &lt; b.z;\n&#125;\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);&#x2F;&#x2F;\n&#125;\nint main() &#123;\n\tcin &gt;&gt; T;\n\twhile (T--) &#123;\n\t\tcin &gt;&gt; n;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].z);\n\t\tsort(edge + 1, edge + n);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfa[i] &#x3D; i, s[i] &#x3D; 1;&#x2F;&#x2F;\n\t\tans &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\t\tint x &#x3D; get(edge[i].x);\n\t\t\tint y &#x3D; get(edge[i].y);\n\t\t\tif (x &#x3D;&#x3D; y) continue;\n\t\t\tans +&#x3D; (long long)(edge[i].z + 1) * (s[x] * s[y] - 1);\n\t\t\tfa[x] &#x3D; y;\n\t\t\ts[y] +&#x3D; s[x];\n\t\t&#125;\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 347. 野餐规划\n&#x2F;&#x2F;Author:XuHt\n#include &lt;map&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 37, INF &#x3D; 0x3f3f3f3f;\nstruct E &#123;\n\tint x, y, z;\n\tbool operator &lt; (const E w) const &#123;\n\t\treturn z &lt; w.z;\n\t&#125;\n&#125; f[N];\nint n, k, tot, ans, a[N][N], fa[N], d[N], v[N];\nmap&lt;string, int&gt; m;\nvector&lt;E&gt; e;\nbool in[N][N];&#x2F;&#x2F;在生成树内\n\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\n&#x2F;&#x2F; 该过程可用树形dp实现，设dp[i].w表示1号节点到i号节点的路径上权值最大的边，dp[i].w &#x3D; max(dp[fa[i]].w, i到fa[i]的边权)。\nvoid dfs(int x, int pre) &#123;&#x2F;&#x2F;1,-1 &#x2F;&#x2F;1~u-(max:f[i].z)-v~i\n\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;\n\t\tif (i &#x3D;&#x3D; pre || !in[x][i]) continue;&#x2F;&#x2F;边(x,i)在Tr外\n\t\tif (f[i].z &#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; &#x3D;&#x3D;init值\n\t\t\tif (f[x].z &gt; a[x][i]) f[i] &#x3D; f[x];&#x2F;&#x2F;1~x-i\n\t\t\telse &#123;\n\t\t\t\tf[i].x &#x3D; x;\n\t\t\t\tf[i].y &#x3D; i;\n\t\t\t\tf[i].z &#x3D; a[x][i];\n\t\t\t&#125;\n\t\t&#125;\n\t\tdfs(i, x);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tmemset(a, 0x3f, sizeof(a));\n\tmemset(d, 0x3f, sizeof(d));\n\tm[&quot;Park&quot;] &#x3D; tot &#x3D; 1;&#x2F;&#x2F;节点1:park\n\tfor (int i &#x3D; 0; i &lt; N; i++) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tE w;\n\t\tstring s1, s2;\n\t\tcin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w.z;\n\t\tw.x &#x3D; m[s1] ? m[s1] : (m[s1] &#x3D; ++tot);&#x2F;&#x2F;离散化后的点tot\n\t\tw.y &#x3D; m[s2] ? m[s2] : (m[s2] &#x3D; ++tot);\n\t\te.push_back(w);\n\t\ta[w.x][w.y] &#x3D; a[w.y][w.x] &#x3D; min(a[w.x][w.y], w.z);\n\t&#125;\n\tcin &gt;&gt; k;&#x2F;&#x2F;表示公园的最大停车数量&#x3D;&#x3D;节点1最大度数S\n\tsort(e.begin(), e.end());&#x2F;&#x2F;Kruskal求(去掉点1后)T个连通块内MST\n\tfor (unsigned int i &#x3D; 0; i &lt; e.size(); i++) &#123;\n\t\tif (e[i].x &#x3D;&#x3D; 1 || e[i].y &#x3D;&#x3D; 1) continue;&#x2F;&#x2F; || 出入park:跳过\n\t\tint rtx &#x3D; get(e[i].x), rty &#x3D; get(e[i].y);\n\t\tif (rtx !&#x3D; rty) &#123;\n\t\t\tfa[rtx] &#x3D; rty;\n\t\t\tin[e[i].x][e[i].y] &#x3D; in[e[i].y][e[i].x] &#x3D; 1;&#x2F;&#x2F;mark块内的边\n\t\t\tans +&#x3D; e[i].z;&#x2F;&#x2F;MST边权和\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++)\n\t\tif (a[1][i] !&#x3D; INF) &#123;\n\t\t\tint rt &#x3D; get(i);\n\t\t\tif (d[rt] &gt; a[1][i]) d[rt] &#x3D; a[1][v[rt]&#x3D;i];&#x2F;&#x2F;1~rt块的minEdge:(1,p)\n\t\t&#125;&#x2F;&#x2F;得到d[rt]&#x3D;a[1][p], v[rt]&#x3D;p\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++)\n\t\tif (d[i] !&#x3D; INF) &#123;&#x2F;&#x2F;T块\n\t\t\t--k;&#x2F;&#x2F;点1度数--\n\t\t\tin[1][v[i]] &#x3D; in[v[i]][1] &#x3D; 1;&#x2F;&#x2F;v[rt]&#x3D;p mark:(1,p)\n\t\t\tans +&#x3D; a[1][v[i]];\n\t\t&#125;\n\t&#x2F;&#x2F;改动S-T条边优化Spanning Tree (块内删max边 1~...连边)\n\twhile (k--) &#123;\n\t\tmemset(f, -1, sizeof(f));&#x2F;&#x2F;init\n\t\tf[1].z &#x3D; -INF;&#x2F;&#x2F;求Tr内1~x上maxEdge\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++)\n\t\t\tif (in[1][i]) f[i].z &#x3D; -INF;&#x2F;&#x2F;(1,p)的f[p].z&#x3D;-INF\n\t\tdfs(1, -1);&#x2F;&#x2F;\n\t\tint o, w &#x3D; -INF;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++)\n\t\t\tif (w &lt; f[i].z - a[1][i])\n\t\t\t\tw &#x3D; f[i].z - a[1][o&#x3D;i];&#x2F;&#x2F;最大的w-z  1~u-(max:w)-v~i 1-(z)-i\n\t\tif (w &lt;&#x3D; 0) break;\n\t\tin[1][o] &#x3D; in[o][1] &#x3D; 1;&#x2F;&#x2F;连边\n\t\tin[f[o].x][f[o].y] &#x3D; in[f[o].y][f[o].x] &#x3D; 0;&#x2F;&#x2F;删边\n\t\tans -&#x3D; w;\n\t&#125;\n\tprintf(&quot;Total miles driven: %d\\n&quot;, ans);\n\treturn 0;\n&#125;\n\n\n\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;map&gt;\nusing namespace std;\n\nconst int M &#x3D; 55;\nint n, m &#x3D; 0, k, ans &#x3D; 0;\nint ee[M][M];\nbool in[M][M];\n&#x2F;&#x2F; in表示in tree，即树边，同ee是邻接矩阵，in[i][j] &#x3D; 1表示i到j有连边 \nint tot &#x3D; 0;\nstruct edge&#123;\n\tint h, t, w;\n&#125;e[10010];\nmap &lt;string, int&gt; vis;\n\nbool cmp(edge x, edge y) &#123;\n\treturn x.w &lt; y.w;\n&#125;\n\nint fa[M];\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\nvoid Kruskal() &#123;\n\tsort(e + 1, e + tot + 1, cmp);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; ++ i) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; ++ i) &#123;\n\t\tint x &#x3D; e[i].h, y &#x3D; e[i].t, z &#x3D; e[i].w;\n\t\tint fx &#x3D; get(x), fy &#x3D; get(y);\n\t\tif (fx &#x3D;&#x3D; 1 || fy &#x3D;&#x3D; 1) continue;\n\t\t&#x2F;&#x2F; 如果为1号节点则跳过 \n\t\tif (fx !&#x3D; fy) fa[fx] &#x3D; fy, ans +&#x3D; z, in[x][y] &#x3D; in[y][x] &#x3D; 1;\n\t&#125;\n&#125;\n\nstruct edges&#123;\n\tint w, l, r;\n&#125;dp[M];\n\nvoid dfs(int depth, int pre) &#123;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; m; ++ i) &#123;\n\t\tif (i &#x3D;&#x3D; pre || !in[depth][i]) continue;\n\t\tif (dp[i].w &#x3D;&#x3D; -1) &#123;\n\t\t\tif (dp[depth].w &gt; ee[depth][i]) dp[i] &#x3D; dp[depth];\n\t\t\telse dp[i].l &#x3D; depth, dp[i].r &#x3D; i, dp[i].w &#x3D; ee[depth][i];\n\t\t&#125;\n\t\tdfs(i, depth);\n\t&#125;\n&#125;\n\nint mintree[M], tminpoint[M];\n&#x2F;&#x2F; mintree[i]为1号节点到连通块i(并查集的编号)中的最短距离（即1号节点到连通块任何一点的边的最小权值），tminpoint[i]表示上述点的编号 \nint num &#x3D; 0, minpoint, point;\n\nint main() &#123;\n\tmemset(ee, 0x3f, sizeof(ee));\n\tmemset(mintree, 0x3f, sizeof(mintree));\n\tcin &gt;&gt; n;\n\tvis[&quot;Park&quot;] &#x3D; (++ m);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; ++ i) &#123;\n\t\tstring x, y;\n\t\tint z;\n\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n\t\tif (!vis[x]) vis[x] &#x3D; (++ m);\n\t\tif (!vis[y]) vis[y] &#x3D; (++ m);\n\t\t&#x2F;&#x2F; 记录点数 \n\t\tint nx &#x3D; vis[x], ny &#x3D; vis[y];\n\t\te[++ tot].h &#x3D; nx, e[tot].t &#x3D; ny, e[tot].w &#x3D; z;\n\t\tee[nx][ny] &#x3D; ee[ny][nx] &#x3D; min(ee[nx][ny], z);\n\t&#125;\n\t&#x2F;&#x2F;邻接表 + 邻接矩阵 \n\tcin &gt;&gt; k;\n\tKruskal(); \n\tfor (int i &#x3D; 2; i &lt;&#x3D; m; ++ i) \n\t\tif (ee[1][i] &lt; 0x3f3f3f3f) &#123;\n\t\t\tint which &#x3D; get(i);\n\t\t\tif (mintree[which] &gt; ee[1][i]) &#123;\n\t\t\t\tmintree[which] &#x3D; ee[1][i];\n\t\t\t\ttminpoint[which] &#x3D; i;\n\t\t\t&#125;\n\t\t&#125;\n\t&#x2F;&#x2F; 查询1号节点到每个除1号节点连通块的最小距离即该边另一端的点的编号 \n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; ++ i)\n\t\tif (mintree[i] &lt; 0x3f3f3f3f) &#123;\n\t\t\t++ num;\n\t\t\tin[1][tminpoint[i]] &#x3D; in[tminpoint[i]][1] &#x3D; 1;\n\t\t\tans +&#x3D; ee[1][tminpoint[i]];\n\t\t&#125;   \n\t&#x2F;&#x2F; 构建最小生成树，从1号节点向所有除1号节点的连通块连边，累计答案 \n\tfor (int i &#x3D; num + 1; i &lt;&#x3D; k; ++ i) &#123;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[1].w &#x3D; -0x3f3f3f3f;\n\t\tfor (int j &#x3D; 2; j &lt;&#x3D; m; ++ j)\n\t\t\tif (in[1][j]) dp[j].w &#x3D; -0x3f3f3f3f;\n\t\tdfs(1, -1);\n\t\t&#x2F;&#x2F; 树形dp求dp数组 \n\t\tminpoint &#x3D; 0x3f3f3f3f;\n\t\tfor (int j &#x3D; 2; j &lt;&#x3D; m; ++ j) \n\t\t\tif (minpoint &gt; ee[1][j] - dp[j].w) minpoint &#x3D; ee[1][j] - dp[j].w, point &#x3D; j;\n\t\tif (minpoint &gt;&#x3D; 0) break;\n\t\t&#x2F;&#x2F; 遍历求最小1号节点到j号节点的权值 - dp[j].w的最小值 \n\t\tin[1][point] &#x3D; in[point][1] &#x3D; 1;\n\t\tin[dp[point].l][dp[point].r] &#x3D; in[dp[point].r][dp[point].l] &#x3D; 0;\n\t\t&#x2F;&#x2F; 处理善后 \n\t\tans +&#x3D; minpoint;\n\t\t&#x2F;&#x2F; 累计答案 \n\t&#125;\n\tcout &lt;&lt; &quot;Total miles driven: &quot; &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n作者：shined\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;1708&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F; AcWing 348. 沙漠之王 \n&#x2F;&#x2F; 最优比率(max&#123;总收益Ce&#x2F;总成本Re&#125;)生成树 0&#x2F;1分数规划:二分答案\n&#x2F;&#x2F; edge[e] &#x3D; Ce - mid * Re(c&#x3D;b-ka)的原图上求最大生成树 边权之和非负：l&#x3D;mid，否则r&#x3D;mid 最终ans&#x3D;mid\n&#x2F;&#x2F;本题：min&#123;总成本(高度差_a)&#x2F;总长度_b&#125; c&#x3D;a-kb Prim求最小生成树 (其余part同上)\n&#x2F;&#x2F;prim的复杂度是O(n2), kruskal的复杂度是O(mlogm)，这个题是完全图所以m&#x3D;n2\n&#x2F;&#x2F;Author:XuHt  TLE!!!!!!\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1006, INF &#x3D; 0x3f3f3f3f;\nconst double eps &#x3D; 1e-6;\nint n;\nstruct P &#123;\n\tint x, y, z;\n&#125; p[N];\ndouble a[N][N], b[N][N], c[N][N], d[N];\nbool v[N];\n\ninline double s(int i, int j) &#123;\n\treturn sqrt((p[i].x - p[j].x) * (p[i].x - p[j].x) + (p[i].y - p[j].y) * (p[i].y - p[j].y));\n&#125;\n\ndouble work(double k) &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; i; j &lt;&#x3D; n; j++)&#x2F;&#x2F;1&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n\n\t\t\tif (i &#x3D;&#x3D; j) c[i][j] &#x3D; INF;&#x2F;&#x2F;(自环)不可达\n\t\t\telse c[i][j] &#x3D; c[j][i] &#x3D; a[i][j] - k * b[i][j];&#x2F;&#x2F;新边权c\n\t&#x2F;&#x2F;Prim求MST\n\tmemset(v, 0, sizeof(v));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) d[i] &#x3D; INF;\n\td[1] &#x3D; 0;\n\tdouble ans &#x3D; 0;\n\twhile (1) &#123;\n\t\tint x &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!v[i] &amp;&amp; (!x || d[x] &gt; d[i])) x &#x3D; i;&#x2F;&#x2F;d[x]min\n\t\tif (!x) break;&#x2F;&#x2F;不能再更新了\n\t\tv[x] &#x3D; 1;\n\t\tans +&#x3D; d[x];\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) d[i] &#x3D; min(d[i], c[x][i]);&#x2F;&#x2F;\n\t&#125;\n\treturn ans;\n&#125;\n\nvoid Desert_King() &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d %d %d&quot;, &amp;p[i].x, &amp;p[i].y, &amp;p[i].z);\n\tdouble num &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\tnum +&#x3D; (a[i][j] &#x3D; a[j][i] &#x3D; abs(p[i].z - p[j].z));&#x2F;&#x2F;成本&#x3D;高度差\n\t\t\tb[i][j] &#x3D; b[j][i] &#x3D; s(i, j);&#x2F;&#x2F;dist[i][j]\n\t\t&#125;\n\tdouble l &#x3D; 0, r &#x3D; num;\n\twhile (l + eps &lt;&#x3D; r) &#123;&#x2F;&#x2F;\n\t\tdouble mid &#x3D; (l + r) &#x2F; 2;\n\t\tif (work(mid) &gt;&#x3D; 0) l &#x3D; mid;\n\t\telse r &#x3D; mid;\n\t&#125;\n\tprintf(&quot;%.3f\\n&quot;, l);\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &amp;&amp; n) Desert_King();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; Dinkelbach算法\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;hzoi_ztx&#x2F;article&#x2F;details&#x2F;54898323\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;hhaile&#x2F;article&#x2F;details&#x2F;8883652\n对于0-1分数规划的Dinkelbach算法的分析 武钢三中吴豪[译]\nhttps:&#x2F;&#x2F;www.docin.com&#x2F;p-601713235.html\n算法合集之《最小割模型在信息学竞赛中的应用》 胡伯涛 2007NOI国家集训队论文_day2\nhttps:&#x2F;&#x2F;wenku.baidu.com&#x2F;view&#x2F;986baf00b52acfc789ebc9a9.html\n&#x2F;*\n参数搜索：\n目标式:R&#x3D;sigma(a[i]*x[i])&#x2F;sigma(b[i]*x[i])\nd[i]&#x3D;a[i]-L*b[i]，那么F(L)&#x3D;sigma(d[i]*x[i])\n二分的时候我们只是用到了F(L)&gt;0这个条件，而对于使得F(L)&gt;0的这组解所求到的R值没有使用。因为F(L)&gt;0,我们已经知道了R是一个更优的解，与其漫无目的的二分，为什么不将解移动到R上去呢？\n\n求01分数规划的另一个方法就是Dinkelbach算法，\nDinkelbach 实质上是一种迭代算法，基于这样的思想：不去二分答案，而是先随便给定一个答案，然后根据更优的解（max&#123;f(r)&#125; 对应直线的横截距） 不断移动答案，逼近最优解。理论上它比二分快些。但是，他的弊端就是需要保存这个解。\n在这个算法中，一般将r初始化为0。\n\n再说最小化\n看上面的图，也很好理解，就是最左边的r为r*，当前的r确定时需要用到min&#123;f(r)&#125;。 \n如果min&#123;f(r)&#125;&gt;0，那么r&lt;r*； \n如果min&#123;f(r)&#125;&#x3D;0，那么r&#x3D;r*； \n如果min&#123;f(r)&#125;&lt;0，那么r&gt;r*。\n\n每次直接把子问题Q(l)最优解带入r的表达式算出一个新l&#39;,进行下一次迭代\n线性时间复杂度算法？？？\n*&#x2F;\n\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ndouble dist[1100][1100], cost[1100][1100];\ndouble ratio, dsum, csum; int n;\n&#x2F;&#x2F; min&#123;总成本(高度差_c)&#x2F;总长度_d&#125; c-kd\ninline double len (int a, int b) &#123; return cost[a][b] - ratio * dist[a][b]; &#125;\n\nvoid prim (void)\n&#123;\n\tdouble dt[1100], ds[1100], dc[1100];\n\tbool added[1100];\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t&#123;\n\t\tdt[i] &#x3D; len(0, i);\n\t\tds[i] &#x3D; dist[0][i], dc[i] &#x3D; cost[0][i];\n\t&#125;\n\tmemset(added, 0, sizeof(added));\n\tadded[0] &#x3D; true;\n\tdsum &#x3D; csum &#x3D; 0;&#x2F;&#x2F;init&#x3D;0\n\tfor (int i &#x3D; 1; i &lt; n; i++)&#x2F;&#x2F;迭代dsum,csum\n\t&#123;\n\t\tint t &#x3D; -1;&#x2F;&#x2F;dt[t] &#x3D; len(0,t) &#x3D; min&#123;c-kd&#125;\n\t\tfor (int j &#x3D; 1; j &lt; n; j++)\n\t\t&#123;\n\t\t\tif (added[j]) continue;\n\t\t\tif (t &#x3D;&#x3D; -1 || dt[j] &lt; dt[t]) t &#x3D; j;\n\t\t&#125;\n\t\tdsum +&#x3D; ds[t], csum +&#x3D; dc[t];&#x2F;&#x2F;更新sum值\n\t\tadded[t] &#x3D; true;\n\t\tfor (int j &#x3D; 1; j &lt; n; j++)&#x2F;&#x2F;更新dt ds dc\n\t\t&#123;\n\t\t\tif (added[j]) continue;\n\t\t\tif (len(t, j) &lt; dt[j]) &#x2F;&#x2F; dt[j] &#x3D;&#x3D; len(0, j)\n\t\t\t&#123;\n\t\t\t\tdt[j] &#x3D; len(t, j);\n\t\t\t\tds[j] &#x3D; dist[t][j], dc[j] &#x3D; cost[t][j];\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint x[1100], y[1100], h[1100];\nint main ()\n&#123;\n\twhile (1)\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;n);\n\t\tif (n &#x3D;&#x3D; 0) break;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d %d %d&quot;, &amp;x[i], &amp;y[i], &amp;h[i]);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tfor (int j &#x3D; i + 1; j &lt; n; j++)\n\t\t\t&#123;\n\t\t\t\tdist[i][j] &#x3D; sqrt((double)(x[i] - x[j]) * (x[i] - x[j]) +\n\t\t\t\t\t\t\t\t  (double)(y[i] - y[j]) * (y[i] - y[j]));\n\t\t\t\tdist[j][i] &#x3D; dist[i][j];\n\t\t\t\tcost[i][j] &#x3D; cost[j][i] &#x3D; abs(h[i] - h[j]);\n\t\t\t&#125;\n\t\t&#125;\n\t\tdsum &#x3D; csum &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++) dsum +&#x3D; dist[0][i], csum +&#x3D; cost[0][i];\n\t\tratio &#x3D; csum &#x2F; dsum;&#x2F;&#x2F;\n\t\twhile (1)&#x2F;&#x2F;迭代逼近\n\t\t&#123;\n\t\t\tprim(); \n\t\t\tdouble tr &#x3D; csum &#x2F; dsum;\n\t\t\tif (fabs(tr - ratio) &lt; 1e-04) break;\n\t\t\telse ratio &#x3D; tr;&#x2F;&#x2F;保存该值，更新答案\n\t\t&#125;\n\t\tprintf(&quot;%.3f\\n&quot;, ratio);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 349. 黑暗城堡\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 1006;\nconst ll P &#x3D; (1ll &lt;&lt; 31) - 1;\nint n, m, a[N][N], d[N];\nbool v[N];\n&#x2F;*\nbool cmp (const int&amp; a, const int&amp; b)\n&#123;\n\treturn d[a] &lt; d[b];\n&#125;\n*&#x2F;\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tmemset(a, 0x3f, sizeof(a));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i][i] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\ta[x][y] &#x3D; a[y][x] &#x3D; min(a[x][y], z);\n\t&#125;\n\t&#x2F;&#x2F;Dijkstra模板\n\tmemset(d, 0x3f, sizeof(d));\n\td[1] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint t &#x3D; 0;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tif (!v[j] &amp;&amp; (!t || d[j] &lt; d[t])) t &#x3D; j;\n\t\tv[t] &#x3D; 1;&#x2F;&#x2F;全局最小值点\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\td[j] &#x3D; min(d[j], d[t] + a[t][j]);&#x2F;&#x2F;更新dist[]\n\t&#125;\n\n\tmemset(v, 0, sizeof(v));\n\tv[1] &#x3D; 1;\n\tll ans &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint t &#x3D; 0, k &#x3D; 0;\n\t\tfor (int j &#x3D; 2; j &lt;&#x3D; n; j++)\n\t\t\tif (!v[j] &amp;&amp; (!t || d[j] &lt; d[t])) t &#x3D; j;&#x2F;&#x2F;dist[t]min O(n^2)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tif (v[j] &amp;&amp; d[j] + a[j][t] &#x3D;&#x3D; d[t]) ++k;\n\t\tv[t] &#x3D; 1;\n\t\t(ans *&#x3D; k) %&#x3D; P;\n\t&#125;\n&#x2F;*\n\tint list[N];\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) list[i] &#x3D; i;\n\tsort(list + 1, list + 1 + n, cmp); &#x2F;&#x2F; O(nlogn)\n\tll ans &#x3D; 1;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint tt &#x3D; 0;\n\t\tfor (int j &#x3D; 1; j &lt; i; j++)\n\t\t&#123;\n\t\t\tif (d[list[j]] + a[list[j]][list[i]] &#x3D;&#x3D; d[list[i]]) ++tt;\n\t\t&#125;\n\t\tans &#x3D; (ans * tt) % P;\n\t&#125;\n*&#x2F;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;类似无向图MST问题：有向图上最小树形图的朱-刘算法（见lrj黑书指导7.2）\n\n&#x2F;&#x2F;0x63. 树的直径与最近公共祖先\n&#x2F;&#x2F;【树的直径】\n&#x2F;&#x2F; AcWing 350. 巡逻\n&#x2F;*\n因为需要获得第一次直径的路径，应该使用两次搜索寻找，这里使用DFS\n第二次寻找直径出现负权，需要使用树形DP求直径\n*&#x2F;\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100006;\nint n, k, d[N], fa[N];\nint Head[N], Edge[N&lt;&lt;1], Leng[N&lt;&lt;1], Next[N&lt;&lt;1], tot &#x3D; 1;\nbool v[N];\n\nvoid add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n\nvoid dfs(int x, int &amp;t) &#123;&#x2F;&#x2F;2次dfs求树的直径\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (v[y]) continue;\n\t\tif ((d[y] &#x3D; d[x] + z) &gt;&#x3D; d[t]) t &#x3D; y;\n\t\tfa[y] &#x3D; i;&#x2F;&#x2F;记录前驱边\n\t\tdfs(y, t);&#x2F;&#x2F;y:直径的一端-最远-&gt;t:另一端\n\t&#125;\n\tv[x] &#x3D; 0;\n&#125;\n\nvoid dp(int x, int &amp;t) &#123;&#x2F;&#x2F;树形DP求t：x子树的直径\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (v[y]) continue;\n\t\tdp(y, t);\n\t\tt &#x3D; max(t, d[x] + d[y] + z);\n\t\td[x] &#x3D; max(d[x], d[y] + z);\n\t&#125;&#x2F;&#x2F;d[x]:x向下子树内最远距离\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; k;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tadd(x, y, 1);&#x2F;&#x2F;双向边 成对添加\n\t\tadd(y, x, 1);\n\t&#125;\n\tint t &#x3D; 1;&#x2F;&#x2F;init:t&#x3D;1 d[1]&#x3D;0\n\tdfs(1, t);&#x2F;&#x2F;...--fa[t]--&gt;t：树的直径\n\td[t] &#x3D; fa[t] &#x3D; 0;\n\tint tt &#x3D; t;&#x2F;&#x2F;init:tt&#x3D;t d[t]&#x3D;0\n\tdfs(t, tt);&#x2F;&#x2F;直径L1: t~&gt;tt\n\tint ans &#x3D; ((n - 1) &lt;&lt; 1) - d[tt] + 1;\n\tif (k &#x3D;&#x3D; 2) &#123;\n\t\twhile (fa[tt]) &#123;\n\t\t\tLeng[fa[tt]] &#x3D; Leng[fa[tt]^1] &#x3D; -1;&#x2F;&#x2F;直径取反(反向边^1)\n\t\t\ttt &#x3D; Edge[fa[tt]^1];&#x2F;&#x2F;tt&#39;&lt;--fa[tt]^1--tt\n\t\t&#125;\n\t\ttt &#x3D; 0;&#x2F;&#x2F;L2\n\t\tmemset(d, 0, sizeof(d));\n\t\tdp(t, tt);\n\t\tans -&#x3D; tt - 1;\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;2*bfs+dp\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;queue&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int u&#x3D;100010;\nint ver[2*u],edge[2*u],next[2*u],head[u],d[u],pre[u],f[u],v[u],n,m,tot,p,i,x,y,z;\nqueue&lt;int&gt; q; \n\nvoid add(int x,int y)\n&#123;\n\tver[++tot]&#x3D;y; edge[tot]&#x3D;1; next[tot]&#x3D;head[x]; head[x]&#x3D;tot;\n&#125;\n\nint bfs(int s)\n&#123;\n\tint i,x,y;\n\tmemset(d,0x3f,sizeof(d));\n\tq.push(s); d[s]&#x3D;pre[s]&#x3D;0;\n\twhile(q.size())\n\t&#123;\n\t\tx&#x3D;q.front(); q.pop();\n\t\tfor(i&#x3D;head[x];i;i&#x3D;next[i])\n\t\t\tif(d[ver[i]]&#x3D;&#x3D;0x3f3f3f3f)\n\t\t\t\td[ver[i]]&#x3D;d[x]+edge[i],pre[ver[i]]&#x3D;i,q.push(ver[i]);\n\t&#125;\n\tfor(x&#x3D;y&#x3D;1;x&lt;&#x3D;n;x++) if(d[x]&gt;d[y]) y&#x3D;x;\n\treturn y;\n&#125;\n\nint get()\n&#123;\n\tp&#x3D;bfs(1);\n\tp&#x3D;bfs(p);\n\treturn d[p];\n&#125;\n\nvoid change()\n&#123;\n\tfor(;pre[p];p&#x3D;ver[pre[p]^1]) edge[pre[p]]&#x3D;edge[pre[p]^1]&#x3D;-1;\n&#125;\n\nvoid dp(int x)\n&#123;\n\tv[x]&#x3D;1;\n\tfor(int i&#x3D;head[x];i;i&#x3D;next[i])\n\t\tif(!v[ver[i]])\n\t\t&#123;\n\t\t\tdp(ver[i]);\n\t\t\ty&#x3D;max(y,f[ver[i]]+f[x]+edge[i]);\n\t\t\tf[x]&#x3D;max(f[x],f[ver[i]]+edge[i]);\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin&gt;&gt;n&gt;&gt;m;\n\ttot&#x3D;1;\n\tfor(i&#x3D;1;i&lt;n;i++)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n\t\tadd(x,y),add(y,x);\n\t&#125;\n\tx&#x3D;get(),y&#x3D;0,z&#x3D;1;\n\tif(m&#x3D;&#x3D;2) change(),dp(1),z&#x3D;2;\n\tcout&lt;&lt;2*(n-1)-x-y+z&lt;&lt;endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 351. 树网的核\n&#x2F;&#x2F;解法4\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 500010;\nint head[N],ver[N*2],Next[N*2],edge[N*2];\nint fa[N],f[N],d[N],a[N]; \nint n,s,m,tot,l,r,x,y,z,temp,ans;\nbool v[N];\n\nvoid add(int x,int y,int z) &#123;\n\tver[++tot]&#x3D;y,Next[tot]&#x3D;head[x],edge[tot]&#x3D;z,head[x]&#x3D;tot;\n&#125;\n\nvoid dfs(int x)&#123;&#x2F;&#x2F;fa d\n\tfor(int i&#x3D;head[x];i;i&#x3D;Next[i])&#123;\n\t\tif(ver[i]!&#x3D;fa[x])&#123;\n\t\t\tfa[ver[i]]&#x3D;x;\n\t\t\td[ver[i]]&#x3D;d[x]+edge[i];\n\t\t\tdfs(ver[i]);\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid diameter()&#123;&#x2F;&#x2F;2*dfs\n\tdfs(1);&#x2F;&#x2F;fa d\n\tx&#x3D;1;\n\tfor(int i&#x3D;2;i&lt;&#x3D;n;i++)\n\t\tif(d[i]&gt;d[x])x&#x3D;i;\n\td[x]&#x3D;0;&#x2F;&#x2F;find直径一个端点x,init d fa\n\tmemset(fa,0,sizeof(fa));\n\tdfs(x);\n\ty&#x3D;1;\n\tfor(int i&#x3D;2;i&lt;&#x3D;n;i++)\n\t\tif(d[i]&gt;d[y])y&#x3D;i;\n\twhile(y!&#x3D;x)&#123;&#x2F;&#x2F;a[]记录直径path:y~x\n\t\tv[y]&#x3D;true;\n\t\ta[++m]&#x3D;y;\n\t\ty&#x3D;fa[y];\n\t&#125;\n\tv[x]&#x3D;1;\n\ta[++m]&#x3D;x;\n&#125;\n\nvoid treedp(int x)&#123;&#x2F;&#x2F;treedp求f[ui]\n\tv[x]&#x3D;true;\n\tfor(int i&#x3D;head[x];i;i&#x3D;Next[i])&#123;\n\t\tif(!v[ver[i]])&#123;\n\t\t\ttreedp(ver[i]);\n\t\t\tf[x]&#x3D;max(f[x],f[ver[i]]+edge[i]);&#x2F;&#x2F;diameter法一只求f不求ans\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()&#123;\n\tscanf(&quot;%d%d&quot;,&amp;n,&amp;s);\n\tfor(int i&#x3D;1;i&lt;&#x3D;n-1;i++)&#123;\n\t\tscanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);\n\t\tadd(x,y,z);add(y,x,z);\n\t&#125;\n\tdiameter();\n\tfor(int i&#x3D;1;i&lt;&#x3D;m;i++)treedp(a[i]);&#x2F;&#x2F;f[ui]\n\tint j&#x3D;m;\n\tans&#x3D;0x7fffffff;\n\tfor(int i&#x3D;1;i&lt;&#x3D;m;i++)temp&#x3D;max(temp,f[a[i]]);&#x2F;&#x2F;max_f[ui]\n\tfor(int i&#x3D;m;i&gt;&#x3D;1;i--)&#123;\n\t\twhile(j&gt;&#x3D;1&amp;&amp;d[a[j]]-d[a[i]]&lt;&#x3D;s)j--;&#x2F;&#x2F;1~j~(恰好&gt;s)~i~m d[y&lt;~x]:大&lt;~小\n\t\tans&#x3D;min(ans,max(temp,max(d[a[i]],d[a[1]]-d[a[j+1]])));&#x2F;&#x2F;i~m 1~j\n\t&#125;&#x2F;&#x2F;min_偏心距ECC(F)\n\tprintf(&quot;%d\\n&quot;,ans);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;yxc 解法3\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 500010, M &#x3D; N * 2;\n\nint n, s;\nint h[N], e[M], w[M], ne[M], idx;\nint q[N], dist[N], pre[N];\nvector&lt;PII&gt; path;\nbool st[N];\n\nvoid add(int a, int b, int c)\n&#123;\n\te[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid bfs(int start)\n&#123;\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\tmemset(dist, 0x3f, sizeof dist);\n\tmemset(pre, -1, sizeof pre);\n\tdist[start] &#x3D; 0;\n\tq[0] &#x3D; start;\n\n\twhile (hh &lt;&#x3D; tt)\n\t&#123;\n\t\tint t &#x3D; q[hh ++ ];\n\t\tfor (int i &#x3D; h[t]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif (dist[j] &gt; dist[t] + w[i])\n\t\t\t&#123;\n\t\t\t\tpre[j] &#x3D; t;\n\t\t\t\tdist[j] &#x3D; dist[t] + w[i];\n\t\t\t\tq[ ++ tt] &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint bfs_max_dist(int start)\n&#123;\n\tint res &#x3D; 0;\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\tq[0] &#x3D; start;\n\twhile (hh &lt;&#x3D; tt)\n\t&#123;\n\t\tint t &#x3D; q[hh ++ ];\n\t\tres &#x3D; max(res, dist[t]);\n\n\t\tfor (int i &#x3D; h[t]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif (!st[j])\n\t\t\t&#123;\n\t\t\t\tst[j] &#x3D; true;\n\t\t\t\tdist[j] &#x3D; dist[t] + w[i];\n\t\t\t\tq[ ++ tt] &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn res;\n&#125;\n\nint get_max()\n&#123;\n\tint t &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tif (dist[t] &lt; dist[i])\n\t\t\tt &#x3D; i;\n\treturn t;\n&#125;\n\nbool check(int mid)\n&#123;\n\tint u &#x3D; 0, v &#x3D; path.size() - 1;\n\twhile (u + 1 &lt; path.size() &amp;&amp; path[u + 1].second &lt;&#x3D; mid) u ++ ;\n\twhile (v - 1 &gt;&#x3D; 0 &amp;&amp; path.back().second - path[v - 1].second &lt;&#x3D; mid) v -- ;\n\tif (u &gt; v) return true;\n\tif (path[v].second - path[u].second &gt; s) return false;\n\n\tmemset(st, false, sizeof st);\n\tmemset(dist, 0, sizeof dist);\n\tfor (auto p : path) st[p.first] &#x3D; true;\n\n\tfor (int i &#x3D; u; i &lt;&#x3D; v; i ++ )\n\t\tif (bfs_max_dist(path[i].first) &gt; mid)\n\t\t\treturn false;\n\treturn true;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;s);\n\tmemset(h, -1, sizeof h);\n\tfor (int i &#x3D; 0; i &lt; n - 1; i ++ )\n\t&#123;\n\t\tint a, b, c;\n\t\tscanf(&quot;%d%d%d&quot;,  &amp;a, &amp;b, &amp;c);\n\t\tadd(a, b, c), add(b, a, c);\n\t&#125;\n\n\tbfs(1);\n\tint u &#x3D; get_max();\n\tbfs(u);\n\tint v &#x3D; get_max();\n\twhile (v !&#x3D; -1)\n\t&#123;\n\t\tpath.push_back(&#123;v, dist[v]&#125;);\n\t\tv &#x3D; pre[v];\n\t&#125;\n\treverse(path.begin(), path.end());\n\n\tint l &#x3D; 0, r &#x3D; 2e9;\n\twhile (l &lt; r)\n\t&#123;\n\t\tint mid &#x3D; (LL)l + r &gt;&gt; 1;\n\t\tif (check(mid)) r &#x3D; mid;\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\n\tprintf(&quot;%d\\n&quot;, r);\n\n\treturn 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;3512&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;【LCA】\n&#x2F;&#x2F; 1.向上标记法 2.树上倍增法 3.LCA的Tarjan算法(并查集优化1)(S(n)大一倍!!!!)\n\n&#x2F;&#x2F;【树上差分】: 差分&lt;-(互逆op)-&gt;前缀和 区间op-&gt;path_op 前缀和-&gt;子树和\n\n&#x2F;&#x2F; AcWing 352. 闇の連鎖\n&#x2F;&#x2F;就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。\n&#x2F;&#x2F;所以must 主+附!!!\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 200010;&#x2F;&#x2F;法3LCA: S(n)大一倍!!!!\nint n, m, fa[N], ans[N], v[N], d[N], f[N], ANS &#x3D; 0;\nint Head[N], Edge[N&lt;&lt;1], Next[N&lt;&lt;1], tot &#x3D; 0;\nvector&lt;pair&lt;int, int&gt; &gt; q[N];\npair&lt;int, int&gt; Q[N];\n\ninline void add(int x, int y) &#123;\n\tEdge[++tot] &#x3D; y;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n&#x2F;&#x2F;法3求LCA\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\nvoid tarjan(int x) &#123;\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (v[y]) continue;\n\t\ttarjan(y);\n\t\tfa[y] &#x3D; x;&#x2F;&#x2F;(2)-&gt;fa\n\t&#125;\n\tfor (unsigned int i &#x3D; 0; i &lt; q[x].size(); i++) &#123;\n\t\tint y &#x3D; q[x][i].first, id &#x3D; q[x][i].second;&#x2F;&#x2F;&#123;y,id&#125;\n\t\tif (v[y] &#x3D;&#x3D; 2) ans[id] &#x3D; get(y);&#x2F;&#x2F;只求lca (1)\n\t&#125;\n\tv[x] &#x3D; 2;&#x2F;&#x2F;\n&#125;\n\nvoid dfs(int x) &#123;\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (v[y]) continue;\n\t\tdfs(y);\n\t\tf[x] +&#x3D; f[y];&#x2F;&#x2F;\n\t&#125;\n\tf[x] +&#x3D; d[x];&#x2F;&#x2F;x子树权值之和\n\tif (!f[x]) ANS +&#x3D; m;&#x2F;&#x2F;切cover_0主&#123;x,fa(x)&#125; + m种附\n\telse if (f[x] &#x3D;&#x3D; 1) ++ANS;&#x2F;&#x2F;切cover_1主&#123;x,fa(x)&#125; + only1种附&#123;x,y&#125;\n&#125;&#x2F;&#x2F;切断方案数ANS：cover_&gt;&#x3D;2主 无法切断 ANS+&#x3D;0\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tadd(x, y);\n\t\tadd(y, x);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);&#x2F;&#x2F;m条附加边\n\t\tif (x &#x3D;&#x3D; y) ans[i] &#x3D; x;&#x2F;&#x2F;ans[i]&#x3D;lca(x,y)\n\t\telse &#123;\n\t\t\tq[x].push_back(&#123;y, i&#125;);&#x2F;&#x2F;与x相关的query\n\t\t\tq[y].push_back(&#123;x, i&#125;);\n\t\t&#125;\n\t\tQ[i].first &#x3D; x;&#x2F;&#x2F;Q[i]&#x3D;&#123;x,y&#125;\n\t\tQ[i].second &#x3D; y;\n\t&#125;\n\ttarjan(1);&#x2F;&#x2F;离线 一次性处理\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\t++d[Q[i].first];&#x2F;&#x2F;权值dx+1 dy+1\n\t\t++d[Q[i].second];\n\t\td[ans[i]] -&#x3D; 2;&#x2F;&#x2F;d(lca(x,y))-2\n\t&#125;\n\tmemset(v, 0, sizeof(v));\n\tdfs(1);\n\tcout &lt;&lt; ANS - m &lt;&lt; endl;&#x2F;&#x2F;f[root]&#x3D;0 不考虑cover_0&#123;rt&lt;-fa(rt)&#125;\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; AcWing 353. 雨天的尾巴\t\t难！！！\n\n\n&#x2F;&#x2F; AcWing 354. 天天爱跑步\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int N &#x3D; 300010;\nint ver[N &lt;&lt; 1], Next[N &lt;&lt; 1], head[N], tot;\nint f[N][20], d[N], w[N], v[N];\nint c1[N &lt;&lt; 1], c2[N &lt;&lt; 1], ans[N];\nint n, m, t;\nqueue&lt;int&gt; q;\nvector&lt;int&gt; a1[N], b1[N], a2[N], b2[N];&#x2F;&#x2F;1段+-type，2段+-type\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid bfs() &#123;&#x2F;&#x2F;预处理d f\n\tt &#x3D; log(n) &#x2F; log(2);&#x2F;&#x2F;树高\n\tq.push(1); d[1] &#x3D; 1;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front(); q.pop();\n\t\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; ver[i];\n\t\t\tif (d[y]) continue;\n\t\t\td[y] &#x3D; d[x] + 1;\n\t\t\tf[y][0] &#x3D; x;\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; t; j++)\n\t\t\t\tf[y][j] &#x3D; f[f[y][j - 1]][j - 1];&#x2F;&#x2F;树上倍增\n\t\t\tq.push(y);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint lca(int x, int y) &#123;\n\tif (d[x] &gt; d[y]) swap(x, y);\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (d[f[y][i]] &gt;&#x3D; d[x]) y &#x3D; f[y][i];\n\tif (x &#x3D;&#x3D; y) return x;\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (f[x][i] !&#x3D; f[y][i]) x &#x3D; f[x][i], y &#x3D; f[y][i];\n\treturn f[x][0];\n&#125;\n\nvoid dfs(int x) &#123;\n\tint val1 &#x3D; c1[d[x] + w[x]], val2 &#x3D; c2[w[x] - d[x] + n];\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (v[y]) continue;\n\t\tdfs(y);\n\t&#125;\n\t&#x2F;&#x2F;全局数组计数\n\tfor (int i &#x3D; 0; i &lt; a1[x].size(); i++) c1[a1[x][i]]++;&#x2F;&#x2F;点x + i_type\n\tfor (int i &#x3D; 0; i &lt; b1[x].size(); i++) c1[b1[x][i]]--;\n\tfor (int i &#x3D; 0; i &lt; a2[x].size(); i++) c2[a2[x][i] + n]++;&#x2F;&#x2F;2段(负)需偏移n\n\tfor (int i &#x3D; 0; i &lt; b2[x].size(); i++) c2[b2[x][i] + n]--;\n\tans[x] +&#x3D; c1[d[x] + w[x]] - val1 + c2[w[x] - d[x] + n] - val2;&#x2F;&#x2F;子树和 区间减法性质\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tadd(x, y), add(y, x);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;w[i]);\n\tbfs();&#x2F;&#x2F;预处理d:depth f[x][k]:x的2^k辈祖先 -&gt; lca\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tint z &#x3D; lca(x, y);\n\t\ta1[x].push_back(d[x]);&#x2F;&#x2F;1+type\n\t\tb1[f[z][0]].push_back(d[x]);&#x2F;&#x2F;1-type\n\t\ta2[y].push_back(d[x] - 2 * d[z]);&#x2F;&#x2F;2+type\n\t\tb2[z].push_back(d[x] - 2 * d[z]);&#x2F;&#x2F;2-type\n\t&#125;\n\tdfs(1);\n\tfor (int i &#x3D; 1; i &lt; n; i++) printf(&quot;%d &quot;, ans[i]);\n\tprintf(&quot;%d\\n&quot;, ans[n]);\n&#125;\n\n\n&#x2F;&#x2F;【LCA的综合应用】\n&#x2F;&#x2F; AcWing 355. 异象石\n&#x2F;&#x2F;Author:XuHt\n#include &lt;set&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 100006;\nint n, m, t, f[N][20], dep[N], dfn[N], tot;\nvector&lt;pair&lt;int, ll&gt; &gt; e[N];\nll d[N], ans;\nset&lt;pair&lt;int, int&gt; &gt; st;\nset&lt;pair&lt;int, int&gt; &gt;::iterator it;\n&#x2F;&#x2F;法2求lca\ninline int lca(int x, int y) &#123;\n\tif (dep[x] &gt; dep[y]) swap(x, y);\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (dep[f[y][i]] &gt;&#x3D; dep[x]) y &#x3D; f[y][i];\n\tif (x &#x3D;&#x3D; y) return x;\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (f[x][i] !&#x3D; f[y][i]) &#123;\n\t\t\tx &#x3D; f[x][i];\n\t\t\ty &#x3D; f[y][i];\n\t\t&#125;\n\treturn f[x][0];\n&#125;\n\ninline ll path(int x, int y) &#123;\n\treturn d[x] + d[y] - (d[lca(x,y)] &lt;&lt; 1);\n&#125;\n\ninline void Insert(int x) &#123;\n\tst.insert(&#123;dfn[x], x&#125;);&#x2F;&#x2F;有序集合 按dfn递增排列 【先insert】\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tauto l &#x3D; it &#x3D;&#x3D; st.begin() ? --st.end() : --it;&#x2F;&#x2F;dfs序前驱(首尾相接)[)-&gt;[]\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tauto r &#x3D; it &#x3D;&#x3D; --st.end() ? st.begin() : ++it;&#x2F;&#x2F;dfs序后继\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);&#x2F;&#x2F;insert(x)\n\tans -&#x3D; path((*l).second, (*r).second);\n\tans +&#x3D; path((*l).second, (*it).second) + path((*it).second, (*r).second);\n&#125;\n\ninline void Remove(int x) &#123;\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tauto l &#x3D; it &#x3D;&#x3D; st.begin() ? --st.end() : --it;\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tauto r &#x3D; it &#x3D;&#x3D; --st.end() ? st.begin() : ++it;\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tans +&#x3D; path((*l).second, (*r).second);\n\tans -&#x3D; path((*l).second, (*it).second) + path((*it).second, (*r).second);\n\tst.erase(&#123;dfn[x], x&#125;);&#x2F;&#x2F;【后erase】\n&#125;\n\nvoid dfs(int x) &#123;&#x2F;&#x2F;dfn dep d f\n\tdfn[x] &#x3D; ++tot;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i].first;\n\t\tif (dep[y]) continue;\n\t\tdep[y] &#x3D; dep[x] + 1;\n\t\tll z &#x3D; e[x][i].second;\n\t\td[y] &#x3D; d[x] + z;\n\t\tf[y][0] &#x3D; x;&#x2F;&#x2F;树上倍增\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; t; j++)\n\t\t\tf[y][j] &#x3D; f[f[y][j-1]][j-1];\n\t\tdfs(y);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y;\n\t\tll z;\n\t\tscanf(&quot;%d %d %lld&quot;, &amp;x, &amp;y, &amp;z);\n\t\te[x].push_back(&#123;y, z&#125;);\n\t\te[y].push_back(&#123;x, z&#125;);\n\t&#125;\n\tt &#x3D; log(n) &#x2F; log(2) + 1;\n\tdep[1] &#x3D; 1;\n\tdfs(1);&#x2F;&#x2F;dfn dep d f\n\tcin &gt;&gt; m;\n\twhile (m--) &#123;\n\t\tchar s[2];\n\t\tscanf(&quot;%s&quot;, s);\n\t\tif (s[0] &#x3D;&#x3D; &#39;?&#39;) printf(&quot;%lld\\n&quot;, ans &gt;&gt; 1);\n\t\telse &#123;\n\t\t\tint x;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\ts[0] &#x3D;&#x3D; &#39;+&#39; ? Insert(x) : Remove(x);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; AcWing 356. 次小生成树\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 100006, M &#x3D; 300006;\nconst ll INF &#x3D; 0x3f3f3f3f3f3f3f3fll;\nint n, m, t, fa[N], d[N], f[N][20];\nstruct P &#123;\n\tint x, y;\n\tll z;\n\tbool k;\n\tbool operator &lt; (const P w) const &#123;\n\t\treturn z &lt; w.z;\n\t&#125;\n&#125; p[M];\nll g[N][20][2], sum, ans &#x3D; INF;\nvector&lt;pair&lt;int, ll&gt; &gt; e[N];\n\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\nvoid kruskal() &#123;\n\tsort(p + 1, p + m + 1);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x &#x3D; get(p[i].x), y &#x3D; get(p[i].y);\n\t\tif (x &#x3D;&#x3D; y) continue;\n\t\tfa[x] &#x3D; y;\n\t\tsum +&#x3D; p[i].z;&#x2F;&#x2F;边权和\n\t\tp[i].k &#x3D; 1;\n\t&#125;\n&#125;\n\nvoid dfs(int x) &#123;&#x2F;&#x2F;d f g\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i].first;\n\t\tif (d[y]) continue;\n\t\td[y] &#x3D; d[x] + 1;\n\t\tf[y][0] &#x3D; x;\n\t\tint z &#x3D; e[x][i].second;\n\t\tg[y][0][0] &#x3D; z;\n\t\tg[y][0][1] &#x3D; -INF;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; t; j++) &#123;\n\t\t\tf[y][j] &#x3D; f[f[y][j-1]][j-1];\n\t\t\tg[y][j][0] &#x3D; max(g[y][j-1][0], g[f[y][j-1]][j-1][0]);\n\t\t\tif (g[y][j-1][0] &#x3D;&#x3D; g[f[y][j-1]][j-1][0])\n\t\t\t\tg[y][j][1] &#x3D; max(g[y][j-1][1], g[f[y][j-1]][j-1][1]);\n\t\t\telse if (g[y][j-1][0] &lt; g[f[y][j-1]][j-1][0])\n\t\t\t\tg[y][j][1] &#x3D; max(g[y][j-1][0], g[f[y][j-1]][j-1][1]);\n\t\t\telse g[y][j][1] &#x3D; max(g[y][j-1][1], g[f[y][j-1]][j-1][0]);\n\t\t&#125;\n\t\tdfs(y);\n\t&#125;\n&#125;\n\ninline void lca(int x, int y, ll &amp;val1, ll &amp;val2) &#123;\n\tif (d[x] &gt; d[y]) swap(x, y);\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (d[f[y][i]] &gt;&#x3D; d[x]) &#123;&#x2F;&#x2F;(v1 v2) &lt;-更新- y(g0 g1)\n\t\t\tif (val1 &gt; g[y][i][0]) val2 &#x3D; max(val2, g[y][i][0]);\n\t\t\telse &#123;\n\t\t\t\tval1 &#x3D; g[y][i][0];\n\t\t\t\tval2 &#x3D; max(val2, g[y][i][1]);\n\t\t\t&#125;\n\t\t\ty &#x3D; f[y][i];\n\t\t&#125;\n\tif (x &#x3D;&#x3D; y) return;\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (f[x][i] !&#x3D; f[y][i]) &#123;\n\t\t\tval1 &#x3D; max(val1, max(g[x][i][0], g[y][i][0]));\n\t\t\t&#x2F;&#x2F;val2&#x3D;max(g[x0],g[x1],g[y0],g[y1]且!&#x3D;val1)\n\t\t\tval2 &#x3D; max(val2, g[x][i][0] !&#x3D; val1 ? g[x][i][0] : g[x][i][1]);\n\t\t\tval2 &#x3D; max(val2, g[y][i][0] !&#x3D; val1 ? g[y][i][0] : g[y][i][1]);\n\t\t\tx &#x3D; f[x][i];\n\t\t\ty &#x3D; f[y][i];\n\t\t&#125;\n\tval1 &#x3D; max(val1, max(g[x][0][0], g[y][0][0]));&#x2F;&#x2F;i-&gt;0父\n\tval2 &#x3D; max(val2, g[x][0][0] !&#x3D; val1 ? g[x][0][0] : g[x][0][1]);\n\tval2 &#x3D; max(val2, g[y][0][0] !&#x3D; val1 ? g[y][0][0] : g[y][0][1]);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d %d %lld&quot;, &amp;p[i].x, &amp;p[i].y, &amp;p[i].z);\n\t\tp[i].k &#x3D; 0;\n\t&#125;\n\tkruskal();\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tif (p[i].k) &#123;\n\t\t\te[p[i].x].push_back(&#123;p[i].y, p[i].z&#125;);&#x2F;&#x2F;add()\n\t\t\te[p[i].y].push_back(&#123;p[i].x, p[i].z&#125;);\n\t\t&#125;\n\tt &#x3D; log(n) &#x2F; log(2) + 1;\n\td[1] &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; t; i++) g[1][i][0] &#x3D; g[1][i][1] &#x3D; -INF;\n\tdfs(1);&#x2F;&#x2F;d f g\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tif (!p[i].k) &#123;&#x2F;&#x2F;非树边\n\t\t\tll val1 &#x3D; -INF, val2 &#x3D; -INF;\n\t\t\tlca(p[i].x, p[i].y, val1, val2);&#x2F;&#x2F;val1 val2\n\t\t\tif (p[i].z &gt; val1) ans &#x3D; min(ans, sum - val1 + p[i].z);\n\t\t\telse ans &#x3D; min(ans, sum - val2 + p[i].z);\n\t\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 357. 疫情控制\n&#x2F;&#x2F;Author:XuHt\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 50006;\nint head[N], Edge[N&lt;&lt;1], Leng[N&lt;&lt;1], Next[N&lt;&lt;1], tot;\nint n, m, t, a[N], b[N], g[N], fa[N][16], sh[N];&#x2F;&#x2F;sh:son_head&#x3D;&#x3D;son_root\nll c[N], d[N], f[N], dis[N][16], sum;\nvector&lt;ll&gt; arv[N];\nqueue&lt;int&gt; q;\nbool v[N], w[N];\n\nvoid add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; head[x];\n\thead[x] &#x3D; tot;\n&#125;\n\nvoid bfs() &#123;&#x2F;&#x2F;fa dis\n\tv[1] &#x3D; 1;\n\tfor (int i &#x3D; head[1]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tq.push(y);\n\t\tv[y] &#x3D; 1;\n\t\tb[sh[y]&#x3D;++t] &#x3D; i;&#x2F;&#x2F;1 - b[y(sh[y]&#x3D;t)]&#x3D;i -&gt; yt\n\t&#125;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i];\n\t\t\tif (v[y]) continue;\n\t\t\tq.push(y);\n\t\t\tv[y] &#x3D; 1;\n\t\t\tfa[y][0] &#x3D; x;\n\t\t\tdis[y][0] &#x3D; Leng[i];\n\t\t\tfor (int j &#x3D; 1; j &lt; 16; j++) &#123;\n\t\t\t\tfa[y][j] &#x3D; fa[fa[y][j-1]][j-1];\n\t\t\t\tdis[y][j] &#x3D; dis[y][j-1] + dis[fa[y][j-1]][j-1];\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nbool dfs(int x) &#123;\n\tv[x] &#x3D; 1;\n\t&#x2F;&#x2F;not son_root &amp;&amp; in_H(驻扎地):第一类 x子树都被管:1\n\tif (!sh[x] &amp;&amp; w[x]) return 1;\n\tbool flag &#x3D; 0;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (v[y]) continue;\n\t\tflag &#x3D; 1;\n\t\tif (!dfs(Edge[i])) return 0;&#x2F;&#x2F;有子节点未被管:0\n\t&#125;\n\treturn flag;&#x2F;&#x2F;子节点都被管了:flag&#x3D;&#x3D;1\n&#125;\n\nbool work(ll now) &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) arv[i].clear();\n\tmemset(v, 0, sizeof(v));\n\tmemset(w, 0, sizeof(w));\n\tv[1] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tg[i] &#x3D; a[i];\n\t\td[i] &#x3D; 0;&#x2F;&#x2F;dis之和\n\t\tfor (int j &#x3D; 15; j &gt;&#x3D; 0; j--)\n\t\t\tif (fa[g[i]][j] &amp;&amp; d[i] + dis[g[i]][j] &lt;&#x3D; now) &#123;\n\t\t\t\td[i] +&#x3D; dis[g[i]][j];\n\t\t\t\tg[i] &#x3D; fa[g[i]][j];\n\t\t\t&#125;\n\t\tw[g[i]] &#x3D; 1;&#x2F;&#x2F;入集合H\n\t\tint j &#x3D; sh[g[i]];&#x2F;&#x2F;1 - b[y(sh[y]&#x3D;t)]&#x3D;i -&gt; yt\n\t\tif (j) &#123;\n\t\t\tarv[j].push_back(now - d[i]);&#x2F;&#x2F;yj.push(rest_i) rest[yj]递减\n\t\t\tif (arv[j].size() &gt; 1 &amp;&amp; now - d[i] &gt; arv[j][arv[j].size()-2])\n\t\t\t\tswap(arv[j][arv[j].size()-1], arv[j][arv[j].size()-2]);\n\t\t&#125;\n\t&#125;\n\tint p &#x3D; 0, q &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tif (!dfs(Edge[b[i]])) &#123;&#x2F;&#x2F; dfs(-&gt;yi)&#x3D;&#x3D;0:yi属于H  min_rest[yj] &lt; 2*len\n\t\t\tif (arv[i].size() &amp;&amp; arv[i][arv[i].size()-1] &lt; (Leng[b[i]] &lt;&lt; 1))\n\t\t\t\tarv[i].pop_back();&#x2F;&#x2F;走不到:出H\n\t\t\telse f[++q] &#x3D; Leng[b[i]];&#x2F;&#x2F;能走到:入剩余集合H\n\t\t&#125;\n\t\tfor (unsigned int j &#x3D; 0; j &lt; arv[i].size(); j++)\n\t\t\tif (arv[i][j] &gt;&#x3D; Leng[b[i]])\n\t\t\t\tc[++p] &#x3D; arv[i][j] - Leng[b[i]];\n\t&#125;\n\tsort(c + 1, c + p + 1);&#x2F;&#x2F;军队：rest-len\n\tsort(f + 1, f + q + 1);&#x2F;&#x2F;H节点:len\n\tif (p &lt; q) return 0;&#x2F;&#x2F;无法完全覆盖：无解\n\tfor (int i &#x3D; q, j &#x3D; p; i; i--, j--)\n\t\tif (c[j] &lt; f[i]) return 0;&#x2F;&#x2F;有军队到不了:无解\n\treturn 1;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t\tsum +&#x3D; z;\n\t&#125;\n\tcin &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\tbfs();\n\tll l &#x3D; 0, r &#x3D; sum + 1;\n\twhile (l &lt; r) &#123;&#x2F;&#x2F;&gt;&#x3D;ans(有解)的min mid] 版本1\n\t\tint mid &#x3D; (l + r) &gt;&gt; 1;\n\t\tif (work(mid)) r &#x3D; mid;\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\tif (l &gt; sum) puts(&quot;-1&quot;);\n\telse cout &lt;&lt; l &lt;&lt; endl;\n\treturn 0;\n&#125;\n--------------------------------------------------\n&#x2F;&#x2F;0x64. 基环树\n&#x2F;&#x2F; AcWing 358. 岛屿\n&#x2F;*\n1.dfs找环，记录来向边（参考割边割点的求法），直到找到第一个非树边时，通过打过的标记将环记录下来（并且要包括边权）。\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;7952&#x2F;\n2.（1类）树形dp，（2类）单调队列处理。\nPS:dfs找环可能会爆栈，所以可以通过bfs+拓扑排序来找环。\n*&#x2F;\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 1000006;\nint Head[N], Edge[N&lt;&lt;1], Leng[N&lt;&lt;1], Next[N&lt;&lt;1], tot;\nint n, du[N], c[N], q[N&lt;&lt;1];\nll f[N], d[N], a[N&lt;&lt;1], b[N&lt;&lt;1], ans;\nbool v[N];\n\ninline void add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n\t++du[y];&#x2F;&#x2F;y入度+1\n&#125;\n\nvoid bfs(int s, int t) &#123;\n\tint l &#x3D; 1, r &#x3D; 1;\n\tc[q[1]&#x3D;s] &#x3D; t;\n\twhile (l &lt;&#x3D; r) &#123;\n\t\tfor (int i &#x3D; Head[q[l]]; i; i &#x3D; Next[i])\n\t\t\tif (!c[Edge[i]]) c[q[++r]&#x3D;Edge[i]] &#x3D; t;\n\t\t++l;\n\t&#125;\n&#125;\n\nvoid topsort() &#123;\n\tint l &#x3D; 1, r &#x3D; 0;&#x2F;&#x2F;r&lt;l\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (du[i] &#x3D;&#x3D; 1) q[++r] &#x3D; i;&#x2F;&#x2F;双向边 (环上的点)入度1入q\n\twhile (l &lt;&#x3D; r) &#123;\n\t\tfor (int i &#x3D; Head[q[l]]; i; i &#x3D; Next[i])\n\t\t\tif (du[Edge[i]] &gt; 1) &#123;&#x2F;&#x2F;P370 树形dp求第一类d[c]:max子树直径\n\t\t\t\td[c[q[l]]] &#x3D; max(d[c[q[l]]], f[q[l]] + f[Edge[i]] + Leng[i]);\n\t\t\t\tf[Edge[i]] &#x3D; max(f[Edge[i]], f[q[l]] + Leng[i]);&#x2F;&#x2F;子树直径f\n\t\t\t\tif (--du[Edge[i]] &#x3D;&#x3D; 1) q[++r] &#x3D; Edge[i];&#x2F;&#x2F;入度-1\n\t\t\t&#125;\n\t\t++l;\n\t&#125;\n&#125;\n&#x2F;&#x2F;考虑第二类\nvoid dp(int t, int x) &#123;\n\tint m &#x3D; 0;&#x2F;&#x2F; 环上点的数量\n\tint y &#x3D; x, k, z &#x3D; 0;\n\tdo &#123;\n\t\ta[++m] &#x3D; f[y];&#x2F;&#x2F; a记录以环上各点为根的子树的直径f\n\t\tdu[y] &#x3D; 1;\n\t\tfor (k &#x3D; Head[y]; k; k &#x3D; Next[k])\n\t\t\tif (du[Edge[k]] &gt; 1) &#123;\n\t\t\t\tb[m+1] &#x3D; b[m] + Leng[k];&#x2F;&#x2F; 环上len前缀和b\n\t\t\t\ty &#x3D; Edge[k];\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t&#125; while (k);\n\tif (m &#x3D;&#x3D; 2) &#123;\n\t\tfor (int i &#x3D; Head[y]; i; i &#x3D; Next[i])\n\t\t\tif (Edge[i] &#x3D;&#x3D; x) z &#x3D; max(z, Leng[i]);\n\t\td[t] &#x3D; max(d[t], f[x] + f[y] + z);&#x2F;&#x2F;~x-(z)-y~\n\t\treturn;\n\t&#125;\n\tfor (int i &#x3D; Head[y]; i; i &#x3D; Next[i])\n\t\tif (Edge[i] &#x3D;&#x3D; x) &#123;\n\t\t\tb[m+1] &#x3D; b[m] + Leng[i];&#x2F;&#x2F;b成环\n\t\t\tbreak;\n\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt; m; i++) &#123;\n\t\ta[m+i] &#x3D; a[i];&#x2F;&#x2F;节点复制\n\t\tb[m+i] &#x3D; b[m+1] + b[i];&#x2F;&#x2F;前缀和+1圈！！！\n\t&#125;\n\tint l &#x3D; 1, r &#x3D; 1;&#x2F;&#x2F;单调队列\n\tq[1] &#x3D; 1;\n\tfor (int i &#x3D; 2; i &lt; (m &lt;&lt; 1); i++) &#123;&#x2F;&#x2F;a(子树直径f)-b(环上dis前缀和)\n\t\tif (l &lt;&#x3D; r &amp;&amp; i - q[l] &gt;&#x3D; m) ++l;\n\t\t&#x2F;&#x2F;d[tr]&#x3D;max(d[tr],f[i]+f[ql]+dis(i,ql))\n\t\td[t] &#x3D; max(d[t], a[i] + a[q[l]] + b[i] - b[q[l]]);&#x2F;&#x2F;ql:max(a-b)\n\t\twhile (l &lt;&#x3D; r &amp;&amp; a[q[r]] - b[q[r]] &lt;&#x3D; a[i] - b[i]) --r;\n\t\tq[++r] &#x3D; i;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123;\n\t\tint y, z;\n\t\tscanf(&quot;%d %d&quot;, &amp;y, &amp;z);\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t&#125;\n\tint t &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (!c[i]) bfs(i, ++t);&#x2F;&#x2F;bfs给森林节点i所在基环树编号c[i]&#x3D;t\n\ttopsort();&#x2F;&#x2F;求d[c]:基环树直径边权和\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (du[i] &gt; 1 &amp;&amp; !v[c[i]]) &#123;&#x2F;&#x2F; 入度大于1:环上的点\n\t\t\tv[c[i]] &#x3D; 1;\n\t\t\tdp(c[i], i);\n\t\t\tans +&#x3D; d[c[i]];&#x2F;&#x2F;各基环树直径和\n\t\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 359. 创世纪\t\t基环树dp\n\n&#x2F;&#x2F;Author:XuHt ??????\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1000006, INF &#x3D; 0x3f3f3f3f;\nint n, fa[N], t, k, f[N][2], s[N][2], ans;\nint Head[N], Edge[N&lt;&lt;1], Next[N&lt;&lt;1], tot;\n\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\ninline void add(int x, int y) &#123;\n\tEdge[++tot] &#x3D; y;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n\nvoid dfs(int x) &#123;\n\tint num &#x3D; INF;\n\tf[x][0] &#x3D; 0;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (y !&#x3D; k) dfs(y);\n\t\tf[x][0] +&#x3D; max(f[y][0], f[y][1]);\n\t\tnum &#x3D; min(num, max(f[y][0], f[y][1]) - f[y][0]);\n\t&#125;\n\tf[x][1] &#x3D; f[x][0] + 1 - num;&#x2F;&#x2F;+1???\n&#125;\n&#x2F;*\nf[x][1] &#x3D; max&#123;Σmax(f[son][0],f[son][1])−max(f[y][0],f[y][1])+f[y][0]&#125;\n\t\t&#x3D; Σmax(f[son][0],f[son][1])−min&#123;max(f[y][0],f[y][1])-f[y][0]&#125;\n\t\t&#x3D; f[x][0] - num\n*&#x2F;\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x;\n\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\tint p &#x3D; get(x), q &#x3D; get(i);\n\t\tif (p &#x3D;&#x3D; q) &#123;\n\t\t\ts[++t][0] &#x3D; x;\n\t\t\ts[t][1] &#x3D; i;\n\t\t&#125; else &#123;\n\t\t\tadd(x, i);&#x2F;&#x2F;\n\t\t\tfa[q] &#x3D; p;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tk &#x3D; 0;\n\t\tdfs(s[i][0]);\n\t\tk &#x3D; s[i][0];&#x2F;&#x2F;Ap 断环\n\t\tdfs(s[i][1]);&#x2F;&#x2F;p\n\t\tint now &#x3D; f[s[i][1]][1];&#x2F;&#x2F;f[p 1]\n\t\tf[s[i][0]][1] &#x3D; f[s[i][0]][0] + 1;&#x2F;&#x2F; 强制连接 p和A[p] 0-&gt;1\n\t\tdfs(s[i][1]);\n\t\tans +&#x3D; max(now, f[s[i][1]][0]);&#x2F;&#x2F;f[p][0]更新ans\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\nhttps:&#x2F;&#x2F;ac.nowcoder.com&#x2F;acm&#x2F;problem&#x2F;blogs&#x2F;51259\n\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\n#include&lt;string.h&gt;\n#include&lt;queue&gt;\n#include&lt;stack&gt;\n#define LL long long\n#define debug cout&lt;&lt;&quot;bug&quot;&lt;&lt;endl;\nusing namespace std;\nconst int maxn&#x3D;1000010;\ninline void read(int &amp;x)&#123;\n\tx&#x3D;0;int f&#x3D;1;char c&#x3D;getchar();\n\twhile(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;)&#123;if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;c&#x3D;getchar();&#125;\n\twhile(c&gt;&#x3D;&#39;0&#39;&amp;&amp;c&lt;&#x3D;&#39;9&#39;) x&#x3D;(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c&#x3D;getchar();\n\tx*&#x3D;f;&#125;\nstruct node&#123;int v,nxt;&#125;e[maxn];\nint head[maxn],tot;\ninline void add(int x,int y)&#123;\n\ttot++;\n\te[tot].v &#x3D;y;\n\te[tot].nxt &#x3D;head[x];\n\thead[x]&#x3D;tot;\n&#125;\nint n,a,cnt,ra[maxn],rb[maxn],now;\n \nint fa[maxn];\ninline int find(int x)\n&#123;\n\tif(fa[x]&#x3D;&#x3D;x) return x;\n\treturn fa[x] &#x3D; find(fa[x]);\n&#125;\n \nint f[maxn],g[maxn];&#x2F;&#x2F;f 放 g 不放\ninline void dfs(int x)\n&#123;\n\tint t&#x3D;1&lt;&lt;30;\n\tg[x]&#x3D;0;\n\tfor(int i&#x3D;head[x];i;i&#x3D;e[i].nxt )\n\t&#123;\n\t\tint v&#x3D;e[i].v ;\n\t\tif(v!&#x3D;now)\n\t\t\tdfs(v);\n\t\tg[x]+&#x3D;max(g[v],f[v]);\n\t\tt&#x3D;min(t, max(g[v],f[v])-g[v] ); &#x2F;&#x2F;没有上司的舞会中的技巧\n\t&#125;\n\tf[x]&#x3D;g[x]+1-t;\n&#125;\nint main()\n&#123;\n\tint ans&#x3D;0;\n\tread(n);\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++) fa[i]&#x3D;i;\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\t&#123;\n\t\tread(a);\n\t\tif(find(a)!&#x3D;find(i))\n\t\t&#123;\n\t\t\tadd(a,i);\n\t\t\tfa[fa[a]]&#x3D;fa[i];\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tcnt++,ra[cnt]&#x3D;a,rb[cnt]&#x3D;i;&#x2F;&#x2F;本身在环上是不连通的\n\t\t&#125;\n\t&#125;\n\tfor(int i&#x3D;1;i&lt;&#x3D;cnt;i++)&#x2F;&#x2F;森林\n\t&#123;\n\t\tdfs(ra[i]);\n\t\tnow&#x3D;ra[i];&#x2F;&#x2F;断环\n\t\tdfs(rb[i]),a&#x3D;f[rb[i]];&#x2F;&#x2F;在这一轮的dfs中是不会去更新 ra[i]儿子的f g值的，导致本身没有ra[i]的值也是没有的，所以需要上一个提前处理出来\n\t\tf[ra[i]]&#x3D;g[ra[i]]+1;&#x2F;&#x2F;强行链接 （在max中程序一定会选择f，它本身的限制节点rb[i]不会被选中 所以有限制他的充分条件）\n\t\tdfs(rb[i]), ans+&#x3D;max(g[rb[i]],a);\n\t&#125;\n\tprintf(&quot;%d&quot;,ans);\n\treturn 0;\n&#125;\n并查集只可以查找到这个环的一处，如果需要查找整个环那就只有前面页讲到的模板了。\n\n这里提出注意事项：在第一个dfs中我们对f是强行负值，这样对于一些叶子节点来讲t值是没有更改的，这就导致f值在最后是一个极小值，这样的f是不会更新答案的。如果不写第一个dfs，使得一些在本不能更新答案的点更新了答案，导致答案错误。所以第一个dfs是必要的。\n&#x2F;&#x2F; 同类型题目 骑士 推荐一做：https:&#x2F;&#x2F;www.luogu.org&#x2F;problem&#x2F;P2607\n\n\n&#x2F;*\n另解（贪心）：对于一个入度为0的点x，由于x无法被控制，所以只能不选。\n那么选择x控制的节点a[x]投放一定是最优的。 在选择a[x]之后，a[a[x]]就不能被\na[x]限制了，把他的度数-1，如果a[a[x]]的度数&#x3D;0，说明他也可以去限制别人了，\n就把他加入待转移集合中。可以用一个队列来实现这个操作。\n\n但是以上的转移完成之后，以上的贪心方法类似于拓扑，所以不适用于环，\n环上的点是不会被加入集合的！但是我们发现对于一个长度为cnt的环，\n可以选择投放的点为cnt&#x2F;2个（隔一个选一个），那么求出每一颗内向树环的长度即可。\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;CABI_ZGX&#x2F;article&#x2F;details&#x2F;83501714\n*&#x2F;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N&#x3D;1e6+10;\ninline int read()\n&#123;\n\tint x&#x3D;0,f&#x3D;1; char ch&#x3D;getchar();\n\twhile(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)f&#x3D;-1; ch&#x3D;getchar();&#125;\n\twhile(ch&gt;&#x3D;&#39;0&#39; &amp;&amp; ch&lt;&#x3D;&#39;9&#39;)&#123;x&#x3D;x*10+ch-&#39;0&#39;; ch&#x3D;getchar();&#125;\n\treturn x*f;\t\n&#125;\nint a[N],du[N],list[N],head,tail;\nbool v[N];\n\nint main()\n&#123;\n\tint n&#x3D;read();\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\t&#123;\n\t\ta[i]&#x3D;read();\n\t\tdu[a[i]]++;\n\t&#125;\n\thead&#x3D;1; tail&#x3D;0;\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\t\tif(du[i]&#x3D;&#x3D;0)\n\t\t\tlist[++tail]&#x3D;i;\n\tint ans&#x3D;0;\n\twhile(head&lt;&#x3D;tail)\n\t&#123;\n\t\tint x&#x3D;list[head];\n\t\tif(!v[x] &amp;&amp; !v[a[x]])\n\t\t&#123;\n\t\t\tans++; \t\n\t\t\tv[a[x]]&#x3D;1; \n\t\t\tdu[a[a[x]]]--; if(du[a[a[x]]]&#x3D;&#x3D;0) list[++tail]&#x3D;a[a[x]];\n\t\t&#125;\n\t\tv[list[head]]&#x3D;1; head++;\n\t&#125;\n\tint cnt&#x3D;0,j;\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\t&#123;\n\t\tif(!v[i])\n\t\t&#123;\n\t\t\tcnt&#x3D;0;\n\t\t\tj&#x3D;i;\n\t\t\twhile(a[j]!&#x3D;i)\n\t\t\t&#123;\n\t\t\t\tv[j]&#x3D;1;\n\t\t\t\tcnt++;\n\t\t\t\tj&#x3D;a[j];\t\n\t\t\t&#125;\n\t\t\tv[j]&#x3D;1;\n\t\t\tans+&#x3D;(cnt+1)&#x2F;2;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;,ans);\n\treturn 0;\n&#125;\n--------------------------------------------------\n&#x2F;&#x2F; AcWing 360. Freda的传呼机\n&#x2F;*\n静态边仙人掌(圆方树)\n前置知识： 运用Tarjan求点双联通分量v-DCC\n学习时参见的博客： https:&#x2F;&#x2F;www.luogu.org&#x2F;blog&#x2F;PinkRabbit&#x2F;Introduction-to-Round-Square-Tree\n时间复杂度分析：Θ(n+qlogn)\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;3936&#x2F;\n*&#x2F;\n\n\n\n\n\n&#x2F;&#x2F;0x65. 负环与差分约束\n&#x2F;&#x2F; AcWing 361. 观光奶牛\n&#x2F;*\npoj3621 sightseeing cow解题报告\nhttps:&#x2F;&#x2F;wenku.baidu.com&#x2F;view&#x2F;f2a563d076eeaeaad1f3305e.html\n2007NOI国家集训队论文_day2《最小割模型在信息学竞赛中的应用》 胡伯涛\n*&#x2F;\n&#x2F;&#x2F;最优比率环\n&#x2F;&#x2F;Author:XuHt\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 1006, M &#x3D; 5006;\nconst double eps &#x3D; 1e-6;\nint n, m, c[N], f[N], x[M], y[M], z[M];\nint Head[N], Edge[M], Next[M], tot;\ndouble Leng[M], d[N];\nbool v[N];\n\nvoid add(int x, int y, double z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n&#x2F;*\n负环的原理就是说存在一个长度为n的最短路路径，这样无限走肯定有个负环。\n那么其实跑的是一个多源的最短路，要【检查每个点出发能否无限走】最短路，所以这里dis具体是多少没有多大意义，只是为了表达相对大小关系，如果存在负环，即可以一直更新一直走~ \t\t所以d[i] &#x3D; 0; v[i] &#x3D; 1;&#x2F;&#x2F;全in_queue init_0\n*&#x2F;\nbool spfa() &#123;\n\tqueue&lt;int&gt; q;\n\t&#x2F;&#x2F; memset(d, 0x3f, sizeof d);\n\t&#x2F;&#x2F; d[1] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tq.push(i);\n\t\td[i] &#x3D; 0;&#x2F;&#x2F;\n\t\tv[i] &#x3D; 1;&#x2F;&#x2F;\n\t&#125;\n\tmemset(c, 0, sizeof(c));&#x2F;&#x2F;c&#x3D;&#x3D;cnt\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tv[x] &#x3D; 0;\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i];\n\t\t\tif (d[y] &gt; d[x] + Leng[i]) &#123;\n\t\t\t\td[y] &#x3D; d[x] + Leng[i];\n\t\t\t\tif (++c[y] &gt;&#x3D; n) return 1;\n\t\t\t\tif (!v[y]) &#123;\n\t\t\t\t\tq.push(y);\n\t\t\t\t\tv[y] &#x3D; 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nbool check(double w) &#123;\n\ttot &#x3D; 0;\n\tmemset(Head, 0, sizeof(Head));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tadd(x[i], y[i], w * z[i] - f[x[i]]);\n\treturn spfa();&#x2F;&#x2F;有负环 mid&lt;ans\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d&quot;, &amp;f[i]);&#x2F;&#x2F;f:点权\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x[i], &amp;y[i], &amp;z[i]);&#x2F;&#x2F;z:边权\n\tdouble l &#x3D; 0, r &#x3D; 1000;\n\twhile (r - l &gt; eps) &#123;&#x2F;&#x2F;&gt;eps：从简l&#x3D;mid r&#x3D;mid\n\t\tdouble mid &#x3D; (l + r) &#x2F; 2;\n\t\tif (check(mid)) l &#x3D; mid;\n\t\telse r &#x3D; mid;\n\t&#125;\n\tprintf(&quot;%.2f&quot;, l);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;【差分约束系统】\n&#x2F;&#x2F; AcWing 362. 区间\n&#x2F;&#x2F;Author:XuHt\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 500006, M &#x3D; 5000006;\nint n, m, d[N];\nint Head[N], Edge[M], Leng[M], Next[M], tot;\nbool v[N];\n\ninline void add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n\nvoid spfa() &#123;&#x2F;&#x2F;模板\n\tqueue&lt;int&gt; q;\n\tq.push(0);\n\tv[0] &#x3D; 1;\n\td[0] &#x3D; 0;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tv[x] &#x3D; 0;\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i];\n\t\t\tif (d[y] &lt; d[x] + Leng[i]) &#123;&#x2F;&#x2F;单源最长路\n\t\t\t\td[y] &#x3D; d[x] + Leng[i];\n\t\t\t\tif (!v[y]) &#123;\n\t\t\t\t\tv[y] &#x3D; 1;\n\t\t\t\t\tq.push(y);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tmemset(d, 0xcf, sizeof(d));\n\ttot &#x3D; m &#x3D; 0;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\tadd(x, y + 1, z);&#x2F;&#x2F;? add(x - 1, y, z);\n\t\tm &#x3D; max(m, y + 1);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tadd(i - 1, i, 0);\n\t\tadd(i, i - 1, -1);\n\t&#125;\n\tspfa();\n\tcout &lt;&lt; d[m] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 贪心 + 数据结构做法\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;6528&#x2F;\n朴素贪心\n考虑把所有线段按照右端点 b 从小到大排序，依次考虑每一条线段的要求：\n\n如果已经满足要求则跳过\n否则尽量选择靠后的数（因为之后的线段的右端点都在这条线段的右边，这样容错更高）\n所以，我们可以建一个数组，d[i] 表示 i 数字是否选择（填1或0），\n【扫一遍 [l,r] 区间求和】，然后【从后往前贪心放数】即可。\n\n对于每条线段需要 O(r−l+1)。所以最坏情况下 O(n2)。但是轻松 52ms 过了。\n\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 50005;\nint n, d[N], c[N];\nstruct Seg&#123;\n\tint a, b, c;\n\tbool operator &lt; (const Seg &amp;x) const &#123;\n\t\treturn b &lt; x.b;\n\t&#125;\n&#125;e[N];\nint main() &#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d%d%d&quot;, &amp;e[i].a, &amp;e[i].b, &amp;e[i].c);\n\tsort(e + 1, e + 1 + n);\n\tint ans &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint l &#x3D; e[i].a, r &#x3D; e[i].b, cnt &#x3D; e[i].c;\n\t\tfor (int j &#x3D; l; j &lt;&#x3D; r; j++)\n\t\t\tcnt -&#x3D; d[j];&#x2F;&#x2F;\n\t\tif(cnt &gt; 0) &#123;\n\t\t\tfor (int j &#x3D; r; j &gt;&#x3D; l &amp;&amp; cnt; j--)&#x2F;&#x2F;&lt;-\n\t\t\t\tif(!d[j]) cnt--, ans++, d[j] &#x3D; 1;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, ans);\n\treturn 0;\n&#125;\n\n优化\n考虑用数据结构优化。\n\n发现我们需要三个操作：\n\n询问 [l,r] 区间的数字个数\n将值为 x 的位置 +1\n从后往前，找到比当前位置靠前的下一个 0 的位置。\n\n前两个就是 “区间求和，单调修改”，典型的树状数组。O(nlog50000)\n第三种操作，可以用并查集优化。为什么可以确保时间复杂度呢？对于每一条线段，最多只有一次会枚举到 1 （即开始的那一次），之后每次枚举都会枚举到 0 的位置，即d[i]&#x3D;0，然后把它变成 1，而以后就不会访问到了。而一共有 50000 个值，所以复杂度是 O(50000logn)\t33ms\n\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 50001;\nint n, d[N], c[N], f[N];\nstruct Seg&#123;\n\tint a, b, c;\n\tbool operator &lt; (const Seg &amp;x) const &#123;\n\t\treturn b &lt; x.b;\n\t&#125;\n&#125;e[N];\n&#x2F;&#x2F; 树状数组\nint inline ask(int x) &#123;\n\tint res &#x3D; 0;\n\tfor (; x; x -&#x3D; x &amp; -x) res +&#x3D; c[x];&#x2F;&#x2F;向左\n\treturn res;\n&#125;\n\nvoid inline add(int x) &#123;\n\tfor (; x &lt; N; x +&#x3D; x &amp; -x) c[x]++;&#x2F;&#x2F;向上\n&#125;\n&#x2F;&#x2F; 并查集：find(x) 表示找到 &lt;&#x3D; x 中最大的一个是 0 的数\nint find(int x) &#123;\n\treturn x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; find(f[x]);&#x2F;&#x2F;f[j]&#x3D;&#x3D;find(j-1)\n&#125;\nint main() &#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 0; i &lt; N; i++) f[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) \n\t\tscanf(&quot;%d%d%d&quot;, &amp;e[i].a, &amp;e[i].b, &amp;e[i].c);\n\tsort(e + 1, e + 1 + n);\n\tint ans &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint l &#x3D; e[i].a, r &#x3D; e[i].b, cnt &#x3D; e[i].c;\n\t\t&#x2F;&#x2F; 取 [l, r] 选了多少个数\n\t\tcnt -&#x3D; ask(r) - ask(l - 1);\n\t\tif(cnt &gt; 0) &#123;\n\t\t\tfor (int j &#x3D; r; j &gt;&#x3D; l &amp;&amp; cnt; ) &#123;\n\t\t\t\t&#x2F;&#x2F; d[j] &#x3D;&#x3D; 1 的情况每条线段至多出现一次\n\t\t\t\tif(!d[j]) &#123;\n\t\t\t\t\tcnt--, ans++, d[j] &#x3D; 1;\n\t\t\t\t\t&#x2F;&#x2F; j 被标记成 1 了，要指向 find(j - 1)\n\t\t\t\t\tf[j] &#x3D; j - 1;\n\t\t\t\t\t&#x2F;&#x2F; 维护树状数组\n\t\t\t\t\tadd(j);\n\t\t\t\t&#125;;\n\t\t\t\tif(find(j) !&#x3D; j) j &#x3D; f[j];&#x2F;&#x2F;路径压缩:f[j]&#x3D;&#x3D;find(j-1)！！！\n\t\t\t\telse j--;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, ans);\n\treturn 0;\n&#125;\n\n作者：墨染空\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;6528&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;0x66. Tarjan算法与无向图连通性\n&#x2F;&#x2F; AcWing 363. B城\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100010, M &#x3D; 500010;\nint head[N], ver[M * 2], Next[M * 2];\nint dfn[N], low[N], Size[N];\nlong long ans[N];\nbool cut[N];\nint n, m, tot, num;\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid tarjan(int x) &#123;&#x2F;&#x2F;割点判定\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tSize[x] &#x3D; 1;&#x2F;&#x2F;\n\tint flag &#x3D; 0, sum &#x3D; 0;&#x2F;&#x2F;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y);\n\t\t\tSize[x] +&#x3D; Size[y];&#x2F;&#x2F;\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t\tif (low[y] &gt;&#x3D; dfn[x]) &#123;\n\t\t\t\tflag++;\n\t\t\t\tans[x] +&#x3D; (long long)Size[y] * (n - Size[y]);&#x2F;&#x2F;\n\t\t\t\tsum +&#x3D; Size[y];&#x2F;&#x2F;\n\t\t\t\tif (x !&#x3D; 1 || flag &gt; 1) cut[x] &#x3D; true;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse low[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n\tif (cut[x])&#x2F;&#x2F;\n\t\tans[x] +&#x3D; (long long)(n - sum - 1)*(sum + 1) + (n - 1);\n\telse\n\t\tans[x] &#x3D; 2 * (n - 1);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\ttot &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tif (x &#x3D;&#x3D; y) continue;\n\t\tadd(x, y), add(y, x);\n\t&#125;\n\ttarjan(1);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tprintf(&quot;%lld\\n&quot;, ans[i]);\n&#125;\n\n&#x2F;&#x2F; AcWing 364. 网络\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int N &#x3D; 200010;\nint head[N], ver[N * 2], Next[N * 2];\nint dfn[N], low[N], c[N];\nint n, m, t, tot, num, dcc, tc, T;\nbool bridge[N * 2], v[N];\nint hc[N], vc[N * 2], nc[N * 2];\nint d[N], f[N][20], fa[N];\nqueue&lt;int&gt; q;\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid add_c(int x, int y) &#123;\n\tvc[++tc] &#x3D; y, nc[tc] &#x3D; hc[x], hc[x] &#x3D; tc;\n&#125;\n\nvoid tarjan(int x, int in_edge) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y, i);&#x2F;&#x2F;\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t\tif (low[y] &gt; dfn[x])\n\t\t\t\tbridge[i] &#x3D; bridge[i ^ 1] &#x3D; true;\n\t\t&#125;\n\t\telse if (i !&#x3D; (in_edge ^ 1))&#x2F;&#x2F;忽略(入边^1)\n\t\t\tlow[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n&#125;\n\nvoid dfs(int x) &#123;\n\tc[x] &#x3D; dcc;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (c[y] || bridge[i]) continue;&#x2F;&#x2F;忽略bridge\n\t\tdfs(y);\n\t&#125;\n&#125;\n\nvoid bfs() &#123;\n\tq.push(1);\n\td[1] &#x3D; 1;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int i &#x3D; hc[x]; i; i &#x3D; nc[i]) &#123;\n\t\t\tint y &#x3D; vc[i];\n\t\t\tif (d[y]) continue;\n\t\t\td[y] &#x3D; d[x] + 1;\n\t\t\tf[y][0] &#x3D; x;\n\t\t\tfor (int j &#x3D; 1; j &lt; 18; j++)\n\t\t\t\tf[y][j] &#x3D; f[f[y][j - 1]][j - 1];\n\t\t\tq.push(y);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint lca(int x, int y) &#123;\n\tif (d[x] &lt; d[y]) swap(x, y);\n\tfor (int i &#x3D; 17; i &gt;&#x3D; 0; i--)\n\t\tif (d[f[x][i]] &gt;&#x3D; d[y]) x &#x3D; f[x][i];\n\tif (x &#x3D;&#x3D; y) return x;\n\tfor (int i &#x3D; 17; i &gt;&#x3D; 0; i--)\n\t\tif (f[x][i] !&#x3D; f[y][i]) x &#x3D; f[x][i], y &#x3D; f[y][i];\n\treturn f[x][0];\n&#125;\n\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;\n\t\t&#x2F;&#x2F; 多组数据，清零\n\t\ttot &#x3D; 1; num &#x3D; dcc &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\thead[i] &#x3D; dfn[i] &#x3D; hc[i] &#x3D; d[i] &#x3D; c[i] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; 2 * m + 1; i++)\n\t\t\tbridge[i] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\t\tint x, y;\n\t\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\t\tadd(x, y), add(y, x);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 求割边、边双连通分量\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!dfn[i]) tarjan(i, 0);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!c[i]) &#123;\n\t\t\t\t++dcc;\n\t\t\t\tdfs(i);\n\t\t\t&#125;\n\t\t&#x2F;&#x2F; 缩点建图\n\t\ttc &#x3D; 1;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;\n\t\t\tint x &#x3D; ver[i ^ 1], y &#x3D; ver[i];\n\t\t\tif (c[x] &#x3D;&#x3D; c[y]) continue;\n\t\t\tadd_c(c[x], c[y]);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 倍增lca预处理\n\t\tbfs();&#x2F;&#x2F;d:dep f\n\t\t&#x2F;&#x2F; 并查集初始化\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; dcc; i++) fa[i] &#x3D; i;\n\t\t&#x2F;&#x2F; 处理询问\n\t\tcin &gt;&gt; t;\n\t\tint ans &#x3D; dcc - 1;&#x2F;&#x2F;总桥数\n\t\tprintf(&quot;Case %d:\\n&quot;, ++T);\n\t\twhile (t--) &#123;\n\t\t\tint x, y;\n\t\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\t\tx &#x3D; c[x], y &#x3D; c[y];\n\t\t\tint p &#x3D; lca(x, y);\n\t\t\t&#x2F;&#x2F;并查集路径压缩优化\n\t\t\tx &#x3D; get(x);\n\t\t\twhile (d[x] &gt; d[p]) &#123;\n\t\t\t\tfa[x] &#x3D; f[x][0];\n\t\t\t\tans--;\n\t\t\t\tx &#x3D; get(x);\n\t\t\t&#125;\n\t\t\ty &#x3D; get(y);\n\t\t\twhile (d[y] &gt; d[p]) &#123;\n\t\t\t\tfa[y] &#x3D; f[y][0];\n\t\t\t\tans--;\n\t\t\t\ty &#x3D; get(y);\n\t\t\t&#125;\n\t\t\tprintf(&quot;%d\\n&quot;, ans);\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 365. 圆桌骑士\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\nconst int N &#x3D; 1010, M &#x3D; 2000010;\nint head[N], ver[M], Next[M];\nint dfn[N], low[N], stack[N];\nint c[N], v[N], able[N];\nint n, m, tot, num, top, cnt, now;\nbool hate[N][N], flag;\nvector&lt;int&gt; dcc[N];\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid tarjan(int x, int root) &#123;&#x2F;&#x2F;v-dcc\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tstack[++top] &#x3D; x;\n\tif (x &#x3D;&#x3D; root &amp;&amp; head[x] &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 孤立点\n\t\tdcc[++cnt].push_back(x);\n\t\treturn;\n\t&#125;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y, root);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t\tif (low[y] &gt;&#x3D; dfn[x]) &#123;\n\t\t\t\tcnt++;\n\t\t\t\tint z;\n\t\t\t\tdo &#123;\n\t\t\t\t\tz &#x3D; stack[top--];\n\t\t\t\t\tdcc[cnt].push_back(z);\n\t\t\t\t&#125; while (z !&#x3D; y);\n\t\t\t\tdcc[cnt].push_back(x);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse low[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n&#125;\n\nvoid dfs(int x, int color) &#123;\n\tc[x] &#x3D; color;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (v[y] !&#x3D; now) continue;&#x2F;&#x2F;\n\t\tif (c[y] &amp;&amp; c[y] &#x3D;&#x3D; color) &#123;\n\t\t\tflag &#x3D; 1;&#x2F;&#x2F;非二分图 存在奇环\n\t\t\treturn;\n\t\t&#125;\n\t\tif (!c[y]) dfs(y, 3 - color);\n\t&#125;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;\n\t\t&#x2F;&#x2F; 清零\n\t\tmemset(head, 0, sizeof(head));\n\t\tmemset(dfn, 0, sizeof(dfn));\n\t\tmemset(able, 0, sizeof(able));\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) dcc[i].clear();\n\t\ttot &#x3D; 1; num &#x3D; top &#x3D; cnt &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) hate[i][j] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\t\tint x, y;\n\t\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\t\tif (x &#x3D;&#x3D; y) continue;\n\t\t\thate[x][y] &#x3D; hate[y][x] &#x3D; 1;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 建补图\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t\tfor (int j &#x3D; i + 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif (!hate[i][j]) add(i, j), add(j, i);\n\t\t&#x2F;&#x2F; 求点双连通分量\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!dfn[i]) tarjan(i, i);\n\t\t&#x2F;&#x2F; 判断每个点双是否包含奇环\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;\n\t\t\tnow &#x3D; i;\n\t\t\tfor (int j &#x3D; 0; j &lt; dcc[i].size(); j++)\n\t\t\t\tv[dcc[i][j]] &#x3D; now, c[dcc[i][j]] &#x3D; 0;&#x2F;&#x2F;v:所在dcc c:colorinit_0\n\t\t\tflag &#x3D; false;\n\t\t\tdfs(dcc[i][0], 1);&#x2F;&#x2F;dfs(x,color) 染色法judge: 二分图&#x3D;无奇环\n\t\t\tif (flag)&#x2F;&#x2F;dcc中存在奇环\n\t\t\t\tfor (int j &#x3D; 0; j &lt; dcc[i].size(); j++)\n\t\t\t\t\table[dcc[i][j]] &#x3D; 1;\n\t\t&#125;\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!able[i]) ans++;\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 366. 看牛\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint head[10010], ver[100010], Next[100010], tot; &#x2F;&#x2F; 邻接表\nint stack[100010], ans[100010]; &#x2F;&#x2F; 模拟系统栈，答案栈\nbool vis[100010];\nint n, m, top, t;\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid euler() &#123;\n\tstack[++top] &#x3D; 1;\n\twhile (top &gt; 0) &#123;\n\t\tint x &#x3D; stack[top], i &#x3D; head[x];\n\t\t&#x2F;&#x2F; 找到一条尚未访问的边\n\t\twhile (i &amp;&amp; vis[i]) i &#x3D; Next[i];\n\t\t&#x2F;&#x2F; 沿着这条边模拟递归过程，标记该边，并更新表头\n\t\tif (i) &#123;\n\t\t\tstack[++top] &#x3D; ver[i];\n\t\t\thead[x] &#x3D; Next[i];\n\t\t\t&#x2F;&#x2F; vis[i] &#x3D; vis[i ^ 1] &#x3D; true;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 与x相连的所有边均已访问，模拟回溯过程，并记录\n\t\telse &#123;\n\t\t\ttop--;\n\t\t\tans[++t] &#x3D; x;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\ttot &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tadd(x, y), add(y, x);\n\t&#125;\n\teuler();\n\tfor (int i &#x3D; t; i; i--) printf(&quot;%d\\n&quot;, ans[i]);\n&#125;\n\n\n&#x2F;&#x2F;0x67. Tarjan算法与有向图连通性\n&#x2F;&#x2F; AcWing 367. 学校网络\n&#x2F;*\n问题二\n结论\n若 scc_cnt&#x3D;1（只有一个强连通分量），则不需要连新的边，答案为 0。\n若 scc_cnt&gt;1，则答案为 max(src,des)。\n证明（yxc讲解总结）\n结论 1 正确性显然，下面证明结论 2。\n\n设缩点后的 DAG 中，起点（入度为 0）的集合为 P，终点（出度为 0）的集合为 Q。分以下两种情况讨论：\n\n|P|≤|Q|\n① 若 |P|&#x3D;1，则只有一个起点，并且这个起点能走到所有点，只要将每一个终点都向这个起点连一条边，那么对于图中任意一点，都可以到达所有点，新加的边数为 |Q|。\n\n② 若 |P|≥2，则 |Q|≥|P|≥2，此时至少存在 2 个起点 p1,p2，2 个终点 q1,q2，满足 p1 能走到 q1，p2 能走到 q2。（反证法：如果不存在两个起点能走到不同的终点，则所有的起点一定只能走到同一个终点，而终点至少有两个，发生矛盾，假设不成立）。如下图：\n\n那么我们可以从 q1 向 p2 新连一条边，那么此时起点和终点的个数都会减少一个（p2 不再是起点，q1 不再是终点），因此只要以这种方式，连接新边 |P|−1 条，则 |P′|&#x3D;1，而 |Q′|&#x3D;|Q|−(|P|−1)，由 ① 得，当 |P′|&#x3D;1 时，需要再连 |Q′| 条新边，那么总添加的新边数量为 |P|−1+|Q|−(|P|−1)&#x3D;|Q|。\n\n|Q|≤|P|\n与情况 1 对称，此时答案为 |P|。\n\n综上所述，scc_cnt&gt;1 时，问题二的答案为 max(|P|,|Q|) 即 max(src,des)。\n*&#x2F;\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 106;\nint n, dfn[N], low[N], num &#x3D; 0;\nint st[N], top &#x3D; 0, tot &#x3D; 0, c[N], ru[N], chu[N];\nbool v[N];\nvector&lt;int&gt; e[N], scc[N], sc[N];\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tst[++top] &#x3D; x;\n\tv[x] &#x3D; 1;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t&#125; else if (v[y]) low[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n&#x2F;*\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\tv[x] &#x3D; 0;\n\t\tscc[++tot].push_back(x);\n\t\tc[x] &#x3D; tot;\n\t\tint y;\n\t\twhile (x !&#x3D; (y &#x3D; st[top--])) &#123;\n\t\t\tscc[tot].push_back(y);\n\t\t\tv[y] &#x3D; 0;\n\t\t\tc[y] &#x3D; tot;\n\t\t&#125;\n\t&#125;*&#x2F;\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\ttot++; int y;\n\t\tdo &#123;\n\t\t\ty &#x3D; st[top--];\n\t\t\tscc[tot].push_back(y);\n\t\t\tv[y] &#x3D; 0;\n\t\t\tc[y] &#x3D; tot;\n\t\t&#125; while (x !&#x3D; y);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x;\n\t\twhile (scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x) e[i].push_back(x); &#x2F;&#x2F;i 应该支援的学校\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (!dfn[i]) tarjan(i);\n\tfor (int x &#x3D; 1; x &lt;&#x3D; n; x++)\n\t\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\t\tint y &#x3D; e[x][i];\n\t\t\tif (c[x] &#x3D;&#x3D; c[y]) continue;&#x2F;&#x2F;\n\t\t\t&#x2F;&#x2F; sc[c[x]].push_back(c[y]);\n\t\t\tru[c[y]]++;\n\t\t\tchu[c[x]]++;\n\t\t&#125;\n\tint ansa &#x3D; 0, ansb &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++) &#123;\n\t\tif (!ru[i]) ansa++;\n\t\tif (!chu[i]) ansb++;\n\t&#125;\n\tcout &lt;&lt; ansa &lt;&lt; endl;\n\tint ans &#x3D; max(ansa, ansb);\n\tif (tot &#x3D;&#x3D; 1) puts(&quot;0&quot;);\n\telse cout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; AcWing 368. 银河\n&#x2F;&#x2F;Author:XuHt\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 100006;\nint n, m, num, top, cnt;\nint d[N], dfn[N], low[N], st[N], c[N], deg[N], f[N], scc[N];\nbool ins[N];\nvector&lt;pair&lt;int, int&gt; &gt; e[N], ec[N];\nqueue&lt;int&gt; q;\n\ninline void add(int x, int y, int z) &#123;\n\te[x].push_back(&#123;y, z&#125;);\n&#125;\n\ninline void addc(int x, int y, int z) &#123;\n\tec[x].push_back(&#123;y, z&#125;);\n\t++deg[y];\n&#125;\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tst[++top] &#x3D; x;\n\tins[x] &#x3D; 1;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i].first;\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t&#125; else if (ins[y])\n\t\t\tlow[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\t++cnt;\n\t\tint y;\n\t\tdo &#123;\n\t\t\ty &#x3D; st[top--];\n\t\t\tins[y] &#x3D; 0;\n\t\t\tc[y] &#x3D; cnt;\n\t\t\t++scc[cnt];&#x2F;&#x2F;scc_size\n\t\t&#125; while (y !&#x3D; x);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint o, a, b;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;o, &amp;a, &amp;b);\n\t\tif (o &#x3D;&#x3D; 2) add(a, b, 1);\n\t\telse if (o &#x3D;&#x3D; 3) add(b, a, 0);\n\t\telse if (o &#x3D;&#x3D; 4) add(b, a, 1);\n\t\telse if (o &#x3D;&#x3D; 5) add(a, b, 0);\n\t\telse &#123;\n\t\t\tadd(a, b, 0);\n\t\t\tadd(b, a, 0);\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) add(0, i, 1);\n\ttarjan(0);\n\tfor (int x &#x3D; 0; x &lt;&#x3D; n; x++)\n\t\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\t\tint y &#x3D; e[x][i].first, z &#x3D; e[x][i].second;\n\t\t\tif (c[x] &#x3D;&#x3D; c[y]) &#123;&#x2F;&#x2F;scc内存在边权为1：无解\n\t\t\t\tif (!z) continue;\n\t\t\t\tputs(&quot;-1&quot;);\n\t\t\t\treturn 0;\n\t\t\t&#125;\n\t\t\taddc(c[x], c[y], z);\n\t\t&#125;\n\t&#x2F;&#x2F;拓扑序DP最长路\n\tfor (int i &#x3D; 1; i &lt;&#x3D; cnt; i++)\n\t\tif (!deg[i]) q.push(i);\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (unsigned int i &#x3D; 0; i &lt; ec[x].size(); i++) &#123;\n\t\t\tint y &#x3D; ec[x][i].first, z &#x3D; ec[x][i].second;\n\t\t\tf[y] &#x3D; max(f[y], f[x] + z);&#x2F;&#x2F;最长路\n\t\t\tif (!--deg[y]) q.push(y);\n\t\t&#125;\n\t&#125;\n\tll ans &#x3D; 0;&#x2F;&#x2F;f[i]:最长路 &#x3D;&#x3D; scc[i]内所有点的最小亮度\n\tfor (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) ans +&#x3D; (ll)f[i] * scc[i];\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 369. 北大ACM队的远足 SCC 有向图必经边_bri\n&#x2F;*\n一条边可能覆盖两次，并且覆盖的不一定是连续的桥\n\n特判没有路径的无解情况\n\n错误的拓扑排序求最短路方式，即只把 s 起点塞到队列里进行拓扑排序，若有一些零度点指向了该路径上的一些点，由于零度点并没有进入刷新，所以那些点的度不会被减到 0，从而就炸裂了，被错判成无解。\n正确的做法是按照往常一样【零入度点入队列】做拓扑排序，只不过初始化时d[s]&#x3D;0, 其余均赋值为正无穷，之后每条边该转移时更新一下即可。\n\n区间的值域很大，但是可以贪心考虑。考虑找到一组最优解，将其向右平移，使他的右端点是一个桥边的右端点，这样答案不会变差。（覆盖桥长尽量长）所以我们 DP 每次的决策只需考虑在每条桥边的端点开始&#x2F;结束坐车即可。\n\n一些定义\n设 d[i] 为 从 S 到第 i 个节点的距离\n设 g[i] 为 从 S 到第 i 个节点的桥的距离\n设 bri[i] 为 [i−1,i] 这段是不是桥\n这些玩意都是可以跑最短路后把最短路抽出来变成一条链 O(n+m) 处理的。\n\nDP\n设 ds[i] 为从 S 到第 i 个节点的最小危险程度&#x3D;&#x3D;S-&gt;i 【uncover的总桥长】\nds[i] &#x3D; min(g[i], ds[i - 1] + g[i] - g[i - 1]);&#x2F;&#x2F;不被k更新的init_ds！！！\n设 dt[i] 为从 i 到第 T 个节点的最小危险程度\n\n处理 ds\n如果 d[i]−d[i−1] 这段是桥：\n\n找到一个最小的 k 满足 d[i]−d[k]&lt;&#x3D;q。显然 i 增大的时候，k 也是不降的，具有单调性可以用双指针 O(n)。\n\n如果 bri[k]\n​ ds[i]&#x3D;g[k]−(q−(d[i]−d[k]))\n否则 ds[i]&#x3D;g[k]\n\n处理 dt\ndt[i] 类似\n找到一个最大的 k 使得 d[k]−d[i]&lt;&#x3D;q\n如果 bri[k]\n​ dt[i]&#x3D;g[tot]−g[k]−(q−(d[k]−d[i]))\n否则 dt[i]&#x3D;g[tot]−g[k]\n真实的分类讨论:\n假设一条桥边上没有覆盖两次，那么必然可以用书中的放法，将桥边画一条界，两边分别取最优。\n否则，假设最优解是一条桥边上覆盖两次的情况，那么存在一种方式是紧挨着的最优解，因为将他们平移至紧挨着答案不会变差，然后问题变成了 2Q 长度的一个覆盖，然后这个覆盖和之前类似，都是把线段平移到端点不会变差，这里就不再赘述。\n\n作者：墨染空\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;192066&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n*&#x2F;\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100005, M &#x3D; 200005, P &#x3D; 1e9 + 7, INF &#x3D; 0x3f3f3f3f;\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; PII;\nint n, m, S, T, Q;\nint head[N], bhead[N], pre[N], d[N], dis[N], g[N], ds[N], dt[N], degS[N];\nint a[N], tot, q[N], degT[N], fs[N], ft[N], numE;\nbool st[M &lt;&lt; 2], bri[N];\n\nstruct E&#123;\n\tint next, v, w;\n&#125; e[M &lt;&lt; 2];\n\nvoid inline add(int u, int v, int w, int h[]) &#123;\n\te[++numE] &#x3D; (E) &#123; h[u], v, w &#125;;\n\th[u] &#x3D; numE;\n&#125;\n\nvoid toposort(int s, int t, int h[], int cnt[], int deg[], int opt) &#123;\n\tfor (int i &#x3D; 0; i &lt; n; i++) cnt[i] &#x3D; 0;\n\tcnt[s] &#x3D; 1;\n\tint hh &#x3D; 0, tt &#x3D; -1;\n\tfor (int i &#x3D; 0; i &lt; n; i++) if (!deg[i]) q[++tt] &#x3D; i;&#x2F;&#x2F;0入度入队\n\twhile (hh &lt;&#x3D; tt) &#123;\n\t\tint u &#x3D; q[hh++];\n\t\tfor (int i &#x3D; h[u]; ~i; i &#x3D; e[i].next) &#123;\n\t\t\tint v &#x3D; e[i].v;\n\t\t\tif (opt &amp;&amp; dis[u] + e[i].w &lt; dis[v])&#x2F;&#x2F;反图opt&#x3D;0：不覆盖\n\t\t\t\tdis[v] &#x3D; dis[u] + e[i].w, pre[v] &#x3D; i;&#x2F;&#x2F;ST最短路 pre:入边\n\t\t\t(cnt[v] +&#x3D; cnt[u]) %&#x3D; P;&#x2F;&#x2F;\n\t\t\tif (--deg[v] &#x3D;&#x3D; 0) q[++tt] &#x3D; v;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid inline clear() &#123;\n\tnumE &#x3D; -1, tot &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\thead[i] &#x3D; bhead[i] &#x3D; -1, dis[i] &#x3D; INF;\n\t\tdegS[i] &#x3D; degT[i] &#x3D; 0, bri[i] &#x3D; false;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; 2 * m; i++) st[i] &#x3D; false;\n&#125;\n\nint main() &#123;\n\tint Case; scanf(&quot;%d&quot;, &amp;Case);\n\twhile (Case--) &#123;\n\t\tscanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;S, &amp;T, &amp;Q); clear();\n\t\tfor (int i &#x3D; 1, u, v, w; i &lt;&#x3D; m; i++) &#123;\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);\n\t\t\tadd(u, v, w, head); add(v, u, w, bhead);\n\t\t\tdegS[v]++, degT[u]++;&#x2F;&#x2F;S、T出发的入度\n\t\t&#125;\n\t\tdis[S] &#x3D; 0;\n\t\ttoposort(S, T, head, fs, degS, 1);\n\t\tif (dis[T] &#x3D;&#x3D; INF) &#123; puts(&quot;-1&quot;); continue; &#125;&#x2F;&#x2F;无解\n\t\ttoposort(T, S, bhead, ft, degT, 0);&#x2F;&#x2F;opt&#x3D;0: 只算ft,保留dis pre\n\t\ta[++tot] &#x3D; T; \n\t\twhile (a[tot] !&#x3D; S) a[++tot] &#x3D; e[pre[a[tot]] ^ 1].v;&#x2F;&#x2F;倒推\n\t\treverse(a + 1, a + 1 + tot);&#x2F;&#x2F;a:ST最短路\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++) d[i] &#x3D; dis[a[i]];&#x2F;&#x2F;d[i]:最短路上i与S距\n\t\tfor (int u &#x3D; 0; u &lt; n; u++) &#123;\n\t\t\tfor (int i &#x3D; head[u]; ~i; i &#x3D; e[i].next) &#123;\n\t\t\t\tint v &#x3D; e[i].v;\n\t\t\t\tif ((LL)fs[u] * ft[v] % P &#x3D;&#x3D; fs[T]) st[i] &#x3D; true;&#x2F;&#x2F;st:必经边桥\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) bri[i] &#x3D; st[pre[a[i]]], g[i] &#x3D; g[i - 1] + (bri[i] ? e[pre[a[i]]].w : 0);&#x2F;&#x2F;bri:a上桥01串 g[i]:S-&gt;i总桥长\n\t\t&#x2F;&#x2F;ds:最小危险程度&#x3D;&#x3D;S-&gt;i uncover的总桥长\n\t\tint k &#x3D; 1;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;\n\t\t\tds[i] &#x3D; min(g[i], ds[i - 1] + g[i] - g[i - 1]);&#x2F;&#x2F;不被k更新的init！\n\t\t\twhile (k + 1 &lt;&#x3D; i &amp;&amp; d[i] - d[k] &gt; Q) k++;&#x2F;&#x2F;&lt;&#x3D;Q的min_k\n\t\t\tds[i] &#x3D; min(ds[i], g[k] - (bri[k] ? Q - (d[i] - d[k]) : 0));\n\t\t&#125;\n\t\t&#x2F;&#x2F;dt\n\t\tds[1] &#x3D; dt[tot] &#x3D; 0, k &#x3D; tot;\n\t\tfor (int i &#x3D; tot - 1; i; i--) &#123;\n\t\t\tdt[i] &#x3D; min(g[tot] - g[i], dt[i + 1] + g[i + 1] - g[i]);&#x2F;&#x2F;\n\t\t\twhile (k - 1 &gt;&#x3D; i &amp;&amp; d[k] - d[i] &gt; Q) k--;\n\t\t\tdt[i] &#x3D; min(dt[i], g[tot] - g[k] - (bri[k + 1] ? Q - (d[k] - d[i]): 0));\n\t\t&#125;\n\t\t&#x2F;&#x2F;更新ans\n\t\tint ans &#x3D; 2e9;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++) ans &#x3D; min(ans, ds[i] + dt[i]);\n\t\t&#x2F;&#x2F;特判\n\t\tk &#x3D; 1;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;\n\t\t\twhile (k + 1 &lt;&#x3D; i &amp;&amp; d[i] - d[k] &gt; 2 * Q) k++;\n\t\t\tans &#x3D; min(ans, g[tot] - g[i] + g[k] - (bri[k] ? 2 * Q - (d[i] - d[k]) : 0));&#x2F;&#x2F;k~(2Q右对齐)~i~tot\n\t\t&#125;\n\t\tprintf(&quot;%d\\n&quot;, ans);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;【2-SAT】\n&#x2F;&#x2F; AcWing 370. 卡图难题\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1006;\nint n, m, dfn[N], low[N], num, st[N], top, c[N], cnt;\nbool ins[N];\nvector&lt;int&gt; e[N&lt;&lt;1];\n\ninline void add(int x, int y) &#123;\n\te[x].push_back(y);\n&#125;\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tst[++top] &#x3D; x;\n\tins[x] &#x3D; 1;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t&#125; else if (ins[y])\n\t\t\tlow[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\t++cnt;\n\t\tint y;\n\t\tdo &#123;\n\t\t\ty &#x3D; st[top--];\n\t\t\tins[y] &#x3D; 0;\n\t\t\tc[y] &#x3D; cnt;\n\t\t&#125; while (x !&#x3D; y);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\twhile (m--) &#123;\n\t\tint a, b, c;\n\t\tchar s[6];\n\t\tscanf(&quot;%d %d %d %s&quot;, &amp;a, &amp;b, &amp;c, s);&#x2F;&#x2F;满足Xa op(s) Xb &#x3D; c \n\t\tif (s[0] &#x3D;&#x3D; &#39;A&#39;) &#123;\n\t\t\tif (c) &#123;\n\t\t\t\tadd(a, a + n);\n\t\t\t\tadd(b, b + n);\n\t\t\t&#125; else &#123;\n\t\t\t\tadd(a + n, b);\n\t\t\t\tadd(b + n, a);\n\t\t\t&#125;\n\t\t&#125; else if (s[0] &#x3D;&#x3D; &#39;O&#39;) &#123;\n\t\t\tif (c) &#123;\n\t\t\t\tadd(a, b + n);\n\t\t\t\tadd(b, a + n);\n\t\t\t&#125; else &#123;\n\t\t\t\tadd(a + n, a);\n\t\t\t\tadd(b + n, b);\n\t\t\t&#125;\n\t\t&#125; else &#123;\n\t\t\tif (c) &#123;\n\t\t\t\tadd(a, b + n);\n\t\t\t\tadd(b, a + n);\n\t\t\t\tadd(a + n, b);\n\t\t\t\tadd(b + n, a);\n\t\t\t&#125; else &#123;\n\t\t\t\tadd(a, b);\n\t\t\t\tadd(b, a);\n\t\t\t\tadd(a + n, b + n);\n\t\t\t\tadd(b + n, a + n);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tif (!dfn[i]) tarjan(i);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tif (c[i] &#x3D;&#x3D; c[i+n]) &#123;\n\t\t\tputs(&quot;NO&quot;);\n\t\t\treturn 0;\n\t\t&#125;\n\tputs(&quot;YES&quot;);\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; AcWing 371. 牧师约翰最忙碌的一天\n&#x2F;&#x2F; 2-SAT构图并打印方案，解法一，自底向上拓扑排序 (POJ3683)\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int u &#x3D; 2010, w &#x3D; 3000010;\nint ver[w], Next[w], head[u], dfn[u], low[u], c[u], s[u], ins[u];\nint ver2[w], Next2[w], head2[u], val[u], deg[u], opp[u];\nint S[u], T[u], D[u], ex[w], ey[w];\nint n, m, tot, tot2, num, t, p, e;\nqueue&lt;int&gt; q;\n\n&#x2F;&#x2F; 原图加边\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n\tex[++e] &#x3D; x, ey[e] &#x3D; y;\n&#125;\n\n&#x2F;&#x2F; 缩点后的图加边\nvoid add2(int x, int y) &#123;\n\tver2[++tot2] &#x3D; y, Next2[tot2] &#x3D; head2[x], head2[x] &#x3D; tot2;\n&#125;\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\ts[++p] &#x3D; x, ins[x] &#x3D; 1;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i])\n\t\tif (!dfn[ver[i]]) &#123;\n\t\t\ttarjan(ver[i]);\n\t\t\tlow[x] &#x3D; min(low[x], low[ver[i]]);\n\t\t&#125;\n\t\telse if (ins[ver[i]])\n\t\t\tlow[x] &#x3D; min(low[x], dfn[ver[i]]);\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\tt++; int y;\n\t\tdo &#123; y &#x3D; s[p--], ins[y] &#x3D; 0; c[y] &#x3D; t; &#125; while (x !&#x3D; y);\n\t&#125;\n&#125;\n\nvoid topsort() &#123;\n\tmemset(val, -1, sizeof(val));\n\t&#x2F;&#x2F; 缩点，建反图\n\tfor (int i &#x3D; 1; i &lt;&#x3D; e; i++)\n\t\tif (c[ex[i]] !&#x3D; c[ey[i]])\n\t\t\tadd2(c[ey[i]], c[ex[i]]), deg[c[ex[i]]]++;\n\t&#x2F;&#x2F; 零入度点入队\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++)\n\t\tif (!deg[i]) q.push(i);\n\t&#x2F;&#x2F; 拓扑排序\n\twhile (q.size()) &#123;\n\t\tint k &#x3D; q.front(); q.pop();\n\t\t&#x2F;&#x2F; 赋值标记\n\t\tif (val[k] &#x3D;&#x3D; -1) val[k] &#x3D; 0, val[opp[k]] &#x3D; 1;\n\t\tfor (int i &#x3D; head2[k]; i; i &#x3D; Next2[i])\n\t\t\tif (--deg[ver2[i]] &#x3D;&#x3D; 0) q.push(ver2[i]);\n\t&#125;\n\t&#x2F;&#x2F; 输出最终结果 0:S~(S+D) 1:(T-D)~T\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (val[c[i]] &#x3D;&#x3D; 0) printf(&quot;%02d:%02d %02d:%02d\\n&quot;,\n\t\t\tS[i] &#x2F; 60, S[i] % 60,\n\t\t\t(S[i] + D[i]) &#x2F; 60, (S[i] + D[i]) % 60);\n\t\telse printf(&quot;%02d:%02d %02d:%02d\\n&quot;,\n\t\t\t(T[i] - D[i]) &#x2F; 60, (T[i] - D[i]) % 60,\n\t\t\tT[i] &#x2F; 60, T[i] % 60);\n&#125;\n\nbool overlap(int a, int b, int c, int d) &#123;\n\tif (a &gt;&#x3D; c&amp;&amp;a&lt;d || b&gt;c&amp;&amp;b &lt;&#x3D; d || a &lt;&#x3D; c&amp;&amp;b &gt;&#x3D; d) return 1;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint sh, sm, th, tm;\n\t\tscanf(&quot;%d:%d %d:%d %d&quot;, &amp;sh, &amp;sm, &amp;th, &amp;tm, &amp;D[i]);\n\t\tS[i] &#x3D; sh * 60 + sm; T[i] &#x3D; th * 60 + tm;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tfor (int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\tif (overlap(S[i], S[i] + D[i], S[j], S[j] + D[j]))\n\t\t\t\tadd(i, n + j), add(j, n + i);\n\t\t\tif (overlap(S[i], S[i] + D[i], T[j] - D[j], T[j]))\n\t\t\t\tadd(i, j), add(n + j, n + i);\n\t\t\tif (overlap(T[i] - D[i], T[i], S[j], S[j] + D[j]))\n\t\t\t\tadd(n + i, n + j), add(j, i);\n\t\t\tif (overlap(T[i] - D[i], T[i], T[j] - D[j], T[j]))\n\t\t\t\tadd(n + i, j), add(n + j, i);\n\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 2 * n; i++)\n\t\tif (!dfn[i]) tarjan(i);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tif (c[i] &#x3D;&#x3D; c[n + i]) &#123; puts(&quot;NO&quot;); return 0; &#125;\n\t\topp[c[i]] &#x3D; c[n + i], opp[c[n + i]] &#x3D; c[i];\n\t&#125;\n\tputs(&quot;YES&quot;);\n\ttopsort();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 2-SAT构图并打印方案，解法二 (POJ3683)\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int u &#x3D; 2010, w &#x3D; 3000010;\nint ver[w], Next[w], head[u], dfn[u], low[u], c[u], s[u], ins[u];\nint val[u], deg[u], opp[u], S[u], T[u], D[u];\nint n, m, tot, num, t, p;\n\n&#x2F;&#x2F; 原图加边\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\ts[++p] &#x3D; x, ins[x] &#x3D; 1;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i])\n\t\tif (!dfn[ver[i]]) &#123;\n\t\t\ttarjan(ver[i]);\n\t\t\tlow[x] &#x3D; min(low[x], low[ver[i]]);\n\t\t&#125;\n\t\telse if (ins[ver[i]])\n\t\t\tlow[x] &#x3D; min(low[x], dfn[ver[i]]);\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\tt++; int y;\n\t\tdo &#123; y &#x3D; s[p--], ins[y] &#x3D; 0; c[y] &#x3D; t; &#125; while (x !&#x3D; y);\n\t&#125;\n&#125;\n\nbool overlap(int a, int b, int c, int d) &#123;\n\tif (a &gt;&#x3D; c&amp;&amp;a&lt;d || b&gt;c&amp;&amp;b &lt;&#x3D; d || a &lt;&#x3D; c&amp;&amp;b &gt;&#x3D; d) return 1;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint sh, sm, th, tm;\n\t\tscanf(&quot;%d:%d %d:%d %d&quot;, &amp;sh, &amp;sm, &amp;th, &amp;tm, &amp;D[i]);\n\t\tS[i] &#x3D; sh * 60 + sm; T[i] &#x3D; th * 60 + tm;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tfor (int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\tif (overlap(S[i], S[i] + D[i], S[j], S[j] + D[j]))\n\t\t\t\tadd(i, n + j), add(j, n + i);\n\t\t\tif (overlap(S[i], S[i] + D[i], T[j] - D[j], T[j]))\n\t\t\t\tadd(i, j), add(n + j, n + i);\n\t\t\tif (overlap(T[i] - D[i], T[i], S[j], S[j] + D[j]))\n\t\t\t\tadd(n + i, n + j), add(j, i);\n\t\t\tif (overlap(T[i] - D[i], T[i], T[j] - D[j], T[j]))\n\t\t\t\tadd(n + i, j), add(n + j, i);\n\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 2 * n; i++)\n\t\tif (!dfn[i]) tarjan(i);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tif (c[i] &#x3D;&#x3D; c[n + i]) &#123; puts(&quot;NO&quot;); return 0; &#125;\n\t\topp[i] &#x3D; n + i, opp[n + i] &#x3D; i;\n\t&#125;\n\tputs(&quot;YES&quot;);\n\t&#x2F;&#x2F; 构造方案 \n\tfor (int i &#x3D; 1; i &lt;&#x3D; 2 * n; i++)\n\t\tval[i] &#x3D; c[i] &gt; c[opp[i]]; &#x2F;&#x2F; &lt;&#x3D;优先为0, &gt;为1\n\t&#x2F;&#x2F; 输出最终结果\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (val[i] &#x3D;&#x3D; 0) printf(&quot;%02d:%02d %02d:%02d\\n&quot;,\n\t\t\tS[i] &#x2F; 60, S[i] % 60,\n\t\t\t(S[i] + D[i]) &#x2F; 60, (S[i] + D[i]) % 60);\n\t\telse printf(&quot;%02d:%02d %02d:%02d\\n&quot;,\n\t\t\t(T[i] - D[i]) &#x2F; 60, (T[i] - D[i]) % 60,\n\t\t\tT[i] &#x2F; 60, T[i] % 60);\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x68. 二分图的匹配\n&#x2F;&#x2F;关押罪犯 (法2： 二分图judge + 二分)\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 20006, M &#x3D; 200006;\nstruct P &#123;\n\tint x, y, z;\n\tbool operator &lt; (const P w) const &#123;\n\t\treturn z &gt; w.z;\n\t&#125;\n&#125; p[M];\nint n, m, v[N];\nvector&lt;pair&lt;int, int&gt; &gt; e[N];\n\nbool dfs(int x, int color) &#123;\n\tv[x] &#x3D; color;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i].first;\n\t\t&#x2F;&#x2F; if (v[y]) &#123;\n\t\t&#x2F;&#x2F; \tif (v[y] &#x3D;&#x3D; color) return 0;\n\t\t&#x2F;&#x2F; &#125; else &#123;\n\t\t&#x2F;&#x2F; \tif (!dfs(y, 3 - color)) return 0;\n\t\t&#x2F;&#x2F; &#125;\n\t\tif (!v[y] &amp;&amp; !dfs(y, 3 - color)) return 0;\n\t\telse if (v[y] &#x3D;&#x3D; color) return 0;\n\t&#125;\n\treturn 1;\n&#125;\n\ninline bool check(int now) &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) e[i].clear();\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tif (p[i].z &lt;&#x3D; now) break;\n\t\t&#x2F;&#x2F;仇恨度&gt;mid:连边\tp按z降序排列:break&#x3D;&#x3D;continue\n\t\te[p[i].x].push_back(&#123;p[i].y, p[i].z&#125;);\n\t\te[p[i].y].push_back(&#123;p[i].x, p[i].z&#125;);\n\t&#125;\n\tmemset(v, 0, sizeof(v));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (!v[i] &amp;&amp; !dfs(i, 1)) return 0;\n\treturn 1;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tscanf(&quot;%d %d %d&quot;, &amp;p[i].x, &amp;p[i].y, &amp;p[i].z);\n\tsort(p + 1, p + m + 1);\n\tint l &#x3D; 0, r &#x3D; p[1].z;&#x2F;&#x2F;怨气值域\n\twhile (l &lt; r) &#123;\n\t\tint mid &#x3D; (l + r) &gt;&gt; 1;\n\t\tif (check(mid)) r &#x3D; mid;\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\tcout &lt;&lt; l &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;【二分图最大匹配:匈牙利 增广路】\n&#x2F;&#x2F; AcWing 372. 棋盘覆盖\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 106;\nconst int dx[4] &#x3D; &#123;0,0,1,-1&#125;;\nconst int dy[4] &#x3D; &#123;1,-1,0,0&#125;;\nint n, m, ans, f[N*N];&#x2F;&#x2F;f&#x3D;&#x3D;match\nbool b[N][N], v[N*N];\nvector&lt;int&gt; e[N*N];\n\nbool dfs(int x) &#123;\n\tfor (unsigned int i &#x3D; 0, y; i &lt; e[x].size(); i++) &#123;\n\t\tif (v[y &#x3D; e[x][i]]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (f[y] &#x3D;&#x3D; -1 || dfs(f[y])) &#123;\n\t\t\tf[y] &#x3D; x;\n\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\twhile (m--) &#123;&#x2F;&#x2F;禁放坐标\n\t\tint x, y;\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y); \n\t\tb[x-1][y-1] &#x3D; 1;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; n; j++)\n\t\t\tif (!b[i][j])\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 4; k++) &#123;&#x2F;&#x2F;相邻格不同色:连边(可放 界内)\n\t\t\t\t\tint x &#x3D; i + dx[k], y &#x3D; j + dy[k];\n\t\t\t\t\tif (x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; n &amp;&amp; !b[x][y]) &#123;\n\t\t\t\t\t\te[i * n + j].push_back(x * n + y);&#x2F;&#x2F;二维坐标合一维！\n\t\t\t\t\t\te[x * n + y].push_back(i * n + j);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\tmemset(f, -1, sizeof(f));\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; n; j++) &#123;\n\t\t\tif ((i ^ j) &amp; 1) continue;&#x2F;&#x2F;行+列为偶数:白格\n\t\t\tmemset(v, 0, sizeof(v));\n\t\t\tans +&#x3D; dfs(i * n + j);&#x2F;&#x2F;max_match数(黑白配 +&#x3D;1、0)\n\t\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 373. 車的放置\t\t匈牙利模板题\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint n, m, t, ans, fa[205];&#x2F;&#x2F;fa&#x3D;&#x3D;match\nbool a[205][205], v[205];\n\nbool dfs(int x) &#123;\n\tfor (int y &#x3D; 1; y &lt;&#x3D; m; y++) &#123;&#x2F;&#x2F;列\n\t\tif (v[y] || a[x][y]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (fa[y] &#x3D;&#x3D; 0 || dfs(fa[y])) &#123;\n\t\t\tfa[y] &#x3D; x;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\treturn false;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; t;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tint x, y; cin &gt;&gt; x &gt;&gt; y;\n\t\ta[x][y] &#x3D; 1;&#x2F;&#x2F;禁放\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;&#x2F;&#x2F;行\n\t\tmemset(v, 0, sizeof(v));\n\t\tif (dfs(i)) ans++;\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;HDOJ 1045. Fire Net\n\n\n&#x2F;&#x2F;【多重匹配：拆点法】\n&#x2F;&#x2F; AcWing 374. 导弹防御塔\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#define pii pair&lt;int, int&gt;\n#define x first\n#define y second\nusing namespace std;\nconst int N &#x3D; 56, M &#x3D; 2506;\nconst double eps &#x3D; 1e-8;\nint n, m, t, t2, V, cnt, f[M];\ndouble t1;\nbool v[M];\npii a[N], b[N];\npair&lt;int, double&gt; c[M];\nvector&lt;int&gt; e[N];\n\ninline double S(pii a, pii b) &#123;\n\tint dx &#x3D; a.x - b.x, dy &#x3D; a.y - b.y;\n\treturn sqrt(dx * dx + dy * dy);\n&#125;\n\nbool dfs(int x) &#123;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (v[y]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (!f[y] || dfs(f[y])) &#123;\n\t\t\tf[y] &#x3D; x;\n\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\ninline bool check(double mid) &#123;\n\tmemset(f, 0, sizeof(f));&#x2F;&#x2F;f&#x3D;&#x3D;match\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\te[i].clear();\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; t; j++)&#x2F;&#x2F;max:塔n导弹m-&gt;人m\n\t\t\tif (c[j].y + S(a[i], b[c[j].x]) &#x2F; V &lt;&#x3D; mid)&#x2F;&#x2F;发射+飞行&lt;&#x3D;mid\n\t\t\t\te[i].push_back(j);&#x2F;&#x2F;连边\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tmemset(v, 0, sizeof(v));\n\t\tif (!dfs(i)) return 0;&#x2F;&#x2F;match\n\t&#125;\n\treturn 1;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; V;\n\tt &#x3D; n * m;&#x2F;&#x2F;塔n导弹m\n\tt1 &#x2F;&#x3D; 60;&#x2F;&#x2F;s-&gt;min\n\t&#x2F;&#x2F;人a入侵塔b\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tscanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d %d&quot;, &amp;b[i].x, &amp;b[i].y);\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#x2F;&#x2F;枚举炮塔 \n\t\tfor(int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t&#x2F;&#x2F;枚举第几个导弹 (最多用一个炮塔发射m颗导弹就够了)\n\t\t&#123;\n\t\t\tc[++cnt].x &#x3D; i;&#x2F;&#x2F;炮塔\n\t\t\tc[cnt].y &#x3D; (j - 1) * (t1 + t2) + t1;&#x2F;&#x2F;发射时间\n\t\t&#125;\n\tdouble l &#x3D; t1, r &#x3D; 100000;\n\twhile (l + eps &lt; r) &#123;\n\t\tdouble mid &#x3D; (l + r) &#x2F; 2;\n\t\tif (check(mid)) r &#x3D; mid;\n\t\telse l &#x3D; mid;\n\t&#125;\n\tprintf(&quot;%.6f\\n&quot;, l);\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;【二分图带权最大(完备)匹配:KM算法(相等子图的完备匹配)】\n&#x2F;&#x2F; AcWing 375. 蚂蚁\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N &#x3D; 105;\nint a[N], b[N], c[N], d[N];\ndouble w[N][N]; &#x2F;&#x2F; 边权\ndouble la[N], lb[N]; &#x2F;&#x2F; 左、右部点的顶标\nbool va[N], vb[N]; &#x2F;&#x2F; 访问标记：是否在交错树中(属于T)\nint match[N], ans[N]; &#x2F;&#x2F; 右部点匹配了哪一个左部点\nint n;\ndouble upd[N], delta;\n\nbool dfs(int x) &#123;\n\tva[x] &#x3D; 1; &#x2F;&#x2F; 访问标记：x在交错树中\n\tfor (int y &#x3D; 1; y &lt;&#x3D; n; y++)\n\t\tif (!vb[y])&#x2F;&#x2F;y不属于T\n\t\t\tif (fabs(la[x] + lb[y] - w[x][y]) &lt; 1e-8) &#123; &#x2F;&#x2F; 相等子图\n\t\t\t\tvb[y] &#x3D; 1; &#x2F;&#x2F; 访问标记：y在交错树中\n\t\t\t\tif (!match[y] || dfs(match[y])) &#123;\n\t\t\t\t\tmatch[y] &#x3D; x;\n\t\t\t\t\treturn true;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\telse upd[y] &#x3D; min(upd[y], la[x] + lb[y] - w[x][y]);\n\treturn false;\n&#125;\n\nvoid KM() &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tla[i] &#x3D; -1e10; &#x2F;&#x2F; -inf\n\t\tlb[i] &#x3D; 0;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tla[i] &#x3D; max(la[i], w[i][j]);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\twhile (true) &#123;\n\t\t\tmemset(va, 0, sizeof(va));\n\t\t\tmemset(vb, 0, sizeof(vb));\n\t\t\tdelta &#x3D; 1e10; &#x2F;&#x2F; inf\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) upd[j] &#x3D; 1e10; \n\t\t\tif (dfs(i)) break;&#x2F;&#x2F; 直到左部点找到匹配\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif (!vb[j]) delta &#x3D; min(delta, upd[j]);\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; &#x2F;&#x2F; 修改顶标\n\t\t\t\tif (va[j]) la[j] -&#x3D; delta;\n\t\t\t\tif (vb[j]) lb[j] +&#x3D; delta;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d%d&quot;, &amp;c[i], &amp;d[i]);\n\t&#x2F;&#x2F;边权取反：带权min-&gt;带权max\tmin边权和&#x3D;(-边权和)\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tw[i][j] &#x3D; -sqrt((a[i]-c[j])*(a[i]-c[j])*1.0+(b[i]-d[j])*(b[i]-d[j])*1.0);\n\tKM();\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) ans[match[i]] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) printf(&quot;%d\\n&quot;, ans[i]);&#x2F;&#x2F;只匹配\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x69. 二分图的覆盖【2要素:2选1】\n&#x2F;&#x2F;(二分图)最小点覆盖数【用最少的点覆盖所有边】&#x3D;&#x3D;最大匹配边数\n&#x2F;&#x2F; AcWing 376. 机器任务\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 106;\nint n, m, k, f[N], ans;\nbool v[N];\nvector&lt;int&gt; e[N];\n\nbool dfs(int x) &#123;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (v[y]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (!f[y] || dfs(f[y])) &#123;\n\t\t\tf[y] &#x3D; x;\n\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\ninline void Machine_Schedule() &#123;\n\tcin &gt;&gt; m &gt;&gt; k;\n\tfor (int i &#x3D; 1; i &lt; n; i++) e[i].clear();\n\tfor (int i &#x3D; 0; i &lt; k; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;i, &amp;x, &amp;y);\n\t\tif (x &amp;&amp; y) e[x].push_back(y);\n\t&#125;\n\tmemset(f, 0, sizeof(f));\n\tans &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tmemset(v, 0, sizeof(v));\n\t\tans +&#x3D; dfs(i);&#x2F;&#x2F;(二分图)最小点覆盖数&#x3D;&#x3D;最大匹配边数\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#x2F;&#x2F; for(int x : f) cout&lt;&lt;x;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &amp;&amp; n) Machine_Schedule();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 377. 泥泞的区域\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 56;\nint n, m, tot &#x3D; 1, a[N][N][2], f[N*N], ans;\nchar s[N][N];\nbool v[N*N];\nvector&lt;int&gt; e[N*N];\n\nbool dfs(int x) &#123;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (v[y]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (!f[y] || dfs(f[y])) &#123;\n\t\t\tf[y] &#x3D; x;\n\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%s&quot;, s[i] + 1);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m + 1; j++)&#x2F;&#x2F;m+1:行末++tot\n\t\t\tif (s[i][j] &#x3D;&#x3D; &#39;*&#39;) a[i][j][0] &#x3D; tot;&#x2F;&#x2F;行泥泞块tot\n\t\t\telse ++tot;&#x2F;&#x2F;tot非连续(块号是几不重要 只为区分)\n\tint t &#x3D; tot;&#x2F;&#x2F;最大泥块号：行t 列tot\n\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n + 1; i++)&#x2F;&#x2F;n+1:列末++tot\n\t\t\tif (s[i][j] &#x3D;&#x3D; &#39;*&#39;) a[i][j][1] &#x3D; tot;&#x2F;&#x2F;列泥泞块tot\n\t\t\telse ++tot;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t\tif (s[i][j] &#x3D;&#x3D; &#39;*&#39;) &#123;&#x2F;&#x2F;泥块所属行、列泥块之间连边\n\t\t\t\te[a[i][j][0]].push_back(a[i][j][1]);\n\t\t\t\te[a[i][j][1]].push_back(a[i][j][0]);\n\t\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt; t; i++) &#123;&#x2F;&#x2F;最后m+1：++tot 行泥块号:1~t-1\n\t\tmemset(v, 0, sizeof(v));\n\t\tans +&#x3D; dfs(i);\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;【二分图最大点独立集(任意两点之间无连边)】\n&#x2F;&#x2F;无向图G的最大团&#x3D;&#x3D;其补图G&#39;的最大独立集\n&#x2F;&#x2F;n点二分图G的最大独立集大小 &#x3D;&#x3D; n-(最大匹配数(最小点覆盖数))\n\n&#x2F;&#x2F; AcWing 378. 骑士放置 【对比Acwing 372.棋盘覆盖(2D坐标-&gt;1D)】\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint n, m, t, ans, fx[105][105], fy[105][105];\nbool a[105][105], v[105][105];\nconst int dx[8] &#x3D; &#123;-2, -2, -1, -1, 1, 1, 2, 2&#125;;\nconst int dy[8] &#x3D; &#123;-1, 1, -2, 2, -2, 2, -1, 1&#125;;\n\nbool dfs(int x, int y) &#123;&#x2F;&#x2F;马走日连边 二维坐标\n\tfor (int i &#x3D; 0; i &lt; 8; i++) &#123;\n\t\tint nx &#x3D; x + dx[i], ny &#x3D; y + dy[i];\n\t\tif (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; m || a[nx][ny]) continue;&#x2F;&#x2F;\n\t\tif (v[nx][ny]) continue;\n\t\tv[nx][ny] &#x3D; 1;\n\t\tif (fx[nx][ny] &#x3D;&#x3D; 0 || dfs(fx[nx][ny], fy[nx][ny])) &#123;\n\t\t\tfx[nx][ny] &#x3D; x, fy[nx][ny] &#x3D; y;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\treturn false;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; t;&#x2F;&#x2F;t个禁放\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tint x, y; cin &gt;&gt; x &gt;&gt; y;\n\t\ta[x][y] &#x3D; 1;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123;\n\t\t\tif (i + j &amp; 1) continue;&#x2F;&#x2F;行+列为偶数:白格\n\t\t\tif (a[i][j]) continue;&#x2F;&#x2F;\n\t\t\tmemset(v, 0, sizeof(v));\n\t\t\tif (dfs(i, j)) ans++;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; n * m - t - ans &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;【DAG的最小路径点覆盖的路径数 &#x3D;&#x3D; n-拆点二分图(左n右n)的max_match数】\n&#x2F;&#x2F;  路径终点&#x3D;&#x3D;左部非匹点\t路径可相交&#x3D;可重复点:先Floyd 传递闭包,去自环\n&#x2F;&#x2F; AcWing 379. 捉迷藏\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 220;\nbool cl[N][N]; &#x2F;&#x2F; 邻接矩阵\nint match[N], n, m;\nbool vis[N], succ[N];\nint hide[N]; &#x2F;&#x2F; 藏身点集合\n\nbool dfs(int x) &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (cl[x][i] &amp;&amp; !vis[i]) &#123;\n\t\t\tvis[i] &#x3D; true;\n\t\t\tif (!match[i] || dfs(match[i])) &#123;\n\t\t\t\tmatch[i] &#x3D; x;\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t&#125;\n\treturn false;\n&#125;\n\nint main() &#123;\n\t&#x2F;&#x2F; 读入\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tcl[x][y] &#x3D; 1;\n\t&#125;\n\t&#x2F;&#x2F; Floyd 传递闭包\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cl[i][i] &#x3D; 1;\n\tfor (int k &#x3D; 1; k &lt;&#x3D; n; k++) \n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) \n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) \n\t\t\t\tcl[i][j] |&#x3D; cl[i][k] &amp;&amp; cl[k][j];&#x2F;&#x2F;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cl[i][i] &#x3D; 0;&#x2F;&#x2F;无自环 DAG\n\t&#x2F;&#x2F; 在拆点二分图(左n右n)上求最大匹配\n\tint ans &#x3D; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tans -&#x3D; dfs(i);\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt;endl;&#x2F;&#x2F;路径条数\n\t&#x2F;&#x2F; 构造方案，先把所有路径终点（左部非匹配点）作为藏身点\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) succ[match[i]] &#x3D; true;\n\tfor (int i &#x3D; 1, k &#x3D; 0; i &lt;&#x3D; n; i++)\n\t\tif (!succ[i]) hide[++k] &#x3D; i;\n\tmemset(vis, 0, sizeof(vis));\n\tbool modify &#x3D; true;\n\twhile (modify) &#123;&#x2F;&#x2F;只要更新了hide，就要重新check\n\t\tmodify &#x3D; false;\n\t\t&#x2F;&#x2F; 求出 next(hide)\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; ans; i++) \n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif (cl[hide[i]][j]) vis[j] &#x3D; true;&#x2F;&#x2F;cl:后继 vis:next(E)\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; ans; i++)\n\t\t\tif (vis[hide[i]]) &#123;&#x2F;&#x2F;next(E)与E有交集\n\t\t\t\tmodify &#x3D; true;\n\t\t\t\t&#x2F;&#x2F; 不断向上移动\n\t\t\t\twhile (vis[hide[i]]) hide[i] &#x3D; match[hide[i]];&#x2F;&#x2F;match:前驱\n\t\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; ans; i++) printf(&quot;%d &quot;, hide[i]);\n\tcout &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;0x6A. 网络流初步\n&#x2F;&#x2F;【最大流】\n&#x2F;&#x2F; AcWing 380. 舞动的夜晚\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf &#x3D; 0x3fffffff, u &#x3D; 40010, w &#x3D; 300010;\nint head[u], ver[w], edge[w], Next[w], d[u], e[w], c[u], stk[u], ins[u], dfn[u], low[u];\nint n, m, p, s, t, i, j, tot, maxflow, ans, x, y, scc, top, num;\nchar str[10];\nvector&lt;int&gt; a[u];\nqueue&lt;int&gt; q;\n\nvoid add(int x, int y, int z) &#123;\n\tver[++tot] &#x3D; y, edge[tot] &#x3D; z, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n\tver[++tot] &#x3D; x, edge[tot] &#x3D; 0, Next[tot] &#x3D; head[y], head[y] &#x3D; tot;\n&#125;\n\nbool bfs() &#123;&#x2F;&#x2F;残量网络上构造分层图\n\tmemset(d, 0, sizeof(d));\n\twhile (q.size()) q.pop();\n\tq.push(s); d[s] &#x3D; 1;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front(); q.pop();\n\t\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i])\n\t\t\tif (edge[i] &amp;&amp; !d[ver[i]]) &#123;&#x2F;&#x2F;剩余容量&gt;0的边\n\t\t\t\tq.push(ver[i]);\n\t\t\t\td[ver[i]] &#x3D; d[x] + 1;&#x2F;&#x2F;\n\t\t\t\tif (ver[i] &#x3D;&#x3D; t) return 1;\n\t\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nint dinic(int x, int flow) &#123;&#x2F;&#x2F;在当前分层图上增广\n\tif (x &#x3D;&#x3D; t) return flow;\n\tint rest &#x3D; flow, k;&#x2F;&#x2F;\n\tfor (int i &#x3D; head[x]; i &amp;&amp; rest; i &#x3D; Next[i])\n\t\tif (edge[i] &amp;&amp; d[ver[i]] &#x3D;&#x3D; d[x] + 1) &#123;\n\t\t\tk &#x3D; dinic(ver[i], min(rest, edge[i]));&#x2F;&#x2F;更新剩余容量\n\t\t\tif (!k) d[ver[i]] &#x3D; 0;&#x2F;&#x2F;剪枝,去掉增广完毕的点\n\t\t\tedge[i] -&#x3D; k;\n\t\t\tedge[i ^ 1] +&#x3D; k;\n\t\t\trest -&#x3D; k;&#x2F;&#x2F;\n\t\t&#125;\n\t&#x2F;&#x2F;head[x] &#x3D; i;&#x2F;&#x2F;当前弧优化（避免重复遍历从x出发不可扩展的边）改了残量网络!\n\treturn flow - rest;&#x2F;&#x2F;sum(k):最大可增广流量\n&#125;\n\nvoid add2(int x, int y)\n&#123;\n\ta[x].push_back(y);\n&#125;\n\nvoid tarjan(int x)\n&#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tstk[++top] &#x3D; x; ins[x] &#x3D; 1;\n\tint y;\n\tfor (int i &#x3D; 0; i &lt; a[x].size(); i++)\n\t\tif (!dfn[y &#x3D; a[x][i]])\n\t\t&#123;\n\t\t\ttarjan(y);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t&#125;\n\t\telse if (ins[y]) low[x] &#x3D; min(low[x], dfn[y]);\n\t\tif (dfn[x] &#x3D;&#x3D; low[x])\n\t\t&#123;\n\t\t\tscc++;\n\t\t\tdo &#123;y &#x3D; stk[top--]; ins[y] &#x3D; 0; c[y] &#x3D; scc;&#125; while (x !&#x3D; y);\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &gt;&gt; p)\n\t&#123;\n\t\tmemset(head, 0, sizeof(head));\n\t\ts &#x3D; 0, t &#x3D; n + m + 1; tot &#x3D; 1; maxflow &#x3D; 0;\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++) add(s, i, 1);&#x2F;&#x2F;源点连边\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; m; i++) add(i + n, t, 1);&#x2F;&#x2F;汇点连边\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; p; i++)\n\t\t&#123;\n\t\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\t\tadd(x, n + y, 1), e[i] &#x3D; tot;&#x2F;&#x2F;&lt;-tot-\n\t\t&#125;\n\t\twhile (bfs())&#x2F;&#x2F;一直尝试增广，直到残量网络中S不可达T\n\t\t\twhile (i &#x3D; dinic(s, inf)) maxflow +&#x3D; i;\n\t\t&#x2F;&#x2F;将残量网络中[S,T除外 相反]的匹配边(&lt;-)连边，非匹配边(-&gt;)连边建新图\n\t\tfor (i &#x3D; s; i &lt;&#x3D; t; i++) a[i].clear();\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; p; i++)&#x2F;&#x2F;edge[e[i]]:反向边的剩余容量\n\t\t\t&#x2F;&#x2F;非匹&lt;-0-(-1-&gt;没flow流过) x-&gt;y\n\t\t\tif (!edge[e[i]]) add2(ver[e[i]], ver[e[i] ^ 1]);\n\t\t\t&#x2F;&#x2F;匹&lt;-1-(-0-&gt;流过) x&lt;-y\n\t\t\telse add2(ver[e[i] ^ 1], ver[e[i]]);\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++)&#x2F;&#x2F;非匹&lt;-0-(-1-&gt;):s&lt;-i 否则 匹&lt;-1-:s-&gt;i\n\t\t\tif (!edge[2 * i]) add2(i, s); else add2(s, i);\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; m; i++)&#x2F;&#x2F;非匹&lt;-0-(-1-&gt;):n+i&lt;-t 否则 匹&lt;-1-:n+i-&gt;t\n\t\t\tif (!edge[2 * (n + i)]) add2(t, n + i); else add2(n + i, t);\n\t\tmemset(dfn, 0, sizeof(dfn));\n\t\tmemset(ins, 0, sizeof(ins));\n\t\tmemset(c, 0, sizeof(c));\n\t\ttop &#x3D; num &#x3D; scc &#x3D; ans &#x3D; 0;\n\t\tfor (i &#x3D; s; i &lt;&#x3D; t; i++)\n\t\t\tif (!dfn[i]) tarjan(i);&#x2F;&#x2F;求scc\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; p; i++)\n\t\t\tif (edge[e[i]] || c[ver[e[i]]] &#x3D;&#x3D; c[ver[e[i] ^ 1]]) ans++;&#x2F;&#x2F;可行边\n\t\tcout &lt;&lt; (ans &#x3D; p - ans) &lt;&lt; endl;&#x2F;&#x2F;不可行边数\n\t\tif (!ans) cout &lt;&lt; endl;\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; p; i++)\n\t\t\tif (!edge[e[i]] &amp;&amp; c[ver[e[i]]] !&#x3D; c[ver[e[i] ^ 1]])&#x2F;&#x2F;不可行边\n\t\t\t\tif (--ans) printf(&quot;%d &quot;, i); else printf(&quot;%d\\n&quot;, i);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;【最小割(边容量之和最小的割边集)&#x3D;&#x3D;最大流】\n&#x2F;&#x2F; AcWing 381. 有线电视网络\t\t点边转化; +INF:防止割断\n&#x2F;&#x2F;Author:xht37\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 56, M &#x3D; 20006, INF &#x3D; 0x3f3f3f3f;\nint n, m, s, t;\nint a[N*N], b[N*N], d[N&lt;&lt;1];\nint Head[N&lt;&lt;1], Edge[M], Leng[M], Next[M], tot;\n\ninline void add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y, Leng[tot] &#x3D; z, Next[tot] &#x3D; Head[x], Head[x] &#x3D; tot;\n\tEdge[++tot] &#x3D; x, Leng[tot] &#x3D; 0, Next[tot] &#x3D; Head[y], Head[y] &#x3D; tot;\n&#125;\n\ninline bool bfs() &#123;\n\tmemset(d, 0, sizeof(d));\n\tqueue&lt;int&gt; q;\n\tq.push(s);\n\td[s] &#x3D; 1;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\t\tif (z &amp;&amp; !d[y]) &#123;\n\t\t\t\tq.push(y);\n\t\t\t\td[y] &#x3D; d[x] + 1;\n\t\t\t\tif (y &#x3D;&#x3D; t) return 1;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\ninline int dinic(int x, int f) &#123;\n\tif (x &#x3D;&#x3D; t) return f;\n\tint rest &#x3D; f;\n\tfor (int i &#x3D; Head[x]; i &amp;&amp; rest; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (z &amp;&amp; d[y] &#x3D;&#x3D; d[x] + 1) &#123;\n\t\t\tint k &#x3D; dinic(y, min(rest, z));\n\t\t\tif (!k) d[y] &#x3D; 0;\n\t\t\tLeng[i] -&#x3D; k;\n\t\t\tLeng[i^1] +&#x3D; k;\n\t\t\trest -&#x3D; k;\n\t\t&#125;\n\t&#125;\n\treturn f - rest;\n&#125;\n\ninline void Cable_TV_Network() &#123;\n\tfor (int i &#x3D; 0; i &lt; m; i++) &#123;\n\t\tchar str[20];\n\t\tscanf(&quot;%s&quot;, str);\n\t\ta[i] &#x3D; b[i] &#x3D; 0;\n\t\tint j;\n\t\tfor (j &#x3D; 1; str[j] !&#x3D; &#39;,&#39;; j++) a[i] &#x3D; a[i] * 10 + str[j] - &#39;0&#39;;\n\t\tfor (j++; str[j] !&#x3D; &#39;)&#39;; j++) b[i] &#x3D; b[i] * 10 + str[j] - &#39;0&#39;;\n\t&#125;\n\tint ans &#x3D; INF;\n\tfor (s &#x3D; 0; s &lt; n; s++)&#x2F;&#x2F;枚举s t\n\t\tfor (t &#x3D; 0; t &lt; n; t++)\n\t\t\tif (s !&#x3D; t) &#123;\n\t\t\t\tmemset(Head, 0, sizeof(Head));\n\t\t\t\ttot &#x3D; 1;\n\t\t\t\tint maxf &#x3D; 0;\n\t\t\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\t\t\tif (i &#x3D;&#x3D; s || i &#x3D;&#x3D; t) add(i, i + n, INF);&#x2F;&#x2F;st:s-INF-&gt;s&#39;\n\t\t\t\t\telse add(i, i + n, 1);\n\t\t\t\tfor (int i &#x3D; 0; i &lt; m; i++) &#123;\n\t\t\t\t\tadd(a[i] + n, b[i], INF);\n\t\t\t\t\tadd(b[i] + n, a[i], INF);\n\t\t\t\t&#125;\n\t\t\t\twhile (bfs()) &#123;\n\t\t\t\t\tint num;\n\t\t\t\t\twhile ((num &#x3D; dinic(s, INF))) maxf +&#x3D; num;\n\t\t\t\t&#125;\n\t\t\t\tans &#x3D; min(ans, maxf);&#x2F;&#x2F;\n\t\t\t&#125;\n\tif (n &lt;&#x3D; 1 || ans &#x3D;&#x3D; INF) ans &#x3D; n;&#x2F;&#x2F;n&#x3D;0 1\n\tcout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m) Cable_TV_Network();\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;【费用流】EK最大流+残量网络上SPFA求最长&#x2F;短路 容量z 0,单位费用c -c\n&#x2F;&#x2F; AcWing 382. K取方格数\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int N &#x3D; 5010, M &#x3D; 200010;\nint ver[M], edge[M], cost[M], Next[M], head[N];\nint d[N], incf[N], pre[N], v[N];\nint n, k, tot, s, t, maxflow, ans;\n\nvoid add(int x, int y, int z, int c) &#123;\n\t&#x2F;&#x2F; 正向边，初始容量z，单位费用c\n\tver[++tot] &#x3D; y, edge[tot] &#x3D; z, cost[tot] &#x3D; c;\n\tNext[tot] &#x3D; head[x], head[x] &#x3D; tot;\n\t&#x2F;&#x2F; 反向边，初始容量0，单位费用-c，与正向边“成对存储”\n\tver[++tot] &#x3D; x, edge[tot] &#x3D; 0, cost[tot] &#x3D; -c;\n\tNext[tot] &#x3D; head[y], head[y] &#x3D; tot;\n&#125;\n\nint num(int i, int j, int k) &#123;&#x2F;&#x2F;k:0 1\n\treturn (i - 1)*n + j + k*n*n;\n&#125;\n\nbool spfa() &#123;\n\tqueue&lt;int&gt; q;\n\tmemset(d, 0xcf, sizeof(d)); &#x2F;&#x2F; -INF\n\tmemset(v, 0, sizeof(v));\n\tq.push(s); d[s] &#x3D; 0; v[s] &#x3D; 1; &#x2F;&#x2F; SPFA 求最长路\n\tincf[s] &#x3D; 1 &lt;&lt; 30; &#x2F;&#x2F; 增广路上各边的最小剩余容量\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front(); v[x] &#x3D; 0; q.pop();\n\t\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tif (!edge[i]) continue; &#x2F;&#x2F; 剩余容量为0，不在残量网络中，不遍历\n\t\t\tint y &#x3D; ver[i];\n\t\t\tif (d[y]&lt;d[x] + cost[i]) &#123;\n\t\t\t\td[y] &#x3D; d[x] + cost[i];\n\t\t\t\tincf[y] &#x3D; min(incf[x], edge[i]);\n\t\t\t\tpre[y] &#x3D; i; &#x2F;&#x2F; 记录前驱，便于找到最长路的实际方案\n\t\t\t\tif (!v[y]) v[y] &#x3D; 1, q.push(y);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif (d[t] &#x3D;&#x3D; 0xcfcfcfcf) return false; &#x2F;&#x2F; 汇点不可达，已求出最大流\n\treturn true;&#x2F;&#x2F;残量网络有增广路\n&#125;\n\n&#x2F;&#x2F; 更新最长增广路及其反向边的剩余容量\nvoid update() &#123;\n\tint x &#x3D; t;&#x2F;&#x2F;(n,n)出点t&#x3D;2*n*n\n\twhile (x !&#x3D; s) &#123;\n\t\tint i &#x3D; pre[x];\n\t\tedge[i] -&#x3D; incf[t];&#x2F;&#x2F;剩余容量\n\t\tedge[i ^ 1] +&#x3D; incf[t]; &#x2F;&#x2F; 利用“成对存储”的xor 1技巧\n\t\tx &#x3D; ver[i ^ 1];\n\t&#125;\n\tmaxflow +&#x3D; incf[t];\n\tans +&#x3D; d[t] * incf[t];&#x2F;&#x2F;sum(max_cost)*max_flow\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; k;\n\ts &#x3D; 1, t &#x3D; 2 * n * n;\n\ttot &#x3D; 1; &#x2F;&#x2F; 一会儿要从2开始“成对存储”，2和3是一对，4和5是一对\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\tint c; scanf(&quot;%d&quot;, &amp;c);\n\t\t\tadd(num(i, j, 0), num(i, j, 1), 1, c);\n\t\t\tadd(num(i, j, 0), num(i, j, 1), k - 1, 0);\n\t\t\tif (j&lt;n) add(num(i, j, 1), num(i, j + 1, 0), k, 0);\n\t\t\tif (i&lt;n) add(num(i, j, 1), num(i + 1, j, 0), k, 0);\n\t\t&#125;\n\twhile (spfa()) update(); &#x2F;&#x2F; 计算最大费用最大流\n\tcout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n\n\n------------------------------------------------------------------------------\n&#x2F;&#x2F;0x6B. 总结与练习\n&#x2F;&#x2F; AcWing 383. 观光\n\n&#x2F;&#x2F; AcWing 384. 升降梯上\n\n&#x2F;&#x2F; AcWing 385. GF和猫咪的玩具\n\n&#x2F;&#x2F; AcWing 386. 社交网络\n\n&#x2F;&#x2F; AcWing 387. 北极网络\n\n&#x2F;&#x2F; AcWing 388. 四叶草魔杖\n\n&#x2F;&#x2F; AcWing 389. 直径\n\n&#x2F;&#x2F; AcWing 390. 逃学的小孩\n\n&#x2F;&#x2F; AcWing 391. 聚会\n\n&#x2F;&#x2F; AcWing 392. 会合\n\n&#x2F;&#x2F; AcWing 393. 雇佣收银员\n\n&#x2F;&#x2F; AcWing 394. 最优高铁环\n\n&#x2F;&#x2F; AcWing 395. 冗余路径\n\n&#x2F;&#x2F; AcWing 396. 矿场搭建\n\n&#x2F;&#x2F; AcWing 397. 逃不掉的路\n\n&#x2F;&#x2F; AcWing 398. 交通实时查询系统\n\n&#x2F;&#x2F; AcWing 399. 约翰的旅行\n\n&#x2F;&#x2F; AcWing 400. 太鼓达人\n\n&#x2F;&#x2F; AcWing 401. 从u到v还是从v到u？\n\n&#x2F;&#x2F; AcWing 402. 杀人游戏\n\n&#x2F;&#x2F; AcWing 403. 平面\n\n&#x2F;&#x2F; AcWing 404. 婚礼\n\n&#x2F;&#x2F; AcWing 405. 将他们分好队\n\n&#x2F;&#x2F; AcWing 406. 放置机器人\n\n&#x2F;&#x2F; AcWing 407. 稳定的牛分配\n\n&#x2F;&#x2F; AcWing 408. 回家\n\n&#x2F;&#x2F; AcWing 409. 空袭\n\n&#x2F;&#x2F; AcWing 410. 排版幻灯片\n\n&#x2F;&#x2F; AcWing 411. 国王的任务\n\n&#x2F;&#x2F; AcWing 412. 排水沟\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n","feature":true,"text":"0x00基本算法&#x2F;&#x2F;a^b %p #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace...","link":"","photos":[],"count_time":{"symbolsCount":"413k","symbolsTime":"6:15"},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x00%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">0x00基本算法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x10%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">0x10基本数据结构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x20%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">0x20搜索</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x30%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">0x30数学知识</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x40%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">0x40数据结构进阶</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x50%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP\"><span class=\"toc-text\">0x50动态规划DP</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x60%E5%9B%BE%E8%AE%BA\"><span class=\"toc-text\">0x60图论</span></a></li></ol>","author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"友链","uid":"1d1c88f130e9de4ee596cb4197a6833d","slug":"友链","date":"2022-08-22T12:56:15.000Z","updated":"2022-08-22T08:55:36.906Z","comments":true,"path":"api/articles/友链.json","keywords":null,"cover":"http://p1.qhimg.com/bdm/480_296_0/t01fbb31f1f9cc7c9d7.jpg","text":"这是我做的itzy8.top仿牛客技术交流社区项目，欢迎来玩啊hh~ Java学习路线 编程导航 Java全栈知识体系 https://javaguide.cn/ 敖丙-文章目录（附硬核面试点脑图） (qq.com) 牛客的Java工程师面试宝典 全菜工程师小辉专栏-Java面试...","link":"","photos":[],"count_time":{"symbolsCount":406,"symbolsTime":"1 mins."},"categories":[{"name":"友链","slug":"友链","count":1,"path":"api/categories/友链.json"}],"tags":[{"name":"友链","slug":"友链","count":1,"path":"api/tags/友链.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Hadoop组件基础","uid":"e742771fc0750ee9de279875153316db","slug":"Hadoop组件基础","date":"2018-12-27T13:51:36.000Z","updated":"2022-08-22T08:37:18.230Z","comments":true,"path":"api/articles/Hadoop组件基础.json","keywords":null,"cover":"http://browser9.qhimg.com/bdm/480_296_0/t0105c03978f0adef4b.jpg","text":"Vi命令{width&#x3D;”6.809942038495188in”height&#x3D;”4.260115923009624in”} HDFS{width&#x3D;”5.768055555555556in”height&#x3D;”2.9347222222222222...","link":"","photos":[],"count_time":{"symbolsCount":"91k","symbolsTime":"1:22"},"categories":[{"name":"大数据","slug":"大数据","count":2,"path":"api/categories/大数据.json"}],"tags":[{"name":"大数据","slug":"大数据","count":2,"path":"api/tags/大数据.json"}],"author":{"name":"CodingSeed","slug":"blog-author","avatar":"http://cache.itzy8.top/img/a.jpg","link":"/","description":"","socials":{"github":"https://github.com/codingseed","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}