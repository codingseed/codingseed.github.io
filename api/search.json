[{"id":"1d1c88f130e9de4ee596cb4197a6833d","title":"友链","content":"这是我做的itzy8.top仿牛客技术交流社区项目，欢迎来玩啊hh~\nJava学习路线\n编程导航\nJava全栈知识体系\nhttps://javaguide.cn/\n敖丙-文章目录（附硬核面试点脑图） (qq.com)\n牛客的Java工程师面试宝典\n全菜工程师小辉专栏-Java面试你要知道这些\n努力更文的小白-掘金专栏\nJava程序员进阶之路x沉默王二 | Java 程序员进阶之路 (tobebetterjavaer.com)\n设计模式就该这样学 - Tom弹架构的专栏 - 掘金 (juejin.cn)\ngo：https://www.liwenzhou.com/\n数组与切片有什么异同 | Go 程序员面试笔试宝典 (golang.design)\nPE：https://blog.csdn.net/kwansy/category_10044050.html\n一位计算机牛人的心得，谈计算机和数学【教材推荐】\n","slug":"友链","date":"2022-08-22T12:56:15.000Z","categories_index":"友链","tags_index":"友链","author_index":"CodingSeed"},{"id":"fdecd5d933e92063c33253528b945c35","title":"算法竞赛进阶指南yyds","content":"0x00基本算法&#x2F;&#x2F;a^b %p\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a, b, p;\n\n&#x2F;&#x2F;快速幂\nint power(int a,int b,int p)&#123;&#x2F;&#x2F;(a^b)%p\n\tint ans &#x3D; 1 % p;&#x2F;&#x2F;b&#x3D;&#x3D;0会跳过for，a^0&#x3D;1%1&#x3D;0 而不是1，故先1%p !!!!! \n\tfor(;b;b &gt;&gt;&#x3D; 1)&#123;\n\t\tif(b &amp; 1) ans &#x3D; ans * 1ll * a % p;&#x2F;&#x2F; (long long)\n\t\ta &#x3D; a * 1ll * a % p;&#x2F;&#x2F;a a^2 a^4 a^8\n\t&#125;\n\treturn ans;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n\tcout &lt;&lt; power(a, b, p) &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;64位整数乘法\n#include&lt;iostream&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nULL a, b, p;\n&#x2F;&#x2F;快速乘\nULL mul(ULL a,ULL b,ULL p) &#123;\n\tULL ans &#x3D; 0;\n\tfor(;b;b &gt;&gt;&#x3D; 1)&#123;\n\t\tif(b &amp; 1) ans &#x3D; (ans + a) % p;\n\t\ta &#x3D; a * 2 % p;\n\t&#125;\n\treturn ans;\n&#125;\n&#x2F;*\nULL mul(ULL a,ULL b,ULL p) &#123;\n\ta %&#x3D; p , b %&#x3D; p;\n\tULL c &#x3D; (long double) a * b &#x2F; p;\n\tULL ans &#x3D; a * b - c * p;\n\tif(ans &lt; 0) ans +&#x3D; p;\n\telse if(ans &gt;&#x3D; p) ans -&#x3D; p;\n\treturn ans;\n&#125;\n*&#x2F;\nint main() &#123;\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n\tcout &lt;&lt; mul(a, b, p) &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;bin状压DP：最短Hamilton路径\n\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 20,M &#x3D; 1 &lt;&lt; 20;\n\nint n;\nint f[M][N],weight[N][N];\n\nint hamilton(int n,int weight[N][N]) &#123;\n\tmemset(f,0x3f,sizeof(f));\n\tf[1][0] &#x3D; 0;\n\tfor(int i &#x3D; 1;i &lt; 1 &lt;&lt; n;i++)\n\t\tfor(int j &#x3D; 0; j &lt; n; j++) if(i &gt;&gt; j &amp; 1)&#x2F;&#x2F;i的j位&#x3D;&#x3D;1\n\t\t\tfor(int k &#x3D; 0; k &lt; n; k++) if((i ^ 1 &lt;&lt; j) &gt;&gt; k &amp; 1)\n\t\t\t&#x2F;&#x2F;i的j位取反为0时，k位&#x3D;&#x3D;1\n\t\t\t\tf[i][j] &#x3D; min(f[i][j],f[i ^ 1 &lt;&lt; j][k] + weight[k][j]);\n\treturn f[(1 &lt;&lt; n) - 1][n-1];\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n;\n\tfor(int i &#x3D; 0;i &lt; n; i++)\n\t\tfor(int j &#x3D; 0;j &lt; n; j++)\n\t\t\tcin &gt;&gt; weight[i][j];\n\t\t\t\n\tint ans &#x3D; hamilton(n,weight);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;acwing 998. 起床困难综合症\n#include &lt;iostream&gt;\n\nusing namespace std;\nint n, m;\npair&lt;string, int&gt; a[100010];\n\nint calc(int bit,int now)&#123; &#x2F;&#x2F;遍历门(对bit位做n次位运算)\n\tfor(int i &#x3D; 1;i &lt;&#x3D; n;i++)&#123;\n\t\tint x &#x3D; a[i].second &gt;&gt; bit &amp; 1;&#x2F;&#x2F;取bit位\n\t\tif(a[i].first &#x3D;&#x3D; &quot;AND&quot;) now &amp;&#x3D; x;\n\t\telse if(a[i].first &#x3D;&#x3D; &quot;OR&quot;) now |&#x3D; x;\n\t\telse now ^&#x3D; x;\n\t&#125;\n\treturn now;\n&#125;\n\nint main()&#123;\n\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#123;\n\t\tchar str[5];int x;\n\t\t&#x2F;&#x2F; cin &gt;&gt; str &gt;&gt; x;\n\t\tscanf(&quot;%s%d&quot;, str, &amp;x);\n\t\ta[i] &#x3D; make_pair(str,x);\n\t&#125;\n\tint val &#x3D; 0,ans &#x3D; 0;\n\tfor(int bit &#x3D; 29; bit &gt;&#x3D; 0; bit--)&#123;&#x2F;&#x2F;10^9~~2^30 遍历每一bit\n\t\tint res0 &#x3D; calc(bit,0);\n\t\tint res1 &#x3D; calc(bit,1);\n\t\tif(val + (1&lt;&lt;bit) &lt;&#x3D; m  &amp;&amp; res0 &lt; res1)&#x2F;&#x2F; 0&lt;1\n\t\t\tval +&#x3D; 1 &lt;&lt; bit, ans +&#x3D; res1 &lt;&lt; bit;\n\t\telse\n\t\t\tans +&#x3D; res0 &lt;&lt; bit;\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;*\n位运算：\n1.用异或实现配偶（最后一位取反）\n\n0^1&#x3D;1,1^1&#x3D;0\n4^1&#x3D;5,5^1&#x3D;4\n\n最小费用流：实现成对的正向&#x2F;反向边\ne[idx]\ne[idx^1]\n\n2. lowbit运算 （树状数组）\n一个num的最后一位1\nlowbit(n) &#x3D; n&amp;(~n+1) &#x3D; n&amp;(-n)\n\n\tint H[37];&#x2F;&#x2F;0&lt;&#x3D;n&lt;&#x3D;35\n\tfor(int i &#x3D; 0; i &lt; 36; i++) H[(1ll &lt;&lt; i) % 37] &#x3D; i;\n\twhile(cin &gt;&gt; n)&#123;\n\twhile(n &gt; 0)&#123;\n\t\tcout &lt;&lt; H[(n &amp; (-n) % 37)] &lt;&lt; &#39; &#39;;\n\t\tn -&#x3D; n &amp; -n;\n\t&#125;\n\tcout &lt;&lt; endl;\n\n\n*&#x2F;\n\n&#x2F;&#x2F;递归枚举 2^n\n#include &lt;iostream&gt;\n\nusing namespace std;\nint n;\n\nvoid dfs(int u, int state)&#123;\n\tif(u &#x3D;&#x3D; n)&#123;\n&#x2F;&#x2F;        int H[37];&#x2F;&#x2F;0&lt;&#x3D;n&lt;&#x3D;35\n&#x2F;&#x2F;        for(int i &#x3D; 0; i &lt; 36; i++) H[(1ll &lt;&lt; i) % 37] &#x3D; i;\n&#x2F;&#x2F;        while(state &gt; 0)&#123;\n&#x2F;&#x2F;            cout &lt;&lt; H[(state &amp; (-state) % 37)] + 1 &lt;&lt; &#39; &#39;;\n&#x2F;&#x2F;            state -&#x3D; state &amp; -state;\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;\t\tcout &lt;&lt; endl;\n\n\t\tfor(int i &#x3D; 0; i &lt; n;i++)\n\t\t\tif(state &gt;&gt; i &amp; 1)\n\t\t\t\tcout &lt;&lt; i + 1 &lt;&lt; &#39; &#39;;&#x2F;&#x2F;1的所有位置(被选的数字)\n\t\tcout &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tdfs(u+1,state);&#x2F;&#x2F;不选\n\tdfs(u+1,state | 1 &lt;&lt; u);&#x2F;&#x2F;选: u位置1\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n;\n\tdfs(0, 0);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;递归枚举C(n,m)\n#include &lt;iostream&gt;\n\nusing namespace std;\nint n, m;\n\nvoid dfs(int u, int sum, int state)&#123;\n\tif(sum + n - u &lt; m) return;&#x2F;&#x2F;已选+余下所有 &lt; m:不可能了\n\tif(sum &#x3D;&#x3D; m)&#123;&#x2F;&#x2F;等价于 sum&gt;m : return  + 上述情况 --&gt;   x&#x3D;&#x3D;n :cout\n\t\tfor(int i &#x3D; 0; i &lt; n;i++)\n\t\t\tif(state &gt;&gt; i &amp; 1)\n\t\t\t\tcout &lt;&lt; i + 1 &lt;&lt; &#39; &#39;;&#x2F;&#x2F;1的所有位置(被选的数字)\n\t\tcout &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tif(u &#x3D;&#x3D; n) return;&#x2F;&#x2F;还没选够m但已经递归到n了，结束\n\n\tdfs(u+1, sum+1, state | 1 &lt;&lt; u);&#x2F;&#x2F;选: u位置1(字典序优先:能选就先选)\n\tdfs(u+1, sum, state);&#x2F;&#x2F;不选\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tdfs(0, 0, 0);&#x2F;&#x2F;cur第几个数，选了几个数，选了哪些数1&#x2F;0\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;递归枚举P(10) 全排列n!\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n;\nvector&lt;int&gt; path;\n\nvoid dfs(int u, int state)&#123;\n\tif(u &#x3D;&#x3D; n)&#123;\n\t\tfor(auto x : path) cout &lt;&lt; x &lt;&lt; &#39; &#39;;&#x2F;&#x2F;!!!!!!!\n\t\tcout &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t\tif(!(state &gt;&gt; i &amp; 1))&#123;&#x2F;&#x2F;没有:不选分支\n\t\t\tpath.push_back(i+1);\n\t\t\tdfs(u+1,state | (1 &lt;&lt; i));\n\t\t\tpath.pop_back();\n\t\t&#125;\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n;\n\tdfs(0, 0);&#x2F;&#x2F;cur,state\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;费解的开关\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int INF &#x3D; 100000; \nchar g[10][10];\nint dx[5] &#x3D; &#123;0, -1, 0, 1, 0&#125;, dy[5] &#x3D; &#123;0, 0, 1, 0, -1&#125;;&#x2F;&#x2F;上右下左\n\nvoid turn(int x,int y)\n&#123;\n\tfor(int i &#x3D; 0; i &lt; 5; i++)\n\t&#123;\n\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n\t\tif(a &gt;&#x3D; 0 &amp;&amp; a &lt; 5 &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; 5)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; g[a][b] &#x3D; &#39;0&#39; + (&#39;1&#39; - g[a][b]);\n\t\t\tg[a][b] ^&#x3D; 1;&#x2F;&#x2F; +1&#x2F;-1 &#39;0&#39;&lt;---&gt;&#39;1&#39;\n\t\t&#125;\n\t&#125;\n&#125;\nint work()\n&#123;&#x2F;&#x2F;--&gt;全1\n\tint ans &#x3D; INF;\n\tfor(int k &#x3D; 0; k &lt; 1 &lt;&lt; 5; k++)\n\t&#123;\n\t\tint res &#x3D; 0;\n\t\tchar backup[10][10];\n\t\tmemcpy(backup, g, sizeof g);\n&#x2F;*\n下面for循环这里不是在枚举第一行灯的所有状态，使第1行全1。\n而是在《枚举》对第一行的《所有操作方式!!!》（与给出局面无关!）。该位为1就点击该位。\n最终得到针对给出局面的合法点击方案，取点击min次的。\n*&#x2F;\n\t\tfor(int j &#x3D; 0; j &lt; 5; j++)\n\t\t\tif(k &gt;&gt; j &amp; 1)&#123;\n\t\t\t\tres++;\n\t\t\t\tturn(0,j);&#x2F;&#x2F;点击0行j位\n\t\t\t&#125;\n\t\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; 5; j++)\n\t\t\t\tif(g[i][j] &#x3D;&#x3D; &#39;0&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tres++;\n\t\t\t\t\tturn(i+1,j);\n\t\t\t\t&#125;\n\t\tbool is_successful &#x3D; true;\n\t\tfor(int j &#x3D; 0; j &lt; 5; j++)\n\t\t\tif(g[4][j] &#x3D;&#x3D; &#39;0&#39;)&#123;\n\t\t\t\tis_successful &#x3D; false;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\n\t\tif(is_successful) ans &#x3D; min(ans, res);\n\t\tmemcpy(g, backup,sizeof backup);\n\t&#125;\n\tif(ans &gt; 6) return -1;\n\treturn ans;\n&#125;\n\nint main()&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile(T--)&#123;\n\t\tfor(int i &#x3D; 0; i &lt; 5; i++) cin &gt;&gt; g[i];&#x2F;&#x2F;一次一行\n\t\tcout &lt;&lt; work() &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;96. 奇怪的汉诺塔\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nint main()&#123;\n\tint d[15],f[15];&#x2F;&#x2F;d:3塔,f:4塔\n\t\n\td[1] &#x3D; 1;\n\tfor(int i &#x3D;2; i &lt;&#x3D; 12; i++)\n\t\td[i] &#x3D; 1 + d[i-1] * 2;\n\t\n\tmemset(f, 0x3f, sizeof f);\n\tf[0] &#x3D; 0;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; 12; i++)\n\t\tfor(int j &#x3D; 0; j &lt; i; j++)\n\t\t\tf[i] &#x3D; min(f[i], 2 * f[j] + d[i-j]);\n\t\t\n\tfor(int i &#x3D; 1; i &lt;&#x3D; 12; i++) cout &lt;&lt; f[i] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;王道机试4.8\n&#x2F;&#x2F;A^B约数之和\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int mod &#x3D; 9901;\n\nint qmi(int a, int k)&#123;&#x2F;&#x2F;sum保证k!&#x3D;0,否则res &#x3D; 1%mod\n\ta %&#x3D; mod;\n\tint res &#x3D; 1;\n\twhile(k)&#123;\n\t\tif(k &amp; 1) res &#x3D; res * a % mod;\n\t\ta &#x3D; a * a % mod;\n\t\tk &gt;&gt;&#x3D; 1;\n\t&#125;\n\treturn res;\n&#125;\n\nint sum(int p,int k)&#123;\n\tif(k &#x3D;&#x3D; 0) return 1;\n\tif(k % 2 &#x3D;&#x3D; 0) return (p % mod * sum(p,k-1) + 1) % mod;&#x2F;&#x2F;偶数：递归\n\treturn (1 + qmi(p, k&#x2F;2+1)) * sum(p, k&#x2F;2) % mod;&#x2F;&#x2F;奇数：分治\n&#125;\n\nint main()&#123;\n\tint A, B;\n\tcin &gt;&gt; A &gt;&gt; B;\n\tint res &#x3D; 1;\n\tfor(int i &#x3D; 2;i &lt;&#x3D; A;i++)&#123;\n\t\tint s &#x3D; 0;\n\t\twhile(A % i &#x3D;&#x3D; 0)&#123;\n\t\t\ts++;\n\t\t\tA &#x2F;&#x3D; i;\n\t\t&#125; \n\t\tif(s) res &#x3D; res * sum(i,s * B) % mod;\n\t&#125;\n\tif(!A) res &#x3D; 0;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;前缀和与2D部分和\n&#x2F;&#x2F;激光炸弹\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 5010;\n\nint g[N][N];\n\nint main()&#123;\n\tint N, R;\n\tcin &gt;&gt; N &gt;&gt; R;&#x2F;&#x2F;地图上的目标数目,正方形的边长\n\tint n &#x3D; R, m &#x3D; R;\n\tfor(int i &#x3D; 0, x, y, w; i &lt; N; i++)&#123;\n\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n\t\tx++; y++;&#x2F;&#x2F;前缀和：从1开始\n\t\tn &#x3D; max(n, x); m &#x3D; max(m, y);&#x2F;&#x2F;坐标上界\n\t\tg[x][y] +&#x3D; w;&#x2F;&#x2F;A[i][j]\n\t&#125;\n\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor(int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t\tg[i][j] +&#x3D; g[i-1][j] + g[i][j-1] -g[i-1][j-1];\n\t&#x2F;&#x2F;枚举边长为r的正方形的右下角坐标[i,j],从[r,r]开始\n\tint res &#x3D; 0;\n\tfor(int i &#x3D; R; i &lt;&#x3D; n; i++)\n\t\tfor(int j &#x3D; R; j &lt;&#x3D; m; j++)\n\t\t\tres &#x3D;  max(res, g[i][j] - g[i-R][j] - g[i][j-R] + g[i-R][j-R]);\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;差分 区间op-&gt;单点op\n&#x2F;&#x2F;InDec Seq\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 100010;\n\nint a[N];\n\nint main() &#123;\n\tint n;\n\tcin &gt;&gt; n;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n ; i++) cin &gt;&gt; a[i];\n\tfor(int i &#x3D; n; i &gt; 1; i--) a[i] -&#x3D; a[i-1];\n\t\n\tLL pos &#x3D; 0, neg &#x3D; 0;\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n ; i++) \n\t\tif(a[i] &gt; 0) pos +&#x3D; a[i];\n\t\telse neg -&#x3D; a[i];&#x2F;&#x2F;负数之和的绝对值\n\t\n\tcout &lt;&lt; max(pos, neg) &lt;&lt; endl;\n\tcout &lt;&lt; abs(pos - neg) + 1 &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;最高的牛\n&#x2F;&#x2F;必须双端判重，故用set&lt;pair&lt;int, int&gt;&gt;,不用set&lt;int&gt; hash单端check\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n&#x2F;&#x2F; #include &lt;unordered_set&gt;&#x2F;&#x2F;hash\n\nusing namespace std;\n\nconst int N &#x3D; 10010;\n\nint height[N];\n\nint main()&#123;\n\tint n, p, h, m;\n\tcin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m;\n\theight[1] &#x3D; h;&#x2F;&#x2F;+&#x3D;,h+C[i],h做初值 \n\t\n\tset&lt;pair&lt;int, int&gt;&gt; existed;\n\tfor(int i &#x3D; 0, a, b; i &lt; m; i++)&#123;\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\tif(a &gt; b) swap(a,b);\n\t\tif(!existed.count(&#123;a,b&#125;))&#123;\n\t\t\texisted.insert(&#123;a,b&#125;);\n\t\t\theight[a+1]--; height[b]++;&#x2F;&#x2F;得到D\n\t\t&#125;\n\t&#125;\n\t\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n\t\theight[i] +&#x3D; height[i-1];&#x2F;&#x2F;求C:D的前缀和\n\t\tcout &lt;&lt; height[i] &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;二分\n&#x2F;&#x2F;最佳牛围栏\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n, m;&#x2F;&#x2F;子段长度&gt;&#x3D;m\nint cows[N];\ndouble sum[N];\n\nbool check(double avg)&#123;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) sum[i] &#x3D; sum[i-1] + cows[i] - avg;\n\t\n\tdouble minv &#x3D; 0;\n\tfor(int i &#x3D; 0, j &#x3D; m; j &lt;&#x3D; n; j++, i++)&#123;&#x2F;&#x2F;i小j大\n\t\tminv &#x3D; min(minv, sum[i]);\n\t\tif(sum[j] &gt;&#x3D; minv) return true;&#x2F;&#x2F;不用max,存在子段和非负即可\n\t&#125;\n\treturn false;\n&#125;\n\nint main()&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; cows[i];\n\tdouble l &#x3D; 0, r &#x3D; 2000;\n\twhile(r - l &gt; 1e-5)&#123;\n\t\tdouble mid &#x3D; (l + r) &#x2F; 2;\n\t\tif(check(mid)) l &#x3D; mid;\n\t\telse r &#x3D; mid;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, int(r * 1000));\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;max子段和\n\n\n&#x2F;&#x2F;113. 特殊排序  在线交互题\n&#x2F;&#x2F; Forward declaration of compare API.\n&#x2F;&#x2F; bool compare(int a, int b);\n&#x2F;&#x2F; return bool means whether a is less than b.\n\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; specialSort(int N) &#123;\n\t\tvector&lt;int&gt; res;\n\t\tres.push_back(1);\n\t\tfor(int i &#x3D; 2; i &lt;&#x3D; N; i++)&#123;\n\t\t\tint l &#x3D; 0, r &#x3D; res.size() - 1;\n\t\t\twhile(l &lt; r)&#123;\n\t\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;&#x2F;&#x2F;mid入右半,2分模板2\n\t\t\t\tif(compare(res[mid], i)) l &#x3D; mid;\n\t\t\t\telse r &#x3D; mid - 1;\n\t\t\t&#125;&#x2F;&#x2F;res[l&#x3D;&#x3D;r]  &#x3D;&#x3D;  &lt;&#x3D;i的max\n\t\t\tres.push_back(i);\n\t\t\tfor(int j &#x3D; res.size() - 2; j &gt; r; j--) swap(res[j], res[j+1]);\n\t\t\tif(compare(i, res[r])) swap(res[r],res[r+1]);&#x2F;&#x2F;i&#x3D;&#x3D;res[r+1]\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\nvim：\nG:至结尾\ngg：至开始\nv：选择\nv G：全选\nd：删\nu：撤回\n\n&#x2F;&#x2F;05排序\n&#x2F;&#x2F;离散化\n&#x2F;&#x2F;电影\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 200006;\nint n, m, a[N], x[N], y[N], cinema[N*3], tot &#x3D; 0, k, ans[N*3];\n\nint find(int f) &#123;&#x2F;&#x2F;找语言在cinema[]中的下标pos\n\treturn lower_bound(cinema + 1, cinema + k + 1, f) - cinema;\n&#125;\n\nint main() &#123;\n\t&#x2F;&#x2F;离散化\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;a[i]);\n\t\tcinema[++tot] &#x3D; a[i];&#x2F;&#x2F;人\n\t&#125;\n\tcin &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;x[i]);\n\t\tcinema[++tot] &#x3D; x[i];&#x2F;&#x2F;语音\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;y[i]);\n\t\tcinema[++tot] &#x3D; y[i];&#x2F;&#x2F;字幕\n\t&#125;\n\tsort(cinema + 1, cinema + tot + 1);\n\tk &#x3D; unique(cinema + 1, cinema + tot + 1) - (cinema + 1);\n\t\n\tmemset(ans, 0, sizeof(ans));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) ans[find(a[i])]++;&#x2F;&#x2F;会lan的人计数\n\tint ans0 &#x3D; 1, ans1 &#x3D; 0, ans2 &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;&#x2F;&#x2F;找会该lan的人数最多的lan\n\t\tint ansx &#x3D; ans[find(x[i])], ansy &#x3D; ans[find(y[i])];\n\t\tif (ansx &gt; ans1 || (ansx &#x3D;&#x3D; ans1 &amp;&amp; ansy &gt; ans2)) &#123;\n\t\t\tans0 &#x3D; i;\n\t\t\tans1 &#x3D; ansx;\n\t\t\tans2 &#x3D; ansy;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; ans0 &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;中位数\n&#x2F;&#x2F;货仓选址\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100100;\nint a[N], n, ans;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; a[i];\n\tsort(a+1, a+1+n);\n\n\t&#x2F;&#x2F; int md &#x3D; a[n&#x2F;2+1];\n\t&#x2F;&#x2F; for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#x2F;&#x2F;     ans +&#x3D; abs(a[i] - md);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; 2; i++)\n\t\tans +&#x3D; a[n-i+1] - a[i];\n\t&#x2F;&#x2F;12345,md&#x3D;3,(a3-a2)+(a3-a1)+(a4-a3)+(a5-a3)\n\t&#x2F;&#x2F;&#x3D;&#x3D;(a4-a2)+(a5-a1)\n\tcout &lt;&lt; ans;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;七夕祭\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 100006;\nint n, m, t, x[N], y[N], a[N], s[N];\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; t;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) scanf(&quot;%d %d&quot;, &amp;x[i], &amp;y[i]);\n\t&#x2F;&#x2F;感兴趣摊点数能整除行数(列数)，则能使各行(列)中感兴趣摊点数一样多\n\tbool row &#x3D; !(t % n), column &#x3D; !(t % m);\n\tif (row) &#123;\n\t\tif (column) cout &lt;&lt; &quot;both &quot;;\n\t\telse cout &lt;&lt; &quot;row &quot;;\n\t&#125; else &#123;\n\t\tif (column) cout &lt;&lt; &quot;column &quot;;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;\n\t\t\treturn 0;\n\t\t&#125;\n\t&#125;\n\n\tll ans &#x3D; 0;\n\tif (row) &#123;\n\t\tint num &#x3D; t &#x2F; n;\n\t\tmemset(a, 0, sizeof(a));\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) a[x[i]]++;&#x2F;&#x2F;行摊点计数\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i] -&#x3D; num;&#x2F;&#x2F;1.-avg\n\t\ts[0] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) s[i] &#x3D; s[i-1] + a[i];&#x2F;&#x2F;2.前缀和\n\t\tsort(s + 1, s + n + 1);&#x2F;&#x2F;3.环形均分纸牌，k处剪开，ans +&#x3D;（si-sk）最小\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; 2; i++) ans +&#x3D; s[n-i+1] - s[i];&#x2F;&#x2F;3.sk为si中位数\n\t&#125;\n\tif (column) &#123;\n\t\tint num &#x3D; t &#x2F; m;\n\t\tmemset(a, 0, sizeof(a));\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) a[y[i]]++;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) a[i] -&#x3D; num;\n\t\ts[0] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) s[i] &#x3D; s[i-1] + a[i];\n\t\tsort(s + 1, s + m + 1);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m &#x2F; 2; i++) ans +&#x3D; s[m-i+1] - s[i];\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;running median  对顶堆\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\nusing namespace std;\npriority_queue&lt;int&gt; q1, q2;\n&#x2F;&#x2F; priority_queue&lt;int , vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;\nvoid Running_Median() &#123;&#x2F;&#x2F;小q1--&gt;大q2\n\twhile (q1.size()) q1.pop();&#x2F;&#x2F;默认大根堆 少\n\twhile (q2.size()) q2.pop();&#x2F;&#x2F;小根堆(元素取负) 多1：top2&#x3D;&#x3D;median\n\tint num, n;\n\tcin &gt;&gt; num &gt;&gt; n;\n\tcout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; (n + 1) &#x2F; 2 &lt;&lt; endl;\n\tint a;\n\tcin &gt;&gt; a;\n\tcout &lt;&lt; a &lt;&lt; &quot; &quot;;\n\tq2.push(-a);\n\tint cnt &#x3D; 1;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;a);\n\t\tif (a &lt; -q2.top()) q1.push(a);\n\t\telse q2.push(-a);\n\t\tint s &#x3D; q1.size();\n\t\tif (s &gt; i &#x2F; 2) &#123;\n\t\t\tq2.push(-q1.top());\n\t\t\tq1.pop();\n\t\t&#125;\n\t\tif (s &lt; i &#x2F; 2) &#123;\n\t\t\tq1.push(-q2.top());\n\t\t\tq2.pop();\n\t\t&#125;\n\t\tif (i % 2) &#123;\n\t\t\tcout&lt;&lt; -q2.top() &lt;&lt; &quot; &quot;;\n\t\t\tif (++cnt % 10 &#x3D;&#x3D; 0 &amp;&amp; cnt &lt; (n + 1) &#x2F; 2) cout &lt;&lt; endl;&#x2F;&#x2F;坑!!!!!\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint t;\n\tcin &gt;&gt; t;\n\twhile (t--) Running_Median();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;归并sort求逆序对\n&#x2F;&#x2F;超级快排\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N&#x3D;501000;\n\n#define ll long long\n\nll n,m,i,j,k,a[N],b[N],cnt;\n\nvoid merge(ll a[], ll l, ll r)\n&#123;\n\tif (l &#x3D;&#x3D; r) return;\n\tll mid &#x3D; (l + r) &gt;&gt; 1;\n\tmerge(a, l, mid);\n\tmerge(a, mid+1, r);\n\t\n\tll i &#x3D; l, j &#x3D; mid + 1;\n\tfor (ll k &#x3D; l; k &lt;&#x3D; r; k++)\n\t&#123;\n\t\tif (j &gt; r || i &lt;&#x3D; mid &amp;&amp; a[i] &lt;&#x3D; a[j])\n\t\t\tb[k] &#x3D; a[i++];\n\t\telse\n\t\t&#123;\n\t\t\tcnt +&#x3D; mid - i + 1;&#x2F;&#x2F;顺便求\n\t\t\tb[k] &#x3D; a[j++];\n\t\t&#125;\n\t&#125;\n\tfor (ll k &#x3D; l; k &lt;&#x3D; r; k++)\n\t\ta[k] &#x3D; b[k];\n&#125;\n\nint main()\n&#123;\n\tios::sync_with_stdio(false);\n\twhile(cin &gt;&gt; n &amp;&amp; n)\n\t&#123;\n\t\tfor(i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tcin &gt;&gt; a[i];\n\t\tcnt &#x3D; 0;\n\t\tmerge(a, 1, n);\n\t\tcout &lt;&lt; cnt &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;奇数码问题\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nint n;\nlong long ans;&#x2F;&#x2F;逆序对数过大！\nvector&lt;int&gt; a[2];&#x2F;&#x2F;vector&lt;int&gt; a[n]: n个动态数组\nint c[250010];\n\n\nvoid merge(int k, int l, int mid, int r)\n&#123;\n\tint x &#x3D; l, y &#x3D; mid + 1;\n\tfor (int i &#x3D; l; i &lt;&#x3D; r; i++)\n\t&#123;\n\t\tif (y &gt; r || x &lt;&#x3D; mid &amp;&amp; a[k][x] &lt; a[k][y])\n\t\t\tc[i] &#x3D; a[k][x++];\n\t\telse ans +&#x3D; mid - x + 1, c[i] &#x3D; a[k][y++];\n\t&#125;\n\tfor (int i &#x3D; l; i &lt;&#x3D; r; i++) a[k][i] &#x3D; c[i];\n&#125;\n\nvoid mergesort(int k, int l, int r)\n&#123;\n\tif (l &#x3D;&#x3D; r) return;\n\tint mid &#x3D; (l + r) &#x2F; 2;\n\tmergesort(k, l, mid);\n\tmergesort(k, mid + 1, r);\n\tmerge(k, l, mid, r);\n&#125;\n\nlong long calc(int k)&#x2F;&#x2F;a[k]的逆序对数\n&#123;\n\tans &#x3D; 0;\n\tmergesort(k, 0, n*n - 1);\n\treturn ans;\n&#125;\n\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n)\n\t&#123;\n\t\ta[0].clear();\n\t\ta[1].clear();\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t&#123;\n\t\t\t\tint x; \n\t\t\t\tscanf(&quot;%d&quot;, &amp;x); \n\t\t\t\tif(x) a[0].push_back(x);\n\t\t\t&#125;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t&#123;\n\t\t\t\tint x; \n\t\t\t\tscanf(&quot;%d&quot;, &amp;x); \n\t\t\t\tif(x) a[1].push_back(x);\n\t\t\t&#125;\n\t\tputs(a[0].size() &amp;&amp; (calc(1) - calc(0) &amp; 1) ? &quot;NIE&quot; : &quot;TAK&quot;);\n\t&#125;&#x2F;&#x2F;(calc(1)&amp;1)!&#x3D;(calc(0)&amp;1) &#x2F;&#x2F;std::abs(calc(1) - calc(0)) % 2\n&#125;\n\n\n&#x2F;&#x2F;0x06 倍增+bin划分\n&#x2F;&#x2F;天才ACM\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 500006;\nint n, m, w;\nll k, a[N], b[N], c[N];\n\nvoid gb(int l, int mid, int r) &#123;&#x2F;&#x2F;merge\n\tint i &#x3D; l, j &#x3D; mid + 1;\n\tfor (int k &#x3D; l; k &lt;&#x3D; r; k++)\n\t\tif (j &gt; r || (i &lt;&#x3D; mid &amp;&amp; b[i] &lt;&#x3D; b[j])) c[k] &#x3D; b[i++];\n\t\telse c[k] &#x3D; b[j++];\n&#125;\n\nll f(int l, int r) &#123;&#x2F;&#x2F;[l,r]段的校验值\n\tif (r &gt; n) r &#x3D; n;\n\tint t &#x3D; min(m, (r - l + 1) &gt;&gt; 1);&#x2F;&#x2F;m对数,取到不能取为止\n\tfor (int i &#x3D; w + 1; i &lt;&#x3D; r; i++) b[i] &#x3D; a[i];\n\tsort(b + w + 1, b + r + 1);&#x2F;&#x2F;新段部分排序\n\tgb(l, w, r);&#x2F;&#x2F;合并新旧两段\n\tll ans &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; t; i++)\n\t\tans +&#x3D; (c[r-i] - c[l+i]) * (c[r-i] - c[l+i]);\n\treturn ans;\n&#125;\n\nvoid Genius_ACM() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tcin &gt;&gt; k; &#x2F;&#x2F;满足每段check &lt;&#x3D; k\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%lld&quot;, &amp;a[i]);\n\tint ans &#x3D; 0, l &#x3D; 1, r &#x3D; 1;\n\tw &#x3D; 1;\n\tb[1] &#x3D; a[1];\n\twhile (l &lt;&#x3D; n) &#123;\n\t\tint p &#x3D; 1;\n\t\twhile (p) &#123;\n\t\t\tll check &#x3D; f(l, r + p);\n\t\t\tif (check &lt;&#x3D; k) &#123;\n\t\t\t\tw &#x3D; r &#x3D; min(r + p, n);&#x2F;&#x2F;新段起点w&#x3D;旧段终点r&#x3D;r+p，不超过n\n\t\t\t\tfor (int i &#x3D; l; i &lt;&#x3D; r; i++) b[i] &#x3D; c[i];\n\t\t\t\tif (r &#x3D;&#x3D; n) break;\n\t\t\t\tp &lt;&lt;&#x3D; 1;\n\t\t\t&#125; else p &gt;&gt;&#x3D; 1;\n\t\t&#125;  \n\t\tans++;&#x2F;&#x2F;求最少需要分几段\n\t\tl &#x3D; r + 1;\n\t&#125;\n\t&#x2F;&#x2F;由于val不同，根据不同的check &lt;&#x3D; k 来倍增r即段长，故段长不等 \n\t&#x2F;&#x2F;故必须一段一段while，不能直接算ans &#x3D; (n % (r-l+1)) n &#x2F; (r-l+1) + 1 : n &#x2F; (r-l+1);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\tint t;\n\tcin &gt;&gt; t;\n\twhile (t--) Genius_ACM();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;RMQ-ST\n\n\n&#x2F;&#x2F;0x07 贪心\n&#x2F;&#x2F;防晒？？？？？？？？？？？？\n&#x2F;&#x2F; pair 天然按第一第二关键字排序 map&lt;int, int&gt; spfs; spfs[spf] +&#x3D; cover;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int,int&gt; PII;\nconst int N &#x3D; 2510;\n\nint n, m;\nPII cows[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second;\n\tsort(cows, cows + n); &#x2F;&#x2F;min升序？？？？\n\n\tmap&lt;int, int&gt; spfs;&#x2F;&#x2F;下标，数量\n\tfor (int i &#x3D; 0; i &lt; m; i ++ )&#123;\n\t\tint spf, cover;\n\t\tcin &gt;&gt; spf &gt;&gt; cover;\n\t\tspfs[spf] +&#x3D; cover;&#x2F;&#x2F; 注意这里要写 +&#x3D;，因为数据中存在spf值相同的防晒霜\n\t&#125;\n\tint res &#x3D; 0;\n\tspfs[0] &#x3D; spfs[1001] &#x3D; n;&#x2F;&#x2F;哨兵,让upper_bound一句不为空\n\tfor (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )&#x2F;&#x2F;max降序???\n\t&#123;&#x2F;&#x2F;auto spf &#x3D;&#x3D; map&lt;int, int&gt; :: iterator it，泛类型\n\t\tauto spf &#x3D; spfs.upper_bound(cows[i].second);&#x2F;&#x2F; &gt;max的最小spf ？？？？\n\t\tspf --;&#x2F;&#x2F;????\n\t\tif (spf-&gt;first &gt;&#x3D; cows[i].first) &#x2F;&#x2F;spf&gt;&#x3D;min\n\t\t&#123;\n\t\t\tres ++ ;\n\t\t\tif (--spf-&gt;second &#x3D;&#x3D; 0)\n\t\t\t\tspfs.erase(spf);\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;畜栏预定\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\n\nusing namespace std;\n\ntypedef pair&lt;int,int&gt; PII;\nconst int N &#x3D; 50010;\n\nint n;\npair&lt;PII, int&gt; cows[N];&#x2F;&#x2F;&#123;&#123;起点,终点&#125;,ID&#125;\nint id[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n\t\tcin &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second;\n\t\tcows[i].second &#x3D; i;\n\t&#125;\n\t\n\tsort(cows, cows + n);\n\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;&#x2F;&#x2F;stall&#123;终点，ID&#125;,以终点升序的小根堆\n\t\n\tfor(int i &#x3D; 0; i &lt; n; i++)&#123;\n\t\tauto cow &#x3D; cows[i].first;\n\t\tif(heap.empty() || heap.top().first &gt;&#x3D; cow.first)&#123;&#x2F;&#x2F;end牛&#123;终点,ID&#125;的终点 &gt;&#x3D; cur牛的起点\n\t\t\tPII stall &#x3D; &#123;cow.second, heap.size() + 1&#125;;&#x2F;&#x2F;&#123;终点，ID&#125;\n\t\t\tid[cows[i].second] &#x3D; stall.second;&#x2F;&#x2F;id[i]\n\t\t\theap.push(stall);\n\t\t&#125;\n\t\telse&#123;\n\t\t\tauto stall &#x3D; heap.top();\n\t\t\theap.pop();\n\t\t\tstall.first &#x3D; cow.second;&#x2F;&#x2F;end牛的终点\n\t\t\tid[cows[i].second] &#x3D; stall.second;\n\t\t\theap.push(stall);&#x2F;&#x2F;cow入堆顶：pop，更新top，push\n\t\t&#125;\n\t&#125;\n\t\n\tcout &lt;&lt; heap.size() &lt;&lt; endl;\n\tfor(int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; id[i] &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;雷达设备\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\ntypedef pair&lt;double, double&gt; PDD;\nconst int N &#x3D; 1010;\nconst double eps &#x3D; 1e-6, INF &#x3D; 1e10;&#x2F;&#x2F;误差&lt;1e-6,认为相等\n\nint n, R;&#x2F;&#x2F;整数n,d\nPDD segs[N];\n\nint main()\n&#123;\n\tbool success &#x3D; true;\n\tcin &gt;&gt; n &gt;&gt; R;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n\t\tint x, y;\n\t\tcin &gt;&gt; x &gt;&gt; y;\n\t\tif(y &gt; R)&#123;\n\t\t\tsuccess &#x3D; false;\n\t\t\tbreak;\n\t\t&#125; \n\t\tdouble len &#x3D; sqrt(R * R - y * y);\n\t\tsegs[i] &#x3D; &#123;x + len, x - len&#125;;&#x2F;&#x2F;终点，起点\n\t&#125;\n\t\n\tif(!success) puts(&quot;-1&quot;);\n\telse&#123;\n\t\tsort(segs,segs + n);\n\t\tint res &#x3D; 0;\n\t\tdouble last &#x3D; -INF;&#x2F;&#x2F;last:最后一个雷达pos(double型)\n\t\tfor(int i &#x3D; 0; i &lt; n; i++)&#123;\n\t\t\tauto seg &#x3D;  segs[i];\n\t\t\tif(seg.second &gt; last + eps)&#123;\n\t\t\t\tres++;\n\t\t\t\tlast &#x3D; seg.first;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; res &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;国王游戏\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 1010;\n\nint n;\nPII ps[N];\n\n&#x2F;&#x2F; 大*小\nvector&lt;int&gt; mul(vector&lt;int&gt; a, int b)&#123;\n\tvector&lt;int&gt; c;\n\tint t &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; a.size(); i++)&#123;\n\t\tt +&#x3D; a[i] * b;\n\t\tc.push_back(t % 10);\n\t\tt &#x2F;&#x3D; 10;&#x2F;&#x2F;进位\n\t&#125;\n\twhile(t) c.push_back(t % 10), t &#x2F;&#x3D; 10;\n\treturn c;\n&#125;\n&#x2F;&#x2F; 大&#x2F;小\nvector&lt;int&gt; div(vector&lt;int&gt; a, int b)&#123;\n\tvector&lt;int&gt; c;\n\tbool is_first &#x3D; false;\n\tfor(int i &#x3D; a.size() - 1, t &#x3D; 0; i &gt;&#x3D; 0; i--)&#123;\n\t\tt &#x3D; t * 10 + a[i];&#x2F;&#x2F;被除数\n\t\tint x &#x3D; t &#x2F; b;&#x2F;&#x2F;商x\n\t\tif(x || is_first)&#123;&#x2F;&#x2F;去掉商的前导零\n\t\t\tis_first &#x3D; true;\n\t\t\tc.push_back(x);&#x2F;&#x2F;高到低\n\t\t&#125;\n\t\tt %&#x3D; b;&#x2F;&#x2F;余数\n\t&#125;\n\treturn vector&lt;int&gt;(c.rbegin(),c.rend());&#x2F;&#x2F;低到高\n&#125;\n\nvector&lt;int&gt; max_vec(vector&lt;int&gt; a, vector&lt;int&gt; b)&#123;&#x2F;&#x2F;比大小，不比字典序\n\tif(a.size() &gt; b.size()) return a;\n\tif(a.size() &lt; b.size()) return b;\n\tif(vector&lt;int&gt;(a.rbegin(), a.rend()) &gt; vector&lt;int&gt;(b.rbegin(), b.rend()))\n\t&#x2F;&#x2F;构造新的逆序a,b(高--&gt;低) 位数相等比大小：按字典序比\n\t\treturn a;\n\treturn b;\n&#125;\n\nvoid output(vector&lt;int&gt; a)&#123;&#x2F;&#x2F;低位先输入，高位先输出\n\tfor(int i &#x3D; a.size() - 1;i &gt;&#x3D; 0; i--) cout &lt;&lt; a[i];\n\tcout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor(int i &#x3D; 0; i &lt;&#x3D; n; i++)&#123;\n\t\tint a, b;\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\tps[i] &#x3D; &#123;a * b, a&#125;;\n\t&#125;\n\tsort(ps + 1, ps + n + 1);\n\n\tvector&lt;int&gt; product(1, 1);&#x2F;&#x2F;之前的人的左手累乘\n\tvector&lt;int&gt; res(1, 0);&#x2F;&#x2F;vector构造(元素个数，初值)！！！！！！！！\n\t\n\tfor(int i &#x3D; 0; i &lt;&#x3D; n; i++)&#123;&#x2F;&#x2F;0,1-n king不给自己发奖金\n\t\tif(i) res &#x3D; max_vec(res, div(product, ps[i].first &#x2F; ps[i].second));\n\t\tproduct &#x3D; mul(product, ps[i].second);\n\t&#125;\n\toutput(res);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;给树染色\n&#x2F;*\n反序和≤乱序和≤顺序和\n染色代价：反序和最小\n如果直接按上述算法做的话，最终的分值不太容易计算，我们可以在将点合并的时候，\n实时更新当前的权值和：\n\n最初所有点各自为一组，总分值是 S&#x3D;∑i&#x3D;1nai*1；\n接下来每次会将两组点合并，将其中一组点接在另一组点的后面。比如两组点分别\n是 xi 和 yi，我们将 yi 接在 xi 之后，则 yi 中每个点所乘的系数均会增加一个相\n同的偏移量，这个偏移量就是 xi 中点的个数，假设是 k，\n则合并之后，总的权值直接加上 k*∑yi 即可；\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace  std;\n\nconst int N &#x3D; 1010;\n\nstruct node&#123;\n\tint fa, size, sum;\n\tdouble avg;\n&#125;nodes[N];\n\nint n, root;\n\nint find()&#123;&#x2F;&#x2F;找最大权值非根节点\n\tdouble avg &#x3D; 0;\n\tint res &#x3D; -1;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif(i !&#x3D; root &amp;&amp; avg &lt; nodes[i].avg)&#123;\n\t\t\tavg &#x3D; nodes[i].avg;\n\t\t\tres &#x3D; i;\n\t\t&#125;\n\treturn res;\n&#125;    \n\nint main()&#123;\n\tcin &gt;&gt; n &gt;&gt; root;\n\tint res &#x3D; 0;\n\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n\t\tauto &amp;nd &#x3D; nodes[i];\n\t\tcin &gt;&gt; nd.sum;\n\t\tnd.size &#x3D; 1;\n\t\tnd.avg &#x3D; nd.sum;\n\t\tres +&#x3D; nd.sum;\n\t&#125;\n\tfor(int i &#x3D; 0, a, b; i &lt; n - 1; i++)&#123;&#x2F;&#x2F;n-1对父子关系\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\tnodes[b].fa &#x3D; a;\n\t&#125;\n\t\n\tfor(int i &#x3D; 0; i &lt; n - 1; i++)&#123;&#x2F;&#x2F;n-1对合并\n\t\tint cur &#x3D; find();\n\t\tint f &#x3D; nodes[cur].fa;\n\t\tres +&#x3D; nodes[cur].sum * nodes[f].size ;&#x2F;&#x2F;s[n]+(s[i-1]*a[i])+()+()...迭代,不断合并!!!\n\t\tnodes[cur].avg &#x3D; -1;\n\t\tfor(int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tif(nodes[j].fa &#x3D;&#x3D; cur)&#x2F;&#x2F;忽略cur\n\t\t\t\tnodes[j].fa &#x3D; f;\n\t\tnodes[f].sum +&#x3D; nodes[cur].sum;\n\t\tnodes[f].size +&#x3D; nodes[cur].size;\n\t\tnodes[f].avg &#x3D; (double) nodes[f].sum &#x2F; nodes[f].size; \n\t&#125;\n\t\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;飞行员兄弟\n&#x2F;&#x2F;位运算\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace  std;\nint change[4][4];\ntypedef pair&lt;int, int&gt; PII;\n\nint get(int x, int y)\n&#123;\n\treturn x * 4 + y;\n&#125;\n\nint main()&#123;\n\tint state &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t&#123;\n\t\tstring line;\n\t\tcin &gt;&gt; line;\n\t\tfor(int j &#x3D; 0; j &lt; 4; j++)\n\t\t\tif(line[j] &#x3D;&#x3D; &#39;+&#39;) \n\t\t\t\tstate +&#x3D; 1 &lt;&lt; get(i, j);&#x2F;&#x2F;16位局面\n\t&#125;\n\tfor(int i &#x3D; 0; i &lt; 4; i++)&#x2F;&#x2F;同行同列op\n\t\tfor(int j &#x3D; 0; j &lt; 4; j++)\n\t\t&#123;\n\t\t\tfor(int k &#x3D; 0; k &lt; 4; k++)\n\t\t\t&#123;\n\t\t\t\tchange[i][j] +&#x3D; 1 &lt;&lt; get(i,k);\n\t\t\t\tchange[i][j] +&#x3D; 1 &lt;&lt; get(k,j);\n\t\t\t&#125;\n\t\t\tchange[i][j] -&#x3D; 1 &lt;&lt; get(i,j);&#x2F;&#x2F;只减[i][j],for(k)外!!!!!!!\n\t\t&#125;\n\t\n\tvector&lt;PII&gt; res;\n\tfor(int k &#x3D; 0; k &lt; 1 &lt;&lt; 16; k++)\n\t&#123;\n\t\tint now &#x3D; state;\n\t\tvector&lt;PII&gt; path;\n\t\tfor(int i &#x3D; 0; i &lt; 16; i++)\n\t\t\tif(k &gt;&gt; i &amp; 1)\n\t\t\t&#123;\n\t\t\t\tint x &#x3D; i &#x2F; 4, y &#x3D; i % 4;\n\t\t\t\tnow ^&#x3D; change[x][y];&#x2F;&#x2F;改局面\n\t\t\t\tpath.push_back(&#123;x, y&#125;);&#x2F;&#x2F;cur方案加入op\n\t\t\t&#125;\n&#x2F;&#x2F;达到全0(合法) &amp;&amp; (还没合法方案 || 有更小op次数的合法方案path) : 更新res\n\t\tif(!now &amp;&amp; (res.empty() || res.size() &gt; path.size())) res &#x3D; path;\n\t&#125;\n\t\n\tcout &lt;&lt; res.size() &lt;&lt; endl;\n\tfor(auto p : res) cout &lt;&lt; p.first + 1 &lt;&lt; &#39; &#39; &lt;&lt; p.second + 1 &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;占卜DIY  模拟\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 14;\n\nvector&lt;int&gt; cards[N];&#x2F;&#x2F;反1-13\nint open[14];&#x2F;&#x2F;正\n\nint get(char c)\n&#123;\n\tif(c &#x3D;&#x3D; &#39;A&#39;) return 1;\n\tif(c &gt;&#x3D; &#39;2&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) return c - &#39;0&#39;;\n\tif(c &#x3D;&#x3D; &#39;0&#39;) return 10;\n\tif(c &#x3D;&#x3D; &#39;J&#39;) return 11;\n\tif(c &#x3D;&#x3D; &#39;Q&#39;) return 12;\n\treturn 13;\n&#125;\n\nint main()\n&#123;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; 13; i++) \n\t&#123;\n\t\tfor(int j &#x3D; 0; j &lt; 4; j++) \n\t\t&#123;\n\t\t\tchar s[2];&#x2F;&#x2F;&#39;A &#39;!!!!!!\n\t\t\tcin &gt;&gt; s;\n\t\t\tcards[i].push_back(get(*s));&#x2F;&#x2F;*s &#x3D;&#x3D; s[0]\n\t\t&#125;\n\t&#125;\n\t\n\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t&#123;\n\t\tint t &#x3D;  cards[13][i];\n\t\twhile(t !&#x3D; 13)\n\t\t&#123;\n\t\t\topen[t]++;\n\t\t\tint r &#x3D; cards[t].back();&#x2F;&#x2F;rear\n\t\t\tcards[t].pop_back();\n\t\t\tt &#x3D; r;\n\t\t&#125;\n\t&#125;\n\tint res &#x3D; 0;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; 12; i++) res +&#x3D; open[i] &gt;&#x3D; 4;&#x2F;&#x2F;-4*K 12堆，+&#x3D;1or0\n\tcout &lt;&lt; res &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n \n\n&#x2F;&#x2F;分形\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nchar g[N][N];\n\nvoid dfs(int n)\n&#123;\n\tif(n &#x3D;&#x3D; 1)\n\t&#123;\n\t\tg[0][0] &#x3D; &#39;X&#39;;\n\t\treturn;\n\t&#125;\n\t\n\tdfs(n - 1);&#x2F;&#x2F;构造n-1级图形\n\tint len &#x3D; 1;\n\tfor(int i &#x3D; 0; i &lt; n - 2; i++) len *&#x3D; 3;&#x2F;&#x2F;n-1级边长&#x3D;&#x3D;3^(n-2)\n\t&#x2F;&#x2F;用n-1级图画n级图\n\tint sx[4] &#x3D; &#123;0, 1, 2, 2&#125;, sy[4] &#x3D; &#123;2, 1, 0, 2&#125;;\n\tfor(int k &#x3D; 0; k &lt; 4; k++)\n\t\tfor(int i &#x3D; 0; i &lt; len; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; len; j++)\n\t\t\t\tg[sx[k] * len + i][sy[k] * len + j] &#x3D; g[i][j];\n&#125;\n\nint main()\n&#123;\n\tdfs(7);\n\t\n\tint n;\n\twhile(cin &gt;&gt; n, n !&#x3D; -1)\n\t&#123;\n\t\tint len &#x3D; 1;\n\t\twhile(--n) len *&#x3D; 3;&#x2F;&#x2F;n-1次\n\t\tfor(int i &#x3D; 0; i &lt; len; i++)\n\t\t&#123;\n\t\t\tfor(int j &#x3D; 0; j &lt; len; j++)\n\t\t\t\tif(g[i][j]) cout &lt;&lt; &#39;X&#39;;\n\t\t\t\telse cout &lt;&lt; &#39; &#39;;\n\t\t\tcout &lt;&lt; endl;\n\t\t&#125;\n\t\tcout &lt;&lt; &#39;-&#39; &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;袭击：分治 平面最近点对 预处理排序，递归内划分O(n)优化DAC\n&#x2F;&#x2F;1类点--&gt;2类点:同类点距离&#x3D;&#x3D;+INF\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 200010;\nconst double INF &#x3D; 1e10;\n\nstruct Point\n&#123;\n\tdouble x, y;\n\tbool type;\n\tbool operator &lt; (const Point &amp;W) const\n\t&#123;\n\t\treturn x &lt; W.x;\n\t&#125;\n&#125;points[N], temp[N];\n\ndouble dist(Point a, Point b)\n&#123;\n\tif(a.type &#x3D;&#x3D; b.type) return INF;\n\tdouble dx &#x3D; a.x - b.x, dy &#x3D; a.y - b.y;\n\treturn sqrt(dx * dx + dy * dy);\n&#125;\n\ndouble dfs(int l, int r)\n&#123;\n\tif(l &gt;&#x3D; r) return INF;\n\n\tint mid &#x3D; l + r &gt;&gt; 1;\n\tdouble mid_x &#x3D; points[mid].x;\n\tdouble res &#x3D; min(dfs(l, mid),dfs(mid + 1, r));&#x2F;&#x2F;归并排序-递归\n\t&#x2F;&#x2F;l和r的y有序性在递归步中merge掉，每层递归O(nlogn)-&gt;O(n) ！！！！\n\t&#123;&#x2F;&#x2F;归并排序-merge O(n)  y-sorted的l和r，代码块,临时变量\n\t\tint k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;\n\t\twhile(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n\t\t\tif(points[i].y &lt;&#x3D; points[j].y) temp[k++] &#x3D; points[i++];\n\t\t\telse temp[k++] &#x3D; points[j++];\n\t\twhile(i &lt;&#x3D; mid) temp[k++] &#x3D; points[i++];\n\t\twhile(j &lt;&#x3D; r) temp[k++] &#x3D; points[j++];\n\t\tfor(i &#x3D; 0, j &#x3D; l; i &lt; k; i++, j++) points[j] &#x3D; temp[i];\n\t&#125;\n\n\tint k &#x3D; 0;\n\tfor(int i &#x3D; l; i &lt;&#x3D; r; i++)\n\t\tif(points[i].x &gt;&#x3D; mid_x - res &amp;&amp; points[i].x &lt;&#x3D; mid_x + res)\n\t\t\ttemp[k++] &#x3D; points[i];\n\t&#x2F;&#x2F;条带内任意两点间找min距离, i&gt;j\n\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\tfor(int j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; temp[i].y - temp[j].y &lt;&#x3D; res; j--)\n\t\t\tres &#x3D; min(res, dist(temp[i], temp[j]));\n\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tint T, n;\n\tcin &gt;&gt; T;\n\twhile(T--)\n\t&#123;\n\t\tcin &gt;&gt; n;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; points[i].x &gt;&gt; points[i].y;\n\t\t\tpoints[i].type &#x3D; 0;\n\t\t&#125;\n\t\tfor (int i &#x3D; n; i &lt; n * 2; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; points[i].x &gt;&gt; points[i].y;\n\t\t\tpoints[i].type &#x3D; 1;\n\t\t&#125;\n\n\t\tsort(points, points + n * 2);\n\t\tprintf(&quot;%.3lf\\n&quot;, dfs(0, n * 2 - 1));\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;防线\n&#x2F;&#x2F;秦腾与教学评估 二分\n&#x2F;&#x2F;利用奇数最多就一个的限制。如果坐标0到当前枚举到的坐标ans间有奇数个人，\n&#x2F;&#x2F;那么那个奇数点一定在这中间。然后再迭代验证。注意要用int64来二分。\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 200010;\n\nstruct Seq\n&#123;\n\tint s, e, d;\n&#125;seqs[N];\n\nint n;&#x2F;&#x2F;n组防线\n\nLL get_sum(int x)&#x2F;&#x2F;防卫数的前缀和\n&#123;\n\tLL res &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; n; i++)&#x2F;&#x2F;第i组防线\n\t\tif(seqs[i].s &lt;&#x3D; x)\n\t\t\tres +&#x3D; (min(seqs[i].e, x) - seqs[i].s) &#x2F; seqs[i].d + 1;&#x2F;&#x2F;区间数+1&#x3D;端点数\n\treturn res;\n&#125;\n\n&#x2F;&#x2F; 用时cin &gt; ios::sync_with_stdio(false); + cin.tie(0),cout.tie(0) &gt; scanf\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\n\twhile (T -- )\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;n);\n\t\tint l &#x3D; 0, r &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\t&#123;\n\t\t\tint s, e, d;\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;s, &amp;e, &amp;d);\n\t\t\tseqs[i] &#x3D; &#123;s, e, d&#125;;\n\t\t\tr &#x3D; max(r, e);\n\t\t&#125;\n\t\t&#x2F;&#x2F;二分\n\t\twhile (l &lt; r)\n\t\t&#123;\n\t\t\tint mid &#x3D; (LL)l + r &gt;&gt; 1;\n\t\t\tif (get_sum(mid) &amp; 1) r &#x3D; mid;\n\t\t\telse l &#x3D; mid + 1;\n\t\t&#125;\n\n\t\tauto sum &#x3D; get_sum(r) - get_sum(r - 1);\n\n\t\tif (sum % 2 &#x3D;&#x3D; 0) puts(&quot;There&#39;s no weakness.&quot;);\n\t\telse printf(&quot;%d %lld\\n&quot;, r, sum);&#x2F;&#x2F;Linux:lld win:I64d\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;赶牛入圈\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 1010;\n\nint n, C;&#x2F;&#x2F;max点数&gt;&#x3D;C\nPII points[N];\nvector&lt;int&gt; numbers;&#x2F;&#x2F;离散化后的数\nint sum[N][N];&#x2F;&#x2F;前缀和\n\nint get(int x)&#x2F;&#x2F;2分找值为x的numbers[下标!!!]\n&#123;\n\tint l &#x3D; 0, r &#x3D; numbers.size() - 1;\n\twhile(l &lt; r)\n\t&#123;\n\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\tif(numbers[mid] &gt;&#x3D; x) r &#x3D; mid;&#x2F;&#x2F;&gt;&#x3D;x:左半,&lt;x:右半\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\treturn r;\n&#125;\n\nbool check(int len)&#x2F;&#x2F;边长为len的窗口在所有点坐标域滑动,num[下标]&#x3D;(映射为)&#x3D;原x,y值, 判断窗口内点数部分和&gt;&#x3D;C否\n&#123;\n\tfor(int x1 &#x3D; 0, x2 &#x3D; 1; x2 &lt; numbers.size(); x2++)\n\t&#123;\n\t\twhile(numbers[x2] - numbers[x1 + 1] + 1 &gt; len) x1++;&#x2F;&#x2F;x1是&lt;len区间左端点的第一个(max)点\n\t\tfor(int y1 &#x3D; 0, y2 &#x3D; 1; y2 &lt; numbers.size(); y2++)\n\t\t&#123;\n\t\t\twhile(numbers[y2] - numbers[y1 + 1] + 1 &gt; len) y1++;\n\t\t\tif(sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1] &gt;&#x3D; C)\n\t\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; C &gt;&gt; n;\n\tnumbers.push_back(0);\n\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tint x, y;\n\t\tcin &gt;&gt; x &gt;&gt; y;\n\t\tpoints[i] &#x3D; &#123;x, y&#125;;\n\t\tnumbers.push_back(x);\n\t\tnumbers.push_back(y);\n\t&#125;\n\t\n\tsort(numbers.begin(), numbers.end());\n\t&#x2F;&#x2F;去重：unique将重复元素至尾，返回last非重元素pos，erase去掉末尾重复元素\n\tnumbers.erase(unique(numbers.begin(), numbers.end()), numbers.end());\n\t\n\t&#x2F;&#x2F;离散化x,y 得到i,j点的sum[i][j]\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tint x &#x3D; get(points[i].first), y &#x3D; get(points[i].second);\n\t\tsum[x][y]++;\n\t&#125;\n\t&#x2F;&#x2F;前缀和\n\tfor (int i &#x3D; 1; i &lt; numbers.size(); i++)\n\t\tfor (int j &#x3D; 1; j &lt; numbers.size(); j++)\n\t\t\tsum[i][j] +&#x3D; sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n\t&#x2F;&#x2F;2分找min_len\n\tint l &#x3D; 1, r &#x3D; 10000;\n\twhile(l &lt; r)\n\t&#123;\n\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\tif(check(mid)) r &#x3D; mid;&#x2F;&#x2F;满足&gt;&#x3D;C,继续缩小\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\tcout &lt;&lt; r &lt;&lt; endl;&#x2F;&#x2F;点数&gt;&#x3D;C的min_len\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;糖果传递\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 1000010;\n\nint n;\nLL a[N];\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tLL sum &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tscanf(&quot;%lld&quot;, &amp;a[i]);\n\t\tsum +&#x3D; a[i];\n\t&#125;\n\tsum &#x2F;&#x3D; n;\n\tfor (int i &#x3D; n; i &gt; 1; i--)&#x2F;&#x2F;x[i] &#x3D; x1-a[i]\n\t&#123;\n\t\ta[i] &#x3D; sum - a[i] + a[i+1];&#x2F;&#x2F;a[i]&#x3D;a[i+1]+(avg-a[i]) &lt;---a[n+1]&#x3D;0\n\t&#125;\n\ta[1] &#x3D; 0;&#x2F;&#x2F;x1 &#x3D; x1-(a[i]&#x3D;0)\n\n\tsort(a + 1, a + n + 1);\n\tLL res &#x3D; 0;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) res +&#x3D; abs(a[i] - a[(n + 1) &#x2F; 2]);\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;士兵\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 10010;\n\nint n;\nint x[N], y[N];\n\nint work(int *q)\n&#123;\n\tint res &#x3D; 0;\n\tsort(q, q+n);\n\tfor(int i &#x3D; 0; i &lt; n; i++) res +&#x3D; abs(q[i] - q[i&#x2F;2]);&#x2F;&#x2F;0+1+1+2+2 \n\t&#x2F;&#x2F;或&#x3D;&#x3D; 2+1+0+1+2: res +&#x3D; abs(q[i] - q[n&#x2F;2]);\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; x[i] &gt;&gt; y[i];\n\tsort(x, x + n);\n\tfor(int i &#x3D; 0; i &lt; n; i++) x[i] -&#x3D; i;\n\t\n\tcout &lt;&lt; work(y) + work(x) &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数的进制转换\n&#x2F;&#x2F;进制a---&gt;10---%b---&gt;b   &#x2F;b%b ,  a--直接-&gt;b\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile(T--)\n\t&#123;\n\t\tint a, b;\n\t\tstring a_line, b_line;\n\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; a_line;\n\t\t\n\t\tvector&lt;int&gt; number;\n\t\tfor(auto c : a_line)\n\t\t&#123;\n\t\t\tif(c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) number.push_back(c - &#39;0&#39;);\n\t\t\tif(c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39;) number.push_back(c - &#39;A&#39; + 10);\n\t\t\tif(c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) number.push_back(c - &#39;a&#39; + 36);\n\t\t&#125;\n\t\treverse(number.begin(), number.end());&#x2F;&#x2F;低到高\n\t\t\n\t\tvector&lt;int&gt; res;\n\t\twhile(number.size())&#x2F;&#x2F;直到商&#x3D;&#x3D;0\n\t\t&#123;\n\t\t\tint r &#x3D; 0;\n\t\t\tfor(int i &#x3D; number.size() - 1; i &gt;&#x3D; 0; i--)\n\t\t\t&#123;\n\t\t\t\tnumber[i] +&#x3D; r * a;&#x2F;&#x2F; cur位 +&#x3D; 高位余数 * a进制\n\t\t\t\tr &#x3D; number[i] % b;&#x2F;&#x2F;余数\n\t\t\t\tnumber[i] &#x2F;&#x3D; b;&#x2F;&#x2F;商\n\t\t\t&#125;\n\t\t\tres.push_back(r);\n\t\t\t&#x2F;&#x2F;去掉末尾的高位前导零\n\t\t\twhile(number.size() &amp;&amp; number.back() &#x3D;&#x3D; 0) number.pop_back();\n\t\t&#125;\n\t\treverse(res.begin(), res.end());\n\t\t\n\t\tfor(auto x : res)\n\t\t&#123;\n\t\t\tif(x &lt;&#x3D; 9) b_line +&#x3D; char(x + &#39;0&#39;);\n\t\t\tif(x &gt;&#x3D; 10 &amp;&amp; x &lt;&#x3D; 35) b_line +&#x3D; char(x - 10 + &#39;A&#39;);\n\t\t\tif(x &gt;&#x3D; 36) b_line +&#x3D; char(x - 36 + &#39;a&#39;);\n\t\t&#125;\n\t\tcout &lt;&lt; a &lt;&lt; &#39; &#39; &lt;&lt; a_line &lt;&lt; endl;\n\t\tcout &lt;&lt; b &lt;&lt; &#39; &#39; &lt;&lt; b_line &lt;&lt; endl;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;耍杂技的牛  国王游戏 贪心   pair可比大小，vector字典序比较 \n#include &lt;limits.h&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 50010;\n\nint n;\nPII cows[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tint  w, s;\n\t\tcin &gt;&gt; w &gt;&gt; s;\n\t\tcows[i] &#x3D; &#123;w + s, w&#125;;&#x2F;&#x2F;！！！！！！\n\t&#125;\n\tsort(cows, cows + n);\n\n\tint sum &#x3D; 0, res &#x3D; INT_MIN;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tint w &#x3D; cows[i].second, s &#x3D; cows[i].first - w;\n\t\tres &#x3D; max(res, sum - s);\n\t\tsum +&#x3D; w;\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;最大子矩阵的和\n#include &lt;limits.h&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110;\n\nint n;\nint g[N][N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; g[i][j];\n\t\t\tg[i][j] +&#x3D; g[i-1][j];\n\t\t&#125;&#x2F;&#x2F;g:一列值的前缀和\n\n\tint res &#x3D; INT_MIN;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; i; j &lt;&#x3D; n; j++)&#x2F;&#x2F;j &gt;&#x3D; i\n\t\t&#123;\n\t\t\tint last &#x3D; 0;\n\t\t\tfor (int k &#x3D; 1; k &lt;&#x3D; n; k++)\n\t\t\t&#123;\n\t\t\t\tlast &#x3D; max(last, 0) + g[j][k] - g[i-1][k];\n\t\t\t\t&#x2F;&#x2F;第k列第i行到第j行的竖条 求max子和\n\t\t\t\tres &#x3D; max(res, last);\n\t\t\t&#125;\n\t\t&#125;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;任务 排序贪心\n&#x2F;&#x2F;首先考虑了所有的任务，然后尽可能的在可行的机器中选择来适配它，并且又尽量选择能力较差的机器，使得剩余的机器能够匹配的任务数量的期望更大，从而保证了任务数量尽量多。\n&#x2F;&#x2F;最大价值和（点权max match）：500x+2y 先time后prio降序遍历\n&#x2F;&#x2F; 如果x范围开大点，就只能离散化或者用set了\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nPII mchs[N], tasks[N];\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; mchs[i].first &gt;&gt; mchs[i].second;\n\t\tfor (int i &#x3D; 0; i &lt; m; i ++ ) cin &gt;&gt; tasks[i].first &gt;&gt; tasks[i].second;\n\t\tsort(mchs, mchs + n);\n\t\tsort(tasks, tasks + m);\n\t\tmultiset&lt;int&gt; ys;&#x2F;&#x2F;不去重\n\t\tLL cnt &#x3D; 0, res &#x3D; 0;\n\t\tfor (int i &#x3D; m - 1, j &#x3D; n - 1; i &gt;&#x3D; 0; i -- )&#x2F;&#x2F;i:task j:machine\n\t\t&#123;\n\t\t\tint x &#x3D; tasks[i].first, y &#x3D; tasks[i].second;\n\t\t\twhile (j &gt;&#x3D; 0 &amp;&amp; mchs[j].first &gt;&#x3D; x) ys.insert(mchs[j -- ].second);\n\t\t\tauto it &#x3D; ys.lower_bound(y);\n\t\t\tif (it !&#x3D; ys.end())\n\t\t\t&#123;\n\t\t\t\tcnt ++ ;\n\t\t\t\tres +&#x3D; 500 * x + 2 * y;\n\t\t\t\tys.erase(it);\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; cnt &lt;&lt; &#39; &#39; &lt;&lt; res &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\nyxc\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;27694&#x2F;\n秦淮岸\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;868&#x2F;\n&#x2F;*\n#define fir(i,a,b) for (ll i&#x3D;a;i&lt;&#x3D;b;i++)\nSTL慢：new动态开内存\n优化：-o2\nvector&lt;int&gt; a(100000);\na.resize(1000);\n*&#x2F;\n\n-----------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0x10基本数据结构&#x2F;&#x2F;0x11 栈\n&#x2F;&#x2F;编辑器  对顶栈\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;limits.h&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint stkl[N], stkr[N], tl, tr;\nint s[N], f[N];\n\nvoid push_left(int x)\n&#123;\n\tstkl[++tl] &#x3D; x;\n\ts[tl] &#x3D; s[tl - 1] + x;\n\tf[tl] &#x3D; max(f[tl-1], s[tl]);\n&#125;\n\nint main()\n&#123;\n\tint n;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tf[0] &#x3D; INT_MIN;\n\twhile(n--)\n\t&#123;\n\t\tchar str[2];\n\t\tint x;\n\t\tscanf(&quot;%s&quot;, str);\n\t\tif(*str &#x3D;&#x3D; &#39;I&#39;)\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\tpush_left(x);\n\t\t&#125;\n\t\telse if(*str &#x3D;&#x3D; &#39;D&#39;)\n\t\t&#123;\n\t\t\tif(tl &gt; 0) tl--;&#x2F;&#x2F;tl，tr: &gt;0才能-- ！！！！！！！！\n\t\t&#125;\n\t\telse if(*str &#x3D;&#x3D; &#39;L&#39;)\n\t\t&#123;\n\t\t\tif(tl &gt; 0) stkr[++tr] &#x3D; stkl[tl--];\n\t\t&#125;\n\t\telse if(*str &#x3D;&#x3D; &#39;R&#39;)\n\t\t&#123;\n\t\t\tif(tr &gt; 0) push_left(stkr[tr--]);   \n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\tprintf(&quot;%d\\n&quot;, f[x]);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;火车进栈 递归枚举\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint n, cnt &#x3D; 20;&#x2F;&#x2F;字典序前20的ans\nvector&lt;int&gt; state1;\nstack&lt;int&gt; state2;\nint state3 &#x3D; 1;&#x2F;&#x2F;（小到大 1-&gt;n）未入3-&gt;栈2-&gt;出1\nvoid dfs()\n&#123;\n\tif(!cnt) return;\n\tif(state1.size() &#x3D;&#x3D; n)&#x2F;&#x2F;输出\n\t&#123;\n\t\tcnt--;\n\t\tfor(auto x : state1) cout &lt;&lt; x;\n\t\tcout &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\tif(state2.size())&#x2F;&#x2F;每一步：先出栈\n\t&#123;\n\t\tstate1.push_back(state2.top());&#x2F;&#x2F;op\n\t\tstate2.pop();\n\t\tdfs();&#x2F;&#x2F;递归\n\t\tstate2.push(state1.back());&#x2F;&#x2F;还原\n\t\tstate1.pop_back();\n\t&#125;\n\n\tif(state3 &lt;&#x3D; n)&#x2F;&#x2F;后入栈\n\t&#123;\n\t\tstate2.push(state3);\n\t\tstate3++;\n\t\tdfs();\n\t\tstate3--;\n\t\tstate2.pop();\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tdfs();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;第一版 高精度求Catalan(n) 1s内：上限37000+\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 6000010;\nLL res[N], tt;\n\nvoid multi(int b)\n&#123;\n\tLL t &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt;&#x3D; tt; i++)\n\t&#123;\n\t\tres[i] &#x3D; res[i] * b + t;\n\t\tt &#x3D; res[i] &#x2F; 1000000000;\n\t\tres[i] %&#x3D; 1000000000;\n\t&#125;\n\twhile(t)\n\t&#123;\n\t\tres[++tt] &#x3D; t % 1000000000;\n\t\tt &#x2F;&#x3D; 1000000000;\n\t&#125;\n&#125;\n\nvoid div(int b)\n&#123;\n\tLL t &#x3D; 0;\n\tfor(int i &#x3D; tt; i &gt;&#x3D; 0; i--)\n\t&#123;\n\t\tres[i] +&#x3D; t * 1000000000;\n\t\tt &#x3D; res[i] % b;\n\t\tres[i] &#x2F;&#x3D; b;\n\t&#125;\n\twhile(!res[tt]) tt--;\n&#125;\n\nint main()\n&#123;\n\tint n;\n\tcin &gt;&gt; n;\n\ttt &#x3D; 0;\n\tres[0] &#x3D; 1;\n\tfor(int i &#x3D; n * 2, j &#x3D; n; j &gt; 0; i--, j--)\n\t&#123;\n\t\tmulti(i);\n\t\tdiv(j);\n\t&#125;&#x2F;&#x2F;1*(2n*...*n&#x2F;1*...*n)\n\tdiv(n+1);\n\t\n\tprintf(&quot;%lld&quot;, res[tt]);\n\tfor(int i &#x3D; tt - 1; i &gt;&#x3D; 0; i--) printf(&quot;%09lld&quot;, res[i]);\n\tcout &lt;&lt; endl;\n\treturn 0;\n&#125;\n&#x2F;* \nint类型占32bit 可表示范围： [-2147483648，2147483647] \nlong long类型 64bit可表示范围：[-9223372036854775808，9223372036854775807]\n\nint可以完整表达9位数字，long long可以完整表达18位。\n所谓高精度就是用数组来充当数字的容器。开辟若干个空间，每个单元内存放固定数目的数据。\n\n高精度常用的方法主要有：不压缩法、压缩4位法、和压缩9位的方法。\n为什么是四位呢？因为int类型能完整表达9位以内的任何数字。而存储四位数字是因为在进行《乘法运算时，很可能会存在四位×四位的情况，而其结果不会超过八位。》int类型完全可以存储。如果存放四位以上的数字的时候，int不能完整的存放其结果，因而无法正确计算。\n三种方式归根结底都是进制的转换问题：普通不压缩法相当于十进制，四位压缩法相当于一万进制，九位压缩法相当于十亿进制。\n\n三种方法的时间效率不同：假设两个数进行四则运算。运用普通法存储拥有最多的单位，其次是四位压缩法，最少是九位压缩法。进行加法运算时，两个数组中，以其中一个数组为起点，使其各个单元与另一个数组的各个单元进行相加运算。其时间复杂度为O（n^2）级。因此压缩9位存储法开辟的单元少，所以消耗的时间最少。\n*&#x2F;\n&#x2F;&#x2F;第二版 素因数分解求 Catalan(n) n&#x3D;60000  1s\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 120010;\n\nint powers[N];&#x2F;&#x2F;pi的次数\nint primes[N], cnt;\nbool st[N];\n\nvoid get_primes(int n)&#x2F;&#x2F;埃氏筛法\n&#123;\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t\tif(!st[i])&#x2F;&#x2F;st[i]是质数 \n\t\t&#123;\n\t\t\tprimes[cnt++] &#x3D; i;\n\t\t\tfor(int j &#x3D; i * 2; j &lt;&#x3D; n; j +&#x3D; i)\n\t\t\t\tst[j] &#x3D; true;\n\t\t&#125;\n&#125;\n\nint get(int n, int p)&#x2F;&#x2F;n!中质因子p的个数\n&#123;\n\tint s &#x3D; 0;\n\twhile(n) s +&#x3D; n &#x2F; p, n &#x2F;&#x3D; p;\n\treturn s;\n&#125;\n\n\nvoid multi(vector&lt;LL&gt; &amp;a, int b)&#x2F;&#x2F;大*小\n&#123;\n\tint t &#x3D; 0;\n\tfor(int i &#x3D; 0; i &lt; a.size(); i++)\n\t&#123;\n\t\ta[i] &#x3D; a[i] * b + t;\n\t\tt &#x3D; a[i] &#x2F; 1000000000;\n\t\ta[i] %&#x3D; 1000000000;\n\t&#125;\n\twhile(t)\n\t&#123;\n\t\ta.push_back(t % 1000000000);\n\t\tt &#x2F;&#x3D; 1000000000;\n\t&#125;\n&#125;\n\nvoid out(vector&lt;LL&gt; &amp;a)\n&#123;&#x2F;&#x2F;高到低倒取\n\tprintf(&quot;%lld&quot;, a.back());&#x2F;&#x2F;first不用补0\n\tfor(int i &#x3D; a.size() - 2; i &gt;&#x3D; 0; i--) printf(&quot;%09lld&quot;, a[i]);&#x2F;&#x2F;补0\n\tcout &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n\tint n;\n\tcin &gt;&gt; n;\n\tget_primes(n * 2);\n\t\n\tfor(int i &#x3D; 0; i &lt; cnt; i++)\n\t&#123;\n\t\tint p &#x3D; primes[i];\n\t\tpowers[p] &#x3D; get(n * 2, p) - get(n, p) * 2;\n\t&#125;\n\t&#x2F;&#x2F; (2n!)&#x2F;(n!n!)&#x2F;(n+1)\n\tint k &#x3D; n + 1;\n\tfor(int i &#x3D; 0; i &lt; cnt &amp;&amp; primes[i] &lt;&#x3D; k; i++)&#x2F;&#x2F;n很小，2n内p只有cnt个\n\t&#x2F;&#x2F;i &lt; cnt，否则 float point exception除0错误\n\t&#123;\n\t\tint p &#x3D; primes[i], s &#x3D; 0;\n\t\twhile(k % p &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\ts++;\n\t\t\tk &#x2F;&#x3D; p;\n\t\t&#125;\n\t\tpowers[p] -&#x3D; s;\n\t&#125;\n\tvector&lt;LL&gt; res;\n\tres.push_back(1);\n\t\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n * 2; i++)\n\t\tfor(int j &#x3D; 0; j &lt; powers[i]; j ++)\n\t\t\tmulti(res, i);&#x2F;&#x2F;低到高存\n\t\n\tout(res);\n\treturn 0;\n&#125;\n--------------------------------------------------------------------\n&#x2F;&#x2F;直方图中最大的矩形  单调栈(递增) O(N)\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 100010;\n\nint n;\nint h[N], q[N], l[N], r[N];\n\nvoid get(int bound[N])&#x2F;&#x2F;单调栈模板 栈顶q[tt] 记录第一个比它矮的下标\n&#123;\n\tint tt &#x3D; 0;\n\th[0] &#x3D; -1;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\twhile(h[q[tt]] &gt;&#x3D; h[i]) tt--;\n\t\tbound[i] &#x3D; q[tt];\n\t\tq[++tt] &#x3D; i;\n\t&#125;\n\t\n&#125;\n\nint main()\n&#123;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; h[i];\n\t\tget(l);\n\t\treverse(h + 1, h + 1 + n);\n\t\tget(r);\n\n\t\t&#x2F;&#x2F;修正\n\t\treverse(h + 1, h + 1 + n);&#x2F;&#x2F;3315412\n\t\treverse(r + 1, r + 1 + n);&#x2F;&#x2F;0003306 \n\t\t&#x2F;&#x2F;r顺序对了，值不对!!!!把终点n+1当起点0了\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tr[i] &#x3D; n + 1 - r[i];\n\t\t\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tres &#x3D; max(res, h[i] * (r[i] - l[i] - 1ll));\n&#x2F;*      &#x2F;&#x2F;yxc\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; 1, j &#x3D; n; i &lt;&#x3D; n; i++, j--)\n\t\t\tres &#x3D; max(res, h[i] * (n + 1 - l[j] - r[i] - 1ll));\n*&#x2F;\n&#x2F;* \n\t\treverse(h + 1, h+ 1 + n);\n\t\treverse(r + 1, r + 1 + n);\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tres &#x3D; max(res, h[i] * (n + 1 - r[i] - l[i] - 1ll));\n*&#x2F;\n\t\tcout &lt;&lt; res &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n&#x2F;*\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\n&#x2F;&#x2F;l[i], r[i]表示第i个矩形的高度可向两侧扩展的左右边界\nint h[N], q[N], l[N], r[N];\n\ntypedef long long LL;\n\nint main()\n&#123;\n\tint n;\n\twhile(scanf(&quot;%d&quot;, &amp;n), n)\n\t&#123;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i ++)  scanf(&quot;%d&quot;, &amp;h[i]);\n\t\th[0] &#x3D; h[n + 1] &#x3D; -1;\n\n\t\tint tt &#x3D; -1;\n\t\tq[++ tt] &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i ++)\n\t\t&#123;\n\t\t\twhile(h[q[tt]] &gt;&#x3D; h[i])  tt --;\n\t\t\tl[i] &#x3D; i - q[tt];\n\t\t\tq[++ tt] &#x3D; i;\n\t\t&#125;\n\n\t\ttt &#x3D; -1;\n\t\tq[++ tt] &#x3D; n + 1;\n\t\tfor(int i &#x3D; n; i; i --)\n\t\t&#123;\n\t\t\twhile(h[q[tt]] &gt;&#x3D; h[i])  tt --;\n\t\t\tr[i] &#x3D; q[tt] - i;\n\t\t\tq[++ tt] &#x3D; i;\n\t\t&#125;\n\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i ++)  res &#x3D; max(res, (LL)h[i] * (l[i] + r[i] - 1));\n\t\tprintf(&quot;%lld\\n&quot;, res);\n\t&#125;\n\treturn 0;\n&#125;\n*&#x2F;\n\n&#x2F;&#x2F;官方标程\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt; \n#include&lt;algorithm&gt;\nusing namespace std;\nint n,p;\nint a[100010];\nint s[100010],w[100010];\nlong long ans;\n\nint main()\n&#123;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tans &#x3D; 0; p &#x3D; 0;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\t\ta[n+1] &#x3D; 0;&#x2F;&#x2F;\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n+1; i++)\n\t\t&#123;\n\t\t\tif(a[i] &gt; s[p]) s[++p] &#x3D; a[i], w[p] &#x3D; 1;\n\t\t\telse&#123;\n\t\t\t\tint width &#x3D; 0;\n\t\t\t\twhile(s[p] &gt; a[i])\n\t\t\t\t&#123;\n\t\t\t\t\twidth +&#x3D; w[p];&#x2F;&#x2F;\n\t\t\t\t\tans &#x3D; max(ans, (long long)width * s[p]);\n\t\t\t\t\tp--;\n\t\t\t\t&#125;\n\t\t\t\ts[++p] &#x3D; a[i], w[p] &#x3D; width + 1;&#x2F;&#x2F; w[p]:top以左降序块宽度\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n&#125;\n--------------------------------------------------------------------\n&#x2F;&#x2F;0x12 队列\n&#x2F;&#x2F;小组队列\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010, M &#x3D; 1000010;\n&#x2F;&#x2F; 需注意：测试用例最多可包含200000（20万）个命令，1000组\n&#x2F;&#x2F; 因此小组队列的实现应该是高效的:入队和出队都需要使用常数时间。\nint teamid[M];&#x2F;&#x2F;teamid[人num] &#x3D; 组id!!!!!!\n\nint main()\n&#123;\n\tint n, C &#x3D; 1;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tprintf(&quot;Scenario #%d\\n&quot;, C++);\n\t\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tint cnt;\n\t\t\tcin &gt;&gt; cnt;\n\t\t\twhile(cnt--)\n\t\t\t&#123;\n\t\t\t\tint x;\n\t\t\t\tcin &gt;&gt; x;\n\t\t\t\tteamid[x] &#x3D; i;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tqueue&lt;int&gt; team;&#x2F;&#x2F;组间 循环队列\n\t\tqueue&lt;int&gt; person[N];&#x2F;&#x2F;&lt;N个组内queue\n\n\t\tstring command;\n\t\twhile(cin &gt;&gt; command, command !&#x3D; &quot;STOP&quot;)\n\t\t&#123;\n\t\t\tif(command &#x3D;&#x3D; &quot;ENQUEUE&quot;)\n\t\t\t&#123;\n\t\t\t\tint x;\n\t\t\t\tcin &gt;&gt; x;\n\t\t\t\tint tid &#x3D; teamid[x];\n\t\t\t\tif(person[tid].empty()) team.push(tid);\n\t\t\t\tperson[tid].push(x);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tint tid &#x3D; team.front();\n\t\t\t\tauto &amp;q &#x3D; person[tid];\n\t\t\t\tcout &lt;&lt; q.front() &lt;&lt; endl;\n\t\t\t\tq.pop();\n\t\t\t\tif(q.empty()) team.pop();\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;蚯蚓\n&#x2F;&#x2F;puts(str);向标准输出设备（屏幕）输出字符串并换行，具体为：把字符串输出到标准输出设备，将&#39;\\0&#39;转换为回车换行。\n&#x2F;&#x2F;puts(&quot;&quot;); &#x3D;&#x3D; cout &lt;&lt; endl;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits.h&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010, M &#x3D; 7000010;\n\nint n, m, q, u, v, t;\nint q1[N], q2[M], q3[M];\nint hh1, hh2, hh3, tt1, tt2 &#x3D; -1, tt3 &#x3D; -1;\nint delta;\n\nint get_max()\n&#123;\n\tint x &#x3D; INT_MIN;\n\tif (hh1 &lt;&#x3D; tt1) x &#x3D; max(x, q1[hh1]);&#x2F;&#x2F;get_max\n\tif (hh2 &lt;&#x3D; tt2) x &#x3D; max(x, q2[hh2]);\n\tif (hh3 &lt;&#x3D; tt3) x &#x3D; max(x, q3[hh3]);\n\tif (hh1 &lt;&#x3D; tt1 &amp;&amp; x &#x3D;&#x3D; q1[hh1]) hh1 ++ ;&#x2F;&#x2F;delete_max\n\telse if (hh2 &lt;&#x3D; tt2 &amp;&amp; x &#x3D;&#x3D; q2[hh2]) hh2 ++ ;\n\telse hh3 ++ ;\n\treturn x;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t);\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q1[i]);\n\tsort(q1, q1 + n);\n\treverse(q1, q1 + n);\n\ttt1 &#x3D; n - 1;\n\t\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\tint x &#x3D; get_max();\n\t\tx +&#x3D; delta;&#x2F;&#x2F;1!!!\n\t\tif (i % t &#x3D;&#x3D; 0) printf(&quot;%d &quot;, x);\n\t\tint left &#x3D; x * 1ll * u &#x2F; v;\n\t\tint right &#x3D; x - left;\n\t\tdelta +&#x3D; q;&#x2F;&#x2F;2!!!\n\t\tq2[ ++ tt2] &#x3D; left - delta, q3[ ++ tt3] &#x3D; right - delta;&#x2F;&#x2F;3!!!\n\t&#125;\n\tputs(&quot;&quot;);\n\t\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n + m; i ++ )&#x2F;&#x2F;!!!\n\t&#123;\n\t\tint x &#x3D; get_max();\n\t\tif (i % t&#x3D;&#x3D; 0) printf(&quot;%d &quot;, x + delta);\n\t&#125;\n\tputs(&quot;&quot;);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;双端队列\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits.h&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 200010;\n\nint n;\nPII a[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; a[i].first;\n\t\ta[i].second &#x3D; i;\n\t&#125;\n\tsort(a, a + n);\n\t\n\tint res &#x3D; 1, last &#x3D; INT_MAX, dir &#x3D; -1;\n\tfor(int i &#x3D; 0; i &lt; n;)\n\t&#123;\n\t\tint j &#x3D; i;\n\t\twhile(j &lt; n &amp;&amp; a[j].first &#x3D;&#x3D; a[i].first) j++;&#x2F;&#x2F; val&#x3D; 的一段[i,j-1]\n\t\t\n\t\tint minp &#x3D; a[i].second, maxp &#x3D; a[j-1].second;\n\t\tif(dir &#x3D;&#x3D; -1)\n\t\t&#123;\n\t\t\tif(last &gt; maxp) last &#x3D; minp;&#x2F;&#x2F;下续\n\t\t\telse dir &#x3D; 1, last &#x3D; maxp;&#x2F;&#x2F;上拐\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tif(last &lt; minp) last &#x3D; maxp;&#x2F;&#x2F;上续\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tres ++ ;\n\t\t\t\tdir &#x3D; -1;\n\t\t\t\tlast &#x3D; minp;&#x2F;&#x2F;下拐\n\t\t\t&#125;\n\t\t&#125;\n\t\ti &#x3D; j;\n\t&#125;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;最大子序和  单调队列(递减)\n#include &lt;iostream&gt;\n#include &lt;limits.h&gt;\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N &#x3D; 300010;\n\nint n, m;\nint q[N];\nLL s[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; s[i];\n\t\ts[i] +&#x3D; s[i-1];\n\t&#125;\n\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\tLL res &#x3D; INT_MIN;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tif(i - q[hh] &gt; m) hh++;\n\t\tres &#x3D; max(res, s[i] - s[q[hh]]);\n\t\twhile(hh &lt;&#x3D; tt &amp;&amp; s[q[tt]] &gt;&#x3D; s[i]) tt--;\n\t\tq[++tt] &#x3D; i;\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x13 链表 邻接表\n&#x2F;&#x2F;邻值查找\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 100010;\n\nint n;\nint p[N], l[N], r[N];&#x2F;&#x2F;l r&#x3D;&#x3D;prev next指针\nPII a[N], ans[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; a[i].first;\n\t\ta[i].second &#x3D; i;\n\t&#125;\n\tsort(a + 1, a + 1 + n);\n\n\ta[0].first &#x3D; 1e9, a[n+1].first &#x3D; -1e9;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tl[i] &#x3D; i - 1, r[i] &#x3D; i + 1;\n\t\tp[a[i].second] &#x3D; i;&#x2F;&#x2F;p[原pos]&#x3D;新pos\n\t&#125;\n\n\tfor (int i &#x3D; n; i &gt; 1; i--)\n\t&#123;\n\t\tint j &#x3D; p[i], left &#x3D; l[j], right &#x3D; r[j];\n\t\tint lv &#x3D; abs(a[j].first - a[left].first);\n\t\tint rv &#x3D; abs(a[j].first - a[right].first);\n\t\tif(lv &lt;&#x3D; rv) ans[i] &#x3D; &#123;lv, a[left].second&#125;;\n\t\telse ans[i] &#x3D; &#123;rv, a[right].second&#125;;&#x2F;&#x2F;min_abs&#x3D;&#x3D;时,A[j]&#x3D;val:min\n\t\t&#x2F;&#x2F;而不是j&#x3D;下标:min\n\t\t&#x2F;&#x2F; else if(lv &gt; rv) ans[i] &#x3D; &#123;rv, a[right].second&#125;;\n\t\t&#x2F;&#x2F; else ans[i] &#x3D; &#123;lv, min(a[left].second,a[right].second)&#125;;\n\n\t\tr[left] &#x3D; right, l[right] &#x3D; left;\n\t&#125;\n\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t\tcout &lt;&lt; ans[i].first &lt;&lt; &#39; &#39; &lt;&lt; ans[i].second &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;解法二: set版        ！！！！！！！！！！！！！！！！！！！！！！！！！\n#include &lt;set&gt;\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int INF &#x3D; 0x7f7f7f7f;\nset&lt;pair&lt;int, int&gt; &gt; s;\n\nint main() &#123;\n\tint n, a;\n\tcin &gt;&gt; n &gt;&gt; a;\n\ts.insert(&#123;a, 1&#125;);\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;a);\n\t\ts.insert(&#123;a, i&#125;);\n\t\tset&lt;pair&lt;int, int&gt; &gt;::iterator it &#x3D; s.find(&#123;a, i&#125;);\n\t\tpair&lt;int, int&gt; ans;\n\t\tans.first &#x3D; INF;\n\t\tif (++it !&#x3D; s.end())\n\t\t\tans &#x3D; &#123;(*it).first - a, (*it).second&#125;;\n\t\tit &#x3D; s.find(&#123;a, i&#125;);\n\t\tif (it-- !&#x3D; s.begin() &amp;&amp; ans.first &gt;&#x3D; a - (*it).first)\n\t\t\tans &#x3D; &#123;a - (*it).first, (*it).second&#125;;\n\t\tcout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x14 hash表\n&#x2F;&#x2F;雪花雪花雪花\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n;\nint snows[N][6], idx[6];\n\nbool cmp_array(int a[], int b[])\n&#123;\n\tfor (int i &#x3D; 0; i &lt; 6; i++)\n\t\t&#x2F;&#x2F; if(a[i] &gt; b[i]) return false;\n\t\treturn (a[i] &lt; b[i]) ? true : false;\n\t&#x2F;&#x2F; return false;\n&#125;\n\nbool cmp(int a, int b)\n&#123;\n\treturn cmp_array(snows[a], snows[b]);\n&#125;\n\nvoid get_min(int a[])\n&#123;\n\tstatic int b[12];\n\tfor (int i &#x3D; 0; i &lt; 12; i++) b[i] &#x3D; a[i % 6];\n\n\tint i &#x3D; 0, j &#x3D; 1, k;\n\twhile(i &lt; 6 &amp;&amp; j &lt; 6)\n\t&#123;\n\t\tfor (k &#x3D; 0; k &lt; 6 &amp;&amp; b[i+k] &#x3D;&#x3D; b[j+k]; k++);\n\t\t\tif(k &#x3D;&#x3D; 6) break;\n\t\tif(b[i + k] &gt; b[j + k])\n\t\t&#123;\n\t\t\ti +&#x3D; k + 1;\n\t\t\tif(i &#x3D;&#x3D; j) i++;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tj +&#x3D; k + 1;\n\t\t\tif(i &#x3D;&#x3D; j) j++;\n\t\t&#125;\n\t&#125;\n\tk &#x3D; min(i, j);\n\tfor(i &#x3D; 0; i &lt; 6; i++) a[i] &#x3D; b[i + k];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tint snow[6], isnow[6];\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0, k &#x3D; 5; j &lt; 6; j++, k--)\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;snow[j]);\n\t\t\tisnow[k] &#x3D; snow[j];\n\t\t&#125;\n\t\tget_min(snow);\n\t\tget_min(isnow);\n\t\t\n\t\tif(cmp_array(snow, isnow)) memcpy(snows[i], snow, sizeof snow);\n\t\telse memcpy(snows[i], isnow, sizeof isnow);\n\n\t\tidx[i] &#x3D; i;\n\t&#125;\n\tsort(idx, idx + n, cmp);\n\n\tbool flag &#x3D; false;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tif(!cmp(idx[i-1], idx[i]) &amp;&amp; !cmp(idx[i], idx[i-1]))\n\t\t&#123;\n\t\t\tflag &#x3D; true;\n\t\t\tbreak;\n\t\t&#125;\n\tif(flag) puts(&quot;Twin snowflakes found.&quot;);\n\telse puts(&quot;No two snowflakes are alike.&quot;);\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x15 字符串\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n;\nint snows[N][6], idx[N];\n\nbool cmp_array(int a[], int b[])\n&#123;\n\tfor (int i &#x3D; 0; i &lt; 6; i++)&#x2F;&#x2F;[i]&#x3D;&#x3D; 不作处理\n\t\tif(a[i] &gt; b[i]) return false;\n\t\telse if(a[i] &lt; b[i]) return true;\n\treturn false;&#x2F;&#x2F;全&#x3D; false\n\n&#x2F;&#x2F; 逻辑错误!!!&#x3D;&#x3D;就false：return (a[i] &lt; b[i]) ? true : false;\n&#125;\n\nbool cmp(int a, int b)\n&#123;\n\treturn cmp_array(snows[a], snows[b]);\n&#125;\n\nvoid get_min(int a[])&#x2F;&#x2F;求串的最小表示\n&#123;\n\tstatic int b[12];\n\tfor (int i &#x3D; 0; i &lt; 12; i++) b[i] &#x3D; a[i % 6];&#x2F;&#x2F;b[0-&gt;11]&#x3D;a[0-&gt;5,0-&gt;5]\n\n\tint i &#x3D; 0, j &#x3D; 1, k;\n\twhile(i &lt; 6 &amp;&amp; j &lt; 6)\n\t&#123;\n\t\tfor (k &#x3D; 0; k &lt; 6 &amp;&amp; b[i+k] &#x3D;&#x3D; b[j+k]; k++);\n\t\t\tif(k &#x3D;&#x3D; 6) break;\n\t\tif(b[i + k] &gt; b[j + k])\n\t\t&#123;\n\t\t\ti +&#x3D; k + 1;\n\t\t\tif(i &#x3D;&#x3D; j) i++;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tj +&#x3D; k + 1;\n\t\t\tif(i &#x3D;&#x3D; j) j++;\n\t\t&#125;\n\t&#125;\n\tk &#x3D; min(i, j);\n\tfor(i &#x3D; 0; i &lt; 6; i++) a[i] &#x3D; b[i + k];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tint snow[6], isnow[6];\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0, k &#x3D; 5; j &lt; 6; j++, k--)\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;snow[j]);\n\t\t\tisnow[k] &#x3D; snow[j];\n\t\t&#125;\n\t\tget_min(snow);\n\t\tget_min(isnow);\n\t\t&#x2F;&#x2F;循环同构串的最小表示snows[i] &#x3D; min(正串的最小表示，反串的最小表示);\n\t\tif(cmp_array(snow, isnow)) memcpy(snows[i], snow, sizeof snow);\n\t\telse memcpy(snows[i], isnow, sizeof isnow);\n\n\t\tidx[i] &#x3D; i;&#x2F;&#x2F;2D数组排序:用索引idx\n\t&#125;\n\tsort(idx, idx + n, cmp);\n\n\tbool flag &#x3D; false;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tif(!cmp(idx[i-1], idx[i]) &amp;&amp; !cmp(idx[i], idx[i-1]))&#x2F;&#x2F;最小表示&#x3D;&#x3D;\n\t\t&#123;\n\t\t\tflag &#x3D; true;\n\t\t\tbreak;\n\t\t&#125;\n\tif(flag) puts(&quot;Twin snowflakes found.&quot;);\n\telse puts(&quot;No two snowflakes are alike.&quot;);\n\n\treturn 0;\n&#125;\n&#x2F;&#x2F;兔子与兔子   string hash\n&#x2F;&#x2F;ULL h[N]; --&gt; printf(&quot;%llu\\n&quot;, h[i]);\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int N &#x3D; 1000010, base &#x3D; 131;\n\nchar str[N];\nULL h[N], p[N];\n\nULL get(int l, int r)&#x2F;&#x2F;子串hash\n&#123;\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%s&quot;, str + 1);\n\tint n &#x3D; strlen(str + 1);\n\n\tp[0] &#x3D; 1;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\th[i] &#x3D; h[i - 1] * base + str[i] - &#39;a&#39; + 1;&#x2F;&#x2F;前缀hash\n\t\tp[i] &#x3D; p[i-1] * base;\n\t&#125;\n\t\n\tint m;\n\tcin &gt;&gt; m;\n\twhile(m--)\n\t&#123;\n\t\tint l1, r1, l2, r2;\n\t\tscanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);\n\t\tif(get(l1, r1) &#x3D;&#x3D;  get(l2, r2)) puts(&quot;Yes&quot;);\n\t\telse puts(&quot;No&quot;);\n\t&#125;\n\t\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;139.回文子串的最大长度  O(nlogn):str_hash(Karp_Rabin)+枚举中点+二分半径(&#x3D;否)\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;906&#x2F;\nhash的O(n)解法:\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;893&#x2F;\n&#x2F;&#x2F; 还有Manacher算法 O(n)\n\n&#x2F;&#x2F;if(str[i - l] &lt;&#x3D; &#39;z&#39;) res &#x3D; max(res, l + 1);   搞不懂？？？？？？？？？\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int N &#x3D; 2000010, base &#x3D; 131;&#x2F;&#x2F;2n\n\nchar str[N];\nULL hl[N], hr[N], p[N];\n\nULL get(ULL h[], int l, int r)&#x2F;&#x2F;[hl~hr]子串hash:前缀和（idx从1开始!!!）相减\n&#123;\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main()\n&#123;\n\tint T &#x3D; 1;\n\twhile(scanf(&quot;%s&quot;, str + 1), strcmp(str + 1, &quot;END&quot;))\n\t&#123;\n\t\tint n &#x3D; strlen(str + 1);\n\t\t\n\t\tfor(int i &#x3D; n * 2; i &gt; 0; i -&#x3D; 2)&#x2F;&#x2F;奇偶统一处理!!!\n\t\t&#123;\n\t\t\tstr[i] &#x3D; str[i &#x2F; 2];\n\t\t\tstr[i - 1] &#x3D; &#39;z&#39; + 1;&#x2F;&#x2F;插入额外字符@之类的\n\t\t&#125;\n\t\t\n\t\tn *&#x3D; 2;&#x2F;&#x2F;!!!\n\t\tp[0] &#x3D; 1;\n\t\tfor(int i &#x3D; 1, j &#x3D; n; i &lt;&#x3D; n; i++, j--)\n\t\t&#123;\n\t\t\thl[i] &#x3D; hl[i - 1] * base + str[i] - &#39;a&#39; + 1;\n\t\t\thr[i] &#x3D; hr[i - 1] * base + str[j] - &#39;a&#39; + 1;&#x2F;&#x2F;区别只在str[j]!!! 倒着存:后缀hash\n\t\t\tp[i] &#x3D; p[i - 1] * base;\n\t\t&#125;\n\t\t\n\t\tint res &#x3D; 0;&#x2F;&#x2F;《枚举中点i，二分半径mid  (mid)i(mid)  》\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\tint l &#x3D; 0, r &#x3D; min(i - 1, n - i);&#x2F;&#x2F;i两边的min半径长度r-l!!!!\n\t\t\twhile(l &lt; r)\n\t\t\t&#123;\n\t\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\t\t\t&#x2F;&#x2F;半径&#x3D;mid,1--&gt;n 2--&gt;n-1: 故坐标x--&gt;n-x+1  ， 逆序\n\t\t\t\tif(get(hl, i - mid, i - 1) !&#x3D; get(hr, n - (i + mid) + 1, n - (i + 1) + 1)) r &#x3D; mid - 1;&#x2F;&#x2F;半径过大\n\t\t\t\telse l &#x3D; mid;&#x2F;&#x2F;求max半径（版本2）\n\t\t\t&#125;&#x2F;&#x2F;l&#x3D;r&#x3D;mid\n\t\t\t&#x2F;&#x2F;2*len的pivot: ceil((2*l+1)&#x2F;2)&#x3D;l+1  eg:(01)-&gt;(0123) 1-2-3 pivot&#x3D;2\n\t\t\tif(str[i - l] &lt;&#x3D; &#39;z&#39;) res &#x3D; max(res, l + 1);&#x2F;&#x2F;字母多一个  0总是&#39;&#123;&#39;\n\t\t\telse res &#x3D; max(res, l);&#x2F;&#x2F;插入字符&#39;&#123;&#39;多一\n\t\t&#125;\n\t\tprintf(&quot;Case %d: %d\\n&quot;, T++, res);\n\t&#125;\n\t\n\treturn 0;\n&#125;\n\n&#x2F;*hash的O(n)解法:\n直接带入上一个位置的回文串长度，用 Hash 检验是否能达到这个长度，如果可以，再进行延长。\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\n#define boost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fo(v,a,b) for(int v&#x3D;(a); v&lt;&#x3D;(b); v++)\n#define fr(v,a,b) for(int v&#x3D;(a); v&gt;&#x3D;(b); v--)\n#define rng(v,a,b) for(int v&#x3D;(a); v&lt;(b); v++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate&lt;typename T&gt; T&amp; chmax(T&amp; a, T b) &#123; a &#x3D; a &gt; b ? a : b; return a;&#125;\ntemplate&lt;typename T&gt; T&amp; chmin(T&amp; a, T b) &#123; a &#x3D; a &lt; b ? a : b; return a;&#125;\nconst int maxn&#x3D;1e6+6,P&#x3D;131;\nchar s[maxn],a[maxn*2];\null H1[maxn*2],H2[maxn*2],g[maxn*2];\nint main()\n&#123;\n\tint T&#x3D;0;\n\twhile(cin &gt;&gt; (s+1) &amp;&amp; strcmp(s+1, &quot;END&quot;)) &#123;\n\t\tcout &lt;&lt; &quot;Case &quot; &lt;&lt; ++T &lt;&lt; &quot;: &quot;;\n\t\tint len &#x3D; strlen(s+1), tl&#x3D;0;\n\t\ta[++tl] &#x3D; &#39;#&#39;;\n\t\tfo(i,1,len) &#123;\n\t\t\ta[++tl] &#x3D; s[i]; a[++tl] &#x3D; &#39;#&#39;;\n\t\t&#125;\n\t\ta[tl+1] &#x3D; &#39;\\0&#39;; len&#x3D;tl;\n\n\t\tg[0] &#x3D; 1;\n\t\tfo(i,1,len) &#123;\n\t\t\tH1[i] &#x3D; H1[i-1]*P+a[i]; g[i] &#x3D; g[i-1]*P;\n\t\t&#125;\n\t\tfr(i,len,1) H2[i] &#x3D; H2[i+1]*P+a[i];\n\n\t\tint ans&#x3D;0,l;\n\t\tfo(i,1,len) &#123;\n\t\t\tl&#x3D;ans;\n\t\t\tif(i+l&gt;&#x3D;len || i-l&lt;1) break;\n\t\t\tif(H1[i+l]-H1[i-1]*g[l+1] !&#x3D; H2[i-l]-H2[i+1]*g[l+1]) continue;\n\t\t\twhile(a[i+l+1] &#x3D;&#x3D; a[i-l-1] &amp;&amp; i+l+1&lt;&#x3D;len &amp;&amp; i-l-1&gt;0) l++;\n\t\t\tchmax(ans,l);\n\t\t&#125;\n\t\tcout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;;\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：春晖のHigherSY\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;893&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;后缀数组 O(n*(logn)^2): 快排+hash+二分\n&#x2F;&#x2F;倍增，DC3 实现？？？？？\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits.h&gt;\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int N &#x3D; 300010, base &#x3D; 131;\n\nint n;\nchar str[N];\nULL h[N], p[N];\nint sa[N];\n\nint get(int l, int r)\n&#123;\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint get_max_common_prefix(int a, int b)&#x2F;&#x2F;二分模板\n&#123;\n\tint l &#x3D; 0, r &#x3D; min(n - a + 1, n - b + 1);\n\twhile(l &lt; r)\n\t&#123;\n\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\tif(get(a, a + mid - 1) !&#x3D; get(b, b + mid - 1)) r &#x3D; mid - 1;\n\t\telse l &#x3D; mid;\n\t&#125;\n&#125;\n\nbool cmp(int a, int b)\n&#123;\n\tint l &#x3D; get_max_common_prefix(a, b);\n\tint av &#x3D; a + l &gt; n ? INT_MIN : str[a + l];&#x2F;&#x2F;空字符&lt;all字符:负无穷\n\tint bv &#x3D; b + l &gt; n ? INT_MIN : str[b + l];\n\treturn av &lt; bv;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%s&quot;, str + 1);&#x2F;&#x2F;str:1--n\n\tn &#x3D; strlen(str + 1);\n\n\tp[0] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\th[i] &#x3D; h[i - 1] * base + str[i] - &#39;a&#39; + 1;\n\t\tp[i] &#x3D; p[i - 1] * base;\n\t\tsa[i] &#x3D; i;\n\t&#125;\n\n\tsort(sa + 1, sa + 1 + n, cmp);\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) printf(&quot;%d &quot;, sa[i] - 1);&#x2F;&#x2F;0-9\n\tputs(&quot;&quot;);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif(i &#x3D;&#x3D; 1) printf(&quot;0 &quot;);\n\t\telse printf(&quot;%d &quot;, get_max_common_prefix(sa[i - 1], sa[i]));\n\tputs(&quot;&quot;);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;周期 KMP  out:前缀长 前缀的max循环节个数\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint n, T &#x3D; 1;\nchar str[N];\nint Next[N];\n\nvoid get_next()&#x2F;&#x2F;KMP next数组模板\n&#123;\n\tfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\twhile(j &gt; 0 &amp;&amp; str[i] !&#x3D; str[j + 1]) j &#x3D; Next[j];\n\t\tif(str[i] &#x3D;&#x3D; str[j + 1]) j++;\n\t\tNext[i] &#x3D; j;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\twhile(scanf(&quot;%d&quot;, &amp;n), n)\n\t&#123;\n\t\tscanf(&quot;%s&quot;, str + 1);\n\t\tget_next();\n\n\t\tprintf(&quot;Test case #%d\\n&quot;, T++);\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\tint t &#x3D; i - Next[i];&#x2F;&#x2F;t&#x3D;i-Next[i]：前缀的最小循环节长度\n\t\t\tif(t !&#x3D; i &amp;&amp; i % t &#x3D;&#x3D; 0) printf(&quot;%d %d\\n&quot;, i, i &#x2F; t);\n\t\t&#125;\n\t\tputs(&quot;&quot;);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x16 Trie字典树\n&#x2F;&#x2F;前缀统计  &gt;100w:用scanf\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010, M &#x3D; 500000;\n\nint n, m;\nint son[M][26], cnt[N], idx;\nchar str[N];\n\n&#x2F;*struct Node\n&#123;\n\tint son[26];\n\tint cnt;\n&#125;;*&#x2F;\n\nvoid insert()\n&#123;\n\tint p &#x3D; 0;\n\tfor (int i &#x3D; 0; str[i]; i++)\n\t&#123;\n\t\tint &amp;s &#x3D; son[p][str[i] - &#39;a&#39;];\n\t\tif(!s) s &#x3D; ++ idx;\n\t\tp &#x3D; s;\n\t&#125;\n\tcnt[p]++;\n&#125;\n\nint query()\n&#123;\n\tint p &#x3D; 0, res &#x3D; 0;\n\tfor (int i &#x3D; 0; str[i]; i++)\n\t&#123;\n\t\tint &amp;s &#x3D; son[p][str[i] - &#39;a&#39;];\n\t\tif(!s) break;\n\t\tp &#x3D; s;\n\t\tres +&#x3D; cnt[p];\n\t&#125;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\twhile(n--)\n\t&#123;\n\t\tscanf(&quot;%s&quot;, str);\n\t\tinsert();\n\t&#125;\n\twhile(m--)\n\t&#123;\n\t\tscanf(&quot;%s&quot;, str);\n\t\tprintf(&quot;%d\\n&quot;, query());\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;最大异或对\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010, M &#x3D; 3000000;\n\nint n;\nint son[M][2], idx;\nint a[N];\n\nint insert(int x)\n&#123;\n\tint p &#x3D; 0;\n\tfor (int i &#x3D; 30; ~i; i--)&#x2F;&#x2F;~i &#x3D;&#x3D; i&gt;&#x3D;0, -1:全1 ~:全0\n\t&#123;\n\t\tint &amp;s &#x3D; son[p][x &gt;&gt; i &amp; 1];&#x2F;&#x2F;x高位到低位&#x3D;1or0\n\t\tif(!s) s &#x3D; ++ idx;&#x2F;&#x2F;新建节点\n\t\tp &#x3D; s;\n\t&#125;\n&#125;\n\nint query(int x)\n&#123;\n\tint res &#x3D; 0, p &#x3D; 0;\n\tfor (int i &#x3D; 30; ~i; i--)\n\t&#123;\n\t\tint s &#x3D; x &gt;&gt; i &amp; 1;\n\t\tif(son[p][!s]) \n\t\t&#123;\n\t\t\tres +&#x3D; 1 &lt;&lt; i;&#x2F;&#x2F;不同：该位为1\n\t\t\tp &#x3D; son[p][!s];\n\t\t&#125;\n\t\telse p &#x3D; son[p][s];&#x2F;&#x2F;&#x3D;&#x3D; 0\n\t&#125;\n\treturn res;&#x2F;&#x2F;就是^结果！\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; a[i];\n\t\tinsert(a[i]);\n\t&#125;\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, query(a[i]));\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;最长异或值路径\n&#x2F;&#x2F;链式前向星  http:&#x2F;&#x2F;www.mamicode.com&#x2F;info-detail-2368742.html\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010, M &#x3D; 3000000;\n\nint n;\nint h[N], e[N * 2], c[N * 2], ne[N * 2], cnt;\n&#x2F;&#x2F;数组模拟无向图邻接表（链式前向星:省排序），\n&#x2F;&#x2F; h[u]:目前为止起点为u的最后一条边编号,\n&#x2F;&#x2F; e边，c边权，ne:next ne[cur_edge] &#x3D; 同起点prev_edge\nint son[M][2], idx;\nint a[N];\n\nvoid add(int u, int v, int w)\n&#123;\n\te[cnt] &#x3D; v, c[cnt] &#x3D; w, ne[cnt] &#x3D; h[u], h[u] &#x3D; cnt++;\n&#125;&#x2F;&#x2F; ne[cnt] &#x3D; h[u]:ne[cur_edge]&#x3D;prev_edge&#x3D;同起点u的上一条边编号h[u]\n\nvoid dfs(int u, int fa, int sum)\n&#123;\n\ta[u] &#x3D; sum;&#x2F;&#x2F;存root--&gt;u的path上的所有边权xor值\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])&#x2F;&#x2F;遍历起点为u的所有边\n\t&#123;\n\t\tint j &#x3D; e[i];&#x2F;&#x2F;u-(边i)-&gt;j\n\t\tif(j !&#x3D; fa) dfs(j, u, sum ^ c[i]);&#x2F;&#x2F;c[i]:边i的权重\n\t&#125;\n&#125;\n\nint insert(int x)&#x2F;&#x2F;x:a[u] 即root--&gt;u的path所有边权xor值D[u]\n&#123;\n\tint p &#x3D; 0;\n\tfor (int i &#x3D; 30; ~i; i--)&#x2F;&#x2F;~i &#x3D;&#x3D; i&gt;&#x3D;0, -1:全1 ~:全0\n\t&#123;\n\t\tint &amp;s &#x3D; son[p][x &gt;&gt; i &amp; 1];&#x2F;&#x2F;x高位到低位&#x3D;1or0\n\t\tif(!s) s &#x3D; ++ idx;&#x2F;&#x2F;新建节点\n\t\tp &#x3D; s;\n\t&#125;\n&#125;\n\nint query(int x)&#x2F;&#x2F;求x:D[u]的最大xor对的xor值\n&#123;\n\tint res &#x3D; 0, p &#x3D; 0;\n\tfor (int i &#x3D; 30; ~i; i--)\n\t&#123;\n\t\tint s &#x3D; x &gt;&gt; i &amp; 1;\n\t\tif(son[p][!s]) \n\t\t&#123;\n\t\t\tres +&#x3D; 1 &lt;&lt; i;\n\t\t\tp &#x3D; son[p][!s];\n\t\t&#125;\n\t\telse p &#x3D; son[p][s];\n\t&#125;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tmemset(h, -1, sizeof h);\n\tfor (int i &#x3D; 0; i &lt; n - 1; i++)\n\t&#123;\n\t\tint u, v, w;\n\t\tcin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n\t\tadd(u, v, w);\n\t\tadd(v, u, w);\n\t&#125;&#x2F;&#x2F;建立邻接表\n\t\n\tdfs(0, -1, 0);&#x2F;&#x2F;-1 无向图遍历:出边&#x3D;&#x3D;fa父节点，就不回去\n\t&#x2F;&#x2F; 遍历邻接表，维护a[u] &#x3D; sum;存root--&gt;u的path上的所有边权xor值D[u]\n\tfor (int i &#x3D; 0; i &lt; n; i++) insert(a[i]);&#x2F;&#x2F;建trie\n\t&#x2F;&#x2F;(x,y)的path边权xor &#x3D;&#x3D; D[x] xor D[y]\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, query(a[i]));\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;* 注意! while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF 或者 -1) 可能超时原因：input结尾有ctrl+z非数字,scanf返回0\n建议改为 while(cin &gt;&gt; n)\n*&#x2F;\n\n&#x2F;&#x2F;0x17 二叉堆\n&#x2F;&#x2F;超市\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nint main()\n&#123;\n\tint n;\n\twhile(cin &gt;&gt; n)\n\t&#123;\n\t\tvector&lt;PII&gt; products(n);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) \n\t\t\tcin &gt;&gt; products[i].second &gt;&gt; products[i].first;\n\t\t\t&#x2F;&#x2F;利润小根堆 过期时间sort\n\t\tsort(products.begin(), products.end());\n\t\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\n\t\tfor (auto p : products)\n\t\t&#123;\n\t\t\theap.push(p.second);&#x2F;&#x2F;先push\n\t\t\tif(heap.size() &gt; p.first) heap.pop();&#x2F;&#x2F;if(size &gt; t) pop();\n\t\t&#125;\n\n\t\tint res &#x3D; 0;\n\t\twhile(heap.size()) res +&#x3D; heap.top(), heap.pop();\n\t\t\n\t\tcout &lt;&lt; res &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;序列  学2-&gt;n-seq合并框架: a&#x3D;,b变 merge(a,b)\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 2010;\n\nint m, n;\nint a[N], b[N], c[N];\n\nvoid merge()\n&#123;\n\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n\tfor (int i &#x3D; 0; i &lt; n; i++) heap.push(&#123;a[0] + b[i], 0&#125;);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\t\tint s &#x3D; t.first, p &#x3D; t.second;&#x2F;&#x2F;sum, p下标\n\t\tc[i] &#x3D; s;\n\t\theap.push(&#123;s - a[p] + a[p + 1], p + 1&#125;);&#x2F;&#x2F; (--&gt;)入队\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; n; i++) a[i] &#x3D; c[i];\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;m, &amp;n);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\n\t\tsort(a, a + n);\n\t\tfor (int i &#x3D; 0; i &lt; m - 1; i++)\n\t\t&#123;\n\t\t\tfor (int j &#x3D; 0; j &lt; n; j++) scanf(&quot;%d&quot;, &amp;b[j]);\n\t\t\tmerge();\n\t\t&#125;\n\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) printf(&quot;%d &quot;, a[i]);\n\t\tputs(&quot;&quot;);\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数据备份  min的两侧同时(不)选\n&#x2F;&#x2F; 双链表(prev,next):l[]r[]模拟 + 堆(修改elems)用set红黑树 ++:O(logn)\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;LL, int&gt; PLI;\n\nconst int N &#x3D; 100010;\n\nint n, k;\nint l[N], r[N];\nLL d[N];\n\nvoid delete_node(int p)\n&#123;\n\tr[l[p]] &#x3D; r[p];\n\tl[r[p]] &#x3D; l[p];\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; k;&#x2F;&#x2F;楼数 电缆数\n\tfor (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; d[i];\n\tfor (int i &#x3D; n - 1; ~i; i--) d[i] -&#x3D; d[i - 1];\n\n\tset&lt;PLI&gt; S;\n\td[0] &#x3D; d[n] &#x3D; 1e15;&#x2F;&#x2F;哨兵\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tl[i] &#x3D; i - 1;\n\t\tr[i] &#x3D; i + 1;\n\t\tif(i &gt;&#x3D; 1 &amp;&amp; i &lt; n) S.insert(&#123;d[i], i&#125;);\n\t&#125;\n\n\tLL res &#x3D; 0;\n\twhile(k--)\n\t&#123;\n\t\tauto it &#x3D; S.begin();\n\t\tLL v &#x3D; it -&gt; first;\n\t\tint p &#x3D; it -&gt; second, left &#x3D; l[p], right &#x3D; r[p];\n\t\t&#x2F;&#x2F;!!!\n\t\tres +&#x3D; v;\n\t\tS.erase(it);\n\t\tS.erase(&#123;d[left], left&#125;), S.erase(&#123;d[right], right&#125;); \n\t\tdelete_node(left), delete_node(right);\n\t\t\n\t\td[p] &#x3D; d[left] + d[right] - d[p];\n\t\tS.insert(&#123;d[p], p&#125;);\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;&#x2F;&#x2F;k-dist最小总长\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;Huffman树\n&#x2F;&#x2F;合并果子\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n, x, res;\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; x, heap.push(x);\n\t\n\twhile(heap.size() &gt;&#x3D; 2)\n\t&#123;\n\t\tint a &#x3D; heap.top(); heap.pop();\n\t\tint b &#x3D; heap.top(); heap.pop();\n\t\tres +&#x3D; a + b;\n\t\theap.push(a + b);\n\t&#125;\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;荷马史诗\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;LL, int&gt; PLI;&#x2F;&#x2F;&#123;出现次数,深度&#125;sort\n\nint main()\n&#123;\n\tint n, k;\n\tcin &gt;&gt; n &gt;&gt; k;\n\n\tpriority_queue&lt;PLI, vector&lt;PLI&gt;, greater&lt;PLI&gt;&gt; heap;\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tLL x;&#x2F;&#x2F;!!!\n\t\tcin &gt;&gt; x;\n\t\theap.push(&#123;x, 0&#125;);\n\t&#125;\n\twhile((n - 1) % (k - 1)) heap.push(&#123;0, 0&#125;), n++;&#x2F;&#x2F;先补0\n\n\tLL res &#x3D; 0;\n\twhile(heap.size() &gt; 1)\n\t&#123;\n\t\tLL s &#x3D; 0;\n\t\tint depth &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\t&#123;\n\t\t\tauto t &#x3D; heap.top();\n\t\t\ts +&#x3D; t.first;\n\t\t\tdepth &#x3D; max(depth, t.second);&#x2F;&#x2F;!!!\n\t\t\theap.pop();\n\t\t&#125;\n\t\tres +&#x3D; s;\n\t\theap.push(&#123;s, depth + 1&#125;);\n\t&#125;\n\t&#x2F;&#x2F;最小总长度，最长si的最短长度\n\tcout &lt;&lt; res &lt;&lt; endl &lt;&lt; heap.top().second &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;0x1.8 总结与练习\n\n&#x2F;&#x2F;  150 括号画家\n&#x2F;*\n()[]&#123;&#125;\n找出其中连续的一段，满足这段子序列是美观的（括号匹配的），并且长度尽量大。\n求max_len\n右)]&#125; 匹配成对删 不匹入栈\n\nDP：决策不唯一时，枚举各种决策\n贪心：不需要做决策 only one\n从最左合法位置开始扫，就能得到最优解：因为\n两合法连续序列有交集，则并集合法。\n（证区间可加性 L:cnt+1 R:cnt-1 任意前缀和cnt&gt;0 整段cnt&#x3D;&#x3D;0）xy yz两段：x&#x3D;y&#x3D;z&#x3D;0\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint main()\n&#123;\n\tstring str;\n\tcin &gt;&gt; str;\n\tstack&lt;int&gt; stk;\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; str.size(); i ++ )\n\t&#123;\n\t\tchar c &#x3D; str[i];\n\t\tif(stk.size())\n\t\t&#123;\n\t\t\tchar t &#x3D; str[stk.top()];\n\t\t\tif (c &#x3D;&#x3D; &#39;)&#39; &amp;&amp; t &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;]&#39; &amp;&amp; t &#x3D;&#x3D; &#39;[&#39; || c &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; t &#x3D;&#x3D; &#39;&#123;&#39;) stk.pop();&#x2F;&#x2F;匹\n\t\t\telse stk.push(i);&#x2F;&#x2F;不匹\n\t\t&#125;\n\t\telse stk.push(i);&#x2F;&#x2F;stk空\n\n\t\tif (stk.size()) res &#x3D; max(res, i - stk.top());&#x2F;&#x2F;匹配就被pop\n\t\telse res &#x3D; max(res, i + 1);&#x2F;&#x2F;0~i\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F; 151 表达式计算4  39.58%  中等\n&#x2F;*\n+,-,*,&#x2F;,^,(,) 有多余括号  二叉树递归定义：stk\n\n处理多余右括号str&#x3D;&#x3D;))) -&gt; ((((str) 保证&#39;(&#39; &gt;&#x3D; &#39;)&#39;\ni-1非数字非&#39;)&#39;则c(i)&#x3D;&#39;-&#39;负号\ntop&gt;&#x3D;cur_priority 可先算\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nstack&lt;int&gt; nums;\nstack&lt;char&gt; ops;\n\nint qmi(int a, int k)\n&#123;\n\tint res &#x3D; 1;\n\twhile (k -- ) res *&#x3D; a;\n\treturn res;\n&#125;\n\nvoid cal()\n&#123;\n\tint a &#x3D; nums.top(); nums.pop();\n\tint b &#x3D; nums.top(); nums.pop();\n\tchar c &#x3D; ops.top(); ops.pop();\n\tint d;\n\n\tif (c &#x3D;&#x3D; &#39;+&#39;) d &#x3D; b + a;\n\telse if (c &#x3D;&#x3D; &#39;-&#39;) d &#x3D; b - a;\n\telse if (c &#x3D;&#x3D; &#39;*&#39;) d &#x3D; b * a;\n\telse if (c &#x3D;&#x3D; &#39;&#x2F;&#39;) d &#x3D; b &#x2F; a;\n\telse d &#x3D; qmi(b, a);\n\n\tnums.push(d);\n&#125;\n\nint main()\n&#123;\n\tstring str;\n\tcin &gt;&gt; str;\n\n\t&#x2F;&#x2F;if (str[0] &#x3D;&#x3D; &#39;-&#39;) str &#x3D; &#39;0&#39; + str;&#x2F;&#x2F; -? &#x3D;&#x3D; 0-?\n\n\t&#x2F;&#x2F; 处理多余右括号str&#x3D;&#x3D;))) -&gt; ((((str) 保证&#39;(&#39; &gt;&#x3D; &#39;)&#39;\n\tstring left;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; str.size(); i ++ ) left +&#x3D; &#39;(&#39;;\n\tstr &#x3D; left + str + &#39;)&#39;;\n\n\tfor (int i &#x3D; 0; i &lt; str.size(); i ++ )\n\t&#123;\n\t\tif (str[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;9&#39;) &#x2F;&#x2F; toInt\n\t\t&#123;\n\t\t\tint j &#x3D; i, t &#x3D; 0;\n\t\t\twhile (str[j] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[j] &lt;&#x3D; &#39;9&#39;)\n\t\t\t&#123;\n\t\t\t\tt &#x3D; t * 10 + str[j] - &#39;0&#39;;\n\t\t\t\tj ++ ;\n\t\t\t&#125;\n\t\t\tnums.push(t);\n\t\t\ti &#x3D; j - 1;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tchar c &#x3D; str[i];\n\t\t\tif (c &#x3D;&#x3D; &#39;(&#39;) ops.push(c);\n\t\t\telse if (c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tif (c &#x3D;&#x3D; &#39;-&#39; &amp;&amp; i &amp;&amp; !(str[i - 1] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i - 1] &lt;&#x3D; &#39;9&#39;) &amp;&amp; str[i - 1] !&#x3D; &#39;)&#39;)&#x2F;&#x2F;i-1非数字非&#39;)&#39;则c(i)&#x3D;&#39;-&#39;负号\n\t\t\t\t&#123;\n\t\t\t\t\tint j &#x3D; i + 1, t &#x3D; 0;\n\t\t\t\t\twhile (str[j] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[j] &lt;&#x3D; &#39;9&#39;)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tt &#x3D; t * 10 + str[j] - &#39;0&#39;;\n\t\t\t\t\t\tj ++ ;\n\t\t\t\t\t&#125;\n\t\t\t\t\tnums.push(-t);&#x2F;&#x2F;-t\n\t\t\t\t\ti &#x3D; j - 1;\n\t\t\t\t&#125;\n\t\t\t\telse&#x2F;&#x2F;c&#x3D;加减号\n\t\t\t\t&#123;\n\t\t\t\t\twhile (ops.top() !&#x3D; &#39;(&#39;) cal();\n\t\t\t\t\tops.push(c);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\telse if (c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;)\n\t\t\t&#123;\n\t\t\t\twhile (ops.top() &#x3D;&#x3D; &#39;*&#39; || ops.top() &#x3D;&#x3D; &#39;&#x2F;&#39; || ops.top() &#x3D;&#x3D; &#39;^&#39;) cal();&#x2F;&#x2F; top&gt;&#x3D;cur_priority 可先算\n\t\t\t\tops.push(c);\n\t\t\t&#125;\n\t\t\telse if (c &#x3D;&#x3D; &#39;^&#39;)\n\t\t\t&#123;\n\t\t\t\twhile (ops.top() &#x3D;&#x3D; &#39;^&#39;) cal();\n\t\t\t\tops.push(c);\n\t\t\t&#125;\n\t\t\telse if (c &#x3D;&#x3D; &#39;)&#39;)\n\t\t\t&#123;\n\t\t\t\twhile (ops.top() !&#x3D; &#39;(&#39;) cal();&#x2F;&#x2F;prio_increment\n\t\t\t\tops.pop(); &#x2F;&#x2F; pop&#39;(&#39;\n\t\t\t&#125;\n\t\t\telse cout &lt;&lt; &quot;invalid operator!&quot; &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; nums.top() &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 152 城市游戏    52.47%  中等\n&#x2F;*\nAcwing131.直方图中最大的矩形 单调栈 变形题\n面积最大的F子矩阵\n\ncin自动过滤空白字符！！！\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nint n, m;\nchar g[N][N];\nint h[N][N]; &#x2F;&#x2F; [cur以上有多少个连续F\nint q[N], l[N], r[N];&#x2F;&#x2F; &gt;&#x3D;i的[l,i,r]边界\n\nvoid cal(int a[], int l[])\n&#123;\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\ta[0] &#x3D; -1;&#x2F;&#x2F;哨兵\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\twhile (a[q[tt]] &gt;&#x3D; a[i]) tt -- ;\n\t\tl[i] &#x3D; q[tt] + 1; &#x2F;&#x2F; [l,r]&gt;&#x3D;a[i]\n\t\tq[ ++ tt] &#x3D; i;\n\t&#125;\n&#125;\n\nint work(int a[])\n&#123;\n\tcal(a, l);\n\treverse(a + 1, a + 1 + m);\n\tcal(a, r);\n\treverse(a + 1, a + 1 + m);\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\tint left &#x3D; l[i];\n\t\tint right &#x3D; m + 1 - r[m + 1 - i]; &#x2F;&#x2F; ！！！！！！！！！！！！！！\n\t\tres &#x3D; max(res, a[i] * (right - left + 1));\n\t&#125;\n\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )\n\t\t&#123;\n\t\t\tcin &gt;&gt; g[i][j];\n\t\t\tif (g[i][j] &#x3D;&#x3D; &#39;F&#39;) h[i][j] &#x3D; h[i - 1][j] + 1;\n\t\t\telse h[i][j] &#x3D; 0;\n\t\t&#125;\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) res &#x3D; max(res, work(h[i]));\n\n\tcout &lt;&lt; res * 3 &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 153 双栈排序    31.17%  困难\n&#x2F;*\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;3710&#x2F;\n两个数 i,j(i≤j) 不能被放入同一个栈中，当且仅当存在 k, k&gt;j 且 q[k]&lt;q[i]&lt;q[j]。\nq[i]&#x3D;2、q[j]&#x3D;3、q[k]&#x3D;1\n如果i, j满足条件(231)，则在i和j之间连一条边。然后判断是否是二分图即可。\njudge二分图：染色法【无奇环】\n\ncur-&gt;(大)-&gt;小\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;stack&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nint n;\nint a[N], f[N];\nint color[N];\nbool g[N][N];\n\nbool dfs(int u, int c)\n&#123;\n\tcolor[u] &#x3D; c;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (g[u][i])&#x2F;&#x2F;u-i相邻\n\t\t&#123;\n\t\t\tif (color[i] &#x3D;&#x3D; c) return false;\n\t\t\tif (color[i] &#x3D;&#x3D; -1 &amp;&amp; !dfs(i, !c)) return false;\n\t\t&#125;\n\n\treturn true;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; a[i];\n\tf[n + 1] &#x3D; n + 1;\n\tmemset(g, false, sizeof g);\n\tfor (int i &#x3D; n; i; i--) f[i] &#x3D; min(f[i + 1], a[i]);&#x2F;&#x2F;f[i]&#x3D;[i后min_a\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; i + 1; j &lt;&#x3D; n; j++)\n\t\t\tif (a[i] &lt; a[j] &amp;&amp; f[j + 1] &lt; a[i])\n\t\t\t\tg[i][j] &#x3D; g[j][i] &#x3D; true;\n\n\tmemset(color, -1, sizeof color);\n\n\tbool flag &#x3D; true;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (color[i] &#x3D;&#x3D; -1 &amp;&amp; !dfs(i, 0))&#x2F;&#x2F;i未染,(01)优先染0,染色不成功\n\t\t&#123;\n\t\t\tflag &#x3D; false;\n\t\t\tbreak;\n\t\t&#125;\n\n\tif (!flag)\n\t&#123;\n\t\tcout &lt;&lt; 0 &lt;&lt; endl;\n\t\treturn 0;\n\t&#125;\n\n\tstack&lt;int&gt; stk1, stk2;\n\n\tint now &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tif (color[i] &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 要入第一个栈了，第一个栈该出的(小)现在必须要出掉\n\t\t\t&#x2F;&#x2F; 为了使字典序最小，第二个栈可以再等等\n\t\t\twhile (stk1.size() &amp;&amp; stk1.top() &#x3D;&#x3D; now)\n\t\t\t&#123;\n\t\t\t\tstk1.pop();\n\t\t\t\tcout &lt;&lt; &quot;b &quot;;\n\t\t\t\tnow++;\n\t\t\t&#125;\n\t\t\tstk1.push(a[i]);\n\t\t\tcout &lt;&lt; &quot;a &quot;;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 要入第二个栈了，第二个栈该出的(小)现在必须要出掉\n\t\t\t&#x2F;&#x2F; 然而由于b比c字典序小，第一个栈可以出的(小)也应该出掉\n\t\t\twhile (true)\n\t\t\t\tif (stk1.size() &amp;&amp; stk1.top() &#x3D;&#x3D; now)\n\t\t\t\t&#123;\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tcout &lt;&lt; &quot;b &quot;;\n\t\t\t\t\tnow++;\n\t\t\t\t&#125;\n\t\t\t\telse if (stk2.size() &amp;&amp; stk2.top() &#x3D;&#x3D; now)\n\t\t\t\t&#123;\n\t\t\t\t\tstk2.pop();\n\t\t\t\t\tcout &lt;&lt; &quot;d &quot;;\n\t\t\t\t\tnow++;\n\t\t\t\t&#125;\n\t\t\t\telse break;\n\t\t\tstk2.push(a[i]);\n\t\t\tcout &lt;&lt; &quot;c &quot;;\n\t\t&#125;\n\n\t&#125;\n\t&#x2F;&#x2F; 最后出栈剩余的\n\twhile (true)\n\t\tif (stk1.size() &amp;&amp; stk1.top() &#x3D;&#x3D; now)\n\t\t&#123;\n\t\t\tstk1.pop();\n\t\t\tcout &lt;&lt; &quot;b &quot;;\n\t\t\tnow++;\n\t\t&#125;\n\t\telse if (stk2.size() &amp;&amp; stk2.top() &#x3D;&#x3D; now)\n\t\t&#123;\n\t\t\tstk2.pop();\n\t\t\tcout &lt;&lt; &quot;d &quot;;\n\t\t\tnow++;\n\t\t&#125;\n\t\telse break;\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 154 滑动窗口    49.84%  简单\n&#x2F;*\n确定滑动窗口位于每个位置时，窗口中的最大值和最小值。\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint n, m;\nint a[N];\nint q[N];\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);\n\n\tint hh &#x3D; 0, tt &#x3D; -1;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tif (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt;&#x3D; i - m) hh ++ ;\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &gt;&#x3D; a[i]) tt -- ;\n\t\tq[ ++ tt] &#x3D; i;\n\t\tif (i &gt;&#x3D; m - 1) printf(&quot;%d &quot;, a[q[hh]]);\n\t&#125;\n\tputs(&quot;&quot;);\n\n\thh &#x3D; 0, tt &#x3D; -1;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tif (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt;&#x3D; i - m) hh ++ ;\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) tt -- ;&#x2F;&#x2F;\n\t\tq[ ++ tt] &#x3D; i;\n\t\tif (i &gt;&#x3D; m - 1) printf(&quot;%d &quot;, a[q[hh]]);\n\t&#125;\n\tputs(&quot;&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; 155 内存分配    40.05%  困难模拟\n&#x2F;*\n数据结构：\n等待队列：(内存长度, 占用时间)：queue\n内存使用情况：(起始下标，长度)\n线性扫描、删除、插入：set(RBTree):O(log)级别的插入,删除,求前驱,求后继等\n小根堆：（释放时间key，[mem_index]起始下标），priority_queue\n算法流程：\n新来一个请求：（T,M,P)\n\n释放掉所有&quot;释放时间&lt;&#x3D;T&quot;的内存，每次释放之后，都要判断等待队列的队头是否可以满足\n判断（T，M，P)是否可以满足，如果不可以，则插入等待队列\n\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;1840&#x2F;\n*&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nint n;\nqueue&lt;PII&gt; waits;       &#x2F;&#x2F; (first: 内存长度M，second: 占用时间P)\nset&lt;PII&gt; runs;          &#x2F;&#x2F; (first: 起始下标，second：长度)\npriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; endts;       &#x2F;&#x2F; (first: 释放时间，second: 起始下标)\nint tm, cnt;    &#x2F;&#x2F; terminate_time, waits_max_size\n\nbool give(int t, int m, int p)&#x2F;&#x2F;判断TMP是否可以满足，满足则分配\n&#123;\n\tfor (auto it &#x3D; runs.begin(); it !&#x3D; runs.end(); it ++ )&#x2F;&#x2F;枚举used_mem\n\t&#123;\n\t\tauto jt &#x3D; it;\n\t\tjt ++ ;&#x2F;&#x2F; jt &#x3D;&#x3D; it+1\n\t\tif (jt !&#x3D; runs.end())\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;m &lt;&#x3D; j_start_idx - it_end_idx - 1 ([it]~[jt]之间缝隙)\n\t\t\tif (m &lt;&#x3D; jt-&gt;first - (it-&gt;first + it-&gt;second - 1) - 1)\n\t\t\t&#123;\n\t\t\t\tint start &#x3D; it-&gt;first + it-&gt;second;\n\t\t\t\truns.insert(&#123;start, m&#125;);&#x2F;&#x2F;起始下标，长度\n\t\t\t\tendts.push(&#123;t + p, start&#125;);&#x2F;&#x2F;释放时间，起始下标\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\treturn false;\n&#125;\n\nvoid finish(int t) &#x2F;&#x2F; 释放掉所有&quot;释放时间&lt;&#x3D;T&quot;的内存\n&#123;\n\twhile (endts.size() &amp;&amp; endts.top().first &lt;&#x3D; t)\n\t&#123;\n\t\tint f &#x3D; endts.top().first;\n\t\twhile (endts.size() &amp;&amp; endts.top().first &#x3D;&#x3D; f)&#x2F;&#x2F;endts&#x3D;&#x3D; 一并删除\n\t\t&#123;\n\t\t\tauto top &#x3D; endts.top();\n\t\t\tendts.pop();\n\t\t\tauto it &#x3D; runs.lower_bound(&#123;top.second, 0&#125;);&#x2F;&#x2F; &gt;&#x3D;起始下标的min\n\t\t\truns.erase(it);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 每次释放之后，都要判断等待队列的队头是否可以满足\n\t\ttm &#x3D; f;\n\t\twhile (waits.size())\n\t\t&#123;\n\t\t\tauto front &#x3D; waits.front();\n\t\t\tif (give(f, front.first, front.second))&#x2F;&#x2F;队头分配成功\n\t\t\t&#123;\n\t\t\t\twaits.pop();\n\t\t\t&#125;\n\t\t\telse break;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tint t, m, p;\n\n\truns.insert(&#123;-1, 1&#125;), runs.insert(&#123;n, 1&#125;);&#x2F;&#x2F;内存使用情况哨兵\n\n\twhile (cin &gt;&gt; t &gt;&gt; m &gt;&gt; p, t || m || p)\n\t&#123;\n\t\tfinish(t);\n\t\tif (!give(t, m, p))&#x2F;&#x2F;判断TMP是否可以满足，如果不可以，则插入等待队列\n\t\t&#123;\n\t\t\twaits.push(&#123;m, p&#125;);\n\t\t\tcnt ++ ;\n\t\t&#125;\n\t&#125;\n\n\tfinish(2e9);&#x2F;&#x2F;\n\n\tcout &lt;&lt; tm &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 156 矩阵  33.52%  中等\n&#x2F;*\nQ次询问，每次询问给出一个A行B列的01矩阵，求该矩阵是否在原矩阵中出现过\n2D str_hash:\n32高位\n10低位\n1&lt;~A行 -&gt; 2&lt;~A+1行：S*p^B-hash1*p^(A*B)+hash(A+1行)\n\n预处理all A*B子矩阵 str_hash-&gt;unordered _set哈希表S , S.count 即可\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_set&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nconst int N &#x3D; 1010, M &#x3D; N * N, P &#x3D; 131;\n\nint n, m, a, b;\nULL hashv[N][N], p[M];\nchar str[N];\n\nULL calc(ULL f[], int l, int r)&#x2F;&#x2F;strLR_hash\n&#123;\n\treturn f[r] - f[l - 1] * p[r - l + 1];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;a, &amp;b);\n\n\tp[0] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n * m; i ++ ) p[i] &#x3D; p[i - 1] * P;&#x2F;&#x2F;p^i\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F;suffix_sum\n\t&#123;\n\t\tscanf(&quot;%s&quot;, str + 1);\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) hashv[i][j] &#x3D; hashv[i][j - 1] * P + str[j] - &#39;0&#39;;\n\t&#125;\n\n\tunordered_set&lt;ULL&gt; S;\n\tfor (int i &#x3D; b; i &lt;&#x3D; m; i ++ )&#x2F;&#x2F;一列一列\n\t&#123;\n\t\tULL s &#x3D; 0;\n\t\tint l &#x3D; i - b + 1, r &#x3D; i;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )&#x2F;&#x2F;S*p^B-hash1*p^(A*B)+hash(A+1行)\n\t\t&#123;\n\t\t\ts &#x3D; s * p[b] + calc(hashv[j], l, r);&#x2F;&#x2F;1~A行\n\t\t\t&#x2F;&#x2F;A+j行：-hashj*p^(A*B)\n\t\t\tif (j - a &gt; 0) s -&#x3D; calc(hashv[j - a], l, r) * p[a * b];\n\t\t\tif (j &gt;&#x3D; a) S.insert(s);\n\t\t&#125;\n\t&#125;\n\n\tint Q;\n\tscanf(&quot;%d&quot;, &amp;Q);\n\twhile (Q -- )\n\t&#123;\n\t\tULL s &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; a; i ++ )\n\t\t&#123;\n\t\t\tscanf(&quot;%s&quot;, str);\n\t\t\tfor (int j &#x3D; 0; j &lt; b; j ++ ) s &#x3D; s * P + str[j] - &#39;0&#39;;\n\t\t&#125;\n\t\tif (S.count(s)) puts(&quot;1&quot;);\n\t\telse puts(&quot;0&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 157 树形地铁系统  62.41%  简单\n&#x2F;*\n每个测试用例，如果两个字符串描述的探索路线 “树同构”：child无LR，则输出same。否则，输出different。\n\n1,2都-&gt;树的最小表示(与这棵树同构的最小的dfs序) &#x3D;&#x3D;就same\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstring dfs(string &amp;seq, int &amp;u)&#x2F;&#x2F;子树的最小表示\n&#123;\n\tu ++ ;&#x2F;&#x2F;root-&gt;sub_root\n\tvector&lt;string&gt; seqs;\n\twhile (seq[u] &#x3D;&#x3D; &#39;0&#39;) seqs.push_back(dfs(seq, u));&#x2F;&#x2F;递归出子树seq\n\tu ++ ;&#x2F;&#x2F;sub_root-&gt;root\n\t\n\tsort(seqs.begin(), seqs.end());\n\tstring res &#x3D; &quot;0&quot;;\n\tfor (auto &amp;s : seqs) res +&#x3D; s; &#x2F;&#x2F; 0+sorted(子seqs)+1\n\tres +&#x3D; &#39;1&#39;;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile (T -- )\n\t&#123;\n\t\tstring a, b;\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\ta &#x3D; &#39;0&#39; + a + &#39;1&#39;;&#x2F;&#x2F;root哨兵\n\t\tb &#x3D; &#39;0&#39; + b + &#39;1&#39;;\n\t\tint ua &#x3D; 0, ub &#x3D; 0;\n\t\tif (dfs(a, ua) &#x3D;&#x3D; dfs(b, ub)) puts(&quot;same&quot;);\n\t\telse puts(&quot;different&quot;);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; 158 项链  57.17%  简单\n&#x2F;*\n一个对于项链的表示就是从项链的某个宝石开始，顺指针绕一圈，沿途记下经过的宝石，比如项链： 0-1-2-3 ，它的可能的四种表示是0123、1230、2301、3012。旋转不变！\n项链不会翻转，给定两个项链的表示，判断他们是否可能是一条项链。\nYes 循环同构串的最小表示法 P76\n环-&gt;链：n*2法 n_window滑动 cmp 1.i&#x3D;2.j i+k&gt;j+k : 1.jump_to_i+k+1 if(i&#x3D;&#x3D;j)i++\nans_start&#x3D;B[min(i,j)]\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 2000000;\n\nint n;\nchar a[N], b[N];\n\nint get_min(char str[])\n&#123;\n\tint i &#x3D; 0, j &#x3D; 1;\n\twhile (i &lt; n &amp;&amp; j &lt; n)\n\t&#123;\n\t\tint k &#x3D; 0;\n\t\twhile (k &lt; n &amp;&amp; str[i + k] &#x3D;&#x3D; str[j + k]) k ++ ;\n\t\tif (k &#x3D;&#x3D; n) break;&#x2F;&#x2F;全等\n\t\tif (str[i + k] &gt; str[j + k]) i +&#x3D; k + 1;\n\t\telse j +&#x3D; k + 1;\n\t\tif (i &#x3D;&#x3D; j) i ++ ;\n\t&#125;\n\tint res &#x3D; min(i, j);\n\tstr[res + n] &#x3D; 0;&#x2F;&#x2F;&#39;\\0&#39;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%s%s&quot;, a, b);\n\tn &#x3D; strlen(a);\n\n\tmemcpy(a + n, a, n);&#x2F;&#x2F;void *memcpy(void*dest, const void *src, size_t n);\n\tmemcpy(b + n, b, n);\n\n\tint ia &#x3D; get_min(a), ib &#x3D; get_min(b);&#x2F;&#x2F;min(i, j)\n\n\tif (strcmp(a + ia, b + ib)) puts(&quot;No&quot;);\n\telse\n\t&#123;\n\t\tputs(&quot;Yes&quot;);\n\t\tputs(a + ia);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 159 奶牛矩阵    40.53%  中等\n&#x2F;*\n最小覆盖窗口面积\n\n串完美循环时：KMP求min循环节长度 \n行上min循环节长度W&#x3D;n-next[n]  max,公倍数 都不对！only爆搜O(n)\nW看做elem，列上做KMP求循环节长度h\nmin_w-&gt;min_h(w+ 原本&#x3D;的循环节变!&#x3D; 为了再&#x3D;&#x3D; h也+)\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 10010, M &#x3D; 80;\n\nint n, m;\nchar str[N][M];\nbool st[M];\nint ne[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F;行i\n\t&#123;\n\t\tcin &gt;&gt; str[i];\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )&#x2F;&#x2F;循环节长度j\n\t\t&#123;\n\t\t\tbool is_match &#x3D; true;\n\t\t\tfor (int k &#x3D; j; k &lt; m; k +&#x3D; j)&#x2F;&#x2F;start k\n\t\t\t&#123;\n\t\t\t\tfor (int u &#x3D; 0; u &lt; j &amp;&amp; k + u &lt; m; u ++ )&#x2F;&#x2F;cur\n\t\t\t\t\tif (str[i][u] !&#x3D; str[i][k + u])&#x2F;&#x2F;第k个!&#x3D;first\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tis_match &#x3D; false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\tif (!is_match) break;\n\t\t\t&#125;\n\t\t\tif (!is_match) st[j] &#x3D; true;&#x2F;&#x2F;不可取\n\t\t&#125;\n\t&#125;\n\n\tint width;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t\tif (!st[i])&#x2F;&#x2F;可取\n\t\t&#123;\n\t\t\twidth &#x3D; i;\n\t\t\tbreak;\n\t\t&#125;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) str[i][width] &#x3D; 0;&#x2F;&#x2F; w+&#39;\\0&#39;-&gt;elem\n\t&#x2F;&#x2F;kmp_ne[]模板\n\tfor (int j &#x3D; 0, i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\twhile (j &amp;&amp; strcmp(str[j + 1], str[i])) j &#x3D; ne[j];\n\t\tif (!strcmp(str[j + 1], str[i])) j ++ ;\n\t\tne[i] &#x3D; j;\n\t&#125;\n\n\tint height &#x3D; n - ne[n];\n\n\tcout &lt;&lt; width * height &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 160 匹配统计    46.76%  中等\n&#x2F;*\n给定你一个整数x，请你告诉他有多少个位置，满足“字符串A从该位置开始的后缀子串”与B匹配的长度恰好为x。\nA&#x3D;aabcde，B&#x3D;ab，则A有aabcde、abcde、bcde、cde、de、e这6个后缀子串，它们与B&#x3D;ab的匹配长度分别是1、2、0、0、0、0。\n因此A与B的匹配长度恰好为0有4个位置，匹配长度恰好为1有1个位置，匹配长度恰好为2有1个位置。\n\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;15841&#x2F;\n法一：str_hash\n法二:kmp\n*&#x2F;\n\n算法1\n(哈希) O(NlogN+M+Q)\n先分别求出 A 与 B 的哈希数组，对于 a 中的每一个后缀，二分求一下能匹配的 B 的最大前缀即可。\n详见代码注释\n\n时间复杂度\n求出 A 的哈希数组，时间复杂度是 O(N)\n求出 B 的哈希数组，时间复杂度是 O(M)\n一共要二分 N 次，每次二分的时间复杂度是 O(log⁡N)，所以二分的总时间复杂度是 O(NlogN)\n要处理 Q 次询问，每次询问的时间复杂度是 O(1)，处理所有询问的时间复杂度就是 O(Q)\n所以总的时间复杂度为 O(Nlog⁡N+M+Q)\nC++ 代码\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef unsigned long long ULL;\nconst int N &#x3D; 200005;\nconst ULL P &#x3D; 131;\n\nint n, m, q;                    &#x2F;&#x2F; 题目中 N, M, Q\nchar A[N], B[N];                &#x2F;&#x2F; 题目中 A, B\nULL hash_A[N], hash_B[N], p[N]; &#x2F;&#x2F; hash_A, hash_B 分别存 A, B 的哈希值。p 存 P 的 i 次幂，用于求出每个子串的哈希值。\nint cnt[N];                     &#x2F;&#x2F; 二分预处理的 A 中每个后缀与 B 匹配的最长长度，存入 cnt\n\nULL get(ULL h[], int l, int r)  &#x2F;&#x2F; 返回 h 中 [l, r] 的哈希值\n&#123;\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d\\n&quot;, &amp;n, &amp;m, &amp;q);\n\tscanf(&quot;%s\\n%s&quot;, A + 1, B + 1); &#x2F;&#x2F; 由于要处理哈希，从 1 开始输入会方便一些\n\tp[0] &#x3D; 1;                      &#x2F;&#x2F; 根据定义，P 的 0 次幂为 1\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; p[i - 1] * P;                  &#x2F;&#x2F; 预处理 p\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) hash_A[i] &#x3D; hash_A[i - 1] * P + A[i]; &#x2F;&#x2F; 预处理 hash_A\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) hash_B[i] &#x3D; hash_B[i - 1] * P + B[i]; &#x2F;&#x2F; 预处理 hash_B\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#x2F;&#x2F; 二分预处理 cnt\n\t&#123;\n\t\tint l &#x3D; i, r &#x3D; i + m, mid; &#x2F;&#x2F; 二分左边界为 i，右边界为 i + m\n\t\tif (r &gt; n + 1) r &#x3D; n + 1;  &#x2F;&#x2F; 如果右边界不在 A 中，让其指向 A 的右边界\n\t\twhile (l &lt; r)              &#x2F;&#x2F; 二分板子\n\t\t&#123;\n\t\t\tmid &#x3D; l + r &gt;&gt; 1;\n\t\t\tif (get(hash_A, i, mid) !&#x3D; get(hash_B, 1, mid - i + 1)) r &#x3D; mid;\n\t\t\telse    l &#x3D; mid + 1;\n\t\t&#125;\n\t\tcnt[r - i] ++ ; &#x2F;&#x2F; 二分之后，r 表示的是 B 与 A 匹配的最靠后的位置（从 i 开始），r - i 是 A 从 i 开始的后缀与 B 匹配的最长长度\n\t&#125;\n\twhile (q -- )       &#x2F;&#x2F; 处理询问\n\t&#123;\n\t\tint x;\n\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\tprintf(&quot;%d\\n&quot;, cnt[x]);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n算法2 【题解至少读两遍！！！】\n(KMP) O(N+M+Q)\n这个解法的确比较难想。。需要对 KMP 足够的熟悉。。\n先对 B 求 KMP，得到 B 的 next 数组。\n然后对 A 做一遍匹配，回忆一下匹配的代码：\n\nfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )\n&#123;\n\twhile (j &amp;&amp; a[i] !&#x3D; b[j + 1]) j &#x3D; ne[j];\n\tif (a[i] &#x3D;&#x3D; b[j + 1]) j ++ ;\n\t&#x2F;&#x2F; blablabla\n&#125;\n我们发现，在 blablabla 那个位置，j 正好是 B 能匹配 A 的以 i 为终点的最长字符串长度。\n也就是说，字符串 A 中，以 i−j+1 为起点的与 B 匹配的长度最小为 j\n但是，以 ii 为终点的，与 B 匹配的字符串只有 A[i−j+1∼i] 嘛？\n不一定，我们发现 A[i−next[j]+1∼i] 也是与 B 的前缀匹配的字符串\n同理，A[i−next[next[j]]+1∼i] 也是与 B 的前缀匹配的字符串...\n\n那么，我们在让 cnt[j] ++ 时，就还需要让 cnt[next[j]] ++，还需要让 cnt[next[next[j]]] ++...\n那我们匹配的时间复杂度就会退化为 O(NM) 了，显然是过不了这道题的。\n观察下我们操作 cnt[x] 的过程，每次都会让 cnt[next[x]] ++，也就是说，cnt[x] ++了多少次，cnt[next[x]] ++也就要相应的执行多少次。\n那么我们就可以先只操作 cnt[j] ++，最后从 m 到 1 循环枚举一遍 cnt[i]，让 cnt[next[i]] +&#x3D; cnt[i] 即可。\n注意最后 cnt[i] 存的是满足匹配的前缀至少为 x 的后缀数量，而题目中所要求的满足匹配的前缀恰好为 x 的答案的应为匹配的前缀至少为 x 的后缀数量 减去 匹配的前缀至少为 x + 1 的后缀数量，即 cnt[x] - cnt[x + 1]（后缀和思想），\n\n时间复杂度\n求 BB 的 nextnext 数组，时间复杂度为 O(M)\n将 AA 与 BB 做匹配，时间复杂度为 O(N)\n处理询问，时间复杂度为 O(Q)\n故总的时间复杂度为 O(N+M+Q)\nC++ 代码\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nconst int N &#x3D; 200005;\n\nint n, m, q;\nchar A[N], B[N];\nint ne[N], cnt[N];  &#x2F;&#x2F; ne 存 B 的 next 数组，cnt 即上述 cnt 数组\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d\\n&quot;, &amp;n, &amp;m, &amp;q);\n\tscanf(&quot;%s\\n%s&quot;, A + 1, B + 1);\n\n\tfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ ) &#x2F;&#x2F; KMP 模板\n\t&#123;\n\t\twhile (j &amp;&amp; B[i] !&#x3D; B[j + 1]) j &#x3D; ne[j];\n\t\tif (B[i] &#x3D;&#x3D; B[j + 1]) j ++ ;\n\t\tne[i] &#x3D; j;\n\t&#125;\n\n\tfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#x2F;&#x2F; 将 A 与 B 做匹配\n\t&#123;\n\t\twhile (j &amp;&amp; A[i] !&#x3D; B[j + 1]) j &#x3D; ne[j];\n\t\tif (A[i] &#x3D;&#x3D; B[j + 1]) j ++ ;\n\t\tcnt[j] ++ ;                       &#x2F;&#x2F; 先只将 cnt[j] ++ \n\t&#125;\n\tfor (int i &#x3D; m; i; i -- ) cnt[ne[i]] +&#x3D; cnt[i]; &#x2F;&#x2F; 从 m 到 1 枚举 cnt[i]，处理出所有的 cnt[next[i]]\n\n\twhile (q -- )\n\t&#123;\n\t\tint x;\n\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\tprintf(&quot;%d\\n&quot;, cnt[x] - cnt[x + 1]); &#x2F;&#x2F; 输出的结果应为 cnt[x] - cnt[x + 1]\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：垫底抽风\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;15841&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;kmp\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N &#x3D; 200010;\n\nint n, m, q;\nchar a[N], b[N];\nint nxt[N];\nint f[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n\tscanf(&quot;%s%s&quot;, a + 1, b + 1);\n\n\tfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\twhile (j &amp;&amp; b[i] !&#x3D; b[j + 1]) j &#x3D; nxt[j];\n\t\tif (b[i] &#x3D;&#x3D; b[j + 1]) j ++ ;\n\t\tnxt[i] &#x3D; j;\n\t&#125;\n\n\tfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\twhile (j &amp;&amp; a[i] !&#x3D; b[j + 1]) j &#x3D; nxt[j];\n\t\tif (a[i] &#x3D;&#x3D; b[j + 1]) j ++ ;\n\t\tf[j] ++ ;\n\t&#125;\n\n\tfor (int i &#x3D; m; i; i -- ) f[nxt[i]] +&#x3D; f[i];\n\n\twhile (q -- )\n\t&#123;\n\t\tint x;\n\t\tcin &gt;&gt; x;\n\t\tcout &lt;&lt; f[x] - f[x + 1] &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; 161 电话列表    29.58%  简单\n&#x2F;*\nTrie 非前缀码\ncur有前缀...：遍历路径中有str_end(leaf) \ncur是...的前缀：insert时没有新建node\n否则return true: has_new_node &amp;&amp; !has_found\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n;\nint son[N][10], idx;\nbool f[N];\n\nbool insert(char *str)\n&#123;\n\tint p &#x3D; 0;\n\tbool has_new_node &#x3D; false;\n\tbool has_found &#x3D; false;\n\tfor (int i &#x3D; 0; str[i]; i ++ )\n\t&#123;\n\t\tint u &#x3D; str[i] - &#39;0&#39;;\n\t\tif (!son[p][u])\n\t\t&#123;\n\t\t\tson[p][u] &#x3D; ++ idx;\n\t\t\thas_new_node &#x3D; true;\n\t\t&#125;\n\t\tp &#x3D; son[p][u];\n\t\tif (f[p]) has_found &#x3D; true;&#x2F;&#x2F;f[p]:遍历路径中有str_end\n\t&#125;\n\n\tf[p] &#x3D; true;&#x2F;&#x2F;!!!\n\n\treturn has_new_node &amp;&amp; !has_found;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile (T -- )\n\t&#123;\n\t\tcin &gt;&gt; n;\n\t\tmemset(son, 0, sizeof son);\n\t\tmemset(f, false, sizeof f);\n\t\tidx &#x3D; 0;\n\n\t\tbool res &#x3D; true;\n\n\t\tchar str[20];\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\t&#123;\n\t\t\tcin &gt;&gt; str;\n\t\t\tif (!insert(str)) res &#x3D; false;\n\t\t&#125;\n\n\t\tif (res) puts(&quot;YES&quot;);\n\t\telse puts(&quot;NO&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;hash做法\n# include &lt;iostream&gt;\n# include &lt;string&gt;\n# include &lt;unordered_set&gt;\n# include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int maxn &#x3D; 1e4 + 5, Hash &#x3D; 131;\nstring phone[maxn];\nULL h[maxn];\nunordered_set&lt;ULL&gt; F;\n\nbool check(string &amp;number)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; number.size(); i++) &#123;\n\t\th[i + 1] &#x3D; h[i] * Hash + number[i] - &#39;0&#39; + 1;  &#x2F;&#x2F; + 1 为了防止 012  与  12 这种情况\n\t\tif (i + 1 &#x3D;&#x3D; number.size() &amp;&amp; F.count(h[i + 1]))\n\t\t\treturn true;\n\t\tF.insert(h[i + 1]);\n\t&#125;\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin &gt;&gt; T;\n\twhile (T--) &#123;\n\t\tF.clear();\n\t\tint n;\n\t\tcin &gt;&gt; n;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tcin &gt;&gt; phone[i];\n\t\tsort(phone + 1, phone + n + 1);\n\t\tbool success &#x3D; true;\n\t\tfor (int i &#x3D; n; i; i--) &#123;\n\t\t\tif (check(phone[i])) &#123;\n\t\t\t\tsuccess &#x3D; false;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (success)\n\t\t\tcout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n\t\telse\n\t\t\tcout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：逆乾\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;1947&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n&#x2F;&#x2F; 162 黑盒子 66.97%  中等\n&#x2F;*\nfind第k大：对顶堆O(nlogn) -&gt;BFPRT:O(n)\noutput升序排序后的第i个数: 对顶堆algo\n保持L:1~i-1\nget i++: Ltop&lt;-Rtop\t\t\t\t\t输出小根堆顶A[i]:right.top\nadd(x): x&gt;&#x3D;A[i]时 toR\t\t\t\tx&lt;A[i] toL,Ltop-&gt;R\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 30010;\n\nint n, m;\nint a[N], b[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; a[i];&#x2F;&#x2F;元素按加入顺序排列\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) cin &gt;&gt; b[i];&#x2F;&#x2F;第i次GET操作时盒子内元素数\n\n\tpriority_queue&lt;int&gt; down;\n\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;\n\n\tint k &#x3D; 0;\n\tfor (int i &#x3D; 1, j &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t&#123;\n\t\twhile (j &lt;&#x3D; b[i])&#x2F;&#x2F;add\n\t\t&#123;\n\t\t\tif (down.empty() || a[j] &gt;&#x3D; down.top()) up.push(a[j]);\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tup.push(down.top());\n\t\t\t\tdown.pop();\n\t\t\t\tdown.push(a[j]);\n\t\t\t&#125;\n\t\t\tj ++ ;\n\t\t&#125;\n\t\t&#x2F;&#x2F;add j次 &#x3D;&#x3D; 盒子内元素数 时: get\n\t\tdown.push(up.top());\n\t\tup.pop();\n\t\tcout &lt;&lt; down.top() &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 163 生日礼物\n&#x2F;*\n首先，我们要使m段的和尽量大，首先需要选m段，并使得m段尽量都为整数。如果整数段数cnt≤m的话，那么我们全部选上即可，而如果cnt&gt;m 的话，那么我们则需要删除部分段，而对于删除我们则有下面两个操作可选：\n\n设k&#x3D;cnt−m\n而现在我们的问题可以转化为，使我们删除的k段尽量地小。\n\n1.删除1段整数\n2.合并j段整数与j−1段负数(+负 &#x3D;&#x3D; -|负|)\n而对于操作一来说相当于减去ai，对于操作二来说相当于减去|ai|。\n且我们选择的两段肯定不相连（如果选了两端相连的相当于选一段正一段负，一定不会是答案）。\n\n而到此这个问题可以转化为P3620 【[APIO&#x2F;CTSC 2007]数据备份】\n我们就可以通过数据备份这道题的做法去处理这个子问题。\n\n作者：wxy_\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;12794&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nint a[N], l[N], r[N];\nbool st[N];\n\nvoid remove(int p)\n&#123;\n\t&#x2F;&#x2F; 从链表中删去\n\tl[r[p]] &#x3D; l[p];\n\tr[l[p]] &#x3D; r[p];\n\n\t&#x2F;&#x2F; 从heap里删去\n\tst[p] &#x3D; true;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\n\tint k &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint x;\n\t\tcin &gt;&gt; x;\n\t\tif ((long long)a[k] * x &lt; 0) a[ ++ k] &#x3D; x;&#x2F;&#x2F;new一段\n\t\telse a[k] +&#x3D; x;\n\t&#125;\n\n\tn &#x3D; k;\n\t&#x2F;&#x2F;正段数 sum\n\tint cnt &#x3D; 0, res &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tif (a[i] &gt; 0)\n\t\t&#123;\n\t\t\tcnt ++ ;\n\t\t\tres +&#x3D; a[i];\n\t\t&#125;\n\n\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n\t&#x2F;&#x2F;建双链表\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tl[i] &#x3D; i - 1;\n\t\tr[i] &#x3D; i + 1;\n\n\t\theap.push(&#123;abs(a[i]), i&#125;); &#x2F;&#x2F; abs\n\t&#125;\n\n\twhile (cnt &gt; m)\n\t&#123;\n\t\twhile (st[heap.top().second]) heap.pop();\n\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\n\t\tint v &#x3D; t.first, p &#x3D; t.second; &#x2F;&#x2F; value pos\n\n\t\tif (l[p] !&#x3D; 0 &amp;&amp; r[p] !&#x3D; n + 1 || a[p] &gt; 0)\n\t\t&#123;\n\t\t\tcnt -- ;\n\t\t\tres -&#x3D; v;\n\t\t\t&#x2F;&#x2F; 3合1\n\t\t\tint left &#x3D; l[p], right &#x3D; r[p];\n\t\t\ta[p] +&#x3D; a[left] + a[right];\n\n\t\t\theap.push(&#123;abs(a[p]), p&#125;);\n\t\t\tremove(left);\n\t\t\tremove(right);\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;38861&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n0x20搜索&#x2F;&#x2F;可达性统计  topsort(BFS) + 状压bitset |\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;bitset&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 30010;\n\nint n, m;&#x2F;&#x2F; v e\nint h[N], e[N], ne[N], idx;\nint d[N], seq[N];&#x2F;&#x2F;入度 topo-seq\n\nbitset&lt;N&gt; f[N];&#x2F;&#x2F;f[i]:i的可达点!!!\n\nvoid add(int a, int b)\n&#123;\n\te[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid topsort()\n&#123;\n\tqueue&lt;int&gt; q;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tif(!d[i]) q.push(i);\n\t\n\tint k &#x3D; 0;\n\twhile(q.size())\n\t&#123;\n\t\tint t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tseq[k++] &#x3D; t;\n\t\tfor(int i &#x3D; h[t]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif(--d[j] &#x3D;&#x3D; 0) q.push(j);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\n\tmemset(h, -1, sizeof h);\n\tfor (int i &#x3D; 0; i &lt; m; i++)\n\t&#123;\n\t\tint a, b;\n\t\tcin &gt;&gt; a &gt;&gt; b;\n\t\tadd(a, b);\n\t\td[b] ++ ;\n\t&#125;\n\ttopsort();\n\n\tfor (int i &#x3D; n - 1; ~i; i--)\n\t&#123;\n\t\tint j &#x3D; seq[i];\n\t\tf[j][j] &#x3D; 1;&#x2F;&#x2F; f[x][i](f[x]第i位) &#x3D; 1 or 0: x--&gt;i是否可达\n\n\t\tfor(int p &#x3D; h[j]; ~p; p &#x3D; ne[p])\n\t\t\tf[j] |&#x3D; f[e[p]];&#x2F;&#x2F;!!!\n\t&#125;\n\t&#x2F;&#x2F;f[i].count返回有多少位为1\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; f[i].count() &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x22 DFS\n&#x2F;&#x2F;子集和问题\n\n&#x2F;&#x2F;全排列问题\n\n&#x2F;&#x2F;N皇后问题\n\n\n&#x2F;&#x2F;小猫爬山\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 20;\n\nint n, m;\nint cat[N], sum[N];\nint ans &#x3D; N;\n\nvoid dfs(int u, int k)&#x2F;&#x2F;u:cur cat, 已租用k车\n&#123;\n\tif(k &gt;&#x3D; ans) return;\n\tif(u &#x3D;&#x3D; n)\n\t&#123;\n\t\tans &#x3D; k;\n\t\treturn;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\tif(cat[u] + sum[i] &lt;&#x3D; m)\n\t\t&#123;\n\t\t\tsum[i] +&#x3D; cat[u];\n\t\t\tdfs(u + 1, k);\n\t\t\tsum[i] -&#x3D; cat[u];\n\t\t&#125;\n\tsum[k] &#x3D; cat[u];\n\tdfs(u + 1, k + 1);\n\tsum[k] &#x3D; 0;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 0;i &lt; n; i++) cin &gt;&gt; cat[i];\n\n\tsort(cat, cat + n);\n\treverse(cat, cat + n);\n\n\tdfs(0, 0);\n\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数独\n&#x2F;&#x2F; 递归函数不加inline!!!!!!!\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 9;\n\nint ones[1 &lt;&lt; N], map[1 &lt;&lt; N];\nint row[N], col[N], cell[3][3];\nchar str[100];\n\ninline int lowbit(int x)\n&#123;\n\treturn x &amp; -x;\n&#125;\n\nvoid init()\n&#123;\n\tfor(int i &#x3D; 0; i &lt; N; i++) row[i] &#x3D; col[i] &#x3D; (1 &lt;&lt; N) - 1;\n\tfor(int i &#x3D; 0; i &lt; 3; i++)\n\t\tfor(int j &#x3D; 0; j &lt; 3; j++)\n\t\t\tcell[i][j] &#x3D; (1 &lt;&lt; N) - 1;\n&#125;\n\ninline int get(int x, int y)\n&#123;\n\treturn row[x] &amp; col[y] &amp; cell[x &#x2F; 3][y &#x2F; 3];\n&#125;\n\nbool dfs(int cnt)\n&#123;\n\tif(!cnt) return true;\n\n\t&#x2F;&#x2F;找出可选方案数(可填数字)最少的空格\n\tint minv &#x3D; 10;\n\tint x, y;\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\tif(str[i * 9 + j] &#x3D;&#x3D; &#39;.&#39;)&#x2F;&#x2F;可填\n\t\t\t&#123;\n\t\t\t\tint t &#x3D; ones[get(i, j)];\n\t\t\t\tif(t &lt; minv)\n\t\t\t\t&#123;\n\t\t\t\t\tminv &#x3D; t;\n\t\t\t\t\tx &#x3D; i, y &#x3D; j;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\tfor(int i &#x3D; get(x, y); i; i -&#x3D; lowbit(i))\n\t&#123;\n\t\tint t &#x3D; map[lowbit(i)];\n\n\t\trow[x] -&#x3D; 1 &lt;&lt; t;\n\t\tcol[y] -&#x3D; 1 &lt;&lt; t;\n\t\tcell[x &#x2F; 3][y &#x2F; 3] -&#x3D; 1 &lt;&lt; t;\n\t\tstr[x * 9 + y] &#x3D; &#39;1&#39; + t;&#x2F;&#x2F;填上\n\t\t&#x2F;&#x2F;递归更新答案\n\t\tif(dfs(cnt - 1)) return true;&#x2F;&#x2F;cnt倒序\n\t\t&#x2F;&#x2F;行不通：回溯\n\t\trow[x] +&#x3D; 1 &lt;&lt; t;\n\t\tcol[y] +&#x3D; 1 &lt;&lt; t;\n\t\tcell[x &#x2F; 3][y &#x2F; 3] +&#x3D; 1 &lt;&lt; t;\n\t\tstr[x * 9 + y] &#x3D; &#39;.&#39;;&#x2F;&#x2F;还原\n\t&#125;\n\treturn false;\n&#125;\n\n\nint main()\n&#123;\n\t&#x2F;&#x2F;预处理\n\tfor(int i &#x3D; 0; i &lt; N; i++) map[1 &lt;&lt; i] &#x3D; i;\n\tfor(int i &#x3D; 0; i &lt; 1 &lt;&lt; N; i++) \n\t&#123;\n\t\tint s &#x3D; 0;\n\t\tfor (int j &#x3D; i; j; j -&#x3D; lowbit(j)) s++;\n\t\tones[i] &#x3D; s;&#x2F;&#x2F; i的二进制表示中有s个1\n\t&#125;\n\n\twhile(cin &gt;&gt; str, str[0] !&#x3D; &#39;e&#39;)\n\t&#123;\n\t\tinit();&#x2F;&#x2F;全1，筛掉不能填的 置0\n\n\t\tint cnt &#x3D; 0;\n\t\tfor (int i &#x3D; 0, k &#x3D; 0; i &lt; N; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt; N; j++, k++)\n\t\t\t\tif(str[k] !&#x3D; &#39;.&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tint t &#x3D; str[k] - &#39;1&#39;;\n\t\t\t\t\trow[i] -&#x3D; 1 &lt;&lt; t;\n\t\t\t\t\tcol[j] -&#x3D; 1 &lt;&lt; t;\n\t\t\t\t\tcell[i &#x2F; 3][j &#x2F; 3] -&#x3D; 1 &lt;&lt; t;\n\t\t\t\t&#125;\n\t\t\t\telse cnt++;\n\n\t\tdfs(cnt);&#x2F;&#x2F;cnt倒序\n\n\t\tcout &lt;&lt; str &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;剪枝\n&#x2F;&#x2F;木棒 yxc版\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 64;\n\nint n, sum, length;\nint sticks[N];\nbool st[N];&#x2F;&#x2F;visited\n\nbool dfs(int u, int cur, int start)&#x2F;&#x2F;第u根已长cur\n&#123;\n\tif(u * length &#x3D;&#x3D; sum) return true;\n\n\tif(cur &#x3D;&#x3D; length) return dfs(u + 1, 0, 0);\n\n\tfor(int i &#x3D; start; i &lt; n; i++)\n\t&#123;\n\t\tif(st[i]) continue;&#x2F;&#x2F;访问过\n\t\tint l &#x3D; sticks[i];\n\t\tif(cur + l &gt; length) continue;\n\n\t\tst[i] &#x3D; true;\n\t\tif(dfs(u, cur + l, i + 1)) return true;\n\t\tst[i] &#x3D; false;&#x2F;&#x2F;还原\n\n\t\t&#x2F;&#x2F; 剪枝3 如果是第一个木棒失败，则一定失败\n\t\tif(!cur) return false;\n\t\t&#x2F;&#x2F; 剪枝4 如果是最后一个木棒失败，则一定失败\n\t\tif(cur + l &#x3D;&#x3D; length) return false;\n\t\t&#x2F;&#x2F; 剪枝2 跳过相同木棒\n\t\tint j &#x3D; i;\n\t\twhile(j &lt; n &amp;&amp; sticks[j] &#x3D;&#x3D; l) j++;\n\t\ti &#x3D; j - 1;\n\t&#125;\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tsum &#x3D; 0, length &#x3D; 0;\n\t\tmemset(st, false, sizeof st);\n\t\t\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tcin &gt;&gt; sticks[i];\n\t\t\tif(sticks[i] &gt; 50) continue;\n\t\t\tsum +&#x3D; sticks[i];\n\t\t\tlength &#x3D; max(length, sticks[i]);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 剪枝：优化搜索顺序\n\t\tsort(sticks, sticks + n);\n\t\treverse(sticks, sticks + n);\n\t\t\n\t\t&#x2F;&#x2F; for(int i &#x3D; 0; i &lt; n; i++)\n\t\t&#x2F;&#x2F; \tif(sticks[i] &gt; 50) st[i] &#x3D; true;\n\t\t\n\t\twhile(true)&#x2F;&#x2F;!!!\n\t\t&#123;\n\t\t\tif(sum % length &#x3D;&#x3D; 0 &amp;&amp; dfs(0, 0, 0))\n\t\t\t&#123;\n\t\t\t\tcout &lt;&lt; length &lt;&lt; endl;\n\t\t\t\tbreak;&#x2F;&#x2F;!!!\n\t\t\t&#125;\n\t\t\tlength++;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;木棒\tAuthor:XuHt    \n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 70;&#x2F;&#x2F;大一点！！！\nint n, a[N], len, sum, val;\nbool v[N];\n\nbool dfs(int stick, int cab, int last) &#123;\n\tif (stick * len &gt; sum) return 1;\n\tif (cab &#x3D;&#x3D; len) return dfs(stick + 1, 0, 1);\n\tint fail &#x3D; 0;\n\tfor (int i &#x3D; last; i &lt;&#x3D; n; i++)&#x2F;&#x2F; 1\n\t\tif (!v[i] &amp;&amp; cab + a[i] &lt;&#x3D; len &amp;&amp; fail !&#x3D; a[i]) &#123;&#x2F;&#x2F; 2\n\t\t\tv[i] &#x3D; 1;\n\t\t\tif (dfs(stick, cab + a[i], i + 1)) return 1;\n\t\t\tfail &#x3D; a[i];\n\t\t\tv[i] &#x3D; 0;\n\t\t\tif (!cab || cab + a[i] &#x3D;&#x3D; len) return 0;&#x2F;&#x2F; 3 4\n\t\t&#125;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &amp;&amp; n) &#123;\n\t\tsum &#x3D; 0, val &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\t\tcin &gt;&gt; a[i];\n\t\t\tif(a[i] &gt; 50) continue;\n\t\t\tsum +&#x3D; a[i];\n\t\t\tval &#x3D; max(val, a[i]);\n\t\t\tv[i] &#x3D; 0;&#x2F;&#x2F;！！！\n\t\t&#125;\n\t\tsort(a + 1, a + n + 1);&#x2F;&#x2F; 0\n\t\treverse(a + 1, a + n + 1);\n\t\tfor (len &#x3D; val; len &lt;&#x3D; sum; len++) &#123;\n\t\t\tif (sum % len) continue;\n\t\t\t&#x2F;&#x2F; memset(v, 0, sizeof(v));&#x2F;&#x2F;循环内memset耗时!!!\n\t\t\tif (dfs(1, 0, 1)) break;\n\t\t&#125;\n\t\tcout &lt;&lt; len &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;生日蛋糕 yxc版\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 25, INF &#x3D; 1e9;\n\nint n, m;\nint R[N], H[N];\nint minv[N], mins[N];\nint ans &#x3D; INF;\n\nvoid dfs(int u, int v, int s)&#x2F;&#x2F;从下往上搜,上u层待定，已有v,s侧\n&#123;\n\t&#x2F;&#x2F;剪枝\n\tif(v + minv[u] &gt; n) return;&#x2F;&#x2F;已有+待定min\n\tif(s + mins[u] &gt;&#x3D; ans) return;\n\tif(s + 2 * (n - v) &#x2F; R[u + 1] &gt;&#x3D; ans) return;\n\n\tif(!u)\n\t&#123;\n\t\tif(n &#x3D;&#x3D; v) ans &#x3D; s;\n\t\treturn;\n\t&#125;\n\t&#x2F;&#x2F;range,倒序\n\tfor (int r &#x3D; min((int)sqrt(n - v), R[u + 1] - 1); r &gt;&#x3D; u; r--)\n\t\tfor (int h &#x3D; min((n - v) &#x2F; r &#x2F; r, H[u + 1] - 1); h &gt;&#x3D; u; h--)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; if(v + minv[u - 1] &gt; n) continue;&#x2F;&#x2F;FPE + 看不懂？？？\n\t\t\t&#x2F;&#x2F; if(s + mins[u - 1] &gt;&#x3D; ans) continue;\n\t\t\t&#x2F;&#x2F; if(s + 2 * (n - v) &#x2F; R[u] &gt;&#x3D; ans) continue;\n\n\t\t\tint t &#x3D; 0;\n\t\t\tif(u &#x3D;&#x3D;  m) t &#x3D; r * r;&#x2F;&#x2F;上表面积之和\n\t\t\tR[u] &#x3D; r, H[u] &#x3D; h;&#x2F;&#x2F;初始化R[u]、H[u]，用于定u-1层的rh-range!!!\n\t\t\tdfs(u - 1, v + r * r * h, s + 2 * r * h + t);\n\t\t\t&#x2F;&#x2F;v,h不变(不是+&#x3D;)，不用(-&#x3D;)还原现场!\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t&#123;\n\t\tminv[i] &#x3D; minv[i - 1] + i * i * i;&#x2F;&#x2F;rrh\n\t\tmins[i] &#x3D; mins[i - 1] + 2 * i * i;&#x2F;&#x2F;2rh\n\t&#125;\n\n\tR[m + 1] &#x3D; H[m + 1] &#x3D; INF;&#x2F;&#x2F;哨兵,求min()!!!!\n\tdfs(m, 0, 0);&#x2F;&#x2F;从下往上\n\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;书上标程 ？？？？？？？？？\n#include &lt;cmath&gt; \n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int INF &#x3D; 0x7fffffff;\nint n, m;\nint minv[30], mins[30], ans &#x3D; INF;\nint h[30], r[30], s &#x3D; 0, v &#x3D; 0;\n\nvoid dfs(int dep) &#123;\n\n\tif (v + minv[dep] &gt; n) return;\n\tif (s + mins[dep] &gt;&#x3D; ans) return;\n\tif (s + 2 * (n - v) &#x2F; r[dep+1] &gt;&#x3D; ans) return;\n\n\tif (!dep) &#123;\n\t\tif (v &#x3D;&#x3D; n) ans &#x3D; min(ans, s);\n\t\treturn;\n\t&#125;\n\n\tfor (r[dep] &#x3D; min((int)sqrt(n - v), r[dep + 1] - 1); r[dep] &gt;&#x3D; dep; r[dep]--)\n\t\tfor (h[dep] &#x3D; min((int)((double)(n-v) &#x2F; r[dep] &#x2F; r[dep]), h[dep+1] - 1); h[dep] &gt;&#x3D; dep; h[dep]--) \n\t\t&#123;   &#x2F;&#x2F;与循环外剪枝等效!!!\n\t\t\tif (v + minv[dep-1] &gt; n) continue;\n\t\t\t&#x2F;&#x2F;v&#x3D;&#x3D;(dep+1)~m层总体积,为什么+minv[dep-1]??????????\n\t\t\tif (s + mins[dep-1] &gt;&#x3D; ans) continue;\n\t\t\tif (s + 2 * (n - v) &#x2F; r[dep] &gt;&#x3D; ans) continue;\n\n\t\t\tif (dep &#x3D;&#x3D; m) s +&#x3D; r[dep] * r[dep];\n\t\t\ts +&#x3D; 2 * r[dep] * h[dep];\n\t\t\tv +&#x3D; r[dep] * r[dep] * h[dep];\n\t\t\tdfs(dep - 1); \n\t\t\tif (dep &#x3D;&#x3D; m) s -&#x3D; r[dep] * r[dep];\n\t\t\ts -&#x3D; 2 * r[dep] * h[dep];\n\t\t\tv -&#x3D; r[dep] * r[dep] * h[dep];\n\t\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tminv[0] &#x3D; mins[0] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tminv[i] &#x3D; minv[i-1] + i * i * i;\n\t\tmins[i] &#x3D; mins[i-1] + i * i;\n\t&#125;\n\th[m+1] &#x3D; r[m+1] &#x3D; INF;\n\tdfs(m);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数独2\n#include &lt;cstring&gt; \n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 16, M &#x3D; N * N + 1;\nint ones[1 &lt;&lt; N], log[1 &lt;&lt; N];\nint state[N][N];\nchar str[N][N + 1];\n\nint bstate[M][N][N], bstate2[M][N][N];&#x2F;&#x2F;M层搜索的备份\nchar bstr[M][N][N + 1];\n\ninline int lowbit(int x)\n&#123;\n\treturn x &amp; -x;\n&#125;\n\nvoid draw(int x, int y, int c)\n&#123;\n\tstr[x][y] &#x3D; c + &#39;A&#39;;&#x2F;&#x2F;填字母\n\t&#x2F;&#x2F;改状态\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t&#123;\n\t\tstate[x][i] &amp;&#x3D; ~(1 &lt;&lt; c);&#x2F;&#x2F;c位置0 ，或-&#x3D; (1 &lt;&lt; c)\n\t\tstate[i][y] &amp;&#x3D; ~(1 &lt;&lt; c);\n\t&#125;\n\n\tint sx &#x3D; x &#x2F; 4 * 4, sy &#x3D; y &#x2F; 4 * 4;\n\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t\tfor(int j &#x3D; 0; j &lt; 4; j++)\n\t\t\tstate[sx + i][sy + j] &amp;&#x3D; ~(1 &lt;&lt; c);\n\n\tstate[x][y] &#x3D; 1 &lt;&lt; c;&#x2F;&#x2F;!!!\n&#125;\n\nbool dfs(int cnt)\n&#123;\n\tif(!cnt) return true;\n\t&#x2F;&#x2F;备份\n\tint kcnt &#x3D; cnt;\n\tmemcpy(bstate[kcnt], state, sizeof state);\n\tmemcpy(bstr[kcnt], str, sizeof str);\n\n\t&#x2F;&#x2F;剪枝1:位置填字母\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\tif(str[i][j] &#x3D;&#x3D; &#39;-&#39;)\n\t\t\t&#123;\n\t\t\t\tint s &#x3D; state[i][j];\n\t\t\t\tif(!s)&#x2F;&#x2F;无字母可填：无解\n\t\t\t\t&#123;\n\t\t\t\t\tmemcpy(state, bstate[kcnt], sizeof state);\n\t\t\t\t\tmemcpy(str, bstr[kcnt], sizeof str);\n\t\t\t\t\treturn false;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;只能填一个字母：直接填\n\t\t\t\tif(ones[s] &#x3D;&#x3D; 1)\n\t\t\t\t&#123;\n\t\t\t\t\tdraw(i, j, log[s]);\n\t\t\t\t\tcnt--;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t&#x2F;&#x2F;剪枝2:字母的合法位置 每行\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t&#123;\n\t\tint sor &#x3D; 0, sand &#x3D; (1 &lt;&lt; N) - 1;\n\t\tint drawn &#x3D; 0;\n\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t&#123;\n\t\t\tint s &#x3D; state[i][j];\n\t\t\tsand &amp;&#x3D; ~(s &amp; sor);&#x2F;&#x2F;多于一处可填字母置0 \n\t\t\tsor |&#x3D; s; &#x2F;&#x2F; 该行能填字母的并集\n\n\t\t\tif(str[i][j] !&#x3D; &#39;-&#39;) drawn |&#x3D; state[i][j];&#x2F;&#x2F;该行drawn的字母\n\t\t&#125;\n\n\t\tif(sor !&#x3D; (1 &lt;&lt; N) - 1)&#x2F;&#x2F;(非全1)有字母不能填在该行\n\t\t&#123;\n\t\t\tmemcpy(state, bstate[kcnt], sizeof state);\n\t\t\tmemcpy(str, bstr[kcnt], sizeof str);\n\t\t\treturn false;\n\t\t&#125;\n\t\tfor(int j &#x3D; sand; j; j -&#x3D; lowbit(j))\n\t\t&#123;\n\t\t\tint t &#x3D; lowbit(j);\n\t\t\tif(!(drawn &amp; t))&#x2F;&#x2F;该字母没被drawn过\n\t\t\t&#123;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; N; k++)\n\t\t\t\t\tif(state[i][k] &amp; t)&#x2F;&#x2F;该位可填t\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tdraw(i, k, log[t]);\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;2 每列\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t&#123;\n\t\tint sor &#x3D; 0, sand &#x3D; (1 &lt;&lt; N) - 1;\n\t\tint drawn &#x3D; 0;\n\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t&#123;\n\t\t\tint s &#x3D; state[j][i];\n\t\t\tsand &amp;&#x3D; ~(s &amp; sor);&#x2F;&#x2F;多于一处可填字母置0 \n\t\t\tsor |&#x3D; s; &#x2F;&#x2F; 该行能填字母的并集\n\n\t\t\tif(str[j][i] !&#x3D; &#39;-&#39;) drawn |&#x3D; state[j][i];&#x2F;&#x2F;该列drawn的字母\n\t\t&#125;\n\n\t\tif(sor !&#x3D; (1 &lt;&lt; N) - 1)&#x2F;&#x2F;(非全1)有字母不能填在该行\n\t\t&#123;\n\t\t\tmemcpy(state, bstate[kcnt], sizeof state);\n\t\t\tmemcpy(str, bstr[kcnt], sizeof str);\n\t\t\treturn false;\n\t\t&#125;\n\t\tfor(int j &#x3D; sand; j; j -&#x3D; lowbit(j))\n\t\t&#123;\n\t\t\tint t &#x3D; lowbit(j);\n\t\t\tif(!(drawn &amp; t))&#x2F;&#x2F;该字母没被drawn过\n\t\t\t&#123;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; N; k++)\n\t\t\t\t\tif(state[k][i] &amp; t)&#x2F;&#x2F;该位可填t\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tdraw(k, i, log[t]);\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;2 每16宫格 [i][j]:第i(0~15)个16宫格的第j(0~15)格  \n\t&#x2F;&#x2F; state[sx + dx][sy + dy] 遍历的是每个4*4的16宫格做剪枝，与state[i][j]无映射关系，只是每行每列每16宫格遍历元素不同罢了。!!!!!!!\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t&#123;\n\t\tint sor &#x3D; 0, sand &#x3D; (1 &lt;&lt; N) - 1;\n\t\tint drawn &#x3D; 0;\n\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;[s0 4 8 12 + d0 1 2 3]   [大16&#x2F;][小16%]\n\t\t\tint sx &#x3D; i &#x2F; 4 * 4, sy &#x3D; i % 4 * 4;\n\t\t\tint dx &#x3D; j &#x2F; 4, dy &#x3D; j % 4;\n\t\t\tint s &#x3D; state[sx + dx][sy + dy];\n\t\t\tsand &amp;&#x3D; ~(s &amp; sor);&#x2F;&#x2F;多于一处可填字母置0 \n\t\t\tsor |&#x3D; s; &#x2F;&#x2F; 该行能填字母的并集\n\n\t\t\tif(str[sx + dx][sy + dy] !&#x3D; &#39;-&#39;) drawn |&#x3D; state[sx + dx][sy + dy];&#x2F;&#x2F;drawn的字母\n\t\t&#125;\n\n\t\tif(sor !&#x3D; (1 &lt;&lt; N) - 1)&#x2F;&#x2F;(非全1)有字母不能填在该行\n\t\t&#123;\n\t\t\tmemcpy(state, bstate[kcnt], sizeof state);\n\t\t\tmemcpy(str, bstr[kcnt], sizeof str);\n\t\t\treturn false;\n\t\t&#125;\n\t\tfor(int j &#x3D; sand; j; j -&#x3D; lowbit(j))\n\t\t&#123;\n\t\t\tint t &#x3D; lowbit(j);\n\t\t\tif(!(drawn &amp; t))&#x2F;&#x2F;该字母没被drawn过\n\t\t\t&#123;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; N; k++)\n\t\t\t\t&#123;\n\t\t\t\t\tint sx &#x3D; i &#x2F; 4 * 4, sy &#x3D; i % 4 * 4;\n\t\t\t\t\tint dx &#x3D; k &#x2F; 4, dy &#x3D; k % 4;\n\t\t\t\t\tif(state[sx + dx][sy + dy] &amp; t)&#x2F;&#x2F;该位可填t\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tdraw(sx + dx, sy + dy, log[t]);\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;剪枝0\n\tif(!cnt) return true;\n\n\tint x, y, s &#x3D; 100;\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\tif(str[i][j] &#x3D;&#x3D; &#39;-&#39; &amp;&amp; ones[state[i][j]] &lt; s)\n\t\t\t&#123;\n\t\t\t\ts &#x3D; ones[state[i][j]];\n\t\t\t\tx &#x3D; i, y &#x3D; j;\n\t\t\t&#125;\n\n\tmemcpy(bstate2[kcnt], state, sizeof state);\n\tfor(int i &#x3D; state[x][y]; i; i -&#x3D; lowbit(i))\n\t&#123;\n\t\tmemcpy(state, bstate2[kcnt], sizeof state);\n\t\tdraw(x, y, log[lowbit(i)]);\n\n\t\tif(dfs(cnt - 1)) return true;\n\t&#125;\n\t&#x2F;&#x2F;恢复现场\n\tmemcpy(state, bstate[kcnt], sizeof state);\n\tmemcpy(str, bstr[kcnt], sizeof str);\n\treturn false; \n&#125;\n\nint main()\n&#123;\n\tfor(int i &#x3D; 0; i &lt; N; i++) log[1 &lt;&lt; i] &#x3D; i;\n\tfor(int i &#x3D; 0; i &lt; 1 &lt;&lt; N; i++)\n\t\tfor(int j &#x3D; i; j; j -&#x3D; lowbit(j)) ones[i]++;\n\t\n\twhile(cin &gt;&gt; str[0])\n\t&#123;\n\t\tfor(int i &#x3D; 1; i &lt; N; i++) cin &gt;&gt; str[i];\n\n\t\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\t\tstate[i][j] &#x3D; (1 &lt;&lt; N) - 1;\n\n\t\tint cnt &#x3D; 0;\t&#x2F;&#x2F; 存储空格的个数\n\t\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\t\tif(str[i][j] !&#x3D; &#39;-&#39;)\n\t\t\t\t&#123;\n\t\t\t\t\tdraw(i, j, str[i][j] - &#39;A&#39;);\n\t\t\t\t&#125;\n\t\t\t\telse cnt++;\n\n\t\tdfs(cnt);\n\n\t\tfor(int i &#x3D; 0; i &lt; N; i++) cout &lt;&lt; str[i] &lt;&lt; endl;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;数独2 （Dancing Links版）待填坑。。。。。。。。。。。。\n\n&#x2F;&#x2F;0x24迭代加深DFS\n&#x2F;&#x2F;加成序列\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110;\n\nint n;\nint path[N];\n\nbool dfs(int u, int depth)\n&#123;\n\tif(u &#x3D;&#x3D; depth) return path[u - 1] &#x3D;&#x3D; n;\n\t&#x2F;&#x2F;判重\n\tbool st[N] &#x3D; &#123;false&#125;;\n\t&#x2F;&#x2F;从大到小枚举\n\tfor(int i &#x3D; u - 1; i &gt;&#x3D; 0; i--)\n\t\tfor(int j &#x3D; i; j &gt;&#x3D; 0; j--)&#x2F;&#x2F; 0 &lt;&#x3D; j &lt;&#x3D; i &lt;&#x3D; u - 1\n\t\t&#123;\n\t\t\tint s &#x3D; path[i] + path[j];\n\t\t\tif(s &gt;&#x3D; path[u - 1] &amp;&amp; s &lt;&#x3D; n &amp;&amp; !st[s])&#x2F;&#x2F;s递增\n\t\t\t&#123;\n\t\t\t\tst[s] &#x3D; true;\n\t\t\t\tpath[u] &#x3D; s;\n\t\t\t\tif(dfs(u + 1, depth)) return true;\n\t\t\t&#125;\n\t\t&#125;\n\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\twhile(cin &gt;&gt; n, n)\n\t&#123;\n\t\tint depth &#x3D; 1;\n\t\tpath[0] &#x3D; 1;\n\t\twhile(!dfs(1, depth)) depth++;&#x2F;&#x2F;cur_d max_d\n\n\t\tfor(int i &#x3D; 0; i &lt; depth; i++) cout &lt;&lt; path[i] &lt;&lt; &#39; &#39;;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;双向DFS\n&#x2F;&#x2F;送礼物\n&#x2F;*\n二分模板\n版本1 求min mid在左\n版本2 求max mid在右 +1原因:lr相邻时mid&#x3D;&#x3D;l(+1让mid&#x3D;&#x3D;r), l&#x3D;mid;即l&#x3D;l;死循环!!!\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N &#x3D; 45;\n\nint n, m, k;\nint g[N];\nint weights[1 &lt;&lt; 24], cnt;\nint ans;\n\nvoid dfs_1(int u, int s)\n&#123;\n\tif(u &#x3D;&#x3D; k)\n\t&#123;\n\t\tweights[cnt++] &#x3D; s;\n\t\treturn;\n\t&#125;\n\tif((LL)s + g[u] &lt;&#x3D; m) dfs_1(u + 1, s + g[u]);\n\tdfs_1(u + 1, s);\n&#125;\n\nvoid dfs_2(int u, int s)\n&#123;\n\tif(u &#x3D;&#x3D; n)&#x2F;&#x2F;二分模板 求max 版本2\n\t&#123;\n\t\tint l &#x3D; 0, r &#x3D; cnt - 1;\n\t\twhile(l &lt; r)\n\t\t&#123;\n\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;&#x2F;&#x2F;mid&#x3D;&#x3D;r\n\t\t\tif((LL)weights[mid] + s &lt;&#x3D; m) l &#x3D; mid;&#x2F;&#x2F;&lt;&#x3D;m的max  防溢出\n\t\t\telse r &#x3D; mid - 1;\n\t\t&#125;\n\t\tif((LL)weights[r] + s &lt;&#x3D; m) ans &#x3D; max(ans, weights[r] + s);&#x2F;&#x2F;+会溢出！！！\n\n\t\treturn;\n\t&#125;\n\n\tif((LL)s + g[u] &lt;&#x3D; m) dfs_2(u + 1, s + g[u]);\n\tdfs_2(u + 1, s);\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; m &gt;&gt; n;&#x2F;&#x2F;m:重量上限\n\tfor (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; g[i];\n\n\tsort(g, g + n);\n\treverse(g, g + n);\n\n\tk &#x3D; n &#x2F; 2 + 2;&#x2F;&#x2F;!!!!\n\tdfs_1(0, 0);&#x2F;&#x2F;cur sum\n\n\tsort(weights, weights + cnt);\n\tcnt &#x3D; unique(weights, weights + cnt) - weights;\n\n\tdfs_2(k, 0);\n\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x25 BFS\n&#x2F;&#x2F;立体推箱子 Bloxorz推木头 http:&#x2F;&#x2F;www.4399.com&#x2F;flash&#x2F;13071_1.htm\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 510;\n\nstruct State\n&#123;\n\tint x, y, lie;\n&#125;;\n\nint n, m;\nchar g[N][N];\nint dist[N][N][3];\n\nbool check(int x, int y)\n&#123;\n\tif(x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; m) return false;&#x2F;&#x2F;出界\n\treturn g[x][y] !&#x3D; &#39;#&#39;;\n&#125;\n\nint bfs(State start, State end)\n&#123;\n\tmemset(dist, -1, sizeof dist);\n\tdist[start.x][start.y][start.lie] &#x3D; 0;\n\tqueue&lt;State&gt; q;\n\tq.push(start);\n\t&#x2F;&#x2F;state012 direction上右下左 &#123;x,y,lie&#125;\n\tint d[3][4][3] &#x3D; &#123;\n\t\t&#123;&#123;-2, 0, 2&#125;, &#123;0, 1, 1&#125;, &#123;1, 0, 2&#125;, &#123;0, -2, 1&#125;&#125;,   &#x2F;&#x2F;0 立着\n\t\t&#123;&#123;-1, 0, 1&#125;, &#123;0, 2, 0&#125;, &#123;1, 0, 1&#125;, &#123;0, -1, 0&#125;&#125;,   &#x2F;&#x2F;1 横躺\n\t\t&#123;&#123;-1, 0, 0&#125;, &#123;0, 1, 2&#125;, &#123;2, 0, 0&#125;, &#123;0, -1, 2&#125;&#125;,   &#x2F;&#x2F;2 竖躺\n\t&#125;;\n\t\n\twhile(q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\t\t\n\t\t&#x2F;&#x2F;扩展t\n\t\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t\t&#123;\n\t\t\tState next &#x3D; &#123;t.x + d[t.lie][i][0], t.y + d[t.lie][i][1], d[t.lie][i][2]&#125;;&#x2F;&#x2F;!!!\n\t\t\t\n\t\t\tint x &#x3D; next.x, y &#x3D; next.y;\n\t\t\tif(!check(x, y)) continue;\n\t\t\t\n\t\t\tif(next.lie &#x3D;&#x3D; 0 &amp;&amp; g[x][y] &#x3D;&#x3D; &#39;E&#39;) continue;&#x2F;&#x2F;太重\n\t\t\tif(next.lie &#x3D;&#x3D; 1 &amp;&amp; !check(x, y + 1)) continue;&#x2F;&#x2F;出界 撞墙\n\t\t\tif(next.lie &#x3D;&#x3D; 2 &amp;&amp; !check(x + 1, y)) continue;\n\t\t\t\n\t\t\tif(dist[x][y][next.lie] &#x3D;&#x3D; -1)\n\t\t\t&#123;\n\t\t\t\tdist[x][y][next.lie] &#x3D; dist[t.x][t.y][t.lie] + 1;\n\t\t\t\tq.push(next);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;算出从st出发到所有能走的点的dist，只取dist[end]\n\treturn dist[end.x][end.y][end.lie];\n&#125;\n\nint main()\n&#123;\n\twhile(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)\n\t&#123;\n\t\tfor(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; g[i];\n\t\t\n\t\tState start &#x3D; &#123;-1&#125;, end;\n\t\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t\t\tfor(int j &#x3D; 0; j &lt; m; j++)\n\t\t\t\tif(g[i][j] &#x3D;&#x3D; &#39;X&#39; &amp;&amp; start.x &#x3D;&#x3D; -1)&#x2F;&#x2F;第一次遍历起点\n\t\t\t\t&#123;\n\t\t\t\t\tif(g[i][j + 1] &#x3D;&#x3D; &#39;X&#39;) start &#x3D; &#123;i, j, 1&#125;;\n\t\t\t\t\telse if(g[i + 1][j] &#x3D;&#x3D; &#39;X&#39;) start &#x3D; &#123;i, j, 2&#125;;\n\t\t\t\t\telse start &#x3D; &#123;i, j, 0&#125;;\n\t\t\t\t&#125;\n\t\t\t\telse if(g[i][j] &#x3D;&#x3D; &#39;O&#39;) end &#x3D; &#123;i, j, 0&#125;;\n\t\t\n\t\tint res &#x3D; bfs(start, end);\n\t\tif(res &#x3D;&#x3D; -1) puts(&quot;Impossible&quot;);\n\t\telse printf(&quot;%d\\n&quot;, res);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;矩阵距离\tBFS多源最短路 +虚拟远点&#x3D;dijkstra\t类似flood fill\n&#x2F;&#x2F;puts()函数用来向标准输出设备（屏幕）输出字符串并换行，具体为：把字符串输出到标准输出设备，将&#39;\\0&#39;转换为回车换行。\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 1010;\n\nint n, m;\nchar g[N][N];\nint d[N][N];\n\nint bfs()\n&#123;\n\tmemset(d, -1, sizeof d);\n\tqueue&lt;PII&gt; q;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; m; j++)\n\t\t\tif(g[i][j] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tq.push(&#123;i, j&#125;);\n\t\t\t\td[i][j] &#x3D; 0;\n\t\t\t&#125;\n\n\tint dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\twhile(q. size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\tfor (int i &#x3D; 0; i &lt; 4; i++)\n\t\t&#123;\n\t\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n\t\t\tif(a &gt;&#x3D; 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; d[a][b] &#x3D;&#x3D; -1)\n\t\t\t&#123;\n\t\t\t\td[a][b] &#x3D; d[x][y] + 1;\n\t\t\t\tq.push(&#123;a, b&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]);\n\n\tbfs();\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; m; j++)\n\t\t\tprintf(&quot;%d &quot;, d[i][j]);\n\t\tputs(&quot;&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;推箱子 S推B到T  yxc版\n&#x2F;*\n1.箱子移动次数最少\n2.人移动次数最少\n3.N、S、W、E的顺序优先选择箱子的移动方向（即先上下推，再左右推）\n4.按照n、s、w、e的顺序优先选择人的移动方向（即先上下动，再左右动）\n\n如果把箱子和人看做整体更新状态只能保证整体总步数最小，而题中首先要使箱子移动次数最小。\n\n首先假设有一只手可以直接推箱子，每个格子之间仍然可以看做是权值为1的两个点，整个矩阵就一个无向图，可以bfs求最短路（宽搜的本质是迪杰斯特拉算法）\n\n但是当箱子在某个点时，还要存储这个箱子是从哪个方向被推过来的，将箱子的位置和方向一起看做一个点，进行宽搜，再看人从上一个状态到这个状态最短路是多长，同样是宽搜。\n\n在箱子的队列中，步数单调增加，但是，在箱子的步数增加1时，按照题目给出的顺序，不同的加1路径对应的人增加的步数不一定是单调增加的。但只要根据队列中的元素依次扩展节点，每次扩展都更新人的步数即可\n\n一定要注意箱子和人的位置对方向的加减！注意状态的更新，不要漏记录某个值！\n*&#x2F;\n&#x2F;*\n如果按箱子移动次数来分层的话，这道题目本质上是求分层图的最短路。上面的代码会一层一层来做，从前一层推后一层的时候，会求出从前一层的每个起点出发，到达下一层每个终点的最短距离，因此这样求出的每层之间人走过的距离一定是最短的，但这只是一个局部最优解。然后我们发现每层之间的状态是完全独立的，因此当所有层都取到最小值的时候，得到的结果一定也是全局最优解。所以上面的代码可以在保证层数最少的情况下，人走过的步数也最少。\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 25;\n\nstruct Node\n&#123;\n\tint x, y, dir;\n&#125;;\n\nint n, m;\nchar g[N][N];   &#x2F;&#x2F; 存储游戏地图\nbool st[N][N][4], used[N][N];   &#x2F;&#x2F; BFS的判重数组，为了防止BFS遍历相同状态\nint dx[4] &#x3D; &#123;1, -1, 0, 0&#125;, dy[4] &#x3D; &#123;0, 0, 1, -1&#125;;  &#x2F;&#x2F;(-)依次表示下、上、右、左四个方向\nPII dist[N][N][4];  &#x2F;&#x2F;前缀！ dist[j][k][i]是表示【从初始状态】到达j,k,i状态所需要的箱子最短路程和人行走最短路程\nvector&lt;int&gt; path[N][N][4];  &#x2F;&#x2F; path[j][k][i] 表示人从推(j,k,i)的上一个状态的位置，走到推(j,k,i)这个状态的位置的行走路径\nNode pre[N][N][4];  &#x2F;&#x2F; 表示箱子在(x, y)，上一个格子在i(+)方向上的状态，即上一个状态是(x + dx[i], y + dy[i]) ---i---&gt;(x,y)\nint pre_man[N][N];  &#x2F;&#x2F;(-)dir!!! pre_man[x][y]表示人从哪个方向【(-)dir】走到(x, y)，如果pre_man[x][y] &#x3D; i(-), 那么上一个状态是(x - dx[i], y - dy[i]) -(-)(-)\n\nbool check(int x, int y)    &#x2F;&#x2F; 判断(x, y)是否在地图内，且是空地\n&#123;\n\treturn x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] !&#x3D; &#39;#&#39;;\n&#125;\n\n\n&#x2F;&#x2F; 求人从start走到end，中间不经过box的最短路径，行走序列保存在seq中(&amp;！！！)\nint bfs_man(PII start, PII end, PII box, vector&lt;int&gt; &amp;seq)\n&#123;\n\tmemset(used, false, sizeof used);\n\tmemset(pre_man, -1, sizeof pre_man);\n\n\tqueue&lt;PII&gt; q;&#x2F;&#x2F;从start扩展时临时记录&#123;x,y&#125;用的队列\n\tq.push(start);\n\tused[start.first][start.second] &#x3D; true;\n\tused[box.first][box.second] &#x3D; true;\n\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tif (t &#x3D;&#x3D; end)\n\t\t&#123;\n\t\t\tseq.clear();\n\t\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t\twhile (pre_man[x][y] !&#x3D; -1)\n\t\t\t&#123;\n\t\t\t\tint dir &#x3D; pre_man[x][y] ^ 1;&#x2F;&#x2F;(+)取反&#x3D;&#x3D;(-)\n\t\t\t\tseq.push_back(dir);&#x2F;&#x2F;seq倒序\n\t\t\t\tx +&#x3D; dx[dir], y +&#x3D; dy[dir];&#x2F;&#x2F;沿着seq回退(-)\n\t\t\t&#125;\n\n\t\t\treturn seq.size();\n\t\t&#125;\n\n\t\tfor (int ii &#x3D; 0; ii &lt; 4; ii ++ )&#x2F;&#x2F;0123\n\t\t&#123;\n\t\t\tint i &#x3D; ii ^ 1;&#x2F;&#x2F;1032\n\t\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];&#x2F;&#x2F;dy(-) i(-) dy[i](+):nswe (x,y)-ii-&gt;(a,b)\n\t\t\tif (check(a, b) &amp;&amp; !used[a][b])\n\t\t\t&#123;\n\t\t\t\tused[a][b] &#x3D; true;\n\t\t\t\tpre_man[a][b] &#x3D; i;\n\t\t\t\tq.push(&#123;a, b&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\treturn -1;\n&#125;\n\nbool bfs_box(PII man, PII box, Node &amp;end)\n&#123;\n\tmemset(st, false, sizeof st);\n\t&#x2F;&#x2F;初态init\n\tqueue&lt;Node&gt; q;\n\tfor (int i &#x3D; 0; i &lt; 4; i ++ )\n\t&#123;\n\t\tint x &#x3D; box.first, y &#x3D; box.second;&#x2F;&#x2F;人 箱子(ab)(x,y:box初值)-&gt;(xy)(jk)\n\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];&#x2F;&#x2F;dy(-)\n\t\tint j &#x3D; x - dx[i], k &#x3D; y - dy[i];\n\t\tvector&lt;int&gt; seq;\n\n\t\tif (check(a, b) &amp;&amp; check(j, k) &amp;&amp; bfs_man(man, &#123;a, b&#125;, box, seq) !&#x3D; -1)\n\t\t&#123;\n\t\t\tst[j][k][i] &#x3D; true;\n\t\t\tq.push(&#123;j, k, i&#125;);\n\t\t\tdist[j][k][i] &#x3D; &#123;1, seq.size()&#125;;&#x2F;&#x2F;初态前缀&#x3D;&#x3D;部分\n\t\t\tpath[j][k][i] &#x3D; seq;\n\t\t\tpre[j][k][i] &#x3D; &#123;x, y, -1&#125;;\n\t\t&#125;\n\t&#125;\n\n\tbool success &#x3D; false;\n\tPII man_d &#x3D; &#123;1e9, 1e9&#125;;\n\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\t\t&#x2F;&#x2F;处理终点\n\t\tif (g[t.x][t.y] &#x3D;&#x3D; &#39;T&#39;)\n\t\t&#123;\n\t\t\tsuccess &#x3D; true;\n\n\t\t\tif (dist[t.x][t.y][t.dir] &lt; man_d)\n\t\t\t&#123;\n\t\t\t\tman_d &#x3D; dist[t.x][t.y][t.dir];&#x2F;&#x2F;min_dist  为了找min_path(best_t)服务\n\t\t\t\tend &#x3D; t;&#x2F;&#x2F;取pos到end时多个t中的最佳Node状态best_t\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;扩展（记录前缀）\n\t\tfor (int i &#x3D; 0; i &lt; 4; i ++ )\n\t\t&#123;\n\t\t\tint a &#x3D; t.x + dx[i], b &#x3D; t.y + dy[i];&#x2F;&#x2F;人 箱子(ab)(t.x,t.y)-&gt;(t.x,t.y)(jk)\n\t\t\tint j &#x3D; t.x - dx[i], k &#x3D; t.y - dy[i];&#x2F;&#x2F;-(-(+))&#x3D;&#x3D;(+)\n\t\t\tif (check(a, b) &amp;&amp; check(j, k))\n\t\t\t&#123;\n\t\t\t\tvector&lt;int&gt; seq;\n\t\t\t\tauto &amp;p &#x3D; dist[j][k][i];\n\t\t\t\tint distance &#x3D; bfs_man(&#123;t.x + dx[t.dir], t.y + dy[t.dir]&#125;, &#123;a, b&#125;, &#123;t.x, t.y&#125;, seq);\n\t\t\t\tif (distance !&#x3D; -1)\n\t\t\t\t&#123;\n\t\t\t\t\tPII td &#x3D; &#123;dist[t.x][t.y][t.dir].first + 1, dist[t.x][t.y][t.dir].second + distance&#125;;\n\t\t\t\t\tif (!st[j][k][i])\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tst[j][k][i] &#x3D; true;\n\t\t\t\t\t\tq.push(&#123;j, k, i&#125;);\n\t\t\t\t\t\tp &#x3D; td;&#x2F;&#x2F;前缀\n\t\t\t\t\t\tpath[j][k][i] &#x3D; seq;&#x2F;&#x2F;部分\n\t\t\t\t\t\tpre[j][k][i] &#x3D; t;\n\t\t\t\t\t&#125;\n&#x2F;* 这里不是在比较推箱子的次数，而是在比较当推箱子次数相同时，人所走过的\n总距离。当第一次访问某个状态时只能保证推箱子次数最少，但并不能保证人的\n次数也最少。所以这条分支不能去掉。*&#x2F;\n\t\t\t\t\telse if (p &gt; td)&#x2F;&#x2F;更新min_man\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tp &#x3D; td;\n\t\t\t\t\t\tpath[j][k][i] &#x3D; seq;\n\t\t\t\t\t\tpre[j][k][i] &#x3D; t;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\treturn success;\n&#125;\n\nvoid output(Node end)\n&#123;\n\tchar ops[] &#x3D; &quot;nswe&quot;;\n\tstring res;\n\twhile (end.dir !&#x3D; -1)&#x2F;&#x2F;ops[dir]路径回溯\n\t&#123;\n\t\tres +&#x3D; ops[end.dir] - 32;&#x2F;&#x2F;NSWE\n\t\tfor (auto dir : path[end.x][end.y][end.dir]) res +&#x3D; ops[dir];&#x2F;&#x2F;path倒序串起来\n\t\tend &#x3D; pre[end.x][end.y][end.dir];\n\t&#125;\n\t\n\treverse(res.begin(), res.end());\n\tcout &lt;&lt; res &lt;&lt; endl;\n&#125;\n\nint main()\n&#123;\n\tint T &#x3D; 1;\n\twhile (cin &gt;&gt; n &gt;&gt; m, n || m)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];\n\n\t\tprintf(&quot;Maze #%d\\n&quot;, T ++ );\n\t\t&#x2F;&#x2F;定man box初值\n\t\tPII man, box;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\t\tfor (int j &#x3D; 0; j &lt; m; j ++ )\n\t\t\t\tif (g[i][j] &#x3D;&#x3D; &#39;S&#39;) man &#x3D; &#123;i, j&#125;;\n\t\t\t\telse if (g[i][j] &#x3D;&#x3D; &#39;B&#39;) box &#x3D; &#123;i, j&#125;;\n\n\t\tNode end;\n\n\t\tif (!bfs_box(man, box, end)) puts(&quot;Impossible.&quot;);\n\t\telse output(end);\n\t\tputs(&quot;&quot;);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;推箱子 蓝书标程版\t\t慢一倍\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 26, INF &#x3D; 0x3f3f3f3f;\nchar A[4] &#x3D; &#123;&#39;N&#39;,&#39;S&#39;,&#39;W&#39;,&#39;E&#39;&#125;;\nchar a[4] &#x3D; &#123;&#39;n&#39;,&#39;s&#39;,&#39;w&#39;,&#39;e&#39;&#125;;\nint r, c, num &#x3D; 0;\nint d[4][2]&#x3D; &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;&#x2F;&#x2F;NSWE\nchar s[N][N];&#x2F;&#x2F;地图\nstring tmp;\n\nstruct P &#123;\n\tint x, y, px, py;&#x2F;&#x2F;箱子x y, 人px py\n\tstring ans;&#x2F;&#x2F;移动方案\n&#125;;\n\nbool pd(int x, int y) &#123;\n\treturn x &gt; 0 &amp;&amp; x &lt;&#x3D; r &amp;&amp; y &gt; 0 &amp;&amp; y &lt;&#x3D; c &amp;&amp; s[x][y] !&#x3D; &#39;#&#39;;\n&#125;\n\nbool bfs2(P p1, P p2) &#123;\n\ttmp &#x3D; &quot;&quot;;\n\tP st;\n\tst.x &#x3D; p1.px, st.y &#x3D; p1.py;&#x2F;&#x2F;xy代替人pos移动 (不用管px py,只记录ans)\n\tst.ans &#x3D; &quot;&quot;;\n\tqueue&lt;P&gt; q;\n\tq.push(st);\n\tbool v[N][N];\n\tmemset(v, 0, sizeof(v));\n\twhile (q.size()) &#123;\n\t\tP now &#x3D; q.front(), nxt;\n\t\tq.pop();\n\t\tif (now.x &#x3D;&#x3D; p1.x &amp;&amp; now.y &#x3D;&#x3D; p1.y) &#123;&#x2F;&#x2F;人走到p1虚拟箱子处（终点）\n\t\t\ttmp &#x3D; now.ans;\n\t\t\treturn 1;\n\t\t&#125;\n\t\tfor (int i &#x3D; 0; i &lt; 4; i++) &#123;\n\t\t\tnxt &#x3D; now;\n\t\t\tnxt.x &#x3D; now.x + d[i][0];\n\t\t\tnxt.y &#x3D; now.y + d[i][1];\n\t\t\tif (!pd(nxt.x, nxt.y)) continue;\n\t\t\tif (v[nxt.x][nxt.y]) continue;\n\t\t\tif (nxt.x &#x3D;&#x3D; p2.x &amp;&amp; nxt.y &#x3D;&#x3D; p2.y) continue;&#x2F;&#x2F;不能经过箱子\n\t\t\tv[nxt.x][nxt.y] &#x3D; 1;\n\t\t\tnxt.ans &#x3D; now.ans + a[i];&#x2F;&#x2F;人走1步\n\t\t\tq.push(nxt);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nstring bfs1() &#123;\n\tP st;\n\tst.x &#x3D; st.y &#x3D; st.px &#x3D; st.py &#x3D; -1;\n\tst.ans &#x3D; &quot;&quot;;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; r &amp;&amp; (st.x &#x3D;&#x3D; -1 || st.px &#x3D;&#x3D; -1); i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; c &amp;&amp; (st.x &#x3D;&#x3D; -1 || st.px &#x3D;&#x3D; -1); j++)\n\t\t\tif (s[i][j] &#x3D;&#x3D; &#39;B&#39;) &#123;\n\t\t\t\tst.x &#x3D; i, st.y &#x3D; j;\n\t\t\t\ts[i][j] &#x3D; &#39;.&#39;;\n\t\t\t&#125; else if (s[i][j] &#x3D;&#x3D; &#39;S&#39;) &#123;\n\t\t\t\tst.px &#x3D; i, st.py &#x3D; j;\n\t\t\t\ts[i][j] &#x3D; &#39;.&#39;;&#x2F;&#x2F;\n\t\t\t&#125;\n\tqueue&lt;P&gt; q;\n\tq.push(st);\n\tbool v[N][N][4];&#x2F;&#x2F;visited\n\tmemset(v, 0, sizeof(v));\n\tstring ans &#x3D; &quot;Impossible.&quot;;\n\tunsigned int cntans &#x3D; INF, cnt &#x3D; INF;&#x2F;&#x2F;箱子长，总长\n\twhile (q.size()) &#123;\n\t\tP prv, now &#x3D; q.front(), nxt;\n\t\tq.pop();\n\t\t&#x2F;&#x2F;处理终点\n\t\tif (s[now.x][now.y] &#x3D;&#x3D; &#39;T&#39;) &#123;\n\t\t\tunsigned int cntnow &#x3D; 0;\n\t\t\tfor (unsigned int i &#x3D; 0; i &lt; now.ans.length(); i++)\n\t\t\t\tif (now.ans[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; now.ans[i] &lt;&#x3D; &#39;Z&#39;) ++cntnow;&#x2F;&#x2F;箱子动\n\t\t\tif (cntnow &lt; cntans || (cntnow &#x3D;&#x3D; cntans &amp;&amp; now.ans.length() &lt; cnt)) &#123;&#x2F;&#x2F;保持步数二元组(step_box:cntans, step_man:cnt)单调性！！\n\t\t\t\tans &#x3D; now.ans;&#x2F;&#x2F;总seq\n\t\t\t\tcntans &#x3D; cntnow;&#x2F;&#x2F;箱子长\n\t\t\t\tcnt &#x3D; now.ans.length();&#x2F;&#x2F;总长\n\t\t\t&#125;\n\t\t\tcontinue;\n\t\t&#125;\n\t\t&#x2F;&#x2F;扩展\n\t\tfor (int i &#x3D; 0; i &lt; 4; i++) &#123;\n\t\t\tnxt &#x3D; now;&#x2F;&#x2F;nxt人覆盖\n\t\t\tnxt.x &#x3D; now.x + d[i][0];&#x2F;&#x2F;箱子变\n\t\t\tnxt.y &#x3D; now.y + d[i][1];\n\t\t\tif (!pd(nxt.x, nxt.y)) continue;&#x2F;&#x2F;位置无效\n\t\t\tif (v[nxt.x][nxt.y][i]) continue;&#x2F;&#x2F;访问过\n\t\t\t\n\t\t\tprv &#x3D; now;\n\t\t\tprv.x &#x3D; now.x - d[i][0];&#x2F;&#x2F;箱子虚拟移动到bfs2人的终点\n\t\t\tprv.y &#x3D; now.y - d[i][1];\n\t\t\tif (!bfs2(prv, now)) continue;\n\t\t\tv[nxt.x][nxt.y][i] &#x3D; 1;\n\t\t\tnxt.ans &#x3D; now.ans + tmp;&#x2F;&#x2F;前缀+bfs2_seq(记录量较大)\n\t\t\tnxt.ans +&#x3D; A[i];&#x2F;&#x2F;箱推1\n\t\t\tnxt.px &#x3D; now.x;&#x2F;&#x2F;人变\n\t\t\tnxt.py &#x3D; now.y;\n\t\t\tq.push(nxt);\n\t\t&#125;\n\t&#125;\n\treturn ans;&#x2F;&#x2F;总seq\n&#125;\n\nvoid Pushing_Boxes() &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; r; i++) cin &gt;&gt; (s[i] + 1);\n\tcout &lt;&lt; &quot;Maze #&quot; &lt;&lt; ++num &lt;&lt; endl &lt;&lt; bfs1() &lt;&lt; endl &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; r &gt;&gt; c, r || c) Pushing_Boxes();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x26 BFS变形\n&#x2F;&#x2F;双端队列BFS\n&#x2F;&#x2F;电路维修\n&#x2F;* \n题目中给定的方格是 n*m 的，所以格点共有 (n+1)*(m+1) 个。\n左上角格点编号是 (0,0)，右下角格点编号是 (n,m)。！！！！！！！\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\nconst int N &#x3D; 510;\n\nint n, m;\nchar g[N][N];\nint d[N][N];\nbool st[N][N];\n\nint bfs()\n&#123;\n\tmemset(st, 0, sizeof st);\n\tmemset(d, 0x3f, sizeof d);\n\t\n\tdeque&lt;PII&gt; dq;\n\tdq.push_back(&#123;0, 0&#125;);\n\td[0][0] &#x3D; 0;\n\t&#x2F;&#x2F; d:4角格点  i:4周方格编号(左上角)\n\tint dx[4] &#x3D; &#123;-1, -1, 1, 1&#125;, dy[4] &#x3D; &#123;-1, 1, 1, -1&#125;;\n\tint ix[4] &#x3D; &#123;-1, -1, 0, 0&#125;, iy[4] &#x3D; &#123;-1, 0, 0, -1&#125;;\n\tchar cs[] &#x3D; &quot;\\\\&#x2F;\\\\&#x2F;&quot;;\n\n\twhile(dq.size())\n\t&#123;\n\t\tauto t &#x3D; dq.front();\n\t\tdq.pop_front();\n\n\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t&#x2F;&#x2F; 每个点虽然可能入队多次，但第一次出来的时候就已经取到最小值了（dijkstra算法的性质），因此后面重复出队的点应该直接忽略。\n\t\tif (st[x][y]) continue;\n\t\tst[x][y] &#x3D; true;\n\t\t\n\t\tfor (int i &#x3D; 0; i &lt; 4; i++)\n\t\t&#123;\n\t\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n\t\t\tint j &#x3D; x + ix[i], k &#x3D; y + iy[i];\n\t\t\tif(a &gt;&#x3D; 0 &amp;&amp; a &lt;&#x3D; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt;&#x3D; m)\n\t\t\t&#123;\n\t\t\t\tint w &#x3D; 0;\n\t\t\t\tif(g[j][k] !&#x3D; cs[i]) w &#x3D; 1;&#x2F;&#x2F;格点与t(x,y)不连通\n\t\t\t\tif(d[a][b] &gt; d[x][y] + w)&#x2F;&#x2F;d(00-&gt;xy-&gt;ab) &lt; d(00-&gt;ab)\n\t\t\t\t&#123;\n\t\t\t\t\td[a][b] &#x3D; d[x][y] + w;&#x2F;&#x2F;更新d(ab)\n\t\t\t\t\tif (w) dq.push_back(&#123;a, b&#125;);&#x2F;&#x2F;1入队尾\n\t\t\t\t\telse dq.push_front(&#123;a, b&#125;);&#x2F;&#x2F;0入队头\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif(d[n][m] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n\treturn d[n][m];\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]);\n\n\t\tint t &#x3D; bfs();\n\t\tif(t &#x3D;&#x3D; -1) puts(&quot;NO SOLUTION&quot;);\n\t\telse printf(&quot;%d\\n&quot;, t);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;优先队列BFS(Dijkstra)\n&#x2F;&#x2F;装满的油箱\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010, M &#x3D; 20010, C &#x3D; 1010;\n\nint n, m;\nint h[N], e[M], w[M], ne[M], idx;&#x2F;&#x2F;w:edge_cost\nint price[N];\nint dist[N][C];&#x2F;&#x2F;从&#123;start,0&#125;到 &#123;N点，油剩余c&#125; 的最少money花费\nint st[N][C];\n\n\nstruct Ver\n&#123;\n\tint d, u, c;&#x2F;&#x2F;dist cur_city contains_oil\n\tbool operator &lt; (const Ver &amp;W) const\n\t&#123;\n\t\treturn d &gt; W.d;\n\t&#125;\n&#125;;\n\nvoid add(int a, int b, int c)\n&#123;\n\te[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;\n&#125;\n\nint dijkstra(int c, int start, int end)&#x2F;&#x2F;容量c s-&gt;e\n&#123;\n\tpriority_queue&lt;Ver&gt; heap;&#x2F;&#x2F;小根堆\n\tmemset(dist, 0x3f, sizeof dist);&#x2F;&#x2F;dist&#x3D;正无穷\n\tmemset(st, false, sizeof st);\n\theap.push(&#123;0, start, 0&#125;);&#x2F;&#x2F;d[start] &#x3D; 0;\n\n\twhile(heap.size())\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\n\t\tif(t.u &#x3D;&#x3D; end) return t.d;\n\t\t\n\t\tif(st[t.u][t.c]) continue;\n\t\tst[t.u][t.c] &#x3D; true;&#x2F;&#x2F;cur_city contains_oil\n\t\t&#x2F;&#x2F;1. oil+1\n\t\tif(t.c &lt; c)&#x2F;&#x2F;duc:dist cur_city contains_oil\n\t\t&#123;\n\t\t\tif(dist[t.u][t.c + 1] &gt; t.d + price[t.u])\n\t\t\t&#123;\n\t\t\t\tdist[t.u][t.c + 1] &#x3D; t.d + price[t.u];&#x2F;&#x2F;花钱price[t.u]\n\t\t\t\theap.push(&#123;dist[t.u][t.c + 1], t.u, t.c + 1&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;2. 遍历邻边\n\t\tfor(int i &#x3D; h[t.u]; ~i; i &#x3D; ne[i])&#x2F;&#x2F;~i &#x3D;&#x3D; i&gt;&#x3D;0, -1:全1 ~:全0\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif(t.c &gt;&#x3D; w[i])\n\t\t\t&#123;\n\t\t\t\tif(dist[j][t.c - w[i]] &gt; t.d)\n\t\t\t\t&#123;\n\t\t\t\t\tdist[j][t.c - w[i]] &#x3D; t.d;&#x2F;&#x2F;不花钱 耗油可到,直接用d更新\n\t\t\t\t\theap.push(&#123;t.d, j, t.c - w[i]&#125;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;price[i]);&#x2F;&#x2F;城市油价\n\tmemset(h, -1, sizeof h);\n\twhile(m--)\n\t&#123;\n\t\tint a, b, c;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n\t\tadd(a, b, c), add(b, a, c);&#x2F;&#x2F;a-&gt;b cost\n\t&#125;\n\n\tint query;\n\tscanf(&quot;%d&quot;, &amp;query);\n\twhile(query--)\n\t&#123;\n\t\tint c, s, e;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;c, &amp;s, &amp;e);&#x2F;&#x2F;容量c s-&gt;e\n\t\tint t &#x3D; dijkstra(c, s, e);\n\t\tif(t &#x3D;&#x3D; -1) puts(&quot;impossible&quot;);\n\t\telse printf(&quot;%d\\n&quot;, t);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;双向BFS  2d-&gt;1d\n&#x2F;&#x2F;噩梦\n&#x2F;&#x2F; 每一秒鬼会先扩展，扩展完毕后男孩和女孩才可以移动。\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 810;\n\nint n, m;\nchar g[N][N];\nint st[N][N];\nPII ghost[2], boy, girl;\n\nbool check(int x, int y, int step)\n&#123;\n\tif(x &lt; 0 || x &gt;&#x3D;n || y &lt; 0 || y &gt;&#x3D;m || g[x][y] &#x3D;&#x3D; &#39;X&#39;) return false;\n\tfor (int i &#x3D; 0; i &lt; 2; i++)\n\t\tif(abs(x - ghost[i].first) + abs(y - ghost[i].second) &lt;&#x3D; step * 2) return false;\n\treturn true;\n&#125;\n\nint bfs()\n&#123;\n\tint dx[] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n\tint cnt &#x3D; 0;\n\tmemset(st, 0, sizeof st);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; m; j++)\n\t\t\tif(g[i][j] &#x3D;&#x3D; &#39;M&#39;) boy &#x3D; &#123;i, j&#125;;\n\t\t\telse if(g[i][j] &#x3D;&#x3D; &#39;G&#39;) girl &#x3D; &#123;i, j&#125;;\n\t\t\telse if(g[i][j] &#x3D;&#x3D; &#39;Z&#39;) ghost[cnt++] &#x3D; &#123;i, j&#125;;\n\t\n\tint step &#x3D; 0;&#x2F;&#x2F;秒数\n\tqueue&lt;PII&gt; qb, qg;\n\tqb.push(boy), qg.push(girl);\n\twhile(qb.size() || qg.size())\n\t&#123;\n\t\tstep ++;\n\t\t&#x2F;&#x2F;男走3\n\t\tfor (int i &#x3D; 0; i &lt; 3; i++)\n\t\t\tfor (int j &#x3D; 0, len &#x3D; qb.size(); j &lt; len; j++)\n\t\t\t&#123;\n\t\t\t\tauto t &#x3D; qb.top();\n\t\t\t\tqb.pop();\n\t\t\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t\t\tif(!check(x, y, step)) continue;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; 4; k++)\n\t\t\t\t&#123;\n\t\t\t\t\tint a &#x3D; x + dx[k], b &#x3D; y + dy[k];\n\t\t\t\t\tif(check(a, b, step))\n\t\t\t\t\t&#123;&#x2F;&#x2F;st&#x3D;0没走过 1男走过 2女走过\n\t\t\t\t\t\tif(st[a][b] &#x3D;&#x3D; 2) return step;\n\t\t\t\t\t\tif(!st[a][b])\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tst[a][b] &#x3D; 1;\n\t\t\t\t\t\t\tqb.push(&#123;a, b&#125;);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#x2F;&#x2F;女走1\n\t\tfor (int i &#x3D; 0; i &lt; 1; i++)\n\t\t\tfor (int j &#x3D; 0, len &#x3D; qg.size(); j &lt; len; j++)\n\t\t\t&#123;\n\t\t\t\tauto t &#x3D; qg.top();\n\t\t\t\tqg.pop();\n\t\t\t\tint x &#x3D; t.first, y &#x3D; t.second;\n\t\t\t\tif(!check(x, y, step)) continue;\n\t\t\t\tfor(int k &#x3D; 0; k &lt; 4; k++)\n\t\t\t\t&#123;\n\t\t\t\t\tint a &#x3D; x + dx[k], b &#x3D; y + dy[k];\n\t\t\t\t\tif(check(a, b, step))\n\t\t\t\t\t&#123;&#x2F;&#x2F;st&#x3D;0没走过 1男走过 2女走过\n\t\t\t\t\t\tif(st[a][b] &#x3D;&#x3D; 1) return step;\n\t\t\t\t\t\tif(!st[a][b])\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tst[a][b] &#x3D; 2;\n\t\t\t\t\t\t\tqg.push(&#123;a, b&#125;);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\t\tfor(int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%s&quot;, g[i]);\n\t\tprintf(&quot;%d\\n&quot;, bfs());\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;auto C++11语法!!!!!!\n\n\n&#x2F;&#x2F;0x27 A* 最短路，边权非负(优先队列BFS + 估价(启发heuristic)函数)\n&#x2F;&#x2F;第k短路\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\ntypedef pair&lt;int, PII&gt; PIII;\n\nconst int N &#x3D; 1010, M &#x3D; 200010;\n\nint n, m;\nint h[N], rh[N], e[M], w[M], ne[M], idx;&#x2F;&#x2F;正反head\nint dist[N], f[N], st[N];&#x2F;&#x2F;st:出队次数\nint S, T, K;&#x2F;&#x2F;S-&gt;T K短\n\nvoid add(int *h, int a, int b, int c)\n&#123;\n\te[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;\n&#125;\n\nint dijkstra()\n&#123;\n\tpriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n\tmemset(dist, 0x3f, sizeof dist);\n\tdist[T] &#x3D; 0;\n\theap.push(&#123;0, T&#125;);\n\n\twhile(heap.size())\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\t\t\n\t\tint ver &#x3D; t.second;&#x2F;&#x2F;&#123;dist[t], t&#125;\n\t\tif(st[ver]) continue;\n\t\tst[ver] &#x3D; 1;\n\n\t\tfor (int i &#x3D; rh[ver]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif(dist[j] &gt; dist[ver] + w[i])\n\t\t\t&#123;\n\t\t\t\tdist[j] &#x3D; dist[ver] + w[i];\n\t\t\t\theap.push(&#123;dist[j], j&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tmemcpy(f, dist, sizeof f);&#x2F;&#x2F;f:估价函数\n&#125;\n\nint a_star()\n&#123;\n\tpriority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap;\n\theap.push(&#123;f[S], &#123;0, S&#125;&#125;);&#x2F;&#x2F; f[i],&#123;dist[i],i&#125;\n\tmemset(st, 0, sizeof st);\n\n\twhile(heap.size())\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\n\t\tint ver &#x3D; t.second.second, distance &#x3D; t.second.first;\n\t\tif(st[ver] &gt;&#x3D; K) continue; &#x2F;&#x2F;优化!!!\n\t\tst[ver]++;\n\t\tif(ver &#x3D;&#x3D; T &amp;&amp; st[ver] &#x3D;&#x3D; K) return distance;\n\n\t\tfor (int i &#x3D; h[ver]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif(st[j] &lt; K)\n\t\t\t\theap.push(&#123;distance + w[i] + f[j], &#123;distance + w[i], j&#125;&#125;);\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tmemset(h, -1, sizeof h);\n\tmemset(rh, -1, sizeof rh);\n\twhile(m--)\n\t&#123;\n\t\tint a, b, c;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n\t\tadd(h, a, b, c), add(rh, b, a, c);\n\t&#125;\n\tscanf(&quot;%d%d%d&quot;, &amp;S, &amp;T, &amp;K);\n\tif(S &#x3D;&#x3D; T) K++;&#x2F;&#x2F; 每条最短路中至少要包含一条边。\n\n\tdijkstra();\n\n\tprintf(&quot;%d\\n&quot;, a_star());\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;八数码  prev: 记录+逆推\tpriority_queue不改元素:st\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010, M &#x3D; 200010;\n\nint f(string state)\n&#123;\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; state.size(); i++)\n\t\tif(state[i] !&#x3D; &#39;x&#39;)\n\t\t&#123;\n\t\t\tint t &#x3D; state[i] - &#39;1&#39;;\n\t\t\tres +&#x3D; abs(i &#x2F; 3 - t &#x2F; 3) + abs(i % 3 - t % 3);&#x2F;&#x2F;真实-cur dx+dy\n\t\t&#125;\n\treturn res;\n&#125;\nstring bfs(string start)\n&#123;\n\tint dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\tchar op[4] &#x3D; &#123;&#39;u&#39;, &#39;r&#39;, &#39;d&#39;, &#39;l&#39;&#125;;\n\n\tstring end &#x3D; &quot;12345678x&quot;;\n\tunordered_map&lt;string, int&gt; dist;\n\tunordered_map&lt;string, bool&gt; st;\n\tunordered_map&lt;string, pair&lt;string, char&gt;&gt; prev;&#x2F;&#x2F;prev_state, to_now_op\n\tpriority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; heap;\n\n\theap.push(&#123;f(start), start&#125;);\n\tdist[start] &#x3D; 0;\n\n\twhile(heap.size())\n\t&#123;\n\t\tauto t &#x3D; heap.top();\n\t\theap.pop();\n\n\t\tstring state &#x3D; t.second;\n\t\tif(state &#x3D;&#x3D; end) break;&#x2F;&#x2F;!!!\n\t\t\n\t\tif(st[state]) continue;\n\t\tst[state] &#x3D; true;\n\n\t\tint step &#x3D; dist[state];\n\t\tint x, y;\n\t\tfor (int i &#x3D; 0; i &lt; state.size(); i++)\n\t\t\tif(state[i] &#x3D;&#x3D; &#39;x&#39;)\n\t\t\t&#123;\n\t\t\t\tx &#x3D; i &#x2F; 3, y &#x3D; i % 3;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\n\t\tstring source &#x3D; state;\n\t\tfor(int i &#x3D; 0; i &lt; 4; i++)\n\t\t&#123;\n\t\t\tint a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n\t\t\tif(a &gt;&#x3D; 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; 3)\n\t\t\t&#123;\n\t\t\t\tswap(state[x * 3 + y], state[a * 3 + b]);&#x2F;&#x2F;备份\n\t\t\t\tif(!dist.count(state) || dist[state] &gt; step + 1)\n\t\t\t\t&#123;&#x2F;&#x2F;走一步\n\t\t\t\t\tdist[state] &#x3D; step + 1;&#x2F;&#x2F;Dijkstra\n\t\t\t\t\tprev[state] &#x3D; &#123;source, op[i]&#125;;\n\t\t\t\t\theap.push(&#123;dist[state] + f(state), state&#125;);\n\t\t\t\t&#125;\n\t\t\t\tswap(state[x * 3 + y], state[a * 3 + b]);&#x2F;&#x2F;还原\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tstring res;\n\twhile(end !&#x3D; start)\n\t&#123;\n\t\tres +&#x3D; prev[end].second;&#x2F;&#x2F;op\n\t\tend &#x3D; prev[end].first;&#x2F;&#x2F;prev\n\t&#125;\n\treverse(res.begin(), res.end());\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tstring g, c, seq;\n\twhile(cin &gt;&gt; c)\n\t&#123;\n\t\tg +&#x3D; c;\n\t\tif(c !&#x3D; &quot;x&quot;) seq +&#x3D; c;\n\t&#125;\n\n\tint t &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; seq.size(); i++)\n\t\tfor (int j &#x3D; i + 1; j &lt; seq.size(); j++)\n\t\t\tif(seq[i] &gt; seq[j])\n\t\t\t\tt++;\n\tif(t &amp; 1) puts(&quot;unsolvable&quot;);\n\telse cout &lt;&lt; bfs(g) &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x28 IDA* (迭代加深DFS + 估价函数)\n&#x2F;*\nID-DFS基本框架:\ndepth &#x3D; 0;\nwhile(!dfs(0, depth)) depth++;\nIDA*:\nif(now_depth + f() &gt; max_depth) return false;\n*&#x2F;\n&#x2F;&#x2F;排书\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 15;\n\nint n;\nint q[N];\nint w[5][N];\n\nint f()\n&#123;\n\tint tot &#x3D; 0;\n\tfor (int i &#x3D; 0; i + 1 &lt; n; i++)\n\t\tif(q[i + 1] !&#x3D; q[i] + 1)\n\t\t\ttot++;\n\treturn (tot + 2) &#x2F; 3;\n&#125;\n\nbool check()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tif(q[i] !&#x3D; i + 1) return false;\n\treturn true;\n&#125;\n\nbool dfs(int depth, int max_depth)\n&#123;\n\tif(depth + f() &gt; max_depth) return false;&#x2F;&#x2F;IDA*\n\tif(check()) return true;\n\n\t&#x2F;&#x2F;搜索每个分支\n\tfor (int len &#x3D; 1; len &lt;&#x3D; n; len++)&#x2F;&#x2F;枚举段长\n\t\tfor (int l &#x3D; 0; l + len - 1 &lt; n; l++)&#x2F;&#x2F;枚举起点\n\t\t&#123;\n\t\t\tint r &#x3D; l + len - 1;\n\t\t\tfor(int k &#x3D; r + 1; k &lt; n; k++)\n\t\t\t&#123;\n\t\t\t\tmemcpy(w[depth], q, sizeof q);\n\n\t\t\t\tint x, y;\n\t\t\t\tfor(x &#x3D; r + 1, y &#x3D; l; x &lt;&#x3D; k; x++, y++) q[y] &#x3D; w[depth][x];\n\t\t\t\t&#x2F;&#x2F;跳过部分[r+1, k]前移\n\t\t\t\tfor(x &#x3D; l; x &lt;&#x3D; r; x++, y++) q[y] &#x3D; w[depth][x];&#x2F;&#x2F;[l,r]移至k后\n\t\t\t\tif(dfs(depth + 1, max_depth)) return true;\n\n\t\t\t\tmemcpy(q, w[depth], sizeof q);\n\t\t\t&#125;\n\n\t\t&#125;\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;n);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]);\n\n\t\tint depth &#x3D; 0;\n\t\twhile(depth &lt; 5 &amp;&amp; !dfs(0, depth)) depth++;&#x2F;&#x2F;迭代加深\n\n\t\tif(depth &gt;&#x3D; 5) puts(&quot;5 or more&quot;);\n\t\telse printf(&quot;%d\\n&quot;, depth);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;回转游戏\n&#x2F;*\n\t  0     1\n\t  2     3\n4  5  6  7  8  9  10\n\t  11    12\n13 14 15 16 17 18 19\n\t  20    21\n\t  22    23\n*&#x2F;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 24;\n\nint op[8][7] &#x3D; &#123;\n\t&#123;0, 2, 6, 11, 15, 20, 22&#125;,\n\t&#123;1, 3, 8, 12, 17, 21, 23&#125;,\n\t&#123;10, 9, 8, 7, 6, 5, 4&#125;,\n\t&#123;19, 18, 17, 16, 15, 14, 13&#125;,\n\t&#123;23, 21, 17, 12, 8, 3, 1&#125;,\n\t&#123;22, 20, 15, 11, 6, 2, 0&#125;,\n\t&#123;13, 14, 15, 16, 17, 18, 19&#125;,\n\t&#123;4, 5, 6, 7, 8, 9, 10&#125;\n&#125;;\nint center[8] &#x3D; &#123;6, 7, 8, 11, 12, 15, 16, 17&#125;;\nint opposite[8] &#x3D; &#123;5, 4, 7, 6, 1, 0, 3, 2&#125;;\n\nint q[N];&#x2F;&#x2F;填充数字 123\nint path[100];\n\nint f()\n&#123;\n\tstatic int sum[4];\n\tmemset(sum, 0, sizeof sum);\n\tfor (int i &#x3D; 0; i &lt; 8; i ++ ) sum[q[center[i]]] ++ ;&#x2F;&#x2F;记录sum\n\tint s &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 3; i ++ ) s &#x3D; max(s, sum[i]);&#x2F;&#x2F;max_sum\n\treturn 8 - s;\n&#125;\n\nbool check()\n&#123;\n\tfor (int i &#x3D; 1; i &lt; 8; i ++ )\n\t\tif (q[center[i]] !&#x3D; q[center[0]])\n\t\t\treturn false;\n\treturn true;\n&#125;\n\nvoid operate(int x)\n&#123;\n\tint t &#x3D; q[op[x][0]];\n\tfor (int i &#x3D; 0; i &lt; 6; i ++ ) q[op[x][i]] &#x3D; q[op[x][i + 1]];\n\tq[op[x][6]] &#x3D; t;\n&#125;\n\nbool dfs(int depth, int max_depth, int last)\n&#123;\n\tif(depth + f() &gt; max_depth) return false;&#x2F;&#x2F;IDA*\n\tif(check()) return true;\n\t&#x2F;&#x2F;扩展其他分支\n\tfor (int i &#x3D; 0; i &lt; 8; i++)\n\t&#123;\n\t\tif(opposite[i] &#x3D;&#x3D; last) continue;\n\t\toperate(i);&#x2F;&#x2F;op-i\n\t\tpath[depth] &#x3D; i;&#x2F;&#x2F;记录op-i\n\t\tif(dfs(depth + 1, max_depth, i)) return true;&#x2F;&#x2F;递归\n\t\toperate(opposite[i]);&#x2F;&#x2F;恢复op-i\n\t&#125;\n\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\twhile (scanf(&quot;%d&quot;, &amp;q[0]), q[0])\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt; N; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);\n\t\tint depth &#x3D; 0;\n\t\twhile (!dfs(0, depth, -1)) depth ++ ;\n\t\t\n\t\tif (!depth) printf(&quot;No moves needed&quot;);\n\t\tfor (int i &#x3D; 0; i &lt; depth; i ++ ) printf(&quot;%c&quot;, &#39;A&#39; + path[i]);\n\t\tprintf(&quot;\\n%d\\n&quot;, q[6]);&#x2F;&#x2F;中间一圈填的数字\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;破坏正方形\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 61;\n\nint n, m;\nvector&lt;int&gt; square[N];\nbool st[N];\n\nbool check(vector&lt;int&gt; &amp;sq)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; sq.size(); i++)\n\t\tif(st[sq[i]]) return false;\n\treturn true;\n&#125;\n\nint f()\n&#123;\n\tstatic bool state[N];\n\tmemcpy(state, st, sizeof st);\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; m; i++)\n\t&#123;\n\t\tvector&lt;int&gt; &amp;sq &#x3D; square[i];\n\t\tif(check(sq))\n\t\t&#123;&#x2F;&#x2F;边全去掉，只记一次\n\t\t\tres ++ ;\n\t\t\tfor (int j &#x3D; 0; j &lt; sq.size(); j++) st[sq[j]] &#x3D; true;\n\t\t&#125;\n\t&#125;\n\tmemcpy(st, state, sizeof st);\n\treturn res;\n&#125;\n\nbool dfs(int depth, int max_depth)\n&#123;\n\tif(depth + f() &gt; max_depth) return false;\n\n\tfor (int i &#x3D; 0; i &lt; m; i++)\n\t&#123;\n\t\tvector&lt;int&gt; &amp;sq &#x3D; square[i];\n\t\tif(check(sq))&#x2F;&#x2F;sq完整\n\t\t&#123;\n\t\t\tfor (int j &#x3D; 0; j &lt; sq.size(); j++)\n\t\t\t&#123;\n\t\t\t\tint x &#x3D; sq[j];\n\t\t\t\tst[x] &#x3D; true;&#x2F;&#x2F;去掉火柴x\n\t\t\t\tif(dfs(depth + 1, max_depth)) return true;\n\t\t\t\tst[x] &#x3D; false;&#x2F;&#x2F;还原\n\t\t\t&#125;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;\n\treturn true;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\twhile(T--)\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;n);\n\n\t\tmemset(st, 0, sizeof st);\n\t\tm &#x3D; 0;\n\t\tfor (int len &#x3D; 1; len &lt;&#x3D; n; len++)&#x2F;&#x2F;枚举边长len\n\t\t\tfor (int a &#x3D; 1; a + len - 1 &lt;&#x3D; n; a++)&#x2F;&#x2F;枚举正方形m起点 行a 向下\n\t\t\t\tfor (int b &#x3D; 1; b + len - 1 &lt;&#x3D; n; b++)&#x2F;&#x2F;列b 向右\n\t\t\t\t&#123;\n\t\t\t\t\tauto &amp;sq &#x3D; square[m];\n\t\t\t\t\tsq.clear();\n\t\t\t\t\tint d &#x3D; 2 * n + 1;\n\t\t\t\t\tfor (int i &#x3D; 0; i &lt; len; i++)\n\t\t\t\t\t&#123;&#x2F;&#x2F;nswe\n\t\t\t\t\t\tsq.push_back(1 + (a - 1) * d + b - 1 + i);\n\t\t\t\t\t\tsq.push_back(1 + (a + len - 1) * d + b - 1 + i);\n\t\t\t\t\t\tsq.push_back(n + 1 + (a - 1) * d + b - 1 + i * d);\n\t\t\t\t\t\tsq.push_back(n + 1 + (a - 1) * d + b - 1 + i * d + len);\n\t\t\t\t\t&#125;\n\t\t\t\t\tm++;\n\t\t\t\t&#125;\n\t\tint k &#x3D; 0;\n\t\tscanf(&quot;%d&quot;, &amp;k);\n\t\twhile(k--)\n\t\t&#123;\n\t\t\tint x;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\tst[x] &#x3D; true;\n\t\t&#125;\n\n\t\tint depth &#x3D; 0;\n\t\twhile(!dfs(0, depth)) depth++;\n\t\tprintf(&quot;%d\\n&quot;, depth);&#x2F;&#x2F;去掉?根火柴&#x3D;&#x3D;搜索?层\n\t&#125;\n\n\treturn 0;\n&#125;\n\n------------------------------------------------------------------------------\n\n&#x2F;&#x2F;0x29 总结与练习\n&#x2F;&#x2F;靶形数独 （166数独 + 取最高分）\n&#x2F;&#x2F; 递归函数不加inline\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 9, M &#x3D; 1 &lt;&lt; N;\n\nint ones[M], log[M];\nint row[N], col[N], cell[3][3];\nint g[N][N];\nint ans &#x3D; -1;\n\ninline int lowbit(int x)\n&#123;\n\treturn x &amp; -x;\n&#125;\n\nvoid init()\n&#123;\n\tfor(int i &#x3D; 0; i &lt; N; i++) log[1 &lt;&lt; i] &#x3D; i;\n\tfor(int i &#x3D; 0; i &lt; M; i++)\n\t\tfor (int j &#x3D; i; j; j -&#x3D; lowbit(j)) \n\t\t\tones[i]++;\n\n\tfor(int i &#x3D; 0; i &lt; N; i++) row[i] &#x3D; col[i] &#x3D; cell[i &#x2F; 3][i % 3] &#x3D; M - 1;\n&#125;\n\ninline int get_score(int x, int y)\n&#123;\n\treturn min(min(x, 8 - x), min(y, 8 - y)) + 6;&#x2F;&#x2F;距边界最短距离0~4 + 6\n&#125;\n\ninline void draw(int x, int y, int t)\n&#123;\n\tint s &#x3D; 1;\n\tif(t &gt; 0) g[x][y] &#x3D; t;&#x2F;&#x2F;置0\n\telse &#x2F;&#x2F; t &lt; 0:  draw(x, y, -t);还原现场用\n\t&#123;\n\t\ts &#x3D; -1;&#x2F;&#x2F;抹掉t 置1\n\t\tt &#x3D; -t;&#x2F;&#x2F;使t &gt; 0\n\t\tg[x][y] &#x3D; 0;\n\t&#125;\n\tt--;&#x2F;&#x2F;1~9 -&gt; 0~8\n\trow[x] -&#x3D; s &lt;&lt; t;\n\tcol[y] -&#x3D; s &lt;&lt; t;\n\tcell[x &#x2F; 3][y &#x2F; 3] -&#x3D; s &lt;&lt; t;\n&#125;\n\ninline int get(int x, int y)&#x2F;&#x2F;x,y处可填的数\n&#123;\n\treturn row[x] &amp; col[y] &amp; cell[x &#x2F; 3][y &#x2F; 3];\n&#125;\n\nvoid dfs(int cnt, int score)\n&#123;\n\tif(!cnt)\n\t&#123;\n\t\tans &#x3D; max(ans, score);\n\t\treturn;\n\t&#125;\n\n\t&#x2F;&#x2F;找出可选方案数(可填数字)最少的空格\n\tint x, y, mins &#x3D; 10;\n\tfor(int i &#x3D; 0; i &lt; N; i++)\n\t\tfor(int j &#x3D; 0; j &lt; N; j++)\n\t\t\tif(!g[i][j])&#x2F;&#x2F;可填\n\t\t\t&#123;\n\t\t\t\tint t &#x3D; ones[get(i, j)];\n\t\t\t\tif(t &lt; mins)\n\t\t\t\t&#123;\n\t\t\t\t\tmins &#x3D; t;\n\t\t\t\t\tx &#x3D; i, y &#x3D; j;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\tfor(int i &#x3D; get(x, y); i; i -&#x3D; lowbit(i))\n\t&#123;\n\t\tint t &#x3D; log[lowbit(i)] + 1;&#x2F;&#x2F;0~8 -&gt; 1~9\n\t\tdraw(x, y, t);&#x2F;&#x2F;填t\n\t\tdfs(cnt - 1, score + t * get_score(x, y));&#x2F;&#x2F;递归\n\t\tdraw(x, y, -t);&#x2F;&#x2F;还原\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tinit();\n\n\tint cnt &#x3D; 0, score &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; N; i++)\n\t\tfor (int j &#x3D; 0; j &lt; N; j++)\n\t\t&#123;\n\t\t\tint x;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\tif(x)\n\t\t\t&#123;\n\t\t\t\tdraw(i, j, x);\n\t\t\t\tscore +&#x3D; x * get_score(i, j);\n\t\t\t&#125;\n\t\t\telse cnt ++;\n\t\t&#125;\n\n\tdfs(cnt, score);\n\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 184\t虫食算\t45.84%\t简单\n&#x2F;*\nN进制竖式加法，算式中三个数都有N位，允许有前导的0\n相同的数字用相同的字母表示\n前N个大写字母来表示这个算式中的0到N-1这N个不同的数字\nN个字母分别至少出现一次\n对于给定的N进制加法算式，【求出N个不同的字母分别代表的数字，使得该加法算式成立。】\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 30;\n\nint n;\nchar e[3][N];\nint q[N], path[N];\t&#x2F;&#x2F;path[q[u]] &#x3D; i; 字母&#x3D;数字\nbool st[N];\t\t\t&#x2F;&#x2F;st[i] &#x3D; true; 数字被用过\n\nbool check()\n&#123;\n\tfor (int i &#x3D; n - 1, t &#x3D; 0; i &gt;&#x3D; 0; i--)&#x2F;&#x2F;进位t只有0、1!!!!!!!!!!!!!!\n\t&#123;\n\t\tint a &#x3D; e[0][i] - &#39;A&#39;, b &#x3D; e[1][i] - &#39;A&#39;, c &#x3D; e[2][i] - &#39;A&#39;;\n\t\tif (path[a] !&#x3D; -1 &amp;&amp; path[b] !&#x3D; -1 &amp;&amp; path[c] !&#x3D; -1)&#x2F;&#x2F;cur列全定(字母全被赋值过)\n\t\t&#123;\n\t\t\ta &#x3D; path[a], b &#x3D; path[b], c &#x3D; path[c];\n\t\t\tif(t !&#x3D; -1)\n\t\t\t&#123;\n\t\t\t\tif((a + b + t) % n !&#x3D; c) return false;\n\t\t\t\tif(!i &amp;&amp; a + b + t &gt;&#x3D; n) return false;&#x2F;&#x2F;最高位无进位\n\t\t\t\tt &#x3D; (a + b + t) &#x2F; n;\n\t\t\t&#125;\n\t\t\telse &#x2F;&#x2F;之前列存在未定\n\t\t\t&#123;\n\t\t\t\tif((a + b + 0) % n !&#x3D; c &amp;&amp; (a + b + 1) % n !&#x3D; c) return false;\n\t\t\t\tif(!i &amp;&amp; a + b &gt;&#x3D; n) return false; &#x2F;&#x2F; if(0&gt;&#x3D;) 1&gt;&#x3D;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse t &#x3D; -1;&#x2F;&#x2F;cur列非全定（有字母未被赋值）\n\t&#125;\n\treturn true;\n&#125;\n\n\nvoid dfs(int u)&#x2F;&#x2F;u个字母已定\n&#123;\n\tif(u &#x3D;&#x3D; n) return true;\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tif(!st[i])\n\t\t&#123;\n\t\t\tst[i] &#x3D; true;\n\t\t\tpath[q[u]] &#x3D; i;\n\t\t\tif(check() &amp;&amp; dfs(u + 1)) return true;\n\t\t\tst[i] &#x3D; false;\n\t\t\tpath[q[u]] &#x3D; -1;\n\t\t&#125;\n\treturn false;\n&#125;\n\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 0; i &lt; 3; i++) scanf(&quot;%s&quot;, e[i]);\n\tfor (int i &#x3D; n - 1, k &#x3D; 0; i &gt;&#x3D; 0; i--) &#x2F;&#x2F;i列 \n\t\tfor (int j &#x3D; 0; j &lt; 3; j++)\n\t\t&#123;\n\t\t\tint t &#x3D; e[j][i] - &#39;A&#39;;\n\t\t\tif(!st[t])\n\t\t\t&#123;\n\t\t\t\tst[t] &#x3D; true;\n\t\t\t\tq[k++] &#x3D; t; \n\t\t\t&#125;\n\n\t\t&#125;\n\n\tmemset(st, 0 , sizeof st);&#x2F;&#x2F;num被用过\n\tmemset(path, -1 , sizeof path);&#x2F;&#x2F;字母被赋值为num\n\tdfs(0);\n\n\tfor (int i &#x3D; 0; i &lt; n; i++) printf(&quot;%d&quot;, path[i]);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 185\t玛雅游戏\t54.04%\t中等\n&#x2F;*\n下落消消乐5*7  I:恰好n步通关(0&lt;n≤5) -&gt; O:每步x,y,g(-1:L 1:R)move&#x2F;swap &gt;&#x3D;3连锁\n颜色不多于10种，从1开始顺序编号，相同数字表示相同颜色\n多组解时:\n按照x为第一关健字，y为第二关健字，1优先于-1，给出一组字典序最小的解。\n没有解决方案 || n &gt; 5，输出-1。\n\nenum:x,y L&#x2F;R \n消掉mark 再judge\n\ncut1:(goal和当前方块颜色相同)这样无意义的操作可能被用来填补操作步数,不能被剪掉\n恰好n步通关：不cut\t\t最少?步通关：cut\ncut2:向左移动时，如果左侧有方块，则直接减掉。这是由于输出的答案要求字典序最小，如果左侧有方块，那么将左侧的方块向右移动的字典序小于将当前方块向左移动的字典序。g&#x3D;1优先于-1\ncut3:当某种颜色的方块数量cnt[]&#x3D;&#x3D;1或2时，一定无解，直接剪枝。\n*&#x2F;\n\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint n;\nint g[5][7], bg[5][5][7];&#x2F;&#x2F; g[列[行]] backup_g\nint cnt[11], bcnt[5][11];&#x2F;&#x2F; num(color)_i个数\nbool st[5][7];&#x2F;&#x2F;state\n\nstruct Move\n&#123;\n\tint x, y, d;\n&#125;path[5];\n\nvoid move(int a, int b, int c) &#x2F;&#x2F; c &#x3D;&#x3D; a+1-1\n&#123;\n\tswap(g[a][b], g[c][b]);\n\n\twhile (true)\n\t&#123;\n\t\tbool flag &#x3D; false;&#x2F;&#x2F;g有无变化\n\t\t&#x2F;&#x2F;处理悬空方格\n\t\tfor (int x &#x3D; 0; x &lt; 5; x++)&#x2F;&#x2F;每列\n\t\t&#123;\n\t\t\tint z &#x3D; 0;\n\t\t\tfor (int y &#x3D; 0; y &lt; 7; y++)\n\t\t\t\tif (g[x][y])\n\t\t\t\t\tg[x][z++] &#x3D; g[x][y];&#x2F;&#x2F;【非空(悬空)才drop(z&#x3D;) z++】\n\t\t\twhile (z &lt; 7) g[x][z++] &#x3D; 0;&#x2F;&#x2F;上方补0\n\t\t&#125;\n\t\t&#x2F;&#x2F;枚举格子T&#x2F;F该删\n\t\tmemset(st, false, sizeof st);\n\t\tfor (int x &#x3D; 0; x &lt; 5; x ++ )\n\t\t\tfor (int y &#x3D; 0; y &lt; 7; y ++ )\n\t\t\t\tif (g[x][y])\n\t\t\t\t&#123;\n\t\t\t\t\tint l &#x3D; x, r &#x3D; x;\n\t\t\t\t\twhile (l - 1 &gt;&#x3D; 0 &amp;&amp; g[l - 1][y] &#x3D;&#x3D; g[x][y]) l--;\n\t\t\t\t\twhile (r + 1 &lt; 5 &amp;&amp; g[r + 1][y] &#x3D;&#x3D; g[x][y]) r++;\n\n\t\t\t\t\tif (r - l + 1 &gt;&#x3D; 3)&#x2F;&#x2F;横连(x,y符合该删条件)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tflag &#x3D; true;\n\t\t\t\t\t\tst[x][y] &#x3D; true;\n\t\t\t\t\t&#125;\n\t\t\t\t\telse\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tl &#x3D; r &#x3D; y;\n\t\t\t\t\t\twhile (l - 1 &gt;&#x3D; 0 &amp;&amp; g[x][l - 1] &#x3D;&#x3D; g[x][y]) l--;\n\t\t\t\t\t\twhile (r + 1 &lt; 7 &amp;&amp; g[x][r + 1] &#x3D;&#x3D; g[x][y]) r++;\n\n\t\t\t\t\t\tif (r - l + 1 &gt;&#x3D; 3)&#x2F;&#x2F;竖连\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tflag &#x3D; true;\n\t\t\t\t\t\t\tst[x][y] &#x3D; true;&#x2F;&#x2F;该删\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\n\t\tif (flag)&#x2F;&#x2F;需要删\n\t\t&#123;\n\t\t\tfor (int x &#x3D; 0; x &lt; 5; x ++ )\n\t\t\t\tfor (int y &#x3D; 0; y &lt; 7; y ++ )\n\t\t\t\t\tif (st[x][y])&#x2F;&#x2F;删他\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tcnt[0] --;\n\t\t\t\t\t\tcnt[g[x][y]] --;\n\t\t\t\t\t\tg[x][y] &#x3D; 0;\n\t\t\t\t\t&#125;\n\t\t&#125;\n\t\telse break;\n\t&#125;\n&#125;\n\nbool dfs(int u)\n&#123;\n\tif (u &#x3D;&#x3D; n) return !cnt[0];&#x2F;&#x2F;0 square\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#x2F;&#x2F;color\n\t\tif (cnt[i] &#x3D;&#x3D; 1 || cnt[i] &#x3D;&#x3D; 2)&#x2F;&#x2F;cut3\n\t\t\treturn false;\n\n\t&#x2F;&#x2F;枚举所有操作\n\tmemcpy(bg[u], g, sizeof g);\n\tmemcpy(bcnt[u], cnt, sizeof cnt);\n\tfor (int x &#x3D; 0; x &lt; 5; x ++ )\n\t\tfor (int y &#x3D; 0; y &lt; 7; y ++ )\n\t\t\tif (g[x][y])\n\t\t\t&#123;\n\t\t\t\tint nx &#x3D; x + 1; &#x2F;&#x2F; -&gt;new_x \n\t\t\t\tif (nx &lt; 5)\n\t\t\t\t&#123;\n\t\t\t\t\tpath[u] &#x3D; &#123; x, y, 1 &#125;;\n\t\t\t\t\tmove(x, y, nx);&#x2F;&#x2F;to:new_x\n\t\t\t\t\tif (dfs(u + 1)) return true;\n\t\t\t\t\tmemcpy(g, bg[u], sizeof g);\n\t\t\t\t\tmemcpy(cnt, bcnt[u], sizeof cnt);\n\t\t\t\t&#125;\n\t\t\t\tnx &#x3D; x - 1; &#x2F;&#x2F; &lt;-new_x\n\t\t\t\tif (nx &gt;&#x3D; 0 &amp;&amp; !g[nx][y])&#x2F;&#x2F;cut1:L必须为空\n\t\t\t\t&#123;\n\t\t\t\t\tpath[u] &#x3D; &#123; x, y, -1 &#125;;\n\t\t\t\t\tmove(x, y, nx);\n\t\t\t\t\tif (dfs(u + 1)) return true;\n\t\t\t\t\tmemcpy(g, bg[u], sizeof g);\n\t\t\t\t\tmemcpy(cnt, bcnt[u], sizeof cnt);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; 5; i++)\n\t&#123;\n\t\tint j &#x3D; 0, y;\n\t\twhile (cin &gt;&gt; y, y)\n\t\t&#123;\n\t\t\tcnt[0] ++;&#x2F;&#x2F;sum of squares\n\t\t\tcnt[y] ++;\n\t\t\tg[i][j++] &#x3D; y;\n\t\t&#125;\n\t&#125;\n\n\tif (dfs(0))\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) printf(&quot;%d %d %d\\n&quot;, path[i].x, path[i].y, path[i].d);\n\t&#125;\n\telse puts(&quot;-1&quot;);\n\n\treturn 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;3428&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F; 186\t巴士\t39.27%\t中等 \n&#x2F;&#x2F;巴士线路的总数量最小是多少ans&lt;&#x3D;17(浅)。 共n辆bus:1≤n≤300(搜索树深)\n&#x2F;*\ndfs 迭代加深 cut:\n首先预处理出所有可能的线路。先枚举起点i，再枚举公差j，则i和j需要满足两个条件：\n1.由于i是起点，因此0 ~ i - 1中不能包含任何该序列的点，所以公差j至少是i + 1；\n2.由于0 ~ 59之间至少要包含两个点，因此i + j一定小于60；\n[d&gt;a , a+d&lt;60]\n再搜:\n最少从合法线路中选出多少条，才可以覆盖所有给定的公交车。\n1.P()-&gt;C()避免重复传入起点start \n2.等差数列降排【搜索顺序cut】\n3.由于剪枝2的存在，当前路线覆盖的点数是最多的，当前路线能覆盖的点数*剩余可选的路径条数+当前已经覆盖的点数&lt;总点数，说明当前方案一定非法，直接回溯\n【可行性cut】\n\n60min内(a,d)定一条路线:C(2,60)&#x3D;60*59&#x2F;2&#x3D;59*30&lt;2000[总路线数N 上限]\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;&#x2F;&#x2F;a d\n\nconst int N &#x3D; 2000, M &#x3D; 60;\n\nint n;\nvector&lt;pair&lt;int, PII&gt;&gt; routes;\nint bus[M]; &#x2F;&#x2F; M时刻bus数\n\nbool is_route(int a, int d)\n&#123;\n\tfor (int i &#x3D; a; i &lt; 60; i +&#x3D; d)\n\t\tif (!bus[i]) return false;\n\treturn true;\n&#125;\n&#x2F;*\nbool dfs(int depth, int u, int sum, int start) &#x2F;&#x2F;sum:cur覆盖?辆 \n&#123;\n\tif (u &#x3D;&#x3D; depth) return sum &#x3D;&#x3D; n;\n\t&#x2F;&#x2F;cut3\n\tif (routes[start].first * (depth - u) + sum &lt; n) return false;\n\t&#x2F;&#x2F;枚举选哪个路线\n\tfor (int i &#x3D; start; i &lt; routes.size(); i ++ )\n\t&#123;\n\t\tauto r &#x3D; routes[i];\n\t\tint a &#x3D; r.second.first, d &#x3D; r.second.second;\n\t\tif (!is_route(a, d)) continue;\n\t\tfor (int j &#x3D; a; j &lt; 60; j +&#x3D; d) bus[j] -- ;&#x2F;&#x2F;路线(a,d)覆盖一遍bus数\n\t\tif (dfs(depth, u + 1, sum + r.first, i)) return true;\n\t\tfor (int j &#x3D; a; j &lt; 60; j +&#x3D; d) bus[j] ++ ;\n\t&#125;\n\treturn false;\n&#125;\n*&#x2F;\nbool dfs(int depth, int sum, int start) &#x2F;&#x2F;depth:剩余?层 sum:cur覆盖?辆 \n&#123;\n\tif (!depth) return sum &#x3D;&#x3D; n;\n\t&#x2F;&#x2F;枚举选哪个路线\n\tfor (int i &#x3D; start; i &lt; routes.size(); i ++ )\n\t&#123;\n\t\tauto r &#x3D; routes[i];\n\t\tint a &#x3D; r.second.first, d &#x3D; r.second.second;\n\t\tif (!is_route(a, d)) continue;\n\t\tif(r.first * depth + sum &lt; n) continue;&#x2F;&#x2F;cut3\n\t\tfor (int j &#x3D; a; j &lt; 60; j +&#x3D; d) bus[j] -- ;&#x2F;&#x2F;路线(a,d)覆盖一遍bus数\n\t\tif (dfs(depth - 1, sum + r.first, i)) return true;\n\t\tfor (int j &#x3D; a; j &lt; 60; j +&#x3D; d) bus[j] ++ ;&#x2F;&#x2F;-- ++\n\t&#125;\n\n\treturn false;\n&#125;\n\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint t;\n\t\tscanf(&quot;%d&quot;, &amp;t);\n\t\tbus[t] ++ ;\n\t&#125;\n\t&#x2F;&#x2F;预处理出所有可能的线路\n\tfor (int a &#x3D; 0; a &lt; 60; a ++ )\n\t\tfor (int d &#x3D; a + 1; a + d &lt; 60; d ++ )&#x2F;&#x2F;d&gt;a a+d&lt;60\n\t\t\tif (is_route(a, d))\n\t\t\t\troutes.push_back(&#123;(59 - a) &#x2F; d + 1, &#123;a, d&#125;&#125;);&#x2F;&#x2F;路线bus数,&#123;a,d&#125;\n\t&#x2F;&#x2F;路线覆盖bus数降排\n\tsort(routes.begin(), routes.end(), greater&lt;pair&lt;int, PII&gt;&gt;());\n\t&#x2F;&#x2F;迭代加深dfs\n\tint depth &#x3D; 0;\n\twhile (!dfs(depth, 0, 0)) depth ++ ;\n\n\tprintf(&quot;%d\\n&quot;, depth);\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 187\t导弹防御系统\t52.00%\t中等\n&#x2F;*\n一套防御系统的导弹拦截高度要么一直严格单调上升要么一直严格单调下降。\n给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。\n\nseq最少拆分为?条严格单调子序列\n搜索顺序分为两个阶段：\n1.从前往后枚举每颗导弹属于某个【上升】子序列，还是下降子序列；\n2.如果属于上升子序列，则枚举属于【哪个上升】子序列（包括新开一个上升子序列）；如果属于下降子序列，可以类似处理。\n因此可以仿照AcWing 896. 最长上升子序列 II， 【分别记录当前每个上升子序列的末尾数up[]，和下降子序列的末尾数down[]。这样在枚举时可以快速判断当前数是否可以接在某个序列的后面。】\n\n贪心cut：\n对于上升子序列而言，我们将当前数接在最大的数后面，一定不会比接在其他数列后面更差。【&gt;&#x3D; 能放在max后，当然也能放在smaller后，反之不行 决策包容性最大:教材P42】\n这是因为处理完当前数后，一定出现一个以当前数结尾的子序列，这是固定不变的，那么此时其他子序列的末尾数越小越好。\n\n常数cut：\n注意到按照这种贪心思路，up[]数组和down[]数组一定是单调的，因此在遍历时找到第一个满足的序列后就可以直接break了。\n\n如何求最小值。因为DFS和BFS不同，第一次搜索到的节点，不一定是步数最短的节点，所以需要进行额外处理。一般有两种处理方式：\n1.ID-DFS\n2.记录全局最小值，不断更新； 这种搜索顺序可以参考@一瞬流年丶涅槃同学的题解；\n*&#x2F;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 60;\n\nint n;\nint h[N];\nint up[N], down[N];\n\nbool dfs(int depth, int u, int su, int sd)&#x2F;&#x2F;本次迭代层数上限 cur up数 down数 \n&#123;\n\t&#x2F;&#x2F; 如果上升序列个数 + 下降序列个数 &gt; 子序列总个数上限，则回溯\n\tif (su + sd &gt; depth) return false;\n\tif (u &#x3D;&#x3D; n) return true;\n\n\t&#x2F;&#x2F; 枚举放到上升子序列中的情况\n\tbool flag &#x3D; false;  &#x2F;&#x2F; 是否放入某subSeq\n\tfor (int i &#x3D; 1; i &lt;&#x3D; su; i ++ )\n\t\tif (up[i] &lt; h[u])\n\t\t&#123;\n\t\t\tint t &#x3D; up[i];\n\t\t\tup[i] &#x3D; h[u];\n\t\t\tif (dfs(depth, u + 1, su, sd)) return true;\n\t\t\tup[i] &#x3D; t;\n\t\t\tflag &#x3D; true; &#x2F;&#x2F;cur放入\n\t\t\tbreak;  &#x2F;&#x2F; 注意由上述证明的贪心原理，只要找到第一个可以放的序列，就可以结束循环了\n\t\t&#125;\n\tif (!flag)  &#x2F;&#x2F; 如果不能放到任意一个序列后面，则单开一个新的序列\n\t&#123;\n\t\tup[su + 1] &#x3D; h[u];\n\t\tif (dfs(depth, u + 1, su + 1, sd)) return true;\n\t&#125;\n\n\t&#x2F;&#x2F; 枚举放到下降子序列中的情况\n\tflag &#x3D; false;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; sd; i ++ )\n\t\tif (down[i] &gt; h[u])\n\t\t&#123;\n\t\t\tint t &#x3D; down[i];\n\t\t\tdown[i] &#x3D; h[u];\n\t\t\tif (dfs(depth, u + 1, su, sd)) return true;\n\t\t\tdown[i] &#x3D; t;\n\t\t\tflag &#x3D; true;\n\t\t\tbreak;  &#x2F;&#x2F; 注意由上述证明的贪心原理，只要找到第一个可以放的序列，就可以结束循环了\n\t\t&#125;\n\tif (!flag)  &#x2F;&#x2F; 如果不能放到任意一个序列后面，则单开一个新的序列\n\t&#123;\n\t\tdown[sd + 1] &#x3D; h[u];\n\t\tif (dfs(depth, u + 1, su, sd + 1)) return true;\n\t&#125;\n\n\treturn false;\n&#125;\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n, n)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; h[i];\n\t\t&#x2F;&#x2F; 迭代加深搜索\n\t\tint depth &#x3D; 0;\n\t\twhile (!dfs(depth, 0, 0, 0)) depth ++ ;\n\n\t\tcout &lt;&lt; depth &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n&#x2F;&#x2F;类似题：AcWing 896. 最长上升子序列 II\n&#x2F;&#x2F; 443 贪心 排序+enum\n&#x2F;&#x2F; 1010 seq最少拆分为?条严格单调上升子序列（证）\n\n\n&#x2F;&#x2F; 188\t武士风度的牛\t52.96%\t简单\n&#x2F;&#x2F;马走日，求跳跃的最小次数 求min：bfs\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 155;\n\nint n, m;\nchar g[N][N];\nint dist[N][N];&#x2F;&#x2F;cur_hops\n\nint bfs(PII start, PII end)\n&#123;\n\tqueue&lt;PII&gt; q;\n\tmemset(dist, -1, sizeof dist);\n\tdist[start.x][start.y] &#x3D; 0;\n\n\tq.push(start);\n\t&#x2F;&#x2F;x向下 y向右\n\tint dx[] &#x3D; &#123;-2, -1, 1, 2, 2, 1, -1, -2&#125;;\n\tint dy[] &#x3D; &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;\n\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int i &#x3D; 0; i &lt; 8; i ++ )\n\t\t&#123;\n\t\t\tint x &#x3D; t.x + dx[i], y &#x3D; t.y + dy[i];\n\t\t\tif (x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; m) continue;&#x2F;&#x2F;越界\n\t\t\tif (g[x][y] &#x3D;&#x3D; &#39;*&#39;) continue;&#x2F;&#x2F;障碍\n\t\t\tif (dist[x][y] !&#x3D; -1) continue;&#x2F;&#x2F;已走过\n\t\t\tdist[x][y] &#x3D; dist[t.x][t.y] + 1;\n\n\t\t\tif (make_pair(x, y) &#x3D;&#x3D; end) return dist[x][y];\n\n\t\t\tq.push(&#123;x, y&#125;);\n\t\t&#125;\n\t&#125;\n\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; m &gt;&gt; n;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];\n\n\tPII start, end;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\tfor (int j &#x3D; 0; j &lt; m; j ++ )\n\t\t\tif (g[i][j] &#x3D;&#x3D; &#39;K&#39;) start &#x3D; &#123;i, j&#125;;\n\t\t\telse if (g[i][j] &#x3D;&#x3D; &#39;H&#39;) end &#x3D; &#123;i, j&#125;;\n\n\tcout &lt;&lt; bfs(start, end) &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; 189\t乳草的入侵\t32.87%\t简单\n&#x2F;&#x2F;每次扩一圈  扩?次占满&#x3D;上题dist_max(global)\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 110;\n\nint n, m;\nPII start;\nchar g[N][N];\nint dist[N][N];\n\nint bfs()\n&#123;\n\tmemset(dist, -1, sizeof dist);\n\tqueue&lt;PII&gt; q;\n\tq.push(start);\n\tdist[start.x][start.y] &#x3D; 0;\n\n\tint res &#x3D; 0;\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\t\t&#x2F;&#x2F;扩一圈\n\t\tfor (int x &#x3D; t.x - 1; x &lt;&#x3D; t.x + 1; x ++ )\n\t\t\tfor (int y &#x3D; t.y - 1; y &lt;&#x3D; t.y + 1; y ++ )\n\t\t\t\tif (x !&#x3D; t.x || y !&#x3D; t.y) &#x2F;&#x2F; !(&amp;&amp;)&#x3D;&#x3D;(!)||(!)\n\t\t\t\t&#123;\n\t\t\t\t\tif (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) continue;\n\t\t\t\t\tif (g[x][y] &#x3D;&#x3D; &#39;*&#39; || dist[x][y] !&#x3D; -1) continue;\n\t\t\t\t\tdist[x][y] &#x3D; dist[t.x][t.y] + 1;\n\t\t\t\t\tres &#x3D; max(res, dist[x][y]);&#x2F;&#x2F;\n\t\t\t\t\tq.push(&#123;x, y&#125;);\n\t\t\t\t&#125;\n\t&#125;\n\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; m &gt;&gt; n &gt;&gt; start.y &gt;&gt; start.x;&#x2F;&#x2F;m列n行\n\tstart.x &#x3D; n + 1 - start.x;&#x2F;&#x2F;x向上\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; g[i] + 1;&#x2F;&#x2F; 1,1\n\n\tcout &lt;&lt; bfs() &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 190\t字串变换\t43.45%\t中等\n&#x2F;* \n至多6个规则 所有字符串长度的上限为 20\n（包含 10步）以内能将 A 变换为 B ，则输出最少的变换步数\n\nk^10-&gt;2*k^5 双向bfs：[最优性]不能每次扩展一点，必须每次扩展一层！！！\nBFS的扩展方式是:分别枚举在原字符串中使用替换规则的起点，和所使用的的替换规则。\n*&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 6;\n\nint n;\nstring A, B;\nstring a[N], b[N];&#x2F;&#x2F;变换规则a[]-&gt;b[]\n\nint extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string, int&gt;&amp;da, unordered_map&lt;string, int&gt;&amp; db, \n\tstring a[N], string b[N])\n&#123;\n\tint d &#x3D; da[q.front()];\n\twhile (q.size() &amp;&amp; da[q.front()] &#x3D;&#x3D; d)&#x2F;&#x2F;只扩cur层d，一次扩一层\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )&#x2F;&#x2F;枚举规则i\n\t\t\tfor (int j &#x3D; 0; j &lt; t.size(); j ++ )&#x2F;&#x2F;枚举subSeq起点j\n\t\t\t\tif (t.substr(j, a[i].size()) &#x3D;&#x3D; a[i])\n\t\t\t\t&#123;\n\t\t\t\t\tstring r &#x3D; t.substr(0, j) + b[i] + t.substr(j + a[i].size());&#x2F;&#x2F;片段a[i]-&gt;b[i]\n\t\t\t\t\tif (db.count(r)) return da[t] + db[r] + 1; &#x2F;&#x2F; A~t&lt;-&gt;r~B\n\t\t\t\t\tif (da.count(r)) continue;&#x2F;&#x2F;重复\n\t\t\t\t\tda[r] &#x3D; da[t] + 1;\n\t\t\t\t\tq.push(r);\n\t\t\t\t&#125;\n\t&#125;\n\n\treturn 11;\n&#125;\n\nint bfs()\n&#123;\n\tqueue&lt;string&gt; qa, qb;&#x2F;&#x2F;存中间结果\n\tunordered_map&lt;string, int&gt; da, db;&#x2F;&#x2F;d[str]&#x3D;A(B)到str的-&gt;(&lt;-)变换规则数\n\n\tqa.push(A), qb.push(B);\n\tda[A] &#x3D; db[B] &#x3D; 0;\n\n\tint step &#x3D; 0;\n\twhile (qa.size() &amp;&amp; qb.size())\n\t&#123;\n\t\tint t;\n\t\tif (qa.size() &lt; qb.size()) t &#x3D; extend(qa, da, db, a, b);&#x2F;&#x2F;qa短:正-&gt;扩\n\t\telse t &#x3D; extend(qb, db, da, b, a);&#x2F;&#x2F;反向变换a&lt;-b  扩短的 2选1\n\n\t\tif (t &lt;&#x3D; 10) return t;\n\t\tif ( ++ step &gt; 10) return -1;&#x2F;&#x2F; &lt;&#x3D; 10 steps\n\t&#125;\n\n\treturn -1;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; A &gt;&gt; B;\n\twhile (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ;&#x2F;&#x2F;【规则数n不定，&lt;&#x3D;N】!!!!!!!!!!\n\n\tint t &#x3D; bfs();\n\tif (t &#x3D;&#x3D; -1) puts(&quot;NO ANSWER!&quot;);\n\telse cout &lt;&lt; t &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;132169&#x2F;\n\n\n\n&#x2F;&#x2F; 191\t天气预报\t29.30%\t中等\n&#x2F;*\n平时可以有足够的雨水，在赶集和过节能够充满阳光。\n四个基本方向（东南西北）之中选取一个方向，将云移动1或2个方格，或将其保持在相同位置。任何地区【s0~s3四个角的状态（最近的一次下雨是什么时候）】都不能连续七天或以上时间都不降雨。\n0表示正常的一天，1表示赶集和过节的一天\n\n可保证:1 or 0\nf(cur_day,x,y,s0,s1,s2,s3) 365*9*(7^4)&#x3D;700w+ 多组数据！！\nDP全集-&gt;dfs bfs子集\n*&#x2F;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 366;\n\nint n;\nbool st[N][3][3][7][7][7][7]; &#x2F;&#x2F; &#x3D;&#x3D;bool visit[]\nstruct Node\n&#123;\n\tint day, x, y, s0, s1, s2, s3;\n&#125;;\nint state[N][4][4];\n\nint bfs()\n&#123;\n\t&#x2F;&#x2F;init云处不能下雨 st&#x3D;1表示赶集和过节的一天\n\tif (state[1][1][1] || state[1][1][2] || state[1][2][1] || state[1][2][2]) return 0;\n\n\tqueue&lt;Node&gt; q;\n\tmemset(st, 0, sizeof st);&#x2F;&#x2F;多组测试数据\n\tq.push(&#123;1, 1, 1, 1, 1, 1, 1&#125;);\n\tst[1][1][1][1][1][1][1] &#x3D; true;\n\n\tint dx[] &#x3D; &#123;-1, 0, 1, 0, 0&#125;, dy[] &#x3D; &#123;0, 1, 0, -1, 0&#125;;\n\n\twhile (q.size())\n\t&#123;\n\t\tauto t &#x3D; q.front();\n\t\tq.pop();\n\n\t\tif (t.day &#x3D;&#x3D; n) return 1;\n\n\t\tfor (int i &#x3D; 0; i &lt; 5; i ++ )&#x2F;&#x2F;direction\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; 2; j ++ )&#x2F;&#x2F;1、2 steps\n\t\t\t&#123;\n\t\t\t\tint x &#x3D; t.x + dx[i] * j, y &#x3D; t.y + dy[i] * j;&#x2F;&#x2F;左上角xy\n\t\t\t\tif (x &lt; 0 || x &gt;&#x3D; 3 || y &lt; 0 || y &gt;&#x3D; 3) continue;\n\t\t\t\t&#x2F;&#x2F;2*2云处不能下雨\n\t\t\t\tauto&amp; s &#x3D; state[t.day + 1];\n\t\t\t\tif (s[x][y] || s[x][y + 1] || s[x + 1][y] || s[x + 1][y + 1]) continue;\n\n\t\t\t\tint s0 &#x3D; t.s0, s1 &#x3D; t.s1, s2 &#x3D; t.s2, s3 &#x3D; t.s3;\n\t\t\t\tif (!x &amp;&amp; !y) s0 &#x3D; 0;&#x2F;&#x2F;s0久旱逢甘露 置0\n\t\t\t\telse if ( ++ s0 &#x3D;&#x3D; 7) continue;&#x2F;&#x2F;旱死了\n\t\t\t\tif (!x &amp;&amp; y &#x3D;&#x3D; 2) s1 &#x3D; 0;\n\t\t\t\telse if ( ++ s1 &#x3D;&#x3D; 7) continue;\n\t\t\t\tif (x &#x3D;&#x3D; 2 &amp;&amp; !y) s2 &#x3D; 0;\n\t\t\t\telse if ( ++ s2 &#x3D;&#x3D; 7) continue;\n\t\t\t\tif (x &#x3D;&#x3D; 2 &amp;&amp; y &#x3D;&#x3D; 2) s3 &#x3D; 0;\n\t\t\t\telse if ( ++ s3 &#x3D;&#x3D; 7) continue;\n\t\t\t\t&#x2F;&#x2F;重复 记忆化剪枝\n\t\t\t\tif (st[t.day + 1][x][y][s0][s1][s2][s3]) continue;\n\n\t\t\t\tst[t.day + 1][x][y][s0][s1][s2][s3] &#x3D; true;\n\t\t\t\tq.push(&#123;t.day + 1, x, y, s0, s1, s2, s3&#125;);\n\t\t\t&#125;\n\t&#125;\n\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n, n)&#x2F;&#x2F;n天\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\t\tfor (int j &#x3D; 0; j &lt; 4; j ++ )\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 4; k ++ )\n\t\t\t\t\tcin &gt;&gt; state[i][j][k];\n\n\t\tcout &lt;&lt; bfs() &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;*\n记忆化保存每个状态，保证每个状态只被搜一次。具体：开一个 \nvis[dep][(x,y)][(d1,d2,d3,d4)]数组，记录每个状态是否搜过。\n回顾我们的状态，dep 表示天数，(x,y) 可以用公式 x*4+y 表示在哪一个，\nd 就是四个角，我们发现最多离上一次淋雨6天，我们的d就表示离上一次淋雨几天（和上面的搜索状态有所不同），可以用 七进制状态压缩 储存\n*&#x2F;\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ninline int read() &#123;\n\tint x&#x3D;0,f&#x3D;1;\n\tchar ch&#x3D;getchar();\n\twhile(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) &#123; if(ch&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1; ch&#x3D;getchar(); &#125;\n\twhile(ch&gt;&#x3D;&#39;0&#39;&amp;&amp;ch&lt;&#x3D;&#39;9&#39;) &#123; x&#x3D;(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch&#x3D;getchar(); &#125;\n\treturn x * f;\n&#125;\nconst int N &#x3D; 366, M &#x3D; 10, MAXN &#x3D; 2807;\nconst int dx[] &#x3D; &#123;0,-1,1,0,0,-2,2,0,0&#125;;\nconst int dy[] &#x3D; &#123;0,0,0,-1,1,0,0,-2,2&#125;;\nint n;\nint state[N];\nbool vis[N][M][MAXN];\nstruct Node &#123;\n\tint d[4];\n&#125;st;\ninline int Get(int x,int y) &#123;\n\treturn 1&lt;&lt;(x*4+y);\n&#125;\ninline bool check(int now,int x,int y,Node cr) &#123;\n\tfor(int i&#x3D;0;i&lt;4;++i)\n\t\tif(now - cr.d[i] &gt; 6) return false;\n\tint weather &#x3D; Get(x,y) | Get(x,y+1) | Get(x+1,y) | Get(x+1,y+1);\n\tif(weather &amp; state[now]) return false;\n\tint s &#x3D; 0, base &#x3D; 8;\n\tfor(int i&#x3D;0;i&lt;4;++i)\n\t\ts &#x3D; s*base + (now - cr.d[i]);\n\tif(vis[now][x*4+y][s]) return false;    &#x2F;&#x2F;记忆化，剪枝 \n\treturn vis[now][x*4+y][s] &#x3D; true;\n&#125;\ninline bool valid(int x,int y) &#123;\n\treturn (x&gt;&#x3D;0&amp;&amp;x&lt;3&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;3);  &#x2F;&#x2F;注意下标从 0 开始编号 \n&#125;\nbool Dfs(int dep,int x,int y,Node cr) &#123; &#x2F;&#x2F;corner 角落 \n\tif(!check(dep,x,y,cr)) return false;\n\tif(dep &#x3D;&#x3D; n) return true;\n\tfor(int i&#x3D;0;i&lt;9;++i) &#123;\n\t\tint nx &#x3D; x + dx[i], ny &#x3D; y + dy[i]; Node ncr &#x3D; cr;\n\t\tif(!valid(nx,ny)) continue;\n\t\tif(nx&#x3D;&#x3D;0 &amp;&amp; ny&#x3D;&#x3D;0) ncr.d[0] &#x3D; dep + 1;\n\t\tif(nx&#x3D;&#x3D;0 &amp;&amp; ny&#x3D;&#x3D;2) ncr.d[1] &#x3D; dep + 1;\n\t\tif(nx&#x3D;&#x3D;2 &amp;&amp; ny&#x3D;&#x3D;0) ncr.d[2] &#x3D; dep + 1;\n\t\tif(nx&#x3D;&#x3D;2 &amp;&amp; ny&#x3D;&#x3D;2) ncr.d[3] &#x3D; dep + 1;\n\t\tif(Dfs(dep+1,nx,ny,ncr)) return true;\n\t&#125;\n\treturn false;\n&#125;\nvoid work() &#123;\n\tmemset(state, 0, sizeof(state));\n\tmemset(vis, 0, sizeof(vis));\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;++i)\n\t\tfor(int j&#x3D;0;j&lt;16;++j)\n\t\t\tstate[i] |&#x3D; (read()&lt;&lt;j);\n\t&#x2F;&#x2F;for(int i&#x3D;1;i&lt;&#x3D;n;++i) printf(&quot;state[%d] &#x3D; %d\\n&quot;,i,state[i]);\n\t&#x2F;&#x2F;cout &lt;&lt; endl;\n\tst.d[0] &#x3D; st.d[1] &#x3D; st.d[2] &#x3D; st.d[3] &#x3D; 0;\n\tvis[1][1*4+1][0] &#x3D; 1;\n\tprintf(&quot;%d\\n&quot;,Dfs(1,1,1,st));\n\t&#x2F;&#x2F;cout &lt;&lt; endl;\n&#125;\nint main()\n&#123;\n\twhile(true) &#123;\n\t\tn &#x3D; read();\n\t\tif(!n) break;\n\t\twork();\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：扶摇直上九万里\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;7518&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F; 192\t立体推箱子2\t38.46%\t困难\n\n\n&#x2F;&#x2F; 193\t算乘方的牛\t38.42%\t困难\n&#x2F;&#x2F; 194\t涂满它！\t34.29%\t中等\n&#x2F;&#x2F; 195\t骑士精神\n\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n\n\n\n0x30数学知识&#x2F;&#x2F;0x31质数\n&#x2F;&#x2F;p-judge：试除法 (Miller-Rabin)，筛法，线性筛\n\n&#x2F;&#x2F;A质因数分解：试除法 (Pollard&#39;s Rho)\n&#x2F;&#x2F;质数距离\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint primes[N], cnt;&#x2F;&#x2F;M&#x3D;5w&#x3D;sqrt(R) 不够!\nbool st[N];\n\nvoid get_primes(int n) &#x2F;&#x2F; 线性筛模板\n&#123;\n\tmemset(st, false, sizeof st);\n\tcnt &#x3D; 0;\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tif(!st[i]) primes[cnt++] &#x3D; i;\n\t\tfor(int j &#x3D; 0; primes[j] * i &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tst[primes[j] * i] &#x3D; true;\n\t\t\tif (i % primes[j] &#x3D;&#x3D; 0) break;&#x2F;&#x2F;p[j]&lt;&#x3D;v[i]最小质因子\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tlong long l, r;\n\n\twhile(cin &gt;&gt; l &gt;&gt; r)\n\t&#123;\n\t\tget_primes(50000);\n\n\t\tmemset(st, false, sizeof st);\n\t\tfor (int i &#x3D; 0; i &lt; cnt; i++)\n\t\t&#123;\n\t\t\tint p &#x3D; primes[i];\n\t\t\t&#x2F;&#x2F;筛掉所有[l,r]中p的倍数  (l+p j+&#x3D;p 会超int!!!)\n\t\t\t&#x2F;&#x2F;max((l + p - 1) &#x2F; p * p, 2ll * p)    l较小时!!!!!!!!!!!!\n\t\t\tfor(long long j &#x3D; max((l + p - 1) &#x2F; p * p, 2ll * p); j &lt;&#x3D; r; j +&#x3D; p)\n\t\t\t\tst[j - l] &#x3D; true;\n\t\t&#125;\n\n\t\tcnt &#x3D; 0;\n\t\tfor(int i &#x3D; 0; i &lt;&#x3D; r - l; i++)\n\t\t\tif(!st[i] &amp;&amp; i + l &gt; 1) primes[cnt++] &#x3D; i + l;&#x2F;&#x2F;1不是质数不是合数!\n\t\tif(cnt &lt; 2) puts(&quot;There are no adjacent primes.&quot;);\n\t\telse\n\t\t&#123;\n\t\t\tint minp &#x3D; 0, maxp &#x3D; 0;\n\t\t\tfor (int i &#x3D; 0; i + 1 &lt; cnt; i++)\n\t\t\t&#123;\n\t\t\t\tint d &#x3D; primes[i + 1] - primes[i];\n\t\t\t\tif(d &lt; primes[minp + 1] - primes[minp]) minp &#x3D; i;\n\t\t\t\tif(d &gt; primes[maxp + 1] - primes[maxp]) maxp &#x3D; i;\n\t\t\t&#125;\n\n\t\t\tprintf(&quot;%d,%d are closest, %d,%d are most distant.\\n&quot;, primes[minp],primes[minp + 1], primes[maxp], primes[maxp + 1]);\n\t\t&#125;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;阶乘分解\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1000010;\n\nint primes[N], cnt;\nbool st[N];\n\nvoid get_primes(int n)\n&#123;\n\tfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tif(!st[i]) primes[cnt++] &#x3D; i;\n\t\tfor(int j &#x3D; 0; primes[j] * i &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tst[primes[j] * i] &#x3D; true;\n\t\t\tif(i % primes[j] &#x3D;&#x3D; 0) break;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tint n;\n\tcin &gt;&gt; n;\n\n\tget_primes(n);\n\n\tfor (int i &#x3D; 0; i &lt; cnt; i++)\n\t&#123;\n\t\tint p &#x3D; primes[i];\n\t\tint s &#x3D; 0, t &#x3D; n;\n\t\twhile(t) s +&#x3D; t &#x2F; p, t &#x2F;&#x3D; p;\n\n\t\tprintf(&quot;%d %d\\n&quot;, p, s);\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x32约数\n&#x2F;&#x2F;试除法，倍数法\n\n&#x2F;&#x2F;反素数\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nint ps[] &#x3D; &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;\n\nint n;\nint sum &#x3D; 0, minx;&#x2F;&#x2F;ans的约数个数，ans(有sum_max的min_ans)\n&#x2F;&#x2F; cur_pi,last_ci,cur总乘积product,cur约数个数\nvoid dfs(int u, int last, int p, int s)\n&#123;\n\tif(s &gt; sum || s &#x3D;&#x3D; sum &amp;&amp; p &lt; minx)\n\t&#123;\n\t\tsum &#x3D; s;\n\t\tminx &#x3D; p;\n\t&#125;&#x2F;&#x2F;更新minx\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; last; i++)&#x2F;&#x2F;ci单调递减\n\t&#123;\n\t\tif((LL) p * ps[u] &gt; n) break;&#x2F;&#x2F;p &lt;&#x3D; n\n\t\tp *&#x3D; ps[u];&#x2F;&#x2F; 数p &#x3D;&#x3D; pi的连乘！！！\n\t\tdfs(u + 1, i, p, s * (i + 1));&#x2F;&#x2F;正约数个数:(ci+1)连乘\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\t\n\tdfs(0, 30, 1, 1);&#x2F;&#x2F;ci &lt;&#x3D; 30\n\n\tcout &lt;&lt; minx &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;余数之和\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nint n;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\t\n\tcout &lt;&lt; minx &lt;&lt; endl;\n\treturn 0;\n&#125;\n&#x2F;&#x2F;gcd\n&#x2F;&#x2F;200\tHankson的趣味题\n\n&#x2F;&#x2F;欧拉函数\n&#x2F;&#x2F;\t201\t可见的点\n\n&#x2F;&#x2F;积性函数：Dirichlet卷积，Mobius反演  待填坑。。。。。。。\n\n&#x2F;&#x2F;0x33 同余\n&#x2F;&#x2F;费马小定理\n&#x2F;&#x2F;欧拉定理\n&#x2F;&#x2F; 202\t最幸运的数字\n\n\n\n&#x2F;&#x2F;exgcd\n&#x2F;&#x2F;乘法逆元 b * b^(p-2) % p &#x3D; 1\n&#x2F;&#x2F; Sumdiv\n\n\n\n&#x2F;&#x2F;线性同余方程\n&#x2F;&#x2F;203\t同余方程\n\n\n&#x2F;&#x2F;中国剩余定理\n&#x2F;&#x2F;204\t表达整数的奇怪方式\n\n\n&#x2F;&#x2F;高次同余方程: a^x(%p)&#x3D;b型\n&#x2F;&#x2F;x^a(%p)&#x3D;b型：原根 阶 指数 待填坑。。。。。。。\n&#x2F;&#x2F;大小步算法\n\n\n\n&#x2F;&#x2F;0x34 矩阵乘法 矩阵快速幂\n&#x2F;&#x2F;205\t斐波那契\n\n&#x2F;&#x2F;206\t石头游戏\n\n\n&#x2F;&#x2F;0x35 高斯消元\n&#x2F;&#x2F; 207\t球形空间产生器\t76.39%\t中等\n\n&#x2F;&#x2F; 208\t开关问题\n\n\n&#x2F;&#x2F;线性空间\n&#x2F;&#x2F; 209\t装备购买\n\n\n&#x2F;&#x2F; 210\t异或运算\n\n\n&#x2F;&#x2F;0x36 组合计数\n&#x2F;&#x2F;\t211\t计算系数\t53.79%\t简单\n\n\n&#x2F;&#x2F; 212\t计数交换\t39.74%\t简单\n\n\n&#x2F;&#x2F;【Lucas定理】\n&#x2F;&#x2F;213\t古代猪文\t46.33%\t简单\n\n\n&#x2F;&#x2F;0x37 容斥 \n&#x2F;&#x2F;214\tDevu和鲜花\t49.58%\t中等\n\n&#x2F;&#x2F;Mobius函数\n&#x2F;&#x2F;215\t破译密码\t41.94%\t困难\n\n\n&#x2F;&#x2F;0x38 概率 数学期望\n&#x2F;&#x2F;216\tRainbow的信号\t41.31%\t简单\n\n\n\n&#x2F;&#x2F;217\t绿豆蛙的归宿\t66.88%\t简单\n\n\n\n&#x2F;&#x2F; 218\t扑克牌\t62.28%\t中等\n\n\n\n&#x2F;&#x2F;0x39 0&#x2F;1分数规划\n\n&#x2F;&#x2F;0x3A 博弈论之SG函数\n&#x2F;&#x2F;219\t剪纸游戏\t46.63%\t中等\n\n\n---------------------------------------------------------------\n\n&#x2F;&#x2F;0x3B 总结与练习\n&#x2F;&#x2F; 220\t最大公约数\t47.09%\t中等\n&#x2F;&#x2F; 221\t龙哥的问题\t46.58%\t中等\n&#x2F;&#x2F; 222\t青蛙的约会\t46.77%\t困难\n&#x2F;&#x2F; 223\t阿九大战朱最学\t63.87%\t简单\n&#x2F;&#x2F; 224\t计算器\t42.11%\t简单\n&#x2F;&#x2F; 225\t矩阵幂求和\t51.81%\t简单\n&#x2F;&#x2F; 226\t233矩阵\t81.58%\t简单\n&#x2F;&#x2F; 227\t小部件厂\t25.67%\t中等\n&#x2F;&#x2F; 228\t异或\t33.33%\t简单\n&#x2F;&#x2F; 229\t新NIM游戏\t53.61%\t简单\n&#x2F;&#x2F; 230\t排列计数\t56.12%\t简单\n&#x2F;&#x2F; 231\t天码\t48.21%\t困难\n&#x2F;&#x2F; 232\t守卫者的挑战\t60.91%\t简单\n&#x2F;&#x2F; 233\t换教室\t44.49%\t中等\n&#x2F;&#x2F; 234\t放弃测试\t53.37%\t中等\n&#x2F;&#x2F; 235\t魔法珠\t42.08%\t简单\n&#x2F;&#x2F; 236\t格鲁吉亚和鲍勃\t51.69%\t困难\n\n\n\n\n\n\n\n\n\n\n\n0x40数据结构进阶&#x2F;&#x2F;0x41 并查集\n&#x2F;&#x2F; 237\t程序自动分析\n\n\n&#x2F;&#x2F;超市（法2）\n\n&#x2F;&#x2F;【扩展域 边带权】\n&#x2F;&#x2F; 238\t银河英雄传说\n\n&#x2F;&#x2F; 239\t奇偶游戏\n\n&#x2F;&#x2F; 240\t食物链\n\n\n&#x2F;&#x2F;0x42 树状数组\n&#x2F;&#x2F; 241\t楼兰图腾\n\n&#x2F;&#x2F; 242\t一个简单的整数问题\n\n&#x2F;&#x2F; 243\t一个简单的整数问题2\t（树状数组）\n\n&#x2F;&#x2F; 244\t谜一样的牛\n\n&#x2F;&#x2F;0x43 线段树\n&#x2F;&#x2F; 245\t你能回答这些问题吗\n\n\n&#x2F;&#x2F; 246\t区间最大公约数\n\n\n&#x2F;&#x2F;【延迟标记】\n&#x2F;&#x2F; 243\t一个简单的整数问题2 （线段树）\n\n\n\n\n&#x2F;&#x2F;0x43.扫描线\n&#x2F;&#x2F;亚特兰蒂斯\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n#define ll long long\nconst int N &#x3D; 20000 + 10;&#x2F;&#x2F;????\nstruct node&#123;\n\tdouble x,y1,y2;\n\tint val;\n\tnode() &#123;&#125;\n\tnode(double x, double y1, double y2,int val)&#123;\n\t\tthis-&gt;x &#x3D; x; this-&gt;val &#x3D; val;\n\t\tthis-&gt;y1 &#x3D; y1; this-&gt;y2 &#x3D; y2;\n\t&#125;\n\tbool operator &lt;(const node &amp;t)const &#123;\n\t\treturn x&lt;t.x;\n\t&#125;\n&#125;;\nstruct Tree&#123;\n\tint l,r,cnt;\n\tdouble len;\n&#125;t[N&lt;&lt;3];\nint n,k&#x3D;1;\nvector&lt;node&gt; a;\nvector&lt;double&gt; y;\nvoid up(int rt) &#123;&#x2F;&#x2F;root\n\tif (t[rt].cnt&gt;0) t[rt].len &#x3D; y[t[rt].r+1] - y[t[rt].l];\n\telse t[rt].len &#x3D; t[rt&lt;&lt;1].len + t[rt&lt;&lt;1|1].len;\n&#125;\nvoid build(int rt,int l,int r) &#123;\n\tt[rt].l &#x3D; l,t[rt].r &#x3D; r; t[rt].cnt &#x3D; 0;\n\tt[rt].len &#x3D; 0;\n\tif (l &#x3D;&#x3D; r) return;\n\tint mid &#x3D; (l+r)&gt;&gt;1;\n\tbuild(rt&lt;&lt;1,l,mid);\n\tbuild(rt&lt;&lt;1|1,mid+1,r);\n&#125;\nvoid update(int rt,int l,int r,int val) &#123;\n\tif (l &lt;&#x3D; t[rt].l &amp;&amp; r &gt;&#x3D; t[rt].r) &#123;\n\t\tt[rt].cnt+&#x3D;val;\n\t\tup(rt);\n\t\treturn;\n\t&#125;\n\tint mid &#x3D; (t[rt].l+t[rt].r)&gt;&gt;1;\n\tif (l &lt;&#x3D; mid) update(rt&lt;&lt;1,l,r,val);\n\tif (r &gt; mid) update(rt&lt;&lt;1|1,l,r,val);\n\tup(rt);\n&#125;\nint main() &#123;\n\twhile (~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123;\n\t\ty.clear();a.clear();\n\t\tfor(int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tdouble x1,x2,y1,y2;\n\t\t\tscanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);\n\t\t\ty.push_back(y1);\n\t\t\ty.push_back(y2);\n\t\t\ta.push_back(node(x1,y2,y1,1));\n\t\t\ta.push_back(node(x2,y2,y1,-1));\n\t\t&#125;\n\t\ty.push_back(-1);\n\t\tsort(a.begin(),a.end());\n\t\tsort(y.begin(),y.end());\n\t\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\tint m &#x3D; y.size(),num &#x3D; a.size();\n\t\tbuild(1,0,m);\n\t\tdouble ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; num; i++) &#123;\n\t\t\tint l &#x3D; lower_bound(y.begin(),y.end(),a[i].y2)-y.begin();\n\t\t\tint r &#x3D; lower_bound(y.begin(),y.end(),a[i].y1) - y.begin()-1;\n\t\t\tupdate(1,l,r,a[i].val);\n\t\t\tans +&#x3D; t[1].len*(a[i+1].x-a[i].x);\n\t\t&#125;\n\t\tprintf(&quot;Test case #%d\\n&quot;,k++);\n\t\tprintf(&quot;Total explored area: %.2f\\n\\n&quot;,ans);\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：19_2\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;92113&#x2F;\n&#x2F;&#x2F;窗内的星星\n\n&#x2F;&#x2F;0x44.分块\n&#x2F;&#x2F;蒲公英\n\n&#x2F;&#x2F;磁力块\n\n&#x2F;&#x2F;小Z的袜子 XuHt注释版\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 50006;\nint n, m, c[N], L[N], R[N], num[N];\nstruct P &#123;\n\tint id, l, r;\n&#125; p[N];\nll ans, Ans[N][2], g;\n\nbool cmp(P a, P b) &#123;\n\treturn a.l &lt; b.l || (a.l &#x3D;&#x3D; b.l &amp;&amp; a.r &lt; b.r);\n&#125;\n\nbool cmp0(P a, P b) &#123;\n\treturn a.r &lt; b.r;\n&#125;\n\nvoid work(int x, int w) &#123;\n\tans -&#x3D; (ll)num[x] * (num[x] - 1);\n\tnum[x] +&#x3D; w;\n\tans +&#x3D; (ll)num[x] * (num[x] - 1);\n&#125;\n\nll gcd(ll a, ll b) &#123;\n\treturn b ? gcd(b, a % b) : a;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;c[i]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d %d&quot;, &amp;p[i].l, &amp;p[i].r);\n\t\tp[i].id &#x3D; i;\n\t&#125;\n\t&#x2F;&#x2F;prework 分段\n\tsort(p + 1, p + m + 1, cmp);\n\tint t &#x3D; sqrt(m);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tL[i] &#x3D; (i - 1) * t + 1;\n\t\tR[i] &#x3D; i * t;\n\t&#125;\n\tif (R[t] &lt; m) &#123;\n\t\tL[t+1] &#x3D; R[t] + 1;\n\t\tR[++t] &#x3D; m;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tsort(p + L[i], p + R[i] + 1, cmp0);&#x2F;&#x2F;段i[)内 r&lt; 排序\n\t\tmemset(num, 0, sizeof(num));\n\t\tans &#x3D; 0;\n\t\tint l &#x3D; p[L[i]].l, r &#x3D; p[L[i]].r;&#x2F;&#x2F;该块第一个询问L[i]的询问区间p:[l,r]\n\t\tfor (int j &#x3D; l; j &lt;&#x3D; r; j++) work(c[j], 1);&#x2F;&#x2F;更新ans\n\t\tAns[p[L[i]].id][0] &#x3D; ans;\n\t\tAns[p[L[i]].id][1] &#x3D; (ll)(r - l) * (r - l + 1);\n\t\tg &#x3D; gcd(Ans[p[L[i]].id][0], Ans[p[L[i]].id][1]);&#x2F;&#x2F;最简分数\n\t\tif (!g) Ans[p[L[i]].id][1] &#x3D; 1;&#x2F;&#x2F;分母为0\n\t\telse &#123;\n\t\t\tAns[p[L[i]].id][0] &#x2F;&#x3D; g;\n\t\t\tAns[p[L[i]].id][1] &#x2F;&#x3D; g;\n\t\t&#125;\n\t\tfor (int j &#x3D; L[i] + 1; j &lt;&#x3D; R[i]; j++) &#123;&#x2F;&#x2F;该块其余询问 \n\t\t\t&#x2F;&#x2F;1p&lt;--&gt;1Ans  询问区间变化，更新ans!!!!!!\n\t\t\twhile (r &lt; p[j].r) work(c[++r], 1);&#x2F;&#x2F;1 4 从next(先+—)开始扩(+1)\n\t\t\twhile (r &gt; p[j].r) work(c[r--], -1);&#x2F;&#x2F;2 3 从self(后+—)开始缩(-1)\n\t\t\twhile (l &lt; p[j].l) work(c[l++], -1);\n\t\t\twhile (l &gt; p[j].l) work(c[--l], 1);\n\t\t\tif (p[j].l &#x3D;&#x3D; p[j].r) &#123;\n\t\t\t\tAns[p[j].id][0] &#x3D; 0;\n\t\t\t\tAns[p[j].id][1] &#x3D; 1;\n\t\t\t&#125; else &#123;\n\t\t\t\tAns[p[j].id][0] &#x3D; ans;\n\t\t\t\tAns[p[j].id][1] &#x3D; (ll)(r - l) * (r - l + 1);\n\t\t\t\tg &#x3D; gcd(Ans[p[j].id][0], Ans[p[j].id][1]);\n\t\t\t\tif (!g) Ans[p[j].id][1] &#x3D; 1;\n\t\t\t\telse &#123;\n\t\t\t\t\tAns[p[j].id][0] &#x2F;&#x3D; g;\n\t\t\t\t\tAns[p[j].id][1] &#x2F;&#x3D; g;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tprintf(&quot;%lld&#x2F;%lld\\n&quot;, Ans[i][0], Ans[i][1]);\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x45.点分治\n&#x2F;&#x2F;Tree\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 10006;\nint n, k, s[N], Ans;\nbool v[N], w[N];&#x2F;&#x2F;&#x2F;&#x2F;访问过 (在之前的递归层)已删除\nint Head[N], Edge[N&lt;&lt;1], Leng[N&lt;&lt;1], Next[N&lt;&lt;1], t;\nint ans, pos;\nint d[N], b[N], a[N], tot, cnt[N];\n\nvoid dfs_find(int S, int x) &#123;&#x2F;&#x2F;子树size:S(传值,非&amp;) 找x所在子树的重心as root\n\tv[x] &#x3D; 1;\n\ts[x] &#x3D; 1;&#x2F;&#x2F;局部变量！\n\tint max_part &#x3D; 0;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;&#x2F;&#x2F;x-i-&gt;y\n\t\tint y &#x3D; Edge[i];\n\t\tif (v[y] || w[y]) continue;&#x2F;&#x2F;w?\n\t\tdfs_find(S, y);\n\t\ts[x] +&#x3D; s[y];&#x2F;&#x2F;向上递推\n\t\tmax_part &#x3D; max(max_part, s[y]);\n\t&#125;\n\tmax_part &#x3D; max(max_part, S - s[x]);&#x2F;&#x2F;!!!\n\tif (max_part &lt; ans) &#123;&#x2F;&#x2F;min化max_part\n\t\tans &#x3D; max_part;\n\t\tpos &#x3D; x;\n\t&#125;\n&#125;\n\nvoid dfs(int x) &#123;\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (v[y] || w[y]) continue;\n\t\t++cnt[b[a[++tot]&#x3D;y]&#x3D;b[x]];&#x2F;&#x2F;子树x加边:x-(z)-&gt;y new点y\n\t\td[y] &#x3D; d[x] + z;\n\t\tdfs(y);\n\t&#125;\n&#125;\n\nbool cmp(int i, int j) &#123;\n\treturn d[i] &lt; d[j];\n&#125;\n\nvoid work(int S, int x) &#123;\n\tmemset(v, 0, sizeof(v));\n\tans &#x3D; S;&#x2F;&#x2F;ans: max_part初值\n\tdfs_find(S, x);&#x2F;&#x2F;1. 重心pos\n\t&#x2F;&#x2F;2. dfs出:d b cnt\n\tmemset(d, 0, sizeof(d));\n\tmemset(cnt, 0, sizeof(cnt));\n\tmemset(v, 0, sizeof(v));\n\tw[a[tot&#x3D;1]&#x3D;b[pos]&#x3D;pos] &#x3D; 1;&#x2F;&#x2F;w&#x3D;1 相当于 (逐递归层)删除根节点！！！\n\t++cnt[pos];&#x2F;&#x2F;cnt:子树size\n\tfor (int i &#x3D; Head[pos]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (v[y] || w[y]) continue;\n\t\t++cnt[a[++tot]&#x3D;b[y]&#x3D;y];&#x2F;&#x2F;new子树(点)y\n\t\td[y] &#x3D; z;\n\t\tdfs(y);\n\t&#125;\n\t&#x2F;&#x2F;3. Calc(P)\n\tsort(a + 1, a + tot + 1, cmp);\n\tint l &#x3D; 1, r &#x3D; tot;\n\t--cnt[b[a[1]]];&#x2F;&#x2F;L:0-&gt;1  cnt[s]:[L+1,R]的s子树size\t\t(L,R]\n\twhile (l &lt; r) &#123;\n\t\twhile (d[a[l]] + d[a[r]] &gt; k) --cnt[b[a[r--]]];&#x2F;&#x2F;while  --cnt(r), r--\n\t\tAns +&#x3D; r - l - cnt[b[a[l]]];\n\t\t--cnt[b[a[++l]]];&#x2F;&#x2F;++l,--cnt(l)\n\t&#125;\n\t&#x2F;&#x2F;4. 递归\n\tint now &#x3D; pos;\n\tfor (int i &#x3D; Head[now]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (w[y]) continue;&#x2F;&#x2F;子树根节点y已删除\n\t\twork(s[y], y);\n\t&#125;\n&#125;\n\nvoid add(int x, int y, int z) &#123;\n\tEdge[++t] &#x3D; y;\n\tLeng[t] &#x3D; z;\n\tNext[t] &#x3D; Head[x];\n\tHead[x] &#x3D; t;\n&#125;\n\nvoid Tree() &#123;\n\tt &#x3D; 0;\n\tmemset(Head, 0, sizeof(Head));\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t&#125;\n\tmemset(w, 0, sizeof(w));\n\tAns &#x3D; 0;\n\twork(n, 1);\n\tcout &lt;&lt; Ans &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; k &amp;&amp; n &amp;&amp; k) Tree();&#x2F;&#x2F;N点无根树，dx+dy&lt;&#x3D;k的路径条数\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x46.BST\n&#x2F;&#x2F;Treap\n&#x2F;&#x2F; 253\t普通平衡树\n\n\n&#x2F;&#x2F;0x47.离线分治算法\n&#x2F;&#x2F;CDQ分治(基于时间)\n&#x2F;&#x2F;天使玩偶   TLE？？？？\n\n&#x2F;&#x2F;天使玩偶 在线KD-Tree\n\n&#x2F;&#x2F;基于值域的整体分治算法\n&#x2F;&#x2F;第K小数 只Q不改\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100010, INF &#x3D; 1e9;\nstruct rec &#123;int op, x, y, z;&#125; q[2 * N], lq[2 * N], rq[2 * N];\nint n, m, t, c[N], ans[N];\n\nint ask(int x) &#123;\n\tint y &#x3D; 0;\n\tfor (; x; x -&#x3D; x &amp; -x) y +&#x3D; c[x];\n\treturn y;\n&#125;\n\nvoid change(int x, int y) &#123;\n\tfor (; x &lt;&#x3D; n; x +&#x3D; x &amp; -x) c[x] +&#x3D; y;\n&#125;\n\nvoid solve(int lval, int rval, int st, int ed) &#123;\n\tif (st &gt; ed) return;\n\tif (lval &#x3D;&#x3D; rval) &#123;\n\t\tfor (int i &#x3D; st; i &lt;&#x3D; ed; i++)\n\t\t\tif (q[i].op &gt; 0) ans[q[i].op] &#x3D; lval;\n\t\treturn;\n\t&#125;\n\tint mid &#x3D; (lval + rval) &gt;&gt; 1;\n\tint lt &#x3D; 0, rt &#x3D; 0;\n\tfor (int i &#x3D; st; i &lt;&#x3D; ed; i++) &#123;\n\t\tif (q[i].op &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 是一次赋值操作\n\t\t\tif (q[i].y &lt;&#x3D; mid) change(q[i].x, 1), lq[++lt] &#x3D; q[i];\n\t\t\telse rq[++rt] &#x3D; q[i];\n\t\t&#125; else &#123; &#x2F;&#x2F; 是一次询问\n\t\t\tint cnt &#x3D; ask(q[i].y) - ask(q[i].x - 1);\n\t\t\tif (cnt &gt;&#x3D; q[i].z) lq[++lt] &#x3D; q[i];\n\t\t\telse q[i].z -&#x3D; cnt, rq[++rt] &#x3D; q[i];\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; ed; i &gt;&#x3D; st; i--) &#123; &#x2F;&#x2F; 还原树状数组\n\t\tif (q[i].op &#x3D;&#x3D; 0 &amp;&amp; q[i].y &lt;&#x3D; mid) change(q[i].x, -1);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; lt; i++) q[st + i - 1] &#x3D; lq[i];\n\tfor (int i &#x3D; 1; i &lt;&#x3D; rt; i++) q[st + lt + i - 1] &#x3D; rq[i];\n\tsolve(lval, mid, st, st + lt - 1);\n\tsolve(mid + 1, rval, st + lt, ed);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint val; scanf(&quot;%d&quot;, &amp;val);\n\t\t&#x2F;&#x2F; a[i]&#x3D;val等价于一次把第i个数赋值为val的操作\n\t\tq[++t].op &#x3D; 0, q[t].x &#x3D; i, q[t].y &#x3D; val;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint l, r, k; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);\n\t\t&#x2F;&#x2F; 记录一次询问\n\t\tq[++t].op &#x3D; i, q[t].x &#x3D; l, q[t].y &#x3D; r, q[t].z &#x3D; k;\n\t&#125;\n\t&#x2F;&#x2F; 基于值域对t&#x3D;n+m个操作进行整体分治\n\tsolve(-INF, INF, 1, t);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) printf(&quot;%d\\n&quot;, ans[i]);\n&#125;\n\n\n&#x2F;&#x2F;Dynamic Ranking\n\n\n&#x2F;&#x2F;0x48.可持久化ds\n&#x2F;&#x2F;可持久化Trie\n&#x2F;&#x2F;最大异或和  ？？？不太理解insert对Trie的构造原因？？？？？？\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\nconst int N &#x3D; 600010;\nint trie[N * 24][2], latest[N * 24]; &#x2F;&#x2F; latest和end可合并为一个数组\nint s[N], root[N], n, m, tot;\n\n&#x2F;&#x2F; 本题需要统计子树latest，故使用递归插入\n&#x2F;&#x2F; 插入s[i]，当前为s[i]的第k位\nvoid insert(int i, int k, int p, int q) &#123;&#x2F;&#x2F;p&#x3D;&#x3D;0：不存在\n\tif (k &lt; 0) &#123;\n\t\tlatest[q] &#x3D; i;&#x2F;&#x2F;节点q是seq s中s[i]的末尾节点\n\t\treturn;\n\t&#125;\n\tint c &#x3D; s[i] &gt;&gt; k &amp; 1;&#x2F;&#x2F;取第k位\n\tif (p) trie[q][c ^ 1] &#x3D; trie[p][c ^ 1];&#x2F;&#x2F;存在，就copy\n\ttrie[q][c] &#x3D; ++tot;&#x2F;&#x2F;？？？\n\tinsert(i, k - 1, trie[p][c], trie[q][c]);&#x2F;&#x2F;？？？\n\tlatest[q] &#x3D; max(latest[trie[q][0]], latest[trie[q][1]]);\n&#125;\n\nint ask(int now, int val, int k, int limit) &#123;\n\tif (k &lt; 0) return s[latest[now]] ^ val;\n\tint c &#x3D; val &gt;&gt; k &amp; 1;\n\tif (latest[trie[now][c ^ 1]] &gt;&#x3D; limit)\n\t\treturn ask(trie[now][c ^ 1], val, k - 1, limit);\n\telse&#x2F;&#x2F; 到底是（先&#x2F;仅）考虑 &gt;&#x3D; l-1????？？？？？？？？？？\n\t\treturn ask(trie[now][c], val, k - 1, limit);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tlatest[0] &#x3D; -1;\n\troot[0] &#x3D; ++tot;\n\tinsert(0, 23, 0, root[0]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x; scanf(&quot;%d&quot;, &amp;x);\n\t\ts[i] &#x3D; s[i - 1] ^ x;\n\t\troot[i] &#x3D; ++tot;\n\t\tinsert(i, 23, root[i - 1], root[i]);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tchar op[2]; scanf(&quot;%s&quot;, op);\n\t\tif (op[0] &#x3D;&#x3D; &#39;A&#39;) &#123;\n\t\t\tint x; scanf(&quot;%d&quot;, &amp;x);\n\t\t\troot[++n] &#x3D; ++tot;\n\t\t\ts[n] &#x3D; s[n - 1] ^ x;\n\t\t\tinsert(n, 23, root[n - 1], root[n]);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tint l, r, x; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;x);\n\t\t\tprintf(&quot;%d\\n&quot;, ask(root[r - 1], x ^ s[n], 23, l - 1));\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;第k小数\n&#x2F;&#x2F;法2. 可持久化SegTree_不带修改\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100010, INF &#x3D; 1e9;\nstruct SegmentTree &#123;\n\tint lc, rc; &#x2F;&#x2F; 左右子节点编号\n\tint sum;\n&#125; tree[N * 20];\nint n, m, t, tot, a[N], b[N], root[N];\n\nint build(int l, int r) &#123;\n\tint p &#x3D; ++tot; &#x2F;&#x2F; 新建一个节点，编号为p，代表当前区间[l,r]\n\ttree[p].sum &#x3D; 0;\n\tif (l &#x3D;&#x3D; r) return p;\n\tint mid &#x3D; (l + r) &gt;&gt; 1;\n\ttree[p].lc &#x3D; build(l, mid);\n\ttree[p].rc &#x3D; build(mid + 1, r);\n\treturn p;\n&#125;\n\nint insert(int now, int l, int r, int x, int delta) &#123;\n\tint p &#x3D; ++tot;\n\ttree[p] &#x3D; tree[now]; &#x2F;&#x2F; 新建一个副本\n\tif (l &#x3D;&#x3D; r) &#123;\n\t\ttree[p].sum +&#x3D; delta; &#x2F;&#x2F; 在副本上修改\n\t\treturn p;\n\t&#125;\n\tint mid &#x3D; (l + r) &gt;&gt; 1;&#x2F;&#x2F;更新lc rc编号\n\tif (x &lt;&#x3D; mid) tree[p].lc &#x3D; insert(tree[now].lc, l, mid, x, delta);\n\telse tree[p].rc &#x3D; insert(tree[now].rc, mid + 1, r, x, delta);\n\ttree[p].sum &#x3D; tree[tree[p].lc].sum + tree[tree[p].rc].sum;\n\treturn p;\n&#125;\n\nint ask(int p, int q, int l, int r, int k) &#123;\n\tif (l &#x3D;&#x3D; r) return l; &#x2F;&#x2F; 找到答案 第k小\n\tint mid &#x3D; (l + r) &gt;&gt; 1;\n\tint lcnt &#x3D; tree[tree[p].lc].sum - tree[tree[q].lc].sum; &#x2F;&#x2F; 值在[l,mid]中的数有多少个\n\tif (k &lt;&#x3D; lcnt) return ask(tree[p].lc, tree[q].lc, l, mid, k);\n\telse return ask(tree[p].rc, tree[q].rc, mid + 1, r, k - lcnt);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;a[i]);\n\t\tb[++t] &#x3D; a[i];\n\t&#125;\n\tsort(b + 1, b + t + 1); &#x2F;&#x2F; 离散化\n\tt &#x3D; unique(b + 1, b + t + 1) - (b + 1);\n\troot[0] &#x3D; build(1, t); &#x2F;&#x2F; 关于离散化后的值域建线段树\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x &#x3D; lower_bound(b + 1, b + t + 1, a[i]) - b; &#x2F;&#x2F; 离散化后的值x\n\t\troot[i] &#x3D; insert(root[i - 1], 1, t, x, 1); &#x2F;&#x2F; 值为x的数增加1个\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint l, r, k; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);\n\t\tint ans &#x3D; ask(root[r], root[l - 1], 1, t, k);&#x2F;&#x2F;离散化后的值&#x3D;&#x3D;下标\n\t\tprintf(&quot;%d\\n&quot;, b[ans]); &#x2F;&#x2F; 从离散化后的值(下标)变回原值\n\t&#125;\n&#125;\n\n-------------------------------------------------------------------\n&#x2F;&#x2F;0x49 总结与练习\n&#x2F;&#x2F; 257\t关押罪犯（法1 法2:0x68 二分图匹配）\n\n&#x2F;&#x2F; 258\t石头剪子布\n\n&#x2F;&#x2F; 259\t真正的骗子\n\n&#x2F;&#x2F; 260\t买票\n\n&#x2F;&#x2F; 261\t旅馆\n\n&#x2F;&#x2F; 262\t海报\n\n\n&#x2F;&#x2F; 263\t作诗\n\n&#x2F;&#x2F; 264\t权值\n\n&#x2F;&#x2F; 265\t营业额统计\n\n&#x2F;&#x2F; 266\t超级备忘录\n\n&#x2F;&#x2F; 267\t莫基亚\n\n&#x2F;&#x2F; 268\t流星\n\n&#x2F;&#x2F; 269\tFotile模拟赛L\n\n&#x2F;&#x2F; 270\t可持久化并查集加强版\n\n\n\n\n\n\n\n\n0x50动态规划DP&#x2F;&#x2F;0x51.线性DP\n&#x2F;&#x2F;杨老师的照相排列\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#define ll long long\nusing namespace std;\nint n[6], k;\nconst int N &#x3D; 31;\n&#x2F;&#x2F; ll f[N][N][N][N][N];\n\nvoid work() &#123;\n\tint n[6] &#x3D; &#123;0&#125;;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; k; i++) cin &gt;&gt; n[i];\n\t&#x2F;&#x2F; while (k &lt; 5) n[++k] &#x3D; 0;\n\tll f[n[1]+1][n[2]+1][n[3]+1][n[4]+1][n[5]+1];&#x2F;&#x2F;0~n 各排人数的方案数\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0][0][0] &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; n[1]; i++)\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; n[2]; j++)\n\t\t\tfor (int k &#x3D; 0; k &lt;&#x3D; n[3]; k++)\n\t\t\t\tfor (int l &#x3D; 0; l &lt;&#x3D; n[4]; l++)\n\t\t\t\t\tfor (int m &#x3D; 0; m &lt;&#x3D; n[5]; m++) &#123;\n\t\t\t\t\t\tll &amp;v &#x3D; f[i][j][k][l][m];\n\t\t\t\t\t\tif (i &lt; n[1]) f[i+1][j][k][l][m] +&#x3D; v;\n\t\t\t\t\t\tif (j &lt; n[2] &amp;&amp; i &gt; j) f[i][j+1][k][l][m] +&#x3D; v;\n\t\t\t\t\t\tif (k &lt; n[3] &amp;&amp; j &gt; k) f[i][j][k+1][l][m] +&#x3D; v;\n\t\t\t\t\t\tif (l &lt; n[4] &amp;&amp; k &gt; l) f[i][j][k][l+1][m] +&#x3D; v;\n\t\t\t\t\t\tif (m &lt; n[5] &amp;&amp; l &gt; m) f[i][j][k][l][m+1] +&#x3D; v;\n\t\t\t\t\t&#125;\n\tcout &lt;&lt; f[n[1]][n[2]][n[3]][n[4]][n[5]] &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; k &amp;&amp; k) work();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;yxc版\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#define LL long long\nusing namespace std;\nint n[6], k;\n&#x2F;&#x2F; LL f[N][N][N][N][N];\n\nvoid work() &#123;\n\tint n[6] &#x3D; &#123;0&#125;;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; k; i++) cin &gt;&gt; n[i];\n&#x2F;&#x2F; \twhile (k &lt; 5) n[++k] &#x3D; 0;\n\tLL f[n[1]+1][n[2]+1][n[3]+1][n[4]+1][n[5]+1];&#x2F;&#x2F;0~n 各排人数的方案数\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0][0][0] &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; n[1]; i++)\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; min(i, n[2]); j++)&#x2F;&#x2F;\n\t\t\tfor (int k &#x3D; 0; k &lt;&#x3D; min(j, n[3]); k++)\n\t\t\t\tfor (int l &#x3D; 0; l &lt;&#x3D; min(k, n[4]); l++)\n\t\t\t\t\tfor (int m &#x3D; 0; m &lt;&#x3D; min(l, n[5]); m++) &#123;\n\t\t\t\t\t\tll &amp;v &#x3D; f[i][j][k][l][m];\n\t\t\t\t\t\tif (i &amp;&amp; i &gt; j) v +&#x3D; f[i-1][j][k][l][m];\n\t\t\t\t\t\tif (j &amp;&amp; j &gt; k) v +&#x3D; f[i][j-1][k][l][m];\n\t\t\t\t\t\tif (k &amp;&amp; k &gt; l) v +&#x3D; f[i][j][k-1][l][m];\n\t\t\t\t\t\tif (l &amp;&amp; l &gt; m) v +&#x3D; f[i][j][k][l-1][m];\n\t\t\t\t\t\tif (m) v +&#x3D; f[i][j][k][l][m-1];\n\t\t\t\t\t&#125;\n\tcout &lt;&lt; f[n[1]][n[2]][n[3]][n[4]][n[5]] &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; k &amp;&amp; k) work();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;最长公共上升子序列   LCS套LIS\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 3006;\nint n, a[N], b[N], f[N][N];\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;b[i]);\n&#x2F;*\n\t&#x2F;&#x2F; O(n^3)\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tf[i][j] &#x3D; f[i - 1][j];\n\t\t\tif (a[i] &#x3D;&#x3D; b[j])\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F; int maxv &#x3D; 1;\n\t\t\t\tfor (int k &#x3D; 1; k &lt; j; k++)\n\t\t\t\t\tif (b[k] &lt; a[i]) f[i][j] &#x3D; max(f[i][j], f[i - 1][k] + 1);\n\t\t\t\t\t\t&#x2F;&#x2F; maxv &#x3D; max(maxv, f[i - 1][k] + 1);\n\t\t\t\t&#x2F;&#x2F; f[i][j] &#x3D; max(f[i][j], maxv);\n\t\t\t&#125;\n\t\t&#125;\n*&#x2F;\n\t&#x2F;&#x2F;O(n^2)\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint maxv &#x3D; 1;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t&#123;\n\t\t\tf[i][j] &#x3D; f[i - 1][j];\n\t\t\tif (a[i] &#x3D;&#x3D; b[j]) f[i][j] &#x3D; max(f[i][j], maxv);\n\t\t\t&#x2F;&#x2F; j即将增大为j+1，检查j能否进入新的决策集合\n\t\t\tif (b[j] &lt; a[i]) maxv &#x3D; max(maxv, f[i - 1][j] + 1);\n\t\t&#125;\n\t&#125;\n\n\tint ans &#x3D; 0;\n\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) ans &#x3D; max(ans, f[n][j]);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;分级\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 2010, INF &#x3D; 0x3f3f3f3f;\n\nint n;\nint a[N], b[N];\nint f[N][N];\n\nint dp()\n&#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) b[i] &#x3D; a[i];\n\tsort(b + 1, b + n + 1);\n\t\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint minv &#x3D; INF;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)&#x2F;&#x2F;O(1)状态转移 更新一行f[i]\n\t\t&#123;\n\t\t\tminv &#x3D; min(minv, f[i - 1][j]);\n\t\t\tf[i][j] &#x3D; minv + abs(b[j] - a[i]);&#x2F;&#x2F;f[i][j]:最后一个数是b[j]时...\n\t\t&#125;\n\t&#125;\n\n\tint res &#x3D; INF;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) res &#x3D; min(res, f[n][i]);\n\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\n\tint res &#x3D; dp();\n\treverse(a+1, a+n+1);\n\tres &#x3D; min(res, dp());\n\n\tprintf(&quot;%d\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;移动服务\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1010, M &#x3D; 210, INF &#x3D; 0x3f3f3f3f;\n\nint n, m;\nint w[M][M];\nint p[N];\nint f[N][M][M];\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;m, &amp;n);&#x2F;&#x2F;位置数，请求数\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t\tscanf(&quot;%d&quot;, &amp;w[i][j]);&#x2F;&#x2F;花费 c(p,q)\n\t&#x2F;&#x2F;批量 离线\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;p[i]);&#x2F;&#x2F;每次请求位置\n\t\n\tmemset(f, 0x3f, sizeof f);\n\tp[0] &#x3D; 3;&#x2F;&#x2F;阶段无后效性 不妨先动3\n\tf[0][1][2] &#x3D; 0;\n\n\tfor (int i &#x3D; 0; i &lt; n; i++)&#x2F;&#x2F;0~n-1: i~i+1\n\t\tfor (int x &#x3D; 1; x &lt;&#x3D; m; x++)\n\t\t\tfor (int y &#x3D; 1; y &lt;&#x3D; m; y++)\n\t\t\t&#x2F;&#x2F; if(f[i][x][y] !&#x3D; INF) &#123;\n\t\t\t&#123;\n\t\t\t\tint z &#x3D; p[i], u &#x3D; p[i + 1], v&#x3D; f[i][x][y];\n\t\t\t\tif(x &#x3D;&#x3D; y || x &#x3D;&#x3D; z || y &#x3D;&#x3D; z) continue;\n\t\t\t\tf[i + 1][x][y] &#x3D; min(f[i + 1][x][y], v + w[z][u]);\n\t\t\t\tf[i + 1][z][y] &#x3D; min(f[i + 1][z][y], v + w[x][u]);\n\t\t\t\tf[i + 1][x][z] &#x3D; min(f[i + 1][x][z], v + w[y][u]);\n\t\t\t&#125;\n\t\n\tint res &#x3D; INF;\n\tfor (int x &#x3D; 1; x &lt;&#x3D; m; x++)\n\t\tfor (int y &#x3D; 1; y &lt;&#x3D; m; y++)\n\t\t&#123;\n\t\t\tint z &#x3D; p[n];\n\t\t\tif(x &#x3D;&#x3D; y || x &#x3D;&#x3D; z || y &#x3D;&#x3D; z) continue;\n\t\t\tres &#x3D; min(res, f[n][x][y]);\n\t\t&#125;\n\tprintf(&quot;%d\\n&quot;, res);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;传纸条\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 55;\nint n, m, w[N][N], f[N&lt;&lt;1][N][N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t\tscanf(&quot;%d&quot;, &amp;w[i][j]);\n\t\n\tfor (int k &#x3D; 2; k &lt;&#x3D; n + m; k++)&#x2F;&#x2F;cur_steps\n\t\tfor (int x1 &#x3D; max(1, k - m); x1 &lt;&#x3D; min(k - 1, n); x1++)\n\t\t\tfor (int x2 &#x3D; max(1, k - m); x2 &lt;&#x3D; min(k - 1, n); x2++)\n\t\t\t&#123;\n\t\t\t\tint t &#x3D; w[x1][k - x1];&#x2F;&#x2F;k&#x3D;&#x3D; x&#x3D;&#x3D; (k-x)&#x3D;&#x3D;\n\t\t\t\tif(x2 !&#x3D; x1) t +&#x3D; w[x2][k - x2];\n\t\t\t\tfor (int a &#x3D; 0; a &lt;&#x3D; 1; a++)\n\t\t\t\t\tfor (int b &#x3D; 0; b &lt;&#x3D; 1; b++)\n\t\t\t\t\t\tf[k][x1][x2] &#x3D; max(f[k][x1][x2], f[k - 1][x1 - a][x2 - b] + t);\n\t\t\t&#125;\n\n\tcout &lt;&lt; f[n + m][n][n] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;I-区域\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 16;\n\nint n, m, k;\nint w[N][N];\nint f[N][N * N][N][N][2][2];&#x2F;&#x2F;ij[lr]xy\n\nstruct State\n&#123;\n\tint i, j, l, r, x, y;\n&#125;g[N][N * N][N][N][2][2];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )\n\t\t\tcin &gt;&gt; w[i][j];\n\n\tmemset(f, -0x3f, sizeof f);&#x2F;&#x2F;init不合法，k&#x3D;&#x3D;0\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; k; j ++ )&#x2F;&#x2F;共选k个格子\n\t\t\tfor (int l &#x3D; 1; l &lt;&#x3D; m; l ++ )\n\t\t\t\tfor (int r &#x3D; l; r &lt;&#x3D; m; r ++ )&#x2F;&#x2F;r&gt;&#x3D;l\n\t\t\t\t&#123;\n\t\t\t\t\tif (j &lt; r - l + 1) continue;\n\n\t\t\t\t\t&#x2F;&#x2F; 左扩张，右扩张\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tauto &amp;vf &#x3D; f[i][j][l][r][1][0];&#x2F;&#x2F;ans最大权值和\n\t\t\t\t\t\tauto &amp;vg &#x3D; g[i][j][l][r][1][0];&#x2F;&#x2F;struct&#123;i-1状态&#125;\n\t\t\t\t\t\tif (j &#x3D;&#x3D; r - l + 1) vf &#x3D; 0;&#x2F;&#x2F;起点,已有vf&#x3D;0\n\t\t\t\t\t\tfor (int p &#x3D; l; p &lt;&#x3D; r; p ++ )\n\t\t\t\t\t\t\tfor (int q &#x3D; p; q &lt;&#x3D; r; q ++ )\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tint val &#x3D; f[i - 1][j - (r - l + 1)][p][q][1][0];\n\t\t\t\t\t\t\t\tif (vf &lt; val)&#x2F;&#x2F;max(val) 更新\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tvf &#x3D; val;\n\t\t\t\t\t\t\t\t\tvg &#x3D; &#123;i - 1, j - (r - l + 1), p, q, 1, 0&#125;;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tfor (int u &#x3D; l; u &lt;&#x3D; r; u ++ ) vf +&#x3D; w[i][u];\n\t\t\t\t\t&#125;\n\n\t\t\t\t\t&#x2F;&#x2F; 左扩张，右收缩\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tauto &amp;vf &#x3D; f[i][j][l][r][1][1];\n\t\t\t\t\t\tauto &amp;vg &#x3D; g[i][j][l][r][1][1];\n\t\t\t\t\t\tfor (int p &#x3D; l; p &lt;&#x3D; r; p ++ )&#x2F;&#x2F;\n\t\t\t\t\t\t\tfor (int q &#x3D; r; q &lt;&#x3D; m; q ++ )&#x2F;&#x2F;\n\t\t\t\t\t\t\t\tfor (int y &#x3D; 0; y &lt;&#x3D; 1; y ++ )&#x2F;&#x2F;\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tint val &#x3D; f[i - 1][j - (r - l + 1)][p][q][1][y];&#x2F;&#x2F;\n\t\t\t\t\t\t\t\t\tif (vf &lt; val)\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\tvf &#x3D; val;\n\t\t\t\t\t\t\t\t\t\tvg &#x3D; &#123;i - 1, j - (r - l + 1), p, q, 1, y&#125;;\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tfor (int u &#x3D; l; u &lt;&#x3D; r; u ++ ) vf +&#x3D; w[i][u];\n\t\t\t\t\t&#125;\n\n\t\t\t\t\t&#x2F;&#x2F; 左收缩，右扩张\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tauto &amp;vf &#x3D; f[i][j][l][r][0][0];\n\t\t\t\t\t\tauto &amp;vg &#x3D; g[i][j][l][r][0][0];\n\t\t\t\t\t\tfor (int p &#x3D; 1; p &lt;&#x3D; l; p ++ )\n\t\t\t\t\t\t\tfor (int q &#x3D; l; q &lt;&#x3D; r; q ++ )\n\t\t\t\t\t\t\t\tfor (int x &#x3D; 0; x &lt;&#x3D; 1; x ++ )\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tint val &#x3D; f[i - 1][j - (r - l + 1)][p][q][x][0];\n\t\t\t\t\t\t\t\t\tif (vf &lt; val)\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\tvf &#x3D; val;\n\t\t\t\t\t\t\t\t\t\tvg &#x3D; &#123;i - 1, j - (r - l + 1), p, q, x, 0&#125;;\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tfor (int u &#x3D; l; u &lt;&#x3D; r; u ++ ) vf +&#x3D; w[i][u];\n\t\t\t\t\t&#125;\n\n\t\t\t\t\t&#x2F;&#x2F; 左收缩，右收缩\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tauto &amp;vf &#x3D; f[i][j][l][r][0][1];\n\t\t\t\t\t\tauto &amp;vg &#x3D; g[i][j][l][r][0][1];\n\t\t\t\t\t\tfor (int p &#x3D; 1; p &lt;&#x3D; l; p ++ )\n\t\t\t\t\t\t\tfor (int q &#x3D; r; q &lt;&#x3D; m; q ++ )\n\t\t\t\t\t\t\t\tfor (int x &#x3D; 0; x &lt;&#x3D; 1; x ++ )\n\t\t\t\t\t\t\t\t\tfor (int y &#x3D; 0; y &lt;&#x3D; 1; y ++ )\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\tint val &#x3D; f[i - 1][j - (r - l + 1)][p][q][x][y];\n\t\t\t\t\t\t\t\t\t\tif (vf &lt; val)\n\t\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\t\tvf &#x3D; val;\n\t\t\t\t\t\t\t\t\t\t\tvg &#x3D; &#123;i - 1, j - (r - l + 1), p, q, x, y&#125;;\n\t\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tfor (int u &#x3D; l; u &lt;&#x3D; r; u ++ ) vf +&#x3D; w[i][u];\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\t\n\tint res &#x3D; 0;\n\tState state;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tfor (int l &#x3D; 1; l &lt;&#x3D; m; l ++ )\n\t\t\tfor (int r &#x3D; 1; r &lt;&#x3D; m; r ++ )\n\t\t\t\tfor (int x &#x3D; 0; x &lt;&#x3D; 1; x ++ )\n\t\t\t\t\tfor (int y &#x3D; 0; y &lt;&#x3D; 1; y ++ )\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tint val &#x3D; f[i][k][l][r][x][y];\n\t\t\t\t\t\tif (res &lt; val)\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tres &#x3D; val;\n\t\t\t\t\t\t\tstate &#x3D; &#123;i, k, l, r, x, y&#125;;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\n\tprintf(&quot;Oil : %d\\n&quot;, res);\n\n\twhile (state.j)&#x2F;&#x2F;j:k-&gt;1\n\t&#123;\n\t\tfor (int i &#x3D; state.l; i &lt;&#x3D; state.r; i ++ ) printf(&quot;%d %d\\n&quot;, state.i, i);&#x2F;&#x2F;行 列\n\t\tstate &#x3D; g[state.i][state.j][state.l][state.r][state.x][state.y];\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;饼干\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 31, M &#x3D; 5010;\n\nint n, m;&#x2F;&#x2F;孩子 饼干\nPII g[N];&#x2F;&#x2F;&#123;i的怨气值, i&#125;\nint s[N];&#x2F;&#x2F;怨气值前缀和\nint f[N][M];&#x2F;&#x2F;状态：前i人共分j块饼干\nint ans[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tcin &gt;&gt; g[i].first;\n\t\tg[i].second &#x3D; i;\n\t&#125;\n\tsort(g + 1, g + n + 1);\n\treverse(g + 1, g + n + 1);\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) s[i] &#x3D; s[i - 1] + g[i].first;\n\n\tmemset(f, 0x3f, sizeof f);\n\tf[0][0] &#x3D; 0;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#x2F;&#x2F; 孩子\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) &#x2F;&#x2F; 饼干\n\t\t&#123;\n\t\t\tif(j &lt; i) continue;&#x2F;&#x2F;每人至少一块饼干\n\t\t\tf[i][j] &#x3D; f[i][j - i];\n\t\t\tfor(int k &#x3D; 1; k &lt;&#x3D; i; k++)\n\t\t\t\tf[i][j] &#x3D; min(f[i][j], f[i - k][j - k] + (s[i] - s[i - k]) * (i - k));\n\t\t&#125;\n\t\n\tcout &lt;&lt; f[n][m] &lt;&lt; endl;\n\t\n\tint i &#x3D; n, j &#x3D; m, h &#x3D; 0;&#x2F;&#x2F;h:整体向上偏移量\n\twhile(i)\n\t&#123;\n\t\tif(f[i][j] &#x3D;&#x3D; f[i][j - i]) j -&#x3D; i, h++;\n\t\telse\n\t\t&#123;\n\t\t\tfor(int k &#x3D; 1; k &lt;&#x3D; i; k++)\n&#x2F;*    while (i &amp;&amp; j)\n\t&#123;\n\t\tif (j &gt;&#x3D; i &amp;&amp; f[i][j] &#x3D;&#x3D; f[i][j - i]) j -&#x3D; i, h ++ ;\n\t\telse\n\t\t&#123;\n\t\t\tfor (int k &#x3D; 1; k &lt;&#x3D; i &amp;&amp; k &lt;&#x3D; j; k ++ ) *&#x2F;\n\t\t\t\tif(f[i][j] &#x3D;&#x3D; f[i - k][j - k] + (s[i] - s[i - k]) * (i - k))\n\t\t\t\t&#123;\n\t\t\t\t\tfor(int u &#x3D;  i - k + 1; u &lt;&#x3D; i; u++) ans[g[u].second] &#x3D; 1 + h;\n\t\t\t\t\ti -&#x3D; k, j -&#x3D; k;&#x2F;&#x2F;去掉只拿一块饼干的人\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;\n\tcout &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x52.背包\n&#x2F;&#x2F;0&#x2F;1bag\n&#x2F;&#x2F;数字组合 数字不等\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 10010;\n\nint n, m;\nint f[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tf[0] &#x3D; 1;\n\twhile(n--)\n\t&#123;\n\t\tint v;\n\t\tcin &gt;&gt; v;\n\t\tfor(int i &#x3D; m; i &gt;&#x3D; v; i--) f[i] +&#x3D; f[i - v];\n\t&#125;\n\n\tcout &lt;&lt; f[m] &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;完全bag \n&#x2F;&#x2F;自然数拆分Lunatic版 数字可重复 无序\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 10010;\n\nint n, m;\nunsigned f[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tf[0] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; i; j &lt;&#x3D; n; j++)\n\t\t\tf[j] +&#x3D; f[j - i];\n\t&#x2F;&#x2F;(int)2147483648 &#x3D;&#x3D; -2147483648 溢出为-INF;C++语法 ...%abs()\n\tcout &lt;&lt; (f[n] - 1) % 2147483648u &lt;&lt; endl;\n\t\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;陪审团\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 210, M &#x3D; 810, base &#x3D; 400;\n\nint n, m;\nint p[N], d[N];\nint f[N][21][M];&#x2F;&#x2F;n,取m,差值\nint ans[N];\n\nint main()\n&#123;\n\tint T &#x3D; 1;\n\twhile(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)\n\t&#123;\n\t\tfor(int i &#x3D; 1;i &lt;&#x3D; n; i++) scanf(&quot;%d%d&quot;, &amp;p[i], &amp;d[i]);\n\n\t\tmemset(f, -0x3f, sizeof f);\n\t\tf[0][0][base] &#x3D; 0;\n\t\t\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt;&#x3D; m; j++)\n\t\t\t\tfor (int k &#x3D; 0; k &lt;&#x3D; M; k++)\n\t\t\t\t&#123;\n\t\t\t\t\tf[i][j][k] &#x3D; f[i - 1][j][k];\n\t\t\t\t\tint t &#x3D; k - (p[i] - d[i]);\n\t\t\t\t\tif(t &lt; 0 ||  t &gt;&#x3D; M) continue;&#x2F;&#x2F;差值不合法\n\t\t\t\t\tif(j &lt; 1) continue;&#x2F;&#x2F;j-1&gt;&#x3D;0\n\t\t\t\t\tf[i][j][k] &#x3D; max(f[i][j][k], f[i - 1][j - 1][t] + p[i] + d[i]);&#x2F;&#x2F;选i,不选i\n\t\t\t\t&#125;\n\t\t&#x2F;&#x2F;abs(差值)&#x3D;&#x3D;0时不存在方案f&lt;0，扩大差值v++\n\t\tint v &#x3D; 0;\n\t\twhile(f[n][m][base - v] &lt; 0 &amp;&amp; f[n][m][base + v] &lt; 0) v++;\n\t\t&#x2F;&#x2F;abs(v)&#x3D;&#x3D; , d+p&#x3D;f_max\n\t\tif(f[n][m][base - v] &gt; f[n][m][base + v]) v &#x3D; base - v;\n\t\telse v &#x3D; base + v;\n\n\t\t&#x2F;&#x2F;选了哪些人ans[cnt]\n\t\tint cnt &#x3D; 0;\n\t\tint i &#x3D; n, j &#x3D; m, k &#x3D; v;\n\t\twhile(j)\n\t\t&#123;\n\t\t\tif(f[i][j][k] &#x3D;&#x3D; f[i - 1][j][k]) i--;&#x2F;&#x2F;不选i\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tans[cnt ++ ] &#x3D; i;&#x2F;&#x2F;记录i\n\t\t\t\tk -&#x3D; (p[i] - d[i]);&#x2F;&#x2F;更新\n\t\t\t\ti--, j--;\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;求sum_p sum_d\n\t\tint sp &#x3D; 0, sd &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; cnt; i++)\n\t\t&#123;\n\t\t\tsp +&#x3D; p[ans[i]];\n\t\t\tsd +&#x3D; d[ans[i]];\n\t\t&#125;\n\n\t\tprintf(&quot;Jury #%d\\n&quot;, T++);\n\t\tprintf(&quot;Best jury has value %d for prosecution and value %d for defence:\\n&quot;, sp, sd);\n\t\tfor (int i &#x3D; 0; i &lt; cnt; i++) printf(&quot; %d\\n&quot;, ans[i]);\n\t\tputs(&quot;\\n&quot;);\n\n\t\treturn 0;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;多重bag\n&#x2F;&#x2F;硬币\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110, M &#x3D; 100010;\n\nint n, m;\nint v[N], s[N];\nint f[M], g[M];\n\nint main()\n&#123;\n\twhile(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)\n\t&#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;v[i]);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;s[i]);\n\t\t\n\t\tmemset(f, 0, sizeof f);\n\n\t\tf[0] &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t&#123;\n\t\t\tmemset(g, 0, sizeof g);\n\t\t\tfor (int j &#x3D; i; j &lt;&#x3D; m; j++)\n\t\t\t\tif(!f[j] &amp;&amp; f[j - v[i]] &amp;&amp; g[j - v[i]] &lt; s[i])\n\t\t\t\t&#123;\n\t\t\t\t\tf[j] &#x3D; 1;\n\t\t\t\t\tg[j] &#x3D; g[j - v[i]] + 1;\n\t\t\t\t&#125;\n\t\t&#125;\n\n\t\tint res &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) res +&#x3D; f[i];\n\n\t\tprintf(&quot;%d\\n&quot;, res);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;分组bag\n&#x2F;&#x2F;0x53.区间DP\n&#x2F;&#x2F;石子合并\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 310, INF &#x3D; 0x3f3f3f3f;\n\nint n;\nint w[N], s[N];\nint f[N][N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; w[i];\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) s[i] &#x3D; s[i - 1] + w[i];\n\n\tfor (int len &#x3D; 2; len &lt;&#x3D; n; len ++ )&#x2F;&#x2F;阶段:len\n\t\tfor (int l &#x3D; 1; l + len - 1 &lt;&#x3D; n; l ++ )&#x2F;&#x2F;状态l\n\t\t&#123;\n\t\t\tint r &#x3D; l + len - 1;&#x2F;&#x2F;状态r\n\t\t\tf[l][r] &#x3D; INF;\n\t\t\tfor(int k &#x3D; l; k &lt; r; k++)&#x2F;&#x2F;决策:划分点k\n\t\t\t\tf[l][r] &#x3D; min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);\n\t\t&#125;\n\tprintf(&quot;%d\\n&quot;, f[1][n]);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;多边形\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110, INF &#x3D; 32768;&#x2F;&#x2F;N &#x3D; 55 * 2\n\nint n;\nchar c[N];&#x2F;&#x2F;op_char\nint w[N];&#x2F;&#x2F;op_num\nint f[N][N], g[N][N];&#x2F;&#x2F;Max, min\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) \n\t&#123;\n\t\tcin &gt;&gt; c[i] &gt;&gt; w[i];\n\t\tc[i + n] &#x3D; c[i];&#x2F;&#x2F;长度2N的链\n\t\tw[i + n] &#x3D; w[i];\n\t&#125;\n\tfor (int len &#x3D; 1; len &lt;&#x3D; n; len ++ )&#x2F;&#x2F;阶段:len\n\t\tfor (int l &#x3D; 1; l + len - 1 &lt;&#x3D; n * 2; l ++ )&#x2F;&#x2F;状态l\n\t\t&#123;\n\t\t\tint r &#x3D; l + len - 1;&#x2F;&#x2F;状态r\n\t\t\tif(len &#x3D;&#x3D; 1) f[l][r] &#x3D; g[l][r] &#x3D; w[l];\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tf[l][r] &#x3D; -INF, g[l][r] &#x3D; INF;\n\t\t\t\tfor(int k &#x3D; l; k &lt; r; k++)&#x2F;&#x2F;决策:划分点k\n\t\t\t\t&#123;\n\t\t\t\t\tchar op &#x3D; c[k + 1];\n\t\t\t\t\tint minl &#x3D; g[l][k], maxl &#x3D; f[l][k], minr &#x3D; g[k + 1][r], maxr &#x3D; f[k + 1][r];\n\t\t\t\t\tif(op &#x3D;&#x3D; &#39;t&#39;)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tf[l][r] &#x3D; max(f[l][r], maxl + maxr);\n\t\t\t\t\t\tg[l][r] &#x3D; min(g[l][r], minl + minr);\n\t\t\t\t\t&#125;\n\t\t\t\t\telse\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tint x1 &#x3D; minl * minr, x2 &#x3D; minl * maxr, x3 &#x3D; maxl * minr, x4 &#x3D; maxl * maxr;\n\t\t\t\t\t\tf[l][r] &#x3D; max(f[l][r], max(max(x1, x2),max(x3, x4)));\n\t\t\t\t\t\tg[l][r] &#x3D; min(g[l][r], min(min(x1, x2),min(x3, x4)));\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\tint res &#x3D; INF;\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) res &#x3D; max(res, f[i][i + n - 1]);\n\tcout &lt;&lt; res &lt;&lt; endl;\n\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif(res &#x3D;&#x3D; f[i][i + n - 1]) cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;金字塔\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef long long LL;\n\nconst int N &#x3D; 310, mod &#x3D; 1e9;\n\nstring str;\nint f[N][N];\n\nint main()\n&#123;\n\tcin &gt;&gt; str;\n\tint n &#x3D; str.size();\n\tif(n % 2 &#x3D;&#x3D; 0) puts(&quot;0&quot;);\n\telse\n\t&#123;\n\t\tfor(int len &#x3D; 1; len &lt;&#x3D; n; len +&#x3D; 2)\n\t\t\tfor(int l &#x3D; 0; l + len - 1 &lt; n; l++)\n\t\t\t&#123;\n\t\t\t\tint r &#x3D; l + len - 1;\n\t\t\t\tif(len &#x3D;&#x3D; 1) f[l][r] &#x3D; 1;\n\t\t\t\telse if (str[l] &#x3D;&#x3D; str[r])\n\t\t\t\t&#123;&#x2F;&#x2F;子树划分决策&#123;(前part子问题f)*(最后一颗子树的f)&#125;求和\n\t\t\t\t\tfor(int k &#x3D; l; k &lt; r; k +&#x3D; 2)\n\t\t\t\t\t\tif(str[k] &#x3D;&#x3D; str[r])\n\t\t\t\t\t\t\tf[l][r] &#x3D; (f[l][r] + (LL)f[l][k] * f[k + 1][r - 1]) % mod;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\tcout &lt;&lt; f[0][n - 1] &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x54.树形DP\n&#x2F;&#x2F;没有上司的舞会\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 6010, INF &#x3D; 0x3f3f3f3f;\n\nint n;\nint h[N], e[N], w[N], ne[N], idx;\nint f[N][2];\nbool st[N];\n\nvoid add(int a, int b)\n&#123;\n\te[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid dfs(int u)\n&#123;\n\tf[u][1] &#x3D; w[u];\n\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])\n\t&#123;\n\t\tint j &#x3D; e[i];\n\t\tdfs(j);\n\t\tf[u][0] +&#x3D; max(f[j][0], f[j][1]);&#x2F;&#x2F;\n\t\tf[u][1] +&#x3D; f[j][0];&#x2F;&#x2F;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);&#x2F;&#x2F;happy值\n\tmemset(h, -1, sizeof h);\n\tfor (int i &#x3D; 0; i &lt; n - 1; i ++ )&#x2F;&#x2F;n-1条边\n\t&#123;\n\t\tint a, b;\n\t\tscanf(&quot;%d%d&quot;, &amp;a, &amp;b);\n\t\tadd(b, a);\n\t\tst[a] &#x3D; true;&#x2F;&#x2F;有父节点\n\t&#125;\n\n\tint root &#x3D; 1;\n\twhile (st[root]) root ++ ;\n\n\tdfs(root);\n\n\tprintf(&quot;%d\\n&quot;, max(f[root][0], f[root][1]));\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;背包类树形DP \n&#x2F;&#x2F;树形背包：必须选择父亲节点才能选择其子节点，求一定体积下的最大点权和\n&#x2F;&#x2F;选课\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 310;\n\nint n, m;\nint h[N], e[N], ne[N], idx;\nint w[N];\nint f[N][N];\n\nvoid add(int a, int b)\n&#123;\n\te[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid dfs(int u)\n&#123;\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])&#x2F;&#x2F;i !&#x3D; -1 子树&#x3D;&#x3D;物品组\n\t&#123;\n\t\tint son &#x3D; e[i];\n\t\tdfs(son);\n\t\t&#x2F;&#x2F;留出fa!!!\n\t\tfor (int j &#x3D; m - 1; j; j -- )&#x2F;&#x2F;先至多选m-1门\n\t\t\tfor (int k &#x3D; 1; k &lt;&#x3D; j; k ++ )\n\t\t\t\tf[u][j] &#x3D; max(f[u][j], f[u][j - k] + f[son][k]);&#x2F;&#x2F;idea同金字塔\n\t&#125;\n\t&#x2F;&#x2F;选上fa&#x3D;&#x3D;u  倒序:保证f[u][i - 1]没改\n\tfor (int i &#x3D; m; i; i -- ) f[u][i] &#x3D; f[u][i - 1] + w[u];\n\t&#x2F;&#x2F;f：自底向上维护！！！\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;&#x2F;&#x2F;n选m\n\n\tmemset(h, -1, sizeof h);&#x2F;&#x2F;init:-1\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tint father;\n\t\tcin &gt;&gt; father &gt;&gt; w[i];\n\t\tadd(father, i);\n\t&#125;\n\n\tm ++ ;&#x2F;&#x2F;虚拟root:0\n\tdfs(0);\n\n\tcout &lt;&lt; f[0][m] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;递归O(NMM)-&gt;可优化至O(NM)\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;5321&#x2F;\n&#x2F;&#x2F;树形背包DP:O(NM)\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;blackjack_&#x2F;article&#x2F;details&#x2F;77652426\n&#x2F;&#x2F;扩展题：ACWing 10. 有依赖的背包问题\n\n\n&#x2F;&#x2F;二次扫描与换根法\n&#x2F;&#x2F;积蓄程度  yxc\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 200010, M &#x3D; N * 2, INF &#x3D; 0x3f3f3f3f;\n\nint n;\nint h[N], e[M], w[M], ne[M], idx;\nint d[N], f[N], deg[N];\n\nvoid add(int x, int y, int z) \n&#123;\n\te[idx] &#x3D; y, w[idx] &#x3D; z, ne[idx] &#x3D; h[x], h[x] &#x3D; idx++;\n&#125;\n\nint dfs_d(int u, int fa)\n&#123;\n\tif (deg[u] &#x3D;&#x3D; 1)&#x2F;&#x2F;叶子结点\n\t&#123;\n\t\td[u] &#x3D; INF;&#x2F;&#x2F;向下流量无limit\n\t\treturn d[u];\n\t&#125;\n\n\td[u] &#x3D; 0;\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])\n\t&#123;\n\t\tint j &#x3D; e[i];\n\t\tif (j &#x3D;&#x3D; fa) continue;\n\t\td[u] +&#x3D; min(dfs_d(j, u), w[i]);\n\t&#125;\n\treturn d[u];\n&#125;\n\nvoid dfs_f(int u, int fa)\n&#123;\n\tfor (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])\n\t&#123;\n\t\tint j &#x3D; e[i];\n\t\tif (j &#x3D;&#x3D; fa) continue;\n\t\tif (deg[j] &#x3D;&#x3D; 1) f[j] &#x3D; min(w[i], f[u] - w[i]);\n\t\telse\n\t\t&#123;\n\t\t\tf[j] &#x3D; d[j] + min(f[u] - min(d[j], w[i]), w[i]);&#x2F;&#x2F;下+上\n\t\t\tdfs_f(j, u);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main() \n&#123;\n\tint T;\n\tcin &gt;&gt; T;\n\twhile (T--) \n\t&#123;\n\t\tcin &gt;&gt; n;\n\n\t\tmemset(h, -1, sizeof h);\n\t\tidx &#x3D; 0;\n\t\tmemset(deg, 0, sizeof deg); \n\n\t\tfor (int i &#x3D; 0; i &lt; n - 1; i++)\n\t\t&#123;\n\t\t\tint x, y, z;\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);\n\t\t\tadd(x, y, z), add(y, x, z);\n\t\t\tdeg[x]++, deg[y]++;\n\t\t&#125;\n&#x2F;*\n如果一开始跑dfs的是出海口，那么dp[u]为0，再减一个数字就变成负数了。\n所以选择一个度数大于1的节点作为根节点；如果所有点的度数均为1，说明是两点一边，特判。\n*&#x2F;\n\t\tint root &#x3D; 1;\n\t\twhile (root &lt;&#x3D; n &amp;&amp; deg[root] &#x3D;&#x3D; 1) root ++ ;\n\n\t\tif (root &gt; n)\n\t\t&#123;\n\t\t\tcout &lt;&lt; w[0] &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tdfs_d(root, -1);\n\n\t\tf[root] &#x3D; d[root];\n\t\tdfs_f(root, -1);\n\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) ans &#x3D; max(ans, f[i]);&#x2F;&#x2F;f_max\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;积蓄程度  标程版\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 200010, M &#x3D; N * 2;\n\nint d[N], v[N], f[N], deg[N];\nint head[N], ver[M], edge[M], Next[M];\nint n, T, tot, root, ans;\n\nvoid add(int x, int y, int z) &#123;\n\tver[++tot] &#x3D; y, edge[tot] &#x3D; z, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid dp(int x) &#123;\n\tv[x] &#x3D; 1; &#x2F;&#x2F; 访问标记\n\td[x] &#x3D; 0;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123; &#x2F;&#x2F; 邻接表存储\n\t\tint y &#x3D; ver[i];\n\t\tif (v[y]) continue;\n\t\tdp(y);\n\t\tif (deg[y] &#x3D;&#x3D; 1) d[x] +&#x3D; edge[i]; &#x2F;&#x2F; edge[i]保存c(x,y),等价于d[y]&#x3D;INF:需加特判\n\t\telse d[x] +&#x3D; min(d[y], edge[i]); \n\t&#125;\n&#125;\n\nvoid dfs(int x) &#123;\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (v[y]) continue;\n\t\tif (deg[x] &#x3D;&#x3D; 1) f[y] &#x3D; d[y] + edge[i];&#x2F;&#x2F;角度不同而已！\n\t\telse f[y] &#x3D; d[y] + min(f[x] - min(d[y], edge[i]), edge[i]);\n\t\tdfs(y);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; T;\n\twhile (T--) &#123;\n\t\ttot &#x3D; 1;\n\t\tcin &gt;&gt; n;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\thead[i] &#x3D; f[i] &#x3D; d[i] &#x3D; deg[i] &#x3D; v[i] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\t\tint x, y, z;\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);\n\t\t\tadd(x, y, z), add(y, x, z);\n\t\t\tdeg[x]++, deg[y]++;\n\t\t&#125;\n\t\tint root &#x3D; 1; &#x2F;&#x2F; 任选一个点为源点\n\t\tdp(root);&#x2F;&#x2F;--&gt;d\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) v[i] &#x3D; 0;\n\t\tf[root] &#x3D; d[root];\n\t\tdfs(root);&#x2F;&#x2F;换根 d--&gt;f\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tans &#x3D; max(ans, f[i]);&#x2F;&#x2F;f_max\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;0x55.环形DP\n&#x2F;&#x2F;休息时间 策略一:分情况\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 4000, INF &#x3D; 0x3f3f3f3f;\n\nint n, m;\nint f[2][N][2];&#x2F;&#x2F;i:滚动数组  滚起来:&amp; 1\nint w[N];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; w[i];\n\n\tmemset(f, -0x3f, sizeof f);\n\tf[1][0][0] &#x3D; f[1][1][1] &#x3D; 0;\n\t&#x2F;&#x2F; 第n小时不在睡觉\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; m; j ++ )\n\t\t&#123;\n\t\t\tf[i &amp; 1][j][0] &#x3D; max(f[i - 1 &amp; 1][j][0], f[i - 1 &amp; 1][j][1]);\n\t\t\tf[i &amp; 1][j][1] &#x3D; -INF;\n\t\t\tif (j) f[i &amp; 1][j][1] &#x3D; max(f[i - 1 &amp; 1][j - 1][0], f[i - 1 &amp; 1][j - 1][1] + w[i]);\n\t\t&#125;\n\n\tint res &#x3D; f[n &amp; 1][m][0];\n\n\t&#x2F;&#x2F; 第n小时在睡觉\n\tmemset(f, -0x3f, sizeof f);\n\tf[1][1][1] &#x3D; w[1];\n\tf[1][0][0] &#x3D; 0;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; m; j ++ )\n\t\t&#123;\n\t\t\tf[i &amp; 1][j][0] &#x3D; max(f[i - 1 &amp; 1][j][0], f[i - 1 &amp; 1][j][1]);\n\t\t\tf[i &amp; 1][j][1] &#x3D; -INF;\n\t\t\tif (j) f[i &amp; 1][j][1] &#x3D; max(f[i - 1 &amp; 1][j - 1][0], f[i - 1 &amp; 1][j - 1][1] + w[i]);\n\t\t&#125;\n\n\tres &#x3D; max(res, f[n &amp; 1][m][1]);\n\n\tcout &lt;&lt; res &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;环路运输  策略二:破环成链\n&#x2F;&#x2F;转化为单调队列:滑动窗口求极值\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 2000010;\n\nint n;\nint w[N], q[N];&#x2F;&#x2F;库存 单调队列\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;w[i]);\n\t\tw[i + n] &#x3D; w[i];\n\t&#125;\n\n\tint res &#x3D; 0;\n\t&#x2F;&#x2F; 对于每个i, 寻找一个j, 使 i-j &lt;&#x3D; n&#x2F;2 且 Aj - j 最大\n\tint hh &#x3D; 0, tt &#x3D; -1;&#x2F;&#x2F;单调(递减)队列求max模板\n\tint len &#x3D; n &#x2F; 2;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n * 2; i ++ )\n\t&#123;\n\t\tif (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; i - len) hh ++ ;\n\t\tres &#x3D; max(res, i - q[hh] + w[q[hh]] + w[i]);&#x2F;&#x2F;q[hh] &#x3D;&#x3D; j   先求max\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; w[q[tt]] - q[tt] &lt;&#x3D; w[i] - i) tt -- ;\n\t\tq[ ++ tt] &#x3D; i;&#x2F;&#x2F;再加入\n\t&#125;\n\n\tprintf(&quot;%d\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;有后效性的状态转移方程\n&#x2F;&#x2F;坏掉的机器人  数学期望DP(倒推)套高斯消元\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nint n, m;\nint x, y;\ndouble f[N][N];\ndouble a[N][N];\n\nvoid gauss()\n&#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )&#x2F;&#x2F;每行非零:左中右末 留中&#x3D;&#x3D;1 末\n\t&#123;\n\t\tdouble r &#x3D; a[i][i];&#x2F;&#x2F;主元归一化\n\t\ta[i][i] &#x2F;&#x3D; r, a[i][i + 1] &#x2F;&#x3D; r;&#x2F;&#x2F;中右\n\t\tif(i &lt; m) a[i][m + 1] &#x2F;&#x3D; r;&#x2F;&#x2F;末\n\n\t\tdouble t &#x3D; a[i + 1][i];&#x2F;&#x2F;左\n\n\t\tint d[3] &#x3D; &#123;i, i + 1, m + 1&#125;;\n\t\tfor (int j &#x3D; 0; j &lt; 3; j ++ )\n\t\t\ta[i + 1][d[j]] -&#x3D; t * a[i][d[j]];&#x2F;&#x2F;消左:i+1行 -&#x3D; 左*(a[i][i]&#x3D;&#x3D;1)\n\t&#125;\n\n\tfor (int i &#x3D; m; i; i -- )&#x2F;&#x2F;自下向上: i-1行 -&#x3D; a[i - 1][i] * i行\n\t&#123;\n\t\ta[i - 1][m + 1] -&#x3D; a[i - 1][i] * a[i][m + 1];\n\t\ta[i - 1][i] -&#x3D; a[i - 1][i] * a[i][i];&#x2F;&#x2F;消右\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tcin &gt;&gt; x &gt;&gt; y;\n\n\tif (m &#x3D;&#x3D; 1) printf(&quot;%.4lf\\n&quot;, 2.0 * (n - x));\n\telse\n\t&#123;\n\t\tfor (int i &#x3D; n - 1; i &gt;&#x3D; x; i -- )&#x2F;&#x2F;1~n行 i+1\n\t\t&#123;\n\t\t\ta[1][1] &#x3D; 2.0 &#x2F; 3, a[1][2] &#x3D; -1.0 &#x2F; 3, a[1][m + 1] &#x3D; f[i + 1][1] &#x2F; 3 + 1;\n\t\t\ta[m][m] &#x3D; 2.0 &#x2F; 3, a[m][m - 1] &#x3D; -1.0 &#x2F; 3, a[m][m + 1] &#x3D; f[i + 1][m] &#x2F; 3 + 1;\n\t\t\tfor (int j &#x3D; 2; j &lt; m; j ++ )\n\t\t\t&#123;\n\t\t\t\ta[j][j - 1] &#x3D; -1.0 &#x2F; 4, a[j][j] &#x3D; 3.0 &#x2F; 4, a[j][j + 1] &#x3D; -1.0 &#x2F; 4;\n\t\t\t\ta[j][m + 1] &#x3D; f[i + 1][j] &#x2F; 4 + 1;\n\t\t\t&#125;\n\n\t\t\tgauss();\n\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) f[i][j] &#x3D; a[j][m + 1];&#x2F;&#x2F; 末&#x2F;(中&#x3D;&#x3D;1)\n\t\t&#125;\n\n\t\tprintf(&quot;%.4lf\\n&quot;, f[x][y]);\n\t\t&#x2F;&#x2F; cout.setf(std::ios::fixed);\n\t\t&#x2F;&#x2F; cout &lt;&lt; setprecision(4) &lt;&lt; f[x][y];\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;0x56.状压DP\n&#x2F;&#x2F;蒙德里安的梦想 yxc\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N &#x3D; 12, M &#x3D; 1 &lt;&lt; N;\n\nint n, m;\nLL f[N][M];\n&#x2F;&#x2F; vector&lt;int&gt; state[M];&#x2F;&#x2F;预处理\nbool st[M];&#x2F;&#x2F;是否合法\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m, n || m)\n\t&#123;\n\t\tfor (int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i ++ )\n\t\t&#123;\n\t\t\tint cnt &#x3D; 0;&#x2F;&#x2F;连续0的个数\n\t\t\tbool is_valid &#x3D; true;\n\t\t\tfor(int j &#x3D; 0; j &lt; n; j++)&#x2F;&#x2F;竖切 向右\n\t\t\t\tif(i &gt;&gt; j &amp; 1)&#x2F;&#x2F;遇1\n\t\t\t\t&#123;\n\t\t\t\t\tif(cnt &amp; 1)&#x2F;&#x2F;连续奇数个0\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tis_valid &#x3D; false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t\tcnt &#x3D; 0;\n\t\t\t\t&#125;\n\t\t\t\telse cnt ++;\n\t\t\tif(cnt &amp; 1) is_valid &#x3D; false;\n\t\t\tst[i] &#x3D; is_valid;\n\t\t&#125;\n&#x2F;&#x2F; \t\tfor (int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i ++ )\n&#x2F;&#x2F; \t\t&#123;\n&#x2F;&#x2F; \t\t\tstate[i].clear();\n&#x2F;&#x2F; \t\t\tfor (int j &#x3D; 0; j &lt; 1 &lt;&lt; n; j ++ )\n&#x2F;&#x2F; \t\t\t\tif ((i &amp; j) &#x3D;&#x3D; 0 &amp;&amp; st[i | j])\n&#x2F;&#x2F; \t\t\t\t\tstate[i].push_back(j);\n&#x2F;&#x2F; \t\t&#125;\n\n\t\tmemset(f, 0, sizeof f);\n\t\tf[0][0] &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n\t\t\tfor (int j &#x3D; 0; j &lt; 1 &lt;&lt; n; j ++ )\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 1 &lt;&lt; n; k ++ )&#x2F;&#x2F;\n\t\t\t\t\tif ((j &amp; k) &#x3D;&#x3D; 0 &amp;&amp; st[j | k])&#x2F;&#x2F;\n\t\t\t\t&#x2F;&#x2F; for (auto k : state[j])\n\t\t\t\t\t\tf[i][j] +&#x3D; f[i - 1][k];\n\n\t\tcout &lt;&lt; f[m][0] &lt;&lt; endl;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;标程版\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\nusing namespace std;\nint n, m;\nlong long f[12][1 &lt;&lt; 11];&#x2F;&#x2F;LL\nbool in_s[1 &lt;&lt; 11];\n\nint main()  &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;\n\t\tfor (int i &#x3D; 0; i &lt; 1 &lt;&lt; m; i++) &#123;\n\t\t\tbool cnt &#x3D; 0, has_odd &#x3D; 0;\n\t\t\tfor (int j &#x3D; 0; j &lt; m; j++)\n\t\t\t\tif (i &gt;&gt; j &amp; 1) has_odd |&#x3D; cnt, cnt &#x3D; 0;&#x2F;&#x2F;\n\t\t\t\telse cnt ^&#x3D; 1;&#x2F;&#x2F;\n\t\t\tin_s[i] &#x3D; has_odd | cnt ? 0 : 1;&#x2F;&#x2F;\n\t\t&#125;\n\t\tf[0][0] &#x3D; 1;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt; 1 &lt;&lt; m; j++) &#123;\n\t\t\t\tf[i][j] &#x3D; 0;\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 1 &lt;&lt; m; k++)\n\t\t\t\t\tif ((j&amp;k) &#x3D;&#x3D; 0 &amp;&amp; in_s[j | k])&#x2F;&#x2F;\n\t\t\t\t\t\tf[i][j] +&#x3D; f[i - 1][k];\n\t\t\t&#125;\n\t\tcout &lt;&lt; f[n][0] &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;炮兵阵地\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 110, M &#x3D; 10, S &#x3D; 1 &lt;&lt; M;\n\nint n, m;\nint g[N];\nint f[2][S][S];\nvector&lt;int&gt; state;\nint cnt[S];\n\nbool check(int s)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; m; i ++ )\n\t\tif ((s &gt;&gt; i &amp; 1) &amp;&amp; ((s &gt;&gt; i + 1 &amp; 1) || (s &gt;&gt; i + 2 &amp; 1)))\n\t\t\treturn false;&#x2F;&#x2F;两个1距离&lt;3\n\treturn true;\n&#125;\n\nint count(int s)&#x2F;&#x2F;1的个数\n&#123;\n\tint res &#x3D; 0;\n\twhile (s)\n\t&#123;\n\t\tres +&#x3D; s &amp; 1;\n\t\ts &gt;&gt;&#x3D; 1;\n\t&#125;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; m; j ++ )\n\t\t&#123;\n\t\t\tchar c;\n\t\t\tcin &gt;&gt; c;\n\t\t\tif (c &#x3D;&#x3D; &#39;H&#39;) g[i] +&#x3D; 1 &lt;&lt; j;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;预处理\n\tfor (int i &#x3D; 0; i &lt; 1 &lt;&lt; m; i ++ )\n\t\tif (check(i))\n\t\t&#123;\n\t\t\tstate.push_back(i);\n\t\t\tcnt[i] &#x3D; count(i);\n\t\t&#125;\n\n\tfor (int i &#x3D; 0; i &lt; n + 2; i ++ )&#x2F;&#x2F;0~n-1 n行n+1行全0\n\t\tfor (int j &#x3D; 0; j &lt; state.size(); j ++ )\n\t\t\tfor (int k &#x3D; 0; k &lt; state.size(); k ++ )\n\t\t\t\tfor (int u &#x3D; 0; u &lt; state.size(); u ++ )\n\t\t\t\t&#123;\n\t\t\t\t\tint a &#x3D; state[u], b &#x3D; state[j], c &#x3D; state[k];&#x2F;&#x2F;ujk\n\t\t\t\t\tif ((a &amp; b) || (a &amp; c) || (b &amp; c)) continue;&#x2F;&#x2F;没错开\n\t\t\t\t\tif (g[i] &amp; c) continue;&#x2F;&#x2F;H&amp;炮兵 &#x3D;&#x3D; 1（存在炮兵站在山地上）\n\t\t\t\t\tf[i &amp; 1][j][k] &#x3D; max(f[i &amp; 1][j][k], f[i - 1 &amp; 1][u][j] + cnt[c]);\n\t\t\t\t&#125;\n\n\tcout &lt;&lt; f[n + 1 &amp; 1][0][0] &lt;&lt; endl;&#x2F;&#x2F;n行n+1行全0\n\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;宝藏\n\n&#x2F;&#x2F;0x57.倍增优化DP\n&#x2F;&#x2F;开车旅行\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;LL, int&gt; PLI;\n\nconst int N &#x3D; 100010, M &#x3D; 17;&#x2F;&#x2F;(1&lt;&lt; M-1) &lt; N\nconst LL INF &#x3D; 1e12;\n\nint n;\nint h[N];\nint ga[N], gb[N];\nint f[M][N][2];\nLL da[M][N][2], db[M][N][2];\n\nvoid init_g()\n&#123;\n\tset&lt;PLI&gt; S;&#x2F;&#x2F;有序集合\n\tS.insert(&#123;INF, 0&#125;), S.insert(&#123;INF + 1, 0&#125;);&#x2F;&#x2F;val,index set:val不等\n\tS.insert(&#123;-INF, 0&#125;), S.insert(&#123;-INF - 1, 0&#125;);\n\n\tfor (int i &#x3D; n; i; i -- )\n\t&#123;\n\t\tPLI t(h[i], i);\n\t\tauto j &#x3D; S.lower_bound(t);&#x2F;&#x2F;&gt;&#x3D;t的min: 3\n\t\tj ++ ;&#x2F;&#x2F;4\n\t\tvector&lt;PLI&gt; cand;\n\t\tfor (int k &#x3D; 0; k &lt; 4; k ++ )\n\t\t&#123;\n\t\t\tcand.push_back(*j);&#x2F;&#x2F;迭代器取val j&#x3D;4321递减\n\t\t\tj -- ;\n\t\t&#125;\n\t\tLL d1 &#x3D; INF, d2 &#x3D; INF;&#x2F;&#x2F;最小次小val\n\t\tint p1 &#x3D; 0, p2 &#x3D; 0;&#x2F;&#x2F;最小次小index\n\t\tfor (int k &#x3D; 3; k &gt;&#x3D; 0; k -- )\n\t\t&#123;\n\t\t\tLL d &#x3D; abs(h[i] - cand[k].first);&#x2F;&#x2F;d&#x3D;abs(hi-hj)\n\t\t\tif (d &lt; d1)&#x2F;&#x2F;!!!\n\t\t\t&#123;\n\t\t\t\td2 &#x3D; d1, d1 &#x3D; d;\n\t\t\t\tp2 &#x3D; p1, p1 &#x3D; cand[k].second;\n\t\t\t&#125;\n\t\t\telse if (d &lt; d2)&#x2F;&#x2F;!!!\n\t\t\t&#123;\n\t\t\t\td2 &#x3D; d;\n\t\t\t\tp2 &#x3D; cand[k].second;\n\t\t\t&#125;\n\t\t&#125;\n\t\tga[i] &#x3D; p2, gb[i] &#x3D; p1;&#x2F;&#x2F;a次小 b最小\n\n\t\tS.insert(t);\n\t&#125;\n&#125;\n\nvoid init_f()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; M; i ++ )\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n\t\t&#123;\n\t\t\tif (!i) f[0][j][0] &#x3D; ga[j], f[0][j][1] &#x3D; gb[j];\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 2; k ++ )\n\t\t\t\t&#123;\n\t\t\t\t\tif (i &#x3D;&#x3D; 1) f[1][j][k] &#x3D; f[0][f[0][j][k]][1 - k];\n\t\t\t\t\telse f[i][j][k] &#x3D; f[i - 1][f[i - 1][j][k]][k];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n\nint get_dist(int a, int b)\n&#123;\n\treturn abs(h[a] - h[b]);\n&#125;\n\nvoid init_d()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; M; i ++ )\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n\t\t&#123;\n\t\t\tif (!i)\n\t\t\t&#123;\n\t\t\t\tda[0][j][0] &#x3D; get_dist(j, ga[j]), da[0][j][1] &#x3D; 0;\n\t\t\t\tdb[0][j][1] &#x3D; get_dist(j, gb[j]), db[0][j][0] &#x3D; 0;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 2; k ++ )\n\t\t\t\t&#123;\n\t\t\t\t\tif (i &#x3D;&#x3D; 1)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tda[1][j][k] &#x3D; da[0][j][k] + da[0][f[0][j][k]][1 - k];\n\t\t\t\t\t\tdb[1][j][k] &#x3D; db[0][j][k] + db[0][f[0][j][k]][1 - k];\n\t\t\t\t\t&#125;\n\t\t\t\t\telse\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tda[i][j][k] &#x3D; da[i - 1][j][k] + da[i - 1][f[i - 1][j][k]][k];\n\t\t\t\t\t\tdb[i][j][k] &#x3D; db[i - 1][j][k] + db[i - 1][f[i - 1][j][k]][k];\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n\nvoid calc(int p, int x, int &amp;la, int &amp;lb)&#x2F;&#x2F;st:p 最多走x\n&#123;\n\tla &#x3D; lb &#x3D; 0;&#x2F;&#x2F;累计行驶路程\n\tfor (int i &#x3D; M - 1; i &gt;&#x3D; 0; i -- )&#x2F;&#x2F;递减倍增 &lt;&#x3D;x就更新\n\t\tif (f[i][p][0] &amp;&amp; la + lb + da[i][p][0] + db[i][p][0] &lt;&#x3D; x)\n\t\t&#123;\n\t\t\tla +&#x3D; da[i][p][0], lb +&#x3D; db[i][p][0];\n\t\t\tp &#x3D; f[i][p][0];\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]);\n\n\tinit_g();&#x2F;&#x2F;next_city\n\tinit_f();\n\tinit_d();\n\n\tint p, x;\n\tscanf(&quot;%d&quot;, &amp;x);\n\tint res &#x3D; 0, max_h &#x3D; 0;\n\tdouble min_ratio &#x3D; INF;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tint la, lb;\n\t\tcalc(i, x, la, lb);\n\t\tdouble ratio &#x3D; lb ? (double)la &#x2F; lb : INF;&#x2F;&#x2F;\n\t\tif (ratio &lt; min_ratio || ratio &#x3D;&#x3D; min_ratio &amp;&amp; h[i] &gt; max_h)&#x2F;&#x2F;\n\t\t&#123;\n\t\t\tmin_ratio &#x3D; ratio;\n\t\t\tmax_h &#x3D; h[i];\n\t\t\tres &#x3D; i;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, res);\n\n\tint m;\n\tscanf(&quot;%d&quot;, &amp;m);\n\twhile (m -- )\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;p, &amp;x);&#x2F;&#x2F;st:p &lt;&#x3D;x\n\t\tint la, lb;\n\t\tcalc(p, x, la, lb);\n\t\tprintf(&quot;%d %d\\n&quot;, la, lb);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;计算重复\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N &#x3D; 110, M &#x3D; 31;&#x2F;&#x2F;0~30\n\nint n1, n2;\nstring s1, s2;\nLL f[N][M];\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; s2 &gt;&gt; n2 &gt;&gt; s1 &gt;&gt; n1)\n\t&#123;\n\t\tbool fail &#x3D; false;\n\n\t\tint sz &#x3D; s1.size();\n\t\tfor (int i &#x3D; 0; i &lt; sz; i ++ )\n\t\t&#123;\n\t\t\tint p &#x3D; i;\n\t\t\tf[i][0] &#x3D; 0;\n\t\t\tfor (int j &#x3D; 0; j &lt; s2.size(); j ++ )\n\t\t\t&#123;\n\t\t\t\tint cnt &#x3D; 0;\n\t\t\t\twhile (s1[p] !&#x3D; s2[j])  &#x2F;&#x2F; 找到下一个s2[j]\n\t\t\t\t&#123;\n\t\t\t\t\tp &#x3D; (p + 1) % sz;\n\t\t\t\t\tif (++cnt &gt;&#x3D; sz)&#x2F;&#x2F; 无解\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tfail &#x3D; true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tif (fail) break;\n\t\t\t\tp &#x3D; (p + 1) % sz;\n\t\t\t\tf[i][0] +&#x3D; cnt + 1;&#x2F;&#x2F; 初值\n\t\t\t&#125;\n\t\t\tif (fail) break;\n\t\t&#125;\n\n\t\tif (fail)&#x2F;&#x2F; 多组数据\n\t\t&#123;\n\t\t\tcout &lt;&lt; 0 &lt;&lt; endl;\n\t\t\tcontinue;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 预处理\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; 30; j ++ )\n\t\t\tfor (int i &#x3D; 0; i &lt; sz; i ++ )\n\t\t\t\tf[i][j] &#x3D; f[i][j - 1] + f[(i + f[i][j - 1]) % sz][j - 1];\n\n\t\t&#x2F;&#x2F; 拼凑\n\t\tLL res &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; sz; i ++ )\n\t\t&#123;\n\t\t\tLL p &#x3D; i, t &#x3D; 0;&#x2F;&#x2F;st:p t&#x3D;(2^k)求和\n\t\t\tfor (int k &#x3D; 30; k &gt;&#x3D; 0; k -- )\n\t\t\t\tif (p + f[p % sz][k] &lt;&#x3D; sz * n1)\n\t\t\t\t&#123;\n\t\t\t\t\tp +&#x3D; f[p % sz][k];\n\t\t\t\t\tt +&#x3D; 1 &lt;&lt; k;\n\t\t\t\t&#125;\n\t\t\tres &#x3D; max(res, t);&#x2F;&#x2F;m&#39;&#x3D;max_t\n\t\t&#125;\n\n\t\tcout &lt;&lt; res &#x2F; n2 &lt;&lt; endl;&#x2F;&#x2F;m&#x3D;m&#39;&#x2F;n2\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;AcWing907.区间覆盖  贪心\n\n&#x2F;&#x2F;0x58.ds优化DP\n&#x2F;&#x2F;清理班次 \n&#x2F;&#x2F;(可贪心做: sort+scan)\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 1000001;\nint n, m, p &#x3D; 1, ans &#x3D; 0, nxt[N];\nint main() &#123;\n\tscanf(&quot;%d%d&quot;, &amp;m, &amp;n);\n\tfor (int i &#x3D; 0, l, r; i &lt; m; i++) \n\t\tscanf(&quot;%d%d&quot;, &amp;l, &amp;r), nxt[l] &#x3D; max(nxt[l], r);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) nxt[i] &#x3D; max(nxt[i], nxt[i - 1]);\n\twhile(p &lt;&#x3D; n &amp;&amp; nxt[p] &gt;&#x3D; p) p &#x3D; nxt[p] + 1, ans++;\n\tprintf(&quot;%d\\n&quot;, p &lt;&#x3D; n ? -1 : ans);\n\treturn 0;\n&#125;\n&#x2F;*\n作者：墨染空\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;6640&#x2F;\n来源：AcWing\n*&#x2F;\n\n&#x2F;&#x2F;法2：SegTree优化DP\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 25010, T &#x3D; 1000010, INF &#x3D; 1e8;\n\nint n, m;\nstruct Range\n&#123;\n\tint l, r;\n\tbool operator&lt; (const Range &amp;t)const\n\t&#123;\n\t\treturn r &lt; t.r;&#x2F;&#x2F;右端点递增\n\t&#125;\n&#125;range[N];\n\nstruct Node\n&#123;\n\tint l, r, v;\n&#125;tr[T * 4];\n\nvoid build(int u, int l, int r)&#x2F;&#x2F;node_u:[l,r]\n&#123;\n\ttr[u] &#x3D; &#123;l, r, INF&#125;;&#x2F;&#x2F;new_node\n\tif (l &#x3D;&#x3D; r) return;\n\tint mid &#x3D; l + r &gt;&gt; 1;\n\tbuild(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n&#125;\n\nvoid pushup(int u)&#x2F;&#x2F;子info更新父info:min_v\n&#123;\n\ttr[u].v &#x3D; min(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);\n&#125;\n\nvoid update(int u, int k, int v)&#x2F;&#x2F;k&#x3D;&#x3D;r 1~r\n&#123;\n\tif (tr[u].l &#x3D;&#x3D; tr[u].r)\n\t&#123;\n\t\ttr[u].v &#x3D; min(tr[u].v, v);\n\t\treturn;\n\t&#125;\n\tint mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n\tif (k &lt;&#x3D; mid) update(u &lt;&lt; 1, k, v);\n\telse update(u &lt;&lt; 1 | 1, k, v);\n\tpushup(u);&#x2F;&#x2F;向上更新min_v\n&#125;\n\nint query(int u, int l, int r)\n&#123;\n\tif (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].v;\n\tint mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n\tint res &#x3D; INF;\n\tif (l &lt;&#x3D; mid) res &#x3D; query(u &lt;&lt; 1, l, r);\n\tif (r &gt; mid) res &#x3D; min(res, query(u &lt;&lt; 1 | 1, l, r));\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\tbuild(1, 0, m);&#x2F;&#x2F;node_u:[0,m]\n\n\tfor (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d%d&quot;, &amp;range[i].l, &amp;range[i].r);\n\tsort(range, range + n);\n\n\tupdate(1, 0, 0);&#x2F;&#x2F;f[0]&#x3D;0\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint l &#x3D; range[i].l, r &#x3D; range[i].r;\n\t\tint v &#x3D; query(1, l - 1, r - 1) + 1;  &#x2F;&#x2F; f[r]&#x3D;min_v[l-1,r) + 1\n\t\tupdate(1, r, v);&#x2F;&#x2F;更新f[r]\n\t&#125;\n\n\tint res &#x3D; query(1, m, m);&#x2F;&#x2F;右端点range[l,r]&#x3D;&#x3D;m f[m]\n\tif (res &#x3D;&#x3D; INF) res &#x3D; -1;\n\n\tprintf(&quot;%d\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;清理班次2\t\tDP法易扩展\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N &#x3D; 10010, M &#x3D; 90000;\nconst LL INF &#x3D; 1e15;&#x2F;&#x2F;&gt;500000*10000\n\nint n, m, e;&#x2F;&#x2F;[m,e]\nstruct Range\n&#123;\n\tint l, r, w;\n\tbool operator&lt; (const Range &amp;t) const\n\t&#123;\n\t\treturn r &lt; t.r;\n\t&#125;\n&#125;range[N];\n\nstruct Node\n&#123;\n\tint l, r;\n\tLL v;\n&#125;tr[M * 4];\n\nvoid pushup(int u)\n&#123;\n\ttr[u].v &#x3D; min(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);\n&#125;\n\nvoid build(int u, int l, int r)\n&#123;\n\ttr[u] &#x3D; &#123;l, r, INF&#125;;\n\tif (l &#x3D;&#x3D; r) return;\n\tint mid &#x3D; l + r &gt;&gt; 1;\n\tbuild(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n&#125;\n\nvoid update(int u, int k, LL v)&#x2F;&#x2F;[l,k]\n&#123;\n\tif (tr[u].l &#x3D;&#x3D; tr[u].r)\n\t&#123;\n\t\ttr[u].v &#x3D; min(tr[u].v, v);\n\t\treturn;\n\t&#125;\n\n\tint mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n\tif (k &lt;&#x3D; mid) update(u &lt;&lt; 1, k, v);\n\telse update(u &lt;&lt; 1 | 1, k, v);\n\tpushup(u);\n&#125;\n\nLL query(int u, int l, int r)\n&#123;\n\tif (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].v;\n\n\tint mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n\tLL res &#x3D; INF;\n\tif (l &lt;&#x3D; mid) res &#x3D; query(u &lt;&lt; 1, l, r);\n\tif (r &gt; mid) res &#x3D; min(res, query(u &lt;&lt; 1 | 1, l, r));\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e);\n\tbuild(1, m - 1, e);&#x2F;&#x2F;[m-1,e] 决定了min_v&#x3D;f[m-1,x]！！！\n\tupdate(1, m - 1, 0);&#x2F;&#x2F;f[m-1]&#x3D;0\n\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint l, r, w;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;w);\n\t\trange[i] &#x3D; &#123;l, r, w&#125;;\n\t&#125;\n\n\tsort(range, range + n);\n\n\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t&#123;\n\t\tint l &#x3D; range[i].l, r &#x3D; range[i].r, w &#x3D; range[i].w;\n\t\tLL v &#x3D; query(1, l - 1, r - 1) + w;  &#x2F;&#x2F; f[r]\n\t\tupdate(1, r, v);  &#x2F;&#x2F; f[r]&#x3D;v\n\t&#125;\n\n\tLL res &#x3D; query(1, e, e);&#x2F;&#x2F;f[e]&#x3D;&#x3D;f[m-1,e] 由build+update决定!\n\tif (res &#x3D;&#x3D; INF) res &#x3D; -1;\n\n\tprintf(&quot;%lld\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;赤壁之战:给定一个长度为N的序列A，求A有多少个长度为M的严格递增子序列seq。\n&#x2F;*\n&#x2F;&#x2F; f[i,j] &#x3D; sum(f[k,j-1])\t其中1&lt;&#x3D;k&lt;i, Ak&lt;Ai \t\tf[ed,len]\nfor (int i &#x3D; 1; i &lt;&#x3D; n ; i ++ )\n\tfor (int j &#x3D; 2; j &lt;&#x3D; m ; j ++ )&#x2F;&#x2F;f[i,1]&#x3D;1\n\t\tfor (int k &#x3D; 1; k &lt; i ; k ++ )\n\t\t\tif(a[k] &lt; a[i])\n\t\t\t\tf[i][j] +&#x3D; f[k][j - 1];\n&#x2F;&#x2F;(优化)单点增加,区间查询：splay难实现, 用离散化+树状数组\n&#x2F;&#x2F;改变循环顺序: ijk(会有n棵树状数组) ---&gt; jik(j~j-1)一棵\n*&#x2F;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 1010, mod &#x3D; 1e9 + 7;\n\nint n, m;\nint a[N];\nint nums[N], cnt;&#x2F;&#x2F;离散化后\nint tr[N];&#x2F;&#x2F;树状数组\nint f[N][N];&#x2F;&#x2F;f[ed,len]:以ed结尾且包含len个数的seq个数\n\nint lowbit(int x)\n&#123;\n\treturn x &amp; -x;\n&#125;\n\nvoid add(int x, int v)\n&#123;\n\tfor (int i &#x3D; x; i &lt;&#x3D; cnt ; i +&#x3D; lowbit(i))&#x2F;&#x2F;向上\n\t\ttr[i] &#x3D; (tr[i] + v) % mod;\n&#125;\n\nint sum(int x)\n&#123;\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; x; i; i -&#x3D; lowbit(i))&#x2F;&#x2F;向左\n\t\tres &#x3D; (res + tr[i]) % mod;\n\treturn res;\n&#125;\n\nint main()\n&#123;\n\tint T;\n\tscanf(&quot;%d&quot;, &amp;T);\n\tfor (int C &#x3D; 1; C &lt;&#x3D; T; C ++ )\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\t\tcnt &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;a[i]);\n\t\t\tnums[cnt ++ ] &#x3D; a[i];\n\t\t&#125;\n\t\tsort(nums, nums + cnt);\n\t\tcnt &#x3D; unique(nums, nums + cnt) - nums;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) \n\t\t\ta[i] &#x3D; lower_bound(nums, nums + cnt, a[i]) - nums + 1;&#x2F;&#x2F;tr_arr[1)\n\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) f[i][1] &#x3D; 1;&#x2F;&#x2F;init\n\t\tfor (int j &#x3D; 2; j &lt;&#x3D; m; j ++ )&#x2F;&#x2F;len\n\t\t&#123;\n\t\t\tfor (int i &#x3D; 1; i &lt;&#x3D; cnt; i ++ ) tr[i] &#x3D; 0;\n\t\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F;ed\n\t\t\t&#123;\n\t\t\t\tf[i][j] &#x3D; sum(a[i] - 1);&#x2F;&#x2F;Q前缀和\n\t\t\t\tadd(a[i], f[i][j - 1]);&#x2F;&#x2F;加入新决策Ai二元组 f[ed,len]\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tint res &#x3D; 0;&#x2F;&#x2F; 不同ed的(len&#x3D;&#x3D;m)seq数求和\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) res &#x3D; (res + f[i][m]) % mod;\n\n\t\tprintf(&quot;Case #%d: %d\\n&quot;, C, res);\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x59.单调队列优化DP  （可求解:多重背包问题 见bag_nine）\n&#x2F;&#x2F;围栏 yxc\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 16010, M &#x3D; 110;\n\nint n, m;\nint q[N];\nint f[M][N];\n\nstruct Carpenter\n&#123;\n\tint l, p, s;\n\tbool operator&lt; (const Carpenter&amp; t) const\n\t&#123;\n\t\treturn s &lt; t.s;\n\t&#125;\n&#125;car[M];\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ ) cin &gt;&gt; car[i].l &gt;&gt; car[i].p &gt;&gt; car[i].s;\n\tsort(car + 1, car + m + 1);\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )&#x2F;&#x2F;人\n\t&#123;\n\t\tint hh &#x3D; 0, tt &#x3D; -1;\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; n; j ++ )&#x2F;&#x2F;板\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 不刷k+1~j板时的转移\n\t\t\tf[i][j] &#x3D; f[i - 1][j];\n\t\t\tif (j) f[i][j] &#x3D; max(f[i][j], f[i][j - 1]);&#x2F;&#x2F;j&gt;&#x3D;1\n\t\t\t&#x2F;&#x2F; 刷k+1~j板时的转移\n\t\t\tint l &#x3D; car[i].l, p &#x3D; car[i].p, s &#x3D; car[i].s;\n\t\t\tif (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; j - l) hh ++ ;&#x2F;&#x2F;更新队头\n\t\t\tif (j &gt;&#x3D; s &amp;&amp; hh &lt;&#x3D; tt)&#x2F;&#x2F;队列非空，j &gt;&#x3D; s取队头转移\n\t\t\t&#123;\n\t\t\t\tint k &#x3D; q[hh];&#x2F;&#x2F;q[hh]&#x3D;&#x3D;区间max\n\t\t\t\tf[i][j] &#x3D; max(f[i][j], f[i - 1][k] + (j - k) * p);\n\t\t\t&#125;\n\n\t\t\tif (j &lt; s)&#x2F;&#x2F;j &lt; s入队\n\t\t\t&#123;\n\t\t\t\twhile (hh &lt;&#x3D; tt &amp;&amp; f[i - 1][q[tt]] - q[tt] * p &lt;&#x3D; f[i - 1][j] - j * p) tt -- ;&#x2F;&#x2F;while(&gt;队尾元素) 删队尾\n\t\t\t\tq[ ++ tt] &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; f[m][n] &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;标程版\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\nstruct rec&#123; int L, P, S; &#125; a[110];\nint n, m;\nint f[110][16010], q[16010];\n\nbool operator &lt;(rec a, rec b) &#123;\n\treturn a.S &lt; b.S;\n&#125;\n\nint calc(int i, int k) &#123;\n\treturn f[i - 1][k] - a[i].P * k;\n&#125;\n\nint main()  &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tscanf(&quot;%d%d%d&quot;, &amp;a[i].L, &amp;a[i].P, &amp;a[i].S);&#x2F;&#x2F;&lt;&#x3D;len 报酬 含s\n\tsort(a + 1, a + m + 1);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\t&#x2F;&#x2F; 初始化单调队列\n\t\tint l &#x3D; 1, r &#x3D; 0;\n\t\t&#x2F;&#x2F; 把最初的候选集合插入队列\n\t\tfor (int k &#x3D; max(0, a[i].S - a[i].L); k &lt;&#x3D; a[i].S - 1; k++) &#123;\n\t\t\t&#x2F;&#x2F; 插入新决策，维护队尾单调性\n\t\t\twhile (l &lt;&#x3D; r &amp;&amp; calc(i, q[r]) &lt;&#x3D; calc(i, k)) r--;\n\t\t\tq[++r] &#x3D; k;\n\t\t&#125;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\t&#x2F;&#x2F; 不粉刷时的转移\n\t\t\tf[i][j] &#x3D; max(f[i - 1][j], f[i][j - 1]);\n\t\t\t&#x2F;&#x2F; 粉刷第k+1~j块木板时的转移\n\t\t\tif (j &gt;&#x3D; a[i].S) &#123;\n\t\t\t\t&#x2F;&#x2F; 排除队头不合法决策\n\t\t\t\twhile (l &lt;&#x3D; r &amp;&amp; q[l] &lt; j - a[i].L) l++;\n\t\t\t\t&#x2F;&#x2F; 队列非空时，取队头进行状态转移\n\t\t\t\tif (l &lt;&#x3D; r) f[i][j] &#x3D; max(f[i][j], calc(i, q[l]) + a[i].P * j);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; f[m][n] &lt;&lt; endl;\n&#125;\n\n&#x2F;*\n#include &lt;queue&gt;\nbool st[N];&#x2F;&#x2F;priority_queue无删除，懒标记:pop到st&#x3D;&#x3D;false的top为止 \npriority_queue&lt;PLI, vector&lt;PLI&gt;, greater&lt;PLI&gt;&gt; heap;&#x2F;&#x2F;不支持修改\n改用\nmultiset:有序多重集，RB-Tree\n*&#x2F;\n&#x2F;&#x2F;裁剪序列\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n \nconst int N &#x3D; 100010;\n\nint n;\nLL m;\nint a[N], q[N];\nLL f[N];\n\nmultiset&lt;LL&gt; S;\n\nvoid remove(LL x)\n&#123;\n\tauto it &#x3D; S.find(x);\n\tS.erase(it);&#x2F;&#x2F;只删一个\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%lld&quot;, &amp;n, &amp;m);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;a[i]);\n\t\tif (a[i] &gt; m)\n\t\t&#123;\n\t\t\tputs(&quot;-1&quot;);\n\t\t\treturn 0;\n\t\t&#125;\n\t&#125;\n\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\tLL sum &#x3D; 0;\n\n\tfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F; [j,i]段\n\t&#123;\n\t\tsum +&#x3D; a[i];\n\t\twhile (sum &gt; m) sum -&#x3D; a[ ++ j];&#x2F;&#x2F; sum&lt;&#x3D;m --&gt; 更新j\n&#x2F;*\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; j) h++;\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) tt -- ;\n\t\tq[++tt] &#x3D; i;\n\t\t\n\t\tf[i] &#x3D; f[j] + a[q[hh]];\n\t\tfor(int k &#x3D; hh; k &lt;&#x3D; tt; k++) f[i] &#x3D; min(f[i], f[q[k]] + a[q[k + 1]]);\n*&#x2F;\n\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; j) \n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 多于一个元素(hh+1存在):才在堆S中删hh\n\t\t\tif(hh &lt; tt) remove(f[q[hh]] + a[q[hh + 1]]);\n\t\t\thh++;\n\t\t&#125;\n\t\tint tail &#x3D; tt;\n\t\twhile (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) \n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 堆S不含q的最后一个元素q[tail]...\n\t\t\tif(tt !&#x3D; tail) remove(f[q[tt]] + a[q[tt + 1]]);\n\t\t\ttt -- ;\n\t\t&#125;\n\t\t&#x2F;&#x2F; tt存在 且 tt被更新过，在堆S中删tt...(s不含q[tt]...)！！！\n\t\tif(hh &lt;&#x3D; tt &amp;&amp; tt !&#x3D; tail) remove(f[q[tt]] + a[q[tt + 1]]);\n\t\tq[++tt] &#x3D; i;\n\t\t&#x2F;&#x2F; q有&gt;1个元素,tt-1...入堆S！！！\n\t\tif(hh &lt; tt) S.insert(f[q[tt - 1]] + a[q[tt]]);\n\t\t\n\t\tf[i] &#x3D; f[j] + a[q[hh]];\n\t\tif (S.size()) f[i] &#x3D; min(f[i], *S.begin());&#x2F;&#x2F;堆头\n\t&#125;\n\n\tprintf(&quot;%lld\\n&quot;, f[n]);\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;0x5A.斜率优化DP\n&#x2F;&#x2F;任务安排1\n&#x2F;&#x2F; 法1: 前i个任务分j批\n&#x2F;&#x2F; f[i][j] &#x3D; min(f[i][j], f[k][j-1] + (s * j + st[i]) * (sc[i] - sc[k]));\n&#x2F;&#x2F; 法2：； 若干批，后续影响提前计算\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 5006;\nint n, s;\nll f[N], st[N], sc[N];\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; s;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tscanf(&quot;%lld %lld&quot;, &amp;st[i], &amp;sc[i]);\n\t\tst[i] +&#x3D; st[i-1];\n\t\tsc[i] +&#x3D; sc[i-1];\n\t&#125;\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; i; j++)\n\t\t\tf[i] &#x3D; min(f[i], f[j] + st[i] * (sc[i] - sc[j]) + s * (sc[n] - sc[j]));&#x2F;&#x2F;\n\tcout &lt;&lt; f[n] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;任务安排2 data增强:斜率优化 Ci,Ti非负\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;string&gt;\nusing namespace std;\nlong long f[300010], sumt[300010], sumc[300010];\nint q[300010], n, s;\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; s;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint t, c;\n\t\tscanf(&quot;%d%d&quot;, &amp;t, &amp;c);\n\t\tsumt[i] &#x3D; sumt[i - 1] + t;\n\t\tsumc[i] &#x3D; sumc[i - 1] + c;\n\t&#125;\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0] &#x3D; 0;\n\tint l &#x3D; 1, r &#x3D; 1;\n\tq[1] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\twhile (l &lt; r &amp;&amp; (f[q[l + 1]] - f[q[l]]) \n\t\t\t&lt;&#x3D; (s + sumt[i]) * (sumc[q[l + 1]] - sumc[q[l]])) l++;\n\t\tf[i] &#x3D; f[q[l]] - (s + sumt[i]) * sumc[q[l]]\n\t\t\t+ sumt[i] * sumc[i] + s * sumc[n];\n\t\twhile (l &lt; r &amp;&amp; (f[q[r]] - f[q[r - 1]]) * (sumc[i] - sumc[q[r]])\n\t\t\t&gt;&#x3D; (f[i] - f[q[r]]) * (sumc[q[r]] - sumc[q[r - 1]])) r--;\n\t\tq[++r] &#x3D; i;\n\t&#125;\n\tcout &lt;&lt; f[n] &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;WA!!!!!!\n&#x2F;&#x2F;任务安排3 Ti可负：不去队头，二分搜索【&gt;&#x3D;k的min斜率】的pos\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nlong long sumt[300010], sumc[300010], f[300010];\nint q[300010], n, s, l, r;\n\nint binary_search(int i, int k)\n&#123;\n\tif (l &#x3D;&#x3D; r) return q[l];\n\tint L &#x3D; l, R &#x3D; r;\n\twhile (L &lt; R)\n\t&#123;\n\t\tint mid &#x3D; (L + R) &gt;&gt; 1;\n\t\tif (f[q[mid + 1]] - f[q[mid]] &lt;&#x3D; k *\n\t\t\t(sumc[q[mid + 1]] - sumc[q[mid]])) L &#x3D; mid + 1; \n\t\telse R &#x3D; mid;&#x2F;&#x2F; 求&gt;k的min\t版本1[&lt;-向左]\tmid]\n\t&#125;\n\treturn q[L];&#x2F;&#x2F;求q[L],变为 &gt;&#x3D;k的min  最终q[L,R]:[&#x3D;...&#x3D;&gt;]k\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; s;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint t, c;\n\t\tscanf(&quot;%d%d&quot;, &amp;t, &amp;c);\n\t\tsumt[i] &#x3D; sumt[i - 1] + t, sumc[i] &#x3D; sumc[i - 1] + c;\n\t&#125;\n\tl &#x3D; r &#x3D; 1, q[1] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint p &#x3D; binary_search(i, s + sumt[i]);\n\t\tf[i] &#x3D; f[p] - (s + sumt[i]) * sumc[p]\n\t\t\t+ sumt[i] * sumc[i] + s * sumc[n];\n\t\twhile (l &lt; r &amp;&amp; (f[q[r]] - f[q[r - 1]]) * (sumc[i] - sumc[q[r]])\n\t\t\t&gt;&#x3D; (f[i] - f[q[r]]) * (sumc[q[r]] - sumc[q[r - 1]])) r--;\n\t\tq[++r] &#x3D; i;\n\t&#125;\n\tcout &lt;&lt; f[n] &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;运输小猫\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nlong long f[110][N], s[N], a[N], d[N], q[N], g[N];\nint n, m, p, i, j, k, l, r;\n\nint main()\n&#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; p;&#x2F;&#x2F;n山m猫p人\n\tfor(i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tcin &gt;&gt; j;\n\t\td[i] &#x3D; d[i-1] + j;&#x2F;&#x2F;山1~i距离的前缀和\n\t&#125;\n\tfor(i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t&#123;\n\t\tcin &gt;&gt; j &gt;&gt; k;&#x2F;&#x2F;cat_i-&gt;山Hi 玩到Ti开始等\n\t\ta[i] &#x3D; k - d[j];&#x2F;&#x2F;T玩 &#x3D; Ti - d[Hi]\n\t&#125;\n\n\tsort(a + 1, a + m + 1);\n\tfor(i &#x3D; 1; i &lt;&#x3D; m; i++) s[i] &#x3D; s[i - 1] + a[i];\n\t\n\tmemset(f, 0x3f, sizeof f);\n\tf[0][0] &#x3D; 0;\n\tfor(i &#x3D; 1; i &lt;&#x3D; p; i++)\n\t&#123;\n\t\tfor(j &#x3D; 1; j &lt;&#x3D; m; j++) g[j] &#x3D; f[i - 1][j] + s[j];&#x2F;&#x2F;y\n\t\tq[l &#x3D; r &#x3D; 1]&#x3D;0;\n\t\tfor(j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;队头斜率&lt;&#x3D;k:出队\n\t\t\twhile(l &lt; r &amp;&amp; g[q[l + 1]] - g[q[l]] &lt;&#x3D; a[j] * (q[l + 1] - q[l])) l++;\n\t\t\t&#x2F;&#x2F;用k&#x3D;q[l]转移\n\t\t\tf[i][j] &#x3D; min(f[i - 1][j], g[q[l]]+a[j] * (j - q[l]) - s[j]);\n\t\t\tif(g[j] &gt;&#x3D; 0x3f3f3f3f3f3f3f3fll) continue;&#x2F;&#x2F;best会超LL:忽略！\n\t\t\t&#x2F;&#x2F;入队\n\t\t\twhile(l &lt; r &amp;&amp; (g[j] - g[q[r]]) * (q[r] - q[r - 1]) &lt;&#x3D; (g[q[r]] - g[q[r - 1]]) * (j - q[r])) r--;\n\t\t\tq[++r] &#x3D; j;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; f[p][m] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x5B.四边形不等式\n&#x2F;&#x2F;诗人小G\n\n&#x2F;&#x2F;一个古老的石头游戏    CE????\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 50010, INF &#x3D; 0x3f3f3f3f;\n\nint n, a;\nint s[N];\nint f[N][N];\nint p[N][N];\n\nint main()\n&#123;\n\twhile(scanf(&quot;%d&quot;, &amp;n), n)\n\t&#123;\n\t\tmemset(f, INF , sizeof f);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\t&#123;\n\t\t\tscanf(&quot;%d&quot;, &amp;a);\n\t\t\ts[i] &#x3D; s[i - 1] + a;\n\t\t&#125;\n\t\t\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\t&#123;\n\t\t\tf[i][i] &#x3D; 0;\n\t\t\tp[i][i] &#x3D; i;&#x2F;&#x2F;p[][]的初始值\n\t\t&#125;\n\t\tfor (int len &#x3D; 2; len &lt;&#x3D; n; len ++ )&#x2F;&#x2F;阶段:len\n\t\t\tfor (int l &#x3D; 1; l + len - 1 &lt;&#x3D; n; l ++ )&#x2F;&#x2F;状态l\n\t\t\t&#123;\n\t\t\t\tint r &#x3D; l + len - 1;&#x2F;&#x2F;状态r\n\t\t\t\tfor(int k &#x3D; p[l][r - 1]; k &lt;&#x3D; p[l + 1][r]; k++)&#x2F;&#x2F;缩小循环范围\n\t\t\t\t&#123;\n\t\t\t\t\tif(f[l][r] &gt; min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]))\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tf[l][r] &#x3D; min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);\n\t\t\t\t\t\tp[l][r] &#x3D; k;&#x2F;&#x2F;更新最佳分割点    \n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\tprintf(&quot;%d\\n&quot;, f[1][n]);\n\t&#125;\n\treturn 0;\n&#125;\n\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;luoyj&#x2F;p&#x2F;12587356.html\n&#x2F;&#x2F;GarsiaWachs算法 O(NlogN)\n\n\n\n\n&#x2F;&#x2F;0x5C.计数类DP\n&#x2F;&#x2F;杰拉尔德和巨型象棋\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;set&gt;\n#include&lt;queue&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\ntypedef long long LL;\n#define x first\n#define y second\nconst int N &#x3D; 2010;\n\npair&lt;int, int&gt; a[N];\nint h, w, n, f[N], mod &#x3D; 1e9 + 7;\nLL jc[200010], jcinv[200010];\n\nint C(int n, int m) &#123;&#x2F;&#x2F;分子*(分母的乘法逆元)\n\treturn jc[n] * jcinv[m] % mod * jcinv[n - m] % mod;\n&#125;\n\nLL power(LL a, int b) &#123;&#x2F;&#x2F;快速幂模板\n\tLL c &#x3D; 1;\n\tfor (; b; b &gt;&gt;&#x3D; 1) &#123;\n\t\tif (b &amp; 1) c &#x3D; c*a%mod;\n\t\ta &#x3D; a * a % mod;\n\t&#125;\n\treturn c;\n&#125;\n\nint main() &#123;\n\tjc[0] &#x3D; 1, jcinv[0] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 200000; i++) &#123;\n\t\tjc[i] &#x3D; jc[i - 1] * i % mod;&#x2F;&#x2F;b&#x3D;i!%p\n\t\tjcinv[i] &#x3D; power(jc[i], mod - 2);&#x2F;&#x2F;乘法逆元b^(p-2)\n\t&#125;\n\tcin &gt;&gt; h &gt;&gt; w &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y);\n\tsort(a + 1, a + n + 1);\n\ta[n + 1].x &#x3D; h, a[n + 1].y &#x3D; w;\n\t\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n + 1; i++) &#123;\n\t\tf[i] &#x3D; C(a[i].x + a[i].y - 2, a[i].x - 1);\n\t\tfor (int j &#x3D; 1; j &lt; i; j++) &#123;\n\t\t\tif (a[j].x &gt; a[i].x || a[j].y &gt; a[i].y) continue;&#x2F;&#x2F;不会走到的点\n\t\t\tf[i] &#x3D; (f[i] - (LL)f[j] * C(a[i].x + a[i].y - a[j].x - a[j].y, a[i].x - a[j].x)) % mod;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; (f[n + 1] + mod) % mod &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;连通图 高精度。。。\n&#x2F;&#x2F;python3版\nimport sys\n\ndef power(k):\n\tres &#x3D; 1\n\tfor i in range(k * (k - 1) &#x2F;&#x2F; 2):\n\t\tres *&#x3D; 2\n\treturn res\n\ndef C(a, b):\n\tres &#x3D; 1\n\tfor i in range(1, a + 1): res *&#x3D; i\n\tfor i in range(1, b + 1): res &#x2F;&#x2F;&#x3D; i\n\tfor i in range(1, a - b + 1): res &#x2F;&#x2F;&#x3D; i\n\treturn res\n\nfor line in sys.stdin:\n\tn &#x3D; int(line)\n\tif n &#x3D;&#x3D; 0:\n\t\tbreak\n\tf &#x3D; [0 for _ in range(n + 1)]\n\tf[1] &#x3D; 1\n\tfor i in range(n + 1):\n\t\tf[i] &#x3D; power(i)\n\t\tfor j in range(1, i):\n\t\t\tf[i] -&#x3D; f[j] * C(i - 1, i - j) * power(i - j)\n\tprint(f[n])\n\n\n\n&#x2F;&#x2F;它们中的多少个  (男人八题之一  出题人:Tourist)\n&#x2F;&#x2F; H[i] 表示i个点组成的连通图个数（可以顺手做做poj1737）\n&#x2F;&#x2F; F[i,j]表示i个点构成的包含j条割边的连通图个数\n&#x2F;&#x2F; G[i,j,k]表示i个点，j条割边，分成k个连通块 的无向图个数。\n&#x2F;*\nfact[i]表示i的阶乘，而infact[i]表示i阶乘的逆元，\n即infact[i] &#x3D; fact[i]^（p - 2） mod p。\n当然具体在预处理时计算fact[i]和infact[i]都可以利用之前计算好的fact[i-1]及infact[i-1]的值，我们知道\nfact[i] &#x3D; fact[i-1] * i；\ninfact[i - 1] * fact[i - 1] mod p &#x3D; 1,设x为i的乘法逆元，故\nfact[i] * infact[i-1] * x mod p &#x3D; fact[i-1] * infact[i-1] * i * x mod p &#x3D; 1，\n故infact[i] &#x3D; infact[i-1] * x mod p，\n即i阶乘的乘法逆元 &#x3D;&#x3D; (i-1)阶乘的乘法逆元 * i的乘法逆元。\n或: infact[i-1] &#x3D; infact[i] * i mod p\n\n(i!)^-1 &#x3D; 1&#x2F;i! &#x3D; (i+1)&#x2F;(i+1)! &#x3D; (i+1) * (i+1)!^-1\n*&#x2F;\n&#x2F;&#x2F;@墨染空 大佬注释版\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\ntypedef long long LL;\n\nconst int N &#x3D; 55, M &#x3D; 1260, P &#x3D; 1e9 + 7;\nint H[N], F[N][N], G[N][N][N], fact[N], infact[N];\nint n, m;\n\nint power(int a, int b) &#123;\n\tint res &#x3D; 1;\n\twhile (b) &#123;\n\t\tif (b &amp; 1) res &#x3D; (LL)res * a % P;\n\t\ta &#x3D; (LL)a * a % P;\n\t\tb &gt;&gt;&#x3D; 1;\n\t&#125;\n\treturn res;\n&#125;\n\nint C(int a, int b) &#123;\n\treturn (LL) fact[a] * infact[b] % P * infact[a - b] % P;\n&#125;\n\n&#x2F;*\n函数声明！！！ 否则CE： \na.cpp: In function &#39;int g(int, int, int)&#39;:\na.cpp:31:29: error: &#39;f&#39; was not declared in this scope\n*&#x2F;\nint f(int i, int j);\n\nint g(int i, int j, int k) &#123;&#x2F;&#x2F;删掉连通块1以后的图方案数\n\tif (k &gt;&#x3D; i || j &gt; i) return 0;&#x2F;&#x2F;割边数&lt;点数(一条链) 连通块数&lt;&#x3D;(|e|&#x3D;0)点数\n\tif (G[i][j][k] !&#x3D; -1) return G[i][j][k];&#x2F;&#x2F;记忆化\n\tint &amp;v &#x3D; G[i][j][k] &#x3D; 0;\n\t&#x2F;&#x2F;【！！！关键语句！！！】 *i：i点选1点与连通块1相连 与*p同理 \n\tif (j &#x3D;&#x3D; 1) return v &#x3D; (LL)f(i, k) * i % P;\n\tfor (int p &#x3D; 1; p &lt;&#x3D; i; p++)  &#123;&#x2F;&#x2F; 以编号最小点所在块为基准枚举\n\t\tfor (int q &#x3D; 0; q &lt;&#x3D; k; q++) &#123;\n\t\t\t&#x2F;&#x2F; *p:块内p选1与连通块1相连\n\t\t\tv &#x3D; (v + (LL) f(p, q) * C(i - 1, p - 1) % P * p % P * g(i - p, j - 1, k - q)) % P;\n\t\t&#125;\n\t&#125;\n\treturn v;\n&#125;\n\nint f(int i, int j) &#123;\n\tif (j &gt;&#x3D; i) return 0;\n\tif (F[i][j] !&#x3D; -1) return F[i][j];&#x2F;&#x2F;记忆化！！！【trick_2 ~~】\n\tint &amp;v &#x3D; F[i][j] &#x3D; 0;\n\tif (j &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;无割边\n\t\tv &#x3D; H[i];&#x2F;&#x2F;i点无向连通图数\n\t\tfor (int k &#x3D; 1; k &lt;&#x3D; i - 1; k++) v &#x3D; (v - f(i, k) + P) % P;\n\t&#125; else &#123;\n\t\tfor (int k &#x3D; 1; k &lt;&#x3D; i - 1; k++) &#123;\n\t\t\tint s &#x3D; 0;\n\t\t\tfor (int x &#x3D; 1; x &lt;&#x3D; min(i - k, j); x++) &#123;\n\t\t\t\ts &#x3D; (s + (LL)g(i - k, x, j - x) * power(k, x)) % P;\n\t\t\t&#125;\n\t\t\tv &#x3D; (v + (LL)f(k, 0) * C(i - 1, k - 1) % P * s % P) % P;\n\t\t&#125;\n\t&#125;\n\treturn v;\n&#125;\n\nint main() &#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\t&#x2F;&#x2F;O(N)预处理fact infact  【trick_1 ~~】\n\tfact[0] &#x3D; infact[0] &#x3D; H[1] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) fact[i] &#x3D; (LL) fact[i - 1] * i % P;\n\tinfact[n] &#x3D; power(fact[n], P - 2);&#x2F;&#x2F;减少power的次数 n-&gt;1倒推：越算越容易\n\t&#x2F;&#x2F;infact[i-1] &#x3D; infact[i] * i mod p\n\tfor (int i &#x3D; n - 1; i; i--) infact[i] &#x3D; (LL) infact[i + 1] * (i + 1) % P;\n\t&#x2F;&#x2F;Hi\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n\t\tH[i] &#x3D; power(2, i * (i - 1) &#x2F; 2);\n\t\tfor (int j &#x3D; 1; j &lt; i; j++) &#123;\n\t\t\tH[i] &#x3D; ((H[i] - (LL)H[j] * C(i - 1, j - 1) % P * power(2, (i - j) * (i - j - 1) &#x2F; 2)) % P + P) % P;\n\t\t&#125;\n\t&#125;\n\n\tmemset(F, -1, sizeof F);\n\tmemset(G, -1, sizeof G);\n\tF[1][0] &#x3D; 1, G[1][1][0] &#x3D; 1;\n\n\tint ans &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; m; i++) (ans +&#x3D; f(n, i)) %&#x3D; P;\n\n\tprintf(&quot;%d\\n&quot;, ans);\n&#125;\n&#x2F;&#x2F; 作者：墨染空\n&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;206906&#x2F;\n&#x2F;&#x2F; 含Tarjan暴力做法\n\n\n&#x2F;&#x2F;装饰围栏\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint t, n;\nlong long m, f[21][21][2];&#x2F;&#x2F;k:0低1高\n\nvoid prework() &#123;\n\tf[1][1][0] &#x3D; f[1][1][1] &#x3D; 1;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; 20; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;\n\t\t\tfor (int p &#x3D; j; p &lt;&#x3D; i - 1; p++)\n\t\t\t\tf[i][j][0] +&#x3D; f[i - 1][p][1];\n\t\t\tfor (int p &#x3D; 1; p &lt;&#x3D; j - 1; p++)\n\t\t\t\tf[i][j][1] +&#x3D; f[i - 1][p][0];\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tprework();\n\tcin &gt;&gt; t;\n\twhile (t--) &#123;\n\t\tcin &gt;&gt; n &gt;&gt; m;&#x2F;&#x2F;字典序排名m\n\t\tbool used[21];\n\t\tmemset(used, 0, sizeof(used));\n\t\tint last, k;\n\t\t&#x2F;&#x2F; 第1块木板，既可能处于高位，也可能处于低位，单独处理\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;&#x2F;&#x2F;枚举第1板长度排名\n\t\t\tif (f[n][j][1] &gt;&#x3D; m) &#123;&#x2F;&#x2F;先1后0:因为&#x3D;&#x3D;对2~N板先0后1(字典序)\n\t\t\t\tlast &#x3D; j, k &#x3D; 1;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse m -&#x3D; f[n][j][1];\n\t\t\tif (f[n][j][0] &gt;&#x3D; m) &#123;\n\t\t\t\tlast &#x3D; j, k &#x3D; 0;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse m -&#x3D; f[n][j][0];\n\t\t&#125;\n\t\tused[last] &#x3D; 1;\n\t\tprintf(&quot;%d&quot;, last);\n\t\t&#x2F;&#x2F; 第2~n块木板，高低位置、合法的长度范围与上一块木板有关\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n\t\t\tk ^&#x3D; 1;\n\t\t\t&#x2F;&#x2F; 真实长度为len，在【剩余木板中排名为j！！！！！！】\n\t\t\tint j &#x3D; 0;\n\t\t\tfor (int len &#x3D; 1; len &lt;&#x3D; n; len++) &#123;\n\t\t\t\tif (used[len]) continue;&#x2F;&#x2F;跳过，不j++\n\t\t\t\tj++;&#x2F;&#x2F;j&#x3D;1\n\t\t\t\tif (k &#x3D;&#x3D; 0 &amp;&amp; len &lt; last || k &#x3D;&#x3D; 1 &amp;&amp; len &gt; last) &#123;&#x2F;&#x2F;0低1高\n\t\t\t\t\tif (f[n - i + 1][j][k] &gt;&#x3D; m) &#123;&#x2F;&#x2F;cur试填第i块\n\t\t\t\t\t\tlast &#x3D; len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t\telse m -&#x3D; f[n - i + 1][j][k];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tused[last] &#x3D; 1;\n\t\t\tprintf(&quot; %d&quot;, last);\n\t\t&#125;\n\t\tputs(&quot;&quot;);\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;0x5D.数位统计DP\n&#x2F;&#x2F;启示录\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nlong long f[21][4];\nint t, n, m;\n\nvoid prework() &#123;\n\tf[0][0] &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt; 20; i++) &#123;\n\t\tfor (int j &#x3D; 0; j &lt; 3; j++) &#123;\n\t\t\tf[i + 1][j + 1] +&#x3D; f[i][j];\n\t\t\tf[i + 1][0] +&#x3D; f[i][j] * 9;\n\t\t&#125;\n\t\tf[i + 1][3] +&#x3D; f[i][3] * 10;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tprework();\n\tcin &gt;&gt; t; &#x2F;&#x2F; 数据组数\n\twhile (t--) &#123;\n\t\tscanf(&quot;%d&quot;, &amp;n); &#x2F;&#x2F; 题目中的X\n\t\t&#x2F;&#x2F; 第n个魔鬼数有m位\n\t\tfor (m &#x3D; 3; f[m][3] &lt; n; m++);&#x2F;&#x2F;&gt;&#x3D;n跳出：确定n的位数m\n\t\t&#x2F;&#x2F; 试填第i位，末尾已有k个6（k&#x3D;3也表示已经是魔鬼数）\n\t\tfor (int i &#x3D; m, k &#x3D; 0; i; i--) &#123;\n\t\t\t&#x2F;&#x2F; 从小到大枚举第i位填的数字j\n\t\t\tfor (int j &#x3D; 0; j &lt;&#x3D; 9; j++) &#123;\n\t\t\t\t&#x2F;&#x2F; 求出后边的i-1位有多少(cnt)种填法【能让整个数是魔鬼数】\n\t\t\t\tlong long cnt &#x3D; f[i - 1][3];&#x2F;&#x2F;魔\n\t\t\t\tif (j &#x3D;&#x3D; 6 || k &#x3D;&#x3D; 3)&#x2F;&#x2F;i位填6 || 末尾已有3个6\n\t\t\t\t\tfor (int l &#x3D; max(3 - k - (j &#x3D;&#x3D; 6), 0); l&lt;3; l++)&#x2F;&#x2F;\n\t\t\t\t\t\tcnt +&#x3D; f[i - 1][l];&#x2F;&#x2F;+“合法”非魔\n\t\t\t\t&#x2F;&#x2F; 如果cnt比n小，说明第n个魔鬼数的第i位应该比j更大\n\t\t\t\tif (cnt &lt; n) &#123;\n\t\t\t\t\tn -&#x3D; cnt;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; 否则，第i位就应该是j\n\t\t\t\telse &#123;\n\t\t\t\t\tif (k &lt; 3) &#123;\n\t\t\t\t\t\tif (j &#x3D;&#x3D; 6) k++; else k &#x3D; 0;\n\t\t\t\t\t&#125;\n\t\t\t\t\tprintf(&quot;%d&quot;, j);\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F;月之谜\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 200, L &#x3D; 21;\nll f[L][N][N][2];\nint n[L];\n\nll calc(ll x, int P) &#123;&#x2F;&#x2F;x:上限R  P:sum\n\tif (!x) return 0;\n\tmemset(f, 0, sizeof(f));\n\tint t &#x3D; 0;\n\twhile (x) &#123;\n\t\tn[++t] &#x3D; x % 10;&#x2F;&#x2F;n[]:上限\n\t\tx &#x2F;&#x3D; 10;\n\t&#125;\n\tf[t+1][0][0][0] &#x3D; 1;\n\tfor (int i &#x3D; t + 1; i &gt; 1; i--)&#x2F;&#x2F;高位-&gt;低位 cur试填位i\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; P; j++)&#x2F;&#x2F;j:i的高位数字cur_sum\n\t\t\tfor (int k &#x3D; 0; k &lt; P; k++)&#x2F;&#x2F;k:i的高位数cur%P余数\n\t\t\t\tif (f[i][j][k][0] || f[i][j][k][1])&#x2F;&#x2F;记忆化\n\t\t\t\t\tfor (int p &#x3D; 0; p &lt; 10; p++) &#123;&#x2F;&#x2F;枚举第i位数字\n\t\t\t\t\t\tint w &#x3D; (10 * k + p) % P;&#x2F;&#x2F;w:cur&#39;%p\n\t\t\t\t\t\tif (p &lt; n[i-1] &amp;&amp; j + p &lt;&#x3D; P)&#x2F;&#x2F;p&lt;该位上限 &amp;&amp; cur_sum&lt;&#x3D;sum\n\t\t\t\t\t\t\t&#x2F;&#x2F;当前试填i-1-&gt;i j-&#x3D;p w-&gt;k  prev+&#x3D;cur\n\t\t\t\t\t\t\tf[i-1][j+p][w][1] +&#x3D; f[i][j][k][0];&#x2F;&#x2F;【1:高位有&lt;】\n\t\t\t\t\t\telse if (p &#x3D;&#x3D; n[i-1] &amp;&amp; j + p &lt;&#x3D; P)\n\t\t\t\t\t\t\tf[i-1][j+p][w][0] +&#x3D; f[i][j][k][0];&#x2F;&#x2F;【0:都&#x3D;上限】\n\t\t\t\t\t\tif (f[i][j][k][1] &amp;&amp; j + p &lt;&#x3D; P)\n\t\t\t\t\t\t\tf[i-1][j+p][w][1] +&#x3D; f[i][j][k][1];\n\t\t\t\t\t&#125;\n\treturn f[1][P][0][0] + f[1][P][0][1];\n&#125;\n\nint main() &#123;\n\tll a, b, ans &#x3D; 0;\n\tcin &gt;&gt; a &gt;&gt; b;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 9 * 18; i++)&#x2F;&#x2F;枚举sum\n\t\tans +&#x3D; calc(b, i) - calc(a - 1, i);\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n------------------------------------------------------------------------------\n\n&#x2F;&#x2F;0x5E.总结与练习\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n\n\n\n0x60图论&#x2F;*\n学：\n#pragma GCC optimize (&quot;O3&quot;)\n#pragma GCC target (&quot;sse4&quot;)\n#define quick() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)&#x2F;&#x2F;读入优化\n*&#x2F;\n\n\n&#x2F;&#x2F;0x61.最短路 \n&#x2F;&#x2F; 单源最短路 （负权）队列优化的Bellman-Ford:SPFA   (无负权)堆优化的Dijkstra\n&#x2F;&#x2F;340\t通信线路\n&#x2F;&#x2F;法一：分层图最短路\t有后效性DP：SPFA迭代\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1006, P &#x3D; 20006, INF &#x3D; 0x3f3f3f3f;\nint n, p, k, d[N*N];\nint Head[N*N], Edge[N*P], Next[N*P], Leng[N*P], tot &#x3D; 0;\nbool v[N*N];&#x2F;&#x2F;在queue中\nqueue&lt;int&gt; q;\n\ninline void add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n\nvoid spfa() &#123;\n\tmemset(d, 0x3f, sizeof(d));\n\td[1] &#x3D; 0;\n\tv[1] &#x3D; 1;\n\tq.push(1);\n\twhile (q.size()) &#123;&#x2F;&#x2F;直至queue为空\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tv[x] &#x3D; 0;\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\t\tif (d[y] &gt; max(d[x], z)) &#123;\n\t\t\t\td[y] &#x3D; max(d[x], z);&#x2F;&#x2F;\n\t\t\t\tif (!v[y]) &#123;\n\t\t\t\t\tq.push(y);\n\t\t\t\t\tv[y] &#x3D; 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; p &gt;&gt; k;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; p; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\t&#x2F;&#x2F;伪2D节点(x,j):1-&gt;x途中已有j条边(1-&gt;任意v)(&lt;&#x3D;&gt;j列)免费\n\t\tfor (int j &#x3D; 0; j &lt;&#x3D; k; j++) &#123;&#x2F;&#x2F;不选xy边免费 \n\t\t\tadd(x + j * n, y + j * n, z);&#x2F;&#x2F;j+1列x行:(x,j)-z-&gt;(y,j)\n\t\t\tadd(y + j * n, x + j * n, z);&#x2F;&#x2F;双向\n\t\t&#125;\n\t\tfor (int j &#x3D; 0; j &lt; k; j++) &#123;&#x2F;&#x2F;j属于[0,k]\n\t\t\tadd(x + j * n, y + (j + 1) * n, 0);&#x2F;&#x2F;(x,j)-0-&gt;(y,j+1) \n\t\t\tadd(y + j * n, x + (j + 1) * n, 0);&#x2F;&#x2F;等价于同一个点,同时更新不用管\n\t\t&#125;\n\t&#125;\n\tspfa();\n\tif (d[(k+1)*n] &#x3D;&#x3D; INF) puts(&quot;-1&quot;);&#x2F;&#x2F;n行k+1列\n\telse cout &lt;&lt; d[(k+1)*n] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;法二:二分ans，deque_BFS\n\n\n&#x2F;&#x2F; 341\t最优贸易\n&#x2F;&#x2F;Author:xht37\n&#x2F;&#x2F; 如果z&#x3D;1，表示这条道路是城市 x 到城市 y 之间的单向道路；\n&#x2F;&#x2F; 如果z&#x3D;2，表示这条道路为城市 x 和城市 y 之间的双向道路。\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1e5 + 6, M &#x3D; 1e6 + 6;\nint n, m, tot, Price[N], Ans;\nint Head[N], Side[M], Next[M], ans[N];\nint fHead[N], fSide[M], fNext[M], fans[N];\npriority_queue&lt;pair&lt;int, int&gt;&gt; q;\npriority_queue&lt;pair&lt;int, int&gt;&gt; fq;\n\nvoid add(int x, int y, int z) &#123;\n\tSide[++tot] &#x3D; y, Next[tot] &#x3D; Head[x], Head[x] &#x3D; tot;\n\t&#x2F;&#x2F;反图:将所有边反向\n\tfSide[tot] &#x3D; x, fNext[tot] &#x3D; fHead[y], fHead[y] &#x3D; tot;\n\t&#x2F;&#x2F;双向边\n\tif (z &#x3D;&#x3D; 2) &#123;\n\t\tSide[++tot] &#x3D; x, Next[tot] &#x3D; Head[y], Head[y] &#x3D; tot;\n\t\tfSide[tot] &#x3D; y, fNext[tot] &#x3D; fHead[x], fHead[x] &#x3D; tot;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;Price[i]);\n\tint x, y, z;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\tadd(x, y, z);\n\t&#125;\n\tmemset(ans, 0x3f, sizeof(ans));\n\tmemset(fans, 0xcf, sizeof(fans));\n\tans[1] &#x3D; Price[1];\n\tfans[n] &#x3D; Price[n];\n\tq.push(&#123;-ans[1], 1&#125;);\n\tfq.push(&#123;fans[n], n&#125;);\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.top().second;\n\t\tq.pop();\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Side[i];\n\t\t\tif (ans[y] &gt; ans[x]) &#123;&#x2F;&#x2F;1~y最小权值\n\t\t\t\tans[y] &#x3D; min(ans[x], Price[y]);\n\t\t\t\tq.push(&#123;-ans[y], y&#125;);&#x2F;&#x2F;-ans:大根堆-&gt;小根堆 求min\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\twhile (fq.size()) &#123;\n\t\tint x &#x3D; fq.top().second;\n\t\tfq.pop();\n\t\tfor (int i &#x3D; fHead[x]; i; i &#x3D; fNext[i]) &#123;\n\t\t\tint y &#x3D; fSide[i];\n\t\t\tif (fans[y] &lt; fans[x]) &#123;&#x2F;&#x2F;y~n最大权值\n\t\t\t\tfans[y] &#x3D; max(fans[x], Price[y]);\n\t\t\t\tfq.push(&#123;fans[y], y&#125;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) Ans &#x3D; max(Ans, fans[i]-ans[i]);\n\tcout &lt;&lt; Ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;yxc\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst int N &#x3D; 100010, M &#x3D; 2000010;\n\nint n, m;\nint price[N];\nint h[N], rh[N], e[M], ne[M], idx;\nint dmin[N], dmax[N];\nbool st[N];\n\nvoid add(int *h, int a, int b)\n&#123;\n\te[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid spfa(int *d, int start, int *h, bool flag)\n&#123;\n\tqueue&lt;int&gt; q;\n\tmemset(st, 0, sizeof st);\n\n\tif (flag) memset(d, 0x3f, sizeof dmin);\n\n\tq.push(start);\n\tst[start] &#x3D; true;\n\td[start] &#x3D; price[start];\n\n\twhile (q.size())\n\t&#123;\n\t\tint t &#x3D; q.front();\n\t\tq.pop();\n\t\tst[t] &#x3D; false;\n\n\t\tfor (int i &#x3D; h[t]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif (flag &amp;&amp; d[j] &gt; min(d[t], price[j]) || !flag &amp;&amp; d[j] &lt; max(d[t], price[j]))\n\t\t\t&#123;\n\t\t\t\tif (flag) d[j] &#x3D; min(d[t], price[j]);\n\t\t\t\telse d[j] &#x3D; max(d[t], price[j]);\n\n\t\t\t\tif (!st[j])\n\t\t\t\t&#123;\n\t\t\t\t\tst[j] &#x3D; true;\n\t\t\t\t\tq.push(j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\n\tmemset(h, -1, sizeof h);\n\tmemset(rh, -1, sizeof rh);\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) scanf(&quot;%d&quot;, &amp;price[i]);\n\twhile (m -- )\n\t&#123;\n\t\tint a, b, c;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n\t\tadd(h, a, b), add(rh, b, a);&#x2F;&#x2F;h-&gt;rh:idx(正反图)交替\n\t\tif (c &#x3D;&#x3D; 2) add(h, b, a), add(rh, a, b);\n\t&#125;\n\n\tspfa(dmin, 1, h, true);\n\tspfa(dmax, n, rh, false);\n\n\tint res &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) res &#x3D; max(res, dmax[i] - dmin[i]);\n\n\tprintf(&quot;%d\\n&quot;, res);\n\n\treturn 0;\n&#125;\n\n------------------------------------------------------------------------------\n&#x2F;&#x2F; 342\t道路与航线  双向边权非负,只无环单向边可能为负权\n&#x2F;&#x2F; (不同连通块间)拓扑序SPFA 套 (连通块内)堆优化Dijkstra\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int maxT &#x3D; 25006, maxRP &#x3D; 150006, INF &#x3D; 0x3f3f3f3f;\nint T, R, P, S;\nint Head[maxT], Edge[maxRP], Cost[maxRP], Next[maxRP], totS &#x3D; 0;\nint c[maxT], deg[maxT], d[maxT], totc &#x3D; 0;&#x2F;&#x2F;c[]:点所在的连通块 totc:连通块数\nbool v[maxT];\nqueue&lt;int&gt; q;\npriority_queue&lt;pair&lt;int, int&gt;&gt; Q;\n\ninline void add(int A, int B, int C) &#123;\n\tEdge[++totS] &#x3D; B;\n\tCost[totS] &#x3D; C;\n\tNext[totS] &#x3D; Head[A];\n\tHead[A] &#x3D; totS;\n&#125;\n\nvoid dfs(int i) &#123;\n\tfor (int j &#x3D; Head[i]; j; j &#x3D; Next[j])\n\t\tif (!c[Edge[j]]) &#123;\n\t\t\tc[Edge[j]] &#x3D; totc;&#x2F;&#x2F;属于连通块totc\n\t\t\tdfs(Edge[j]);\n\t\t&#125;\n&#125;\n\nint main() &#123;\n\tmemset(d, 0x7f, sizeof(d));\n\tcin &gt;&gt; T &gt;&gt; R &gt;&gt; P &gt;&gt; S;&#x2F;&#x2F;T点 R道路 P航线 S起点\n\tfor (int i &#x3D; 1; i &lt;&#x3D; R; i++) &#123;\n\t\tint A, B, C;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C);\n\t\tadd(A, B, C);\n\t\tadd(B, A, C);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; T; i++)\n\t\tif (!c[i]) &#123;\n\t\t\tc[i] &#x3D; ++totc;&#x2F;&#x2F;属于连通块totc\n\t\t\tdfs(i);\n\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; P; i++) &#123;\n\t\tint A, B, C;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C);\n\t\tadd(A, B, C);\n\t\t++deg[c[B]];&#x2F;&#x2F;B所在连通块的总入度+1\n\t&#125;\n\tq.push(c[S]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; totc; i++) if (!deg[i]) q.push(i);\n\td[S] &#x3D; 0;\n\twhile (q.size()) &#123;\n\t\tint i &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; T; j++)\n\t\t\tif (c[j] &#x3D;&#x3D; i) Q.push(&#123;-d[j], j&#125;);&#x2F;&#x2F;块i所有节点入小根堆Q(-d[j])\n\t\twhile (Q.size()) &#123;\n\t\t\tint x &#x3D; Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif (v[x]) continue;\n\t\t\tv[x] &#x3D; 1;\n\t\t\tfor (int j &#x3D; Head[x]; j; j &#x3D; Next[j]) &#123;\n\t\t\t\tint y &#x3D; Edge[j];\n\t\t\t\tif (d[x] + Cost[j] &lt; d[y]) &#123;\n\t\t\t\t\td[y] &#x3D; d[x] + Cost[j];\n\t\t\t\t\tif (c[x] &#x3D;&#x3D; c[y]) Q.push(&#123;-d[y], y&#125;);\n\t\t\t\t&#125;\n\t\t\t\tif (c[x] !&#x3D; c[y] &amp;&amp; !--deg[c[y]]) q.push(c[y]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; T; i++)\n&#x2F;&#x2F;可能存在某个点被s不能走到的点更新。因此判断无解时不能写成&#x3D;&#x3D;inf\n\t\tif (d[i] &gt; INF) puts(&quot;NO PATH&quot;);\n\t\telse printf(&quot;%d\\n&quot;, d[i]);\n\treturn 0;\n&#125;\n\n\n&#x2F;*\nSLF优化SPFA:\nSLF优化,不同于一般的SPFA算法,它是一种利用双端队列算法处理的问题.\n\n如果说当前点所花费的值少于我们当前队头点的值的话,那么我们就将这个节点插入到队头去,否则我们还是插入到队尾.\n*&#x2F;\n&#x2F;*\n堆优化，LLL优化,容错机制,SLF,SLF+Swap,xay-spfa\n记录一个权值w,w&#x3D;sqrt&#123;sum(w_i)&#125;,当dis_&#123;front&#125;+w&lt;dis_&#123;now&#125;,就把当前点加入队尾\n用前向星的话可以试试双关键字排序，边权小的排前面\n随机化插入\n\nSPFA已死：\nhttps:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;292283275&#x2F;answer&#x2F;484871888\n从原理上分析，所有 spfa 的优化都是为了使队列接近优先队列。然而，我们知道维护一个优先队列在目前来说是需要 log 的复杂度的，所以低于该复杂度的 一定能 Hack。\n*&#x2F;\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N&#x3D;400000 +100;\nint head[N],ver[N],Next[N],edge[N],vis[N],dis[N],tot;\nvoid add_edge(int a,int b,int c)\n&#123;\n\tedge[tot]&#x3D;b;\n\tver[tot]&#x3D;c;\n\tNext[tot]&#x3D;head[a];\n\thead[a]&#x3D;tot++;\n&#125;\nvoid spfa(int s)\n&#123;\n\tmemset(dis,0x3f,sizeof(dis));\n\tmemset(vis,false,sizeof(vis));\n\tdeque&lt;int&gt; q;\n\tdis[s]&#x3D;0;\n\tvis[s]&#x3D;true;\n\tq.push_back(s);\n\twhile(q.size())\n\t&#123;\n\t\tint now&#x3D;q.front();\n\t\tvis[now]&#x3D;false;\n\t\tq.pop_front();\n\t\tfor(int i&#x3D;head[now]; ~i; i&#x3D;Next[i])\n\t\t&#123;\n\t\t\tint j&#x3D;edge[i];\n\t\t\tif (dis[j]&gt;dis[now]+ver[i])\n\t\t\t&#123;\n\t\t\t\tdis[j]&#x3D;dis[now]+ver[i];\n\t\t\t\tif (!vis[j])\n\t\t\t\t&#123;\n\t\t\t\t\tvis[j]&#x3D;true;\n\t\t\t\t\tif (q.size() &amp;&amp; dis[j]&lt;dis[q.front()])&#x2F;&#x2F;SLF优化\n\t\t\t\t\t\tq.push_front(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tq.push_back(j);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\nint main()\n&#123;\n\tint t,r,p,s,x,y,z;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin&gt;&gt;t&gt;&gt;r&gt;&gt;p&gt;&gt;s;\n\tmemset(head,-1,sizeof(head));\n\tfor(int i&#x3D;1; i&lt;&#x3D;r; i++)\n\t&#123;\n\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n\t\tadd_edge(x,y,z);\n\t\tadd_edge(y,x,z);\n\t&#125;\n\tfor(int i&#x3D;1; i&lt;&#x3D;p; i++)\n\t&#123;\n\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n\t\tadd_edge(x,y,z);\n\t&#125;\n\tspfa(s);\n\tfor(int i&#x3D;1; i&lt;&#x3D;t; i++)\n\t&#123;\n\t\tif (dis[i]&#x3D;&#x3D;0x3f3f3f3f)\n\t\t\tcout&lt;&lt;&quot;NO PATH&quot;&lt;&lt;endl;\n\t\telse\n\t\t\tcout&lt;&lt;dis[i]&lt;&lt;endl;\n\t&#125;\n\treturn 0;\n&#125;\n\n作者：秦淮岸灯火阑珊\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;2427&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n------------------------------------------------------------------------------\n&#x2F;&#x2F;多源最短路 \n&#x2F;*\nFloyd:\nmemset(d, 0x3f, sizeof d);\nfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) d[i][i] &#x3D; 0;\nd[x][y] &#x3D; min(d[x][y],z);\n&#x2F;&#x2F; for(kij)\nd[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);\n\n传递闭包:\nbool d[N][N];\nfor_i: d[i][i] &#x3D; 1;\nd[x][y] &#x3D; d[y][x] &#x3D; 1;\n&#x2F;&#x2F; for(kij)\nd[i][j] |&#x3D; d[i][k] &amp; d[k][j];\n*&#x2F;\n\n&#x2F;&#x2F;343. 排序\t不等式全部为&lt;关系\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 30;\nint n, m, d[N][N], e[N][N];\n\nint floyd() &#123;\n\tmemcpy(e, d, sizeof(e));\n\tfor (int k &#x3D; 0; k &lt; n; k++)\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt; n; j++) &#123;\n\t\t\t\te[i][j] |&#x3D; e[i][k] &amp; e[k][j];\n\t\t\t\tif (e[i][j] &#x3D;&#x3D; e[j][i] &amp;&amp; e[i][j] &amp;&amp; i !&#x3D; j) return -1;&#x2F;&#x2F;均为1\n\t\t\t&#125;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; n; j++)\n\t\t\tif (e[i][j] &#x3D;&#x3D; e[j][i] &amp;&amp; !e[i][j] &amp;&amp; i !&#x3D; j) return 0;&#x2F;&#x2F;均为0\n\treturn 1;\n&#125;\n\nvoid Sorting_It_All_Out() &#123;\n\tmemset(d, 0, sizeof(d));\n\tbool flag &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tchar s[6];\n\t\tscanf(&quot;%s&quot;, s);\n\t\td[s[0]-&#39;A&#39;][s[2]-&#39;A&#39;] &#x3D; 1;\n\t\tif (flag) &#123;\n\t\t\tint now &#x3D; floyd();&#x2F;&#x2F;-1 0 1\n\t\t\tif (now &#x3D;&#x3D; -1) &#123;\n\t\t\t\tprintf(&quot;Inconsistency found after %d relations.\\n&quot;, i);\n\t\t\t\tflag &#x3D; 0;&#x2F;&#x2F;end\n\t\t\t&#125; else if (now &#x3D;&#x3D; 1) &#123;\n\t\t\t\tprintf(&quot;Sorted sequence determined after %d relations: &quot;, i);\n\t\t\t\tpair&lt;int, char&gt; ans[N];\n\t\t\t\tfor (int j &#x3D; 0; j &lt; n; j++) &#123;\n\t\t\t\t\tans[j].first &#x3D; 0;\n\t\t\t\t\tans[j].second &#x3D; &#39;A&#39; + j;\n\t\t\t\t&#125;&#x2F;&#x2F;&#123;&#123;0,&#39;A&#39;&#125;,&#123;0,&#39;B&#39;&#125;,...&#125;\n\t\t\t\tfor (int j &#x3D; 0; j &lt; n; j++)&#x2F;&#x2F;j&lt;k:ans[j]&#x3D;&#123;0,&#39;A&#39;&#125;-&gt;&#123;1,&#39;A&#39;&#125;\n\t\t\t\t\tfor (int k &#x3D; 0; k &lt; n; k++)\n\t\t\t\t\t\tif (e[j][k]) ++ans[j].first;\n\t\t\t\tsort(ans, ans + n);&#x2F;&#x2F;大-&gt;小：0E 1D 2C 3B 4A\n\t\t\t\tfor (int j &#x3D; n - 1; j &gt;&#x3D; 0; j--) printf(&quot;%c&quot;, ans[j].second);\n\t\t\t\tputs(&quot;.&quot;);\n\t\t\t\tflag &#x3D; 0;&#x2F;&#x2F;end\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif (flag) puts(&quot;Sorted sequence cannot be determined.&quot;);\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) Sorting_It_All_Out();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; AcWing 344. 观光之旅\t\t无向图最小环问题\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint a[310][310], d[310][310], pos[310][310];\nint n, m, ans &#x3D; 0x3f3f3f3f;\nvector&lt;int&gt; path; &#x2F;&#x2F;具体方案\n\nvoid get_path(int x, int y) &#123;\n\tif (pos[x][y] &#x3D;&#x3D; 0) return;\n\tget_path(x, pos[x][y]);\n\tpath.push_back(pos[x][y]);&#x2F;&#x2F;\n\tget_path(pos[x][y], y);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tmemset(a, 0x3f, sizeof(a));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i][i] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);\n\t\ta[y][x] &#x3D; a[x][y] &#x3D; min(a[x][y], z);\n\t&#125;\n\tmemcpy(d, a, sizeof(a));\n\tfor (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;\n\t\tfor (int i &#x3D; 1; i &lt; k; i++)\n\t\t\tfor (int j &#x3D; i + 1; j &lt; k; j++)\n\t\t\t\tif ((long long)d[i][j] + a[j][k] + a[k][i] &lt; ans) &#123;\n\t\t\t\t\tans &#x3D; d[i][j] + a[j][k] + a[k][i];\n\t\t\t\t\tpath.clear();\n\t\t\t\t\tpath.push_back(i);\n\t\t\t\t\tget_path(i, j);\n\t\t\t\t\tpath.push_back(j);\n\t\t\t\t\tpath.push_back(k);\n\t\t\t\t&#125;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif (d[i][j] &gt; d[i][k] + d[k][j]) &#123;\n\t\t\t\t\td[i][j] &#x3D; d[i][k] + d[k][j];\n\t\t\t\t\tpos[i][j] &#x3D; k;\n\t\t\t\t&#125;\n\t&#125;\n\tif (ans &#x3D;&#x3D; 0x3f3f3f3f) &#123;\n\t\tputs(&quot;No solution.&quot;);\n\t\treturn 0;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; path.size(); i++)\n\t\tprintf(&quot;%d &quot;, path[i]);\n\tputs(&quot;&quot;);\n&#125;\n\n\n&#x2F;&#x2F; AcWing 345. 牛站\n&#x2F;&#x2F;Author:XuHt\n#include &lt;map&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 206, INF &#x3D; 0x3f3f3f3f;\nint n, t, s, e, tot &#x3D; 200;\nmap&lt;int, int&gt; m;\nstruct M &#123;&#x2F;&#x2F;图的可达矩阵a~a^n\n\tint a[N][N];\n\tvoid pre() &#123;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; tot; j++)\n\t\t\t\ta[i][j] &#x3D; INF;\n\t&#125;\n&#125; st, ed;\n\nM mul(M a, M b) &#123;&#x2F;&#x2F;广义矩阵乘法\n\tM c;\n\tc.pre();\n\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; tot; j++)\n\t\t\tfor (int k &#x3D; 1; k &lt;&#x3D; tot; k++)\n\t\t\t\tc.a[i][j] &#x3D; min(c.a[i][j], a.a[i][k] + b.a[k][j]);\n\treturn c;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; t &gt;&gt; s &gt;&gt; e;&#x2F;&#x2F;s~经过n条边~&gt;e 总边数t\n\tst.pre();\n\ttot &#x3D; 0;\n\twhile (t--) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;z, &amp;x, &amp;y);\n\t\tx &#x3D; m[x] ? m[x] : (m[x] &#x3D; ++tot);&#x2F;&#x2F;所有点离散化(重新编号为tot)\n\t\ty &#x3D; m[y] ? m[y] : (m[y] &#x3D; ++tot);\n\t\tst.a[x][y] &#x3D; st.a[y][x] &#x3D; z;\n\t&#125;\n\tmemcpy(ed.a, st.a, sizeof(ed.a));\n\t--n;&#x2F;&#x2F;st[s][e]:经过一条边s-&gt;e \t故ed&#x3D;a^(n-1)\n\twhile (n) &#123;&#x2F;&#x2F;快速幂 求ed\n\t\tif (n &amp; 1) ed &#x3D; mul(ed, st);\n\t\tst &#x3D; mul(st, st);\n\t\tn &gt;&gt;&#x3D; 1;\n\t&#125;\n\tcout &lt;&lt; ed.a[m[s]][m[e]] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;0x62.最小生成树MST\n&#x2F;&#x2F; AcWing 346. 走廊泼水节\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nstruct rec &#123; int x, y, z; &#125; edge[6010];\nint fa[6010], s[6010], n, T;\nlong long ans;\nbool operator &lt;(rec a, rec b) &#123;\n\treturn a.z &lt; b.z;\n&#125;\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);&#x2F;&#x2F;\n&#125;\nint main() &#123;\n\tcin &gt;&gt; T;\n\twhile (T--) &#123;\n\t\tcin &gt;&gt; n;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].z);\n\t\tsort(edge + 1, edge + n);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfa[i] &#x3D; i, s[i] &#x3D; 1;&#x2F;&#x2F;\n\t\tans &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\t\tint x &#x3D; get(edge[i].x);\n\t\t\tint y &#x3D; get(edge[i].y);\n\t\t\tif (x &#x3D;&#x3D; y) continue;\n\t\t\tans +&#x3D; (long long)(edge[i].z + 1) * (s[x] * s[y] - 1);\n\t\t\tfa[x] &#x3D; y;\n\t\t\ts[y] +&#x3D; s[x];\n\t\t&#125;\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 347. 野餐规划\n&#x2F;&#x2F;Author:XuHt\n#include &lt;map&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 37, INF &#x3D; 0x3f3f3f3f;\nstruct E &#123;\n\tint x, y, z;\n\tbool operator &lt; (const E w) const &#123;\n\t\treturn z &lt; w.z;\n\t&#125;\n&#125; f[N];\nint n, k, tot, ans, a[N][N], fa[N], d[N], v[N];\nmap&lt;string, int&gt; m;\nvector&lt;E&gt; e;\nbool in[N][N];&#x2F;&#x2F;在生成树内\n\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\n&#x2F;&#x2F; 该过程可用树形dp实现，设dp[i].w表示1号节点到i号节点的路径上权值最大的边，dp[i].w &#x3D; max(dp[fa[i]].w, i到fa[i]的边权)。\nvoid dfs(int x, int pre) &#123;&#x2F;&#x2F;1,-1 &#x2F;&#x2F;1~u-(max:f[i].z)-v~i\n\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;\n\t\tif (i &#x3D;&#x3D; pre || !in[x][i]) continue;&#x2F;&#x2F;边(x,i)在Tr外\n\t\tif (f[i].z &#x3D;&#x3D; -1) &#123; &#x2F;&#x2F; &#x3D;&#x3D;init值\n\t\t\tif (f[x].z &gt; a[x][i]) f[i] &#x3D; f[x];&#x2F;&#x2F;1~x-i\n\t\t\telse &#123;\n\t\t\t\tf[i].x &#x3D; x;\n\t\t\t\tf[i].y &#x3D; i;\n\t\t\t\tf[i].z &#x3D; a[x][i];\n\t\t\t&#125;\n\t\t&#125;\n\t\tdfs(i, x);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tmemset(a, 0x3f, sizeof(a));\n\tmemset(d, 0x3f, sizeof(d));\n\tm[&quot;Park&quot;] &#x3D; tot &#x3D; 1;&#x2F;&#x2F;节点1:park\n\tfor (int i &#x3D; 0; i &lt; N; i++) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tE w;\n\t\tstring s1, s2;\n\t\tcin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w.z;\n\t\tw.x &#x3D; m[s1] ? m[s1] : (m[s1] &#x3D; ++tot);&#x2F;&#x2F;离散化后的点tot\n\t\tw.y &#x3D; m[s2] ? m[s2] : (m[s2] &#x3D; ++tot);\n\t\te.push_back(w);\n\t\ta[w.x][w.y] &#x3D; a[w.y][w.x] &#x3D; min(a[w.x][w.y], w.z);\n\t&#125;\n\tcin &gt;&gt; k;&#x2F;&#x2F;表示公园的最大停车数量&#x3D;&#x3D;节点1最大度数S\n\tsort(e.begin(), e.end());&#x2F;&#x2F;Kruskal求(去掉点1后)T个连通块内MST\n\tfor (unsigned int i &#x3D; 0; i &lt; e.size(); i++) &#123;\n\t\tif (e[i].x &#x3D;&#x3D; 1 || e[i].y &#x3D;&#x3D; 1) continue;&#x2F;&#x2F; || 出入park:跳过\n\t\tint rtx &#x3D; get(e[i].x), rty &#x3D; get(e[i].y);\n\t\tif (rtx !&#x3D; rty) &#123;\n\t\t\tfa[rtx] &#x3D; rty;\n\t\t\tin[e[i].x][e[i].y] &#x3D; in[e[i].y][e[i].x] &#x3D; 1;&#x2F;&#x2F;mark块内的边\n\t\t\tans +&#x3D; e[i].z;&#x2F;&#x2F;MST边权和\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++)\n\t\tif (a[1][i] !&#x3D; INF) &#123;\n\t\t\tint rt &#x3D; get(i);\n\t\t\tif (d[rt] &gt; a[1][i]) d[rt] &#x3D; a[1][v[rt]&#x3D;i];&#x2F;&#x2F;1~rt块的minEdge:(1,p)\n\t\t&#125;&#x2F;&#x2F;得到d[rt]&#x3D;a[1][p], v[rt]&#x3D;p\n\n\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++)\n\t\tif (d[i] !&#x3D; INF) &#123;&#x2F;&#x2F;T块\n\t\t\t--k;&#x2F;&#x2F;点1度数--\n\t\t\tin[1][v[i]] &#x3D; in[v[i]][1] &#x3D; 1;&#x2F;&#x2F;v[rt]&#x3D;p mark:(1,p)\n\t\t\tans +&#x3D; a[1][v[i]];\n\t\t&#125;\n\t&#x2F;&#x2F;改动S-T条边优化Spanning Tree (块内删max边 1~...连边)\n\twhile (k--) &#123;\n\t\tmemset(f, -1, sizeof(f));&#x2F;&#x2F;init\n\t\tf[1].z &#x3D; -INF;&#x2F;&#x2F;求Tr内1~x上maxEdge\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++)\n\t\t\tif (in[1][i]) f[i].z &#x3D; -INF;&#x2F;&#x2F;(1,p)的f[p].z&#x3D;-INF\n\t\tdfs(1, -1);&#x2F;&#x2F;\n\t\tint o, w &#x3D; -INF;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++)\n\t\t\tif (w &lt; f[i].z - a[1][i])\n\t\t\t\tw &#x3D; f[i].z - a[1][o&#x3D;i];&#x2F;&#x2F;最大的w-z  1~u-(max:w)-v~i 1-(z)-i\n\t\tif (w &lt;&#x3D; 0) break;\n\t\tin[1][o] &#x3D; in[o][1] &#x3D; 1;&#x2F;&#x2F;连边\n\t\tin[f[o].x][f[o].y] &#x3D; in[f[o].y][f[o].x] &#x3D; 0;&#x2F;&#x2F;删边\n\t\tans -&#x3D; w;\n\t&#125;\n\tprintf(&quot;Total miles driven: %d\\n&quot;, ans);\n\treturn 0;\n&#125;\n\n\n\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;map&gt;\nusing namespace std;\n\nconst int M &#x3D; 55;\nint n, m &#x3D; 0, k, ans &#x3D; 0;\nint ee[M][M];\nbool in[M][M];\n&#x2F;&#x2F; in表示in tree，即树边，同ee是邻接矩阵，in[i][j] &#x3D; 1表示i到j有连边 \nint tot &#x3D; 0;\nstruct edge&#123;\n\tint h, t, w;\n&#125;e[10010];\nmap &lt;string, int&gt; vis;\n\nbool cmp(edge x, edge y) &#123;\n\treturn x.w &lt; y.w;\n&#125;\n\nint fa[M];\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\nvoid Kruskal() &#123;\n\tsort(e + 1, e + tot + 1, cmp);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; ++ i) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; ++ i) &#123;\n\t\tint x &#x3D; e[i].h, y &#x3D; e[i].t, z &#x3D; e[i].w;\n\t\tint fx &#x3D; get(x), fy &#x3D; get(y);\n\t\tif (fx &#x3D;&#x3D; 1 || fy &#x3D;&#x3D; 1) continue;\n\t\t&#x2F;&#x2F; 如果为1号节点则跳过 \n\t\tif (fx !&#x3D; fy) fa[fx] &#x3D; fy, ans +&#x3D; z, in[x][y] &#x3D; in[y][x] &#x3D; 1;\n\t&#125;\n&#125;\n\nstruct edges&#123;\n\tint w, l, r;\n&#125;dp[M];\n\nvoid dfs(int depth, int pre) &#123;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; m; ++ i) &#123;\n\t\tif (i &#x3D;&#x3D; pre || !in[depth][i]) continue;\n\t\tif (dp[i].w &#x3D;&#x3D; -1) &#123;\n\t\t\tif (dp[depth].w &gt; ee[depth][i]) dp[i] &#x3D; dp[depth];\n\t\t\telse dp[i].l &#x3D; depth, dp[i].r &#x3D; i, dp[i].w &#x3D; ee[depth][i];\n\t\t&#125;\n\t\tdfs(i, depth);\n\t&#125;\n&#125;\n\nint mintree[M], tminpoint[M];\n&#x2F;&#x2F; mintree[i]为1号节点到连通块i(并查集的编号)中的最短距离（即1号节点到连通块任何一点的边的最小权值），tminpoint[i]表示上述点的编号 \nint num &#x3D; 0, minpoint, point;\n\nint main() &#123;\n\tmemset(ee, 0x3f, sizeof(ee));\n\tmemset(mintree, 0x3f, sizeof(mintree));\n\tcin &gt;&gt; n;\n\tvis[&quot;Park&quot;] &#x3D; (++ m);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; ++ i) &#123;\n\t\tstring x, y;\n\t\tint z;\n\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n\t\tif (!vis[x]) vis[x] &#x3D; (++ m);\n\t\tif (!vis[y]) vis[y] &#x3D; (++ m);\n\t\t&#x2F;&#x2F; 记录点数 \n\t\tint nx &#x3D; vis[x], ny &#x3D; vis[y];\n\t\te[++ tot].h &#x3D; nx, e[tot].t &#x3D; ny, e[tot].w &#x3D; z;\n\t\tee[nx][ny] &#x3D; ee[ny][nx] &#x3D; min(ee[nx][ny], z);\n\t&#125;\n\t&#x2F;&#x2F;邻接表 + 邻接矩阵 \n\tcin &gt;&gt; k;\n\tKruskal(); \n\tfor (int i &#x3D; 2; i &lt;&#x3D; m; ++ i) \n\t\tif (ee[1][i] &lt; 0x3f3f3f3f) &#123;\n\t\t\tint which &#x3D; get(i);\n\t\t\tif (mintree[which] &gt; ee[1][i]) &#123;\n\t\t\t\tmintree[which] &#x3D; ee[1][i];\n\t\t\t\ttminpoint[which] &#x3D; i;\n\t\t\t&#125;\n\t\t&#125;\n\t&#x2F;&#x2F; 查询1号节点到每个除1号节点连通块的最小距离即该边另一端的点的编号 \n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; ++ i)\n\t\tif (mintree[i] &lt; 0x3f3f3f3f) &#123;\n\t\t\t++ num;\n\t\t\tin[1][tminpoint[i]] &#x3D; in[tminpoint[i]][1] &#x3D; 1;\n\t\t\tans +&#x3D; ee[1][tminpoint[i]];\n\t\t&#125;   \n\t&#x2F;&#x2F; 构建最小生成树，从1号节点向所有除1号节点的连通块连边，累计答案 \n\tfor (int i &#x3D; num + 1; i &lt;&#x3D; k; ++ i) &#123;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[1].w &#x3D; -0x3f3f3f3f;\n\t\tfor (int j &#x3D; 2; j &lt;&#x3D; m; ++ j)\n\t\t\tif (in[1][j]) dp[j].w &#x3D; -0x3f3f3f3f;\n\t\tdfs(1, -1);\n\t\t&#x2F;&#x2F; 树形dp求dp数组 \n\t\tminpoint &#x3D; 0x3f3f3f3f;\n\t\tfor (int j &#x3D; 2; j &lt;&#x3D; m; ++ j) \n\t\t\tif (minpoint &gt; ee[1][j] - dp[j].w) minpoint &#x3D; ee[1][j] - dp[j].w, point &#x3D; j;\n\t\tif (minpoint &gt;&#x3D; 0) break;\n\t\t&#x2F;&#x2F; 遍历求最小1号节点到j号节点的权值 - dp[j].w的最小值 \n\t\tin[1][point] &#x3D; in[point][1] &#x3D; 1;\n\t\tin[dp[point].l][dp[point].r] &#x3D; in[dp[point].r][dp[point].l] &#x3D; 0;\n\t\t&#x2F;&#x2F; 处理善后 \n\t\tans +&#x3D; minpoint;\n\t\t&#x2F;&#x2F; 累计答案 \n\t&#125;\n\tcout &lt;&lt; &quot;Total miles driven: &quot; &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n作者：shined\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;1708&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F; AcWing 348. 沙漠之王 \n&#x2F;&#x2F; 最优比率(max&#123;总收益Ce&#x2F;总成本Re&#125;)生成树 0&#x2F;1分数规划:二分答案\n&#x2F;&#x2F; edge[e] &#x3D; Ce - mid * Re(c&#x3D;b-ka)的原图上求最大生成树 边权之和非负：l&#x3D;mid，否则r&#x3D;mid 最终ans&#x3D;mid\n&#x2F;&#x2F;本题：min&#123;总成本(高度差_a)&#x2F;总长度_b&#125; c&#x3D;a-kb Prim求最小生成树 (其余part同上)\n&#x2F;&#x2F;prim的复杂度是O(n2), kruskal的复杂度是O(mlogm)，这个题是完全图所以m&#x3D;n2\n&#x2F;&#x2F;Author:XuHt  TLE!!!!!!\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1006, INF &#x3D; 0x3f3f3f3f;\nconst double eps &#x3D; 1e-6;\nint n;\nstruct P &#123;\n\tint x, y, z;\n&#125; p[N];\ndouble a[N][N], b[N][N], c[N][N], d[N];\nbool v[N];\n\ninline double s(int i, int j) &#123;\n\treturn sqrt((p[i].x - p[j].x) * (p[i].x - p[j].x) + (p[i].y - p[j].y) * (p[i].y - p[j].y));\n&#125;\n\ndouble work(double k) &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; i; j &lt;&#x3D; n; j++)&#x2F;&#x2F;1&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n\n\t\t\tif (i &#x3D;&#x3D; j) c[i][j] &#x3D; INF;&#x2F;&#x2F;(自环)不可达\n\t\t\telse c[i][j] &#x3D; c[j][i] &#x3D; a[i][j] - k * b[i][j];&#x2F;&#x2F;新边权c\n\t&#x2F;&#x2F;Prim求MST\n\tmemset(v, 0, sizeof(v));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) d[i] &#x3D; INF;\n\td[1] &#x3D; 0;\n\tdouble ans &#x3D; 0;\n\twhile (1) &#123;\n\t\tint x &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!v[i] &amp;&amp; (!x || d[x] &gt; d[i])) x &#x3D; i;&#x2F;&#x2F;d[x]min\n\t\tif (!x) break;&#x2F;&#x2F;不能再更新了\n\t\tv[x] &#x3D; 1;\n\t\tans +&#x3D; d[x];\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) d[i] &#x3D; min(d[i], c[x][i]);&#x2F;&#x2F;\n\t&#125;\n\treturn ans;\n&#125;\n\nvoid Desert_King() &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d %d %d&quot;, &amp;p[i].x, &amp;p[i].y, &amp;p[i].z);\n\tdouble num &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\tnum +&#x3D; (a[i][j] &#x3D; a[j][i] &#x3D; abs(p[i].z - p[j].z));&#x2F;&#x2F;成本&#x3D;高度差\n\t\t\tb[i][j] &#x3D; b[j][i] &#x3D; s(i, j);&#x2F;&#x2F;dist[i][j]\n\t\t&#125;\n\tdouble l &#x3D; 0, r &#x3D; num;\n\twhile (l + eps &lt;&#x3D; r) &#123;&#x2F;&#x2F;\n\t\tdouble mid &#x3D; (l + r) &#x2F; 2;\n\t\tif (work(mid) &gt;&#x3D; 0) l &#x3D; mid;\n\t\telse r &#x3D; mid;\n\t&#125;\n\tprintf(&quot;%.3f\\n&quot;, l);\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &amp;&amp; n) Desert_King();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; Dinkelbach算法\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;hzoi_ztx&#x2F;article&#x2F;details&#x2F;54898323\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;hhaile&#x2F;article&#x2F;details&#x2F;8883652\n对于0-1分数规划的Dinkelbach算法的分析 武钢三中吴豪[译]\nhttps:&#x2F;&#x2F;www.docin.com&#x2F;p-601713235.html\n算法合集之《最小割模型在信息学竞赛中的应用》 胡伯涛 2007NOI国家集训队论文_day2\nhttps:&#x2F;&#x2F;wenku.baidu.com&#x2F;view&#x2F;986baf00b52acfc789ebc9a9.html\n&#x2F;*\n参数搜索：\n目标式:R&#x3D;sigma(a[i]*x[i])&#x2F;sigma(b[i]*x[i])\nd[i]&#x3D;a[i]-L*b[i]，那么F(L)&#x3D;sigma(d[i]*x[i])\n二分的时候我们只是用到了F(L)&gt;0这个条件，而对于使得F(L)&gt;0的这组解所求到的R值没有使用。因为F(L)&gt;0,我们已经知道了R是一个更优的解，与其漫无目的的二分，为什么不将解移动到R上去呢？\n\n求01分数规划的另一个方法就是Dinkelbach算法，\nDinkelbach 实质上是一种迭代算法，基于这样的思想：不去二分答案，而是先随便给定一个答案，然后根据更优的解（max&#123;f(r)&#125; 对应直线的横截距） 不断移动答案，逼近最优解。理论上它比二分快些。但是，他的弊端就是需要保存这个解。\n在这个算法中，一般将r初始化为0。\n\n再说最小化\n看上面的图，也很好理解，就是最左边的r为r*，当前的r确定时需要用到min&#123;f(r)&#125;。 \n如果min&#123;f(r)&#125;&gt;0，那么r&lt;r*； \n如果min&#123;f(r)&#125;&#x3D;0，那么r&#x3D;r*； \n如果min&#123;f(r)&#125;&lt;0，那么r&gt;r*。\n\n每次直接把子问题Q(l)最优解带入r的表达式算出一个新l&#39;,进行下一次迭代\n线性时间复杂度算法？？？\n*&#x2F;\n\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ndouble dist[1100][1100], cost[1100][1100];\ndouble ratio, dsum, csum; int n;\n&#x2F;&#x2F; min&#123;总成本(高度差_c)&#x2F;总长度_d&#125; c-kd\ninline double len (int a, int b) &#123; return cost[a][b] - ratio * dist[a][b]; &#125;\n\nvoid prim (void)\n&#123;\n\tdouble dt[1100], ds[1100], dc[1100];\n\tbool added[1100];\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t&#123;\n\t\tdt[i] &#x3D; len(0, i);\n\t\tds[i] &#x3D; dist[0][i], dc[i] &#x3D; cost[0][i];\n\t&#125;\n\tmemset(added, 0, sizeof(added));\n\tadded[0] &#x3D; true;\n\tdsum &#x3D; csum &#x3D; 0;&#x2F;&#x2F;init&#x3D;0\n\tfor (int i &#x3D; 1; i &lt; n; i++)&#x2F;&#x2F;迭代dsum,csum\n\t&#123;\n\t\tint t &#x3D; -1;&#x2F;&#x2F;dt[t] &#x3D; len(0,t) &#x3D; min&#123;c-kd&#125;\n\t\tfor (int j &#x3D; 1; j &lt; n; j++)\n\t\t&#123;\n\t\t\tif (added[j]) continue;\n\t\t\tif (t &#x3D;&#x3D; -1 || dt[j] &lt; dt[t]) t &#x3D; j;\n\t\t&#125;\n\t\tdsum +&#x3D; ds[t], csum +&#x3D; dc[t];&#x2F;&#x2F;更新sum值\n\t\tadded[t] &#x3D; true;\n\t\tfor (int j &#x3D; 1; j &lt; n; j++)&#x2F;&#x2F;更新dt ds dc\n\t\t&#123;\n\t\t\tif (added[j]) continue;\n\t\t\tif (len(t, j) &lt; dt[j]) &#x2F;&#x2F; dt[j] &#x3D;&#x3D; len(0, j)\n\t\t\t&#123;\n\t\t\t\tdt[j] &#x3D; len(t, j);\n\t\t\t\tds[j] &#x3D; dist[t][j], dc[j] &#x3D; cost[t][j];\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint x[1100], y[1100], h[1100];\nint main ()\n&#123;\n\twhile (1)\n\t&#123;\n\t\tscanf(&quot;%d&quot;, &amp;n);\n\t\tif (n &#x3D;&#x3D; 0) break;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d %d %d&quot;, &amp;x[i], &amp;y[i], &amp;h[i]);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tfor (int j &#x3D; i + 1; j &lt; n; j++)\n\t\t\t&#123;\n\t\t\t\tdist[i][j] &#x3D; sqrt((double)(x[i] - x[j]) * (x[i] - x[j]) +\n\t\t\t\t\t\t\t\t  (double)(y[i] - y[j]) * (y[i] - y[j]));\n\t\t\t\tdist[j][i] &#x3D; dist[i][j];\n\t\t\t\tcost[i][j] &#x3D; cost[j][i] &#x3D; abs(h[i] - h[j]);\n\t\t\t&#125;\n\t\t&#125;\n\t\tdsum &#x3D; csum &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt; n; i++) dsum +&#x3D; dist[0][i], csum +&#x3D; cost[0][i];\n\t\tratio &#x3D; csum &#x2F; dsum;&#x2F;&#x2F;\n\t\twhile (1)&#x2F;&#x2F;迭代逼近\n\t\t&#123;\n\t\t\tprim(); \n\t\t\tdouble tr &#x3D; csum &#x2F; dsum;\n\t\t\tif (fabs(tr - ratio) &lt; 1e-04) break;\n\t\t\telse ratio &#x3D; tr;&#x2F;&#x2F;保存该值，更新答案\n\t\t&#125;\n\t\tprintf(&quot;%.3f\\n&quot;, ratio);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 349. 黑暗城堡\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 1006;\nconst ll P &#x3D; (1ll &lt;&lt; 31) - 1;\nint n, m, a[N][N], d[N];\nbool v[N];\n&#x2F;*\nbool cmp (const int&amp; a, const int&amp; b)\n&#123;\n\treturn d[a] &lt; d[b];\n&#125;\n*&#x2F;\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tmemset(a, 0x3f, sizeof(a));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i][i] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\ta[x][y] &#x3D; a[y][x] &#x3D; min(a[x][y], z);\n\t&#125;\n\t&#x2F;&#x2F;Dijkstra模板\n\tmemset(d, 0x3f, sizeof(d));\n\td[1] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint t &#x3D; 0;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tif (!v[j] &amp;&amp; (!t || d[j] &lt; d[t])) t &#x3D; j;\n\t\tv[t] &#x3D; 1;&#x2F;&#x2F;全局最小值点\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\td[j] &#x3D; min(d[j], d[t] + a[t][j]);&#x2F;&#x2F;更新dist[]\n\t&#125;\n\n\tmemset(v, 0, sizeof(v));\n\tv[1] &#x3D; 1;\n\tll ans &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint t &#x3D; 0, k &#x3D; 0;\n\t\tfor (int j &#x3D; 2; j &lt;&#x3D; n; j++)\n\t\t\tif (!v[j] &amp;&amp; (!t || d[j] &lt; d[t])) t &#x3D; j;&#x2F;&#x2F;dist[t]min O(n^2)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tif (v[j] &amp;&amp; d[j] + a[j][t] &#x3D;&#x3D; d[t]) ++k;\n\t\tv[t] &#x3D; 1;\n\t\t(ans *&#x3D; k) %&#x3D; P;\n\t&#125;\n&#x2F;*\n\tint list[N];\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) list[i] &#x3D; i;\n\tsort(list + 1, list + 1 + n, cmp); &#x2F;&#x2F; O(nlogn)\n\tll ans &#x3D; 1;\n\tfor (int i &#x3D; 2; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tint tt &#x3D; 0;\n\t\tfor (int j &#x3D; 1; j &lt; i; j++)\n\t\t&#123;\n\t\t\tif (d[list[j]] + a[list[j]][list[i]] &#x3D;&#x3D; d[list[i]]) ++tt;\n\t\t&#125;\n\t\tans &#x3D; (ans * tt) % P;\n\t&#125;\n*&#x2F;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;类似无向图MST问题：有向图上最小树形图的朱-刘算法（见lrj黑书指导7.2）\n\n&#x2F;&#x2F;0x63. 树的直径与最近公共祖先\n&#x2F;&#x2F;【树的直径】\n&#x2F;&#x2F; AcWing 350. 巡逻\n&#x2F;*\n因为需要获得第一次直径的路径，应该使用两次搜索寻找，这里使用DFS\n第二次寻找直径出现负权，需要使用树形DP求直径\n*&#x2F;\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100006;\nint n, k, d[N], fa[N];\nint Head[N], Edge[N&lt;&lt;1], Leng[N&lt;&lt;1], Next[N&lt;&lt;1], tot &#x3D; 1;\nbool v[N];\n\nvoid add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n\nvoid dfs(int x, int &amp;t) &#123;&#x2F;&#x2F;2次dfs求树的直径\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (v[y]) continue;\n\t\tif ((d[y] &#x3D; d[x] + z) &gt;&#x3D; d[t]) t &#x3D; y;\n\t\tfa[y] &#x3D; i;&#x2F;&#x2F;记录前驱边\n\t\tdfs(y, t);&#x2F;&#x2F;y:直径的一端-最远-&gt;t:另一端\n\t&#125;\n\tv[x] &#x3D; 0;\n&#125;\n\nvoid dp(int x, int &amp;t) &#123;&#x2F;&#x2F;树形DP求t：x子树的直径\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (v[y]) continue;\n\t\tdp(y, t);\n\t\tt &#x3D; max(t, d[x] + d[y] + z);\n\t\td[x] &#x3D; max(d[x], d[y] + z);\n\t&#125;&#x2F;&#x2F;d[x]:x向下子树内最远距离\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; k;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tadd(x, y, 1);&#x2F;&#x2F;双向边 成对添加\n\t\tadd(y, x, 1);\n\t&#125;\n\tint t &#x3D; 1;&#x2F;&#x2F;init:t&#x3D;1 d[1]&#x3D;0\n\tdfs(1, t);&#x2F;&#x2F;...--fa[t]--&gt;t：树的直径\n\td[t] &#x3D; fa[t] &#x3D; 0;\n\tint tt &#x3D; t;&#x2F;&#x2F;init:tt&#x3D;t d[t]&#x3D;0\n\tdfs(t, tt);&#x2F;&#x2F;直径L1: t~&gt;tt\n\tint ans &#x3D; ((n - 1) &lt;&lt; 1) - d[tt] + 1;\n\tif (k &#x3D;&#x3D; 2) &#123;\n\t\twhile (fa[tt]) &#123;\n\t\t\tLeng[fa[tt]] &#x3D; Leng[fa[tt]^1] &#x3D; -1;&#x2F;&#x2F;直径取反(反向边^1)\n\t\t\ttt &#x3D; Edge[fa[tt]^1];&#x2F;&#x2F;tt&#39;&lt;--fa[tt]^1--tt\n\t\t&#125;\n\t\ttt &#x3D; 0;&#x2F;&#x2F;L2\n\t\tmemset(d, 0, sizeof(d));\n\t\tdp(t, tt);\n\t\tans -&#x3D; tt - 1;\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;2*bfs+dp\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;queue&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int u&#x3D;100010;\nint ver[2*u],edge[2*u],next[2*u],head[u],d[u],pre[u],f[u],v[u],n,m,tot,p,i,x,y,z;\nqueue&lt;int&gt; q; \n\nvoid add(int x,int y)\n&#123;\n\tver[++tot]&#x3D;y; edge[tot]&#x3D;1; next[tot]&#x3D;head[x]; head[x]&#x3D;tot;\n&#125;\n\nint bfs(int s)\n&#123;\n\tint i,x,y;\n\tmemset(d,0x3f,sizeof(d));\n\tq.push(s); d[s]&#x3D;pre[s]&#x3D;0;\n\twhile(q.size())\n\t&#123;\n\t\tx&#x3D;q.front(); q.pop();\n\t\tfor(i&#x3D;head[x];i;i&#x3D;next[i])\n\t\t\tif(d[ver[i]]&#x3D;&#x3D;0x3f3f3f3f)\n\t\t\t\td[ver[i]]&#x3D;d[x]+edge[i],pre[ver[i]]&#x3D;i,q.push(ver[i]);\n\t&#125;\n\tfor(x&#x3D;y&#x3D;1;x&lt;&#x3D;n;x++) if(d[x]&gt;d[y]) y&#x3D;x;\n\treturn y;\n&#125;\n\nint get()\n&#123;\n\tp&#x3D;bfs(1);\n\tp&#x3D;bfs(p);\n\treturn d[p];\n&#125;\n\nvoid change()\n&#123;\n\tfor(;pre[p];p&#x3D;ver[pre[p]^1]) edge[pre[p]]&#x3D;edge[pre[p]^1]&#x3D;-1;\n&#125;\n\nvoid dp(int x)\n&#123;\n\tv[x]&#x3D;1;\n\tfor(int i&#x3D;head[x];i;i&#x3D;next[i])\n\t\tif(!v[ver[i]])\n\t\t&#123;\n\t\t\tdp(ver[i]);\n\t\t\ty&#x3D;max(y,f[ver[i]]+f[x]+edge[i]);\n\t\t\tf[x]&#x3D;max(f[x],f[ver[i]]+edge[i]);\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin&gt;&gt;n&gt;&gt;m;\n\ttot&#x3D;1;\n\tfor(i&#x3D;1;i&lt;n;i++)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;,&amp;x,&amp;y);\n\t\tadd(x,y),add(y,x);\n\t&#125;\n\tx&#x3D;get(),y&#x3D;0,z&#x3D;1;\n\tif(m&#x3D;&#x3D;2) change(),dp(1),z&#x3D;2;\n\tcout&lt;&lt;2*(n-1)-x-y+z&lt;&lt;endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 351. 树网的核\n&#x2F;&#x2F;解法4\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 500010;\nint head[N],ver[N*2],Next[N*2],edge[N*2];\nint fa[N],f[N],d[N],a[N]; \nint n,s,m,tot,l,r,x,y,z,temp,ans;\nbool v[N];\n\nvoid add(int x,int y,int z) &#123;\n\tver[++tot]&#x3D;y,Next[tot]&#x3D;head[x],edge[tot]&#x3D;z,head[x]&#x3D;tot;\n&#125;\n\nvoid dfs(int x)&#123;&#x2F;&#x2F;fa d\n\tfor(int i&#x3D;head[x];i;i&#x3D;Next[i])&#123;\n\t\tif(ver[i]!&#x3D;fa[x])&#123;\n\t\t\tfa[ver[i]]&#x3D;x;\n\t\t\td[ver[i]]&#x3D;d[x]+edge[i];\n\t\t\tdfs(ver[i]);\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid diameter()&#123;&#x2F;&#x2F;2*dfs\n\tdfs(1);&#x2F;&#x2F;fa d\n\tx&#x3D;1;\n\tfor(int i&#x3D;2;i&lt;&#x3D;n;i++)\n\t\tif(d[i]&gt;d[x])x&#x3D;i;\n\td[x]&#x3D;0;&#x2F;&#x2F;find直径一个端点x,init d fa\n\tmemset(fa,0,sizeof(fa));\n\tdfs(x);\n\ty&#x3D;1;\n\tfor(int i&#x3D;2;i&lt;&#x3D;n;i++)\n\t\tif(d[i]&gt;d[y])y&#x3D;i;\n\twhile(y!&#x3D;x)&#123;&#x2F;&#x2F;a[]记录直径path:y~x\n\t\tv[y]&#x3D;true;\n\t\ta[++m]&#x3D;y;\n\t\ty&#x3D;fa[y];\n\t&#125;\n\tv[x]&#x3D;1;\n\ta[++m]&#x3D;x;\n&#125;\n\nvoid treedp(int x)&#123;&#x2F;&#x2F;treedp求f[ui]\n\tv[x]&#x3D;true;\n\tfor(int i&#x3D;head[x];i;i&#x3D;Next[i])&#123;\n\t\tif(!v[ver[i]])&#123;\n\t\t\ttreedp(ver[i]);\n\t\t\tf[x]&#x3D;max(f[x],f[ver[i]]+edge[i]);&#x2F;&#x2F;diameter法一只求f不求ans\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()&#123;\n\tscanf(&quot;%d%d&quot;,&amp;n,&amp;s);\n\tfor(int i&#x3D;1;i&lt;&#x3D;n-1;i++)&#123;\n\t\tscanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);\n\t\tadd(x,y,z);add(y,x,z);\n\t&#125;\n\tdiameter();\n\tfor(int i&#x3D;1;i&lt;&#x3D;m;i++)treedp(a[i]);&#x2F;&#x2F;f[ui]\n\tint j&#x3D;m;\n\tans&#x3D;0x7fffffff;\n\tfor(int i&#x3D;1;i&lt;&#x3D;m;i++)temp&#x3D;max(temp,f[a[i]]);&#x2F;&#x2F;max_f[ui]\n\tfor(int i&#x3D;m;i&gt;&#x3D;1;i--)&#123;\n\t\twhile(j&gt;&#x3D;1&amp;&amp;d[a[j]]-d[a[i]]&lt;&#x3D;s)j--;&#x2F;&#x2F;1~j~(恰好&gt;s)~i~m d[y&lt;~x]:大&lt;~小\n\t\tans&#x3D;min(ans,max(temp,max(d[a[i]],d[a[1]]-d[a[j+1]])));&#x2F;&#x2F;i~m 1~j\n\t&#125;&#x2F;&#x2F;min_偏心距ECC(F)\n\tprintf(&quot;%d\\n&quot;,ans);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;yxc 解法3\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; PII;\n\nconst int N &#x3D; 500010, M &#x3D; N * 2;\n\nint n, s;\nint h[N], e[M], w[M], ne[M], idx;\nint q[N], dist[N], pre[N];\nvector&lt;PII&gt; path;\nbool st[N];\n\nvoid add(int a, int b, int c)\n&#123;\n\te[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\nvoid bfs(int start)\n&#123;\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\tmemset(dist, 0x3f, sizeof dist);\n\tmemset(pre, -1, sizeof pre);\n\tdist[start] &#x3D; 0;\n\tq[0] &#x3D; start;\n\n\twhile (hh &lt;&#x3D; tt)\n\t&#123;\n\t\tint t &#x3D; q[hh ++ ];\n\t\tfor (int i &#x3D; h[t]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif (dist[j] &gt; dist[t] + w[i])\n\t\t\t&#123;\n\t\t\t\tpre[j] &#x3D; t;\n\t\t\t\tdist[j] &#x3D; dist[t] + w[i];\n\t\t\t\tq[ ++ tt] &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint bfs_max_dist(int start)\n&#123;\n\tint res &#x3D; 0;\n\tint hh &#x3D; 0, tt &#x3D; 0;\n\tq[0] &#x3D; start;\n\twhile (hh &lt;&#x3D; tt)\n\t&#123;\n\t\tint t &#x3D; q[hh ++ ];\n\t\tres &#x3D; max(res, dist[t]);\n\n\t\tfor (int i &#x3D; h[t]; ~i; i &#x3D; ne[i])\n\t\t&#123;\n\t\t\tint j &#x3D; e[i];\n\t\t\tif (!st[j])\n\t\t\t&#123;\n\t\t\t\tst[j] &#x3D; true;\n\t\t\t\tdist[j] &#x3D; dist[t] + w[i];\n\t\t\t\tq[ ++ tt] &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn res;\n&#125;\n\nint get_max()\n&#123;\n\tint t &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n\t\tif (dist[t] &lt; dist[i])\n\t\t\tt &#x3D; i;\n\treturn t;\n&#125;\n\nbool check(int mid)\n&#123;\n\tint u &#x3D; 0, v &#x3D; path.size() - 1;\n\twhile (u + 1 &lt; path.size() &amp;&amp; path[u + 1].second &lt;&#x3D; mid) u ++ ;\n\twhile (v - 1 &gt;&#x3D; 0 &amp;&amp; path.back().second - path[v - 1].second &lt;&#x3D; mid) v -- ;\n\tif (u &gt; v) return true;\n\tif (path[v].second - path[u].second &gt; s) return false;\n\n\tmemset(st, false, sizeof st);\n\tmemset(dist, 0, sizeof dist);\n\tfor (auto p : path) st[p.first] &#x3D; true;\n\n\tfor (int i &#x3D; u; i &lt;&#x3D; v; i ++ )\n\t\tif (bfs_max_dist(path[i].first) &gt; mid)\n\t\t\treturn false;\n\treturn true;\n&#125;\n\nint main()\n&#123;\n\tscanf(&quot;%d%d&quot;, &amp;n, &amp;s);\n\tmemset(h, -1, sizeof h);\n\tfor (int i &#x3D; 0; i &lt; n - 1; i ++ )\n\t&#123;\n\t\tint a, b, c;\n\t\tscanf(&quot;%d%d%d&quot;,  &amp;a, &amp;b, &amp;c);\n\t\tadd(a, b, c), add(b, a, c);\n\t&#125;\n\n\tbfs(1);\n\tint u &#x3D; get_max();\n\tbfs(u);\n\tint v &#x3D; get_max();\n\twhile (v !&#x3D; -1)\n\t&#123;\n\t\tpath.push_back(&#123;v, dist[v]&#125;);\n\t\tv &#x3D; pre[v];\n\t&#125;\n\treverse(path.begin(), path.end());\n\n\tint l &#x3D; 0, r &#x3D; 2e9;\n\twhile (l &lt; r)\n\t&#123;\n\t\tint mid &#x3D; (LL)l + r &gt;&gt; 1;\n\t\tif (check(mid)) r &#x3D; mid;\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\n\tprintf(&quot;%d\\n&quot;, r);\n\n\treturn 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;3512&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;【LCA】\n&#x2F;&#x2F; 1.向上标记法 2.树上倍增法 3.LCA的Tarjan算法(并查集优化1)(S(n)大一倍!!!!)\n\n&#x2F;&#x2F;【树上差分】: 差分&lt;-(互逆op)-&gt;前缀和 区间op-&gt;path_op 前缀和-&gt;子树和\n\n&#x2F;&#x2F; AcWing 352. 闇の連鎖\n&#x2F;&#x2F;就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。\n&#x2F;&#x2F;所以must 主+附!!!\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 200010;&#x2F;&#x2F;法3LCA: S(n)大一倍!!!!\nint n, m, fa[N], ans[N], v[N], d[N], f[N], ANS &#x3D; 0;\nint Head[N], Edge[N&lt;&lt;1], Next[N&lt;&lt;1], tot &#x3D; 0;\nvector&lt;pair&lt;int, int&gt; &gt; q[N];\npair&lt;int, int&gt; Q[N];\n\ninline void add(int x, int y) &#123;\n\tEdge[++tot] &#x3D; y;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n&#x2F;&#x2F;法3求LCA\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\nvoid tarjan(int x) &#123;\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (v[y]) continue;\n\t\ttarjan(y);\n\t\tfa[y] &#x3D; x;&#x2F;&#x2F;(2)-&gt;fa\n\t&#125;\n\tfor (unsigned int i &#x3D; 0; i &lt; q[x].size(); i++) &#123;\n\t\tint y &#x3D; q[x][i].first, id &#x3D; q[x][i].second;&#x2F;&#x2F;&#123;y,id&#125;\n\t\tif (v[y] &#x3D;&#x3D; 2) ans[id] &#x3D; get(y);&#x2F;&#x2F;只求lca (1)\n\t&#125;\n\tv[x] &#x3D; 2;&#x2F;&#x2F;\n&#125;\n\nvoid dfs(int x) &#123;\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (v[y]) continue;\n\t\tdfs(y);\n\t\tf[x] +&#x3D; f[y];&#x2F;&#x2F;\n\t&#125;\n\tf[x] +&#x3D; d[x];&#x2F;&#x2F;x子树权值之和\n\tif (!f[x]) ANS +&#x3D; m;&#x2F;&#x2F;切cover_0主&#123;x,fa(x)&#125; + m种附\n\telse if (f[x] &#x3D;&#x3D; 1) ++ANS;&#x2F;&#x2F;切cover_1主&#123;x,fa(x)&#125; + only1种附&#123;x,y&#125;\n&#125;&#x2F;&#x2F;切断方案数ANS：cover_&gt;&#x3D;2主 无法切断 ANS+&#x3D;0\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);\n\t\tadd(x, y);\n\t\tadd(y, x);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y);&#x2F;&#x2F;m条附加边\n\t\tif (x &#x3D;&#x3D; y) ans[i] &#x3D; x;&#x2F;&#x2F;ans[i]&#x3D;lca(x,y)\n\t\telse &#123;\n\t\t\tq[x].push_back(&#123;y, i&#125;);&#x2F;&#x2F;与x相关的query\n\t\t\tq[y].push_back(&#123;x, i&#125;);\n\t\t&#125;\n\t\tQ[i].first &#x3D; x;&#x2F;&#x2F;Q[i]&#x3D;&#123;x,y&#125;\n\t\tQ[i].second &#x3D; y;\n\t&#125;\n\ttarjan(1);&#x2F;&#x2F;离线 一次性处理\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\t++d[Q[i].first];&#x2F;&#x2F;权值dx+1 dy+1\n\t\t++d[Q[i].second];\n\t\td[ans[i]] -&#x3D; 2;&#x2F;&#x2F;d(lca(x,y))-2\n\t&#125;\n\tmemset(v, 0, sizeof(v));\n\tdfs(1);\n\tcout &lt;&lt; ANS - m &lt;&lt; endl;&#x2F;&#x2F;f[root]&#x3D;0 不考虑cover_0&#123;rt&lt;-fa(rt)&#125;\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; AcWing 353. 雨天的尾巴\t\t难！！！\n\n\n&#x2F;&#x2F; AcWing 354. 天天爱跑步\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int N &#x3D; 300010;\nint ver[N &lt;&lt; 1], Next[N &lt;&lt; 1], head[N], tot;\nint f[N][20], d[N], w[N], v[N];\nint c1[N &lt;&lt; 1], c2[N &lt;&lt; 1], ans[N];\nint n, m, t;\nqueue&lt;int&gt; q;\nvector&lt;int&gt; a1[N], b1[N], a2[N], b2[N];&#x2F;&#x2F;1段+-type，2段+-type\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid bfs() &#123;&#x2F;&#x2F;预处理d f\n\tt &#x3D; log(n) &#x2F; log(2);&#x2F;&#x2F;树高\n\tq.push(1); d[1] &#x3D; 1;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front(); q.pop();\n\t\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; ver[i];\n\t\t\tif (d[y]) continue;\n\t\t\td[y] &#x3D; d[x] + 1;\n\t\t\tf[y][0] &#x3D; x;\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; t; j++)\n\t\t\t\tf[y][j] &#x3D; f[f[y][j - 1]][j - 1];&#x2F;&#x2F;树上倍增\n\t\t\tq.push(y);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint lca(int x, int y) &#123;\n\tif (d[x] &gt; d[y]) swap(x, y);\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (d[f[y][i]] &gt;&#x3D; d[x]) y &#x3D; f[y][i];\n\tif (x &#x3D;&#x3D; y) return x;\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (f[x][i] !&#x3D; f[y][i]) x &#x3D; f[x][i], y &#x3D; f[y][i];\n\treturn f[x][0];\n&#125;\n\nvoid dfs(int x) &#123;\n\tint val1 &#x3D; c1[d[x] + w[x]], val2 &#x3D; c2[w[x] - d[x] + n];\n\tv[x] &#x3D; 1;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (v[y]) continue;\n\t\tdfs(y);\n\t&#125;\n\t&#x2F;&#x2F;全局数组计数\n\tfor (int i &#x3D; 0; i &lt; a1[x].size(); i++) c1[a1[x][i]]++;&#x2F;&#x2F;点x + i_type\n\tfor (int i &#x3D; 0; i &lt; b1[x].size(); i++) c1[b1[x][i]]--;\n\tfor (int i &#x3D; 0; i &lt; a2[x].size(); i++) c2[a2[x][i] + n]++;&#x2F;&#x2F;2段(负)需偏移n\n\tfor (int i &#x3D; 0; i &lt; b2[x].size(); i++) c2[b2[x][i] + n]--;\n\tans[x] +&#x3D; c1[d[x] + w[x]] - val1 + c2[w[x] - d[x] + n] - val2;&#x2F;&#x2F;子树和 区间减法性质\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tadd(x, y), add(y, x);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;w[i]);\n\tbfs();&#x2F;&#x2F;预处理d:depth f[x][k]:x的2^k辈祖先 -&gt; lca\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tint z &#x3D; lca(x, y);\n\t\ta1[x].push_back(d[x]);&#x2F;&#x2F;1+type\n\t\tb1[f[z][0]].push_back(d[x]);&#x2F;&#x2F;1-type\n\t\ta2[y].push_back(d[x] - 2 * d[z]);&#x2F;&#x2F;2+type\n\t\tb2[z].push_back(d[x] - 2 * d[z]);&#x2F;&#x2F;2-type\n\t&#125;\n\tdfs(1);\n\tfor (int i &#x3D; 1; i &lt; n; i++) printf(&quot;%d &quot;, ans[i]);\n\tprintf(&quot;%d\\n&quot;, ans[n]);\n&#125;\n\n\n&#x2F;&#x2F;【LCA的综合应用】\n&#x2F;&#x2F; AcWing 355. 异象石\n&#x2F;&#x2F;Author:XuHt\n#include &lt;set&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 100006;\nint n, m, t, f[N][20], dep[N], dfn[N], tot;\nvector&lt;pair&lt;int, ll&gt; &gt; e[N];\nll d[N], ans;\nset&lt;pair&lt;int, int&gt; &gt; st;\nset&lt;pair&lt;int, int&gt; &gt;::iterator it;\n&#x2F;&#x2F;法2求lca\ninline int lca(int x, int y) &#123;\n\tif (dep[x] &gt; dep[y]) swap(x, y);\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (dep[f[y][i]] &gt;&#x3D; dep[x]) y &#x3D; f[y][i];\n\tif (x &#x3D;&#x3D; y) return x;\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (f[x][i] !&#x3D; f[y][i]) &#123;\n\t\t\tx &#x3D; f[x][i];\n\t\t\ty &#x3D; f[y][i];\n\t\t&#125;\n\treturn f[x][0];\n&#125;\n\ninline ll path(int x, int y) &#123;\n\treturn d[x] + d[y] - (d[lca(x,y)] &lt;&lt; 1);\n&#125;\n\ninline void Insert(int x) &#123;\n\tst.insert(&#123;dfn[x], x&#125;);&#x2F;&#x2F;有序集合 按dfn递增排列 【先insert】\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tauto l &#x3D; it &#x3D;&#x3D; st.begin() ? --st.end() : --it;&#x2F;&#x2F;dfs序前驱(首尾相接)[)-&gt;[]\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tauto r &#x3D; it &#x3D;&#x3D; --st.end() ? st.begin() : ++it;&#x2F;&#x2F;dfs序后继\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);&#x2F;&#x2F;insert(x)\n\tans -&#x3D; path((*l).second, (*r).second);\n\tans +&#x3D; path((*l).second, (*it).second) + path((*it).second, (*r).second);\n&#125;\n\ninline void Remove(int x) &#123;\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tauto l &#x3D; it &#x3D;&#x3D; st.begin() ? --st.end() : --it;\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tauto r &#x3D; it &#x3D;&#x3D; --st.end() ? st.begin() : ++it;\n\tit &#x3D; st.find(&#123;dfn[x], x&#125;);\n\tans +&#x3D; path((*l).second, (*r).second);\n\tans -&#x3D; path((*l).second, (*it).second) + path((*it).second, (*r).second);\n\tst.erase(&#123;dfn[x], x&#125;);&#x2F;&#x2F;【后erase】\n&#125;\n\nvoid dfs(int x) &#123;&#x2F;&#x2F;dfn dep d f\n\tdfn[x] &#x3D; ++tot;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i].first;\n\t\tif (dep[y]) continue;\n\t\tdep[y] &#x3D; dep[x] + 1;\n\t\tll z &#x3D; e[x][i].second;\n\t\td[y] &#x3D; d[x] + z;\n\t\tf[y][0] &#x3D; x;&#x2F;&#x2F;树上倍增\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; t; j++)\n\t\t\tf[y][j] &#x3D; f[f[y][j-1]][j-1];\n\t\tdfs(y);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y;\n\t\tll z;\n\t\tscanf(&quot;%d %d %lld&quot;, &amp;x, &amp;y, &amp;z);\n\t\te[x].push_back(&#123;y, z&#125;);\n\t\te[y].push_back(&#123;x, z&#125;);\n\t&#125;\n\tt &#x3D; log(n) &#x2F; log(2) + 1;\n\tdep[1] &#x3D; 1;\n\tdfs(1);&#x2F;&#x2F;dfn dep d f\n\tcin &gt;&gt; m;\n\twhile (m--) &#123;\n\t\tchar s[2];\n\t\tscanf(&quot;%s&quot;, s);\n\t\tif (s[0] &#x3D;&#x3D; &#39;?&#39;) printf(&quot;%lld\\n&quot;, ans &gt;&gt; 1);\n\t\telse &#123;\n\t\t\tint x;\n\t\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\t\ts[0] &#x3D;&#x3D; &#39;+&#39; ? Insert(x) : Remove(x);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; AcWing 356. 次小生成树\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 100006, M &#x3D; 300006;\nconst ll INF &#x3D; 0x3f3f3f3f3f3f3f3fll;\nint n, m, t, fa[N], d[N], f[N][20];\nstruct P &#123;\n\tint x, y;\n\tll z;\n\tbool k;\n\tbool operator &lt; (const P w) const &#123;\n\t\treturn z &lt; w.z;\n\t&#125;\n&#125; p[M];\nll g[N][20][2], sum, ans &#x3D; INF;\nvector&lt;pair&lt;int, ll&gt; &gt; e[N];\n\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\nvoid kruskal() &#123;\n\tsort(p + 1, p + m + 1);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x &#x3D; get(p[i].x), y &#x3D; get(p[i].y);\n\t\tif (x &#x3D;&#x3D; y) continue;\n\t\tfa[x] &#x3D; y;\n\t\tsum +&#x3D; p[i].z;&#x2F;&#x2F;边权和\n\t\tp[i].k &#x3D; 1;\n\t&#125;\n&#125;\n\nvoid dfs(int x) &#123;&#x2F;&#x2F;d f g\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i].first;\n\t\tif (d[y]) continue;\n\t\td[y] &#x3D; d[x] + 1;\n\t\tf[y][0] &#x3D; x;\n\t\tint z &#x3D; e[x][i].second;\n\t\tg[y][0][0] &#x3D; z;\n\t\tg[y][0][1] &#x3D; -INF;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; t; j++) &#123;\n\t\t\tf[y][j] &#x3D; f[f[y][j-1]][j-1];\n\t\t\tg[y][j][0] &#x3D; max(g[y][j-1][0], g[f[y][j-1]][j-1][0]);\n\t\t\tif (g[y][j-1][0] &#x3D;&#x3D; g[f[y][j-1]][j-1][0])\n\t\t\t\tg[y][j][1] &#x3D; max(g[y][j-1][1], g[f[y][j-1]][j-1][1]);\n\t\t\telse if (g[y][j-1][0] &lt; g[f[y][j-1]][j-1][0])\n\t\t\t\tg[y][j][1] &#x3D; max(g[y][j-1][0], g[f[y][j-1]][j-1][1]);\n\t\t\telse g[y][j][1] &#x3D; max(g[y][j-1][1], g[f[y][j-1]][j-1][0]);\n\t\t&#125;\n\t\tdfs(y);\n\t&#125;\n&#125;\n\ninline void lca(int x, int y, ll &amp;val1, ll &amp;val2) &#123;\n\tif (d[x] &gt; d[y]) swap(x, y);\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (d[f[y][i]] &gt;&#x3D; d[x]) &#123;&#x2F;&#x2F;(v1 v2) &lt;-更新- y(g0 g1)\n\t\t\tif (val1 &gt; g[y][i][0]) val2 &#x3D; max(val2, g[y][i][0]);\n\t\t\telse &#123;\n\t\t\t\tval1 &#x3D; g[y][i][0];\n\t\t\t\tval2 &#x3D; max(val2, g[y][i][1]);\n\t\t\t&#125;\n\t\t\ty &#x3D; f[y][i];\n\t\t&#125;\n\tif (x &#x3D;&#x3D; y) return;\n\tfor (int i &#x3D; t; i &gt;&#x3D; 0; i--)\n\t\tif (f[x][i] !&#x3D; f[y][i]) &#123;\n\t\t\tval1 &#x3D; max(val1, max(g[x][i][0], g[y][i][0]));\n\t\t\t&#x2F;&#x2F;val2&#x3D;max(g[x0],g[x1],g[y0],g[y1]且!&#x3D;val1)\n\t\t\tval2 &#x3D; max(val2, g[x][i][0] !&#x3D; val1 ? g[x][i][0] : g[x][i][1]);\n\t\t\tval2 &#x3D; max(val2, g[y][i][0] !&#x3D; val1 ? g[y][i][0] : g[y][i][1]);\n\t\t\tx &#x3D; f[x][i];\n\t\t\ty &#x3D; f[y][i];\n\t\t&#125;\n\tval1 &#x3D; max(val1, max(g[x][0][0], g[y][0][0]));&#x2F;&#x2F;i-&gt;0父\n\tval2 &#x3D; max(val2, g[x][0][0] !&#x3D; val1 ? g[x][0][0] : g[x][0][1]);\n\tval2 &#x3D; max(val2, g[y][0][0] !&#x3D; val1 ? g[y][0][0] : g[y][0][1]);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tscanf(&quot;%d %d %lld&quot;, &amp;p[i].x, &amp;p[i].y, &amp;p[i].z);\n\t\tp[i].k &#x3D; 0;\n\t&#125;\n\tkruskal();\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tif (p[i].k) &#123;\n\t\t\te[p[i].x].push_back(&#123;p[i].y, p[i].z&#125;);&#x2F;&#x2F;add()\n\t\t\te[p[i].y].push_back(&#123;p[i].x, p[i].z&#125;);\n\t\t&#125;\n\tt &#x3D; log(n) &#x2F; log(2) + 1;\n\td[1] &#x3D; 1;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; t; i++) g[1][i][0] &#x3D; g[1][i][1] &#x3D; -INF;\n\tdfs(1);&#x2F;&#x2F;d f g\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tif (!p[i].k) &#123;&#x2F;&#x2F;非树边\n\t\t\tll val1 &#x3D; -INF, val2 &#x3D; -INF;\n\t\t\tlca(p[i].x, p[i].y, val1, val2);&#x2F;&#x2F;val1 val2\n\t\t\tif (p[i].z &gt; val1) ans &#x3D; min(ans, sum - val1 + p[i].z);\n\t\t\telse ans &#x3D; min(ans, sum - val2 + p[i].z);\n\t\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 357. 疫情控制\n&#x2F;&#x2F;Author:XuHt\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 50006;\nint head[N], Edge[N&lt;&lt;1], Leng[N&lt;&lt;1], Next[N&lt;&lt;1], tot;\nint n, m, t, a[N], b[N], g[N], fa[N][16], sh[N];&#x2F;&#x2F;sh:son_head&#x3D;&#x3D;son_root\nll c[N], d[N], f[N], dis[N][16], sum;\nvector&lt;ll&gt; arv[N];\nqueue&lt;int&gt; q;\nbool v[N], w[N];\n\nvoid add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; head[x];\n\thead[x] &#x3D; tot;\n&#125;\n\nvoid bfs() &#123;&#x2F;&#x2F;fa dis\n\tv[1] &#x3D; 1;\n\tfor (int i &#x3D; head[1]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tq.push(y);\n\t\tv[y] &#x3D; 1;\n\t\tb[sh[y]&#x3D;++t] &#x3D; i;&#x2F;&#x2F;1 - b[y(sh[y]&#x3D;t)]&#x3D;i -&gt; yt\n\t&#125;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i];\n\t\t\tif (v[y]) continue;\n\t\t\tq.push(y);\n\t\t\tv[y] &#x3D; 1;\n\t\t\tfa[y][0] &#x3D; x;\n\t\t\tdis[y][0] &#x3D; Leng[i];\n\t\t\tfor (int j &#x3D; 1; j &lt; 16; j++) &#123;\n\t\t\t\tfa[y][j] &#x3D; fa[fa[y][j-1]][j-1];\n\t\t\t\tdis[y][j] &#x3D; dis[y][j-1] + dis[fa[y][j-1]][j-1];\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nbool dfs(int x) &#123;\n\tv[x] &#x3D; 1;\n\t&#x2F;&#x2F;not son_root &amp;&amp; in_H(驻扎地):第一类 x子树都被管:1\n\tif (!sh[x] &amp;&amp; w[x]) return 1;\n\tbool flag &#x3D; 0;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (v[y]) continue;\n\t\tflag &#x3D; 1;\n\t\tif (!dfs(Edge[i])) return 0;&#x2F;&#x2F;有子节点未被管:0\n\t&#125;\n\treturn flag;&#x2F;&#x2F;子节点都被管了:flag&#x3D;&#x3D;1\n&#125;\n\nbool work(ll now) &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) arv[i].clear();\n\tmemset(v, 0, sizeof(v));\n\tmemset(w, 0, sizeof(w));\n\tv[1] &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tg[i] &#x3D; a[i];\n\t\td[i] &#x3D; 0;&#x2F;&#x2F;dis之和\n\t\tfor (int j &#x3D; 15; j &gt;&#x3D; 0; j--)\n\t\t\tif (fa[g[i]][j] &amp;&amp; d[i] + dis[g[i]][j] &lt;&#x3D; now) &#123;\n\t\t\t\td[i] +&#x3D; dis[g[i]][j];\n\t\t\t\tg[i] &#x3D; fa[g[i]][j];\n\t\t\t&#125;\n\t\tw[g[i]] &#x3D; 1;&#x2F;&#x2F;入集合H\n\t\tint j &#x3D; sh[g[i]];&#x2F;&#x2F;1 - b[y(sh[y]&#x3D;t)]&#x3D;i -&gt; yt\n\t\tif (j) &#123;\n\t\t\tarv[j].push_back(now - d[i]);&#x2F;&#x2F;yj.push(rest_i) rest[yj]递减\n\t\t\tif (arv[j].size() &gt; 1 &amp;&amp; now - d[i] &gt; arv[j][arv[j].size()-2])\n\t\t\t\tswap(arv[j][arv[j].size()-1], arv[j][arv[j].size()-2]);\n\t\t&#125;\n\t&#125;\n\tint p &#x3D; 0, q &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tif (!dfs(Edge[b[i]])) &#123;&#x2F;&#x2F; dfs(-&gt;yi)&#x3D;&#x3D;0:yi属于H  min_rest[yj] &lt; 2*len\n\t\t\tif (arv[i].size() &amp;&amp; arv[i][arv[i].size()-1] &lt; (Leng[b[i]] &lt;&lt; 1))\n\t\t\t\tarv[i].pop_back();&#x2F;&#x2F;走不到:出H\n\t\t\telse f[++q] &#x3D; Leng[b[i]];&#x2F;&#x2F;能走到:入剩余集合H\n\t\t&#125;\n\t\tfor (unsigned int j &#x3D; 0; j &lt; arv[i].size(); j++)\n\t\t\tif (arv[i][j] &gt;&#x3D; Leng[b[i]])\n\t\t\t\tc[++p] &#x3D; arv[i][j] - Leng[b[i]];\n\t&#125;\n\tsort(c + 1, c + p + 1);&#x2F;&#x2F;军队：rest-len\n\tsort(f + 1, f + q + 1);&#x2F;&#x2F;H节点:len\n\tif (p &lt; q) return 0;&#x2F;&#x2F;无法完全覆盖：无解\n\tfor (int i &#x3D; q, j &#x3D; p; i; i--, j--)\n\t\tif (c[j] &lt; f[i]) return 0;&#x2F;&#x2F;有军队到不了:无解\n\treturn 1;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t\tsum +&#x3D; z;\n\t&#125;\n\tcin &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) scanf(&quot;%d&quot;, &amp;a[i]);\n\tbfs();\n\tll l &#x3D; 0, r &#x3D; sum + 1;\n\twhile (l &lt; r) &#123;&#x2F;&#x2F;&gt;&#x3D;ans(有解)的min mid] 版本1\n\t\tint mid &#x3D; (l + r) &gt;&gt; 1;\n\t\tif (work(mid)) r &#x3D; mid;\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\tif (l &gt; sum) puts(&quot;-1&quot;);\n\telse cout &lt;&lt; l &lt;&lt; endl;\n\treturn 0;\n&#125;\n--------------------------------------------------\n&#x2F;&#x2F;0x64. 基环树\n&#x2F;&#x2F; AcWing 358. 岛屿\n&#x2F;*\n1.dfs找环，记录来向边（参考割边割点的求法），直到找到第一个非树边时，通过打过的标记将环记录下来（并且要包括边权）。\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;7952&#x2F;\n2.（1类）树形dp，（2类）单调队列处理。\nPS:dfs找环可能会爆栈，所以可以通过bfs+拓扑排序来找环。\n*&#x2F;\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 1000006;\nint Head[N], Edge[N&lt;&lt;1], Leng[N&lt;&lt;1], Next[N&lt;&lt;1], tot;\nint n, du[N], c[N], q[N&lt;&lt;1];\nll f[N], d[N], a[N&lt;&lt;1], b[N&lt;&lt;1], ans;\nbool v[N];\n\ninline void add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n\t++du[y];&#x2F;&#x2F;y入度+1\n&#125;\n\nvoid bfs(int s, int t) &#123;\n\tint l &#x3D; 1, r &#x3D; 1;\n\tc[q[1]&#x3D;s] &#x3D; t;\n\twhile (l &lt;&#x3D; r) &#123;\n\t\tfor (int i &#x3D; Head[q[l]]; i; i &#x3D; Next[i])\n\t\t\tif (!c[Edge[i]]) c[q[++r]&#x3D;Edge[i]] &#x3D; t;\n\t\t++l;\n\t&#125;\n&#125;\n\nvoid topsort() &#123;\n\tint l &#x3D; 1, r &#x3D; 0;&#x2F;&#x2F;r&lt;l\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (du[i] &#x3D;&#x3D; 1) q[++r] &#x3D; i;&#x2F;&#x2F;双向边 (环上的点)入度1入q\n\twhile (l &lt;&#x3D; r) &#123;\n\t\tfor (int i &#x3D; Head[q[l]]; i; i &#x3D; Next[i])\n\t\t\tif (du[Edge[i]] &gt; 1) &#123;&#x2F;&#x2F;P370 树形dp求第一类d[c]:max子树直径\n\t\t\t\td[c[q[l]]] &#x3D; max(d[c[q[l]]], f[q[l]] + f[Edge[i]] + Leng[i]);\n\t\t\t\tf[Edge[i]] &#x3D; max(f[Edge[i]], f[q[l]] + Leng[i]);&#x2F;&#x2F;子树直径f\n\t\t\t\tif (--du[Edge[i]] &#x3D;&#x3D; 1) q[++r] &#x3D; Edge[i];&#x2F;&#x2F;入度-1\n\t\t\t&#125;\n\t\t++l;\n\t&#125;\n&#125;\n&#x2F;&#x2F;考虑第二类\nvoid dp(int t, int x) &#123;\n\tint m &#x3D; 0;&#x2F;&#x2F; 环上点的数量\n\tint y &#x3D; x, k, z &#x3D; 0;\n\tdo &#123;\n\t\ta[++m] &#x3D; f[y];&#x2F;&#x2F; a记录以环上各点为根的子树的直径f\n\t\tdu[y] &#x3D; 1;\n\t\tfor (k &#x3D; Head[y]; k; k &#x3D; Next[k])\n\t\t\tif (du[Edge[k]] &gt; 1) &#123;\n\t\t\t\tb[m+1] &#x3D; b[m] + Leng[k];&#x2F;&#x2F; 环上len前缀和b\n\t\t\t\ty &#x3D; Edge[k];\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t&#125; while (k);\n\tif (m &#x3D;&#x3D; 2) &#123;\n\t\tfor (int i &#x3D; Head[y]; i; i &#x3D; Next[i])\n\t\t\tif (Edge[i] &#x3D;&#x3D; x) z &#x3D; max(z, Leng[i]);\n\t\td[t] &#x3D; max(d[t], f[x] + f[y] + z);&#x2F;&#x2F;~x-(z)-y~\n\t\treturn;\n\t&#125;\n\tfor (int i &#x3D; Head[y]; i; i &#x3D; Next[i])\n\t\tif (Edge[i] &#x3D;&#x3D; x) &#123;\n\t\t\tb[m+1] &#x3D; b[m] + Leng[i];&#x2F;&#x2F;b成环\n\t\t\tbreak;\n\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt; m; i++) &#123;\n\t\ta[m+i] &#x3D; a[i];&#x2F;&#x2F;节点复制\n\t\tb[m+i] &#x3D; b[m+1] + b[i];&#x2F;&#x2F;前缀和+1圈！！！\n\t&#125;\n\tint l &#x3D; 1, r &#x3D; 1;&#x2F;&#x2F;单调队列\n\tq[1] &#x3D; 1;\n\tfor (int i &#x3D; 2; i &lt; (m &lt;&lt; 1); i++) &#123;&#x2F;&#x2F;a(子树直径f)-b(环上dis前缀和)\n\t\tif (l &lt;&#x3D; r &amp;&amp; i - q[l] &gt;&#x3D; m) ++l;\n\t\t&#x2F;&#x2F;d[tr]&#x3D;max(d[tr],f[i]+f[ql]+dis(i,ql))\n\t\td[t] &#x3D; max(d[t], a[i] + a[q[l]] + b[i] - b[q[l]]);&#x2F;&#x2F;ql:max(a-b)\n\t\twhile (l &lt;&#x3D; r &amp;&amp; a[q[r]] - b[q[r]] &lt;&#x3D; a[i] - b[i]) --r;\n\t\tq[++r] &#x3D; i;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123;\n\t\tint y, z;\n\t\tscanf(&quot;%d %d&quot;, &amp;y, &amp;z);\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t&#125;\n\tint t &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (!c[i]) bfs(i, ++t);&#x2F;&#x2F;bfs给森林节点i所在基环树编号c[i]&#x3D;t\n\ttopsort();&#x2F;&#x2F;求d[c]:基环树直径边权和\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (du[i] &gt; 1 &amp;&amp; !v[c[i]]) &#123;&#x2F;&#x2F; 入度大于1:环上的点\n\t\t\tv[c[i]] &#x3D; 1;\n\t\t\tdp(c[i], i);\n\t\t\tans +&#x3D; d[c[i]];&#x2F;&#x2F;各基环树直径和\n\t\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 359. 创世纪\t\t基环树dp\n\n&#x2F;&#x2F;Author:XuHt ??????\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1000006, INF &#x3D; 0x3f3f3f3f;\nint n, fa[N], t, k, f[N][2], s[N][2], ans;\nint Head[N], Edge[N&lt;&lt;1], Next[N&lt;&lt;1], tot;\n\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\ninline void add(int x, int y) &#123;\n\tEdge[++tot] &#x3D; y;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n\nvoid dfs(int x) &#123;\n\tint num &#x3D; INF;\n\tf[x][0] &#x3D; 0;\n\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i];\n\t\tif (y !&#x3D; k) dfs(y);\n\t\tf[x][0] +&#x3D; max(f[y][0], f[y][1]);\n\t\tnum &#x3D; min(num, max(f[y][0], f[y][1]) - f[y][0]);\n\t&#125;\n\tf[x][1] &#x3D; f[x][0] + 1 - num;&#x2F;&#x2F;+1???\n&#125;\n&#x2F;*\nf[x][1] &#x3D; max&#123;Σmax(f[son][0],f[son][1])−max(f[y][0],f[y][1])+f[y][0]&#125;\n\t\t&#x3D; Σmax(f[son][0],f[son][1])−min&#123;max(f[y][0],f[y][1])-f[y][0]&#125;\n\t\t&#x3D; f[x][0] - num\n*&#x2F;\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) fa[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x;\n\t\tscanf(&quot;%d&quot;, &amp;x);\n\t\tint p &#x3D; get(x), q &#x3D; get(i);\n\t\tif (p &#x3D;&#x3D; q) &#123;\n\t\t\ts[++t][0] &#x3D; x;\n\t\t\ts[t][1] &#x3D; i;\n\t\t&#125; else &#123;\n\t\t\tadd(x, i);&#x2F;&#x2F;\n\t\t\tfa[q] &#x3D; p;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tk &#x3D; 0;\n\t\tdfs(s[i][0]);\n\t\tk &#x3D; s[i][0];&#x2F;&#x2F;Ap 断环\n\t\tdfs(s[i][1]);&#x2F;&#x2F;p\n\t\tint now &#x3D; f[s[i][1]][1];&#x2F;&#x2F;f[p 1]\n\t\tf[s[i][0]][1] &#x3D; f[s[i][0]][0] + 1;&#x2F;&#x2F; 强制连接 p和A[p] 0-&gt;1\n\t\tdfs(s[i][1]);\n\t\tans +&#x3D; max(now, f[s[i][1]][0]);&#x2F;&#x2F;f[p][0]更新ans\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\nhttps:&#x2F;&#x2F;ac.nowcoder.com&#x2F;acm&#x2F;problem&#x2F;blogs&#x2F;51259\n\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\n#include&lt;string.h&gt;\n#include&lt;queue&gt;\n#include&lt;stack&gt;\n#define LL long long\n#define debug cout&lt;&lt;&quot;bug&quot;&lt;&lt;endl;\nusing namespace std;\nconst int maxn&#x3D;1000010;\ninline void read(int &amp;x)&#123;\n\tx&#x3D;0;int f&#x3D;1;char c&#x3D;getchar();\n\twhile(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;)&#123;if(c&#x3D;&#x3D;&#39;-&#39;) f&#x3D;-1;c&#x3D;getchar();&#125;\n\twhile(c&gt;&#x3D;&#39;0&#39;&amp;&amp;c&lt;&#x3D;&#39;9&#39;) x&#x3D;(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c&#x3D;getchar();\n\tx*&#x3D;f;&#125;\nstruct node&#123;int v,nxt;&#125;e[maxn];\nint head[maxn],tot;\ninline void add(int x,int y)&#123;\n\ttot++;\n\te[tot].v &#x3D;y;\n\te[tot].nxt &#x3D;head[x];\n\thead[x]&#x3D;tot;\n&#125;\nint n,a,cnt,ra[maxn],rb[maxn],now;\n \nint fa[maxn];\ninline int find(int x)\n&#123;\n\tif(fa[x]&#x3D;&#x3D;x) return x;\n\treturn fa[x] &#x3D; find(fa[x]);\n&#125;\n \nint f[maxn],g[maxn];&#x2F;&#x2F;f 放 g 不放\ninline void dfs(int x)\n&#123;\n\tint t&#x3D;1&lt;&lt;30;\n\tg[x]&#x3D;0;\n\tfor(int i&#x3D;head[x];i;i&#x3D;e[i].nxt )\n\t&#123;\n\t\tint v&#x3D;e[i].v ;\n\t\tif(v!&#x3D;now)\n\t\t\tdfs(v);\n\t\tg[x]+&#x3D;max(g[v],f[v]);\n\t\tt&#x3D;min(t, max(g[v],f[v])-g[v] ); &#x2F;&#x2F;没有上司的舞会中的技巧\n\t&#125;\n\tf[x]&#x3D;g[x]+1-t;\n&#125;\nint main()\n&#123;\n\tint ans&#x3D;0;\n\tread(n);\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++) fa[i]&#x3D;i;\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\t&#123;\n\t\tread(a);\n\t\tif(find(a)!&#x3D;find(i))\n\t\t&#123;\n\t\t\tadd(a,i);\n\t\t\tfa[fa[a]]&#x3D;fa[i];\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tcnt++,ra[cnt]&#x3D;a,rb[cnt]&#x3D;i;&#x2F;&#x2F;本身在环上是不连通的\n\t\t&#125;\n\t&#125;\n\tfor(int i&#x3D;1;i&lt;&#x3D;cnt;i++)&#x2F;&#x2F;森林\n\t&#123;\n\t\tdfs(ra[i]);\n\t\tnow&#x3D;ra[i];&#x2F;&#x2F;断环\n\t\tdfs(rb[i]),a&#x3D;f[rb[i]];&#x2F;&#x2F;在这一轮的dfs中是不会去更新 ra[i]儿子的f g值的，导致本身没有ra[i]的值也是没有的，所以需要上一个提前处理出来\n\t\tf[ra[i]]&#x3D;g[ra[i]]+1;&#x2F;&#x2F;强行链接 （在max中程序一定会选择f，它本身的限制节点rb[i]不会被选中 所以有限制他的充分条件）\n\t\tdfs(rb[i]), ans+&#x3D;max(g[rb[i]],a);\n\t&#125;\n\tprintf(&quot;%d&quot;,ans);\n\treturn 0;\n&#125;\n并查集只可以查找到这个环的一处，如果需要查找整个环那就只有前面页讲到的模板了。\n\n这里提出注意事项：在第一个dfs中我们对f是强行负值，这样对于一些叶子节点来讲t值是没有更改的，这就导致f值在最后是一个极小值，这样的f是不会更新答案的。如果不写第一个dfs，使得一些在本不能更新答案的点更新了答案，导致答案错误。所以第一个dfs是必要的。\n&#x2F;&#x2F; 同类型题目 骑士 推荐一做：https:&#x2F;&#x2F;www.luogu.org&#x2F;problem&#x2F;P2607\n\n\n&#x2F;*\n另解（贪心）：对于一个入度为0的点x，由于x无法被控制，所以只能不选。\n那么选择x控制的节点a[x]投放一定是最优的。 在选择a[x]之后，a[a[x]]就不能被\na[x]限制了，把他的度数-1，如果a[a[x]]的度数&#x3D;0，说明他也可以去限制别人了，\n就把他加入待转移集合中。可以用一个队列来实现这个操作。\n\n但是以上的转移完成之后，以上的贪心方法类似于拓扑，所以不适用于环，\n环上的点是不会被加入集合的！但是我们发现对于一个长度为cnt的环，\n可以选择投放的点为cnt&#x2F;2个（隔一个选一个），那么求出每一颗内向树环的长度即可。\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;CABI_ZGX&#x2F;article&#x2F;details&#x2F;83501714\n*&#x2F;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N&#x3D;1e6+10;\ninline int read()\n&#123;\n\tint x&#x3D;0,f&#x3D;1; char ch&#x3D;getchar();\n\twhile(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)f&#x3D;-1; ch&#x3D;getchar();&#125;\n\twhile(ch&gt;&#x3D;&#39;0&#39; &amp;&amp; ch&lt;&#x3D;&#39;9&#39;)&#123;x&#x3D;x*10+ch-&#39;0&#39;; ch&#x3D;getchar();&#125;\n\treturn x*f;\t\n&#125;\nint a[N],du[N],list[N],head,tail;\nbool v[N];\n\nint main()\n&#123;\n\tint n&#x3D;read();\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\t&#123;\n\t\ta[i]&#x3D;read();\n\t\tdu[a[i]]++;\n\t&#125;\n\thead&#x3D;1; tail&#x3D;0;\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\t\tif(du[i]&#x3D;&#x3D;0)\n\t\t\tlist[++tail]&#x3D;i;\n\tint ans&#x3D;0;\n\twhile(head&lt;&#x3D;tail)\n\t&#123;\n\t\tint x&#x3D;list[head];\n\t\tif(!v[x] &amp;&amp; !v[a[x]])\n\t\t&#123;\n\t\t\tans++; \t\n\t\t\tv[a[x]]&#x3D;1; \n\t\t\tdu[a[a[x]]]--; if(du[a[a[x]]]&#x3D;&#x3D;0) list[++tail]&#x3D;a[a[x]];\n\t\t&#125;\n\t\tv[list[head]]&#x3D;1; head++;\n\t&#125;\n\tint cnt&#x3D;0,j;\n\tfor(int i&#x3D;1;i&lt;&#x3D;n;i++)\n\t&#123;\n\t\tif(!v[i])\n\t\t&#123;\n\t\t\tcnt&#x3D;0;\n\t\t\tj&#x3D;i;\n\t\t\twhile(a[j]!&#x3D;i)\n\t\t\t&#123;\n\t\t\t\tv[j]&#x3D;1;\n\t\t\t\tcnt++;\n\t\t\t\tj&#x3D;a[j];\t\n\t\t\t&#125;\n\t\t\tv[j]&#x3D;1;\n\t\t\tans+&#x3D;(cnt+1)&#x2F;2;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;,ans);\n\treturn 0;\n&#125;\n--------------------------------------------------\n&#x2F;&#x2F; AcWing 360. Freda的传呼机\n&#x2F;*\n静态边仙人掌(圆方树)\n前置知识： 运用Tarjan求点双联通分量v-DCC\n学习时参见的博客： https:&#x2F;&#x2F;www.luogu.org&#x2F;blog&#x2F;PinkRabbit&#x2F;Introduction-to-Round-Square-Tree\n时间复杂度分析：Θ(n+qlogn)\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;3936&#x2F;\n*&#x2F;\n\n\n\n\n\n&#x2F;&#x2F;0x65. 负环与差分约束\n&#x2F;&#x2F; AcWing 361. 观光奶牛\n&#x2F;*\npoj3621 sightseeing cow解题报告\nhttps:&#x2F;&#x2F;wenku.baidu.com&#x2F;view&#x2F;f2a563d076eeaeaad1f3305e.html\n2007NOI国家集训队论文_day2《最小割模型在信息学竞赛中的应用》 胡伯涛\n*&#x2F;\n&#x2F;&#x2F;最优比率环\n&#x2F;&#x2F;Author:XuHt\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 1006, M &#x3D; 5006;\nconst double eps &#x3D; 1e-6;\nint n, m, c[N], f[N], x[M], y[M], z[M];\nint Head[N], Edge[M], Next[M], tot;\ndouble Leng[M], d[N];\nbool v[N];\n\nvoid add(int x, int y, double z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n&#x2F;*\n负环的原理就是说存在一个长度为n的最短路路径，这样无限走肯定有个负环。\n那么其实跑的是一个多源的最短路，要【检查每个点出发能否无限走】最短路，所以这里dis具体是多少没有多大意义，只是为了表达相对大小关系，如果存在负环，即可以一直更新一直走~ \t\t所以d[i] &#x3D; 0; v[i] &#x3D; 1;&#x2F;&#x2F;全in_queue init_0\n*&#x2F;\nbool spfa() &#123;\n\tqueue&lt;int&gt; q;\n\t&#x2F;&#x2F; memset(d, 0x3f, sizeof d);\n\t&#x2F;&#x2F; d[1] &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tq.push(i);\n\t\td[i] &#x3D; 0;&#x2F;&#x2F;\n\t\tv[i] &#x3D; 1;&#x2F;&#x2F;\n\t&#125;\n\tmemset(c, 0, sizeof(c));&#x2F;&#x2F;c&#x3D;&#x3D;cnt\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tv[x] &#x3D; 0;\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i];\n\t\t\tif (d[y] &gt; d[x] + Leng[i]) &#123;\n\t\t\t\td[y] &#x3D; d[x] + Leng[i];\n\t\t\t\tif (++c[y] &gt;&#x3D; n) return 1;\n\t\t\t\tif (!v[y]) &#123;\n\t\t\t\t\tq.push(y);\n\t\t\t\t\tv[y] &#x3D; 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nbool check(double w) &#123;\n\ttot &#x3D; 0;\n\tmemset(Head, 0, sizeof(Head));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tadd(x[i], y[i], w * z[i] - f[x[i]]);\n\treturn spfa();&#x2F;&#x2F;有负环 mid&lt;ans\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d&quot;, &amp;f[i]);&#x2F;&#x2F;f:点权\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x[i], &amp;y[i], &amp;z[i]);&#x2F;&#x2F;z:边权\n\tdouble l &#x3D; 0, r &#x3D; 1000;\n\twhile (r - l &gt; eps) &#123;&#x2F;&#x2F;&gt;eps：从简l&#x3D;mid r&#x3D;mid\n\t\tdouble mid &#x3D; (l + r) &#x2F; 2;\n\t\tif (check(mid)) l &#x3D; mid;\n\t\telse r &#x3D; mid;\n\t&#125;\n\tprintf(&quot;%.2f&quot;, l);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;【差分约束系统】\n&#x2F;&#x2F; AcWing 362. 区间\n&#x2F;&#x2F;Author:XuHt\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 500006, M &#x3D; 5000006;\nint n, m, d[N];\nint Head[N], Edge[M], Leng[M], Next[M], tot;\nbool v[N];\n\ninline void add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y;\n\tLeng[tot] &#x3D; z;\n\tNext[tot] &#x3D; Head[x];\n\tHead[x] &#x3D; tot;\n&#125;\n\nvoid spfa() &#123;&#x2F;&#x2F;模板\n\tqueue&lt;int&gt; q;\n\tq.push(0);\n\tv[0] &#x3D; 1;\n\td[0] &#x3D; 0;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tv[x] &#x3D; 0;\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i];\n\t\t\tif (d[y] &lt; d[x] + Leng[i]) &#123;&#x2F;&#x2F;单源最长路\n\t\t\t\td[y] &#x3D; d[x] + Leng[i];\n\t\t\t\tif (!v[y]) &#123;\n\t\t\t\t\tv[y] &#x3D; 1;\n\t\t\t\t\tq.push(y);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tmemset(d, 0xcf, sizeof(d));\n\ttot &#x3D; m &#x3D; 0;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x, y, z;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);\n\t\tadd(x, y + 1, z);&#x2F;&#x2F;? add(x - 1, y, z);\n\t\tm &#x3D; max(m, y + 1);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tadd(i - 1, i, 0);\n\t\tadd(i, i - 1, -1);\n\t&#125;\n\tspfa();\n\tcout &lt;&lt; d[m] &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 贪心 + 数据结构做法\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;6528&#x2F;\n朴素贪心\n考虑把所有线段按照右端点 b 从小到大排序，依次考虑每一条线段的要求：\n\n如果已经满足要求则跳过\n否则尽量选择靠后的数（因为之后的线段的右端点都在这条线段的右边，这样容错更高）\n所以，我们可以建一个数组，d[i] 表示 i 数字是否选择（填1或0），\n【扫一遍 [l,r] 区间求和】，然后【从后往前贪心放数】即可。\n\n对于每条线段需要 O(r−l+1)。所以最坏情况下 O(n2)。但是轻松 52ms 过了。\n\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 50005;\nint n, d[N], c[N];\nstruct Seg&#123;\n\tint a, b, c;\n\tbool operator &lt; (const Seg &amp;x) const &#123;\n\t\treturn b &lt; x.b;\n\t&#125;\n&#125;e[N];\nint main() &#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d%d%d&quot;, &amp;e[i].a, &amp;e[i].b, &amp;e[i].c);\n\tsort(e + 1, e + 1 + n);\n\tint ans &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint l &#x3D; e[i].a, r &#x3D; e[i].b, cnt &#x3D; e[i].c;\n\t\tfor (int j &#x3D; l; j &lt;&#x3D; r; j++)\n\t\t\tcnt -&#x3D; d[j];&#x2F;&#x2F;\n\t\tif(cnt &gt; 0) &#123;\n\t\t\tfor (int j &#x3D; r; j &gt;&#x3D; l &amp;&amp; cnt; j--)&#x2F;&#x2F;&lt;-\n\t\t\t\tif(!d[j]) cnt--, ans++, d[j] &#x3D; 1;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, ans);\n\treturn 0;\n&#125;\n\n优化\n考虑用数据结构优化。\n\n发现我们需要三个操作：\n\n询问 [l,r] 区间的数字个数\n将值为 x 的位置 +1\n从后往前，找到比当前位置靠前的下一个 0 的位置。\n\n前两个就是 “区间求和，单调修改”，典型的树状数组。O(nlog50000)\n第三种操作，可以用并查集优化。为什么可以确保时间复杂度呢？对于每一条线段，最多只有一次会枚举到 1 （即开始的那一次），之后每次枚举都会枚举到 0 的位置，即d[i]&#x3D;0，然后把它变成 1，而以后就不会访问到了。而一共有 50000 个值，所以复杂度是 O(50000logn)\t33ms\n\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 50001;\nint n, d[N], c[N], f[N];\nstruct Seg&#123;\n\tint a, b, c;\n\tbool operator &lt; (const Seg &amp;x) const &#123;\n\t\treturn b &lt; x.b;\n\t&#125;\n&#125;e[N];\n&#x2F;&#x2F; 树状数组\nint inline ask(int x) &#123;\n\tint res &#x3D; 0;\n\tfor (; x; x -&#x3D; x &amp; -x) res +&#x3D; c[x];&#x2F;&#x2F;向左\n\treturn res;\n&#125;\n\nvoid inline add(int x) &#123;\n\tfor (; x &lt; N; x +&#x3D; x &amp; -x) c[x]++;&#x2F;&#x2F;向上\n&#125;\n&#x2F;&#x2F; 并查集：find(x) 表示找到 &lt;&#x3D; x 中最大的一个是 0 的数\nint find(int x) &#123;\n\treturn x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; find(f[x]);&#x2F;&#x2F;f[j]&#x3D;&#x3D;find(j-1)\n&#125;\nint main() &#123;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tfor (int i &#x3D; 0; i &lt; N; i++) f[i] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) \n\t\tscanf(&quot;%d%d%d&quot;, &amp;e[i].a, &amp;e[i].b, &amp;e[i].c);\n\tsort(e + 1, e + 1 + n);\n\tint ans &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint l &#x3D; e[i].a, r &#x3D; e[i].b, cnt &#x3D; e[i].c;\n\t\t&#x2F;&#x2F; 取 [l, r] 选了多少个数\n\t\tcnt -&#x3D; ask(r) - ask(l - 1);\n\t\tif(cnt &gt; 0) &#123;\n\t\t\tfor (int j &#x3D; r; j &gt;&#x3D; l &amp;&amp; cnt; ) &#123;\n\t\t\t\t&#x2F;&#x2F; d[j] &#x3D;&#x3D; 1 的情况每条线段至多出现一次\n\t\t\t\tif(!d[j]) &#123;\n\t\t\t\t\tcnt--, ans++, d[j] &#x3D; 1;\n\t\t\t\t\t&#x2F;&#x2F; j 被标记成 1 了，要指向 find(j - 1)\n\t\t\t\t\tf[j] &#x3D; j - 1;\n\t\t\t\t\t&#x2F;&#x2F; 维护树状数组\n\t\t\t\t\tadd(j);\n\t\t\t\t&#125;;\n\t\t\t\tif(find(j) !&#x3D; j) j &#x3D; f[j];&#x2F;&#x2F;路径压缩:f[j]&#x3D;&#x3D;find(j-1)！！！\n\t\t\t\telse j--;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;, ans);\n\treturn 0;\n&#125;\n\n作者：墨染空\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;AcWing&#x2F;content&#x2F;6528&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;0x66. Tarjan算法与无向图连通性\n&#x2F;&#x2F; AcWing 363. B城\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100010, M &#x3D; 500010;\nint head[N], ver[M * 2], Next[M * 2];\nint dfn[N], low[N], Size[N];\nlong long ans[N];\nbool cut[N];\nint n, m, tot, num;\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid tarjan(int x) &#123;&#x2F;&#x2F;割点判定\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tSize[x] &#x3D; 1;&#x2F;&#x2F;\n\tint flag &#x3D; 0, sum &#x3D; 0;&#x2F;&#x2F;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y);\n\t\t\tSize[x] +&#x3D; Size[y];&#x2F;&#x2F;\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t\tif (low[y] &gt;&#x3D; dfn[x]) &#123;\n\t\t\t\tflag++;\n\t\t\t\tans[x] +&#x3D; (long long)Size[y] * (n - Size[y]);&#x2F;&#x2F;\n\t\t\t\tsum +&#x3D; Size[y];&#x2F;&#x2F;\n\t\t\t\tif (x !&#x3D; 1 || flag &gt; 1) cut[x] &#x3D; true;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse low[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n\tif (cut[x])&#x2F;&#x2F;\n\t\tans[x] +&#x3D; (long long)(n - sum - 1)*(sum + 1) + (n - 1);\n\telse\n\t\tans[x] &#x3D; 2 * (n - 1);\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\ttot &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tif (x &#x3D;&#x3D; y) continue;\n\t\tadd(x, y), add(y, x);\n\t&#125;\n\ttarjan(1);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tprintf(&quot;%lld\\n&quot;, ans[i]);\n&#125;\n\n&#x2F;&#x2F; AcWing 364. 网络\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int N &#x3D; 200010;\nint head[N], ver[N * 2], Next[N * 2];\nint dfn[N], low[N], c[N];\nint n, m, t, tot, num, dcc, tc, T;\nbool bridge[N * 2], v[N];\nint hc[N], vc[N * 2], nc[N * 2];\nint d[N], f[N][20], fa[N];\nqueue&lt;int&gt; q;\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid add_c(int x, int y) &#123;\n\tvc[++tc] &#x3D; y, nc[tc] &#x3D; hc[x], hc[x] &#x3D; tc;\n&#125;\n\nvoid tarjan(int x, int in_edge) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y, i);&#x2F;&#x2F;\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t\tif (low[y] &gt; dfn[x])\n\t\t\t\tbridge[i] &#x3D; bridge[i ^ 1] &#x3D; true;\n\t\t&#125;\n\t\telse if (i !&#x3D; (in_edge ^ 1))&#x2F;&#x2F;忽略(入边^1)\n\t\t\tlow[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n&#125;\n\nvoid dfs(int x) &#123;\n\tc[x] &#x3D; dcc;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (c[y] || bridge[i]) continue;&#x2F;&#x2F;忽略bridge\n\t\tdfs(y);\n\t&#125;\n&#125;\n\nvoid bfs() &#123;\n\tq.push(1);\n\td[1] &#x3D; 1;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int i &#x3D; hc[x]; i; i &#x3D; nc[i]) &#123;\n\t\t\tint y &#x3D; vc[i];\n\t\t\tif (d[y]) continue;\n\t\t\td[y] &#x3D; d[x] + 1;\n\t\t\tf[y][0] &#x3D; x;\n\t\t\tfor (int j &#x3D; 1; j &lt; 18; j++)\n\t\t\t\tf[y][j] &#x3D; f[f[y][j - 1]][j - 1];\n\t\t\tq.push(y);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint lca(int x, int y) &#123;\n\tif (d[x] &lt; d[y]) swap(x, y);\n\tfor (int i &#x3D; 17; i &gt;&#x3D; 0; i--)\n\t\tif (d[f[x][i]] &gt;&#x3D; d[y]) x &#x3D; f[x][i];\n\tif (x &#x3D;&#x3D; y) return x;\n\tfor (int i &#x3D; 17; i &gt;&#x3D; 0; i--)\n\t\tif (f[x][i] !&#x3D; f[y][i]) x &#x3D; f[x][i], y &#x3D; f[y][i];\n\treturn f[x][0];\n&#125;\n\nint get(int x) &#123;\n\tif (x &#x3D;&#x3D; fa[x]) return x;\n\treturn fa[x] &#x3D; get(fa[x]);\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;\n\t\t&#x2F;&#x2F; 多组数据，清零\n\t\ttot &#x3D; 1; num &#x3D; dcc &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\thead[i] &#x3D; dfn[i] &#x3D; hc[i] &#x3D; d[i] &#x3D; c[i] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; 2 * m + 1; i++)\n\t\t\tbridge[i] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\t\tint x, y;\n\t\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\t\tadd(x, y), add(y, x);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 求割边、边双连通分量\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!dfn[i]) tarjan(i, 0);\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!c[i]) &#123;\n\t\t\t\t++dcc;\n\t\t\t\tdfs(i);\n\t\t\t&#125;\n\t\t&#x2F;&#x2F; 缩点建图\n\t\ttc &#x3D; 1;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;\n\t\t\tint x &#x3D; ver[i ^ 1], y &#x3D; ver[i];\n\t\t\tif (c[x] &#x3D;&#x3D; c[y]) continue;\n\t\t\tadd_c(c[x], c[y]);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 倍增lca预处理\n\t\tbfs();&#x2F;&#x2F;d:dep f\n\t\t&#x2F;&#x2F; 并查集初始化\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; dcc; i++) fa[i] &#x3D; i;\n\t\t&#x2F;&#x2F; 处理询问\n\t\tcin &gt;&gt; t;\n\t\tint ans &#x3D; dcc - 1;&#x2F;&#x2F;总桥数\n\t\tprintf(&quot;Case %d:\\n&quot;, ++T);\n\t\twhile (t--) &#123;\n\t\t\tint x, y;\n\t\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\t\tx &#x3D; c[x], y &#x3D; c[y];\n\t\t\tint p &#x3D; lca(x, y);\n\t\t\t&#x2F;&#x2F;并查集路径压缩优化\n\t\t\tx &#x3D; get(x);\n\t\t\twhile (d[x] &gt; d[p]) &#123;\n\t\t\t\tfa[x] &#x3D; f[x][0];\n\t\t\t\tans--;\n\t\t\t\tx &#x3D; get(x);\n\t\t\t&#125;\n\t\t\ty &#x3D; get(y);\n\t\t\twhile (d[y] &gt; d[p]) &#123;\n\t\t\t\tfa[y] &#x3D; f[y][0];\n\t\t\t\tans--;\n\t\t\t\ty &#x3D; get(y);\n\t\t\t&#125;\n\t\t\tprintf(&quot;%d\\n&quot;, ans);\n\t\t&#125;\n\t\tcout &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 365. 圆桌骑士\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\nconst int N &#x3D; 1010, M &#x3D; 2000010;\nint head[N], ver[M], Next[M];\nint dfn[N], low[N], stack[N];\nint c[N], v[N], able[N];\nint n, m, tot, num, top, cnt, now;\nbool hate[N][N], flag;\nvector&lt;int&gt; dcc[N];\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid tarjan(int x, int root) &#123;&#x2F;&#x2F;v-dcc\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tstack[++top] &#x3D; x;\n\tif (x &#x3D;&#x3D; root &amp;&amp; head[x] &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 孤立点\n\t\tdcc[++cnt].push_back(x);\n\t\treturn;\n\t&#125;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y, root);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t\tif (low[y] &gt;&#x3D; dfn[x]) &#123;\n\t\t\t\tcnt++;\n\t\t\t\tint z;\n\t\t\t\tdo &#123;\n\t\t\t\t\tz &#x3D; stack[top--];\n\t\t\t\t\tdcc[cnt].push_back(z);\n\t\t\t\t&#125; while (z !&#x3D; y);\n\t\t\t\tdcc[cnt].push_back(x);\n\t\t\t&#125;\n\t\t&#125;\n\t\telse low[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n&#125;\n\nvoid dfs(int x, int color) &#123;\n\tc[x] &#x3D; color;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; ver[i];\n\t\tif (v[y] !&#x3D; now) continue;&#x2F;&#x2F;\n\t\tif (c[y] &amp;&amp; c[y] &#x3D;&#x3D; color) &#123;\n\t\t\tflag &#x3D; 1;&#x2F;&#x2F;非二分图 存在奇环\n\t\t\treturn;\n\t\t&#125;\n\t\tif (!c[y]) dfs(y, 3 - color);\n\t&#125;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;\n\t\t&#x2F;&#x2F; 清零\n\t\tmemset(head, 0, sizeof(head));\n\t\tmemset(dfn, 0, sizeof(dfn));\n\t\tmemset(able, 0, sizeof(able));\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) dcc[i].clear();\n\t\ttot &#x3D; 1; num &#x3D; top &#x3D; cnt &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) hate[i][j] &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\t\tint x, y;\n\t\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\t\tif (x &#x3D;&#x3D; y) continue;\n\t\t\thate[x][y] &#x3D; hate[y][x] &#x3D; 1;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 建补图\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t\tfor (int j &#x3D; i + 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif (!hate[i][j]) add(i, j), add(j, i);\n\t\t&#x2F;&#x2F; 求点双连通分量\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!dfn[i]) tarjan(i, i);\n\t\t&#x2F;&#x2F; 判断每个点双是否包含奇环\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;\n\t\t\tnow &#x3D; i;\n\t\t\tfor (int j &#x3D; 0; j &lt; dcc[i].size(); j++)\n\t\t\t\tv[dcc[i][j]] &#x3D; now, c[dcc[i][j]] &#x3D; 0;&#x2F;&#x2F;v:所在dcc c:colorinit_0\n\t\t\tflag &#x3D; false;\n\t\t\tdfs(dcc[i][0], 1);&#x2F;&#x2F;dfs(x,color) 染色法judge: 二分图&#x3D;无奇环\n\t\t\tif (flag)&#x2F;&#x2F;dcc中存在奇环\n\t\t\t\tfor (int j &#x3D; 0; j &lt; dcc[i].size(); j++)\n\t\t\t\t\table[dcc[i][j]] &#x3D; 1;\n\t\t&#125;\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\t\tif (!able[i]) ans++;\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 366. 看牛\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint head[10010], ver[100010], Next[100010], tot; &#x2F;&#x2F; 邻接表\nint stack[100010], ans[100010]; &#x2F;&#x2F; 模拟系统栈，答案栈\nbool vis[100010];\nint n, m, top, t;\n\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid euler() &#123;\n\tstack[++top] &#x3D; 1;\n\twhile (top &gt; 0) &#123;\n\t\tint x &#x3D; stack[top], i &#x3D; head[x];\n\t\t&#x2F;&#x2F; 找到一条尚未访问的边\n\t\twhile (i &amp;&amp; vis[i]) i &#x3D; Next[i];\n\t\t&#x2F;&#x2F; 沿着这条边模拟递归过程，标记该边，并更新表头\n\t\tif (i) &#123;\n\t\t\tstack[++top] &#x3D; ver[i];\n\t\t\thead[x] &#x3D; Next[i];\n\t\t\t&#x2F;&#x2F; vis[i] &#x3D; vis[i ^ 1] &#x3D; true;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 与x相连的所有边均已访问，模拟回溯过程，并记录\n\t\telse &#123;\n\t\t\ttop--;\n\t\t\tans[++t] &#x3D; x;\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\ttot &#x3D; 1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tadd(x, y), add(y, x);\n\t&#125;\n\teuler();\n\tfor (int i &#x3D; t; i; i--) printf(&quot;%d\\n&quot;, ans[i]);\n&#125;\n\n\n&#x2F;&#x2F;0x67. Tarjan算法与有向图连通性\n&#x2F;&#x2F; AcWing 367. 学校网络\n&#x2F;*\n问题二\n结论\n若 scc_cnt&#x3D;1（只有一个强连通分量），则不需要连新的边，答案为 0。\n若 scc_cnt&gt;1，则答案为 max(src,des)。\n证明（yxc讲解总结）\n结论 1 正确性显然，下面证明结论 2。\n\n设缩点后的 DAG 中，起点（入度为 0）的集合为 P，终点（出度为 0）的集合为 Q。分以下两种情况讨论：\n\n|P|≤|Q|\n① 若 |P|&#x3D;1，则只有一个起点，并且这个起点能走到所有点，只要将每一个终点都向这个起点连一条边，那么对于图中任意一点，都可以到达所有点，新加的边数为 |Q|。\n\n② 若 |P|≥2，则 |Q|≥|P|≥2，此时至少存在 2 个起点 p1,p2，2 个终点 q1,q2，满足 p1 能走到 q1，p2 能走到 q2。（反证法：如果不存在两个起点能走到不同的终点，则所有的起点一定只能走到同一个终点，而终点至少有两个，发生矛盾，假设不成立）。如下图：\n\n那么我们可以从 q1 向 p2 新连一条边，那么此时起点和终点的个数都会减少一个（p2 不再是起点，q1 不再是终点），因此只要以这种方式，连接新边 |P|−1 条，则 |P′|&#x3D;1，而 |Q′|&#x3D;|Q|−(|P|−1)，由 ① 得，当 |P′|&#x3D;1 时，需要再连 |Q′| 条新边，那么总添加的新边数量为 |P|−1+|Q|−(|P|−1)&#x3D;|Q|。\n\n|Q|≤|P|\n与情况 1 对称，此时答案为 |P|。\n\n综上所述，scc_cnt&gt;1 时，问题二的答案为 max(|P|,|Q|) 即 max(src,des)。\n*&#x2F;\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 106;\nint n, dfn[N], low[N], num &#x3D; 0;\nint st[N], top &#x3D; 0, tot &#x3D; 0, c[N], ru[N], chu[N];\nbool v[N];\nvector&lt;int&gt; e[N], scc[N], sc[N];\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tst[++top] &#x3D; x;\n\tv[x] &#x3D; 1;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t&#125; else if (v[y]) low[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n&#x2F;*\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\tv[x] &#x3D; 0;\n\t\tscc[++tot].push_back(x);\n\t\tc[x] &#x3D; tot;\n\t\tint y;\n\t\twhile (x !&#x3D; (y &#x3D; st[top--])) &#123;\n\t\t\tscc[tot].push_back(y);\n\t\t\tv[y] &#x3D; 0;\n\t\t\tc[y] &#x3D; tot;\n\t\t&#125;\n\t&#125;*&#x2F;\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\ttot++; int y;\n\t\tdo &#123;\n\t\t\ty &#x3D; st[top--];\n\t\t\tscc[tot].push_back(y);\n\t\t\tv[y] &#x3D; 0;\n\t\t\tc[y] &#x3D; tot;\n\t\t&#125; while (x !&#x3D; y);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint x;\n\t\twhile (scanf(&quot;%d&quot;, &amp;x) &amp;&amp; x) e[i].push_back(x); &#x2F;&#x2F;i 应该支援的学校\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (!dfn[i]) tarjan(i);\n\tfor (int x &#x3D; 1; x &lt;&#x3D; n; x++)\n\t\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\t\tint y &#x3D; e[x][i];\n\t\t\tif (c[x] &#x3D;&#x3D; c[y]) continue;&#x2F;&#x2F;\n\t\t\t&#x2F;&#x2F; sc[c[x]].push_back(c[y]);\n\t\t\tru[c[y]]++;\n\t\t\tchu[c[x]]++;\n\t\t&#125;\n\tint ansa &#x3D; 0, ansb &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++) &#123;\n\t\tif (!ru[i]) ansa++;\n\t\tif (!chu[i]) ansb++;\n\t&#125;\n\tcout &lt;&lt; ansa &lt;&lt; endl;\n\tint ans &#x3D; max(ansa, ansb);\n\tif (tot &#x3D;&#x3D; 1) puts(&quot;0&quot;);\n\telse cout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; AcWing 368. 银河\n&#x2F;&#x2F;Author:XuHt\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#define ll long long\nusing namespace std;\nconst int N &#x3D; 100006;\nint n, m, num, top, cnt;\nint d[N], dfn[N], low[N], st[N], c[N], deg[N], f[N], scc[N];\nbool ins[N];\nvector&lt;pair&lt;int, int&gt; &gt; e[N], ec[N];\nqueue&lt;int&gt; q;\n\ninline void add(int x, int y, int z) &#123;\n\te[x].push_back(&#123;y, z&#125;);\n&#125;\n\ninline void addc(int x, int y, int z) &#123;\n\tec[x].push_back(&#123;y, z&#125;);\n\t++deg[y];\n&#125;\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tst[++top] &#x3D; x;\n\tins[x] &#x3D; 1;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i].first;\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t&#125; else if (ins[y])\n\t\t\tlow[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\t++cnt;\n\t\tint y;\n\t\tdo &#123;\n\t\t\ty &#x3D; st[top--];\n\t\t\tins[y] &#x3D; 0;\n\t\t\tc[y] &#x3D; cnt;\n\t\t\t++scc[cnt];&#x2F;&#x2F;scc_size\n\t\t&#125; while (y !&#x3D; x);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint o, a, b;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;o, &amp;a, &amp;b);\n\t\tif (o &#x3D;&#x3D; 2) add(a, b, 1);\n\t\telse if (o &#x3D;&#x3D; 3) add(b, a, 0);\n\t\telse if (o &#x3D;&#x3D; 4) add(b, a, 1);\n\t\telse if (o &#x3D;&#x3D; 5) add(a, b, 0);\n\t\telse &#123;\n\t\t\tadd(a, b, 0);\n\t\t\tadd(b, a, 0);\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) add(0, i, 1);\n\ttarjan(0);\n\tfor (int x &#x3D; 0; x &lt;&#x3D; n; x++)\n\t\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\t\tint y &#x3D; e[x][i].first, z &#x3D; e[x][i].second;\n\t\t\tif (c[x] &#x3D;&#x3D; c[y]) &#123;&#x2F;&#x2F;scc内存在边权为1：无解\n\t\t\t\tif (!z) continue;\n\t\t\t\tputs(&quot;-1&quot;);\n\t\t\t\treturn 0;\n\t\t\t&#125;\n\t\t\taddc(c[x], c[y], z);\n\t\t&#125;\n\t&#x2F;&#x2F;拓扑序DP最长路\n\tfor (int i &#x3D; 1; i &lt;&#x3D; cnt; i++)\n\t\tif (!deg[i]) q.push(i);\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (unsigned int i &#x3D; 0; i &lt; ec[x].size(); i++) &#123;\n\t\t\tint y &#x3D; ec[x][i].first, z &#x3D; ec[x][i].second;\n\t\t\tf[y] &#x3D; max(f[y], f[x] + z);&#x2F;&#x2F;最长路\n\t\t\tif (!--deg[y]) q.push(y);\n\t\t&#125;\n\t&#125;\n\tll ans &#x3D; 0;&#x2F;&#x2F;f[i]:最长路 &#x3D;&#x3D; scc[i]内所有点的最小亮度\n\tfor (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) ans +&#x3D; (ll)f[i] * scc[i];\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 369. 北大ACM队的远足 SCC 有向图必经边_bri\n&#x2F;*\n一条边可能覆盖两次，并且覆盖的不一定是连续的桥\n\n特判没有路径的无解情况\n\n错误的拓扑排序求最短路方式，即只把 s 起点塞到队列里进行拓扑排序，若有一些零度点指向了该路径上的一些点，由于零度点并没有进入刷新，所以那些点的度不会被减到 0，从而就炸裂了，被错判成无解。\n正确的做法是按照往常一样【零入度点入队列】做拓扑排序，只不过初始化时d[s]&#x3D;0, 其余均赋值为正无穷，之后每条边该转移时更新一下即可。\n\n区间的值域很大，但是可以贪心考虑。考虑找到一组最优解，将其向右平移，使他的右端点是一个桥边的右端点，这样答案不会变差。（覆盖桥长尽量长）所以我们 DP 每次的决策只需考虑在每条桥边的端点开始&#x2F;结束坐车即可。\n\n一些定义\n设 d[i] 为 从 S 到第 i 个节点的距离\n设 g[i] 为 从 S 到第 i 个节点的桥的距离\n设 bri[i] 为 [i−1,i] 这段是不是桥\n这些玩意都是可以跑最短路后把最短路抽出来变成一条链 O(n+m) 处理的。\n\nDP\n设 ds[i] 为从 S 到第 i 个节点的最小危险程度&#x3D;&#x3D;S-&gt;i 【uncover的总桥长】\nds[i] &#x3D; min(g[i], ds[i - 1] + g[i] - g[i - 1]);&#x2F;&#x2F;不被k更新的init_ds！！！\n设 dt[i] 为从 i 到第 T 个节点的最小危险程度\n\n处理 ds\n如果 d[i]−d[i−1] 这段是桥：\n\n找到一个最小的 k 满足 d[i]−d[k]&lt;&#x3D;q。显然 i 增大的时候，k 也是不降的，具有单调性可以用双指针 O(n)。\n\n如果 bri[k]\n​ ds[i]&#x3D;g[k]−(q−(d[i]−d[k]))\n否则 ds[i]&#x3D;g[k]\n\n处理 dt\ndt[i] 类似\n找到一个最大的 k 使得 d[k]−d[i]&lt;&#x3D;q\n如果 bri[k]\n​ dt[i]&#x3D;g[tot]−g[k]−(q−(d[k]−d[i]))\n否则 dt[i]&#x3D;g[tot]−g[k]\n真实的分类讨论:\n假设一条桥边上没有覆盖两次，那么必然可以用书中的放法，将桥边画一条界，两边分别取最优。\n否则，假设最优解是一条桥边上覆盖两次的情况，那么存在一种方式是紧挨着的最优解，因为将他们平移至紧挨着答案不会变差，然后问题变成了 2Q 长度的一个覆盖，然后这个覆盖和之前类似，都是把线段平移到端点不会变差，这里就不再赘述。\n\n作者：墨染空\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;192066&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n*&#x2F;\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 100005, M &#x3D; 200005, P &#x3D; 1e9 + 7, INF &#x3D; 0x3f3f3f3f;\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; PII;\nint n, m, S, T, Q;\nint head[N], bhead[N], pre[N], d[N], dis[N], g[N], ds[N], dt[N], degS[N];\nint a[N], tot, q[N], degT[N], fs[N], ft[N], numE;\nbool st[M &lt;&lt; 2], bri[N];\n\nstruct E&#123;\n\tint next, v, w;\n&#125; e[M &lt;&lt; 2];\n\nvoid inline add(int u, int v, int w, int h[]) &#123;\n\te[++numE] &#x3D; (E) &#123; h[u], v, w &#125;;\n\th[u] &#x3D; numE;\n&#125;\n\nvoid toposort(int s, int t, int h[], int cnt[], int deg[], int opt) &#123;\n\tfor (int i &#x3D; 0; i &lt; n; i++) cnt[i] &#x3D; 0;\n\tcnt[s] &#x3D; 1;\n\tint hh &#x3D; 0, tt &#x3D; -1;\n\tfor (int i &#x3D; 0; i &lt; n; i++) if (!deg[i]) q[++tt] &#x3D; i;&#x2F;&#x2F;0入度入队\n\twhile (hh &lt;&#x3D; tt) &#123;\n\t\tint u &#x3D; q[hh++];\n\t\tfor (int i &#x3D; h[u]; ~i; i &#x3D; e[i].next) &#123;\n\t\t\tint v &#x3D; e[i].v;\n\t\t\tif (opt &amp;&amp; dis[u] + e[i].w &lt; dis[v])&#x2F;&#x2F;反图opt&#x3D;0：不覆盖\n\t\t\t\tdis[v] &#x3D; dis[u] + e[i].w, pre[v] &#x3D; i;&#x2F;&#x2F;ST最短路 pre:入边\n\t\t\t(cnt[v] +&#x3D; cnt[u]) %&#x3D; P;&#x2F;&#x2F;\n\t\t\tif (--deg[v] &#x3D;&#x3D; 0) q[++tt] &#x3D; v;\n\t\t&#125;\n\t&#125;\n&#125;\n\nvoid inline clear() &#123;\n\tnumE &#x3D; -1, tot &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\thead[i] &#x3D; bhead[i] &#x3D; -1, dis[i] &#x3D; INF;\n\t\tdegS[i] &#x3D; degT[i] &#x3D; 0, bri[i] &#x3D; false;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; 2 * m; i++) st[i] &#x3D; false;\n&#125;\n\nint main() &#123;\n\tint Case; scanf(&quot;%d&quot;, &amp;Case);\n\twhile (Case--) &#123;\n\t\tscanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;S, &amp;T, &amp;Q); clear();\n\t\tfor (int i &#x3D; 1, u, v, w; i &lt;&#x3D; m; i++) &#123;\n\t\t\tscanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);\n\t\t\tadd(u, v, w, head); add(v, u, w, bhead);\n\t\t\tdegS[v]++, degT[u]++;&#x2F;&#x2F;S、T出发的入度\n\t\t&#125;\n\t\tdis[S] &#x3D; 0;\n\t\ttoposort(S, T, head, fs, degS, 1);\n\t\tif (dis[T] &#x3D;&#x3D; INF) &#123; puts(&quot;-1&quot;); continue; &#125;&#x2F;&#x2F;无解\n\t\ttoposort(T, S, bhead, ft, degT, 0);&#x2F;&#x2F;opt&#x3D;0: 只算ft,保留dis pre\n\t\ta[++tot] &#x3D; T; \n\t\twhile (a[tot] !&#x3D; S) a[++tot] &#x3D; e[pre[a[tot]] ^ 1].v;&#x2F;&#x2F;倒推\n\t\treverse(a + 1, a + 1 + tot);&#x2F;&#x2F;a:ST最短路\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++) d[i] &#x3D; dis[a[i]];&#x2F;&#x2F;d[i]:最短路上i与S距\n\t\tfor (int u &#x3D; 0; u &lt; n; u++) &#123;\n\t\t\tfor (int i &#x3D; head[u]; ~i; i &#x3D; e[i].next) &#123;\n\t\t\t\tint v &#x3D; e[i].v;\n\t\t\t\tif ((LL)fs[u] * ft[v] % P &#x3D;&#x3D; fs[T]) st[i] &#x3D; true;&#x2F;&#x2F;st:必经边桥\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) bri[i] &#x3D; st[pre[a[i]]], g[i] &#x3D; g[i - 1] + (bri[i] ? e[pre[a[i]]].w : 0);&#x2F;&#x2F;bri:a上桥01串 g[i]:S-&gt;i总桥长\n\t\t&#x2F;&#x2F;ds:最小危险程度&#x3D;&#x3D;S-&gt;i uncover的总桥长\n\t\tint k &#x3D; 1;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;\n\t\t\tds[i] &#x3D; min(g[i], ds[i - 1] + g[i] - g[i - 1]);&#x2F;&#x2F;不被k更新的init！\n\t\t\twhile (k + 1 &lt;&#x3D; i &amp;&amp; d[i] - d[k] &gt; Q) k++;&#x2F;&#x2F;&lt;&#x3D;Q的min_k\n\t\t\tds[i] &#x3D; min(ds[i], g[k] - (bri[k] ? Q - (d[i] - d[k]) : 0));\n\t\t&#125;\n\t\t&#x2F;&#x2F;dt\n\t\tds[1] &#x3D; dt[tot] &#x3D; 0, k &#x3D; tot;\n\t\tfor (int i &#x3D; tot - 1; i; i--) &#123;\n\t\t\tdt[i] &#x3D; min(g[tot] - g[i], dt[i + 1] + g[i + 1] - g[i]);&#x2F;&#x2F;\n\t\t\twhile (k - 1 &gt;&#x3D; i &amp;&amp; d[k] - d[i] &gt; Q) k--;\n\t\t\tdt[i] &#x3D; min(dt[i], g[tot] - g[k] - (bri[k + 1] ? Q - (d[k] - d[i]): 0));\n\t\t&#125;\n\t\t&#x2F;&#x2F;更新ans\n\t\tint ans &#x3D; 2e9;\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; tot; i++) ans &#x3D; min(ans, ds[i] + dt[i]);\n\t\t&#x2F;&#x2F;特判\n\t\tk &#x3D; 1;\n\t\tfor (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;\n\t\t\twhile (k + 1 &lt;&#x3D; i &amp;&amp; d[i] - d[k] &gt; 2 * Q) k++;\n\t\t\tans &#x3D; min(ans, g[tot] - g[i] + g[k] - (bri[k] ? 2 * Q - (d[i] - d[k]) : 0));&#x2F;&#x2F;k~(2Q右对齐)~i~tot\n\t\t&#125;\n\t\tprintf(&quot;%d\\n&quot;, ans);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;【2-SAT】\n&#x2F;&#x2F; AcWing 370. 卡图难题\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 1006;\nint n, m, dfn[N], low[N], num, st[N], top, c[N], cnt;\nbool ins[N];\nvector&lt;int&gt; e[N&lt;&lt;1];\n\ninline void add(int x, int y) &#123;\n\te[x].push_back(y);\n&#125;\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tst[++top] &#x3D; x;\n\tins[x] &#x3D; 1;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (!dfn[y]) &#123;\n\t\t\ttarjan(y);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t&#125; else if (ins[y])\n\t\t\tlow[x] &#x3D; min(low[x], dfn[y]);\n\t&#125;\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\t++cnt;\n\t\tint y;\n\t\tdo &#123;\n\t\t\ty &#x3D; st[top--];\n\t\t\tins[y] &#x3D; 0;\n\t\t\tc[y] &#x3D; cnt;\n\t\t&#125; while (x !&#x3D; y);\n\t&#125;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\twhile (m--) &#123;\n\t\tint a, b, c;\n\t\tchar s[6];\n\t\tscanf(&quot;%d %d %d %s&quot;, &amp;a, &amp;b, &amp;c, s);&#x2F;&#x2F;满足Xa op(s) Xb &#x3D; c \n\t\tif (s[0] &#x3D;&#x3D; &#39;A&#39;) &#123;\n\t\t\tif (c) &#123;\n\t\t\t\tadd(a, a + n);\n\t\t\t\tadd(b, b + n);\n\t\t\t&#125; else &#123;\n\t\t\t\tadd(a + n, b);\n\t\t\t\tadd(b + n, a);\n\t\t\t&#125;\n\t\t&#125; else if (s[0] &#x3D;&#x3D; &#39;O&#39;) &#123;\n\t\t\tif (c) &#123;\n\t\t\t\tadd(a, b + n);\n\t\t\t\tadd(b, a + n);\n\t\t\t&#125; else &#123;\n\t\t\t\tadd(a + n, a);\n\t\t\t\tadd(b + n, b);\n\t\t\t&#125;\n\t\t&#125; else &#123;\n\t\t\tif (c) &#123;\n\t\t\t\tadd(a, b + n);\n\t\t\t\tadd(b, a + n);\n\t\t\t\tadd(a + n, b);\n\t\t\t\tadd(b + n, a);\n\t\t\t&#125; else &#123;\n\t\t\t\tadd(a, b);\n\t\t\t\tadd(b, a);\n\t\t\t\tadd(a + n, b + n);\n\t\t\t\tadd(b + n, a + n);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tif (!dfn[i]) tarjan(i);\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tif (c[i] &#x3D;&#x3D; c[i+n]) &#123;\n\t\t\tputs(&quot;NO&quot;);\n\t\t\treturn 0;\n\t\t&#125;\n\tputs(&quot;YES&quot;);\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F; AcWing 371. 牧师约翰最忙碌的一天\n&#x2F;&#x2F; 2-SAT构图并打印方案，解法一，自底向上拓扑排序 (POJ3683)\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int u &#x3D; 2010, w &#x3D; 3000010;\nint ver[w], Next[w], head[u], dfn[u], low[u], c[u], s[u], ins[u];\nint ver2[w], Next2[w], head2[u], val[u], deg[u], opp[u];\nint S[u], T[u], D[u], ex[w], ey[w];\nint n, m, tot, tot2, num, t, p, e;\nqueue&lt;int&gt; q;\n\n&#x2F;&#x2F; 原图加边\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n\tex[++e] &#x3D; x, ey[e] &#x3D; y;\n&#125;\n\n&#x2F;&#x2F; 缩点后的图加边\nvoid add2(int x, int y) &#123;\n\tver2[++tot2] &#x3D; y, Next2[tot2] &#x3D; head2[x], head2[x] &#x3D; tot2;\n&#125;\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\ts[++p] &#x3D; x, ins[x] &#x3D; 1;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i])\n\t\tif (!dfn[ver[i]]) &#123;\n\t\t\ttarjan(ver[i]);\n\t\t\tlow[x] &#x3D; min(low[x], low[ver[i]]);\n\t\t&#125;\n\t\telse if (ins[ver[i]])\n\t\t\tlow[x] &#x3D; min(low[x], dfn[ver[i]]);\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\tt++; int y;\n\t\tdo &#123; y &#x3D; s[p--], ins[y] &#x3D; 0; c[y] &#x3D; t; &#125; while (x !&#x3D; y);\n\t&#125;\n&#125;\n\nvoid topsort() &#123;\n\tmemset(val, -1, sizeof(val));\n\t&#x2F;&#x2F; 缩点，建反图\n\tfor (int i &#x3D; 1; i &lt;&#x3D; e; i++)\n\t\tif (c[ex[i]] !&#x3D; c[ey[i]])\n\t\t\tadd2(c[ey[i]], c[ex[i]]), deg[c[ex[i]]]++;\n\t&#x2F;&#x2F; 零入度点入队\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++)\n\t\tif (!deg[i]) q.push(i);\n\t&#x2F;&#x2F; 拓扑排序\n\twhile (q.size()) &#123;\n\t\tint k &#x3D; q.front(); q.pop();\n\t\t&#x2F;&#x2F; 赋值标记\n\t\tif (val[k] &#x3D;&#x3D; -1) val[k] &#x3D; 0, val[opp[k]] &#x3D; 1;\n\t\tfor (int i &#x3D; head2[k]; i; i &#x3D; Next2[i])\n\t\t\tif (--deg[ver2[i]] &#x3D;&#x3D; 0) q.push(ver2[i]);\n\t&#125;\n\t&#x2F;&#x2F; 输出最终结果 0:S~(S+D) 1:(T-D)~T\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (val[c[i]] &#x3D;&#x3D; 0) printf(&quot;%02d:%02d %02d:%02d\\n&quot;,\n\t\t\tS[i] &#x2F; 60, S[i] % 60,\n\t\t\t(S[i] + D[i]) &#x2F; 60, (S[i] + D[i]) % 60);\n\t\telse printf(&quot;%02d:%02d %02d:%02d\\n&quot;,\n\t\t\t(T[i] - D[i]) &#x2F; 60, (T[i] - D[i]) % 60,\n\t\t\tT[i] &#x2F; 60, T[i] % 60);\n&#125;\n\nbool overlap(int a, int b, int c, int d) &#123;\n\tif (a &gt;&#x3D; c&amp;&amp;a&lt;d || b&gt;c&amp;&amp;b &lt;&#x3D; d || a &lt;&#x3D; c&amp;&amp;b &gt;&#x3D; d) return 1;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint sh, sm, th, tm;\n\t\tscanf(&quot;%d:%d %d:%d %d&quot;, &amp;sh, &amp;sm, &amp;th, &amp;tm, &amp;D[i]);\n\t\tS[i] &#x3D; sh * 60 + sm; T[i] &#x3D; th * 60 + tm;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tfor (int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\tif (overlap(S[i], S[i] + D[i], S[j], S[j] + D[j]))\n\t\t\t\tadd(i, n + j), add(j, n + i);\n\t\t\tif (overlap(S[i], S[i] + D[i], T[j] - D[j], T[j]))\n\t\t\t\tadd(i, j), add(n + j, n + i);\n\t\t\tif (overlap(T[i] - D[i], T[i], S[j], S[j] + D[j]))\n\t\t\t\tadd(n + i, n + j), add(j, i);\n\t\t\tif (overlap(T[i] - D[i], T[i], T[j] - D[j], T[j]))\n\t\t\t\tadd(n + i, j), add(n + j, i);\n\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 2 * n; i++)\n\t\tif (!dfn[i]) tarjan(i);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tif (c[i] &#x3D;&#x3D; c[n + i]) &#123; puts(&quot;NO&quot;); return 0; &#125;\n\t\topp[c[i]] &#x3D; c[n + i], opp[c[n + i]] &#x3D; c[i];\n\t&#125;\n\tputs(&quot;YES&quot;);\n\ttopsort();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; 2-SAT构图并打印方案，解法二 (POJ3683)\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int u &#x3D; 2010, w &#x3D; 3000010;\nint ver[w], Next[w], head[u], dfn[u], low[u], c[u], s[u], ins[u];\nint val[u], deg[u], opp[u], S[u], T[u], D[u];\nint n, m, tot, num, t, p;\n\n&#x2F;&#x2F; 原图加边\nvoid add(int x, int y) &#123;\n\tver[++tot] &#x3D; y, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n&#125;\n\nvoid tarjan(int x) &#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\ts[++p] &#x3D; x, ins[x] &#x3D; 1;\n\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i])\n\t\tif (!dfn[ver[i]]) &#123;\n\t\t\ttarjan(ver[i]);\n\t\t\tlow[x] &#x3D; min(low[x], low[ver[i]]);\n\t\t&#125;\n\t\telse if (ins[ver[i]])\n\t\t\tlow[x] &#x3D; min(low[x], dfn[ver[i]]);\n\tif (dfn[x] &#x3D;&#x3D; low[x]) &#123;\n\t\tt++; int y;\n\t\tdo &#123; y &#x3D; s[p--], ins[y] &#x3D; 0; c[y] &#x3D; t; &#125; while (x !&#x3D; y);\n\t&#125;\n&#125;\n\nbool overlap(int a, int b, int c, int d) &#123;\n\tif (a &gt;&#x3D; c&amp;&amp;a&lt;d || b&gt;c&amp;&amp;b &lt;&#x3D; d || a &lt;&#x3D; c&amp;&amp;b &gt;&#x3D; d) return 1;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tint sh, sm, th, tm;\n\t\tscanf(&quot;%d:%d %d:%d %d&quot;, &amp;sh, &amp;sm, &amp;th, &amp;tm, &amp;D[i]);\n\t\tS[i] &#x3D; sh * 60 + sm; T[i] &#x3D; th * 60 + tm;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\tfor (int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\tif (overlap(S[i], S[i] + D[i], S[j], S[j] + D[j]))\n\t\t\t\tadd(i, n + j), add(j, n + i);\n\t\t\tif (overlap(S[i], S[i] + D[i], T[j] - D[j], T[j]))\n\t\t\t\tadd(i, j), add(n + j, n + i);\n\t\t\tif (overlap(T[i] - D[i], T[i], S[j], S[j] + D[j]))\n\t\t\t\tadd(n + i, n + j), add(j, i);\n\t\t\tif (overlap(T[i] - D[i], T[i], T[j] - D[j], T[j]))\n\t\t\t\tadd(n + i, j), add(n + j, i);\n\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; 2 * n; i++)\n\t\tif (!dfn[i]) tarjan(i);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tif (c[i] &#x3D;&#x3D; c[n + i]) &#123; puts(&quot;NO&quot;); return 0; &#125;\n\t\topp[i] &#x3D; n + i, opp[n + i] &#x3D; i;\n\t&#125;\n\tputs(&quot;YES&quot;);\n\t&#x2F;&#x2F; 构造方案 \n\tfor (int i &#x3D; 1; i &lt;&#x3D; 2 * n; i++)\n\t\tval[i] &#x3D; c[i] &gt; c[opp[i]]; &#x2F;&#x2F; &lt;&#x3D;优先为0, &gt;为1\n\t&#x2F;&#x2F; 输出最终结果\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (val[i] &#x3D;&#x3D; 0) printf(&quot;%02d:%02d %02d:%02d\\n&quot;,\n\t\t\tS[i] &#x2F; 60, S[i] % 60,\n\t\t\t(S[i] + D[i]) &#x2F; 60, (S[i] + D[i]) % 60);\n\t\telse printf(&quot;%02d:%02d %02d:%02d\\n&quot;,\n\t\t\t(T[i] - D[i]) &#x2F; 60, (T[i] - D[i]) % 60,\n\t\t\tT[i] &#x2F; 60, T[i] % 60);\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x68. 二分图的匹配\n&#x2F;&#x2F;关押罪犯 (法2： 二分图judge + 二分)\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 20006, M &#x3D; 200006;\nstruct P &#123;\n\tint x, y, z;\n\tbool operator &lt; (const P w) const &#123;\n\t\treturn z &gt; w.z;\n\t&#125;\n&#125; p[M];\nint n, m, v[N];\nvector&lt;pair&lt;int, int&gt; &gt; e[N];\n\nbool dfs(int x, int color) &#123;\n\tv[x] &#x3D; color;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i].first;\n\t\t&#x2F;&#x2F; if (v[y]) &#123;\n\t\t&#x2F;&#x2F; \tif (v[y] &#x3D;&#x3D; color) return 0;\n\t\t&#x2F;&#x2F; &#125; else &#123;\n\t\t&#x2F;&#x2F; \tif (!dfs(y, 3 - color)) return 0;\n\t\t&#x2F;&#x2F; &#125;\n\t\tif (!v[y] &amp;&amp; !dfs(y, 3 - color)) return 0;\n\t\telse if (v[y] &#x3D;&#x3D; color) return 0;\n\t&#125;\n\treturn 1;\n&#125;\n\ninline bool check(int now) &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) e[i].clear();\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tif (p[i].z &lt;&#x3D; now) break;\n\t\t&#x2F;&#x2F;仇恨度&gt;mid:连边\tp按z降序排列:break&#x3D;&#x3D;continue\n\t\te[p[i].x].push_back(&#123;p[i].y, p[i].z&#125;);\n\t\te[p[i].y].push_back(&#123;p[i].x, p[i].z&#125;);\n\t&#125;\n\tmemset(v, 0, sizeof(v));\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (!v[i] &amp;&amp; !dfs(i, 1)) return 0;\n\treturn 1;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tscanf(&quot;%d %d %d&quot;, &amp;p[i].x, &amp;p[i].y, &amp;p[i].z);\n\tsort(p + 1, p + m + 1);\n\tint l &#x3D; 0, r &#x3D; p[1].z;&#x2F;&#x2F;怨气值域\n\twhile (l &lt; r) &#123;\n\t\tint mid &#x3D; (l + r) &gt;&gt; 1;\n\t\tif (check(mid)) r &#x3D; mid;\n\t\telse l &#x3D; mid + 1;\n\t&#125;\n\tcout &lt;&lt; l &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;【二分图最大匹配:匈牙利 增广路】\n&#x2F;&#x2F; AcWing 372. 棋盘覆盖\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 106;\nconst int dx[4] &#x3D; &#123;0,0,1,-1&#125;;\nconst int dy[4] &#x3D; &#123;1,-1,0,0&#125;;\nint n, m, ans, f[N*N];&#x2F;&#x2F;f&#x3D;&#x3D;match\nbool b[N][N], v[N*N];\nvector&lt;int&gt; e[N*N];\n\nbool dfs(int x) &#123;\n\tfor (unsigned int i &#x3D; 0, y; i &lt; e[x].size(); i++) &#123;\n\t\tif (v[y &#x3D; e[x][i]]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (f[y] &#x3D;&#x3D; -1 || dfs(f[y])) &#123;\n\t\t\tf[y] &#x3D; x;\n\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\twhile (m--) &#123;&#x2F;&#x2F;禁放坐标\n\t\tint x, y;\n\t\tscanf(&quot;%d %d&quot;, &amp;x, &amp;y); \n\t\tb[x-1][y-1] &#x3D; 1;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; n; j++)\n\t\t\tif (!b[i][j])\n\t\t\t\tfor (int k &#x3D; 0; k &lt; 4; k++) &#123;&#x2F;&#x2F;相邻格不同色:连边(可放 界内)\n\t\t\t\t\tint x &#x3D; i + dx[k], y &#x3D; j + dy[k];\n\t\t\t\t\tif (x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; n &amp;&amp; !b[x][y]) &#123;\n\t\t\t\t\t\te[i * n + j].push_back(x * n + y);&#x2F;&#x2F;二维坐标合一维！\n\t\t\t\t\t\te[x * n + y].push_back(i * n + j);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\tmemset(f, -1, sizeof(f));\n\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\tfor (int j &#x3D; 0; j &lt; n; j++) &#123;\n\t\t\tif ((i ^ j) &amp; 1) continue;&#x2F;&#x2F;行+列为偶数:白格\n\t\t\tmemset(v, 0, sizeof(v));\n\t\t\tans +&#x3D; dfs(i * n + j);&#x2F;&#x2F;max_match数(黑白配 +&#x3D;1、0)\n\t\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 373. 車的放置\t\t匈牙利模板题\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint n, m, t, ans, fa[205];&#x2F;&#x2F;fa&#x3D;&#x3D;match\nbool a[205][205], v[205];\n\nbool dfs(int x) &#123;\n\tfor (int y &#x3D; 1; y &lt;&#x3D; m; y++) &#123;&#x2F;&#x2F;列\n\t\tif (v[y] || a[x][y]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (fa[y] &#x3D;&#x3D; 0 || dfs(fa[y])) &#123;\n\t\t\tfa[y] &#x3D; x;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\treturn false;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; t;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tint x, y; cin &gt;&gt; x &gt;&gt; y;\n\t\ta[x][y] &#x3D; 1;&#x2F;&#x2F;禁放\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;&#x2F;&#x2F;行\n\t\tmemset(v, 0, sizeof(v));\n\t\tif (dfs(i)) ans++;\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;HDOJ 1045. Fire Net\n\n\n&#x2F;&#x2F;【多重匹配：拆点法】\n&#x2F;&#x2F; AcWing 374. 导弹防御塔\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#define pii pair&lt;int, int&gt;\n#define x first\n#define y second\nusing namespace std;\nconst int N &#x3D; 56, M &#x3D; 2506;\nconst double eps &#x3D; 1e-8;\nint n, m, t, t2, V, cnt, f[M];\ndouble t1;\nbool v[M];\npii a[N], b[N];\npair&lt;int, double&gt; c[M];\nvector&lt;int&gt; e[N];\n\ninline double S(pii a, pii b) &#123;\n\tint dx &#x3D; a.x - b.x, dy &#x3D; a.y - b.y;\n\treturn sqrt(dx * dx + dy * dy);\n&#125;\n\nbool dfs(int x) &#123;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (v[y]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (!f[y] || dfs(f[y])) &#123;\n\t\t\tf[y] &#x3D; x;\n\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\ninline bool check(double mid) &#123;\n\tmemset(f, 0, sizeof(f));&#x2F;&#x2F;f&#x3D;&#x3D;match\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\te[i].clear();\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; t; j++)&#x2F;&#x2F;max:塔n导弹m-&gt;人m\n\t\t\tif (c[j].y + S(a[i], b[c[j].x]) &#x2F; V &lt;&#x3D; mid)&#x2F;&#x2F;发射+飞行&lt;&#x3D;mid\n\t\t\t\te[i].push_back(j);&#x2F;&#x2F;连边\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tmemset(v, 0, sizeof(v));\n\t\tif (!dfs(i)) return 0;&#x2F;&#x2F;match\n\t&#125;\n\treturn 1;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; V;\n\tt &#x3D; n * m;&#x2F;&#x2F;塔n导弹m\n\tt1 &#x2F;&#x3D; 60;&#x2F;&#x2F;s-&gt;min\n\t&#x2F;&#x2F;人a入侵塔b\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++)\n\t\tscanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tscanf(&quot;%d %d&quot;, &amp;b[i].x, &amp;b[i].y);\n\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#x2F;&#x2F;枚举炮塔 \n\t\tfor(int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t&#x2F;&#x2F;枚举第几个导弹 (最多用一个炮塔发射m颗导弹就够了)\n\t\t&#123;\n\t\t\tc[++cnt].x &#x3D; i;&#x2F;&#x2F;炮塔\n\t\t\tc[cnt].y &#x3D; (j - 1) * (t1 + t2) + t1;&#x2F;&#x2F;发射时间\n\t\t&#125;\n\tdouble l &#x3D; t1, r &#x3D; 100000;\n\twhile (l + eps &lt; r) &#123;\n\t\tdouble mid &#x3D; (l + r) &#x2F; 2;\n\t\tif (check(mid)) r &#x3D; mid;\n\t\telse l &#x3D; mid;\n\t&#125;\n\tprintf(&quot;%.6f\\n&quot;, l);\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;【二分图带权最大(完备)匹配:KM算法(相等子图的完备匹配)】\n&#x2F;&#x2F; AcWing 375. 蚂蚁\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nconst int N &#x3D; 105;\nint a[N], b[N], c[N], d[N];\ndouble w[N][N]; &#x2F;&#x2F; 边权\ndouble la[N], lb[N]; &#x2F;&#x2F; 左、右部点的顶标\nbool va[N], vb[N]; &#x2F;&#x2F; 访问标记：是否在交错树中(属于T)\nint match[N], ans[N]; &#x2F;&#x2F; 右部点匹配了哪一个左部点\nint n;\ndouble upd[N], delta;\n\nbool dfs(int x) &#123;\n\tva[x] &#x3D; 1; &#x2F;&#x2F; 访问标记：x在交错树中\n\tfor (int y &#x3D; 1; y &lt;&#x3D; n; y++)\n\t\tif (!vb[y])&#x2F;&#x2F;y不属于T\n\t\t\tif (fabs(la[x] + lb[y] - w[x][y]) &lt; 1e-8) &#123; &#x2F;&#x2F; 相等子图\n\t\t\t\tvb[y] &#x3D; 1; &#x2F;&#x2F; 访问标记：y在交错树中\n\t\t\t\tif (!match[y] || dfs(match[y])) &#123;\n\t\t\t\t\tmatch[y] &#x3D; x;\n\t\t\t\t\treturn true;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\telse upd[y] &#x3D; min(upd[y], la[x] + lb[y] - w[x][y]);\n\treturn false;\n&#125;\n\nvoid KM() &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tla[i] &#x3D; -1e10; &#x2F;&#x2F; -inf\n\t\tlb[i] &#x3D; 0;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tla[i] &#x3D; max(la[i], w[i][j]);\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\twhile (true) &#123;\n\t\t\tmemset(va, 0, sizeof(va));\n\t\t\tmemset(vb, 0, sizeof(vb));\n\t\t\tdelta &#x3D; 1e10; &#x2F;&#x2F; inf\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) upd[j] &#x3D; 1e10; \n\t\t\tif (dfs(i)) break;&#x2F;&#x2F; 直到左部点找到匹配\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif (!vb[j]) delta &#x3D; min(delta, upd[j]);\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; &#x2F;&#x2F; 修改顶标\n\t\t\t\tif (va[j]) la[j] -&#x3D; delta;\n\t\t\t\tif (vb[j]) lb[j] +&#x3D; delta;\n\t\t\t&#125;\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\tcin &gt;&gt; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d%d&quot;, &amp;c[i], &amp;d[i]);\n\t&#x2F;&#x2F;边权取反：带权min-&gt;带权max\tmin边权和&#x3D;(-边权和)\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\tw[i][j] &#x3D; -sqrt((a[i]-c[j])*(a[i]-c[j])*1.0+(b[i]-d[j])*(b[i]-d[j])*1.0);\n\tKM();\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) ans[match[i]] &#x3D; i;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) printf(&quot;%d\\n&quot;, ans[i]);&#x2F;&#x2F;只匹配\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;0x69. 二分图的覆盖【2要素:2选1】\n&#x2F;&#x2F;(二分图)最小点覆盖数【用最少的点覆盖所有边】&#x3D;&#x3D;最大匹配边数\n&#x2F;&#x2F; AcWing 376. 机器任务\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 106;\nint n, m, k, f[N], ans;\nbool v[N];\nvector&lt;int&gt; e[N];\n\nbool dfs(int x) &#123;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (v[y]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (!f[y] || dfs(f[y])) &#123;\n\t\t\tf[y] &#x3D; x;\n\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\ninline void Machine_Schedule() &#123;\n\tcin &gt;&gt; m &gt;&gt; k;\n\tfor (int i &#x3D; 1; i &lt; n; i++) e[i].clear();\n\tfor (int i &#x3D; 0; i &lt; k; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;i, &amp;x, &amp;y);\n\t\tif (x &amp;&amp; y) e[x].push_back(y);\n\t&#125;\n\tmemset(f, 0, sizeof(f));\n\tans &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tmemset(v, 0, sizeof(v));\n\t\tans +&#x3D; dfs(i);&#x2F;&#x2F;(二分图)最小点覆盖数&#x3D;&#x3D;最大匹配边数\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\t&#x2F;&#x2F; for(int x : f) cout&lt;&lt;x;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &amp;&amp; n) Machine_Schedule();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; AcWing 377. 泥泞的区域\n&#x2F;&#x2F;Author:XuHt\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 56;\nint n, m, tot &#x3D; 1, a[N][N][2], f[N*N], ans;\nchar s[N][N];\nbool v[N*N];\nvector&lt;int&gt; e[N*N];\n\nbool dfs(int x) &#123;\n\tfor (unsigned int i &#x3D; 0; i &lt; e[x].size(); i++) &#123;\n\t\tint y &#x3D; e[x][i];\n\t\tif (v[y]) continue;\n\t\tv[y] &#x3D; 1;\n\t\tif (!f[y] || dfs(f[y])) &#123;\n\t\t\tf[y] &#x3D; x;\n\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%s&quot;, s[i] + 1);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m + 1; j++)&#x2F;&#x2F;m+1:行末++tot\n\t\t\tif (s[i][j] &#x3D;&#x3D; &#39;*&#39;) a[i][j][0] &#x3D; tot;&#x2F;&#x2F;行泥泞块tot\n\t\t\telse ++tot;&#x2F;&#x2F;tot非连续(块号是几不重要 只为区分)\n\tint t &#x3D; tot;&#x2F;&#x2F;最大泥块号：行t 列tot\n\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n + 1; i++)&#x2F;&#x2F;n+1:列末++tot\n\t\t\tif (s[i][j] &#x3D;&#x3D; &#39;*&#39;) a[i][j][1] &#x3D; tot;&#x2F;&#x2F;列泥泞块tot\n\t\t\telse ++tot;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++)\n\t\t\tif (s[i][j] &#x3D;&#x3D; &#39;*&#39;) &#123;&#x2F;&#x2F;泥块所属行、列泥块之间连边\n\t\t\t\te[a[i][j][0]].push_back(a[i][j][1]);\n\t\t\t\te[a[i][j][1]].push_back(a[i][j][0]);\n\t\t\t&#125;\n\tfor (int i &#x3D; 1; i &lt; t; i++) &#123;&#x2F;&#x2F;最后m+1：++tot 行泥块号:1~t-1\n\t\tmemset(v, 0, sizeof(v));\n\t\tans +&#x3D; dfs(i);\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;【二分图最大点独立集(任意两点之间无连边)】\n&#x2F;&#x2F;无向图G的最大团&#x3D;&#x3D;其补图G&#39;的最大独立集\n&#x2F;&#x2F;n点二分图G的最大独立集大小 &#x3D;&#x3D; n-(最大匹配数(最小点覆盖数))\n\n&#x2F;&#x2F; AcWing 378. 骑士放置 【对比Acwing 372.棋盘覆盖(2D坐标-&gt;1D)】\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint n, m, t, ans, fx[105][105], fy[105][105];\nbool a[105][105], v[105][105];\nconst int dx[8] &#x3D; &#123;-2, -2, -1, -1, 1, 1, 2, 2&#125;;\nconst int dy[8] &#x3D; &#123;-1, 1, -2, 2, -2, 2, -1, 1&#125;;\n\nbool dfs(int x, int y) &#123;&#x2F;&#x2F;马走日连边 二维坐标\n\tfor (int i &#x3D; 0; i &lt; 8; i++) &#123;\n\t\tint nx &#x3D; x + dx[i], ny &#x3D; y + dy[i];\n\t\tif (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; m || a[nx][ny]) continue;&#x2F;&#x2F;\n\t\tif (v[nx][ny]) continue;\n\t\tv[nx][ny] &#x3D; 1;\n\t\tif (fx[nx][ny] &#x3D;&#x3D; 0 || dfs(fx[nx][ny], fy[nx][ny])) &#123;\n\t\t\tfx[nx][ny] &#x3D; x, fy[nx][ny] &#x3D; y;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\treturn false;\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; t;&#x2F;&#x2F;t个禁放\n\tfor (int i &#x3D; 1; i &lt;&#x3D; t; i++) &#123;\n\t\tint x, y; cin &gt;&gt; x &gt;&gt; y;\n\t\ta[x][y] &#x3D; 1;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123;\n\t\t\tif (i + j &amp; 1) continue;&#x2F;&#x2F;行+列为偶数:白格\n\t\t\tif (a[i][j]) continue;&#x2F;&#x2F;\n\t\t\tmemset(v, 0, sizeof(v));\n\t\t\tif (dfs(i, j)) ans++;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; n * m - t - ans &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;【DAG的最小路径点覆盖的路径数 &#x3D;&#x3D; n-拆点二分图(左n右n)的max_match数】\n&#x2F;&#x2F;  路径终点&#x3D;&#x3D;左部非匹点\t路径可相交&#x3D;可重复点:先Floyd 传递闭包,去自环\n&#x2F;&#x2F; AcWing 379. 捉迷藏\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 220;\nbool cl[N][N]; &#x2F;&#x2F; 邻接矩阵\nint match[N], n, m;\nbool vis[N], succ[N];\nint hide[N]; &#x2F;&#x2F; 藏身点集合\n\nbool dfs(int x) &#123;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tif (cl[x][i] &amp;&amp; !vis[i]) &#123;\n\t\t\tvis[i] &#x3D; true;\n\t\t\tif (!match[i] || dfs(match[i])) &#123;\n\t\t\t\tmatch[i] &#x3D; x;\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t&#125;\n\treturn false;\n&#125;\n\nint main() &#123;\n\t&#x2F;&#x2F; 读入\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n\t\tint x, y;\n\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\tcl[x][y] &#x3D; 1;\n\t&#125;\n\t&#x2F;&#x2F; Floyd 传递闭包\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cl[i][i] &#x3D; 1;\n\tfor (int k &#x3D; 1; k &lt;&#x3D; n; k++) \n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) \n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) \n\t\t\t\tcl[i][j] |&#x3D; cl[i][k] &amp;&amp; cl[k][j];&#x2F;&#x2F;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) cl[i][i] &#x3D; 0;&#x2F;&#x2F;无自环 DAG\n\t&#x2F;&#x2F; 在拆点二分图(左n右n)上求最大匹配\n\tint ans &#x3D; n;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tans -&#x3D; dfs(i);\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt;endl;&#x2F;&#x2F;路径条数\n\t&#x2F;&#x2F; 构造方案，先把所有路径终点（左部非匹配点）作为藏身点\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) succ[match[i]] &#x3D; true;\n\tfor (int i &#x3D; 1, k &#x3D; 0; i &lt;&#x3D; n; i++)\n\t\tif (!succ[i]) hide[++k] &#x3D; i;\n\tmemset(vis, 0, sizeof(vis));\n\tbool modify &#x3D; true;\n\twhile (modify) &#123;&#x2F;&#x2F;只要更新了hide，就要重新check\n\t\tmodify &#x3D; false;\n\t\t&#x2F;&#x2F; 求出 next(hide)\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; ans; i++) \n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++)\n\t\t\t\tif (cl[hide[i]][j]) vis[j] &#x3D; true;&#x2F;&#x2F;cl:后继 vis:next(E)\n\t\tfor (int i &#x3D; 1; i &lt;&#x3D; ans; i++)\n\t\t\tif (vis[hide[i]]) &#123;&#x2F;&#x2F;next(E)与E有交集\n\t\t\t\tmodify &#x3D; true;\n\t\t\t\t&#x2F;&#x2F; 不断向上移动\n\t\t\t\twhile (vis[hide[i]]) hide[i] &#x3D; match[hide[i]];&#x2F;&#x2F;match:前驱\n\t\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; ans; i++) printf(&quot;%d &quot;, hide[i]);\n\tcout &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;0x6A. 网络流初步\n&#x2F;&#x2F;【最大流】\n&#x2F;&#x2F; AcWing 380. 舞动的夜晚\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int inf &#x3D; 0x3fffffff, u &#x3D; 40010, w &#x3D; 300010;\nint head[u], ver[w], edge[w], Next[w], d[u], e[w], c[u], stk[u], ins[u], dfn[u], low[u];\nint n, m, p, s, t, i, j, tot, maxflow, ans, x, y, scc, top, num;\nchar str[10];\nvector&lt;int&gt; a[u];\nqueue&lt;int&gt; q;\n\nvoid add(int x, int y, int z) &#123;\n\tver[++tot] &#x3D; y, edge[tot] &#x3D; z, Next[tot] &#x3D; head[x], head[x] &#x3D; tot;\n\tver[++tot] &#x3D; x, edge[tot] &#x3D; 0, Next[tot] &#x3D; head[y], head[y] &#x3D; tot;\n&#125;\n\nbool bfs() &#123;&#x2F;&#x2F;残量网络上构造分层图\n\tmemset(d, 0, sizeof(d));\n\twhile (q.size()) q.pop();\n\tq.push(s); d[s] &#x3D; 1;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front(); q.pop();\n\t\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i])\n\t\t\tif (edge[i] &amp;&amp; !d[ver[i]]) &#123;&#x2F;&#x2F;剩余容量&gt;0的边\n\t\t\t\tq.push(ver[i]);\n\t\t\t\td[ver[i]] &#x3D; d[x] + 1;&#x2F;&#x2F;\n\t\t\t\tif (ver[i] &#x3D;&#x3D; t) return 1;\n\t\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nint dinic(int x, int flow) &#123;&#x2F;&#x2F;在当前分层图上增广\n\tif (x &#x3D;&#x3D; t) return flow;\n\tint rest &#x3D; flow, k;&#x2F;&#x2F;\n\tfor (int i &#x3D; head[x]; i &amp;&amp; rest; i &#x3D; Next[i])\n\t\tif (edge[i] &amp;&amp; d[ver[i]] &#x3D;&#x3D; d[x] + 1) &#123;\n\t\t\tk &#x3D; dinic(ver[i], min(rest, edge[i]));&#x2F;&#x2F;更新剩余容量\n\t\t\tif (!k) d[ver[i]] &#x3D; 0;&#x2F;&#x2F;剪枝,去掉增广完毕的点\n\t\t\tedge[i] -&#x3D; k;\n\t\t\tedge[i ^ 1] +&#x3D; k;\n\t\t\trest -&#x3D; k;&#x2F;&#x2F;\n\t\t&#125;\n\t&#x2F;&#x2F;head[x] &#x3D; i;&#x2F;&#x2F;当前弧优化（避免重复遍历从x出发不可扩展的边）改了残量网络!\n\treturn flow - rest;&#x2F;&#x2F;sum(k):最大可增广流量\n&#125;\n\nvoid add2(int x, int y)\n&#123;\n\ta[x].push_back(y);\n&#125;\n\nvoid tarjan(int x)\n&#123;\n\tdfn[x] &#x3D; low[x] &#x3D; ++num;\n\tstk[++top] &#x3D; x; ins[x] &#x3D; 1;\n\tint y;\n\tfor (int i &#x3D; 0; i &lt; a[x].size(); i++)\n\t\tif (!dfn[y &#x3D; a[x][i]])\n\t\t&#123;\n\t\t\ttarjan(y);\n\t\t\tlow[x] &#x3D; min(low[x], low[y]);\n\t\t&#125;\n\t\telse if (ins[y]) low[x] &#x3D; min(low[x], dfn[y]);\n\t\tif (dfn[x] &#x3D;&#x3D; low[x])\n\t\t&#123;\n\t\t\tscc++;\n\t\t\tdo &#123;y &#x3D; stk[top--]; ins[y] &#x3D; 0; c[y] &#x3D; scc;&#125; while (x !&#x3D; y);\n\t\t&#125;\n&#125;\n\nint main()\n&#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m &gt;&gt; p)\n\t&#123;\n\t\tmemset(head, 0, sizeof(head));\n\t\ts &#x3D; 0, t &#x3D; n + m + 1; tot &#x3D; 1; maxflow &#x3D; 0;\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++) add(s, i, 1);&#x2F;&#x2F;源点连边\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; m; i++) add(i + n, t, 1);&#x2F;&#x2F;汇点连边\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; p; i++)\n\t\t&#123;\n\t\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\t\t\tadd(x, n + y, 1), e[i] &#x3D; tot;&#x2F;&#x2F;&lt;-tot-\n\t\t&#125;\n\t\twhile (bfs())&#x2F;&#x2F;一直尝试增广，直到残量网络中S不可达T\n\t\t\twhile (i &#x3D; dinic(s, inf)) maxflow +&#x3D; i;\n\t\t&#x2F;&#x2F;将残量网络中[S,T除外 相反]的匹配边(&lt;-)连边，非匹配边(-&gt;)连边建新图\n\t\tfor (i &#x3D; s; i &lt;&#x3D; t; i++) a[i].clear();\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; p; i++)&#x2F;&#x2F;edge[e[i]]:反向边的剩余容量\n\t\t\t&#x2F;&#x2F;非匹&lt;-0-(-1-&gt;没flow流过) x-&gt;y\n\t\t\tif (!edge[e[i]]) add2(ver[e[i]], ver[e[i] ^ 1]);\n\t\t\t&#x2F;&#x2F;匹&lt;-1-(-0-&gt;流过) x&lt;-y\n\t\t\telse add2(ver[e[i] ^ 1], ver[e[i]]);\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; n; i++)&#x2F;&#x2F;非匹&lt;-0-(-1-&gt;):s&lt;-i 否则 匹&lt;-1-:s-&gt;i\n\t\t\tif (!edge[2 * i]) add2(i, s); else add2(s, i);\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; m; i++)&#x2F;&#x2F;非匹&lt;-0-(-1-&gt;):n+i&lt;-t 否则 匹&lt;-1-:n+i-&gt;t\n\t\t\tif (!edge[2 * (n + i)]) add2(t, n + i); else add2(n + i, t);\n\t\tmemset(dfn, 0, sizeof(dfn));\n\t\tmemset(ins, 0, sizeof(ins));\n\t\tmemset(c, 0, sizeof(c));\n\t\ttop &#x3D; num &#x3D; scc &#x3D; ans &#x3D; 0;\n\t\tfor (i &#x3D; s; i &lt;&#x3D; t; i++)\n\t\t\tif (!dfn[i]) tarjan(i);&#x2F;&#x2F;求scc\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; p; i++)\n\t\t\tif (edge[e[i]] || c[ver[e[i]]] &#x3D;&#x3D; c[ver[e[i] ^ 1]]) ans++;&#x2F;&#x2F;可行边\n\t\tcout &lt;&lt; (ans &#x3D; p - ans) &lt;&lt; endl;&#x2F;&#x2F;不可行边数\n\t\tif (!ans) cout &lt;&lt; endl;\n\t\tfor (i &#x3D; 1; i &lt;&#x3D; p; i++)\n\t\t\tif (!edge[e[i]] &amp;&amp; c[ver[e[i]]] !&#x3D; c[ver[e[i] ^ 1]])&#x2F;&#x2F;不可行边\n\t\t\t\tif (--ans) printf(&quot;%d &quot;, i); else printf(&quot;%d\\n&quot;, i);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;【最小割(边容量之和最小的割边集)&#x3D;&#x3D;最大流】\n&#x2F;&#x2F; AcWing 381. 有线电视网络\t\t点边转化; +INF:防止割断\n&#x2F;&#x2F;Author:xht37\n#include &lt;queue&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N &#x3D; 56, M &#x3D; 20006, INF &#x3D; 0x3f3f3f3f;\nint n, m, s, t;\nint a[N*N], b[N*N], d[N&lt;&lt;1];\nint Head[N&lt;&lt;1], Edge[M], Leng[M], Next[M], tot;\n\ninline void add(int x, int y, int z) &#123;\n\tEdge[++tot] &#x3D; y, Leng[tot] &#x3D; z, Next[tot] &#x3D; Head[x], Head[x] &#x3D; tot;\n\tEdge[++tot] &#x3D; x, Leng[tot] &#x3D; 0, Next[tot] &#x3D; Head[y], Head[y] &#x3D; tot;\n&#125;\n\ninline bool bfs() &#123;\n\tmemset(d, 0, sizeof(d));\n\tqueue&lt;int&gt; q;\n\tq.push(s);\n\td[s] &#x3D; 1;\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front();\n\t\tq.pop();\n\t\tfor (int i &#x3D; Head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\t\tif (z &amp;&amp; !d[y]) &#123;\n\t\t\t\tq.push(y);\n\t\t\t\td[y] &#x3D; d[x] + 1;\n\t\t\t\tif (y &#x3D;&#x3D; t) return 1;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\ninline int dinic(int x, int f) &#123;\n\tif (x &#x3D;&#x3D; t) return f;\n\tint rest &#x3D; f;\n\tfor (int i &#x3D; Head[x]; i &amp;&amp; rest; i &#x3D; Next[i]) &#123;\n\t\tint y &#x3D; Edge[i], z &#x3D; Leng[i];\n\t\tif (z &amp;&amp; d[y] &#x3D;&#x3D; d[x] + 1) &#123;\n\t\t\tint k &#x3D; dinic(y, min(rest, z));\n\t\t\tif (!k) d[y] &#x3D; 0;\n\t\t\tLeng[i] -&#x3D; k;\n\t\t\tLeng[i^1] +&#x3D; k;\n\t\t\trest -&#x3D; k;\n\t\t&#125;\n\t&#125;\n\treturn f - rest;\n&#125;\n\ninline void Cable_TV_Network() &#123;\n\tfor (int i &#x3D; 0; i &lt; m; i++) &#123;\n\t\tchar str[20];\n\t\tscanf(&quot;%s&quot;, str);\n\t\ta[i] &#x3D; b[i] &#x3D; 0;\n\t\tint j;\n\t\tfor (j &#x3D; 1; str[j] !&#x3D; &#39;,&#39;; j++) a[i] &#x3D; a[i] * 10 + str[j] - &#39;0&#39;;\n\t\tfor (j++; str[j] !&#x3D; &#39;)&#39;; j++) b[i] &#x3D; b[i] * 10 + str[j] - &#39;0&#39;;\n\t&#125;\n\tint ans &#x3D; INF;\n\tfor (s &#x3D; 0; s &lt; n; s++)&#x2F;&#x2F;枚举s t\n\t\tfor (t &#x3D; 0; t &lt; n; t++)\n\t\t\tif (s !&#x3D; t) &#123;\n\t\t\t\tmemset(Head, 0, sizeof(Head));\n\t\t\t\ttot &#x3D; 1;\n\t\t\t\tint maxf &#x3D; 0;\n\t\t\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\t\t\tif (i &#x3D;&#x3D; s || i &#x3D;&#x3D; t) add(i, i + n, INF);&#x2F;&#x2F;st:s-INF-&gt;s&#39;\n\t\t\t\t\telse add(i, i + n, 1);\n\t\t\t\tfor (int i &#x3D; 0; i &lt; m; i++) &#123;\n\t\t\t\t\tadd(a[i] + n, b[i], INF);\n\t\t\t\t\tadd(b[i] + n, a[i], INF);\n\t\t\t\t&#125;\n\t\t\t\twhile (bfs()) &#123;\n\t\t\t\t\tint num;\n\t\t\t\t\twhile ((num &#x3D; dinic(s, INF))) maxf +&#x3D; num;\n\t\t\t\t&#125;\n\t\t\t\tans &#x3D; min(ans, maxf);&#x2F;&#x2F;\n\t\t\t&#125;\n\tif (n &lt;&#x3D; 1 || ans &#x3D;&#x3D; INF) ans &#x3D; n;&#x2F;&#x2F;n&#x3D;0 1\n\tcout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\twhile (cin &gt;&gt; n &gt;&gt; m) Cable_TV_Network();\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;【费用流】EK最大流+残量网络上SPFA求最长&#x2F;短路 容量z 0,单位费用c -c\n&#x2F;&#x2F; AcWing 382. K取方格数\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int N &#x3D; 5010, M &#x3D; 200010;\nint ver[M], edge[M], cost[M], Next[M], head[N];\nint d[N], incf[N], pre[N], v[N];\nint n, k, tot, s, t, maxflow, ans;\n\nvoid add(int x, int y, int z, int c) &#123;\n\t&#x2F;&#x2F; 正向边，初始容量z，单位费用c\n\tver[++tot] &#x3D; y, edge[tot] &#x3D; z, cost[tot] &#x3D; c;\n\tNext[tot] &#x3D; head[x], head[x] &#x3D; tot;\n\t&#x2F;&#x2F; 反向边，初始容量0，单位费用-c，与正向边“成对存储”\n\tver[++tot] &#x3D; x, edge[tot] &#x3D; 0, cost[tot] &#x3D; -c;\n\tNext[tot] &#x3D; head[y], head[y] &#x3D; tot;\n&#125;\n\nint num(int i, int j, int k) &#123;&#x2F;&#x2F;k:0 1\n\treturn (i - 1)*n + j + k*n*n;\n&#125;\n\nbool spfa() &#123;\n\tqueue&lt;int&gt; q;\n\tmemset(d, 0xcf, sizeof(d)); &#x2F;&#x2F; -INF\n\tmemset(v, 0, sizeof(v));\n\tq.push(s); d[s] &#x3D; 0; v[s] &#x3D; 1; &#x2F;&#x2F; SPFA 求最长路\n\tincf[s] &#x3D; 1 &lt;&lt; 30; &#x2F;&#x2F; 增广路上各边的最小剩余容量\n\twhile (q.size()) &#123;\n\t\tint x &#x3D; q.front(); v[x] &#x3D; 0; q.pop();\n\t\tfor (int i &#x3D; head[x]; i; i &#x3D; Next[i]) &#123;\n\t\t\tif (!edge[i]) continue; &#x2F;&#x2F; 剩余容量为0，不在残量网络中，不遍历\n\t\t\tint y &#x3D; ver[i];\n\t\t\tif (d[y]&lt;d[x] + cost[i]) &#123;\n\t\t\t\td[y] &#x3D; d[x] + cost[i];\n\t\t\t\tincf[y] &#x3D; min(incf[x], edge[i]);\n\t\t\t\tpre[y] &#x3D; i; &#x2F;&#x2F; 记录前驱，便于找到最长路的实际方案\n\t\t\t\tif (!v[y]) v[y] &#x3D; 1, q.push(y);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif (d[t] &#x3D;&#x3D; 0xcfcfcfcf) return false; &#x2F;&#x2F; 汇点不可达，已求出最大流\n\treturn true;&#x2F;&#x2F;残量网络有增广路\n&#125;\n\n&#x2F;&#x2F; 更新最长增广路及其反向边的剩余容量\nvoid update() &#123;\n\tint x &#x3D; t;&#x2F;&#x2F;(n,n)出点t&#x3D;2*n*n\n\twhile (x !&#x3D; s) &#123;\n\t\tint i &#x3D; pre[x];\n\t\tedge[i] -&#x3D; incf[t];&#x2F;&#x2F;剩余容量\n\t\tedge[i ^ 1] +&#x3D; incf[t]; &#x2F;&#x2F; 利用“成对存储”的xor 1技巧\n\t\tx &#x3D; ver[i ^ 1];\n\t&#125;\n\tmaxflow +&#x3D; incf[t];\n\tans +&#x3D; d[t] * incf[t];&#x2F;&#x2F;sum(max_cost)*max_flow\n&#125;\n\nint main() &#123;\n\tcin &gt;&gt; n &gt;&gt; k;\n\ts &#x3D; 1, t &#x3D; 2 * n * n;\n\ttot &#x3D; 1; &#x2F;&#x2F; 一会儿要从2开始“成对存储”，2和3是一对，4和5是一对\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\tint c; scanf(&quot;%d&quot;, &amp;c);\n\t\t\tadd(num(i, j, 0), num(i, j, 1), 1, c);\n\t\t\tadd(num(i, j, 0), num(i, j, 1), k - 1, 0);\n\t\t\tif (j&lt;n) add(num(i, j, 1), num(i, j + 1, 0), k, 0);\n\t\t\tif (i&lt;n) add(num(i, j, 1), num(i + 1, j, 0), k, 0);\n\t\t&#125;\n\twhile (spfa()) update(); &#x2F;&#x2F; 计算最大费用最大流\n\tcout &lt;&lt; ans &lt;&lt; endl;\n&#125;\n\n\n------------------------------------------------------------------------------\n&#x2F;&#x2F;0x6B. 总结与练习\n&#x2F;&#x2F; AcWing 383. 观光\n\n&#x2F;&#x2F; AcWing 384. 升降梯上\n\n&#x2F;&#x2F; AcWing 385. GF和猫咪的玩具\n\n&#x2F;&#x2F; AcWing 386. 社交网络\n\n&#x2F;&#x2F; AcWing 387. 北极网络\n\n&#x2F;&#x2F; AcWing 388. 四叶草魔杖\n\n&#x2F;&#x2F; AcWing 389. 直径\n\n&#x2F;&#x2F; AcWing 390. 逃学的小孩\n\n&#x2F;&#x2F; AcWing 391. 聚会\n\n&#x2F;&#x2F; AcWing 392. 会合\n\n&#x2F;&#x2F; AcWing 393. 雇佣收银员\n\n&#x2F;&#x2F; AcWing 394. 最优高铁环\n\n&#x2F;&#x2F; AcWing 395. 冗余路径\n\n&#x2F;&#x2F; AcWing 396. 矿场搭建\n\n&#x2F;&#x2F; AcWing 397. 逃不掉的路\n\n&#x2F;&#x2F; AcWing 398. 交通实时查询系统\n\n&#x2F;&#x2F; AcWing 399. 约翰的旅行\n\n&#x2F;&#x2F; AcWing 400. 太鼓达人\n\n&#x2F;&#x2F; AcWing 401. 从u到v还是从v到u？\n\n&#x2F;&#x2F; AcWing 402. 杀人游戏\n\n&#x2F;&#x2F; AcWing 403. 平面\n\n&#x2F;&#x2F; AcWing 404. 婚礼\n\n&#x2F;&#x2F; AcWing 405. 将他们分好队\n\n&#x2F;&#x2F; AcWing 406. 放置机器人\n\n&#x2F;&#x2F; AcWing 407. 稳定的牛分配\n\n&#x2F;&#x2F; AcWing 408. 回家\n\n&#x2F;&#x2F; AcWing 409. 空袭\n\n&#x2F;&#x2F; AcWing 410. 排版幻灯片\n\n&#x2F;&#x2F; AcWing 411. 国王的任务\n\n&#x2F;&#x2F; AcWing 412. 排水沟\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"算法竞赛进阶指南yyds","date":"2020-06-08T14:31:57.000Z","categories_index":"算法","tags_index":"算法","author_index":"CodingSeed"},{"id":"e742771fc0750ee9de279875153316db","title":"Hadoop组件基础","content":"Vi命令{width&#x3D;”6.809942038495188in”height&#x3D;”4.260115923009624in”}\nHDFS{width&#x3D;”5.768055555555556in”height&#x3D;”2.9347222222222222in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.886419510061242in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.8211089238845144in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.7393919510061244in”}\nHadoop{width&#x3D;”5.768055555555556in”height&#x3D;”2.9402777777777778in”}\n图中涉及的技术名词解释如下：\n\nSqoop：\n\n\n\n\n\n\n\n\n\n\nsqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql)间进行数据的传递，可以将一个关系型数据库（例如：MySQL,Oracle等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。\n2）Flume：\nFlume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。\n3）Kafka：\nKafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：\n（1）通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。\n（2）高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息\n（3）支持通过Kafka服务器和消费机集群来分区消息。\n（4）支持Hadoop并行数据加载。\n4）Storm：\nStorm为分布式实时计算提供了一组通用原语，可被用于”流处理”之中，实时处理消息并更新数据库。这是管理队列及工作者集群的另一种方式。Storm也可被用于”连续计算”（continuouscomputation），对数据流做连续查询，在计算时就将结果以流的形式输出给用户。\n5）Spark：\nSpark是当前最流行的开源大数据内存计算框架。可以基于Hadoop上存储的大\n数据进行计算。\n6）Oozie：\nOozie是一个管理Hdoop作业（job）的工作流程调度管理系统。Oozie协调作业就是通过时间（频率）和有效数据触发当前的Oozie工作流程。\n7）Hbase：\nHBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。\n8）Hive：\nhive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。\n10）R语言：\nR是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。\n11）Mahout:\nApacheMahout是个可扩展的机器学习和数据挖掘库，当前Mahout支持主要的4个用例：\n推荐挖掘：搜集用户动作并以此给用户推荐可能喜欢的事物。\n聚集：收集文件并进行相关文件分组。\n分类：从现有的分类文档中学习，寻找文档中的相似特征，并为无标签的文档进行正确的归类。\n频繁项集挖掘：将一组项分组，并识别哪些个别项会经常一起出现。\n12）ZooKeeper：\nZookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。\nMapReduce优缺点1.2.1 优点\n1）MapReduce易于编程。它简单的实现一些接口，就可以完成一个分布式程序，这个分布式程序可以分布到大量廉价的PC机器上运行。也就是说你写一个分布式程序，跟写一个简单的串行程序是一模一样的。就是因为这个特点使得MapReduce编程变得非常流行。\n2）良好的扩展性。当你的计算资源不能得到满足的时候，你可以通过简单的增加机器来扩展它的计算能力。\n3）高容错性。MapReduce设计的初衷就是使程序能够部署在廉价的PC机器上，这就要求它具有很高的容错性。比如其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行，不至于这个任务运行失败，而且这个过程不需要人工参与，而完全是由Hadoop内部完成的。\n4）适合PB级以上海量数据的离线处理。这里加红字体离线处理，说明它适合离线处理而不适合在线处理。比如像毫秒级别的返回一个结果，MapReduce很难做到。\n1.2.2 缺点\nMapReduce不擅长做实时计算、流式计算、DAG（有向图）计算。\n1）实时计算。MapReduce无法像Mysql一样，在毫秒或者秒级内返回结果。\n2）流式计算。流式计算的输入数据是动态的，而MapReduce的输入数据集是静态的，不能动态变化。这是因为MapReduce自身的设计特点决定了数据源必须是静态的。\n3）DAG（有向图）计算。多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情况下，MapReduce并不是不能做，而是使用后，每个MapReduce作业的输出结果都会写入到磁盘，会造成大量的磁盘IO，导致性能非常的低下。\n{width&#x3D;”5.756944444444445in”height&#x3D;”2.8784722222222223in”}\nMapReduce开发总结在编写mapreduce程序时，需要考虑的几个方面：\n1）输入数据接口：InputFormat\n默认使用的实现类是：TextInputFormat\nTextInputFormat的功能逻辑是：一次读一行文本，然后将该行的起始偏移量作为key，行内容作为value返回。\nKeyValueTextInputFormat每一行均为一条记录，被分隔符分割为key，value。默认分隔符是tab（\\t）。\nNlineInputFormat按照指定的行数N来划分切片。\nCombineTextInputFormat可以把多个小文件合并成一个切片处理，提高处理效率。\n用户还可以自定义InputFormat。\n2）逻辑处理接口：Mapper\n用户根据业务需求实现其中三个方法：map() setup() cleanup()\n3）Partitioner分区\n有默认实现HashPartitioner，逻辑是根据key的哈希值和numReduces来返回一个分区号；key.hashCode()&amp;Integer.MAXVALUE% numReduces\n如果业务上有特别的需求，可以自定义分区。\n4）Comparable排序\n当我们用自定义的对象作为key来输出时，就必须要实现WritableComparable接口，重写其中的compareTo()方法。\n部分排序：对最终输出的每一个文件进行内部排序。\n全排序：对所有数据进行排序，通常只有一个Reduce。\n二次排序：排序的条件有两个。\n5）Combiner合并\nCombiner合并可以提高程序执行效率，减少io传输。但是使用时必须不能影响原有的业务处理结果。\n6）reduce端分组：Groupingcomparator\nreduceTask拿到输入数据（一个partition的所有数据）后，首先需要对数据进行分组，其分组的默认原则是key相同，然后对每一组kv数据调用一次reduce()方法，并且将这一组kv中的第一个kv的key作为参数传给reduce的key，将这一组数据的value的迭代器传给reduce()的values参数。\n利用上述这个机制，我们可以实现一个高效的分组取最大值的逻辑。\n自定义一个bean对象用来封装我们的数据，然后改写其compareTo方法产生倒序排序的效果。然后自定义一个Groupingcomparator，将bean对象的分组逻辑改成按照我们的业务分组id来分组（比如订单号）。这样，我们要取的最大值就是reduce()方法中传进来key。\n7）逻辑处理接口：Reducer\n用户根据业务需求实现其中三个方法：reduce() setup() cleanup()\n8）输出数据接口：OutputFormat\n默认实现类是TextOutputFormat，功能逻辑是：将每一个KV对向目标文本文件中输出为一行。\nSequenceFileOutputFormat将它的输出写为一个顺序文件。如果输出需要作为后续MapReduce任务的输入，这便是一种好的输出格式，因为它的格式紧凑，很容易被压缩。\n用户还可以自定义OutputFormat。\nHadoop数据压缩压缩Mapreduce的一种优化策略：通过压缩编码对Mapper或者Reducer的输出进行压缩，以减少磁盘IO，提高MR程序运行速度（但相应增加了cpu运算负担）。\n注意：压缩特性运用得当能提高性能，但运用不当也可能降低性能。\n基本原则：\n（1）运算密集型的job，少用压缩\n（2）IO密集型的job，多用压缩\nYarn{width&#x3D;”6.264702537182852in”height&#x3D;”2.9716983814523186in”}\n{width&#x3D;”6.298482064741907in”height&#x3D;”3.122700131233596in”}\n{width&#x3D;”6.071529965004374in”height&#x3D;”3.061349518810149in”}\n{width&#x3D;”5.988567366579177in”height&#x3D;”3.0490791776027995in”}\nScheduler{width&#x3D;”5.7545067804024495in”height&#x3D;”2.6687160979877516in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.845833333333333in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.8555555555555556in”}\n任务的推测执行1）作业完成时间取决于最慢的任务完成时间\n一个作业由若干个Map任务和Reduce任务构成。因硬件老化、软件Bug等，某些任务可能运行非常慢。\n典型案例：系统中有99%的Map任务都完成了，只有少数几个Map老是进度很慢，完不成，怎么办？\n2）推测执行机制：\n发现拖后腿的任务，比如某个任务运行速度远慢于任务平均速度。为拖后腿任务启动一个备份任务，同时运行。谁先运行完，则采用谁的结果。\n3）执行推测任务的前提条件\n（1）每个task只能有一个备份任务；\n（2）当前job已完成的task必须不小于0.05（5%）\n（3）开启推测执行参数设置。Hadoop2.7.2mapred-site.xml文件中默认是打开的。\n&lt;name&gt;mapreduce.map.speculative&lt;&#x2F;name&gt;\n&lt;value&gt;true&lt;&#x2F;value&gt;\n&lt;name&gt;mapreduce.reduce.speculative&lt;&#x2F;name&gt;\n&lt;value&gt;true&lt;&#x2F;value&gt;\n4）不能启用推测执行机制情况\n（1）任务间存在严重的负载倾斜；need调整MR！！！\n（2）特殊任务，比如任务向数据库中写数据。\n5）算法原理：\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.8in”}\nHadoop 企业优化 6.1 MapReduce 跑的慢的原因Mapreduce 程序效率的瓶颈在于两点：\n1）计算机性能\nCPU、内存、磁盘健康、网络\n2）I&#x2F;O 操作优化\n（1）数据倾斜\n（2）map和reduce数设置不合理 (切片，diskIO速度256M&#x2F;s256M&#x2F;块；测试)\n（3）map运行时间太长，导致reduce等待过久（run完的map可先进入reduce，慎用！）\n（4）小文件过多（IO慢）\n（5）大量的不可分块的超大文件（&gt;buffer80%，需要不断溢写）\n（6）spill次数过多\n（7）merge次数过多等。\n6.2 MapReduce优化方法MapReduce优化方法主要从六个方面考虑：数据输入、Map阶段、Reduce阶段、IO传输、数据倾斜问题和常用的调优参数。\n6.2.1 数据输入（1）合并小文件：在执行mr任务前将小文件进行合并，大量的小文件会产生大量的map任务，增大map任务装载次数+耗尽namenode内存，而任务的装载比较耗时，从而导致mr运行较慢。\n（2）采用CombineTextInputFormat切片优化来作为输入，解决输入端大量小文件场景。\n6.2.2 Map阶段1）减少溢写（spill）次数：通过调整io.sort.mb及sort.spill.percent参数值，增大触发spill的内存上限，减少spill次数，从而减少磁盘IO。\n2）减少合并（merge）次数：通过调整io.sort.factor参数，增大merge的文件数目，减少merge的次数，从而缩短mr处理时间。\n3）在map之后，不影响业务逻辑前提下，先进行combine处理，减少I&#x2F;O。\n6.2.3 Reduce阶段1）合理设置map和reduce数：两个都不能设置太少，也不能设置太多。太少，会导致task等待，延长处理时间；太多，会导致map、reduce任务间竞争资源，造成处理超时等错误。\n2）设置map、reduce共存：调整slowstart.completedmaps参数，使map运行到一定程度后，reduce也开始运行，减少reduce的等待时间。\n3）规避使用reduce：因为reduce在用于连接数据集的时候将会产生大量的网络消耗。\n4）合理设置reduce端的buffer：默认情况下，数据达到一个阈值的时候，buffer中的数据就会写入磁盘，然后reduce会从磁盘中获得所有的数据。也就是说，buffer和reduce是没有直接关联的，中间多个一个写磁盘-&gt;读磁盘的过程，既然有这个弊端，那么就可以通过参数来配置，使得buffer中的一部分数据可以直接输送到reduce，从而减少IO开销：mapred.job.reduce.input.buffer.percent，默认为0.0。当值大于0的时候，会保留指定比例的内存读buffer中的数据直接拿给reduce使用（减少溢写）。这样一来，设置buffer需要内存，读取数据需要内存，reduce计算也要内存，所以要根据作业的运行情况进行调整。\n6.2.4 IO传输1）采用数据压缩的方式，减少网络IO的的时间。安装Snappy和LZO(index,格式splitable)压缩编码器。\n2）使用SequenceFile二进制文件。(字节紧密，省校验)\n6.2.5 数据倾斜问题1）数据倾斜现象\n数据频率倾斜——某一个区域的数据量要远远大于其他区域。\n数据大小倾斜——部分记录的大小远远大于平均值。\n2）如何收集倾斜数据\n+————————————————————–+| 在reduce方法中加入记录map输出键的详细情况的功能。            ||                                                              || public static final String MAX_VALUES &#x3D; &quot;skew.maxvalues&quot;; ||                                                              || private int maxValueThreshold;                               ||                                                              || @Override                                                   ||                                                              || public void configure(JobConf job) {                         ||                                                              || maxValueThreshold &#x3D; job.getInt(MAX_VALUES, 100);            ||                                                              || }                                                            ||                                                              || @Override                                                   ||                                                              || public void reduce(Text key, Iterator&lt;Text&gt; values,        ||                                                              || OutputCollector&lt;Text, Text&gt; output,                        ||                                                              || Reporter reporter) throws IOException {                      ||                                                              || int i &#x3D; 0;                                                   ||                                                              || while (values.hasNext()) {                                   ||                                                              || values.next();                                               ||                                                              || i++;                                                         ||                                                              || }                                                            ||                                                              || if (++i &gt; maxValueThreshold) {                              ||                                                              || log.info(&quot;Received &quot; + i + &quot; values for key &quot; + key);    ||                                                              || }                                                            ||                                                              || }                                                            |+————————————————————–+|                                                              |+————————————————————–+\n3）减少数据倾斜的方法\n方法1：抽样和范围分区\n可以通过对原始数据进行抽样得到的结果集来预设分区边界值。\n方法2：自定义分区\n基于输出键的背景知识进行自定义分区。例如，如果map输出键的单词来源于一本书，且其中某几个专业词汇较多。那么就可以自定义分区将这这些专业词汇发送给固定的一部分reduce实例。而将其他的都发送给剩余的reduce实例。\n方法3：Combine\n使用Combine可以大量地减小数据倾斜。在可能的情况下，combine的目的就是聚合并精简数据。\n方法4：采用Map Join，尽量避免Reduce Join。\n6.2.6 常用的调优参数1）资源相关参数\n+———————————–+———————————–+| （1）以下参数是在用户自己的mr应用程序中配置就可以生效（mapr | 参数说明 || ed-default.xml）配置参数          |                                   |+———————————–+———————————–+| mapreduce.map.memory.mb           | 一个Map                           ||                                   | Task可使用的资源上限（单位:MB），默认为1024。如果Map ||                                   |                                   ||                                   | Task实际使用的资源量超过该值，则会被强制杀死。 |+———————————–+———————————–+| mapreduce.reduce.memory.mb        | 一个Reduce                        ||                                   | Task可使用的资源上限（单位:MB），默认为1024。如果Red ||                                   | uceTask实际使用的资源量超过该值，则会被强制杀死。 |+———————————–+———————————–+| mapreduce.map.cpu.vcores          | 每个Map task可使用的最多cpu       ||                                   | core数目，默认值: 1               |+———————————–+———————————–+| mapreduce.reduce.cpu.vcores       | 每个Reduce task可使用的最多cpu    ||                                   | core数目，默认值: 1               |+———————————–+———————————–+| mapreduce.reduce.shuffle.parallel | 每个reduce去map中拿数据的并行数。默认值是5 || copies                            |                                   |+———————————–+———————————–+| mapreduce.reduce.shuffle.merge.pe | buffer中的数据达到多少比例开始写入磁盘。默认值0.66 || rcent                             |                                   ||                                   |                                   || 可提高                            |                                   |+———————————–+———————————–+| mapreduce.reduce.shuffle.input.bu | buffer大小占reduce可用内存的比例。默认值0.7 || ffer.percent                      |                                   |+———————————–+———————————–+| mapreduce.reduce.input.buffer.per | 指定多少比例的内存用来存放buffer中的数据，默认值是0.0 || cent                              |                                   |+———————————–+———————————–+\n（2）应该在yarn启动之前就配置在服务器的配置文件中才能生效（yarn-default.xml）\n\n  配置参数                                     参数说明  yarn.scheduler.minimum-allocation-mb1024     给应用程序container分配的最小内存  yarn.scheduler.maximum-allocation-mb8192     给应用程序container分配的最大内存  yarn.scheduler.minimum-allocation-vcores1    每个container申请的最小CPU核数  yarn.scheduler.maximum-allocation-vcores32   每个container申请的最大CPU核数  yarn.nodemanager.resource.memory-mb 8192     给containers分配的最大物理内存\n\n（3）shuffle性能优化的关键参数，应在yarn启动之前就配置好（mapred-default.xml）\n\n  配置参数                               参数说明  mapreduce.task.io.sort.mb 100          shuffle的环形缓冲区大小，默认100m  mapreduce.map.sort.spill.percent 0.8   环形缓冲区溢出的阈值，默认80%\n\n2）容错相关参数(mapreduce性能优化)\n\n  配置参数                       参数说明  mapreduce.map.maxattempts      每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。  mapreduce.reduce.maxattempts   每个Reduce Task最大重试次数，一旦重试参数超过该值，则认为Reduce Task运行失败，默认值：4。  mapreduce.task.timeout     Task超时时间，经常需要设置的一个参数，该参数表达的意思为：如果一个task在一定时间内没有任何进入，即不会读取新的数据，也没有输出数据，则认为该task处于block状态，可能是卡住了，也许永远会卡住，为了防止因为用户程序永远block住不退出，则强制设置了一个该超时时间（单位毫秒），默认是600000**(10分钟)。如果你的程序对每条输入数据的处理时间过长（比如会访问数据库，通过网络拉取数据等）**，建议将该参数调大，该参数过小常出现的错误提示是”AttemptID:attempt_14267829456721_123456_m_000224_0 Timed out after 300 secsContainer killed by the ApplicationMaster.”。\n\n6.3 HDFS小文件优化方法6.3.1 HDFS小文件弊端\nHDFS上每个文件都要在namenode上建立一个索引，这个索引的大小约为150byte，这样当小文件比较多的时候，就会产生很多的索引文件，一方面会大量占用namenode的内存空间，另一方面就是索引文件过大使得索引速度变慢。\n6.3.2 解决方案1）Hadoop Archive:\n是一个高效地将小文件放入HDFS块中的文件存档工具，它能够将多个小文件打包成一个HAR文件，这样就减少了namenode的内存使用。\n2）Sequence file：\nsequencefile由一系列的二进制key&#x2F;value组成，如果key为文件名，value为文件内容，则可以将大批小文件合并成一个大文件。\n3）CombineFileInputFormat：\nCombineFileInputFormat是一种新的inputformat，用于将多个文件合并成一个单独的split，另外，它会考虑数据的存储位置。\n4）开启JVM重用\n对于大量小文件Job，可以开启JVM重用会减少45%运行时间。\nJVM重用理解：一个map运行一个jvm，重用的话，一个map在jvm上运行完毕后，jvm继续运行其他map。\n具体设置：mapreduce.job.jvm.numtasks值在10-20之间。\nZookeeperZookeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.040277777777778in”}\nServer写，Client读\n1）Zookeeper：一个领导者（leader），多个跟随者（follower）组成的集群。\n2）Leader负责进行投票的发起和决议，更新系统状态。\n3）Follower用于接收客户请求并向客户端返回结果，在选举Leader过程中参与投票。\n4）集群中只要有(奇数个)半数以上节点存活，Zookeeper集群就能正常服务。\n5）全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的。\n6）更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行。\n7）数据更新原子性，一次数据更新要么成功，要么失败。\n8）实时性，在一定时间范围内，client能读到最新数据。\nZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树（stat结构体），每个节点称做一个ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。\n提供的服务包括：统一命名(域名)服务、统一配置管理(configcenter)、统一集群管理(Register+watch)、服务器节点动态上下线、软负载均衡LB等。\nLB：1个域名，n个（IP）servers(选访问量min)\n配置参数解读解读zoo.cfg文件中参数含义\n1）tickTime&#x3D;2000：通信心跳数，Zookeeper服务器心跳时间，单位毫秒 2s\nZookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。\n它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超\n时时间是2*tickTime)\n2）initLimit&#x3D;10：Leader和Follower初始通信时限 20s\n集群中的follower跟随者服务器与leader领导者服务器之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限。\n投票选举新leader的初始化时间\nFollower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。\nLeader允许Follower在initLimit时间内完成这个工作。\n3）syncLimit&#x3D;5：Leader和Follower同步通信时限 10s\n集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit *tickTime，Leader认为Follower死掉，从服务器列表中删除Follower。\n在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。\n如果L发出心跳包在syncLimit之后，还没有从F那收到响应，那么就认为这个F已经不在线了。\n4）dataDir：数据文件目录+数据持久化路径\n保存内存数据库快照信息的位置，如果没有其他说明，更新的事务日志也保存到数据库。\n5）clientPort&#x3D;[2181：]{.underline}客户端连接端口，监听客户端连接的端口\n分布式安装部署2）配置zoo.cfg文件\n（1）具体配置\ndataDir&#x3D;&#x2F;opt&#x2F;module&#x2F;zookeeper-3.4.10&#x2F;zkData\n增加如下配置\n#######################cluster##########################\nserver.2&#x3D;hadoop102:2888:3888\nserver.3&#x3D;hadoop103:2888:3888\nserver.4&#x3D;hadoop104:2888:3888\n（2）配置参数解读\nServer.A&#x3D;B:C:D。\nA是一个数字，表示这个是第几号服务器；\nB是这个服务器的ip地址&#x2F;hostname；\nC是这个服务器与集群中的Leader服务器交换信息的端口；2888\nD是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。3888\n集群模式下配置一个文件myid，这个文件在dataDir目录下，这个文件里面有一个数据就是A的值，[Zookeeper启动时读取此文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。]{.underline}\n3）集群操作\n（1）在&#x2F;opt&#x2F;module&#x2F;zookeeper-3.4.10&#x2F;zkData目录下创建一个myid的文件\ntouch myid\n添加myid文件，注意一定要在linux里面创建，在notepad++里面很可能乱码\n（2）编辑myid文件\nvi myid\n在文件中添加与server对应的编号：如2\n（3）拷贝配置好的zookeeper到其他机器上\nscp -r zookeeper-3.4.10&#x2F; root@hadoop103.atguigu.com:&#x2F;opt&#x2F;app&#x2F;\nscp -r zookeeper-3.4.10&#x2F; root@hadoop104.atguigu.com:&#x2F;opt&#x2F;app&#x2F;\n并分别修改myid文件中内容为3、4\n（4）分别启动zookeeper\n（5）查看状态\n[root@hadoop102 zookeeper-3.4.10]# bin&#x2F;zkServer.sh status\nFollower&#x2F;leader\nZookeeper内部原理 3.1 选举机制1）半数机制（Paxos协议）：集群中半数以上机器存活，集群可用。所以zookeeper适合装在奇数台机器上。\n2）Zookeeper虽然在配置文件中并没有指定master和slave。但是，zookeeper工作时，是有一个节点为leader，其他则为follower，Leader是通过内部的选举机制临时产生的。\n3）以一个简单的例子来说明整个选举的过程。\n假设有五台服务器组成的zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么。\n（1）服务器1启动，此时只有它一台服务器启动了，它发出去的报投自己没有任何响应，所以它的选举状态一直是LOOKING状态。\n（2）服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以**[id值较大的服务器2胜出]{.underline}，但是由于没有达到超过半数以上的服务器都同意选举**它(这个例子中的半数以上是3)，所以服务器1、2还是继续保持LOOKING状态。\n（3）服务器3启动，根据前面的理论分析，服务器[3成为服务器1、2、3中的老大]{.underline}，而与上面不同的是，此时[有三台服务器选举了它]{.underline}，所以它成为了这次选举的leader。\n（4）服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。\n（5）服务器5启动，同4一样当小弟。\n3.2 节点类型1）Znode有两种类型：\n短暂（ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除\n持久（persistent）：客户端和服务器端断开连接后，创建的节点不删除\n2）Znode有四种形式的目录节点（默认是persistent ）\n（1）持久化目录节点（PERSISTENT）\n客户端与zookeeper断开连接后，该节点依旧存在。\n（2）持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）\n客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号（不重复）。\n（3）临时目录节点（EPHEMERAL）\n客户端与zookeeper断开连接后，该节点被删除。动态上下线\n（4）临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）多用，实现znode动态上下线！\n客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。\n3）创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护\n4）在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样[客户端可以通过顺序号推断事件的顺序]{.underline}\n{width&#x3D;”6.912146762904637in”height&#x3D;”3.254717847769029in”}\n{width&#x3D;”6.983436132983377in”height&#x3D;”3.3301891951006124in”}\nHive一 Hive 基本概念1.1 什么是 HiveHive：由 Facebook 开源用于解决海量结构化日志的数据统计。\nHive 是基于 Hadoop的一个数据仓库DW工具，可以将结构化的数据文件映射为一张表，并\n提供类 SQL 查询功能。\n本质是：将 HQL 转化成 MapReduce 程序\n1）Hive 处理的数据存储在 HDFS\n2）Hive 分析数据底层的实现是 MapReduce\n3）执行程序运行在 Yarn 上\n1.2 Hive 的优缺点1.2.1 优点\n1）操作接口采用类 SQL 语法，提供快速开发的能力（简单、容易上手）\n2）避免了去写 MapReduce，减少开发人员的学习成本。\n3）Hive 的执行延迟比较高，因此 Hive常用于数据分析，对实时性要求不高的场合；\n4）Hive 优势在于处理大数据，对于处理小数据没有优势，因为 Hive的执行延迟比较高。场景：凌晨日活、月活、回流，分析后给mysql\n5）Hive 支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。\n1.2.2 缺点\n1）Hive 的 HQL 表达能力有限\n（1）迭代式算法无法表达\n（2）数据挖掘方面不擅长\n2）Hive 的效率比较低\n（1）Hive 自动生成的 MapReduce 作业，通常情况下不够智能化\n（2）Hive 调优比较困难，粒度较粗\n1.3 Hive 架构原理Hive 架构\n{width&#x3D;”3.6904636920384952in”height&#x3D;”3.2835826771653545in”}\n如图中所示，Hive通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，使用自己的Driver，结合元数据(MetaStore)，将这些指令翻译成 MapReduce，提交到 Hadoop中\n执行，最后，将执行返回的结果输出到用户交互接口。\n1）用户接口：Client\nCLI（hive shell）、JDBC&#x2F;ODBC(java 访问 hive)、WEBUI（浏览器访问 hive）\n2）元数据：Metastore\n元数据包括：表名、表所属的数据库（默认是default）、表的拥有者、列&#x2F;分区字段、表的类型（是否是外部表）、表的数据所在目录等；\n默认存储在自带的 derby 数据库中，推荐使用 MySQL 存储 Metastore\n3）Hadoop\n使用 HDFS 进行存储，使用 MapReduce 进行计算。\n4）驱动器：Driver\n（1）解析器（SQL Parser）：将 SQL 字符串转换成抽象语法树AST，这一步一般都用第三方工具库完成，比如 antlr；对 AST进行语法分析，比如表是否存在、字段是否存在、SQL 语义是否有误。\n（2）编译器（Physical Plan）：将 AST 编译生成逻辑执行计划。\n（3）优化器（Query Optimizer）：对逻辑执行计划进行优化。\n（4）执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于Hive 来说，就是 MR&#x2F;Spark。\n1.4 Hive 和数据库比较由于 Hive 采用了类似 SQL 的查询语言 HQL(Hive Query Language)，因此很容易将 Hive 理解为数据库。其实从结构上来看，Hive和数据库除了拥有类似的查询语言，再无类似之处。本文将从多个方面来阐述Hive 和数据库的差异。数据库可以用在 Online 的应用中，但是 Hive是为数据仓库而设计的，清楚这一点，有助于从应用角度理解 Hive 的特性。\n1.4.1 查询语言\n由于 SQL 被广泛的应用在数据仓库中，因此，专门针对 Hive 的特性设计了类SQL 的\n查询语言 HQL。熟悉 SQL 开发的开发者可以很方便的使用 Hive 进行开发。\n1.4.2 数据存储位置\nHive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS中的。而数据库则可以将数据保存在块设备或者本地文件系统中。\n1.4.3 数据更新\n由于 Hive是针对数据仓库应用设计的，而数据仓库的内容是读多写少的。因此，Hive中不支持对数据的改写和添加，所有的数据都是在加载的时候确定好的。而数据库中的数据通常是需要经常进行修改的，因此可以使用INSERT INTO … VALUES 添加数据，使用 UPDATE … SET 修改数据。\n1.4.4 索引\nHive在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些Key 建立索引。Hive要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。由于MapReduce 的引入， Hive可以并行访问数据，因此即使没有索引，[对于大数据量]{.underline}的访问，Hive仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。由于数据的访问延迟较高，决定了Hive 不适合在线数据查询。\n1.4.5 执行\nHive 中大多数查询的执行是通过 Hadoop 提供的 MapReduce来实现的。而数据库通常有自己的执行引擎。\n1.4.6 执行延迟\nHive在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致Hive 执行延迟高的因素是 MapReduce 框架。由于 MapReduce本身具有较高的延迟，因此在利用 MapReduce 执行 Hive查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。\n1.4.7 可扩展性\n由于 Hive 是建立在 Hadoop 之上的，因此 Hive 的可扩展性是和 Hadoop的可扩展性是一致的（世界上最大的 Hadoop 集群在 Yahoo!，2009 年的规模在4000 台节点左右）。而数据库由于 ACID语义的严格限制，扩展行非常有限。目前最先进的并行数据库[Oracle]{.underline}在理论上的扩展能力也只有 100 台左右。\n1.4.8 数据规模\n由于 Hive 建立在集群上并可以利用 MapReduce进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。\n适合处理大量数据：凌晨日活、月活、回流，分析后给mysql\n6.5 排序 6.5.1 全局排序（Order By）Order By：全局排序，一个 MapReduce\n1）使用 ORDER BY 子句排序\nASC（ascend）: 升序（默认）\nDESC（descend）: 降序\n2）ORDER BY 子句在 SELECT 语句的结尾。\n3）案例实操\n（1）查询员工信息按工资升序排列\nhive (default)&gt; select * from emp order by sal;\n（2）查询员工信息按工资降序排列\nhive (default)&gt; select * from emp order by sal desc;\n6.5.4 每个 MapReduce 内部排序（Sort By）Sort By：每个 MapReduce 内部进行排序，对全局结果集来说不是排序。\n1）设置 reduce 个数\nhive (default)&gt; set mapreduce.job.reduces&#x3D;3;\n2）查看设置 reduce 个数\nhive (default)&gt; set mapreduce.job.reduces;\n3）根据部门编号降序查看员工信息\nhive (default)&gt; select * from emp sort by deptno desc;\n4）将查询结果导入到文件中（按照部门编号降序排序）\nhive (default)&gt; insert overwrite local directory&#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;sortby-result&#39; select * from emp sort by deptnodesc;\n6.5.5 分区排序（Distribute By…sort by…）Distribute By：类似 MR 中 partition，进行分区，结合 sort by 使用。\n注意，Hive 要求 DISTRIBUTE BY 语句要写在 SORT BY 语句之前。\n对于 distribute by 进行测试，一定要分配多 reduce 进行处理，否则无法看到distribute by的效果。\n案例实操：\n（1）先按照部门编号分区，再按照员工编号降序排序。相当于自定义partitioner!!!!!\nhive (default)&gt; set mapreduce.job.reduces&#x3D;3;\nhive (default)&gt; insert overwrite local directory&#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;distribute-result&#39; select * from emp distribute bydeptno sort by empno desc;\n6.5.6 Cluster By当 [distribute by 和 sorts by 字段相同]{.underline}时，可以使用 clusterby 方式。\ncluster by 除了具有 distribute by 的功能外还兼具 sort by的功能。但是排序只能是倒序排序，不能指定排序规则为 ASC 或者 DESC。\n1）以下两种写法等价\nselect * from emp cluster by deptno;\nselect * from emp distribute by deptno sort by deptno;\n注意：按照部门编号分区，不一定就是固定死的数值，可以是 20 号和 30号部门分到一\n个分区里面去。\n6.6 分桶及抽样查询 6.6.1 分桶表数据存储partition分区针对的是数据的存储路径；分桶针对的是数据文件。\n分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理\n的分区，特别是之前所提到过的要确定合适的划分大小这个疑虑。\n分桶是将数据集分解成更容易管理的若干部分的另一个技术。\n1）先创建分桶表，通过直接导入数据文件的方式\n（0）数据准备\nstudent.txt\n（1）创建分桶表\ncreate table stu_buck(id int, name string)\nclustered by(id)\ninto 4 buckets\nrow format delimited fields terminated by &#39;\\t&#39;;\n（2）查看表结构\nhive (default)&gt; desc formatted stu_buck;\n{width&#x3D;”5.388888888888889in”height&#x3D;”1.0555555555555556in”}{width&#x3D;”5.305555555555555in”height&#x3D;”0.7222222222222222in”}\nNum Buckets: 4\n（3）导入数据到分桶表中\nhive (default)&gt; load data local inpath&#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;student.txt&#39; into table stu_buck;\n（4）查看创建的分桶表中是否分成 4 个桶\n发现并没有分成 4 个桶。是什么原因呢？\n2）创建分桶表时，数据通过子查询的方式导入\n（1）先建一个普通的 stu 表\ncreate table stu(id int, name string)\nrow format delimited fields terminated by &#39;\\t&#39;;\n（2）向普通的 stu 表中导入数据\nload data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;student.txt&#39; into table stu;\n（3）清空 stu_buck 表中数据\ntruncate table stu_buck;\nselect * from stu_buck;\n（4）导入数据到分桶表，通过子查询的方式\ninsert into table stu_buck\nselect id, name from stu cluster by(id);\n（5）发现还是只有一个分桶\n（6）需要设置一个属性\nhive (default)&gt;set hive.enforce.bucketing&#x3D;true;\nhive (default)&gt; set mapreduce.job.reduces&#x3D;-1;\nhive (default)&gt;insert into table stu_buck\n{width&#x3D;”5.291666666666667in”height&#x3D;”1.6388888888888888in”}select id, name from stu cluster by(id);\ndept_partition分区表分folders（&#x2F;month&#x3D;201707&#x2F;），stu_buck:分数据文件0000002_0.txt……\n（7）查询分桶的数据\nhive (default)&gt; select * from stu_buck;\nOK\nstu_buck.id stu_buck.name\n1001 ss1\n1005 ss5\n1009 ss9\n1012 ss12\n1016 ss16\n1002 ss2\n1006 ss6\n1013 ss13\n1003 ss3\n1007 ss7\n1010 ss10\n1014 ss14\n1004 ss4\n1008 ss8\n1011 ss11\n1015 ss15\n6.6.2 分桶抽样查询不可分割的大数据集，有null&#x2F;脏数据\n对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结\n果。Hive 可以通过对表进行抽样来满足这个需求。\n查询表 stu_buck 中的数据。\nhive (default)&gt; select * from stu_buck tablesample(bucket 1 out of 4on id);\n注：tablesample 是抽样语句，语法：TABLESAMPLE(BUCKET x OUT OF y) 。\ny 必须是 table 总 bucket 数的倍数或者因子。hive 根据 y的大小，决定抽样的比例。例如，table 总共分了 4 份，当 y&#x3D;2时，抽取(4&#x2F;2&#x3D;)2 个 bucket 的数据，当 y&#x3D;8 时，[抽取(**4&#x2F;**8&#x3D;)1&#x2F;2个bucket]{.underline} 的数据。\nx 表示[从哪个 bucket 开始]{.underline}抽取。例如，table 总bucket 数为 4，tablesample(bucket 4 out of 4)，表示总共抽取（4&#x2F;4&#x3D;）1 个bucket 的数据，抽取第 4 个 bucket 的数据。 注意：x 的值必须小于等于 y的值，否则\nFAILED: SemanticException [Error 10061]: Numerator should not bebigger than\ndenominator in sample clause for table stu_buck\n6.6.3 数据块抽样Hive提供了另外一种按照百分比进行抽样的方式，这种是基于行数的，按照输入路径\n下的数据块百分比进行的抽样。\nhive (default)&gt; select * from stu tablesample(0.1 percent) ;128M的0.1%\n提示：这种抽样方式不一定适用于所有的文件格式。另外，这种抽样的最小抽样单元是\n一个 HDFS 数据块128M。因此，如果表的数据大小小于普通的块大小 128M的话，那么将会返回所有行。\n8.5 文件存储格式 Hive 支持的存储数的格式主要有：TEXTFILE 、SEQUENCEFILE、ORC、PARQUET。\nstored as …\n{width&#x3D;”7.146527777777778in” height&#x3D;”2.6375in”}8.5.1 列式存储和行式存储上图左边为逻辑表，右边第一个为行式存储，第二个为列式存储。\n行存储的特点：查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。\n列存储的特点：因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以**针对性的设计更好的设计压缩算法。**\n**TEXTFILE 和 SEQUENCEFILE 的存储格式都是基于行存储的； **\n**ORC 和 PARQUET 是基于列式存储的。 **\n8.5.2 TextFile 格式默认格式，数据[不做压缩，磁盘开销大，数据解析开销大]{.underline}。可结合Gzip、Bzip2 使用(系\n统自动检查，执行查询时自动解压)，但使用这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。\n8.5.3 Orc 格式Orc (Optimized Row Columnar)是 hive 0.11 版里引入的新的存储格式。\n{width&#x3D;”4.125in”height&#x3D;”5.1007206911636045in”}\n可以看到每个 Orc 文件由 1 个或多个 stripe 组成，每个 stripe 250MB大小，这个 Stripe实际相当于 RowGroup 概念，不过大小由4MB-&gt;250MB，这样应该能提升顺序读的吞吐率。每个 Stripe里由三部分组成，分别是 Index Data,Row Data,Stripe Footer：\n1）Index Data：一个轻量级的 index，默认是每隔 1W行做一个索引。这里做的索引应该只是记录某行的各字段在 Row Data 中的offset。\n2）RowData：存的是具体的数据，先取部分行，然后对这些行按列进行存储。对每个列进行了编码，分成多个Stream 来存储。\n3）Stripe Footer：存的是各个 Stream的类型，长度等信息。每个文件有一个 File Footer，这里面存的是每个Stripe 的行数，每个 Column 的数据类型信息等；每个文件的尾部是一个PostScript，这里面记录了整个文件的压缩类型以及FileFooter的长度信息等。【在读取文件时，会 seek 到文件尾部读PostScript，从里面解析到 File Footer长度，再读FileFooter，从里面解析到各个 Stripe 信息，再读各个Stripe，即从后往前读。】\n8.5.4 Parquet 格式Parquet 是面向分析型业务的列式存储格式，由 Twitter 和 Cloudera合作开发，2015 年 5月从 Apache 的孵化器里毕业成为 Apache 顶级项目。\nParquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet 格式文件是自解析的。通常情况下，在存储 Parquet数据的时候会按照 Block 大小设置行组的大小，由于一般情况下每一个 Mapper任务处理数据的最小单位是一个 Block，这样可以把每一个行组由一个 Mapper任务处理，增大任务执行并行度。Parquet 文件的格式如下图所示。\n{width&#x3D;”6.522916666666666in”height&#x3D;”4.885416666666667in”}\n上图展示了一个 Parquet文件的内容，一个文件中可以存储多个行组，文件的首位都是\n该文件的 Magic Code，用于校验它是否是一个 Parquet 文件，Footer length记录了文件元数据的大小，通过该值和文件长度可以计算出元数据的偏移量，文件的元数据中包括每一个行组的元数据信息和该文件存储数据的Schema信息。除了文件中每一个行组的元数据，每一页的开始都会存储该页的元数据，在Parquet中，有三种类型的页：数据页、字典页和索引页。数据页用于存储当前行组中该列的值，字典页存储该列值的编码字典，每一个列块中最多包含一个字典页，索引页用来存储当前行组下该列的索引，目前Parquet 中还不支持索引页。\n**TEXTFILE 和 SEQUENCEFILE 的存储格式都是基于行存储的； **\nORC 和 PARQUET 是基于列式存储的。\n8.6.2 测试存储和压缩\n2）创建一个 SNAPPY 压缩的 ORC 存储方式\n（1）建表语句\ncreate table log_orc_snappy(\ntrack_time string,\nurl string,\nsession_id string,\nreferer string,\nip string,\nend_user_id string,\ncity_id string\n)\nrow format delimited fields terminated by &#39;\\t&#39;\nstored as orc **tblproperties (&quot;orc.compress&quot;&#x3D;&quot;SNAPPY&quot;); **\n（2）插入数据\ninsert into table log_orc_snappy select * from log_text ;\n（3）查看插入后数据\ndfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_orc_snappy&#x2F; ;\norc 存储文件默认采用 ZLIB 压缩。比 snappy 压缩的小。\n4）存储方式和压缩总结：\n在实际的项目开发当中，**hive 表的数据存储格式一般选择：orc 或parquet（小）。压缩方式一般选择（快）snappy不可切，lzo可切。 **\n九 Hive企业级调优 9.1 Fetch 抓取 Fetch 抓取是指，Hive 中对某些情况的查询可以不必使用 MapReduce计算。例如：SELECT * FROM employees;在这种情况下，Hive 可以简单地读取employee 对应的存储目录下的文件，然后输出查询结果到控制台。\n在 hive-default.xml.template 文件中 hive.fetch.task.conversion 默认是more，老版本 hive默认是 minimal，该属性修改为 more以后，在全局查找、字段查找、limit 查找等都不走mapreduce。\n&lt;property&gt;\n&lt;name&gt;hive.fetch.task.conversion&lt;&#x2F;name&gt;\n&lt;value&gt;more&lt;&#x2F;value&gt;\n&lt;description&gt;\nExpects one of [none, minimal, more].\nSome select queries can be converted to single FETCH task minimizinglatency.\nCurrently the query should be single sourced not having any subquery andshould not\nhave\nany aggregations or distincts (which incurs RS), lateral views andjoins.\n0. none : disable hive.fetch.task.conversion\n1. minimal : SELECT STAR, FILTER on partition columns, LIMIT only\n2. more : SELECT, FILTER, LIMIT only (support TABLESAMPLE and virtual\ncolumns)\n&lt;&#x2F;description&gt;\n&lt;&#x2F;property&gt;\n案例实操：\n1）把 hive.fetch.task.conversion 设置成 none，然后执行查询语句，都会执行mapreduce程序。\nhive (default)&gt; set hive.fetch.task.conversion&#x3D;none;\nhive (default)&gt; select * from emp;\nhive (default)&gt; select ename from emp;\nhive (default)&gt; select ename from emp limit 3;\n2）把 hive.fetch.task.conversion 设置成more，然后执行查询语句，如下查询方式都不会执行 mapreduce 程序。\nhive (default)&gt; set hive.fetch.task.conversion&#x3D;more;\nhive (default)&gt; select * from emp;\nhive (default)&gt; select ename from emp;\nhive (default)&gt; select ename from emp limit 3;\n9.2 本地模式 大多数的 Hadoop Job 是需要 Hadoop提供的完整的可扩展性来处理大数据集的。不过，有时 Hive的输入数据量是非常小的。在这种情况下，为查询触发执行任务时消耗可能会比实际job 的执行时间要多的多。对于大多数这种情况，Hive可以通过本地模式在单台机器上处理所有的任务。对于小数据集，执行时间可以明显被缩短。\n用户可以通过设置 hive.exec.mode.local.auto 的值为 true，来让 Hive在适当的时候自动启动这个优化。\nset hive.exec.mode.local.auto&#x3D;true; &#x2F;&#x2F;开启本地 mr\n&#x2F;&#x2F;设置 local mr 的最大输入数据量，当输入数据量小于这个值时采用 local mr的方式，\n默认为 134217728，即 128M\nset hive.exec.mode.local.auto.inputbytes.max&#x3D;50000000;\n&#x2F;&#x2F;设置 local mr 的最大输入文件个数，\n当输入文件个数小于这个值时采用 local mr 的方式，\n默认为 4\nset hive.exec.mode.local.auto.input.files.max&#x3D;10;\n案例实操：\n1）开启本地模式，并执行查询语句\nhive (default)&gt; set hive.exec.mode.local.auto&#x3D;true;\nhive (default)&gt; select * from emp cluster by deptno;\nTime taken: 1.328 seconds, Fetched: 14 row(s)\n2）关闭本地模式，并执行查询语句\nhive (default)&gt; set hive.exec.mode.local.auto&#x3D;false;\nhive (default)&gt; select * from emp cluster by deptno;\nTime taken: 20.09 seconds, Fetched: 14 row(s)\n9.3 表的优化 9.3.1 小表、大表 Join将 key 相对分散，并且数据量小的表放在 join的左边，这样可以有效减少内存溢出错误发生的几率；再进一步，可以使用Group 让小的维度表（1000 条以下的记录条数）先进内存。在 map 端完成reduce。\n实际测试发现：新版的 hive 已经对小表 JOIN 大表和大表 JOIN小表进行了优化。小表放在左边和右边已经没有明显区别。\n案例实操\n（0）需求：测试大表 JOIN 小表和小表 JOIN 大表的效率\n（1）建大表、小表和 JOIN 后表的语句\ncreate table bigtable(id bigint, time bigint, uid string, keywordstring, url_rank int, click_num int, click_url string) row formatdelimited fields terminated by &#39;\\t&#39;;\ncreate table smalltable(id bigint, time bigint, uid string, keywordstring, url_rank int, click_num int, click_url string) row formatdelimited fields terminated by &#39;\\t&#39;;\ncreate table jointable(id bigint, time bigint, uid string, keywordstring, url_rank int, click_num int, click_url string) row formatdelimited fields terminated by &#39;\\t&#39;;\n（2）分别向大表和小表中导入数据\nhive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;bigtable&#39;into table bigtable;\nhive (default)&gt;load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;smalltable&#39;into table smalltable;\n（3）关闭 mapjoin 功能（默认是打开的）\nset hive.auto.convert.join &#x3D; false;\n（4）执行小表 JOIN 大表语句\ninsert overwrite table jointable\nselect b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,b.click_url\nfrom smalltable s\nleft join bigtable b\non b.id &#x3D; s.id;\nTime taken: 35.921 seconds\n（5）执行大表 JOIN 小表语句\ninsert overwrite table jointable\nselect b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,b.click_url\nfrom bigtable b\nleft join smalltable s\non s.id &#x3D; b.id;\nTime taken: 34.196 seconds\n9.3.2 大表 Join 大表1）空 KEY 过滤\n有时 join 超时是因为某些 key 对应的数据太多，而相同 key对应的数据都会发送到相同的 reducer上，从而导致内存不够。此时我们应该仔细分析这些异常的key，很多情况下，这些 key 对应的数据是异常数据，我们需要在 SQL语句中进行过滤。例如 key 对应的字段为空，操作如下：\n案例实操\n（1）配置历史服务器\n配置 mapred-site.xml\n&lt;property&gt;\n&lt;name&gt;mapreduce.jobhistory.address&lt;&#x2F;name&gt;\n&lt;value&gt;hadoop102:10020&lt;&#x2F;value&gt;\n&lt;&#x2F;property&gt;\n&lt;property&gt;\n&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;&#x2F;name&gt;\n&lt;value&gt;hadoop102:19888&lt;&#x2F;value&gt;\n&lt;&#x2F;property&gt;\n启动历史服务器\nsbin&#x2F;mr-jobhistory-daemon.sh start historyserver\n查看 jobhistory\nhttp://192.168.1.102:19888/jobhistory\n\n（2）创建原始数据表、空 id 表、合并后数据表\ncreate table ori(id bigint, time bigint, uid string, keyword string,url_rank int, click_num int, click_url string) row format delimitedfields terminated by &#39;\\t&#39;;\ncreate table nullidtable(id bigint, time bigint, uid string, keywordstring, url_rank int, click_num int, click_url string) row formatdelimited fields terminated by &#39;\\t&#39;;\ncreate table jointable(id bigint, time bigint, uid string, keywordstring, url_rank int, click_num int, click_url string) row formatdelimited fields terminated by &#39;\\t&#39;;\n（3）分别加载原始数据和空 id 数据到对应表中\nhive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;ori&#39; intotable ori;\nhive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;nullid&#39;into table nullidtable;\n（4）测试不过滤空 id\nhive (default)&gt; insert overwrite table jointable\nselect n.* from nullidtable n left join ori o on n.id &#x3D; o.id;\nTime taken: 42.038 seconds\n（5）测试过滤空 id\nhive (default)&gt; insert overwrite table jointable\nselect n.* from [(select * from nullidtable where id is not null)]{.underline} n left join ori o on n.id &#x3D; o.id;\nTime taken: 31.725 seconds\n2）空 key 转换\n有时虽然某个 key为空对应的数据很多（进入同一个reduce中：数据倾斜），但是相应的数据不是异常数据，必须要包含在join的结果中，此时我们可以给表 a 中 key为空的字段赋一个随机的值，使得数据随机均匀地分到不同的 reducer上。例如：\n案例实操：\n不随机分布空 null 值：\n（1）设置 5 个 reduce 个数\nset mapreduce.job.reduces &#x3D; 5;\n（2）JOIN 两张表\ninsert overwrite table jointable\nselect n.* from nullidtable n left join ori b on n.id &#x3D; b.id;\n{width&#x3D;”6.689583333333333in”height&#x3D;”2.8645833333333335in”}\n结果：可以看出来，出现了数据倾斜，某些 reducer 的资源消耗远大于其他reducer。\n随机分布空 null 值\n（1）设置 5 个 reduce 个数\nset mapreduce.job.reduces &#x3D; 5;\n（2）JOIN 两张表\ninsert overwrite table jointable\nselect n.* from nullidtable n full join ori o on\n[case when n.id is null then concat(&#39;hive&#39;, rand()) elsen.id end]{.underline} &#x3D; o.id;\n{width&#x3D;”6.725694444444445in”height&#x3D;”2.7604166666666665in”}\n结果：可以看出来，消除了数据倾斜，负载均衡 reducer 的资源消耗\n9.3.3 MapJoin如果不指定 MapJoin 或者不符合 MapJoin 的条件，那么 Hive 解析器会将 Join操作转换成Common Join，即：在 Reduce 阶段完成join。容易发生数据倾斜。可以用 MapJoin 把小表全部加载到内存在 map 端进行join，避免 reducer 处理。\n1）开启 MapJoin 参数设置：\n（1）设置自动选择 Mapjoin\nset hive.auto.convert.join &#x3D; true; 默认为 true\n（2）大表小表的阀值设置（默认 25M 以下认为是小表）：\nset hive.mapjoin.smalltable.filesize&#x3D;25000000;\n2）MapJoin 工作机制\n{width&#x3D;”7.310951443569554in”height&#x3D;”3.6875in”}\n案例实操：\n（1）开启 Mapjoin 功能\nset hive.auto.convert.join &#x3D; true; 默认为 true\n（2）执行小表 JOIN 大表语句\ninsert overwrite table jointable\nselect b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,b.click_url\nfrom smalltable s\njoin bigtable b\non s.id &#x3D; b.id;\nTime taken: 24.594 seconds\n（3）执行大表 JOIN 小表语句 （优化更多）\ninsert overwrite table jointable\nselect b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,b.click_url\nfrom bigtable b\njoin smalltable s\non s.id &#x3D; b.id;\nTime taken: 24.315 seconds\n9.3.4 Group By默认情况下，Map 阶段同一 Key 数据分发给一个 reduce，当一个 key数据过大时就倾\n斜了。 方法一：Map join ；方法二：负载均衡\n并不是所有的聚合操作都需要在 Reduce 端完成，很多聚合操作都可以先在 Map端进行\n部分聚合，最后在 Reduce 端得出最终结果。\n1）开启 Map 端聚合参数设置\n（1）是否在 Map 端进行聚合，默认为 True\nhive.map.aggr &#x3D; true\n（2）在 Map 端进行聚合操作的条目数目\nhive.groupby.mapaggr.checkinterval &#x3D; 100000\n（3）有数据倾斜的时候进行负载均衡（默认是 false）\nhive.groupby.skewindata &#x3D; true\n当选项设定为 true，生成的查询计划会有两个 MR Job。第一个 MR Job中，Map 的输\n出结果会随机分布到 Reduce 中，每个 Reduce做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MRJob 再根据预处理的数据结果按照 Group By Key 分布到 Reduce中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce中），最后完成最终的聚合操作。 （类似于：二级缓存）\n9.3.5 Count(Distinct) 去重统计数据量小的时候无所谓，数据量大的情况下，由于 COUNT DISTINCT操作需要用一个\nReduce Task 来完成，这一个 Reduce 需要处理的数据量太大，就会导致整个 Job很难完成，一般 COUNT DISTINCT 使用先 GROUP BY 再 COUNT 的方式替换：\n案例实操\n（1）创建一张大表\nhive (default)&gt; create table bigtable(id bigint, time bigint, uidstring, keyword string, url_rank int, click_num int, click_urlstring) row format delimited fields terminated by &#39;\\t&#39;;\n（2）加载数据\nhive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;bigtable&#39;into table bigtable;\n（3）设置 5 个 reduce 个数\nset mapreduce.job.reduces &#x3D; 5;\n（4）执行去重 id 查询\nhive (default)&gt; select count(distinct id) from bigtable;\nStage-Stage-1: Map: 1 Reduce: 1 Cumulative CPU: 7.12 sec HDFS Read:\n120741990 HDFS Write: 7 SUCCESS\nTotal MapReduce CPU Time Spent: 7 seconds 120 msec\nOK\nc0\n100001\nTime taken: 23.607 seconds, Fetched: 1 row(s)\nTime taken: 34.941 seconds, Fetched: 1 row(s)\n（5）采用 GROUP by 去重 id\nhive (default)&gt; select count(id) from [(select id from bigtable groupby id)]{.underline} a;\nStage-Stage-1: Map: 1 Reduce: 5 Cumulative CPU: 17.53 sec HDFS Read:\n120752703 HDFS Write: 580 SUCCESS\nStage-Stage-2: Map: 3 Reduce: 1 Cumulative CPU: 4.29 sec HDFS Read: 9409\nHDFS Write: 7 SUCCESS\nTotal MapReduce CPU Time Spent: 21 seconds 820 msec\nOK\n_c0\n100001\nTime taken: 50.795 seconds, Fetched: 1 row(s)\n虽然会多用一个 Job 来完成，但在数据量大的情况下，这个绝对是值得的。\n9.3.6 笛卡尔积尽量避免笛卡尔积，join 的时候不加 on 条件，或者无效的 on 条件，Hive只能使用 1\n个 reducer 来完成笛卡尔积\n9.3.7 行列过滤列处理：在 SELECT 中，只拿需要的列，如果有，尽量使用分区过滤，少用SELECT *。\n行处理：在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在 Where后面，\n那么就会先全表关联，之后再过滤，不好。比如：\n案例实操：\n（1）测试先join关联两张表，再用 where 条件过滤\nhive (default)&gt; select o.id from bigtable b\njoin ori o on o.id &#x3D; b.id\nwhere o.id &lt;&#x3D; 10;\nTime taken: 34.406 seconds, Fetched: 100 row(s)\nTime taken: 26.043 seconds, Fetched: 100 row(s)\n（2）通过子查询where后，再关联join表\nhive (default)&gt; select b.id from bigtable b\njoin [(select id from ori where id &lt;&#x3D; 10 ) o]{.underline} on b.id &#x3D;o.id;\nTime taken: 30.058 seconds, Fetched: 100 row(s)\nTime taken: 29.106 seconds, Fetched: 100 row(s)\n9.3.8 动态分区调整关系型数据库中，对分区表 Insert数据时候，数据库自动会根据分区字段的值，将数据\n插入到相应的分区中，Hive 中也提供了类似的机制，即动态分区(DynamicPartition)，只不过，使用 Hive 的动态分区，需要进行相应的配置。\n1）开启动态分区参数设置\n（1）开启动态分区功能（默认 true，开启）\nhive.exec.dynamic.partition&#x3D;true\n（2）设置为非严格模式（动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。）\nhive.exec.dynamic.partition.mode&#x3D;nonstrict\n（3）在所有执行 MR 的节点上，最大一共可以创建多少个动态分区。\nhive.exec.max.dynamic.partitions&#x3D;1000\n（4）在每个执行 MR的节点上，最大可以创建多少个动态分区。该参数需要根据实际\n的数据来设定。比如：源数据中包含了**[一年的数据，即 day 字段有 365个值，那么该参数就需要设置成大于 365，如果使用默认值 100，则会报错。]{.underline}**\nhive.exec.max.dynamic.partitions.pernode&#x3D;100\n（5）整个 MR Job 中，最大可以创建多少个 HDFS 文件。\nhive.exec.max.created.files&#x3D;100000\n（6）当有空分区生成时，是否抛出异常。一般不需要设置。\nhive.error.on.empty.partition&#x3D;false\n2）案例实操\n需求：\n将 ori 中的数据按照时间(如：20111230000008)，插入到目标表ori_partitioned_target的相应分区中。\n（1）创建分区表\ncreate table ori_partitioned(id bigint, time bigint, uid string,keyword string, url_rank int, click_num int, click_url string)\npartitioned by (p_time bigint)\nrow format delimited fields terminated by &#39;\\t&#39;;\n（2）加载数据到分区表中\nhive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;ds1&#39; intotable ori_partitioned partition(p_time&#x3D;&#39;20111230000010&#39;) ;\nhive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;ds2&#39; intotable ori_partitioned partition(p_time&#x3D;&#39;20111230000011&#39;) ;\n（3）创建目标分区表\ncreate table ori_partitioned_target(id bigint, time bigint, uidstring, keyword string, url_rank int, click_num int, click_urlstring) PARTITIONED BY (p_time STRING) row format delimited fieldsterminated by &#39;\\t&#39;;\n（4）设置动态分区\nset hive.exec.dynamic.partition &#x3D; true;\nset hive.exec.dynamic.partition.mode &#x3D; nonstrict;\nset hive.exec.max.dynamic.partitions &#x3D; 1000;\nset hive.exec.max.dynamic.partitions.pernode &#x3D; 100;\nset hive.exec.max.created.files &#x3D; 100000;\nset hive.error.on.empty.partition &#x3D; false;\nhive (default)&gt; insert overwrite table ori_partitioned_targetpartition (p_time) select id, time, uid, keyword, url_rank,click_num, click_url, p_time from ori_partitioned;\n（5）查看目标分区表的分区情况\nhive (default)&gt; show partitions ori_partitioned_target;\n9.3.9 分桶详见 6.6 章。\n9.3.10 分区详见 4.6 章。\n9.4 数据倾斜 9.4.1 合理设置 Map 数1）通常情况下，作业会通过 input 的目录产生一个或者多个 map任务。 切片公式\n主要的决定因素有：input 的文件总个数，input的文件大小，集群设置的文件块大小。\n2）是不是 map 数越多越好？\n答案是否定的。如果一个任务有很多小文件（远远小于块大小128m），则每个小文件也会被当做一个块，用一个 map 任务来完成，而一个 map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的map 数是受限的。\n**很多小文件IO密集型：减少 map 数 **\n3）是不是保证每个 map 处理接近 128m 的文件块，就高枕无忧了？\n答案也是不一定。比如有一个 127m 的文件，正常会用一个 map去完成，但这个文件只\n有一个或者两个小字段，却有几千万的记录，如果 map处理的逻辑比较复杂，用一个 map任务去做，肯定也比较耗时。计算密集型：增加 map 数\n针对上面的问题 2 和 3，我们需要采取两种方式来解决：即减少 map 数和增加map 数；\n9.4.2 小文件进行合并hadoop:CombineTextInputFormat\n在 map 执行前合并小文件，减少 map 数：CombineHiveInputFormat具有对小文件进行\n合并的功能（系统默认的格式）。HiveInputFormat 没有对小文件合并功能。\n[set hive.input.format&#x3D;org.apache.hadoop.hive.ql.io.CombineHiveInputFormat; ]{.underline}\n9.4.3 复杂文件增加 Map 数当 input 的文件都很大，任务逻辑复杂，map 执行非常慢的时候，可以考虑增加Map\n数，来使得每个 map 处理的数据量减少，从而提高任务的执行效率。\n增加 map 的方法为：一个splite进入一个map\ncomputeSpliteSize(Math.max(minSize1,Math.min(maxSizelong最大值,blocksize128M)))&#x3D;blocksize&#x3D;128M公式，**调整 maxSize 最大值。让 maxSize 最大值低于 blocksize 就可以增加map 的个数。 **\n案例实操：\n（1）执行查询\nhive (default)&gt; select count(*) from emp;\nHadoop job information for Stage-1: number of mappers: 1; number ofreducers: 1\n（2）设置最大切片值为 100 个字节\nhive (default)&gt; set mapreduce.input.fileinputformat.split.maxsize&#x3D;100;\nhive (default)&gt; select count(*) from emp;\nHadoop job information for Stage-1: number of mappers: 6; number ofreducers: 1\n9.4.4 合理设置 Reduce 数1）调整 reduce 个数方法一\n（1）每个 Reduce 处理的数据量默认是 256MB\nhive.exec.reducers.bytes.per.reducer&#x3D;256000000\n（2）每个任务最大的 reduce 数，默认为 1009\nhive.exec.reducers.max&#x3D;1009\n（3）计算 reducer 数的公式\nN&#x3D;min(参数 2，总输入数据量&#x2F;参数 1)\n2）调整 reduce 个数方法二\n在 hadoop 的 mapred-default.xml 文件中修改\n设置每个 job 的 Reduce 个数\nset mapreduce.job.reduces &#x3D; 15;\n3）reduce 个数并不是越多越好\n1）过多的启动和初始化 reduce 也会消耗时间和资源；\n2）另外，有多少个reduce，就会有多少个输出文件，如果生成了很多个小文件，那么\n如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；\n在设置 reduce 个数的时候也需要考虑这两个原则：处理大数据量利用合适的reduce 数；\n使单个 reduce 任务处理数据量大小要合适；\n9.5 并行执行 Hdfs –put… -- &gt; 多个.edits文件\nHive 会将一个查询转化成一个或者多个阶段。这样的阶段可以是 MapReduce阶段、抽\n样阶段、合并阶段、limit 阶段。或者 Hive执行过程中可能需要的其他阶段。默认情况下，Hive一次只会执行一个阶段。不过，[某个特定的 job可能包含众多的阶段，而这些阶段可能并非完全互相依赖的]{.underline}，也就是说有些阶段是可以并行执行的，这样可能使得整个job 的执行时间缩短。不过，如果有更多的阶段可以并行执行，那么 job可能就越快完成。\n通过设置参数 hive.exec.parallel 值为true，就可以开启并发执行。不过，在共享集群中，需要注意下，如果 job中并行阶段增多，那么集群利用率就会增加。\nset hive.exec.parallel&#x3D;true; &#x2F;&#x2F;打开任务并行执行\nset hive.exec.parallel.thread.number&#x3D;16; &#x2F;&#x2F;同一个 sql允许最大并行度，默认为 8。\n当然，得是在系统资源比较空闲的时候才有优势，否则，没资源，并行也起不来。\n9.6 严格模式 Hive提供了一个严格模式，可以防止用户执行那些可能意向不到的不好的影响的查询。通过设置属性hive.mapred.mode 值为默认是非严格模式 nonstrict 。开启严格模式需要修改hive.mapred.mode 值为 strict，开启严格模式可以禁止 3 种类型的查询。\nhive-default.xml:\n&lt;property&gt;\n&lt;name&gt;hive.mapred.mode&lt;&#x2F;name&gt;\n&lt;value&gt;strict&lt;&#x2F;value&gt;\n&lt;description&gt;\nThe mode in which the Hive operations are being performed.\nIn strict mode, some risky queries are not allowed to run. They include:\nCartesian Product.\nNo partition being picked up for a query.\nComparing bigints and strings.\nComparing bigints and doubles.\nOrderby without limit.\n&lt;&#x2F;description&gt;\n&lt;&#x2F;property&gt;\n1）对于分区表，除非 [where语句中含有分区字段过滤条件来限制范围]{.underline}，否则不允许执行。换句话说，就是用户不允许扫描所有分区。进行这个限制的原因是，通常分区表都拥有非常大的数据集，而且数据增加迅速。没有进行分区限制的查询可能会消耗令人不可接受的巨大资源来处理这个表。\n2）对于使用了 [order by 语句的查询，要求必须使用 limit]{.underline}语句。因为 order by 为了执行排序过程会将所有的结果数据分发到同一个Reducer 中进行处理，强制要求用户增加这个 LIMIT语句可以防止 Reducer额外执行很长一段时间。\n3）**[限制笛卡尔积]{.underline}的查询。对关系型数据库非常了解的用户可能期望在执行JOIN 查询的时候不使用 ON 语句而是使用 where语句，这样关系数据库的执行优化器**就可以高效地将WHERE 语句转化成那个ON 语句。不幸的是，Hive并不会执行这种优化，因此，如果表足够大，那么这个查询就会出现不可控的情况。\n9.7 JVM 重用 JVM 重用是 Hadoop 调优参数的内容，其对 Hive的性能具有非常大的影响，特别是对\n于很难避免小文件的场景或 task特别多的场景，这类场景大多数执行时间都很短。\nHadoop 的默认配置通常是使用派生 JVM 来执行 map 和 Reduce 任务的。这时JVM 的\n启动过程可能会造成相当大的开销，尤其是执行的 job 包含有成百上千 task任务的情况。JVM重用可以使得 JVM 实例在同一个 job 中重新使用 N 次。N的值可以在 Hadoop 的mapred-site.xml 文件中进行配置。通常在 10-20之间，具体多少需要根据具体业务场景测试\n得出。\n&lt;property&gt;\n&lt;name&gt;mapreduce.job.jvm.numtasks&lt;&#x2F;name&gt;\n&lt;value&gt;10&lt;&#x2F;value&gt;\n&lt;description&gt;How many tasks to run per jvm. If set to -1, there is\nno limit.\n&lt;&#x2F;description&gt;\n&lt;&#x2F;property&gt;\n这个功能的缺点是，开启 JVM 重用将一直占用使用到的 task插槽，以便进行重用，直\n到任务完成后才能释放。如果某个”不平衡的”job 中有某几个 reduce task执行的时间要比其他 Reduce task消耗的时间多的多(数据倾斜)的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task 都结束了才会释放。\n9.8 推测执行 在分布式集群环境下，因为程序 Bug（包括 Hadoop 本身的bug），负载不均衡或者资源分布不均等原因，会造成同一个作业的多个任务之间运行速度不一致，有些任务的运行速度可能明显慢于其他任务（比如一个作业的某个任务进度只有50%，而其他所有任务已经运行完毕），则这些任务会拖慢作业的整体执行进度。为了避免这种情况发生，Hadoop采用了推测执行（SpeculativeExecution）机制，它根据一定的法则推测出”拖后腿”的任务，并为这样的任务启动一个备份任务，让该任务与原始任务同时处理同一份数据，并最终选用最先成功运行完成任务的计算结果作为最终结果。\n设置开启推测执行参数：Hadoop 的 mapred-site.xml 文件中进行配置\n&lt;property&gt;\n&lt;name&gt;mapreduce.map.speculative&lt;&#x2F;name&gt;\n&lt;value&gt;true&lt;&#x2F;value&gt;\n&lt;description&gt;If true, then multiple instances of some map tasks\nmay be executed in parallel.&lt;&#x2F;description&gt;\n&lt;&#x2F;property&gt;\n&lt;property&gt;\n&lt;name&gt;mapreduce.reduce.speculative&lt;&#x2F;name&gt;\n&lt;value&gt;true&lt;&#x2F;value&gt;\n&lt;description&gt;If true, then multiple instances of some reduce tasks\nmay be executed in parallel.&lt;&#x2F;description&gt;\n&lt;&#x2F;property&gt;\n不过 hive 本身也提供了配置项来控制 reduce-side 的推测执行：\n&lt;property&gt;\n&lt;name&gt;hive.mapred.reduce.tasks.speculative.execution&lt;&#x2F;name&gt;\n&lt;value&gt;true&lt;&#x2F;value&gt;\n&lt;description&gt;Whether speculative execution for reducers should beturned on.\n&lt;&#x2F;description&gt;\n&lt;&#x2F;property&gt;\n关于调优这些推测执行变量，还很难给一个具体的建议。如果用户对于运行时的偏差非常敏感的话，那么可以将这些功能关闭掉。如果用户因为输入数据量很大而需要执行长时间的map 或者 Reduce task 的话，那么启动推测执行造成的浪费是非常巨大的。\n9.9 压缩 详见第 8 章。\n9.10 执行计划（Explain） 1）基本语法\nEXPLAIN [EXTENDED | DEPENDENCY | AUTHORIZATION] query\n2）案例实操\n（1）查看下面这条语句的执行计划\nhive (default)&gt; explain select * from emp;\nhive (default)&gt; explain select deptno, avg(sal) avg_sal from emp groupby deptno;\n（2）查看详细执行计划\nhive (default)&gt; explain extended select * from emp;\nhive (default)&gt; explain extended select deptno, avg(sal) avg_sal fromemp group by deptno;\n数据仓库 11.1 什么是数据仓库 数据仓库，英文名称为 Data Warehouse，可简写为 DW 或DWH。数据仓库，是[为企业所有级别的决策制定过程]{.underline}，提供所有类型数据支持的战略集合。它出于分析性报告和决策支持目的而创建。为需要业务智能的企业，提供指导业务流程改进、监视时间、成本、质量以及控制。\n11.2 数据仓库能干什么？ 1）[年度销售目标的指定]{.underline}，需要[根据以往的历史报表进行决策]{.underline}，不能拍脑袋。\n2）如何[优化业务流程 ]{.underline}\n例如：一个电商网站订单的完成包括：浏览、下单、支付、物流，其中物流环节可能和中通、申通、韵达等快递公司合作。快递公司每派送一个订单，都会有订单派送的确认时间，可以根据订单派送时间来分析哪个快递公司比较快捷高效，从而选择与哪些快递公司合作，剔除哪些快递公司，增加用户友好型。\n11.3 数据仓库的特点 1）数据仓库的数据是面向主题的 分类\n与传统数据库面向应用进行数据组织的特点相对应，数据仓库中的数据是面向主题进行组织的。什么是主题呢？首先，主题是一个抽象的概念，是较高层次上企业信息系统中的数据综合、归类并进行分析利用的抽象。在逻辑意义上，它是对应企业中某一宏观分析领域所涉及的分析对象。面向主题的数据组织方式，就是在较高层次上对分析对象的数据的一个完整、一致的描述，能完整、统一地刻划各个分析对象所涉及的企业的各项数据，以及数据之间的联系。所谓较高层次是相对面向应用的数据组织方式而言的，是指按照主题进行数据组织的方式具有更高的数据抽象级别。\n2）数据仓库的数据是集成的\n数据仓库的数据是从原有的分散的数据库数据抽取来的。操作型数据与 DSS分析型数据之间差别甚大。第一，数据仓库的每一个主题所对应的源数据在原有的各分散数据库中有许多重复和不一致的地方，且来源于不同的联机系统的数据都和不同的应用逻辑捆绑在一起；第二，数据仓库中的综合数据不能从原有的数据库系统直接得到。因此在数据进入数据仓库之前，必然要经过统一与综合，这一步是数据仓库建设中最关键、最复杂的一步，所要完成的工作有：\n（1）要统一源数据中所有矛盾之处，如字段的同名异义、异名同义、单位不统一、字长不一致等。\n（2）进行数据综合和计算。数据仓库中的数据综合工作可以在从原有数据库抽取数据时生成，但许多是在数据仓库内部生成的，即进入数据仓库以后进行综合生成的。\n3）数据仓库的数据是不可更新的 清洗再分类，不删\n数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一般情况下并不进行修改操作。数据仓库的[数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据，而不是联机处理的数据。]{.underline}数据库中进行联机处理的数据经过集成输入到数据仓库中，\n一旦数据仓库存放的数据已经超过数据仓库的数据存储期限，这些数据将从当前的数据仓库中删去。因为数据仓库只进行数据查询操作，所以数据仓库管理系统相比数据库管理系统而言要简单得多。数据库管理系统中许多技术难点，如完整性保护、并发控制等等，在数据仓库的管理中几乎可以省去。但是由于数据仓库的查询数据量往往很大，所以就对数据查询提出了更高的要求，它要求采用各种复杂的索引技术；同时由于数据仓库面向的是商业企业的高层管理者，他们会对数据查询的[界面友好性和数据表示]{.underline}提出更高的要求。\n4）数据仓库的数据是随时间不断变化的\n数据仓库中的数据不可更新是针对应用来说的，也就是说，数据仓库的用户进行分析处理时是不进行数据更新操作的。但并不是说，在从数据集成输入数据仓库开始到最终被删除的整个数据生存周期中，所有的数据仓库数据都是永远不变的。数据仓库的数据是随时间的变化而不断变化的，这是数据仓库数据的第四个特征。这一特征表现在以下3 方面：\n（1）数据仓库随时间变化不断增加新的数据内容。数据仓库系统必须不断捕捉OLTP数据库中变化的数据，追加到数据仓库中去，也就是要不断地生成 OLTP数据库的快照，经统一集成后增加到数据仓库中去；但对于确实不再变化的数据库快照，如果捕捉到新的变化数据，则只生成一个新的数据库快照增加进去，而不会对原有的数据库快照进行修改。\n（2）数据仓库随时间变化不断删去旧的数据内容。数据仓库的数据也有存储期限，一旦超过了这一期限，过期数据就要被删除。只是数据仓库内的数据时限要远远长于操作型环境中的数据时限。在操作型环境中一般只保存有60~90 天的数据，而在数据仓库中则需要保存较长时限的数据（如 [5~10年]{.underline}），以适应 DSS 进行趋势分析的要求。\n（3）数据仓库中包含有大量的综合数据，这些综合数据中很多跟时间有关，如数据经常按照时间段进行综合，或隔一定的时间片进行抽样等等。这些数据要随着时间的变化不断地进行重新综合。因此，数据仓库的数据特征都包含时间项，以标明数据的历史时期。\n11.4 数据仓库发展历程 数据仓库的发展大致经历了这样的三个过程：\n1）简单报表阶段：这个阶段，系统的主要目标是解决一些日常的工作中业务人员需要的报表，以及生成一些简单的能够帮助领导进行决策所需要的汇总数据。这个阶段的大部分表现形式为数据库和前端报表工具。\n2）数据集市阶段：这个阶段，主要是根据某个业务部门的需要，进行一定的数据的采集，整理，按照业务人员的需要，进行多维报表的展现，能够提供对特定业务指导的数据，并且能够提供特定的领导决策数据。\n3）数据仓库阶段：这个阶段，主要是按照一定的**[数据模型]{.underline}**，对整个企业的数据进行采集，整理，并且能够按照各个业务部门的需要，提供跨部门的，完全一致的业务报表数据，能够通过数据仓库生成对业务具有指导性的数据，同时，为领导决策提供全面的数据支持。通过数据仓库建设的发展阶段，我们能够看出，数据仓库的建设和数据集市的建设的重要区别就在于数据模型的支持。因此，数据模型的建设，对于我们数据仓库的建设，有着决定性的意义。\n11.5 数据库与数据仓库的区别 了解数据库与数据仓库的区别之前，首先掌握三个概念。数据库软件、数据库、数据仓库。\n数据库软件：是一种软件，可以看得见，可以操作。用来实现数据库逻辑功能。属于物理层。\n数据库：是一种逻辑概念，用来存放数据的仓库。通过数据库软件来实现。数据库由很多表组成，表是二维的，一张表里可以有很多字段。字段一字排开，对应的数据就一行一行写入表中。数据库的表，在于能够用二维表现多维关系。目前市面上流行的数据库都是二维数据库。如：Oracle、DB2、MySQL、Sybase、MSSQL Server 等。\n数据仓库：是数据库概念的升级。从逻辑上理解，数据库和数据仓库没有区别，都是通过数据库软件实现的存放数据的地方，只不过从数据量来说，数据仓库要比数据库更庞大得多。数据仓库主要用于数据挖掘和数据分析，辅助领导做决策。\n在 IT的架构体系中，数据库是必须存在的。必须要有地方存放数据。比如现在的网购，淘宝，京东等等。物品的存货数量，货品的价格，用户的账户余额之类的。这些数据都是存放在后台数据库中。或者最简单理解，我们现在微博，QQ等账户的用户名和密码。在后台数据库必然有一张 user表，字段起码有两个，即用户名和密码，然后我们的数据就一行一行的存在表上面。当我们登录的时候，我们填写了用户名和密码，这些数据就会被传回到后台去，去跟表上面的数据匹配，匹配成功了，你就能登录了。匹配不成功就会报错说密码错误或者没有此用户名等。这个就是数据库，数据库在生产环境就是用来干活的。凡是跟业务应用挂钩的，我们都使用数据库。\n数据仓库则是 BI下的其中一种技术。由于数据库是跟业务应用挂钩的，所以一个数据库不可能装下一家公司的所有数据。数据库的表设计往往是针对某一个应用进行设计的。比如刚才那个登录的功能，这张user表上就只有这两个字段，没有别的字段了。但是这张表符合应用，没有问题。但是这张表不符合分析。比如我想知道在哪个时间段，用户登录的量最多？哪个用户一年购物最多？诸如此类的指标。那就要重新设计数据库的表结构了。对于数据分析和数据挖掘，我们引入数据仓库概念。数据仓库的表结构是依照分析需求，分析维度，分析指标进行设计的。\n数据库与数据仓库的区别实际讲的是 OLTP 与 OLAP 的区别。\n操作型处理，叫联机事务处理 OLTP（On-Line TransactionProcessing），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。\n传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。\n分析型处理，叫联机分析处理 OLAP（On-Line AnalyticalProcessing）一般针对某些主题的历史数据进行分析，支持管理决策。\n{width&#x3D;”6.5in”height&#x3D;”4.897222222222222in”}\n11.6 数据仓库架构分层 11.6.1 数据仓库架构数据仓库标准上可以分为四层：ODS（临时存储层）、PDW（数据仓库层）、DM（数{width&#x3D;”4.263888888888889in”height&#x3D;”2.611111111111111in”}据集市层）、APP（应用层）。\n1）ODS 层：\n为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。一般来说\nODS层的数据和源系统的数据是同构的，主要目的是简化后续数据加工处理的工作。从数\n据粒度上来说 ODS 层的数据粒度是最细的。ODS层的表通常包括两类，一个用于存储当前需要加载的数据，一个用于存储处理完后的历史数据。历史数据一般保存3-6个月后需要清除，以节省空间。但不同的项目要区别对待，如果源系统的数据量不大，可以保留更长的时间，甚至全量保存；\n2）PDW 层：\n为数据仓库层，PDW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。这一层的数据一般是遵循数据库第三范式的，其数据粒度通常和ODS 的粒度相同。在 PDW 层会保存 BI 系统中所有的历史数据，例如保存10年的数据。\n3）DM 层：\n为数据集市层，这层数据是面向主题来组织数据的，通常是星形或雪花结构的数据。从\n数据粒度来说，这层的数据是轻度汇总级的数据，已经不存在明细数据了。从数据的时间跨度来说，通常是PDW层的一部分，主要的目的是为了满足用户分析的需求，而从分析的角度来说，用户通常只需要分析近几年（如近三年的数据）的即可。从数据的广度来说，仍然覆盖了所有业务数据。\n4）APP 层：\n为应用层，这层数据是完全为了满足具体的分析需求而构建的数据，也是星形或雪花结构的数据。从数据粒度来说是高度汇总的数据。从数据的广度来说，则并不一定会覆盖所有业务数据，而是DM 层数据的一个真子集，从某种意义上来说是 DM层数据的一个重复。从极端情况来说，可以为每一张报表在 APP层构建一个模型来支持，达到以空间换时间的目的。\n数据仓库的标准分层只是一个建议性质的标准，实际实施时需要根据实际情况确定数据仓库的分层，不同类型的数据也可能采取不同的分层方法。\n11.6.2 为什么要对数据仓库分层？1）用空间换时间，通过大量的预处理来提升应用系统的用户体验（效率），因此数据\n仓库会存在大量冗余的数据。\n2）如果不分层的话，如果源业务系统的业务规则发生变化将会影响整个数据清洗过程，\n工作量巨大。\n3）通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。\n11.7 元数据介绍 当需要了解某地企业及其提供的服务时，电话黄页的重要性就体现出来了。元数据（Metadata）类似于这样的电话黄页。\n\n元数据的定义\n\n数据仓库的元数据是关于数据仓库中数据的数据。\n它的作用类似于数据库管理系统的数据字典，保存了逻辑数据结构、文件、地址和索引等信息。广义上讲，在数据仓库中，元数据描述了数据仓库内数据的结构和建立方法的数据。元数据是数据仓库管理系统的重要组成部分，元数据管理器是企业级数据仓库中的关键组件，贯穿数据仓库构建的整个过程，直接影响着数据仓库的构建、使用和维护。\n（1）构建数据仓库的主要步骤之一是ETL。这时元数据将发挥重要的作用，它定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、\n数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。\n（2）用户在使用数据仓库时，通过元数据访问数据，明确数据项的含义以及定制报表。\n（3）数据仓库的规模及其复杂性离不开[正确的元数据管理]{.underline}，包括增加或移除外部数据\n源，改变数据清洗方法，控制出错的查询以及安排备份等。\n元数据可分为技术元数据和业务元数据。\n技术元数据为开发和管理数据仓库的 IT人员使用，它描述了与数据仓库开发、管理和维护相关的数据，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等。\n而业务元数据为管理层和业务分析人员服务，从业务角度描述数据，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用。\n由上可见，元数据不仅定义了数据仓库中数据的模式、来源、抽取和转换规则等，而且是整个[数据仓库系统运行的基础]{.underline}，元数据把数据仓库系统中[各个松散的组件联系]{.underline}起来，组成{width&#x3D;”4.618055555555555in”height&#x3D;”2.9270833333333335in”}了一个有机的整体，如图所示\n2）元数据的存储方式\n元数据有两种常见存储方式：一种是以数据集为基础，每一个数据集有对应的元数据文件，每一个元数据文件包含对应数据集的元数据内容；另一种存储方式是以数据库为基础，即元数据库。其中元数据文件由若干项组成，每一项表示元数据的一个要素，每条记录为数据集的元数据内容。\n上述存储方式各有优缺点，\n第一种存储方式的优点是调用数据时相应的元数据也作为一个独立的文件被传输，相对数据库有较强的独立性，在对元数据进行检索时可以利用数据库的功能实现，也可以把元数据文件调到其他数据库系统中操作；不足是如果每一数据集都对应一个元数据文档，在规模巨大的数据库中则会有大量的元数据文件，管理不方便。\n第二种存储方式下，元数据库中只有一个元数据文件，管理比较方便，添加或删除数据集，只要在该文件中添加或删除相应的记录项即可。在[获取某数据集的元数据时，因为实际得到的只是关系表格数据的一条记录，所以要求用户系统可以接受这种特定形式的数据]{.underline}。因此**[推荐]{.underline}**使用元数据库的方式。元数据库用于[存储]{.underline}元数据，因此元数据库最好选用主流的关系数据库管理系统。元数据库还包含用于操作和查询元数据的机制。建立元数据库的主要好处是提供统一的数据结构和业务规则，易于把企业内部的多个数据集市有机地集成起来。目前，一些企业倾向建立多个数据集市，而不是一个集中的数据仓库，这时可以考虑在建立数据仓库（或数据集市）之前，先建立一个用于描述数据、服务应用集成的元数据库，做好数据仓库实施的初期支持工作，对后续开发和维护有很大的帮助。元数据库保证了数据仓库数据的一致性和准确性，为企业进行数据质量管理提供基础。\n3）元数据的作用\n在数据仓库中，元数据的主要作用如下。\n（1）描述哪些数据在数据仓库中，帮助决策分析者对数据仓库的内容定位。\n（2）定义数据进入数据仓库的方式，作为[数据汇总、映射和清洗的指南。]{.underline}\n（3）记录[业务事件发生而随之进行]{.underline}的[数据抽取工作时间安排]{.underline}。\n（4）记录并检测系统数据一致性的要求和执行情况。\n（5）评估数据质量。\n11.8 星型模型和雪花模型 在多维分析的商业智能解决方案中，根据事实表和维度表的关系，又可将常见的模型分为星型模型和雪花型模型。在设计逻辑型数据的模型的时候，就应考虑数据是按照星型模型还是雪花型模型进行组织。\n11.8.1 星型模型当所有维表都直接连接到”事实表”上时，整个图解就像星星一样，故将该模型称为星型模型。\n{width&#x3D;”6.5in”height&#x3D;”3.582638888888889in”}星型架构是一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度，所以数据有一定的冗余，如在地域维度表中，存在国家A省B的城市C以及国家A 省 B 的城市 D 两条记录，那么[国家 A 和省 B的信息分别存储了两次，即存在冗余。]{.underline}\n11.8.2 雪花模型当有一个或多个维表没有直接连接到事实表上，而是通过其他维表连接到事实表上时，其图解就像多个雪花连接在一起，故称雪花模型。雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的&quot;层次&quot;区域，这些被分解的表都连接到主维度表而不是事实表。如图所示，将地域维表又分解为国家，省份，城市等维表。它的优点是：通过最大限度地减少数据存储量以及联合较小的维表来改善查询性能。雪花型结构去除了数据冗余。\n{width&#x3D;”6.5in”height&#x3D;”3.3270833333333334in”}\n星型模型因为数据的冗余所以很多统计查询不需要做外部的连接，因此一般情况下效率比雪花型模型要高。星型结构不用考虑很多正规化的因素，设计与实现都比较简单。雪花型模型由于去除了冗余，有些统计就需要通过表的联接才能产生，所以效率不一定有星型模型高。正规化也是一种比较复杂的过程，相应的数据库结构设计、数据的ETL、以及后期的维护都要复杂一些。\n因此在冗余可以接受的前提下，实际运用中星型模型使用更多，也更有效率。\n11.8.3 星型模型和雪花模型对比星形模型和雪花模型是数据仓库中常用到的两种方式，而它们之间的对比要从四个角度来进行讨论。\n1）数据优化\n雪花模型使用的是规范化数据，也就是说数据在数据库内部是组织好的，以便消除冗余，因此它能够有效地减少数据量。通过引用完整性，其业务层级和维度都将存储在数据模型之中。\n{width&#x3D;”7.094444444444444in”height&#x3D;”1.5833333333333333in”}\n雪花模型\n相比较而言，星形模型使用的是反规范化数据。在星形模型中，维度直接指的是事实{width&#x3D;”4.426388888888889in”height&#x3D;”1.2555555555555555in”}表，业务层级不会通过维度之间的参照完整性来部署。\n星形模型\n2）业务模型\n主键是一个单独的唯一键(数据属性)，为特殊数据所选择。在上面的例子中，Advertiser_ID就将是一个主键。外键(参考属性)仅仅是一个表中的字段，用来匹配其他维度表中的主键。在我们所引用的例子中，Advertiser_ID将是 Account_dimension 的一个外键。在雪花模型中，数据模型的业务层级是由一个不同维度表主键-外键的关系来代表的。而在星形模型中，所有必要的维度表在事实表中都只拥有外键。\n3）性能\n第三个区别在于性能的不同。雪花模型在维度表、事实表之间的连接很多，因此性能方面会比较低。举个例子，如果你想要知道Advertiser 的详细信息，雪花模型就会请求许多信息，比如 AdvertiserName、ID以及那些广告主和客户表的地址需要连接起来，然后再与事实表连接。而星形模型的连接就少的多，在这个模型中，如果你需要上述信息，你只要将Advertiser的维度表和事实表连接即可。\n4）ETL\n雪花模型加载数据集市，因此 ETL操作在设计上更加复杂，而且由于附属模型的限制，不能并行化。星形模型加载维度表，不需要在维度之间添加附属模型，因此 ETL就相对简单，而且可以实现高度的并行化。\n总结\n雪花模型使得维度分析（多维、复杂关系）更加容易，比如”针对特定的广告主，有哪些客户或者公司是在线的?”星形模型用来做指标分析（单维）更适合，比如”给定的一个客户他们的收入是多少?”\nHive项目: Youtube_TopN查询一、需求描述 统计Youtube视频网站的常规指标，各种TopN指标：\n--统计视频观看数Top10\n--统计视频类别热度Top10\n--统计视频观看数Top20所属类别包含这Top20视频的个数\n--统计视频观看数Top50所关联视频的所属类别Rank\n--统计每个类别中的视频热度Top10\n--统计每个类别中视频流量Top10\n--统计上传视频最多的用户Top10以及他们上传的视频\n--统计每个类别视频观看数Top10\n二、知识储备梳理2.1 UDAF行转列行转列\nMySQL：group_concat\n虚拟机设置：处理器：虚拟化引擎：选中”虚拟化Intel VT-x&#x2F;EPT或AMD-V&#x2F;RVI(V)”\n能加快集群运行速度\n启动hadoop\nhive\n找不到metastore\nroot\ncentos6: service mysqld restart\ncentos7: systemctl restart mysqld.service\n.tsv &#x2F;t分割 excel可以直接可以打开\n.csv ,分割\n把星座和血型一样的人归类到一起\nselect\nt1.base,\nconcat_ws(&#39;|&#39;, collect_set(t1.name)) name\nfrom\n(select\n\n\n\n\n\n\n\n\n\nname,\nconcat(constellation, &quot;,&quot;, blood_type) base\nfrom\n\n\n\n\n\n\n\n\n\nperson_info) t1\ngroup by\nt1.base;\n白羊座，A 猪八戒|孙悟空\n聚合函数 concat_ws(&#39;|&#39;, collect_set(column1)) name\nselect\n条件列\nconcat_ws(&#39;|&#39;, collect_set(别的列)) 别名\nfrom\n…\nGroup by\n条件列\n见Hive7.2：当 Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-definedfunction）。\n3）根据用户自定义函数类别分为以下三种：\n（1）UDF（User-Defined-Function）\n一进一出\n（2）UDAF（User-Defined Aggregation Function） collect_set\n聚集函数，多进一出 处理多列\n类似于：count&#x2F;max&#x2F;min\n（3）UDTF（User-Defined Table-Generating Functions）\n一进多出\n如 lateral view explore()\n4）官方文档地址\nhttps://cwiki.apache.org/confluence/display/Hive/HivePlugins\n5）编程步骤：\n（1）继承 org.apache.hadoop.hive.ql.UDF\n（2）需要实现 evaluate 函数；evaluate 函数支持重载；\n（3）在 hive 的命令行窗口创建函数\na）添加 jar\nadd jar linux_jar_path\nb）创建 function， 永久函数注册进MySQL元数据信息里\ncreate [temporary] function [dbname.]function_name ASclass_name;jar包全类名\n（4）在 hive 的命令行窗口删除函数\nDrop [temporary] function [if exists] [dbname.]function_name;\n6）注意事项\n（1）UDF 必须要有返回类型，可以返回 null，但是返回类型不能为 void；\n7.3 自定义 UDF 函数开发案例\n1）创建一个 java 工程，并创建一个 lib 文件夹\n2）将 hive 的 jar 包解压后，将 apache-hive-1.2.1-bin\\lib 文件下的 jar包都拷贝到 java 工程中。\n3）创建一个类\npackage com.atguigu.hive;\nimport org.apache.hadoop.hive.ql.exec.UDF;\npublic class Lower extends UDF {\npublic String evaluate (final String s) {\nif (s &#x3D;&#x3D; null) {\nreturn null;\n}\nreturn s.toString().toLowerCase();\n}\n}\n4）打成 jar 包上传到服务器&#x2F;opt&#x2F;module&#x2F;jars&#x2F;udf.jar\n5）将 jar 包添加到 hive 的 classpath\nhive (default)&gt; add jar &#x2F;opt&#x2F;module&#x2F;datas&#x2F;udf.jar;\n6）创建临时函数与开发好的 java class 关联\nhive (default)&gt; create temporary function my_lower as&quot;com.atguigu.hive.Lower&quot;;\n7）即可在 hql 中使用自定义的函数 strip\nhive (default)&gt; select ename, my_lower(ename) lowername fromemp;\n2.2 UDTF列转行{width&#x3D;”5.768055555555556in”height&#x3D;”1.2277777777777779in”}\ncreate table movie_info(\nmovie string,\ncategory array&lt;string&gt;)\nrow format delimited fields terminated by &quot;\\t&quot;\ncollection items terminated by &quot;,&quot;;\nload data local inpath &quot;movie_info.tsv&quot; into table movie_info;\n将电影分类中的数组数据展开\nselect\nmovie,\ncategory_name\nfrom\nmovie_info lateral view explode(category) table_tmp as category_name;\nlateral侧写\nUDTF：explode(array&lt;&gt;)\nTable1 lateral view explode(column1 array&lt;&gt;) table2 as column2\n2.3、数组操作“fields terminated by”：字段与字段之间的分隔符。\n“collection items terminated by”：一个字段中各个子元素item的分隔符。\n行存储转列存储转的是元数据 建索引\n2.5、Hive分桶分区New dir&#x2F;file namenode增大\nHive可以将表或者表的分区进一步组织成桶，以达到：\n1、数据取样效率更高\n2、数据处理效率更高\n桶通过对指定列进行哈希来实现，将一个列名下的数据切分为”一组桶”，每个桶都对应了一个该列名下的一个存储文件。\n2.5.1、直接分桶开始操作之前，需要将hive.enforce.bucketing属性设置为true，以标识Hive可以识别桶。\ncreate table music(\nid int,\nname string,\nsize float)\nrow format delimited\nfields terminated by &quot;\\t&quot;\nclustered by (id) into 4 buckets;\n将music表按照id将数据分成了4个桶，插入数据时，会对应4个reduce操作，输出4个文件。\nId.hash%4\nHashcode:hash+equal\nSet Map.key array index+datatype ???????????????????\n2.5.2、在分区中分桶当数据量过大，需要庞大分区数量时，可以考虑桶，因为分区数量太大的情况可能会导致文件系统挂掉，而且桶比分区有更高的查询效率。数据最终落在哪一个桶里，取决于clusteredby的那个列的值的hash数与桶的个数求余来决定。虽然有一定离散性，但不能保证每个桶中的数据量是一样的。\ncreate table music2(\nid int,\nname string,\nsize float)\npartitioned by (date string)\nclustered by (id) sorted by(size) into 4 bucket\nrow format delimited 两句话！！！！！！\nfields terminated by &quot;\\t&quot;;\nload data local inpath &#39;demo&#x2F;music.txt&#39; into table music2partition(date&#x3D;&#39;2017-08-30&#39;);\n3.6、业务分析3.6.4、统计视频观看数 Top50 所关联视频的所属类别的热度排名（最难）思路：\n1) 查询出观看数最多的前 50个视频的所有信息(当然包含了每个视频对应的关联视频)，记\n为临时表 t1\nt1:观看数前 50 的视频\nselect\n* relatedId\nfrom\nyoutube_orc\norder by\nviews\ndesc\nlimit 50;\n2) 将找到的 50 条视频信息的相关视频 relatedId 列转行，记为临时表 t2\nt2:将相关视频的 id 进行列转行操作\nselect\nexplode(relatedId) as videoId\nfrom t1;\n3) 将相关视频的 id 和 youtube_orc 表进行 inner join 操作\nt5:得到两列数据，一列是 category，一列是之前查询出来的相关视频 id\n(select\ndistinct(t2.videoId),\nt3.category\nfrom\nt2 inner join youtube_orc t3 on t2.videoId &#x3D; t3.videoId)\nt4 lateral view explode(category) t_catetory as category_name;\n4) 按照视频类别进行分组，统计(类别热度:)每组视频个数，然后排行\n最终代码：\nselect category_name as category, count(t5.videoId) as hot\nfrom (\nselect videoId, category_name\nfrom (\n\n\n\n\n\n\n\n\n\nselect distinct(t2.videoId), t3.category\nfrom (\nselect explode(relatedId) as videoId\nfrom ( select * relatedId from youtube_orc order by views desc limit50) t1\n) t2 inner join youtube_orc t3 on t2.videoId &#x3D; t3.videoId\n) t4 lateral view explode(category) t_category as category_name\n) t5\ngroup by category_name\norder by hot desc;\nSqoop一、Sqoop 简介 Apache Sqoop(TM)是一种旨在有效地在 Apache Hadoop和诸如关系数据库等结构化数据存\n储之间传输大量数据的工具。\nSqoop 于 2012 年 3 月孵化出来，现在是一个顶级的 Apache 项目。\n最新的稳定版本是 1.4.6。Sqoop2 的最新版本是 1.99.7。请注意，1.99.7 与1.4.6 不兼容，且没有特征不完整，它并不打算用于生产部署。\n二、Sqoop 原理 将导入或导出命令翻译成 mapreduce 程序来实现。\n在翻译出的 mapreduce 中主要是对 inputformat 和 outputformat 进行定制。\nFlume一、Flume 简介 1) Flume提供一个[分布式的，可靠的]{.underline}，对[大数据量的日志进行高效收集、聚集、移动]{.underline}的服务，Flume只能在 Unix 环境下运行。\n2) Flume 基于流式架构，容错性强，也很灵活简单。\n3) Flume、Kafka 用来实时进行数据收集，Spark、Storm用来实时处理数据，impala 用来实时查询。\ndata传输效率70M&#x2F;s以下，data请求次数25w-50w QPS以内可靠，or大量丢包改源码定制\n实时抽取本地磁盘数据，传到HDFS\n内存数据写入kafka集群（端口），分发到HDFS\n过程中.tmp\n后数据分析：Spark（在线），MR，Hive（离线）\nresult--&gt;hbase,RDBMS\nFlume不擅长处理单个大文件channel.capacity（几十G蓝光电影…），而擅长处理大量小文件。\n二、Flume 角色 {width&#x3D;”4.311321084864392in”height&#x3D;”1.6793886701662293in”}\n一个agent是一个flume job的实例化，一个JVM进程。\n2.1、Source用于采集数据，Source 是产生数据流的地方，同时 Source会将产生的数据流传输到 Channel，\n这个有点类似于 Java IO 部分的 Channel。\n2.2、Channel用于桥接 Sources 和 Sinks，类似于一个队列。 Memory 快，大点（会GC）&#x2F;File\n2.3、Sink从 Channel 收集数据，将数据写到目标源(可以是下一个 Source，也可以是 HDFS或者 HBase)。 复制+分发+LB（1--&gt; 多）\n2.4、Event传输单元，Flume 数据传输的基本单元，以事件的形式将数据从源头送至目的地。\n业务模型：Setting multi-agent flow\nConsolidation\n{width&#x3D;”6.5in”height&#x3D;”4.465972222222222in”}\n场景：适合同一业务不同机器，同样的数据结构的文件\nMultiplexing the flow\n{width&#x3D;”5.632075678040245in”height&#x3D;”3.4598753280839896in”}\nChannel:Sink&#x3D;1:1\n场景：data实时运算，存到HDFS备份ori，+（Flume）+Kafka+Spark只存结果。之后离线校验ori。\n三、Flume 传输过程 source监控某个文件或数据流，数据源产生新的数据，拿到该数据后，将数据封装在一个Event中，并 put 到 channel 后 commit 提交，channel 队列先进先出，sink 去channel 队列中拉取数据，然后写入到 HDFS 中。\n4.2.2、案例二：实时读取本地文件到 HDFS\n4.2.4、案例四：Flume 与 Flume 之间数据传递：单 Flume 多Channel、Sink，\n4.2.5、案例五：Flume 与 Flume 之间数据传递，多 Flume汇总数据到单 Flume\nFlume 监控之 Ganglia Kafka一 Kafka概述1.1 Kafka是什么在流式计算中，Kafka一般用来缓存数据，Storm通过消费Kafka的数据进行计算。\n1）ApacheKafka是一个开源消息系统，由Scala写成。是由Apache软件基金会开发的一个开源消息系统项目。\n2）Kafka最初是由LinkedIn公司开发，并于 2011年初开源。2012年10月从ApacheIncubator毕业。该项目的目标是为处理实时数据提供一个统一、高通量、低等待的平台。\n3）Kafka是一个分布式消息队列。Kafka对消息保存时[根据Topic进行归类]{.underline}，发送消息者称为Producer，消息接受者称为Consumer，此外kafka集群由多个kafka实例组成，每个实例(server)称为broker。\n4）无论是kafka集群，还是producer和consumer都依赖于[zookeeper集群(3~5台，统一化目录结构&#x3D;&#x3D;百度网盘，大量网络IO，need开网络监控)]{.underline}保存一些[meta信息]{.underline}，来保证系统可用性。\n1.2 消息队列内部实现原理（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）\n点对点模型通常是一个基于pull[拉取或者轮询poll]{.underline}的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被一个且只有一个接收者接收处理，即使有多个消息监听者也是如此。\n（2）发布&#x2F;订阅模式（一对多，数据生产后，推送给所有订阅者）\n发布订阅模型则是一个基于推送push的消息传送模型。发布订阅模型可以有[多种不同topic]{.underline}的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，即使当前订阅者不可用，处于离线状态。\n1.3 为什么需要消息队列1）解耦：\n　　允许你独立的扩展或修改定制两边的处理过程，只要确保它们遵守同样的接口约束。\n2）冗余：\n消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式[规避了数据丢失风险]{.underline}。许多消息队列所采用的&quot;插入-获取-删除&quot;范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。\n3）扩展性：\n因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。\n4）灵活性 &amp; 峰值处理能力：\n在访问量剧增的情况下，应用仍然需要继续发挥作用，但是[这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费]{.underline}。使用消息队列能够[使关键组件顶住突发的访问压力]{.underline}，而[不会因为突发的超负荷的请求而完全崩溃]{.underline}。Buffer\n5）可恢复性：\n系统的一部分组件失效时，[不会影响到整个系统]{.underline}。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。\n6）顺序保证：\n在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka保证一个Partition内的消息的有序性）\n7）缓冲：\n有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。\n8）异步通信：\n很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并[不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。]{.underline}\n1.4 Kafka架构1）Producer ：消息生产者，就是向kafka broker发消息的客户端。\n2）Consumer ：消息消费者，向kafka broker取消息的客户端\n3）Topic ：可以理解为一个队列。\n4） Consumer Group（CG）：这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个（不重复消费）consumer）的手段。一个topic可以有多个CG。topic的消息会复制-给consumer。如果需要实现[广播，只要每个consumer有一个独立的CG]{.underline}就可以了。要实现[单播只要所有的consumer在同一个CG]{.underline}。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。\n同一个CG里同时只有一个Consumer消费；不重复消费独立广播；一个分区数据只交给一个consumer\nFollower不暴露，只用于备份，高可用\nZK 一致性: followerLeader（保存Kafka brokerstatus心跳），（保存consumer消费信息：offset）\n5）Broker：一台kafka服务器就是一个broker。一个集群由多个broker组成。[一个broker可以容纳多个topic。]{.underline}\n6）Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka[只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序]{.underline}。\n7）Offset（紫线）：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然thefirst offset就是00000000000.kafka\n流式计算，默认缓存7天实际**[数据是存在logs&#x2F;【offsetNum】.log文件]{.underline}**里的\n1.5 分布式模型分布式共有：\n同一个Kafka集群\n拥有同一个Topic里多分区\n不同的数据不同的分区\nKafka每个主题的多个分区日志分布式地存储在Kafka集群上，同时为了故障容错，每个分区都会以副本的方式复制到多个消息代理节点上。其中一个节点会作为主副本（Leader），其他节点作为备份副本（Follower，也叫作从副本）。主副本会负责所有的客户端读写操作，备份副本仅仅从主副本同步数据。当主副本出现故障时，备份副本中的一个副本会被选择为新的主副本。因为每个分区的副本中只有主副本接受读写，所以每个服务器端都会作为某些分区的主副本，以及另外一些分区的备份副本，这样Kafka集群的所有服务端整体上对客户端是负载均衡的。\nKafka的生产者和消费者相对于服务器端而言都是客户端。\nKafka生产者客户端发布消息到服务端的指定主题，会指定消息所属的分区。生产者发布消息时根据消息是否有键，采用不同的分区策略。[消息没有键时，通过轮询方式进行客户端负载均衡；消息有键时，根据分区语义（例如hash）确保相同键的消息总是发送到同一分区。]{.underline}\nKafka的消费者通过订阅主题来消费消息，并且每个消费者都会设置一个消费组名称。因为生产者发布到主题的每一条消息都只会发送给消费者组的一个消费者。所以，如果要实现传统消息系统的”队列”模型，可以让每个消费者都拥有相同的消费组名称，这样消息就会负责均衡到所有的消费者同组顺序单播；如果要实现”发布-订阅”模型，则每个消费者的消费者组名称都不相同，这样每条消息就会广播给所有的消费者。\n分区是消费者现场模型的最小并行单位。如下图（图1）所示，生产者发布消息到一台服务器的3个分区时，只有一个消费者消费所有的3个分区。在下图（图2）中，3个分区分布在3台服务器上，同时有3个消费者分别消费不同的分区。假设每个服务器的吞吐量是300MB，在下图（图1）中分摊到每个分区只有100MB，而在下图（图2）中，集群整体的吞吐量有900MB。可以看到，[增加服务器节点会提升集群的性能（吞吐量），增加消费者数量会提升处理性能。]{.underline}\n同一个消费组下多个消费者互相协调消费工作，Kafka会将所有的分区平均地分配给所有的消费者实例，这样每个消费者都可以分配到数量均等的分区。Kafka的[消费组管理协议会动态地维护消费组的成员列表，当一个新消费者加入消费者组，或者有消费者离开消费组，都会触发再平衡操作。]{.underline}\n{width&#x3D;”3.3854166666666665in”height&#x3D;”3.7395833333333335in”}\n图12:LB网络与磁盘IO，提高吞吐量（横向扩展），独立CG广播：同topic不同用途\nKafka的消费者消费消息时，[只保证在一个分区内的消息的完全有序性，并不保证同一个主题汇总多个分区的消息顺序]{.underline}。而且，消费者读取一个分区消息的顺序和生产者写入到这个分区的顺序是一致的。比如，生产者写入”hello”和”Kafka”两条消息到分区P1，则消费者读取到的顺序也一定是”hello”和”Kafka”。如果业务上需要保证所有消息完全一致，只能通过设置一个分区完成，但这种做法的缺点是最多只能有一个消费者进行消费。一般来说，只需要保证每个分区的有序性，再对消息假设键来保证相同键的所有消息落入同一分区，就可以满足绝大多数的应用。\n设计代码：自定义分区规则；设计key；暴力指定分区号\n三 Kafka工作流程分析3.1 Kafka生产过程分析3.1.1 写入方式**集群最低要求：Disk转速&gt;&#x3D;7200转&#x2F;s，400~500M&#x2F;s RW效率 **\nproducer采用推（push）模式将消息发布到broker，每条消息都被追加（append）到分区（patition）中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障kafka吞吐率）。\nKafka&#x2F;logs&#x2F;topic-012partition，1个partition1个folder\n.log序列化文件\nKafka内嵌编解码器（反）序列化器：SerializerEncoder SerializerDecoder\n3.1.2 分区（Partition）！！！！！！！！！！！Kafka集群有多个消息代理服务器（broker-server）组成，发布到Kafka集群的每条消息都有一个类别，用主题（topic）来表示。通常，不同应用产生不同类型的数据，可以设置不同的主题。一个主题一般会有多个消息的订阅者，当生产者发布消息到某个主题时，订阅了这个主题的消费者都可以接收到生成者写入的新消息。\nKafka集群为每个主题维护了分布式的分区（partition）日志文件，物理意义上可以把主题（topic）看作进行了分区的日志文件（partitionlog）offset.log。主题的每个分区都是一个有序的、不可变的记录序列，新的消息会不断追加到日志中。分区中的每条消息都会按照时间顺序分配到一个单调递增的顺序编号，叫做偏移量（offset），这个偏移量能够唯一地定位当前分区中的每一条消息。\n消息发送时都被发送到一个topic，其本质就是一个目录，而topic是由一些PartitionLogs(分区日志)组成，其组织结构如下图所示：\n下图中的topic有3个分区，每个分区的偏移量都从0开始，不同分区之间的偏移量都是独立的，不会相互影响。\n\n\n不标记data为已消费，消费完删除，activeMQ会mark\nReach time&#x2F;space清理阈值，即使没consume，也删除：加快内部data管理效率\noffset由ZK、consumer自己管理\n4个方法重载，params：\nKey 默认”a”.hash%partition LB,\npartition未指定：轮询auto-LB 0开始，一旦指定key就没意义了,\nvalue\n我们可以看到，每个Partition中的消息都是有序的，生产的消息被不断追加到Partitionlog上，其中的每一个消息都被赋予了一个唯一的offset值。Offset.log\n发布到Kafka主题的每条[消息包括键值和时间戳]{.underline}。消息到达服务器端的指定分区后，都会[分配]{.underline}到一个[自增的偏移量]{.underline}。原始的[消息内容和分配的偏移量以及其他一些元数据信息]{.underline}最后**[都会]{.underline}**存储到[分区日志文件中]{.underline}。消息的键也可以不用设置，这种情况下消息会均衡地分布到不同的分区。\n\n分区的原因\n\n（1）方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；\n（2）可以提高并发，因为可以以Partition为单位读写了。\n传统消息系统在服务端保持消息的顺序，如果有多个消费者消费同一个消息队列，服务端会以消费存储的顺序依次发送给消费者。但由于消息是异步发送给消费者的，消息到达消费者的顺序可能是无序的，这就意味着在并行消费时，传统消息系统无法很好地保证消息被顺序处理。虽然我们可以设置一个专用的消费者只消费一个队列，以此来解决消息顺序的问题，但是这就使得消费处理无法真正执行。\nKafka比传统消息系统有更强的顺序性保证，它使用主题的分区作为消息处理的并行单元。Kafka以分区作为最小的粒度，将每个分区分配给消费者组中不同的而且是唯一的消费者，并确保一个分区只属于一个消费者，即这个消费者就是这个分区的唯一读取线程。那么，只要分区的消息是有序的，消费者处理的消息顺序就有保证。每个主题有多个分区，不同的消费者处理不同的分区，所以Kafka不仅保证了消息的有序性，也做到了消费者的负载均衡。\n2）分区的原则\n（1）指定了patition，则直接使用；\n（2）未指定patition但指定key，通过对key的value进行hash出一个patition\n（3）patition和key都未指定，使用轮询选出一个patition。\n+———————————————————————–+| DefaultPartitioner类 kafka.0.11版本                               ||                                                                       || public int partition(String topic, Object key, byte[]   || keyBytes, Object value, byte[] valueBytes, Cluster cluster) {   ||                                                                       || List&lt;PartitionInfo&gt; partitions &#x3D; cluster.partitionsForTopic(topic); ||                                                                       || int numPartitions &#x3D; partitions.size();                            ||                                                                       || if (keyBytes &#x3D;&#x3D; null) {                                       ||                                                                       || int nextValue &#x3D; nextValue(topic);                                 ||                                                                       || List&lt;PartitionInfo&gt; availablePartitions &#x3D;                           || cluster.availablePartitionsForTopic(topic);                           ||                                                                       || if (availablePartitions.size() &gt; 0) {                            ||                                                                       || int part &#x3D; Utils.toPositive(nextValue) %                        || availablePartitions.size();                                           ||                                                                       || return availablePartitions.get(part).partition();                 ||                                                                       || } else { &#x2F;&#x2F;(3)                                                    ||                                                                       || &#x2F;&#x2F; no partitions are available, give a non-available partition        ||                                                                       || return Utils.toPositive(nextValue) % numPartitions;             ||                                                                       || }                                                                     ||                                                                       || } else { &#x2F;&#x2F;(2)                                                    ||                                                                       || &#x2F;&#x2F; hash the keyBytes to choose a partition                            ||                                                                       || return Utils.toPositive(Utils.murmur2(keyBytes)) %            || numPartitions;                                                        ||                                                                       || }                                                                     ||                                                                       || }&#x2F;&#x2F;？？？？？？？？???????????????????????????????????????????????    |+———————————————————————–+\n3.1.3 副本（Replication）同一个partition可能会有多个replication（对应 server.properties 配置中的default.replication.factor&#x3D;N）。没有replication的情况下，一旦broker宕机，其上所有 partition的数据都不可被消费，同时producer也不能再将数据存于其上的patition。引入replication之后，同一个partition可能会有多个replication，而这时需要在这些replication之间选出一个leader，producer和consumer只与这个leader交互，其它replication作为follower从leader中复制数据。\n3.1.4 写入流程 producer写入消息流程如下：\n1）producer先从zookeeper的&quot;&#x2F;brokers&#x2F;...&#x2F;state&quot;节点找到该partition的leader\n2）producer将消息发送给该leader\n3）leader将消息写入本地log\n4）followers从leader pull消息，写入本地log后向leader发送ACK\n5）leader[收到所有ISR中的replication的ACK后(对consumer才可见)]{.underline}，**[增加HW（highwatermark，最后commit 的offset）]{.underline}**并向producer发送ACK\n3.3 Kafka消费过程分析kafka提供了两套consumer API：高级Consumer API和低级API。\n3.3.1 消费模型消息由生产者发布到Kafka集群后，会被消费者消费。消息的消费模型有两种：推送模型（push）和拉取模型（pull）。\n基于推送模型（push）的消息系统，由消息代理记录消费者的消费状态。消息代理在将消息推送到消费者后，标记这条消息为已消费，但这种方式无法很好地保证消息被处理。比如，消息代理把消息发送出去后，当消费进程挂掉或者由于网络原因没有收到这条消息时，就有可能造成消息丢失（因为消息代理已经把这条消息标记为已消费了，但实际上这条消息并没有被实际处理）。如果要保证消息被处理，消息代理发送完消息后，要设置状态为”已发送”，只有[收到消费者的确认请求后才更新为”已消费”]{.underline}，这就需要[消息代理中记录所有的消费状态]{.underline}，这种做法显然是[不可取]{.underline}的。[填鸭式教育，速度不一致：data易丢失]{.underline}\nKafka采用拉取模型，由消费者自己记录消费状态，每个消费者互相独立地顺序读取每个分区的消息。如下图所示，有两个消费者（不同消费者组）拉取同一个主题的消息，消费者A的消费进度是3，消费者B的消费进度是6。[消费者拉取的最大上限通过最高水位（watermark）控制wait，生产者最新写入的消息如果还没有达到备份数量，对消费者是不可见的。]{.underline}这种由消费者控制偏移量的优点是：消费者可以按照任意的顺序消费消息。比如，消费者可以重置到旧的偏移量，重新处理之前已经消费过的消息；或者直接跳到最近的位置，从当前的时刻开始消费。[按需消费，主动获取]{.underline}\n{width&#x3D;”4.854166666666667in”height&#x3D;”1.5416666666666667in”}\n在一些消息系统中，消息代理会在消息[被消费之后立即删除消息]{.underline}。如果有不同类型的消费者订阅同一个主题，消息代理可能需要[冗余地存储同一消息；或者等所有消费者都消费完才删除]{.underline}，这就需要消息代理[跟踪每个消费者的消费状态]{.underline}，这种设计很大程度上[限制]{.underline}了消息系统的[整体吞吐量和处理延迟]{.underline}。Kafka的做法是生产者发布的所有消息会一致保存在Kafka集群中，不管消息有没有被消费。用户可以通过[设置保留时间来清理过期的数据]{.underline}，比如，设置保留策略为两天。那么，在消息发布之后，它可以被不同的消费者消费，在两天之后，过期的消息就会自动清理掉。\n3.3.2 高级API1）高级API优点\n高级API 写起来简单\n不需要自行去管理[offset，系统通过zookeeper自行管理。]{.underline}\n不需要管理分区，副本等情况，.系统自动管理。\n消费者断线会自动根据上一次记录在zookeeper中的offset去接着获取数据（默认设置1分钟更新一下zookeeper中存的offset）\n可以使用group来区分对同一个topic的不同程序访问分离开来（不同的group记录不同的offset，这样不同程序读取同一个topic才不会因为offset互相影响）\n2）高级API缺点\n不能自行控制[offset]{.underline}（对于某些特殊需求来说）\n不能细化控制如[分区、副本、zk等]{.underline}\n3.3.3 低级API1）低级 API 优点\n能够让开发者自己控制offset，想从哪里读取就从哪里读取。\n自行[控制连接分区，对分区自定义进行负载均衡]{.underline}\n对zookeeper的依赖性降低（如：[offset不一定非要靠zk存储，自行存储offset]{.underline}即可，比如[存在文件或者内存中]{.underline}）\n2）低级API缺点\n太过复杂，需要自行控制offset，连接哪个分区，找到分区leader 等。\n3.3.4 消费者组一个Consumer可订阅多个主题，Kafka streaming对bad topic做数据清洗\n消费者是以consumergroup消费者组的方式工作，由一个或者多个消费者组成一个组，共同消费一个topic。[每个分区在同一时间只能由group中的一个消费者读取]{.underline}，但是多个group可以同时消费这个partition。在图中，有一个由三个消费者组成的group，有一个消费者读取主题中的两个分区，另外两个分别读取一个分区。某个消费者[读取]{.underline}某个分区，也可以叫做某个消费者[是某个分区的拥有者]{.underline}。\n在这种情况下，消费者可以通过水平扩展的方式同时读取大量的消息。另外，如果一个消费者[失败]{.underline}了，那么[其他的group成员会自动负载均衡]{.underline}读取之前失败的消费者读取的分区。\n3.3.5 消费方式consumer采用pull（拉）模式从broker中读取数据。\npush（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是[拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费]{.underline}消息。\n对于Kafka而言，pull模式更合适，它可简化broker的设计，consumer可自主控制消费消息的[速率]{.underline}，同时consumer可以自己控制消费[方式]{.underline}——即[可批量消费也可逐条消费]{.underline}，同时还能[选择不同的提交方式从而实现不同的传输语义]{.underline}。\npull模式不足之处是，如果kafka[没有数据，消费者可能会陷入循环中，一直等待数据到达]{.underline}。为了避免这种情况，我们在我们的[拉请求中有参数，允许消费者请求在等待数据到达的”长轮询”中进行阻塞]{.underline}（并且[可选地等待到给定的字节数，以确保大的传输大小]{.underline}）。\n4.2.3 创建生产者带回调函数（新API）\n五 Kafka producer拦截器(interceptor)5.1 拦截器原理Producer拦截器(interceptor)是在Kafka0.10版本被引入的，主要用于实现clients端的定制化控制逻辑。\n对于producer而言，interceptor使得用户在消息发送前以及producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer允许用户指定多个interceptor按序作用于同一条消息从而形成一个（强依赖）拦截链(interceptorchain)。Intercetpor的实现接口是org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：\n（1）configure(configs)\n获取配置信息和初始化数据时调用。\n（2）onSend(ProducerRecord)：\n该方法封装进KafkaProducer.send方法中，即它运行在用户主线程中。Producer确保在消息[被序列化以及计算分区前调用]{.underline}该方法。用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区，否则会影响目标分区的计算\n（3）onAcknowledgement(RecordMetadata, Exception)：\n该方法会在消息被应答或消息发送失败时调用，并且通常都是[在producer回调逻辑触发之前]{.underline}。onAcknowledgement运行在[producer的IO线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢producer的消息发送效率]{.underline}\n（4）close：\n关闭interceptor，主要用于执行一些资源清理工作\n如前所述，interceptor可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外倘若指定了多个interceptor，则producer将按照指定顺序调用它们，并仅仅是捕获每个interceptor可能抛出的异常记录到错误日志中而[非再向上传递]{.underline}。这在使用过程中要特别留意。\n5.2 拦截器案例1）需求：\n实现一个简单的双interceptor组成的拦截链。第一个interceptor会在消息[发送前将时间戳信息加到消息value的最前部]{.underline}；第二个interceptor会在消息[发送后更新成功发送消息数或失败发送消息数]{.underline}。\n六 kafka Streams6.1 概述6.1.1 Kafka StreamsKafka Streams。ApacheKafka开源项目的一个组成部分。是一个功能强大，易于使用的库。用于在Kafka上构建高可分布式、拓展性，容错的应用程序。\n6.1.2 Kafka Streams特点1）功能强大 \n\n\n\n\n\n\n\n\n\n高扩展性，弹性，容错 \n2）轻量级 \n无需专门的集群 \n一个库，而不是框架\n3）完全集成 \n\n\n\n\n\n\n\n\n\n100%的Kafka 0.10.0版本兼容\n易于集成到现有的应用程序 \n4）实时性\n\n\n\n\n\n\n\n\n\n毫秒级延迟 \n并非微批处理 \n窗口允许乱序数据 \n允许迟到数据\n6.1.3 为什么要有Kafka Stream当前已经有非常多的流式处理系统，最知名且应用最多的[开源流式处理系统有SparkStreaming和Apache Storm。]{.underline}ApacheStorm发展多年，应用广泛，提供记录级别的处理能力，当前也支持SQL onStream。而Spark Streaming基于ApacheSpark，可以非常方便与图计算，SQL处理等集成，功能强大，对于熟悉其它Spark应用开发的用户而言使用门槛低。另外，目前主流的Hadoop发行版，如Cloudera和Hortonworks，都集成了ApacheStorm和Apache Spark，使得部署更容易。\n既然Apache Spark与Apache Storm拥有如此多的优势，那为何还需要KafkaStream呢？主要有如下原因。分担框架压力\n第一，Spark和Storm都是流式处理框架，而KafkaStream提供的是一个基于Kafka的流式处理类库。[框架要求开发者按照特定的方式去开发逻辑部分，供框架调用。开发者很难了解框架的具体运行方式，从而使得调试成本高，并且使用受限]{.underline}。而KafkaStream作为流式处理类库，直接[提供具体的类]{.underline}给开发者调用，整个应用的运行方式主要由开发者控制，方便使用和调试。\n\n第二，虽然Cloudera与Hortonworks方便了Storm和Spark的部署，但是这些框架的部署仍然相对复杂。而KafkaStream作为类库，可以非常方便的嵌入应用程序中，它对应用的打包和部署基本没有任何要求。\n第三，就流式处理系统而言，基本都支持Kafka作为数据源。例如Storm具有专门的kafka-spout，而Spark也提供专门的spark-streaming-kafka模块。事实上，[Kafka基本上是主流的流式处理系统的标准数据源]{.underline}。换言之，大部分流式系统中都已部署了Kafka，此时使用KafkaStream的成本非常低。\n第四，使用Storm或SparkStreaming时，需要[为框架本身的进程预留资源]{.underline}，如Storm的supervisor和Sparkon YARN的nodemanager。即使对于应用实例而言，框架本身也会占用部分资源，如SparkStreaming需要为shuffle和storage预留内存。但是[Kafka作为类库不占用系统资源。]{.underline}\n第五，由于Kafka本身提供数据持久化，因此KafkaStream提供[滚动部署和滚动升级以及重新计算]{.underline}的能力。\n第六，由于Kafka [Consumer Rebalance机制]{.underline}，KafkaStream可以在线动态调整并行度。\n6.2 Kafka Stream数据清洗案例HBase一、HBase 介绍 1.1、HBase 的起源HBase 的原型是 Google 的 BigTable 论文，受到了该论文思想的启发，目前作为Hadoop 的子项目来开发维护，用于支持结构化的数据存储。\n官方网站：http://hbase.apache.org\n-- 2006 年 Google 发表 BigTable 白皮书\n-- 2006 年开始开发 HBase\n-- 2008 年北京成功开奥运会，程序员默默地将 HBase 弄成了 Hadoop 的子项目\n-- 2010 年 HBase 成为 Apache 顶级项目\n-- 现在很多公司二次开发出了很多发行版本，你也开始使用了。\n1.2、HBase 的角色1.2.1、HMaster功能：\n1) 监控 RegionServer\n2) 处理 RegionServer 故障转移\n3) 处理元数据的变更\n4) 处理 region 的分配或移除\n5) 在空闲时间进行数据的负载均衡\n6) 通过 Zookeeper 发布自己的位置给客户端\n1.2.2、RegionServer功能：\n1) 负责存储 HBase 的实际数据\n2) 处理分配给它的 Region\n3) 刷新缓存（二级缓存：内存+disk缓存）到 HDFS\n4) 维护 HLog (学oracle)\n5) 执行压缩\n6) 负责处理 Region 分片\n组件：\n1) Write-Ahead logs （HLog）\nHBase 的修改记录，当对 HBase读写数据的时候，数据不是直接写进磁盘，它会在内存中保留一段时间（时间以及数据量阈值可以设定）。但[把数据保存在内存中可能有更高的概率引起数据丢失，为了解决这个问题，数据会先写在一个叫做Write-Ahead logfile的文件中，然后再写入内存中。]{.underline}所以在系统出现故障的时候，数据可以通过这个日志文件重建。\n2) HFile\n这是在磁盘上保存原始数据的实际的物理文件，是实际的存储文件。\n3) Store\nHFile 存储在 Store 中，一个 Store 对应 HBase 表中的一个列族。\n4) MemStore\n顾名思义，就是内存存储，位于内存中，用来保存当前的数据操作，所以当数据保存在WAL（HLog）中之后，RegionServer会在内存中存储键值对。\n5) Region\nHbase 表的分片，\nHBase 表会根据 RowKey 值被切分成不同的 region 存储在 RegionServer 中，\n在一个 RegionServer 中可以有多个不同的 region。\n1.3、HBase 的架构HBase 一种是[作为存储的分布式文件系统，另一种是作为数据处理模型的 MR框架]{.underline}。因为日常开发人员比较熟练的是结构化的数据进行处理，但是在HDFS 直接存储的文件往往不具有结构化，所以催生出了 HBase 在 HDFS上的操作。如果需要查询数据，只需要通过键值便可以成功访问。\n{width&#x3D;”6.170138888888889in”height&#x3D;”3.5909722222222222in”}架构图如下图所示：\n即时通信维持长连接：发心跳包 （2min30s2min50s刷服务器socket链接，无data就kill掉） 重启，HMaster重新负载\nHBase 内 置 有 Zookeeper ， 但 一 般 我 们 会 有 其 他 的 Zookeeper 集群 来 监 管 master 和regionserver，Zookeeper通过选举，保证任何时候，集群中只有一个活跃的 HMaster，HMaster与HRegionServer 启动时会向 ZooKeeper 注册，存储所有HRegion的寻址入口，实时监控[Hregionserver（服务，维护HRegion）的上线和下线]{.underline}信息。并实时通知给HMaster，存储 HBase 的 schema 和 table元数据，默认情况下，HBase 管理ZooKeeper 实例，Zookeeper 的引入使得 HMaster不再是单点故障。一般情况下会启动两个 HMaster，非 Active 的 HMaster会定期的和 ActiveHMaster通信以获取其最新状态，从而保证它是实时更新的，因而如果启动了多个HMaster 反而增加了 Active HMaster 的负担。\n一个 RegionServer 可以包含多个 HRegion，每个 RegionServer 维护一个Hlog(合并，溢写)，和多个 HFiles 以及其对应的MemStore（Store）。**[RegionServer 运行于 DataNode上]{.underline}**，数量可以与 DataNode 数量一致，\n{width&#x3D;”6.8519925634295715in”height&#x3D;”3.9569630358705163in”}请参考如下架构图：\nMemStore 内存缓存 LRUCache算法：用双链表维护对应访问关系\nregion&#x3D;&#x3D;table\nrowkey&#x3D;&#x3D;id\nstore&#x3D;列族\n写入MemStore+HLog 即成功 达到阈值到HFile（localdisk）--&gt;HDFS（HBase调HDFSClient API）\n保留HFile的metadata（哪个DataNode）\nHDFS支持随机读写的错觉\n等 批处理效率高\nHBase有多个Clients，一个集群。多region&#x3D;多业务tables\n{width&#x3D;”6.5in”height&#x3D;”4.587664041994751in”}\n2.2.2、表的操作1) 创建表 create ‘表名’，’列族(column family)名’\nhbase(main)&gt; create &#39;student&#39;,&#39;info&#39;\n{width&#x3D;”6.5in”height&#x3D;”3.629166666666667in”}\nhbase.put(rowkey[类似主键ID]:info[column family]:name[columnquality],nick[cell])\n可以没字段，动态创建字段。适合存储稀疏的非结构化数据（不适合数据分析，适合数据挖掘：logistic回归）\nHive：结构化数据\ntimestamp自带时间戳，维护不同版本（覆盖，默认对外展示latest，备份保留历史版&#x2F;副本）\n列族需要已存在！！！！！！if无，alter 加列族。\n2) 插入数据到表\nhbase(main) &gt; put &#39;student&#39;,&#39;1001&#39;,&#39;info:name&#39;,&#39;Thomas&#39;\ntable rowkey 列族:动态创建列 value\nhbase(main) &gt; put &#39;student&#39;,&#39;1001&#39;,&#39;info:sex&#39;,&#39;male&#39;\nhbase(main) &gt; put &#39;student&#39;,&#39;1001&#39;,&#39;info:age&#39;,&#39;18&#39;\nhbase(main) &gt; put &#39;student&#39;,&#39;1002&#39;,&#39;info:name&#39;,&#39;Janna&#39;\nhbase(main) &gt; put &#39;student&#39;,&#39;1002&#39;,&#39;info:sex&#39;,&#39;female&#39;\nhbase(main) &gt; put &#39;student&#39;,&#39;1002&#39;,&#39;info:age&#39;,&#39;20&#39;\n3) 扫描查看表数据\nhbase(main) &gt; scan &#39;student&#39;\nhbase(main) &gt; scan &#39;student&#39;,{STARTROW &#x3D;&gt; &#39;1001&#39;, STOPROW &#x3D;&gt;&#39;1001&#39;}\n字符按位比较 ac：ac e (有比没有大)\nhbase(main) &gt; scan &#39;student&#39;,{STARTROW &#x3D;&gt; &#39;1001&#39;}\ncolumn(qualify全列名)&#x3D;info:name\n4) 查看表结构\nhbase(main):012:0&gt; describe ‘student’\n5) 更新指定字段的数据\nhbase(main) &gt; put &#39;student&#39;,&#39;1001&#39;,&#39;info:name&#39;,&#39;Nick&#39;\nhbase(main) &gt; put &#39;student&#39;,&#39;1001&#39;,&#39;info:age&#39;,&#39;100&#39;\n6) 查看”指定行”或”指定列族**:**列”的数据\nhbase(main) &gt; get &#39;student&#39;,&#39;1001&#39;\nhbase(main) &gt; get &#39;student&#39;,&#39;1001&#39;,&#39;info:name&#39;\n7) 删除数据\n删除某 rowkey 的全部数据：\nhbase(main) &gt; deleteall &#39;student&#39;,&#39;1001&#39;\n删除某 rowkey 的某一列数据：\nhbase(main) &gt; delete &#39;student&#39;,&#39;1002&#39;,&#39;info:sex&#39;\n8) 清空表数据\nhbase(main) &gt; truncate &#39;student&#39;\n尖叫提示：清空表的操作顺序为先 disable，然后再 truncating。\n9) 删除表\n首先需要先让该表为 disable 状态：\nhbase(main) &gt; disable &#39;student&#39;\n然后才能 drop 这个表：\nhbase(main) &gt; drop &#39;student&#39;\n尖叫提示：如果直接 drop 表，会报错：Drop the named table. Table mustfirst be disabled ERROR: Table student is enabled. Disable it first.\n10) 统计表数据行数(rowkey)(hbase按列存储)\nhbase(main) &gt; count &#39;student&#39;\n11) 变更表信息\n将 info 列族中的数据存放 3 个版本：\nhbase(main) &gt; alter &#39;student&#39;,{NAME&#x3D;&gt;&#39;info&#39;,VERSIONS&#x3D;&gt;3}\n&#x3D;&gt;映射符\n-&gt;lambda\nMySQL：一个user对应一个schema（类似package，~：DB：tables）\n{width&#x3D;”4.583333333333333in”height&#x3D;”0.6979166666666666in”}\n1 table：n regions 大表切分\nHMaster主节点：负载低 可与NN等高消耗App开在一起\nNN不能同开：耗内存Spark\n2.3、读写流程 Client-&gt;ZK：(-ROOT- 不切分，对应一个region) -&gt;RegionServer(.META.可切分)-&gt;region 【元数据信息location】-&gt;Client\nClient-&gt;region:业务data scan table\nmemstore:存用户最近写入的数据\nblockcache：最近读取data LRUCache 读写分离\nHFile（从HDFS）读取完数据，缓存入blockcache\nHBase能存最多region个数：2^35\nlocation+ Index(range)\n{width&#x3D;”6.5in”height&#x3D;”2.8965277777777776in”}\nRW同时进行，冲突Compact\nn级索引：page_size^n\nHMaster：RegionServer故障转移（init时持有 -ROOT-、.META.表元数据信息(DataNode）），状态管理-&gt;ZK\n2.3.1、HBase 读数据流程1) HRegionServer 保存着 meta 表以及表数据，要访问表数据，首先 Client先去访问\nzookeeper，从 zookeeper 里面获取 meta 表所在的位置信息，即找到这个 meta表在哪个HRegionServer 上保存着。\n2) 接着 Client 通过刚才获取到的 HRegionServer 的 IP 来访问 Meta表所在的\nHRegionServer，从而读取到 Meta，进而获取到 Meta 表中存放的元数据。\n3) Client 通过元数据中存储的信息，访问对应的HRegionServer，然后扫描所在\nHRegionServer 的 Memstore 和 Storefile 来查询数据。\n4) 最后 HRegionServer 把查询到的数据响应给 Client。\n2.3.2、HBase 写数据流程1) Client 也是先访问 zookeeper，找到 Meta 表，并获取 Meta 表信息。\n2) 确定当前将要写入的数据所对应的 RegionServer 服务器和 Region。\n3) Client 向该 RegionServer 服务器发起写入数据请求，然后RegionServer 收到请求并响应。\n4) Client 先把数据写入到 Hlog（MySQL：binlog），以防止数据丢失。\n5) 然后将数据写入到 Memstore。\n6) 如果 Hlog 和 Memstore均写入成功，则这条数据写入成功。在此过程中，[如果Memstore达到阈值16KB，会把 Memstore 中的数据 flush 到 StoreFile 中。]{.underline}\n[flush:16KB满-&gt;BufferQueue缓存队列-&gt;HFile]{.underline}\n（NN环形缓冲区80%）保证写入和溢写同时进行。\n7) 当 Storefile 越来越多，会触发 Compact 合并操作，把过多的Storefile 合并成一个大的Storefile。当 Storefile 越来越大，Region也会越来越大，达到阈值后，会触发 Split 操作，将 Region 一分为二。\n表划分region：-∞~~+∞\nHDFS不能随机读写，只能：复制合并\nRegionServer-&gt;n threads:调用HDFS API（HFile）\n环境数组太小\nMemStore（Write）单例 memstore:HFile&#x3D;1:n，溢写完释放资源\n尖叫提示：因为内存空间是有限的，所以说溢写过程必定伴随着大量的小文件产生。\n2.6.1、HBase 与 Hive 的对比1) Hive\n(1) 数据仓库\nHive 的本质其实就相当于将 HDFS 中已经存储的文件在 Mysql中做了一个双射关系，以方\n便使用 HQL 去管理查询。\n(2) 用于数据分析、清洗\nHive 适用于离线的数据分析和清洗，延迟较高。\n(3) 基于 HDFS、MapReduce\nHive 存储的数据依旧在 DataNode 上，\n编写的 HQL 语句终将是转换为 MapReduce 代码执行。\n2) HBase\n(1) 数据库\n是一种面向列存储的非关系型数据库。\n(2) 用于存储结构化和非结构话的数据\n适用于单表非关系型数据的存储，不适合做关联查询，类似 JOIN 等操作。\n(3) 基于 HDFS\n数据持久化存储的体现形式是 Hfile，存放于 DataNode 中，被 ResionServer 以region 的形式进行管理。\n(4) 延迟较低，接入在线业务使用\n面对大量的企业数据，HBase可以直线单表大量数据的存储，同时提供了高效的数据访问速度。\nHBase 的优化 3.1、高可用 在 HBase 中 Hmaster 负责监控 RegionServer 的生命周期，均衡 RegionServer的负载，如果Hmaster 挂掉了，那么整个 HBase集群将陷入不健康的状态，并且此时的工作状态并不会维持太久。所以 HBase支持对 Hmaster 的高可用配置。\n1) 关闭 HBase 集群（如果没有开启则跳过此步）\n$ bin&#x2F;stop-hbase.sh\n2) 在 conf 目录下创建 backup-masters 文件\n$ touch conf&#x2F;backup-masters\n3) 在 backup-masters 文件中配置高可用 HMaster 节点\n$ echo linux02 &gt; conf&#x2F;backup-masters\n4) 将整个 conf 目录 scp 到其他节点\n$ scp -r conf&#x2F; linux02:&#x2F;opt&#x2F;modules&#x2F;cdh&#x2F;hbase-0.98.6-cdh5.3.6&#x2F;\n$ scp -r conf&#x2F; linux03:&#x2F;opt&#x2F;modules&#x2F;cdh&#x2F;hbase-0.98.6-cdh5.3.6&#x2F;\n5) 打开页面测试查看\n0.98 版本之前：http://linux01:60010 \n0.98 版本之后：http://linux01:16010\n3.2、Hadoop 的通用性优化 1) NameNode 元数据备份使用 SSD\n2) 定时备份 NameNode 上的元数据\n每小时或者每天备份，如果数据极其重要，可以 5~10分钟备份一次。备份可以通过定时任务复制元数据目录即可。\n3) 为 NameNode 指定多个元数据目录\n使用 dfs.name.dir 或者 dfs.namenode.name.dir指定。这样可以提供元数据的冗余和健壮性，以免发生故障。\n4) NameNode 的 dir 自恢复\n设置 dfs.namenode.name.dir.restore 为 true，允许尝试恢复之前失败的dfs.namenode.name.dir 目录，在创建 checkpoint时做此尝试，如果设置了多个磁盘，建议允许。\n5) HDFS 保证 RPC 调用会有较多的线程数\nhdfs-site.xml\n属性：dfs.namenode.handler.count\n解释：该属性是 NameNode 服务默认线程数，的默认值是10，根据机器的可用内存可以调整为 50~100\n属性：dfs.datanode.handler.count\n解释：该属性默认值为 10，是 DataNode 的处理线程数，如果 HDFS客户端程序读写请求比较多，可以调高到15~20，设置的值越大，内存消耗越多，不要调整的过高，一般业务中，5~10即可。\n6) HDFS 副本数的调整\nhdfs-site.xml\n属性：dfs.replication\n解释：如果数据量巨大，且不是非常之重要，可以调整为2~3，如果数据非常之重要，可以调整为 3~5。\n7) HDFS 文件块大小的调整\nhdfs-site.xml\n属性：dfs.blocksize\n解释：块大小定义，该属性应该根据存储的大量的单个文件大小来设置，如果大量的单个文件都小于100M，建议设置成 64M 块大小，对于大于 100M 或者达到 GB的这种情况，建议设置成 256M，一般设置范围波动在 64M~256M 之间。\n8) MapReduce Job 任务服务线程数调整\nmapred-site.xml\n属性：mapreduce.jobtracker.handler.count\n解释：该属性是 Job 任务线程数，默认值是 10，根据机器的可用内存可以调整为50~100\n9) Http 服务器工作线程数\nmapred-site.xml\n属性：mapreduce.tasktracker.http.threads\n解释：定义 HTTP 服务器工作线程数，默认值为 40，对于大集群可以调整到80~100\n10) 文件排序合并优化\nmapred-site.xml\n属性：mapreduce.task.io.sort.factor\n解释：文件排序时同时合并的数据流的数量，这也定义了同时打开文件的个数，默认值为10，如果调高该参数，可以明显减少磁盘IO，即减少文件读取的次数。\n11) 设置任务并发\nmapred-site.xml\n属性：mapreduce.map.speculative\n解释：该属性可以设置任务是否可以并发执行，如果任务多而小，该属性设置为true 可以明显加快任务执行效率，但是对于延迟非常高的任务，建议改为false，这就类似于迅雷下载。\n12) MR 输出数据的压缩\nmapred-site.xml\n属性：mapreduce.map.output.compress、mapreduce.output.fileoutputformat.compress解释：对于大集群而言，建议设置 Map-Reduce的输出为压缩的数据，而对于小集群，则不需要。\n13) 优化 Mapper 和 Reducer 的个数\nmapred-site.xml\n属性：\nmapreduce.tasktracker.map.tasks.maximum\nmapreduce.tasktracker.reduce.tasks.maximum\n解释：以上两个属性分别为一个单独的 Job 任务可以同时运行的 Map 和 Reduce的数量。设置上面两个参数时，需要考虑 CPU 核数、磁盘和内存容量。假设一个8 核的 CPU，业务内容非常消耗 CPU，那么可以设置 map 数量为4，如果该业务不是特别消耗 CPU 类型的，那么可以设置 map 数量为 40，reduce数量为20。这些参数的值修改完成之后，一定要观察是否有较长等待的任务，如果有的话，可以减少数量以加快任务执行，如果设置一个很大的值，会引起大量的上下文切换，以及内存与磁盘之间的数据交换，这里没有标准的配置数值，需要根据业务和硬件配置以及经验来做出选择。在同一时刻，不要同时运行太多的MapReduce，这样会消耗过多的内存，任务会执行的非常缓慢，我们需要根据 CPU核数，内存容量设置一个 MR任务并发的最大值，使固定数据量的任务完全加载到内存中，避免频繁的内存和磁盘数据交换，从而降低磁盘IO，提高性能。\n大概估算公式：\nmap &#x3D; 2 + ⅔cpu_core\nreduce &#x3D; 2 + ⅓cpu_core\n3.3、Linux 优化 1) 开启文件系统的预读缓存可以提高读取速度\n$ sudo blockdev --setra 32768 &#x2F;dev&#x2F;sda\n尖叫提示：ra 是 readahead 的缩写\n2) 关闭进程睡眠池\n即不允许后台进程进入睡眠状态，如果进程空闲，则直接 kill 掉释放资源\n$ sudo sysctl -w vm.swappiness&#x3D;0\n3) 调整 ulimit 上限，默认值为比较小的数字\n$ ulimit -n 查看允许最大进程数\n$ ulimit -u 查看允许打开最大文件数\n优化修改：\n$ sudo vi &#x2F;etc&#x2F;security&#x2F;limits.conf 修改打开文件数限制\n末尾添加：\n* soft nofile 1024000\n* hard nofile 1024000\nHive - nofile 1024000\nhive - nproc 1024000\n$ sudo vi &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;20-nproc.conf 修改用户打开进程数限制\n修改为：\n#* soft nproc 4096\n#root soft nproc unlimited\n* soft nproc 40960\nroot soft nproc unlimited\n4) 开启集群的时间同步 **NTP **\n集群中某台机器同步网络时间服务器的时间，集群中其他机器则同步这台机器的时间。\n5) 更新系统补丁\n更新补丁前，请先测试新版本补丁对集群节点的兼容性。\n3.4、Zookeeper 优化 1) 优化 Zookeeper 会话超时时间\nhbase-site.xml\n参数：zookeeper.session.timeout\n解释：In hbase-site.xml, set zookeeper.session.timeout to 30 seconds orless to bound failure detection (20-30 seconds is a goodstart).该值会直接关系到 master 发现服务器宕机的最大周期，默认值为 30秒，如果该值过小，会在 HBase 在写入大量数据发生而 GC时，导致RegionServer 短暂的不可用，从而没有向 ZK发送心跳包，最终导致认为从节shutdown。一般 20 台左右的集群需要配置 5 台zookeeper。\n3.5、HBase 优化 3.5.1、预分区每一个 region 维护着 startRow 与 endRowKey，如果加入的数据符合某个region 维护的 rowKey范围，则该数据交给这个 region维护。那么依照这个原则，我们可以将数据索要投放的分区提前大致的规划好，以提高HBase 性能。\n1) 手动设定预分区\nhbase&gt; create &#39;staff&#39;,&#39;info&#39;,&#39;partition1&#39;,SPLITS &#x3D;&gt;[&#39;1000&#39;,&#39;2000&#39;,&#39;3000&#39;,&#39;4000&#39;]\n2) 生成 16 进制序列预分区\ncreate &#39;staff2&#39;,&#39;info&#39;,&#39;partition2&#39;,{NUMREGIONS &#x3D;&gt; 15, SPLITALGO&#x3D;&gt; &#39;HexStringSplit&#39;}\n3) 按照文件中设置的规则预分区\n创建 splits.txt 文件内容如下：\naaaa\nbbbb\ncccc\ndddd\n然后执行：\ncreate &#39;staff3&#39;,&#39;partition3&#39;,SPLITS_FILE &#x3D;&gt; &#39;splits.txt&#39;\n4) 使用 JavaAPI 创建预分区\n&#x2F;&#x2F;自定义算法，产生一系列 Hash 散列值存储在二维数组中\nbyte[][] splitKeys &#x3D; 某个散列值函数\n&#x2F;&#x2F;创建 HBaseAdmin 实例\nHBaseAdmin hAdmin &#x3D; new HBaseAdmin(HBaseConfiguration.create());\n&#x2F;&#x2F;创建 HTableDescriptor 实例\nHTableDescriptor tableDesc &#x3D; new HTableDescriptor(tableName);\n&#x2F;&#x2F;通过 HTableDescriptor 实例和散列值二维数组创建带有预分区的 HBase 表\nhAdmin.createTable(tableDesc, splitKeys);\n3.5.2、RowKey 设计一条数据的唯一标识就是 rowkey，那么这条数据存储于哪个分区，取决于 rowkey处于哪个预分区的区间内，设计 rowkey 的主要目的，就是让数据均匀的分布于所有的region中，在一定程度上防止数据倾斜。接下来我们就谈一谈 rowkey常用的设计方案。\n1) 生成随机数、hash、散列值\n比如：\n原本 rowKey 为 1001 的，SHA1后变成：dd01903921ea24941c26a48f2cec24e0bb0e8cc7 原本 rowKey 为 3001的，SHA1 后变成：49042c54de64a1e9bf0b33e00245660ef92dc7bd 原本 rowKey 为5001 的，SHA1 后变成：7b61dec07e02c188790670af43e717f0f46e8913\n在做此操作之前，一般我们会选择从数据集中抽取样本，来决定什么样的 rowKey来 Hash后作为每个分区的临界值。\n2) 字符串反转\n20170524000001 转成 10000042507102\n20170524000002 转成 20000042507102\n这样也可以在一定程度上散列逐步 put 进来的数据。\n3) 字符串拼接\n20170524000001_a12e\n20170524000001_93i7\n3.5.3、内存优化HBase 操作过程中需要大量的内存开销，毕竟 Table是可以缓存在内存中的，一般会分配整个可用内存的 70%给 HBase 的 Java堆。但是不建议分配非常大的堆内存，因为 GC 过程持续太久会导致RegionServer 处于长期不可用状态，一般 16~48G内存就可以了，如果因为框架占用内存过高导致系统内存不足，框架一样会被系统服务拖死。\n3.5.4、基础优化1) 允许在 HDFS 的文件中追加内容\n不是不允许追加内容么？没错，请看背景故事：\nhttp://blog.cloudera.com/blog/2009/07/file-appends-in-hdfs/\nhdfs-site.xml、hbase-site.xml\n属性：dfs.support.append\n解释：开启 HDFS 追加同步，可以优秀的配合 HBase的数据同步和持久化。默认值为 true。\n2) 优化 DataNode 允许的最大文件打开数\nhdfs-site.xml\n属性：dfs.datanode.max.transfer.threads\n解释：HBase一般都会同一时间操作大量的文件，根据集群的数量和规模以及数据动作，设置为4096 或者更高。默认值：4096\n3) 优化延迟高的数据操作的等待时间\nhdfs-site.xml\n属性：dfs.image.transfer.timeout\n解释：如果对于某一次数据操作来讲，延迟非常高，socket需要等待更长的时间，建议把该值设置为更大的值（默认 60000 毫秒），以确保socket 不会被 timeout 掉。\n4) 优化数据的写入效率\nmapred-site.xml\n属性：\nmapreduce.map.output.compress\nmapreduce.map.output.compress.codec\n解释：开启这两个数据可以大大提高文件的写入效率，减少写入时间。第一个属性值修改为true，第二个属性值修改为：org.apache.hadoop.io.compress.GzipCodec或者其他压缩方式。\n5) 优化 DataNode 存储\n属性：dfs.datanode.failed.volumes.tolerated\n解释： 默认为 0，意思是当 DataNode 中有一个磁盘出现故障，则会认为该DataNode shutdown了。如果修改为1，则一个磁盘出现故障时，数据会被复制到其他正常的 DataNode 上，当前的DataNode 继续工作。\n6) 设置 RPC 监听数量\nhbase-site.xml\n属性：hbase.regionserver.handler.count\n解释：默认值为 30，用于指定 RPC监听的数量，可以根据客户端的请求数进行调整，读写请求较多时，增加此值。\n7) 优化 HStore 文件大小\nhbase-site.xml\n属性：hbase.hregion.max.filesize\n解释：默认值 10737418240（10GB），如果需要运行 HBase 的 MR任务，可以减小此值，因为一个 region 对应一个 map 任务，如果单个 region过大，会导致 map 任务执行时间过长。该值的意思就是，如果 HFile的大小达到这个数值，则这个 region 会被切分为两个 Hfile。\n8) 优化 hbase 客户端缓存\nhbase-site.xml\n属性：hbase.client.write.buffer\n解释：用于指定 HBase 客户端缓存，增大该值可以减少 RPC调用次数，但是会消耗更多内存，反之则反之。一般我们需要设定一定的缓存大小，以达到减少RPC 次数的目的。\n9) 指定 scan.next 扫描 HBase 所获取的行数\nhbase-site.xml\n属性：hbase.client.scanner.caching\n解释：用于指定 scan.next 方法获取的默认行数，值越大，消耗内存越大。\n10) flush、compact、split 机制\n当 MemStore 达到阈值，将 Memstore 中的数据 Flush 进 Storefile；compact机制则是把 flush 出来的小文件合并成大的 Storefile 文件。split 则是当Region 达到阈值，会把过大的 Region一分为二。\n涉及属性：\n即：128M 就是 Memstore 的默认阈值\n{width&#x3D;”5.569444444444445in”height&#x3D;”1.8888888888888888in”}\nhbase.hregion.memstore.flush.size：134217728\n即：这个参数的作用是当单个 HRegion 内所有的 Memstore大小总和超过指定值时，flush该 HRegion 的所有 memstore。RegionServer 的flush是通过将请求添加一个队列，模拟生产消费模型来异步处理的。那这里就有一个问题，当队列来不及消费，产生大量积压请求时，可能会导致内存陡增，最坏的情况是触发OOM。\nhbase.regionserver.global.memstore.upperLimit：0.4\nhbase.regionserver.global.memstore.lowerLimit：0.38\n即：当 MemStore 使用内存总量达到hbase.regionserver.global.memstore.upperLimit 指定值时，将会有多个MemStores flush 到文件中，MemStore flush顺序是按照大小降序执行的，直到刷新到 MemStore 使用内存略小于 lowerLimit\n","slug":"Hadoop组件基础","date":"2018-12-27T13:51:36.000Z","categories_index":"大数据","tags_index":"大数据","author_index":"CodingSeed"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-08-18T15:39:21.726Z","categories_index":"","tags_index":"","author_index":"CodingSeed"},{"id":"ab3568622c7f6e7ae567a8af8514c4cd","title":"学Netty-黑马满哥","content":"黑马Netty：https://www.bilibili.com/video/BV1py4y1E7oA\n学Netty，建议看黑马Netty教程。然后尚硅谷Netty课的Protobuf, DubboRPC等案例就可以了。\n尚硅谷-韩顺平：https://www.bilibili.com/video/BV1DJ411m7NR?p=1\n学习Netty建议一定要看 《Netty in Action》（Ntty实战）， 网上有大神也翻译了 ： https://waylau.com/essential-netty-in-action/index.html别人的学习文档，持续更新：https://github.com/guang19/framework-learning\n一. NIO 基础non-blocking io 非阻塞 IO\n1. 三大组件1.1 Channel &amp; Bufferchannel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层\ngraph LR\nchannel --&gt; buffer\nbuffer --&gt; channel\n\n常见的 Channel 有\n\nFileChannel\nDatagramChannel    UDP\nSocketChannel    C&#x2F;S\nServerSocketChannel    S\n\nbuffer 则用来缓冲读写数据，常见的 buffer 有\n\nByteBuffer 抽象类\nMappedByteBuffer\nDirectByteBuffer\nHeapByteBuffer\n\n\nShortBuffer\nIntBuffer\nLongBuffer\nFloatBuffer\nDoubleBuffer\nCharBuffer\n\n1.2 Selectorselector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途\n多线程版设计graph TD\nsubgraph 多线程版\nt1(thread) --&gt; s1(socket1)\nt2(thread) --&gt; s2(socket2)\nt3(thread) --&gt; s3(socket3)\nend\n\n⚠️ 多线程版缺点\n内存占用高\n线程上下文切换成本高\n只适合连接数少的场景\n\n线程池版设计graph TD\nsubgraph 线程池版\nt4(thread) --&gt; s4(socket1)\nt5(thread) --&gt; s5(socket2)\nt4(thread) -.-&gt; s6(socket3)\nt5(thread) -.-&gt; s7(socket4)\nend\n\n⚠️ 线程池版缺点\n阻塞模式下，线程仅能处理一个 socket 连接\n仅适合短连接场景：因为阻塞模式！resp后尽快断开处理其他socket\n\nTH利用率不高\nselector 版设计selector 的作用就是【配合一个线程来管理多个】 channel，获取这些 channel 上发生的【事件】，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低[非频繁请求]的场景（low traffic）\ngraph TD\nsubgraph selector 版\nthread --&gt; selector\nselector --&gt; c1(channel)\nselector --&gt; c2(channel)\nselector --&gt; c3(channel)\nend\n\n可连接|R|W的event\n调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理\n2. ByteBuffer有一普通文本文件 data.txt，内容为\n1234567890abcd\n\n使用 FileChannel 来读取文件内容\t&#x3D;&#x3D;twr：try-with-resources&#x3D;&#x3D;\n@Slf4j\npublic class TestByteBuffer &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; FileChannel\n        &#x2F;&#x2F; 1. 输入输出流， 2. RandomAccessFile\n        try (FileChannel channel &#x3D; new FileInputStream(&quot;data.txt&quot;).getChannel()) &#123;\n            &#x2F;&#x2F; 准备缓冲区\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);\n            while (true) &#123;\n                &#x2F;&#x2F; 从channel读取数据，写到buffer\n                int len &#x3D; channel.read(buffer);\n                log.debug(&quot;读取到的字节数 &#123;&#125;&quot;, len);\n                if(len &#x3D;&#x3D; -1) break;&#x2F;&#x2F;没有内容了\n                &#x2F;&#x2F;print\n                buffer.flip(); &#x2F;&#x2F;切换到读buffer模式\n                while(buffer.hasRemaining()) &#123;\n                    byte b &#x3D; buffer.get();&#x2F;&#x2F;读1B\n                    log.debug(&quot;实际字节数 &#123;&#125;&quot;, (char) b);\n                &#125;\n                buffer.clear(); &#x2F;&#x2F;切换到写buffer模式\n            &#125;\n\n        &#125; catch (IOException e) &#123;\n        &#125;\n    &#125;\n\n&#125;\n\n\n输出\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1\n\n\n\n2.1  ByteBuffer 正确使用姿势\n向 buffer 写入数据，例如调用 channel.read(buffer)\n调用 flip() 切换至读模式\n从 buffer 读取数据，例如调用 buffer.get()\n调用 clear() 或 compact() 【R一部分，压缩掉已读部分继续W】切换至写模式\n重复 1~4 步骤\n\n2.2 ByteBuffer 结构ByteBuffer 有以下重要属性\n\ncapacity\nposition curW&#x2F;R位置\nlimit W&#x2F;R限制\n\n一开始\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\nflip 动作发生后，position 切换为读取位置，limit 切换为读取限制\n\n读取 4 个字节后，状态\n\nclear 动作发生后，状态\n\ncompact 方法，是把**[未读完]的部分向前压缩，然后切换至写(继续W)**模式\n\n💡 调试工具类public class ByteBufferUtil &#123;\n    private static final char[] BYTE2CHAR &#x3D; new char[256];\n    private static final char[] HEXDUMP_TABLE &#x3D; new char[256 * 4];\n    private static final String[] HEXPADDING &#x3D; new String[16];\n    private static final String[] HEXDUMP_ROWPREFIXES &#x3D; new String[65536 &gt;&gt;&gt; 4];\n    private static final String[] BYTE2HEX &#x3D; new String[256];\n    private static final String[] BYTEPADDING &#x3D; new String[16];\n\n    static &#123;\n        final char[] DIGITS &#x3D; &quot;0123456789abcdef&quot;.toCharArray();\n        for (int i &#x3D; 0; i &lt; 256; i++) &#123;\n            HEXDUMP_TABLE[i &lt;&lt; 1] &#x3D; DIGITS[i &gt;&gt;&gt; 4 &amp; 0x0F];\n            HEXDUMP_TABLE[(i &lt;&lt; 1) + 1] &#x3D; DIGITS[i &amp; 0x0F];\n        &#125;\n\n        int i;\n\n        &#x2F;&#x2F; Generate the lookup table for hex dump paddings\n        for (i &#x3D; 0; i &lt; HEXPADDING.length; i++) &#123;\n            int padding &#x3D; HEXPADDING.length - i;\n            StringBuilder buf &#x3D; new StringBuilder(padding * 3);\n            for (int j &#x3D; 0; j &lt; padding; j++) &#123;\n                buf.append(&quot;   &quot;);\n            &#125;\n            HEXPADDING[i] &#x3D; buf.toString();\n        &#125;\n\n        &#x2F;&#x2F; Generate the lookup table for the start-offset header in each row (up to 64KiB).\n        for (i &#x3D; 0; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;\n            StringBuilder buf &#x3D; new StringBuilder(12);\n            buf.append(NEWLINE);\n            buf.append(Long.toHexString(i &lt;&lt; 4 &amp; 0xFFFFFFFFL | 0x100000000L));\n            buf.setCharAt(buf.length() - 9, &#39;|&#39;);\n            buf.append(&#39;|&#39;);\n            HEXDUMP_ROWPREFIXES[i] &#x3D; buf.toString();\n        &#125;\n\n        &#x2F;&#x2F; Generate the lookup table for byte-to-hex-dump conversion\n        for (i &#x3D; 0; i &lt; BYTE2HEX.length; i++) &#123;\n            BYTE2HEX[i] &#x3D; &#39; &#39; + StringUtil.byteToHexStringPadded(i);\n        &#125;\n\n        &#x2F;&#x2F; Generate the lookup table for byte dump paddings\n        for (i &#x3D; 0; i &lt; BYTEPADDING.length; i++) &#123;\n            int padding &#x3D; BYTEPADDING.length - i;\n            StringBuilder buf &#x3D; new StringBuilder(padding);\n            for (int j &#x3D; 0; j &lt; padding; j++) &#123;\n                buf.append(&#39; &#39;);\n            &#125;\n            BYTEPADDING[i] &#x3D; buf.toString();\n        &#125;\n\n        &#x2F;&#x2F; Generate the lookup table for byte-to-char conversion\n        for (i &#x3D; 0; i &lt; BYTE2CHAR.length; i++) &#123;\n            if (i &lt;&#x3D; 0x1f || i &gt;&#x3D; 0x7f) &#123;\n                BYTE2CHAR[i] &#x3D; &#39;.&#39;;\n            &#125; else &#123;\n                BYTE2CHAR[i] &#x3D; (char) i;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 打印所有内容\n     * @param buffer\n     *&#x2F;\n    public static void debugAll(ByteBuffer buffer) &#123;\n        int oldlimit &#x3D; buffer.limit();\n        buffer.limit(buffer.capacity());\n        StringBuilder origin &#x3D; new StringBuilder(256);\n        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());\n        System.out.println(&quot;+--------+-------------------- all ------------------------+----------------+&quot;);\n        System.out.printf(&quot;position: [%d], limit: [%d]\\n&quot;, buffer.position(), oldlimit);\n        System.out.println(origin);\n        buffer.limit(oldlimit);\n    &#125;\n\n    &#x2F;**\n     * 打印可读取内容\n     * @param buffer\n     *&#x2F;\n    public static void debugRead(ByteBuffer buffer) &#123;\n        StringBuilder builder &#x3D; new StringBuilder(256);\n        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());\n        System.out.println(&quot;+--------+-------------------- read -----------------------+----------------+&quot;);\n        System.out.printf(&quot;position: [%d], limit: [%d]\\n&quot;, buffer.position(), buffer.limit());\n        System.out.println(builder);\n    &#125;\n\n    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) &#123;\n        if (isOutOfBounds(offset, length, buf.capacity())) &#123;\n            throw new IndexOutOfBoundsException(\n                    &quot;expected: &quot; + &quot;0 &lt;&#x3D; offset(&quot; + offset + &quot;) &lt;&#x3D; offset + length(&quot; + length\n                            + &quot;) &lt;&#x3D; &quot; + &quot;buf.capacity(&quot; + buf.capacity() + &#39;)&#39;);\n        &#125;\n        if (length &#x3D;&#x3D; 0) &#123;\n            return;\n        &#125;\n        dump.append(\n                &quot;         +-------------------------------------------------+&quot; +\n                        NEWLINE + &quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot; +\n                        NEWLINE + &quot;+--------+-------------------------------------------------+----------------+&quot;);\n\n        final int startIndex &#x3D; offset;\n        final int fullRows &#x3D; length &gt;&gt;&gt; 4;\n        final int remainder &#x3D; length &amp; 0xF;\n\n        &#x2F;&#x2F; Dump the rows which have 16 bytes.\n        for (int row &#x3D; 0; row &lt; fullRows; row++) &#123;\n            int rowStartIndex &#x3D; (row &lt;&lt; 4) + startIndex;\n\n            &#x2F;&#x2F; Per-row prefix.\n            appendHexDumpRowPrefix(dump, row, rowStartIndex);\n\n            &#x2F;&#x2F; Hex dump\n            int rowEndIndex &#x3D; rowStartIndex + 16;\n            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            &#125;\n            dump.append(&quot; |&quot;);\n\n            &#x2F;&#x2F; ASCII dump\n            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            &#125;\n            dump.append(&#39;|&#39;);\n        &#125;\n\n        &#x2F;&#x2F; Dump the last row which has less than 16 bytes.\n        if (remainder !&#x3D; 0) &#123;\n            int rowStartIndex &#x3D; (fullRows &lt;&lt; 4) + startIndex;\n            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);\n\n            &#x2F;&#x2F; Hex dump\n            int rowEndIndex &#x3D; rowStartIndex + remainder;\n            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            &#125;\n            dump.append(HEXPADDING[remainder]);\n            dump.append(&quot; |&quot;);\n\n            &#x2F;&#x2F; Ascii dump\n            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            &#125;\n            dump.append(BYTEPADDING[remainder]);\n            dump.append(&#39;|&#39;);\n        &#125;\n\n        dump.append(NEWLINE +\n                &quot;+--------+-------------------------------------------------+----------------+&quot;);\n    &#125;\n\n    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) &#123;\n        if (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;\n            dump.append(HEXDUMP_ROWPREFIXES[row]);\n        &#125; else &#123;\n            dump.append(NEWLINE);\n            dump.append(Long.toHexString(rowStartIndex &amp; 0xFFFFFFFFL | 0x100000000L));\n            dump.setCharAt(dump.length() - 9, &#39;|&#39;);\n            dump.append(&#39;|&#39;);\n        &#125;\n    &#125;\n\n    public static short getUnsignedByte(ByteBuffer buffer, int index) &#123;\n        return (short) (buffer.get(index) &amp; 0xFF);\n    &#125;\n&#125;\n\n\n\n2.3 ByteBuffer 常见方法-nio.c2分配空间\tTestByteBufferAllocate可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法\nBytebuffer buf &#x3D; ByteBuffer.allocate(16);\n\nSystem.out.println(ByteBuffer.allocateDirect(16).getClass());\n&#x2F;*\n        零拷贝:allocateDirect(16)\n        class java.nio.HeapByteBuffer    - java 堆内存，读写效率较低，受到 GC copy的影响\n        class java.nio.DirectByteBuffer  - 直接内存，读写效率高（少一次拷贝），不会受 GC 影响，调OSsys函数：分配的效率低\n        【优化-Netty对象池：减少bytebuffer分配频率，并回收】\n         *&#x2F;\n\n\n\n向 buffer 写入数据\tTestByteBufferReadWrite有两种办法\n\n调用 channel 的 read 方法\n调用 buffer 自己的 put 方法\n\nint readBytes &#x3D; channel.read(buf);\n\n和\nbuf.put((byte)127);\n\n\n\n从 buffer 读取数据\tTestByteBufferRead同样有两种办法\n\n调用 channel 的 write 方法\n调用 buffer 自己的 get 方法\n\nint writeBytes &#x3D; channel.write(buf);\n\n和\nbyte b &#x3D; buf.get();\n\nget 方法会让 position 读指针向后走，如果想重复读取数据\n\n可以调用 rewind 方法将 position 重新置为 0\n或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针\n\nmark 和 resetmark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\n\n\n\n\n\n\n\n\n\n注意\nrewind 和 flip 都会清除 mark 位置！\n字符串与 ByteBuffer 互转\tTestByteBufferString        &#x2F;&#x2F; 1. 字符串转为 ByteBuffer allocate+put:W\n        ByteBuffer buffer1 &#x3D; ByteBuffer.allocate(16);\n        buffer1.put(&quot;hello&quot;.getBytes());&#x2F;&#x2F;\n        debugAll(buffer1);\n\n        &#x2F;&#x2F; 2. Charset R\n        ByteBuffer buffer2 &#x3D; StandardCharsets.UTF_8.encode(&quot;你好&quot;);\n        debugAll(buffer2);\n\n        &#x2F;&#x2F; 3. wrap R\n        ByteBuffer buffer3 &#x3D; ByteBuffer.wrap(&quot;hello&quot;.getBytes());\n        debugAll(buffer3);\n\nByteBuffer buffer1 &#x3D; StandardCharsets.UTF_8.encode(&quot;你好&quot;);\nByteBuffer buffer2 &#x3D; Charset.forName(&quot;utf-8&quot;).encode(&quot;你好&quot;);\n\ndebug(buffer1);\ndebug(buffer2);\n\nbuffer1.flip();&#x2F;&#x2F;W-&gt;R\nCharBuffer buffer3 &#x3D; StandardCharsets.UTF_8.decode(buffer1);\nSystem.out.println(buffer3.getClass());&#x2F;&#x2F;HeapCharBuffer\nSystem.out.println(buffer3.toString());&#x2F;&#x2F;\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\nclass java.nio.HeapCharBuffer\n你好\n\n\n\n⚠️ Buffer 的线程安全\n\n\n\n\n\n\n\n\nBuffer 是非线程安全的\n2.4 Scattering Reads分散读取，有一个文本文件 3parts.txt\nonetwothree\n\n使用如下方式读取，可以将数据【填充至多个 buffer】\ntry (RandomAccessFile file &#x3D; new RandomAccessFile(&quot;helloword&#x2F;3parts.txt&quot;, &quot;rw&quot;)) &#123;\n    FileChannel channel &#x3D; file.getChannel();\n    ByteBuffer a &#x3D; ByteBuffer.allocate(3);\n    ByteBuffer b &#x3D; ByteBuffer.allocate(3);\n    ByteBuffer c &#x3D; ByteBuffer.allocate(5);\n    channel.read(new ByteBuffer[]&#123;a, b, c&#125;);&#x2F;&#x2F;增强read([])\n    a.flip();\n    b.flip();\n    c.flip();\n    debug(a);\n    debug(b);\n    debug(c);\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\n\n结果\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6f 6e 65                                        |one             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 77 6f                                        |two             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 68 72 65 65                                  |three           |\n+--------+-------------------------------------------------+----------------+\n\n\n\n2.5 Gathering Writes使用如下方式写入，可以将多个 buffer 的数据填充至 channel\ntry (RandomAccessFile file &#x3D; new RandomAccessFile(&quot;helloword&#x2F;3parts.txt&quot;, &quot;rw&quot;)) &#123;\n    FileChannel channel &#x3D; file.getChannel();\n    ByteBuffer d &#x3D; ByteBuffer.allocate(4);\n    ByteBuffer e &#x3D; ByteBuffer.allocate(4);\n    channel.position(11);&#x2F;&#x2F;\n\n    d.put(new byte[]&#123;&#39;f&#39;, &#39;o&#39;, &#39;u&#39;, &#39;r&#39;&#125;);\n    e.put(new byte[]&#123;&#39;f&#39;, &#39;i&#39;, &#39;v&#39;, &#39;e&#39;&#125;);\n    d.flip();\n    e.flip();\n    debug(d);\n    debug(e);\n    channel.write(new ByteBuffer[]&#123;d, e&#125;);&#x2F;&#x2F;\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 6f 75 72                                     |four            |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 69 76 65                                     |five            |\n+--------+-------------------------------------------------+----------------+\n\n文件内容\nonetwothreefourfive\n\n\n\n2.6 练习\tTestByteBufferExam网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\nHello,world\\n\nI’m zhangsan\\n\nHow are you?\\n\n\n变成了下面的两个 byteBuffer (黏包，半包)\n\nHello,world\\nI’m zhangsan\\nHo\nw are you?\\n\n\n现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据\npublic static void main(String[] args) &#123;\n    ByteBuffer source &#x3D; ByteBuffer.allocate(32);\n    &#x2F;&#x2F;                     11            24\n    source.put(&quot;Hello,world\\nI&#39;m zhangsan\\nHo&quot;.getBytes());\n    split(source);\n\n    source.put(&quot;w are you?\\nhaha!\\n&quot;.getBytes());\n    split(source);\n&#125;\n\n    private static void split(ByteBuffer source) &#123;\n        source.flip();\n        for (int i &#x3D; 0; i &lt; source.limit(); i++) &#123;\n            &#x2F;&#x2F; 找到一条完整消息\n            if (source.get(i) &#x3D;&#x3D; &#39;\\n&#39;) &#123;\n                int length &#x3D; i + 1 - source.position();\n                &#x2F;&#x2F; 把这条完整消息存入新的 ByteBuffer\n                ByteBuffer target &#x3D; ByteBuffer.allocate(length);\n                &#x2F;&#x2F; 从 source 读，向 target 写\n                for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                    target.put(source.get());&#x2F;&#x2F;\n                &#125;\n                debugAll(target);\n            &#125;\n        &#125;\n        source.compact();&#x2F;&#x2F;Ho copy覆盖,待拼接ne！\n    &#125;\n\n\n\n3. 文件编程3.1 FileChannel⚠️ FileChannel 工作模式\n\n\n\n\n\n\n\n\nFileChannel 只能工作在阻塞模式下，不能select非阻塞！\n获取不能直接打开 FileChannel，必须【通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法】\n\n通过 FileInputStream 获取的 channel 只能读\n通过 FileOutputStream 获取的 channel 只能写\n通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\n\n读取会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\nint readBytes &#x3D; channel.read(buffer);\n\n\n\n写入写入的正确姿势如下， SocketChannel\nByteBuffer buffer &#x3D; ...;\nbuffer.put(...); &#x2F;&#x2F; 存入数据\nbuffer.flip();   &#x2F;&#x2F; 切换读模式\n\nwhile(buffer.hasRemaining()) &#123;\n    channel.write(buffer);\n&#125;\n\n在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\n关闭channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\n位置获取当前位置\nlong pos &#x3D; channel.position();\n\n设置当前位置\nlong newPos &#x3D; ...;\nchannel.position(newPos);\n\n设置当前位置时，如果设置为文件的末尾\n\n这时读取会返回 -1 \n这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\n大小使用 size 方法获取文件的大小\n强制写入【操作系统出于性能的考虑，会将数据缓存】，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\n3.2 两个 Channel 传输数据-nio.c3String FROM &#x3D; &quot;helloword&#x2F;data.txt&quot;;\nString TO &#x3D; &quot;helloword&#x2F;to.txt&quot;;\nlong start &#x3D; System.nanoTime();\ntry (FileChannel from &#x3D; new FileInputStream(FROM).getChannel();\n     FileChannel to &#x3D; new FileOutputStream(TO).getChannel();\n    ) &#123;\n    from.transferTo(0, from.size(), to);&#x2F;&#x2F;\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\nlong end &#x3D; System.nanoTime();\nSystem.out.println(&quot;transferTo 用时：&quot; + (end - start) &#x2F; 1000_000.0);\n\n输出\ntransferTo 用时：8.2011\n\n\n\n超过 2g 大小的文件传输\tTestFileChannelTransferTo\npublic class TestFileChannelTransferTo &#123;\n    public static void main(String[] args) &#123;\n        try (\n                FileChannel from &#x3D; new FileInputStream(&quot;data.txt&quot;).getChannel();\n                FileChannel to &#x3D; new FileOutputStream(&quot;to.txt&quot;).getChannel();\n        ) &#123;\n            &#x2F;&#x2F; 效率高，底层会利用操作系统的零拷贝进行优化\n            long size &#x3D; from.size();\n            &#x2F;&#x2F; left 变量代表【还剩余多少字节】\n            for (long left &#x3D; size; left &gt; 0; ) &#123;\n                System.out.println(&quot;position:&quot; + (size - left) + &quot; left:&quot; + left);\n                left -&#x3D; from.transferTo((size - left), left, to);&#x2F;&#x2F;[sz-left ...-&gt;sz]\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n实际传输一个超大文件\nposition:0 left:7769948160\nposition:2147483647 left:5622464513\nposition:4294967294 left:3474980866\nposition:6442450941 left:1327497219\n\n\n\n3.3 Pathjdk7 引入了 Path 和 Paths 类\n\nPath 用来表示文件路径\nPaths 是工具类，用来获取 Path 实例\n\nPath source &#x3D; Paths.get(&quot;1.txt&quot;); &#x2F;&#x2F; 相对路径 使用 user.dir 环境变量来定位 1.txt\n\nPath source &#x3D; Paths.get(&quot;d:\\\\1.txt&quot;); &#x2F;&#x2F; 绝对路径 代表了  d:\\1.txt\n\nPath source &#x3D; Paths.get(&quot;d:&#x2F;1.txt&quot;); &#x2F;&#x2F; 绝对路径 同样代表了  d:\\1.txt\n\nPath projects &#x3D; Paths.get(&quot;d:\\\\data&quot;, &quot;projects&quot;); &#x2F;&#x2F; 代表了  d:\\data\\projects\n\n\n. 代表了当前路径\n.. 代表了上一级路径\n\n例如目录结构如下\nd:\n\t|- data\n\t\t|- projects\n\t\t\t|- a\n\t\t\t|- b\n\n代码\nPath path &#x3D; Paths.get(&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;);\nSystem.out.println(path);\nSystem.out.println(path.normalize()); &#x2F;&#x2F; 正常化路径\n\n会输出\nd:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b\n\n\n\n3.4 Files检查文件是否存在\nPath path &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nSystem.out.println(Files.exists(path));&#x2F;&#x2F;\n\n\n\n创建一级目录\nPath path &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\nFiles.createDirectory(path);&#x2F;&#x2F;\n\n\n如果目录已存在，会抛异常 FileAlreadyExistsException\n不能一次创建多级目录，否则会抛异常 NoSuchFileException\n\n创建多级目录用\nPath path &#x3D; Paths.get(&quot;helloword&#x2F;d1&#x2F;d2&quot;);\nFiles.createDirectories(path);&#x2F;&#x2F;\n\n\n\n拷贝文件\nPath source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\n\nFiles.copy(source, target);&#x2F;&#x2F;\n\n\n如果文件已存在，会抛异常 FileAlreadyExistsException\n\n如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);&#x2F;&#x2F;REPLACE_EXISTING\n\n\n\n移动文件\nPath source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);&#x2F;&#x2F;ATOMIC_MOVE\n\n\nStandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\n\n删除文件\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\n\nFiles.delete(target);\n\n\n如果文件不存在，会抛异常 NoSuchFileException\n\n删除目录\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\n\nFiles.delete(target);\n\n\n如果目录还有内容，会抛异常 DirectoryNotEmptyException\n\nTestFilesWalkFileTree&#x3D;&#x3D;!Extract Method:ctrl+alt+M&#x3D;&#x3D;\n遍历目录文件\n&#x2F;&#x2F;    !Extract Method:ctrl+alt+M\n    private static void m1() throws IOException &#123;\n        AtomicInteger dirCount &#x3D; new AtomicInteger();&#x2F;&#x2F;法一\n        AtomicInteger fileCount &#x3D; new AtomicInteger();\n&#x2F;&#x2F;        不是多线程，匿名类里不能使用非final的，所以你必须用对象去做，换成个数组也行【Integer是不可变类！不能++！】\n&#x2F;&#x2F;        因为原子类是引用类型，放到内部类当中【将引用复制到内部类对象所在的堆当中，使用基本数据类型复制会有数据不一致的问题】\n&#x2F;&#x2F;        final int[] cnt &#x3D; &#123;0&#125;;&#x2F;&#x2F;法二\n&#x2F;&#x2F;        SimpleFileVisitor内部类  visitor访问者模式！！！\n        Files.walkFileTree(Paths.get(&quot;D:\\\\Software\\\\Program Files\\\\Java\\\\jdk1.8.0_162&quot;), new SimpleFileVisitor&lt;Path&gt;()&#123;\n            @Override\n            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;\n                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;+dir);\n                dirCount.incrementAndGet();\n&#x2F;&#x2F;                cnt[0]++;\n                return super.preVisitDirectory(dir, attrs);\n            &#125;\n\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n                System.out.println(file);\n                fileCount.incrementAndGet();\n                return super.visitFile(file, attrs);\n            &#125;\n        &#125;);\n        System.out.println(&quot;dir count:&quot; +dirCount);\n        System.out.println(&quot;file count:&quot; +fileCount);\n    &#125;\n\n\n\n统计 jar 的数目\nprivate static void m2() throws IOException &#123;\n    AtomicInteger jarCount &#x3D; new AtomicInteger();\n    Files.walkFileTree(Paths.get(&quot;D:\\\\Software\\\\Program Files\\\\Java\\\\jdk1.8.0_162&quot;), new SimpleFileVisitor&lt;Path&gt;()&#123;\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n            if (file.toString().endsWith(&quot;.jar&quot;)) &#123;&#x2F;&#x2F;\n                System.out.println(file);\n                jarCount.incrementAndGet();\n            &#125;\n            return super.visitFile(file, attrs);\n        &#125;\n    &#125;);\n    System.out.println(&quot;jar count:&quot; +jarCount);\n&#125;\n\n\n\n删除多级目录\n    public static void main(String[] args) throws IOException &#123;\n\n&#x2F;&#x2F;        m1();\n&#x2F;&#x2F;        m2();\n\n        &#x2F;&#x2F;删除多级目录\n        Files.delete(Paths.get(&quot;D:\\\\Snipaste-1.16.2-x64 - 副本&quot;));&#x2F;&#x2F;DirectoryNotEmptyException!!!\n        &#x2F;&#x2F;先删文件，再删目录\n        Files.walkFileTree(Paths.get(&quot;D:\\\\Snipaste-1.16.2-x64 - 副本&quot;), new SimpleFileVisitor&lt;Path&gt;() &#123;\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n                Files.delete(file);&#x2F;&#x2F;\n                return super.visitFile(file, attrs);\n            &#125;\n            @Override\n            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123;\n                Files.delete(dir);&#x2F;&#x2F;\n                return super.postVisitDirectory(dir, exc);\n            &#125;\n        &#125;);\n    &#125;\n\n\n\n\n⚠️ 删除很危险\n\n\n\n\n\n\n\n\n删除是危险操作，确保要递归删除的文件夹没有重要内容\n拷贝多级目录\tTestFilesCopy\nlong start &#x3D; System.currentTimeMillis();\nString source &#x3D; &quot;D:\\\\Snipaste-1.16.2-x64&quot;;\nString target &#x3D; &quot;D:\\\\Snipaste-1.16.2-x64aaa&quot;;\n\nFiles.walk(Paths.get(source)).forEach(path -&gt; &#123;\n    try &#123;\n        String targetName &#x3D; path.toString().replace(source, target);\n        &#x2F;&#x2F; 是目录\n        if (Files.isDirectory(path)) &#123;\n            Files.createDirectory(Paths.get(targetName));\n        &#125;\n        &#x2F;&#x2F; 是普通文件\n        else if (Files.isRegularFile(path)) &#123;\n            Files.copy(path, Paths.get(targetName));\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;);\nlong end &#x3D; System.currentTimeMillis();\nSystem.out.println(end - start);\n\n\n\n\n\n4. 网络编程-nio.c44.1 非阻塞 vs 阻塞1、阻塞\n阻塞模式下，相关方法都会导致线程暂停\nServerSocketChannel.accept 会在没有连接建立时让线程暂停\nSocketChannel.read 会在没有数据可读时让线程暂停\n阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\n\n\n单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\n但多线程下，有新的问题，体现在以下方面\n32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\n可以采用&#x3D;&#x3D;线程池技术来减少线程数和线程上下文切换，但治标不治本，如果【有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程】，因此不适合长连接，【只适合短连接】&#x3D;&#x3D;\n\n\n\n服务器端\n&#x2F;&#x2F; 使用 nio 来理解阻塞模式, 单线程\n&#x2F;&#x2F; 0. ByteBuffer\nByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F; 1. 创建了服务器\nServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n\n&#x2F;&#x2F; 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n\n&#x2F;&#x2F; 3. 连接集合\nList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();\nwhile (true) &#123;\n    &#x2F;&#x2F; 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    log.debug(&quot;connecting...&quot;);\n    SocketChannel sc &#x3D; ssc.accept(); &#x2F;&#x2F; 阻塞方法，线程停止运行\n    log.debug(&quot;connected... &#123;&#125;&quot;, sc);\n    channels.add(sc);\n    for (SocketChannel channel : channels) &#123;\n        &#x2F;&#x2F; 5. 接收客户端发送的数据\n        log.debug(&quot;before read... &#123;&#125;&quot;, channel);\n        channel.read(buffer); &#x2F;&#x2F; 阻塞方法，线程停止运行\n        buffer.flip();\n        debugRead(buffer);\n        buffer.clear();\n        log.debug(&quot;after read...&#123;&#125;&quot;, channel);\n    &#125;\n&#125;\n\n客户端\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        SocketAddress address &#x3D; sc.getLocalAddress();\n        System.out.println(&quot;waiting...&quot;);\n&#x2F;&#x2F;        sc.close();\n\n\n\nS：run\tconnecting\tbefore read()\nC:debug sc-右键evaluate expression：sc.write(Charset.defaultCharset().encode(“hello”));\n再发“hi”，没反应！需要建立新连接！\n&#x3D;&#x3D;Client-edit conf-勾选Alow parallel run：debug 新C&#x3D;&#x3D;\nsc.write(Charset.defaultCharset().encode(“hi”));\n单线程处理多个连接：accept() read()均阻塞！\n2、非阻塞\n非阻塞模式下，相关方法都不会让线程暂停\n在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行\nSocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept \n写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去\n\n\n但&#x3D;&#x3D;非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu！！！&#x3D;&#x3D;\n&#x3D;&#x3D;数据【复制】过程中，线程实际还是阻塞的（AIO[异步！] 改进的地方）&#x3D;&#x3D;\n\n服务器端，客户端代码不变\n&#x2F;&#x2F; 使用 nio 来理解非阻塞模式, 单线程\n&#x2F;&#x2F; 0. ByteBuffer\nByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F; 1. 创建了服务器\nServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\nssc.configureBlocking(false); &#x2F;&#x2F; 非阻塞模式\n&#x2F;&#x2F; 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n&#x2F;&#x2F; 3. 连接集合\nList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();\nwhile (true) &#123;\n    &#x2F;&#x2F; 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    SocketChannel sc &#x3D; ssc.accept(); &#x2F;&#x2F; 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null\n    if (sc !&#x3D; null) &#123;\n        log.debug(&quot;connected... &#123;&#125;&quot;, sc);\n        sc.configureBlocking(false); &#x2F;&#x2F; 非阻塞模式\n        channels.add(sc);\n    &#125;\n    for (SocketChannel channel : channels) &#123;\n        &#x2F;&#x2F; 5. 接收客户端发送的数据\n        int read &#x3D; channel.read(buffer);&#x2F;&#x2F; 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n        if (read &gt; 0) &#123;\n            buffer.flip();\n            debugRead(buffer);\n            buffer.clear();\n            log.debug(&quot;after read...&#123;&#125;&quot;, channel);\n        &#125;\n    &#125;\n&#125;\n\n单线程处理多个连接\n12:39:32 [DEBUG] [main] c.i.nio.c4.Server - connected... java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:11261]\n12:39:40 [DEBUG] [main] c.i.nio.c4.Server - connected... java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:11268]\n12:39:47 [DEBUG] [main] c.i.nio.c4.Server - connected... java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:11284]\n\n\n\n实战：nio.c4！！！Client\npublic class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        SocketAddress address &#x3D; sc.getLocalAddress();\n        System.out.println(&quot;waiting...&quot;);\n&#x2F;&#x2F;        sc.close();\n    &#125;\n&#125;\n\n\n\nServer\npackage cn.itcast.nio.c4;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static cn.itcast.nio.c2.ByteBufferUtil.debugRead;\n\n@Slf4j\npublic class Server &#123;\n\n    public static void main(String[] args) throws IOException &#123;\n&#x2F;&#x2F;&#x2F;&#x2F; 使用 nio 来理解非阻塞模式, 单线程\n&#x2F;&#x2F;&#x2F;&#x2F; 0. ByteBuffer\n&#x2F;&#x2F;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F;&#x2F;&#x2F; 1. 创建了服务器\n&#x2F;&#x2F;        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n&#x2F;&#x2F;        ssc.configureBlocking(false); &#x2F;&#x2F; 非阻塞模式\n&#x2F;&#x2F;&#x2F;&#x2F; 2. 绑定监听端口\n&#x2F;&#x2F;        ssc.bind(new InetSocketAddress(8080));\n&#x2F;&#x2F;&#x2F;&#x2F; 3. 连接集合\n&#x2F;&#x2F;        List&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();\n&#x2F;&#x2F;        while (true) &#123;\n&#x2F;&#x2F;            &#x2F;&#x2F; 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n&#x2F;&#x2F;            SocketChannel sc &#x3D; ssc.accept(); &#x2F;&#x2F; 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null\n&#x2F;&#x2F;            if (sc !&#x3D; null) &#123;\n&#x2F;&#x2F;                log.debug(&quot;connected... &#123;&#125;&quot;, sc);\n&#x2F;&#x2F;                sc.configureBlocking(false); &#x2F;&#x2F; 非阻塞模式\n&#x2F;&#x2F;                channels.add(sc);\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;            for (SocketChannel channel : channels) &#123;\n&#x2F;&#x2F;                &#x2F;&#x2F; 5. 接收客户端发送的数据\n&#x2F;&#x2F;                int read &#x3D; channel.read(buffer);&#x2F;&#x2F; 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n&#x2F;&#x2F;                if (read &gt; 0) &#123;\n&#x2F;&#x2F;                    buffer.flip();\n&#x2F;&#x2F;                    debugRead(buffer);\n&#x2F;&#x2F;                    buffer.clear();\n&#x2F;&#x2F;                    log.debug(&quot;after read...&#123;&#125;&quot;, channel);\n&#x2F;&#x2F;                &#125;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;        &#125;\n\n\n        &#x2F;&#x2F; 1. 创建 selector, 管理多个 channel\n        Selector selector &#x3D; Selector.open();\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        &#x2F;&#x2F; 2. 建立 selector 和 channel 的联系（&lt;-注册）\n        &#x2F;&#x2F; SelectionKey 就是将来事件发生后，通过它可以知道当前是哪个事件和哪个channel的事件\n        SelectionKey sscKey &#x3D; ssc.register(selector, 0, null);\n        &#x2F;&#x2F; key 只关注 accept 事件：监听新的连接请求\n        sscKey.interestOps(SelectionKey.OP_ACCEPT);\n        log.debug(&quot;sscKey:&#123;&#125;&quot;, sscKey);\n\n        &#x2F;&#x2F;观察者模式？？？\n        ssc.bind(new InetSocketAddress(8080));\n        while (true) &#123;\n            &#x2F;&#x2F; 3. 【select 方法： 没有事件发生，线程阻塞，有事件，线程才会恢复运行】\n            &#x2F;&#x2F; select 在【事件未处理时，它不会阻塞】, 事件发生后要么处理，要么取消key.cancel()，不能置之不理！他会继续让你处理cur，非阻塞死循环！\n            selector.select();\n            &#x2F;&#x2F; 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n            &#x2F;&#x2F; 边遍历边删除：不要用增强for遍历，用iter遍历！iter.remove();！\n            Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator(); &#x2F;&#x2F; accept, read\n            while (iter.hasNext()) &#123;\n                SelectionKey key &#x3D; iter.next();\n                &#x2F;&#x2F; 处理key 时，要从 selectedKeys(只+不-) 集合中主动删除，否则下次处理(没事件)就会有问题:NullPointerException!!!\n                iter.remove();\n                log.debug(&quot;key: &#123;&#125;&quot;, key);\n\n                &#x2F;&#x2F; 5. 区分事件类型\n                if (key.isAcceptable()) &#123; &#x2F;&#x2F; 如果是 accept\n                    ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();\n                    SocketChannel sc &#x3D; channel.accept();&#x2F;&#x2F;if(处理完，ssckey不删):下次再accept()会NullPointerException! 故要主动iter.remove()!\n                    sc.configureBlocking(false);\n\n                    SelectionKey scKey &#x3D; sc.register(selector, 0, null);\n                    scKey.interestOps(SelectionKey.OP_READ);&#x2F;&#x2F;accept后注册到read上！\n                    log.debug(&quot;&#123;&#125;&quot;, sc);\n                    log.debug(&quot;scKey:&#123;&#125;&quot;, scKey);\n                &#125; else if (key.isReadable()) &#123; &#x2F;&#x2F; 如果是 read\n                    try &#123;\n                        SocketChannel channel &#x3D; (SocketChannel) key.channel(); &#x2F;&#x2F; 拿到触发事件的channel\n                        ByteBuffer buffer &#x3D; ByteBuffer.allocate(4);\n                        int read &#x3D; channel.read(buffer); &#x2F;&#x2F; 如果是正常断开，read 的方法的返回值是 -1\n                        if(read &#x3D;&#x3D; -1) &#123;\n                            key.cancel();&#x2F;&#x2F;取消!!!sc.close()正常断开！\n                        &#125; else &#123;\n                            buffer.flip();\n&#x2F;&#x2F;                            debugAll(buffer);\n                            System.out.println(Charset.defaultCharset().decode(buffer));\n                        &#125;\n                    &#125; catch (IOException e) &#123;\n                        e.printStackTrace();\n                        &#x2F;&#x2F; 因为客户端(异常)断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）处理异常，accept()阻塞：否则死循环抛异常！\n                        key.cancel();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\niter.remove();\n\n异常断开：try-catch:cancel()\tsc.close()正常断开:read&#x3D;&#x3D;-1:cancel()\t否则死循环！\nutf8:中文3B\n\nsc.write(Charset.defaultCharset().encode(&quot;中国&quot;));\n\n半包现象！\n【分步讲解】4.2 Selectorgraph TD\nsubgraph selector 版\nthread --&gt; selector\nselector --&gt; c1(channel)\nselector --&gt; c2(channel)\nselector --&gt; c3(channel)\nend\n\n\n\n3、多路复用单线程可以配合 Selector 完成对多个 Channel 可读写【事件】的监控，这称之为多路复用\n\n多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用\n如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证\n有可连接事件时才去连接\n有可读事件才去读取\n有可写事件才去写入\n限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\n\n\n\n\n\n好处\n\n一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功\n让这个线程能够被充分利用\n节约了线程的数量\n减少了线程上下文切换\n\n创建Selector selector &#x3D; Selector.open();\n\n\n\n绑定 Channel 事件也称之为注册事件，绑定的事件 selector 才会关心 \nchannel.configureBlocking(false);\nSelectionKey key &#x3D; channel.register(selector, 绑定事件);\n\n\nchannel 必须工作在非阻塞模式\nFileChannel 没有非阻塞模式，因此不能配合 selector 一起使用\n绑定的事件类型可以有\n【connect - 客户端连接成功】时触发\naccept - 服务器端成功接受连接时触发\nread - 数据可读入时触发，有因为S接收能力弱，数据暂不能读入的情况\nwrite - 数据可写出时触发，有因为S发送能力弱，数据暂不能写出的情况\n\n\n\n监听 Channel 事件可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件\n方法1，阻塞直到绑定事件发生\nint count &#x3D; selector.select();\n\n\n\n方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\nint count &#x3D; selector.select(long timeout);\n\n\n\n方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值(事件数)检查是否有事件\nint count &#x3D; selector.selectNow();\n\n\n\n💡 select 何时不阻塞\n\n\n\n\n\n\n\n\n\n事件发生时\n客户端发起连接请求，会触发 accept 事件\n【客户端发送数据过来，客户端正常、异常关闭时】，都会触发 read 事件，另外如果客户端发送的数据大于 buffer 缓冲区，会触发多次读取事件\nchannel 可写，会触发 write 事件\n在 linux 下 nio bug 发生时\n\n\n调用 selector.wakeup()\n调用 selector.close()\nselector 所在线程 interrupt\n\n4.3 处理 accept 事件客户端代码为\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        try (Socket socket &#x3D; new Socket(&quot;localhost&quot;, 8080)) &#123;\n            System.out.println(socket);\n            socket.getOutputStream().write(&quot;world&quot;.getBytes());\n            System.in.read();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n\n服务器端代码为\n@Slf4j\npublic class ChannelDemo6 &#123;\n    public static void main(String[] args) &#123;\n        try (ServerSocketChannel channel &#x3D; ServerSocketChannel.open()) &#123;\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector &#x3D; Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) &#123;\n                int count &#x3D; selector.select();\n&#x2F;&#x2F;                int count &#x3D; selector.selectNow();\n                log.debug(&quot;select count: &#123;&#125;&quot;, count);\n&#x2F;&#x2F;                if(count &lt;&#x3D; 0) &#123;\n&#x2F;&#x2F;                    continue;\n&#x2F;&#x2F;                &#125;\n\n                &#x2F;&#x2F; 获取所有事件\n                Set&lt;SelectionKey&gt; keys &#x3D; selector.selectedKeys();\n\n                &#x2F;&#x2F; 遍历所有事件，逐一处理\n                Iterator&lt;SelectionKey&gt; iter &#x3D; keys.iterator();\n                while (iter.hasNext()) &#123;\n                    SelectionKey key &#x3D; iter.next();\n                    &#x2F;&#x2F; 判断事件类型\n                    if (key.isAcceptable()) &#123;\n                        ServerSocketChannel c &#x3D; (ServerSocketChannel) key.channel();\n                        &#x2F;&#x2F; 必须处理\n                        SocketChannel sc &#x3D; c.accept();\n                        log.debug(&quot;&#123;&#125;&quot;, sc);\n                    &#125;\n                    &#x2F;&#x2F; 处理完毕，必须将事件移除\n                    iter.remove();\n                &#125;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n\n💡 事件发生后能否不处理\n\n\n\n\n\n\n\n\n事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 【nio 底层使用的是水平触发？？？】\n4.4 处理 read 事件@Slf4j\npublic class ChannelDemo6 &#123;\n    public static void main(String[] args) &#123;\n        try (ServerSocketChannel channel &#x3D; ServerSocketChannel.open()) &#123;\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector &#x3D; Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) &#123;\n                int count &#x3D; selector.select();\n&#x2F;&#x2F;                int count &#x3D; selector.selectNow();\n                log.debug(&quot;select count: &#123;&#125;&quot;, count);\n&#x2F;&#x2F;                if(count &lt;&#x3D; 0) &#123;\n&#x2F;&#x2F;                    continue;\n&#x2F;&#x2F;                &#125;\n\n                &#x2F;&#x2F; 获取所有事件\n                Set&lt;SelectionKey&gt; keys &#x3D; selector.selectedKeys();\n\n                &#x2F;&#x2F; 遍历所有事件，逐一处理\n                Iterator&lt;SelectionKey&gt; iter &#x3D; keys.iterator();\n                while (iter.hasNext()) &#123;\n                    SelectionKey key &#x3D; iter.next();\n                    &#x2F;&#x2F; 判断事件类型\n                    if (key.isAcceptable()) &#123;\n                        ServerSocketChannel c &#x3D; (ServerSocketChannel) key.channel();\n                        &#x2F;&#x2F; 必须处理\n                        SocketChannel sc &#x3D; c.accept();\n                        sc.configureBlocking(false);\n                        sc.register(selector, SelectionKey.OP_READ);\n                        log.debug(&quot;连接已建立: &#123;&#125;&quot;, sc);\n                    &#125; else if (key.isReadable()) &#123;\n                        SocketChannel sc &#x3D; (SocketChannel) key.channel();\n                        ByteBuffer buffer &#x3D; ByteBuffer.allocate(128);\n                        int read &#x3D; sc.read(buffer);\n                        if(read &#x3D;&#x3D; -1) &#123;\n                            key.cancel();\n                            sc.close();\n                        &#125; else &#123;\n                            buffer.flip();\n                            debug(buffer);\n                        &#125;\n                    &#125;\n                    &#x2F;&#x2F; 处理完毕，必须将事件移除\n                    iter.remove();\n                &#125;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n开启两个客户端，修改一下发送文字，输出\nsun.nio.ch.ServerSocketChannelImpl[&#x2F;0:0:0:0:0:0:0:0:8080]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60367]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60378]\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 6f 72 6c 64                                  |world           |\n+--------+-------------------------------------------------+----------------+\n\n\n\n💡 为何要 iter.remove()\n\n\n\n\n\n\n\n\n因为 select 在事件发生后，就[会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除]。例如\n\n第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey \n第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\n\n💡 cancel 的作用\n\n\n\n\n\n\n\n\ncancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件\n⚠️  不处理边界的问题以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的\npublic class Server &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket ss&#x3D;new ServerSocket(9000);\n        while (true) &#123;\n            Socket s &#x3D; ss.accept();\n            InputStream in &#x3D; s.getInputStream();\n            &#x2F;&#x2F; 这里这么写，有没有问题\n            byte[] arr &#x3D; new byte[4];\n            while(true) &#123;\n                int read &#x3D; in.read(arr);\n                &#x2F;&#x2F; 这里这么写，有没有问题\n                if(read &#x3D;&#x3D; -1) &#123;\n                    break;\n                &#125;\n                System.out.println(new String(arr, 0, read));\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n客户端\npublic class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Socket max &#x3D; new Socket(&quot;localhost&quot;, 9000);\n        OutputStream out &#x3D; max.getOutputStream();\n        out.write(&quot;hello&quot;.getBytes());\n        out.write(&quot;world&quot;.getBytes());\n        out.write(&quot;你好&quot;.getBytes());\n        max.close();\n    &#125;\n&#125;\n\n输出\nhell\nowor\nld�\n�好\n\n\n为什么？\n处理消息的边界！！！\n\n一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽\n另一种思路是按分隔符拆分，缺点是效率低\nTLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量\nHttp 1.1 是 TLV 格式 content-type\tcontent-length\nHttp 2.0 是 LTV 格式\n\n\n\n\nif不扩容，会分成两次，局部变量buffer被覆盖：\n\nbuffer扩容：\nsequenceDiagram \nparticipant c1 as 客户端1\nparticipant s as 服务器\nparticipant b1 as ByteBuffer1\nparticipant b2 as ByteBuffer2\nc1 -&gt;&gt; s: 发送 01234567890abcdef3333\\r\ns -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef\ns -&gt;&gt; b2: 扩容\nb1 -&gt;&gt; b2: 拷贝 01234567890abcdef\ns -&gt;&gt; b2: 第二次 read 存入 3333\\r\nb2 -&gt;&gt; b2: 01234567890abcdef3333\\r\n\n服务器端Server\tTestByteBufferExam.split\t分隔符匹配拆分法\nprivate static void split(ByteBuffer source) &#123;\n    source.flip();\n    for (int i &#x3D; 0; i &lt; source.limit(); i++) &#123;\n        &#x2F;&#x2F; 找到一条完整消息\n        if (source.get(i) &#x3D;&#x3D; &#39;\\n&#39;) &#123;\n            int length &#x3D; i + 1 - source.position();\n            &#x2F;&#x2F; 把这条完整消息存入新的 ByteBuffer\n            ByteBuffer target &#x3D; ByteBuffer.allocate(length);\n            &#x2F;&#x2F; 从 source 读，向 target 写\n            for (int j &#x3D; 0; j &lt; length; j++) &#123;\n                target.put(source.get());\n            &#125;\n            debugAll(target);\n        &#125;\n    &#125;\n    source.compact(); &#x2F;&#x2F; 0123456789abcdef  position 16 limit 16\n&#125;\n\npublic static void main(String[] args) throws IOException &#123;\n    &#x2F;&#x2F; 1. 创建 selector, 管理多个 channel\n    Selector selector &#x3D; Selector.open();\n    ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    &#x2F;&#x2F; 2. 建立 selector 和 channel 的联系（注册）\n    &#x2F;&#x2F; SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件\n    SelectionKey sscKey &#x3D; ssc.register(selector, 0, null);\n    &#x2F;&#x2F; key 只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    log.debug(&quot;sscKey:&#123;&#125;&quot;, sscKey);\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) &#123;\n        &#x2F;&#x2F; 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行\n        &#x2F;&#x2F; select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理\n        selector.select();\n        &#x2F;&#x2F; 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n        Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator(); &#x2F;&#x2F; accept, read\n        while (iter.hasNext()) &#123;\n            SelectionKey key &#x3D; iter.next();\n            &#x2F;&#x2F; 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题\n            iter.remove();\n            log.debug(&quot;key: &#123;&#125;&quot;, key);\n            &#x2F;&#x2F; 5. 区分事件类型\n            if (key.isAcceptable()) &#123; &#x2F;&#x2F; 如果是 accept\n                ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();\n                SocketChannel sc &#x3D; channel.accept();\n                sc.configureBlocking(false);\n                ByteBuffer buffer &#x3D; ByteBuffer.allocate(16); &#x2F;&#x2F; attachment\n                &#x2F;&#x2F; 将一个 byteBuffer 作为附件关联到 selectionKey 上\n                SelectionKey scKey &#x3D; sc.register(selector, 0, buffer);\n                scKey.interestOps(SelectionKey.OP_READ);\n                log.debug(&quot;&#123;&#125;&quot;, sc);\n                log.debug(&quot;scKey:&#123;&#125;&quot;, scKey);\n            &#125; else if (key.isReadable()) &#123; &#x2F;&#x2F; 如果是 read\n                try &#123;\n                    SocketChannel channel &#x3D; (SocketChannel) key.channel(); &#x2F;&#x2F; 拿到触发事件的channel\n                    &#x2F;&#x2F; 获取 selectionKey 上关联的附件\n                    ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();\n                    int read &#x3D; channel.read(buffer); &#x2F;&#x2F; 如果是正常断开，read 的方法的返回值是 -1\n                    if(read &#x3D;&#x3D; -1) &#123;\n                        key.cancel();\n                    &#125; else &#123;\n                        split(buffer);&#x2F;&#x2F;\n                        &#x2F;&#x2F; 需要扩容\n                        if (buffer.position() &#x3D;&#x3D; buffer.limit()) &#123;\n                            ByteBuffer newBuffer &#x3D; ByteBuffer.allocate(buffer.capacity() * 2);\n                            buffer.flip();\n                            newBuffer.put(buffer); &#x2F;&#x2F; 0123456789abcdef3333\\n\n                            key.attach(newBuffer);\n                        &#125;\n                    &#125;\n\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                    key.cancel();  &#x2F;&#x2F; 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n客户端\nSocketChannel sc &#x3D; SocketChannel.open();\nsc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\nSocketAddress address &#x3D; sc.getLocalAddress();\n&#x2F;&#x2F; sc.write(Charset.defaultCharset().encode(&quot;hello\\nworld\\n&quot;));\nsc.write(Charset.defaultCharset().encode(&quot;0123\\n456789abcdef\\n&quot;));\nsc.write(Charset.defaultCharset().encode(&quot;0123456789abcdef3333\\n&quot;));\nSystem.in.read();\n\n\n\nnetty则可自适应扩缩容buffer大小，更加精细~\nByteBuffer 大小分配\n每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer【关联附件 attchment() attach(newBuffer)】\nByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer\n一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能【上例】，参考实现 http://tutorials.jenkov.com/java-performance/resizable-array.html\n另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗【eg：Netty中的CompositeByteBuffer！】\n\n\n\n4.5 处理 write 事件\tWriteServer&#x2F;Clientwhile处理该sc，其他sc来了处理不了！！！效率不高！\n\n一堆0：写缓冲区满了【转去：读】，没被消费，因为写不了！\n一次无法写完例子\n非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）\n用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略\n当消息处理器第一次写入消息时，才将 channel 注册到 selector 上\nselector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册\n如果不取消，会每次可写均会触发 write 事件\n\n\n\npublic class WriteServer &#123;\n\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        ssc.bind(new InetSocketAddress(8080));\n\n        Selector selector &#x3D; Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true) &#123;\n            selector.select();\n\n            Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\n            while (iter.hasNext()) &#123;\n                SelectionKey key &#x3D; iter.next();\n                iter.remove();\n                if (key.isAcceptable()) &#123;\n                    SocketChannel sc &#x3D; ssc.accept();\n                    sc.configureBlocking(false);\n                    SelectionKey sckey &#x3D; sc.register(selector, SelectionKey.OP_READ);\n                    &#x2F;&#x2F; 1. 向客户端发送内容\n                    StringBuilder sb &#x3D; new StringBuilder();\n                    for (int i &#x3D; 0; i &lt; 3000000; i++) &#123;\n                        sb.append(&quot;a&quot;);\n                    &#125;\n                    ByteBuffer buffer &#x3D; Charset.defaultCharset().encode(sb.toString());\n                    int write &#x3D; sc.write(buffer);\n                    &#x2F;&#x2F; 3. write 表示实际写了多少字节\n                    System.out.println(&quot;实际写入字节:&quot; + write);\n                    &#x2F;&#x2F; 4. 如果有剩余未读字节，才需要关注写事件\n                    if (buffer.hasRemaining()) &#123;\n                        &#x2F;&#x2F; read 1  write 4\n                        &#x2F;&#x2F; 在原有关注事件的基础上，多关注 写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        &#x2F;&#x2F; 把 buffer 作为附件加入 sckey\n                        sckey.attach(buffer);\n                    &#125;\n                &#125; else if (key.isWritable()) &#123;\n                    ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();\n                    SocketChannel sc &#x3D; (SocketChannel) key.channel();\n                    int write &#x3D; sc.write(buffer);\n                    System.out.println(&quot;实际写入字节:&quot; + write);\n                    if (!buffer.hasRemaining()) &#123; &#x2F;&#x2F; 写完了\n                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);\n                        key.attach(null);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n客户端\npublic class WriteClient &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Selector selector &#x3D; Selector.open();\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.configureBlocking(false);\n        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        int count &#x3D; 0;\n        while (true) &#123;\n            selector.select();\n            Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\n            while (iter.hasNext()) &#123;\n                SelectionKey key &#x3D; iter.next();\n                iter.remove();\n                if (key.isConnectable()) &#123;\n                    System.out.println(sc.finishConnect());\n                &#125; else if (key.isReadable()) &#123;\n                    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024 * 1024);\n                    count +&#x3D; sc.read(buffer);\n                    buffer.clear();\n                    System.out.println(count);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n💡 write 为何要取消只要向 channel 发送数据时，[socket 缓冲可写，这个事件会频繁触发]，因此应当[只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注]\n4.6 更进一步💡 利用多线程优化\n\n\n\n\n\n\n\n\n现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费\n前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？\n分两组选择器\n\n单线程配一个选择器，专门处理 accept 事件\n创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件\n\n\nduplicate line: ctrl+D\nmove line down: alt+shift+下\n\n新C又被阻，不可读！\npackage cn.itcast.nio.c4;\n\nimport javafx.concurrent.Worker;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static cn.itcast.nio.c2.ByteBufferUtil.debugAll;\n\n@Slf4j\npublic class MultiThreadServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Thread.currentThread().setName(&quot;boss&quot;);\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        Selector boss &#x3D; Selector.open();\n        SelectionKey bossKey &#x3D; ssc.register(boss, 0, null);\n        bossKey.interestOps(SelectionKey.OP_ACCEPT);\n        ssc.bind(new InetSocketAddress(8080));\n\n        &#x2F;&#x2F;static方法不能调用非static(成员)内部类！（还不存在！）\n        &#x2F;&#x2F; 1. 创建固定数量的 worker 并初始化\n        Worker[] workers &#x3D; new Worker[Runtime.getRuntime().availableProcessors()];\n        for (int i &#x3D; 0; i &lt; workers.length; i++) &#123;\n            workers[i] &#x3D; new Worker(&quot;worker-&quot; + i);\n        &#125;\n        AtomicInteger index &#x3D; new AtomicInteger();&#x2F;&#x2F;\n\n        while(true) &#123;\n            boss.select();\n            Iterator&lt;SelectionKey&gt; iter &#x3D; boss.selectedKeys().iterator();\n            while (iter.hasNext()) &#123;\n                SelectionKey key &#x3D; iter.next();\n                iter.remove();\n                if (key.isAcceptable()) &#123;\n                    SocketChannel sc &#x3D; ssc.accept();\n                    sc.configureBlocking(false);\n\n                    log.debug(&quot;connected...&#123;&#125;&quot;, sc.getRemoteAddress());\n                    &#x2F;&#x2F; 2. 关联 selector\n                    log.debug(&quot;before register...&#123;&#125;&quot;, sc.getRemoteAddress());\n                    &#x2F;&#x2F; round robin 轮询\n                    workers[index.getAndIncrement() % workers.length].register(sc); &#x2F;&#x2F;[1] boss 调用 初始化 selector , 启动 worker-0\n                    &#x2F;&#x2F; worker.register(sc);\n                    &#x2F;&#x2F; sc.register(worker.selector, SelectionKey.OP_READ, null); &#x2F;&#x2F; boss--&gt;应该下移到worker中！跨worker先后顺序不可控！\n                    log.debug(&quot;after register...&#123;&#125;&quot;, sc.getRemoteAddress());\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    static class Worker implements Runnable&#123;\n        private Thread thread;\n        private Selector selector;\n        private String name;\n        private volatile boolean start &#x3D; false; &#x2F;&#x2F; 还未初始化\n        private ConcurrentLinkedQueue&lt;Runnable&gt; queue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();\n        public Worker(String name) &#123;\n            this.name &#x3D; name;\n        &#125;\n\n        &#x2F;&#x2F; 初始化线程，和 selector\n        public void register(SocketChannel sc) throws IOException &#123;\n            if(!start) &#123;\n                selector &#x3D; Selector.open();\n                thread &#x3D; new Thread(this, name);\n                thread.start();\n                start &#x3D; true;\n            &#125;\n            selector.wakeup(); &#x2F;&#x2F; （1）唤醒 select 方法 boss  【(卖票)一次性，可先后，等fd】 goto-implement：WindowsSelectorImpl\n            sc.register(selector, SelectionKey.OP_READ, null); &#x2F;&#x2F; （2）boss   select不阻塞才能reg成功\n        &#125;\n\n        @Override\n        public void run() &#123;\n            while(true) &#123;\n                try &#123;\n                    selector.select(); &#x2F;&#x2F; （3）worker-0  阻塞 【(1、2)(3)3句顺序均OK！！！】\n                    Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\n                    while (iter.hasNext()) &#123;\n                        SelectionKey key &#x3D; iter.next();\n                        iter.remove();\n                        if (key.isReadable()) &#123;\n                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n                            SocketChannel channel &#x3D; (SocketChannel) key.channel();\n                            log.debug(&quot;read...&#123;&#125;&quot;, channel.getRemoteAddress());\n                            channel.read(buffer);\n                            buffer.flip();\n                            debugAll(buffer);\n                        &#125;\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n\n&#x2F;&#x2F;    static class Worker implements Runnable &#123;\n&#x2F;&#x2F;        private Thread thread;\n&#x2F;&#x2F;        private Selector selector;\n&#x2F;&#x2F;        private String name;\n&#x2F;&#x2F;        private volatile boolean start &#x3D; false; &#x2F;&#x2F;还未初始化\n&#x2F;&#x2F;        private ConcurrentLinkedQueue&lt;Runnable&gt; queue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();&#x2F;&#x2F;两线程间传递数据：ConcurrentLinkedQueue解耦！见P161！同netty做法！\n&#x2F;&#x2F;\n&#x2F;&#x2F;        public Worker(String name) &#123;\n&#x2F;&#x2F;            this.name &#x3D; name;\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;        &#x2F;&#x2F;[1] 初始化线程，和selector\n&#x2F;&#x2F;        public void register(SocketChannel sc) throws IOException &#123;\n&#x2F;&#x2F;            if(!start) &#123;&#x2F;&#x2F;first time!\n&#x2F;&#x2F;                selector &#x3D; Selector.open();\n&#x2F;&#x2F;                thread &#x3D; new Thread(this, name);\n&#x2F;&#x2F;                thread.start();&#x2F;&#x2F;[2]\n&#x2F;&#x2F;                start &#x3D; true;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;            &#x2F;&#x2F;[3.2] boss：向队列里添加了任务，但此任务并没有立刻执行！\n&#x2F;&#x2F;            queue.add(()-&gt;&#123;\n&#x2F;&#x2F;                try &#123;\n&#x2F;&#x2F;                    sc.register(selector, SelectionKey.OP_READ, null); &#x2F;&#x2F; 仍然是boss里执行！用ConcurrentLinkedQueue解耦\n&#x2F;&#x2F;                &#125; catch (ClosedChannelException e) &#123;\n&#x2F;&#x2F;                    e.printStackTrace();\n&#x2F;&#x2F;                &#125;\n&#x2F;&#x2F;            &#125;);\n&#x2F;&#x2F;            selector.wakeup(); &#x2F;&#x2F;[4] 唤醒 run()里的 selector.select() 方法\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;        @Override\n&#x2F;&#x2F;        public void run() &#123;&#x2F;&#x2F;[2]worker: new start!\n&#x2F;&#x2F;            while(true) &#123;\n&#x2F;&#x2F;                try &#123;\n&#x2F;&#x2F;                    selector.select();&#x2F;&#x2F;[3.1] worker-0 阻塞:等到事件发生(first:还没reg(read),等别的事件发生:晚) 被wakeup()主动唤醒:reg(read)\n&#x2F;&#x2F;                    Runnable task &#x3D; queue.poll();\n&#x2F;&#x2F;                    if(task !&#x3D; null) &#123;\n&#x2F;&#x2F;                        task.run();&#x2F;&#x2F;[5] worker:执行了 sc.register(selector, SelectionKey.OP_READ, null);\n&#x2F;&#x2F;                    &#125;\n&#x2F;&#x2F;                    Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\n&#x2F;&#x2F;                    while(iter.hasNext()) &#123;\n&#x2F;&#x2F;                        SelectionKey key &#x3D; iter.next();\n&#x2F;&#x2F;                        iter.remove();\n&#x2F;&#x2F;                        if(key.isReadable()) &#123;\n&#x2F;&#x2F;                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F;                            SocketChannel channel &#x3D; (SocketChannel) key.channel();\n&#x2F;&#x2F;                            log.debug(&quot;read...&#123;&#125;&quot;, channel.getRemoteAddress());\n&#x2F;&#x2F;                            channel.read(buffer);\n&#x2F;&#x2F;                            buffer.flip();\n&#x2F;&#x2F;                            debugAll(buffer);\n&#x2F;&#x2F;                            &#x2F;&#x2F; 细节：粘包半包，捉异常退出cancel，可多次写...\n&#x2F;&#x2F;                        &#125;\n&#x2F;&#x2F;                    &#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;                &#125; catch (IOException e) &#123;\n&#x2F;&#x2F;                    e.printStackTrace();\n&#x2F;&#x2F;                &#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;        &#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;    &#125;\n\n&#125;\n\n\n数组Worker[].length &#x2F;&#x2F;字段！！！\tstr.length()！！！\n① 对于Object中wait和notify：必须在锁中使用，这里指synchronized，并且wait方法要先于notify，否则wait方法会一直阻塞该该线程。\n② Lock中lock.newCondition:condition.await()和condition.signal()：必须在锁中使用，这里指lock.lock()之后，并且await方法要先于singnal，否则await方法会一直阻塞该该线程。\n为我们提供了一种方便的基于同一个锁， 实现多个条件的 wait() 和 notify() 操作。Condition接口把Object中的wait()、notify()和notifyAll()分解到了不同对象中，搭配上任意一种Lock使用，使得一个对象可以存在于多个等待集。\n\n③ LockSupport优势，优势1：类静态方法，不需要在锁中进行；优势二：park方法可以不先于unpark方法。\nhttps://blog.csdn.net/weixin_44601714/article/details/100081131\n其他线程如果因为调用了selector.select()或者selector.select(long)这两个方法而阻塞， 调用了selector.wakeup()之后，就会立即返回结果，并且返回的值!&#x3D;0， 如果当前Selector没有阻塞在select方法上， 那么本次 wakeup调用会在下一次select阻塞(可以不先于)的时候生效。\nselect()方法会阻塞，是因为用户态将socket的文件描述符和感兴趣的事件传递给操作系统底层的pipe？，底层函数【执行完成，触发事件之后底层就会向用户态返回数据】，这样才会打破阻塞\n\npublic Selector wakeup() &#123;\n    synchronized(this.interruptLock) &#123;\n        if (!this.interruptTriggered) &#123;\n            this.setWakeupSocket();\n            this.interruptTriggered &#x3D; true;\n        &#125;\n\n        return this;\n    &#125;\n&#125;\n&#x2F;&#x2F;这里追到了native方法\nprivate native void setWakeupSocket0(int var1);\n\nsetWakeupSocket()方法 会直接向pipe中添加wakeupSinkFD，这个FD会立即执行完成并且返回数据，这样底层就会给用户态数据，然后结束阻塞\npublic class ChannelDemo7 &#123;\n    public static void main(String[] args) throws IOException &#123;\n        new BossEventLoop().register();\n    &#125;\n\n\n    @Slf4j\n    static class BossEventLoop implements Runnable &#123;\n        private Selector boss;\n        private WorkerEventLoop[] workers;\n        private volatile boolean start &#x3D; false;\n        AtomicInteger index &#x3D; new AtomicInteger();\n\n        public void register() throws IOException &#123;\n            if (!start) &#123;\n                ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n                ssc.bind(new InetSocketAddress(8080));\n                ssc.configureBlocking(false);\n                boss &#x3D; Selector.open();\n                SelectionKey ssckey &#x3D; ssc.register(boss, 0, null);\n                ssckey.interestOps(SelectionKey.OP_ACCEPT);\n                workers &#x3D; initEventLoops();\n                new Thread(this, &quot;boss&quot;).start();\n                log.debug(&quot;boss start...&quot;);\n                start &#x3D; true;\n            &#125;\n        &#125;\n\n        public WorkerEventLoop[] initEventLoops() &#123;\n&#x2F;&#x2F;        EventLoop[] eventLoops &#x3D; new EventLoop[Runtime.getRuntime().availableProcessors()];\n            WorkerEventLoop[] workerEventLoops &#x3D; new WorkerEventLoop[2];\n            for (int i &#x3D; 0; i &lt; workerEventLoops.length; i++) &#123;\n                workerEventLoops[i] &#x3D; new WorkerEventLoop(i);\n            &#125;\n            return workerEventLoops;\n        &#125;\n\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                try &#123;\n                    boss.select();\n                    Iterator&lt;SelectionKey&gt; iter &#x3D; boss.selectedKeys().iterator();\n                    while (iter.hasNext()) &#123;\n                        SelectionKey key &#x3D; iter.next();\n                        iter.remove();\n                        if (key.isAcceptable()) &#123;\n                            ServerSocketChannel c &#x3D; (ServerSocketChannel) key.channel();\n                            SocketChannel sc &#x3D; c.accept();\n                            sc.configureBlocking(false);\n                            log.debug(&quot;&#123;&#125; connected&quot;, sc.getRemoteAddress());\n                            workers[index.getAndIncrement() % workers.length].register(sc);\n                        &#125;\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    @Slf4j\n    static class WorkerEventLoop implements Runnable &#123;\n        private Selector worker;\n        private volatile boolean start &#x3D; false;\n        private int index;\n\n        private final ConcurrentLinkedQueue&lt;Runnable&gt; tasks &#x3D; new ConcurrentLinkedQueue&lt;&gt;();\n\n        public WorkerEventLoop(int index) &#123;\n            this.index &#x3D; index;\n        &#125;\n\n        public void register(SocketChannel sc) throws IOException &#123;\n            if (!start) &#123;\n                worker &#x3D; Selector.open();\n                new Thread(this, &quot;worker-&quot; + index).start();\n                start &#x3D; true;\n            &#125;\n            tasks.add(() -&gt; &#123;\n                try &#123;\n                    SelectionKey sckey &#x3D; sc.register(worker, 0, null);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    worker.selectNow();&#x2F;&#x2F;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;);\n            worker.wakeup();\n        &#125;\n\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                try &#123;\n                    worker.select();\n                    Runnable task &#x3D; tasks.poll();\n                    if (task !&#x3D; null) &#123;\n                        task.run();\n                    &#125;\n                    Set&lt;SelectionKey&gt; keys &#x3D; worker.selectedKeys();\n                    Iterator&lt;SelectionKey&gt; iter &#x3D; keys.iterator();\n                    while (iter.hasNext()) &#123;\n                        SelectionKey key &#x3D; iter.next();\n                        if (key.isReadable()) &#123;\n                            SocketChannel sc &#x3D; (SocketChannel) key.channel();\n                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(128);\n                            try &#123;\n                                int read &#x3D; sc.read(buffer);\n                                if (read &#x3D;&#x3D; -1) &#123;\n                                    key.cancel();\n                                    sc.close();\n                                &#125; else &#123;\n                                    buffer.flip();\n                                    log.debug(&quot;&#123;&#125; message:&quot;, sc.getRemoteAddress());\n                                    debugAll(buffer);\n                                &#125;\n                            &#125; catch (IOException e) &#123;\n                                e.printStackTrace();\n                                key.cancel();\n                                sc.close();\n                            &#125;\n                        &#125;\n                        iter.remove();\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n💡 如何拿到 cpu 个数\n\n\n\n\n\n\n\n\n\nRuntime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数\tjdk8下部署，最好手动指定几核！\n这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启\n\nCPU计算密集型：核心数、IO密集型：THs&gt;核数 Amdahl定律：\n\n 串行部分\n 并行部分\n 核数\n\n4.7 UDP\nUDP 是无连接的，client 发送数据不会管 server 是否开启\nserver 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃\n\n首先启动服务器端\npublic class UdpServer &#123;\n    public static void main(String[] args) &#123;\n        try (DatagramChannel channel &#x3D; DatagramChannel.open()) &#123;\n            channel.socket().bind(new InetSocketAddress(9999));&#x2F;&#x2F;\n            System.out.println(&quot;waiting...&quot;);\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(32);\n            channel.receive(buffer);&#x2F;&#x2F;\n            buffer.flip();\n            debug(buffer);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n输出\nwaiting...\n\n\n\n运行客户端\npublic class UdpClient &#123;\n    public static void main(String[] args) &#123;\n        try (DatagramChannel channel &#x3D; DatagramChannel.open()) &#123;\n            ByteBuffer buffer &#x3D; StandardCharsets.UTF_8.encode(&quot;hello&quot;);\n            InetSocketAddress address &#x3D; new InetSocketAddress(&quot;localhost&quot;, 9999);\n            channel.send(buffer, address);&#x2F;&#x2F;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n接下来服务器端输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n\n\n\n\n\n5. NIO vs BIO5.1 stream vs channel\nstream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\nstream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\n二者均为全双工，即读写可以同时进行？？？\n\n5.2 IO 模型&#x3D;&#x3D;同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞&#x3D;&#x3D;\n\n同步：线程自己去获取结果（一个线程）\n异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）\n\n当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\n\n等待数据阶段\n复制数据阶段\n\n\n\n阻塞 IO\n\n\n非阻塞  IO    两态切换过于频繁\n\n\n多路复用\n\n\n阻塞 IO[串行] vs 多路复用[一次性拿到一批events，循环分类处理]\n\n\n\n信号驱动\n\n异步 IO    th1定义了回调直接返回，th2调用回调函数，填入参，送结果\n\n\n\n\n\n🔖 参考UNIX 网络编程 - 卷 I\n5.3 零拷贝传统 IO 问题传统的 IO 将一个文件通过 socket 写出\nFile f &#x3D; new File(&quot;helloword&#x2F;data.txt&quot;);\nRandomAccessFile file &#x3D; new RandomAccessFile(file, &quot;r&quot;);\n\nbyte[] buf &#x3D; new byte[(int)f.length()];\nfile.read(buf);&#x2F;&#x2F;12\n\nSocket socket &#x3D; ...;\nsocket.getOutputStream().write(buf);&#x2F;&#x2F;34\n\n内部工作流程是这样的：\n\n\njava 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的用户态切换至内核态，去调用操作系统（Kernel）的读能力，将数据读入内核缓冲区。这期间【用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu】\n\n\n\n\n\n\n\n\n\nDMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\n\n从内核态切换回用户态，将数据从内核缓冲区读入用户缓冲区（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA\n\n调用 write 方法，这时将数据从用户缓冲区（byte[] buf）写入 socket 缓冲区，cpu 会参与拷贝\n\n接下来要向网卡写数据，这项能力 java 又不具备，因此又得从用户态切换至内核态，调用操作系统的写能力，【使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu】\n\n\n可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\n\n用户态与内核态的切换发生了 3 次，这个操作比较重量级\n数据拷贝了共 4 次\n\nNIO 优化通过 &#x3D;&#x3D;DirectByteBuf&#x3D;&#x3D;\n\nByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存\nByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存\n\n\n大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使&#x3D;&#x3D;用 DirectByteBuf 将【堆外内存映射到 jvm 内存中来直接访问】使用&#x3D;&#x3D;\n\n&#x3D;&#x3D;这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写&#x3D;&#x3D;\njava 中的 &#x3D;&#x3D;DirectByteBuf 对象仅维护了此内存的虚引用&#x3D;&#x3D;，内存回收分成两步\nDirectByteBuf 对象被垃圾回收，将[虚引用加入引用队列]\n通过&#x3D;&#x3D;专门线程访问引用队列，根据虚引用释放堆外内存&#x3D;&#x3D;\n\n\n只减少了一次数据拷贝，用户态与内核态的切换次数没有减少\n\n进一步优化（底层采用了 &#x3D;&#x3D;linux 2.1&#x3D;&#x3D; 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo&#x2F;transferFrom 方法拷贝数据\n\n\njava 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu\n数据从内核缓冲区传输到 socket 缓冲区，【cpu 会参与拷贝】\n最后使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu\n\n可以看到\n\n只发生了一次用户态与内核态的切换\n数据拷贝了 3 次\n\n进一步优化&#x3D;&#x3D;（linux 2.4）&#x3D;&#x3D;\n\n\njava 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu\n只会将一些&#x3D;&#x3D;【offset 和 length 信息】拷入 socket 缓冲区，几乎无消耗&#x3D;&#x3D;\n使用 DMA 将 内核缓冲区的数据写入网卡，不会使用 cpu\n\n整个过程&#x3D;&#x3D;仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次&#x3D;&#x3D;。所谓的【零拷贝】，并不是真正无拷贝，而是【不会再拷贝重复数据到 jvm 内存中】，零拷贝的优点有\n\n更少的用户态与内核【态的切换】\n【不利用 cpu 计算】，&#x3D;&#x3D;减少 cpu 缓存伪共享&#x3D;&#x3D;\n零拷贝适合小文件传输【缓冲区，反复RW：小文件！】\n\n5.3 AIOAIO 用来解决数据复制阶段的阻塞问题\n\n同步意味着，在进行读写操作时，线程需要等待结果，还是相当于[闲置]\n异步意味着，在进行读写操作时，线程[不必等待]结果，而是[将来由操作系统来通过回调方式由另外的线程来获得结果]\n\n\n\n\n\n\n\n\n\n\n异步模型需要底层操作系统（Kernel）提供支持\n\n&#x3D;&#x3D;Windows 系统通过 IOCP 实现了真正的异步 IO？？？&#x3D;&#x3D;(I&#x2F;O Completion Port,I&#x2F;O完成端口) 线程池。。。\nLinux 系统异步 IO 在 【2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势，且引入不必要的复杂性。】 Netty5基于此的API也被废弃了，目前最新就用Netty4！\n\n文件 AIO先来看看 AsynchronousFileChannel\n@Slf4j\npublic class AioDemo1 &#123;\n    public static void main(String[] args) throws IOException &#123;\n        try&#123;\n            AsynchronousFileChannel s &#x3D; \n                AsynchronousFileChannel.open(\n                \tPaths.get(&quot;1.txt&quot;), StandardOpenOption.READ);\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(2);\n            log.debug(&quot;begin...&quot;);\n            s.read(buffer, 0, null, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) &#123;\n                    log.debug(&quot;read completed...&#123;&#125;&quot;, result);\n                    buffer.flip();\n                    debug(buffer);\n                &#125;\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) &#123;\n                    log.debug(&quot;read failed...&quot;);\n                &#125;\n            &#125;);\n\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        log.debug(&quot;do other things...&quot;);\n        System.in.read();&#x2F;&#x2F;\n    &#125;\n&#125;\n\n输出\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...\n13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0d                                           |a.              |\n+--------+-------------------------------------------------+----------------+\n\n可以看到\n\n响应文件读取成功的是另一个线程 Thread-5\n主线程并没有 IO 操作阻塞\n\n💡 守护线程&#x3D;&#x3D;&#x3D;默认文件 AIO 使用的线程都是守护线程，所以最后要执行 System.in.read() 以避免守护线程意外结束&#x3D;&#x3D;\n网络 AIOpublic class AioServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        AsynchronousServerSocketChannel ssc &#x3D; AsynchronousServerSocketChannel.open();\n        ssc.bind(new InetSocketAddress(8080));\n        ssc.accept(null, new AcceptHandler(ssc));\n        System.in.read();\n    &#125;\n\n    private static void closeChannel(AsynchronousSocketChannel sc) &#123;\n        try &#123;\n            System.out.printf(&quot;[%s] %s close\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());\n            sc.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    private static class ReadHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;\n        private final AsynchronousSocketChannel sc;\n\n        public ReadHandler(AsynchronousSocketChannel sc) &#123;\n            this.sc &#x3D; sc;\n        &#125;\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) &#123;\n            try &#123;\n                if (result &#x3D;&#x3D; -1) &#123;\n                    closeChannel(sc);\n                    return;\n                &#125;\n                System.out.printf(&quot;[%s] %s read\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());\n                attachment.flip();\n                System.out.println(Charset.defaultCharset().decode(attachment));\n                attachment.clear();\n                &#x2F;&#x2F; 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件\n                sc.read(attachment, attachment, this);\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) &#123;\n            closeChannel(sc);\n            exc.printStackTrace();\n        &#125;\n    &#125;\n\n    private static class WriteHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;\n        private final AsynchronousSocketChannel sc;\n\n        private WriteHandler(AsynchronousSocketChannel sc) &#123;\n            this.sc &#x3D; sc;\n        &#125;\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) &#123;\n            &#x2F;&#x2F; 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容\n            if (attachment.hasRemaining()) &#123;\n                sc.write(attachment);\n            &#125;\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) &#123;\n            exc.printStackTrace();\n            closeChannel(sc);\n        &#125;\n    &#125;\n\n    private static class AcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; &#123;\n        private final AsynchronousServerSocketChannel ssc;\n\n        public AcceptHandler(AsynchronousServerSocketChannel ssc) &#123;\n            this.ssc &#x3D; ssc;\n        &#125;\n\n        @Override\n        public void completed(AsynchronousSocketChannel sc, Object attachment) &#123;\n            try &#123;\n                System.out.printf(&quot;[%s] %s connected\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n            &#x2F;&#x2F; 读事件由 ReadHandler 处理\n            sc.read(buffer, buffer, new ReadHandler(sc));\n            &#x2F;&#x2F; 写事件由 WriteHandler 处理\n            sc.write(Charset.defaultCharset().encode(&quot;server hello!&quot;), ByteBuffer.allocate(16), new WriteHandler(sc));\n            &#x2F;&#x2F; 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件\n            ssc.accept(null, this);\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, Object attachment) &#123;\n            exc.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n二. Netty 入门1. 概述1.1 Netty 是什么？Netty is an asynchronous event-driven network application framework\nfor rapid development of maintainable high performance protocol servers &amp; clients.\n\nNetty 是一个[调用时]异步的[用多线程将方法调用与处理结果相分离]、基于事件驱动[IO模型还是selector多路复用]的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端\n1.2 Netty 的作者\n他还是另一个著名网络应用框架 Apache Mina 的重要贡献者\n1.3 Netty 的地位Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位\n以下的框架都使用了 Netty，因为它们有网络通信需求！\n\nCassandra - nosql 数据库\nSpark - 大数据分布式[计算]框架\nHadoop - 大数据分布式[存储]框架\nRocketMQ - ali 开源的消息队列\nElasticSearch - 搜索引擎\ngRPC - rpc 框架\nDubbo - rpc 框架\nSpring 5.x - flux api (WebFlux) 完全抛弃了 tomcat ，使用 netty 作为服务器端\nZookeeper - 分布式协调框架\n\n1.4 Netty 的优势\nNetty vs NIO，工作量大，bug 多\n需要自己构建协议\n解决 TCP 传输问题，如粘包、半包\nepoll 空轮询导致 CPU 100%\n对 API 进行增强，使之更易用，如 [FastThreadLocal] &#x3D;&gt; ThreadLocal，[ByteBuf] &#x3D;&gt; ByteBuffer\n\n\nNetty vs 其它网络应用框架\nMina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀\n久经考验，16年，Netty 版本\n2.x 2004\n3.x 2008\n4.x 2013\n5.x 已废弃（没有明显的性能提升，维护成本高）\n\n\n\n\n\n2. Hello World2.1 目标开发一个简单的服务器端和客户端\n\n客户端向服务器端发送 hello, world\n服务器仅接收，不返回\n\n加入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.1.39.Final&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n\n2.2 服务器端new ServerBootstrap()\n    .group(new NioEventLoopGroup()) &#x2F;&#x2F; 1\n    .channel(NioServerSocketChannel.class) &#x2F;&#x2F; 2\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; &#x2F;&#x2F; 3\n        protected void initChannel(NioSocketChannel ch) &#123;\n            ch.pipeline().addLast(new StringDecoder()); &#x2F;&#x2F; 5\n            ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123; &#x2F;&#x2F; 6\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;\n                    System.out.println(msg);\n                &#125;\n            &#125;);\n        &#125;\n    &#125;)\n    .bind(8080); &#x2F;&#x2F; 4\n\n代码解读\n\n1 处，创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector 后面会详细展开\n\n2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有\n\n\n3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n\n4 处，ServerSocketChannel 绑定的监听端口\n\n5 处，SocketChannel 的处理器，解码 ByteBuf &#x3D;&gt; String\n\n6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果\n\n\n2.3 客户端new Bootstrap()\n    .group(new NioEventLoopGroup()) &#x2F;&#x2F; 1\n    .channel(NioSocketChannel.class) &#x2F;&#x2F; 2\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123; &#x2F;&#x2F; 3\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder()); &#x2F;&#x2F; 8\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080) &#x2F;&#x2F; 4\n    .sync() &#x2F;&#x2F; 5\n    .channel() &#x2F;&#x2F; 6\n    .writeAndFlush(new Date() + &quot;: hello world!&quot;); &#x2F;&#x2F; 7\n\n代码解读\n\n1 处，创建 NioEventLoopGroup，同 Server\n\n2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有\n\n\n3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n\n4 处，指定要连接的服务器和端口\n\n5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕\n\n6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n\n7 处，写入消息并清空缓冲区\n\n8 处，消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 发出\n\n数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程\n\n\n2.4 流程梳理\nfilter、interceptor、handler\t责任链\n💡 提示\n\n\n\n\n\n\n\n\n一开始需要树立正确的观念\n\n把 channel 理解为数据的通道\n把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf\n把 handler 理解为数据的处理工序\n工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）\nhandler 分 Inbound (-&gt;mem)和 Outbound (-&gt;C)两类\n\n\n把 eventLoop 理解为处理数据的工人【单th池】\n工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定：TH安全）\n工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务\n工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序（非IO操作的任务）指定不同的工人\n\n\n\n3. 组件3.1 EventLoop&#x3D;包装的Selector事件循环对象\nEventLoop 本质是一个&#x3D;&#x3D;单线程执行器[任务队列]（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 【io】 事件。&#x3D;&#x3D;\n它的继承关系比较复杂\n\n一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\n另一条线是继承自 netty 自己的 OrderedEventExecutor，【保证 io 顺序】\n提供了 boolean inEventLoop(Thread thread) 方法【判断一个线程是否属于此 EventLoop】\n提供了 parent 方法来看看【自己属于哪个 EventLoopGroup】\n\n\n\n事件循环组\nEventLoopGroup 是一组 EventLoop，&#x3D;&#x3D;【Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）】&#x3D;&#x3D;\n\n继承自 netty 自己的 EventExecutorGroup\n实现了 Iterable 接口提供遍历 EventLoop 的能力\n另有 next 方法获取集合中下一个 EventLoop\n\n\n\n以一个简单的实现为例：\n&#x2F;&#x2F; 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程\nDefaultEventLoopGroup group &#x3D; new DefaultEventLoopGroup(2);\nSystem.out.println(group.next());\nSystem.out.println(group.next());\nSystem.out.println(group.next());\n\n输出\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\nio.netty.channel.DefaultEventLoop@60f82f98\n\n也可以使用 for 循环\nDefaultEventLoopGroup group &#x3D; new DefaultEventLoopGroup(2);\nfor (EventExecutor eventLoop : group) &#123;\n    System.out.println(eventLoop);\n&#125;\n\n输出\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\n\n\n\nprivate static final int DEFAULT_EVENT_LOOP_THREADS &#x3D; Math.max(1, SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));&#x2F;&#x2F;默认线程数：配置，2倍核数，0-&gt;1\n\n\n\n演示 NioEventLoop 处理 io 事件服务器端两个 nio worker 工人\tnetty.c3.EventLoopServer\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(NioSocketChannel ch) &#123;\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    ByteBuf byteBuf &#x3D; msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf !&#x3D; null) &#123;\n                        byte[] buf &#x3D; new byte[16];\n                        ByteBuf len &#x3D; byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    &#125;\n                &#125;\n            &#125;);\n        &#125;\n    &#125;).bind(8080).sync();\n\n\n\nEventLoopClient\n客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\npublic static void main(String[] args) throws InterruptedException &#123;\n    Channel channel &#x3D; new Bootstrap()\n            .group(new NioEventLoopGroup(1))\n            .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n                    System.out.println(&quot;init...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                &#125;\n            &#125;)\n            .channel(NioSocketChannel.class).connect(&quot;localhost&quot;, 8080)\n            .sync()\n            .channel();\n\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;wangwu&quot;.getBytes()));\n    Thread.sleep(2000);\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;wangwu&quot;.getBytes()));\n\n最后输出\n22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        \n22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         \n\n可以看到两个EventLoop工人轮流处理 channel，但工人与 channel 之间进行了绑定\n\nhandler…\n再增加两个非 nio 工人\tEventLoopServer\nDefaultEventLoopGroup normalWorkers &#x3D; new DefaultEventLoopGroup(2);&#x2F;&#x2F;非nio\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))&#x2F;&#x2F;\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(NioSocketChannel ch)  &#123;\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));&#x2F;&#x2F;\n            ch.pipeline().addLast(normalWorkers,&quot;myhandler&quot;,\n              new ChannelInboundHandlerAdapter() &#123;&#x2F;&#x2F;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    ByteBuf byteBuf &#x3D; msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf !&#x3D; null) &#123;\n                        byte[] buf &#x3D; new byte[16];\n                        ByteBuf len &#x3D; byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    &#125;\n                &#125;\n            &#125;);\n        &#125;\n    &#125;).bind(8080).sync();\n\n\n\n\n\n\n\npackage cn.itcast.netty.c3;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.nio.charset.Charset;\n\n@Slf4j\npublic class EventLoopServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 细分2：创建一个独立的 EventLoopGroup\n        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();\n        new ServerBootstrap()\n                &#x2F;&#x2F; boss 和 worker\n                &#x2F;&#x2F; 细分1：boss 只负责 ServerSocketChannel 上 accept 事件     worker 只负责 socketChannel 上的读写\n                .group(new NioEventLoopGroup(), new NioEventLoopGroup(2))&#x2F;&#x2F;默认2*CPUs\n                .channel(NioServerSocketChannel.class)&#x2F;&#x2F;only one!\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n                        ch.pipeline().addLast(&quot;handler1&quot;, new ChannelInboundHandlerAdapter() &#123;&#x2F;&#x2F;io事件\n                            @Override                                         &#x2F;&#x2F; ByteBuf\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                log.debug(buf.toString(Charset.defaultCharset()));\n                                ctx.fireChannelRead(msg); &#x2F;&#x2F; 让消息传递给下一个handler！\n                            &#125;\n                        &#125;);\n                        &#x2F;*.addLast(group, &quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;&#x2F;&#x2F;普通任务\n                            @Override                                         &#x2F;&#x2F; ByteBuf\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                log.debug(buf.toString(Charset.defaultCharset()));\n                            &#125;\n                        &#125;);*&#x2F;\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;\n\n\n客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n输出\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] REGISTERED\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] ACTIVE\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] READ COMPLETE\n22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52588] READ COMPLETE\n22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] REGISTERED\n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] ACTIVE\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] READ COMPLETE\n22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52612] READ COMPLETE\n22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] REGISTERED\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] ACTIVE\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] READ COMPLETE\n22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52625] READ COMPLETE\n22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n\n可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）\n\n一个长channelRead会拖慢绑定在worker上监测的其他所有channel的io处理！\n创建独立的DefaultEventLoopGroup：只处理普通&#x2F;定时任务，不处理io事件！\n💡 handler 执行中如何换人？关键代码 io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()\nstatic void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;\n    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);\n    &#x2F;&#x2F; 下一个 handler 的事件循环是否与当前的事件循环是同一个线程\n    EventExecutor executor &#x3D; next.executor();\n    \n    &#x2F;&#x2F; 是，直接调用\n    if (executor.inEventLoop()) &#123;\n        next.invokeChannelRead(m);\n    &#125; \n    &#x2F;&#x2F; 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）\n    else &#123;\n        executor.execute(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                next.invokeChannelRead(m);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n\n如果两个 handler 绑定的是同一个线程，那么就直接调用\n否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用\n\n演示 NioEventLoop 处理普通任务NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务\nNioEventLoopGroup nioWorkers &#x3D; new NioEventLoopGroup(2);\n\nlog.debug(&quot;server start...&quot;);\nThread.sleep(2000);\nnioWorkers.execute(()-&gt;&#123; &#x2F;&#x2F; 或submit\n    log.debug(&quot;normal task...&quot;);\n&#125;);\n\n输出\n22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...\n\n\n\n\n\n\n\n\n\n\n可以用来执行耗时较长的任务\n演示 NioEventLoop 处理定时任务NioEventLoopGroup nioWorkers &#x3D; new NioEventLoopGroup(2);\n\nlog.debug(&quot;server start...&quot;);\nThread.sleep(2000);\nnioWorkers.scheduleAtFixedRate(() -&gt; &#123;&#x2F;&#x2F;\n    log.debug(&quot;running...&quot;);\n&#125;, 0, 1, TimeUnit.SECONDS);\n\n输出\n22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n...\n\n\n\n\n\n\n\n\n\n\n可以用来执行定时任务\n3.2 Channel！！！channel 的主要作用\n\nclose() 可以用来关闭 channel\ncloseFuture() 用来处理 channel 的关闭\nsync 方法作用是同步等待 channel 关闭\n而 addListener 方法是异步等待 channel 关闭\n\n\npipeline() 方法添加处理器\nwrite() 方法将数据写入\nwriteAndFlush() 方法将数据写入并刷出：C-&gt;S\n\nChannelFuture这时刚才的客户端代码\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080)\n    .sync()\n    .channel()\n    .writeAndFlush(new Date() + &quot;: hello world!&quot;);\n\n现在把它拆开来看\nChannelFuture channelFuture &#x3D; new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080); &#x2F;&#x2F; 1\n\nchannelFuture.sync().channel().writeAndFlush(new Date() + &quot;: hello world!&quot;);\n\n\n1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象\n\n注意 &#x3D;&#x3D;connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象&#x3D;&#x3D;\n实验如下：sync\nChannelFuture channelFuture &#x3D; new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080);\n\nSystem.out.println(channelFuture.channel()); &#x2F;&#x2F; 1\nchannelFuture.sync(); &#x2F;&#x2F; 2\nSystem.out.println(channelFuture.channel()); &#x2F;&#x2F; 3\n\n\n执行到 1 时，连接未建立，打印 [id: 0x2e1884dd]\n执行到 2 时，&#x3D;&#x3D;sync 方法是同步等待连接建立完成&#x3D;&#x3D;\n执行到 3 时，连接肯定建立了，打印 [id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]\n\n&#x3D;&#x3D;！！！除了用 sync 方法可以让connect异步操作同步以外，还可以使用回调的方式：&#x3D;&#x3D;https://zhuanlan.zhihu.com/p/386837957\n一个ChannelHandler可以简单的理解为一个回调方法，在Netty内部使用【回调来处理事件】；当一个事件被触发时，与事件相关的ChannelHandler将被调用来响应这个事件的处理\n在Netty中，Future提供了一种在【操作完成时[通知]应用程序】的方式。这个对象可以看作是一个异步操作结果的占位符；它将在未来某个时刻完成并提供【对结果的访问】。\nChannelHandler和Future是【相互补充】的机制；它们相互结合使用构成了Netty本身的关键构件之一。\n\n虽然可以通过ChannelFuture的get()方法获取异步操作的结果,但完成时间是无法预测的,若不设置超时时间则有可能导致线程长时间被阻塞;若是不能精确的设置超时时间则可能导致I&#x2F;O操作中断.因此,Netty建议通过GenericFutureListener接口执行异步操作结束后的回调.\nChannelFuture接口额外提供了注册一个或者多个GenericFutureListener实例的方法，监听器的回调方法operationComplete()将会在对应的操作完成时被调用。\nChannelFuture channelFuture &#x3D; new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080);\nSystem.out.println(channelFuture.channel()); &#x2F;&#x2F; 1\nchannelFuture.addListener((ChannelFutureListener) future -&gt; &#123;\n    System.out.println(future.channel()); &#x2F;&#x2F; 2\n&#125;);\n\n\n执行到 1 时，连接未建立，打印 [id: 0x749124ba]\n&#x3D;&#x3D;ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了&#x3D;&#x3D;，打印 [id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]\n\nCloseFuture@Slf4j\npublic class CloseFutureClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        NioEventLoopGroup group new NioEventLoopGroup();\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override &#x2F;&#x2F; 在连接建立后被调用  也是异步回调！相互补充！\n                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        ch.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        Channel channel &#x3D; channelFuture.sync().channel();&#x2F;&#x2F;\n        log.debug(&quot;&#123;&#125;&quot;, channel);\n        new Thread(()-&gt;&#123;&#x2F;&#x2F;\n            Scanner scanner &#x3D; new Scanner(System.in);\n            while (true) &#123;\n                String line &#x3D; scanner.nextLine();\n                if (&quot;q&quot;.equals(line)) &#123;\n                    channel.close(); &#x2F;&#x2F; close 异步操作: 1s 之后【非阻塞！】\n&#x2F;&#x2F;                    log.debug(&quot;处理关闭之后的操作&quot;); &#x2F;&#x2F; 不能在这里善后！可能还没close！\n                    break;\n                &#125;\n                channel.writeAndFlush(line);\n            &#125;\n        &#125;, &quot;input&quot;).start();\n\n        &#x2F;&#x2F; 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭\n        ChannelFuture closeFuture &#x3D; channel.closeFuture();\n        &#x2F;*log.debug(&quot;waiting close...&quot;);\n        closeFuture.sync();\n        log.debug(&quot;处理关闭之后的操作&quot;);*&#x2F;\n        &#x2F;*\n        closeFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                log.debug(&quot;处理关闭之后的操作&quot;);\n                group.shutdownGracefully();&#x2F;&#x2F;\n            &#125;\n        &#125;);*&#x2F;\n        &#x2F;&#x2F;@FunctionalInterface函数式接口&#x2F;功能性接口(单抽象方法接口) 可使用 Lambda 表达式,方法引用和构造函数引用来表示\n        &#x2F;&#x2F;new ChannelFutureListener()&#123;只有一个待重写的单抽象方法：operationComplete&#125;可用lambda表达式简化 alt+enter！！！\n        closeFuture.addListener((ChannelFutureListener) future -&gt; &#123;\n            log.debug(&quot;处理关闭之后的操作&quot;);\n            group.shutdownGracefully();&#x2F;&#x2F;\n        &#125;);\n    &#125;\n&#125;\n\nlogback.xml\n&lt;!-- 用来控制查看那个类的日志内容（对mybatis name 代表命名空间） --&gt;\n&lt;logger name&#x3D;&quot;cn.itcast&quot; level&#x3D;&quot;DEBUG&quot; additivity&#x3D;&quot;false&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt;\n&lt;&#x2F;logger&gt;\n\n&lt;logger name&#x3D;&quot;io.netty.handler.logging.LoggingHandler&quot; level&#x3D;&quot;DEBUG&quot; additivity&#x3D;&quot;false&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt;\n&lt;&#x2F;logger&gt;\n\n&lt;root level&#x3D;&quot;ERROR&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;STDOUT&quot;&#x2F;&gt;\n&lt;&#x2F;root&gt;\n\n\n💡 优雅关闭优雅关闭 shutdownGracefully 方法。该方法会&#x3D;&#x3D;【首先切换 EventLoopGroup 到关闭状态从而拒绝新的任务的加入】，然后【在任务队列的任务都处理完成后，停止线程的运行】&#x3D;&#x3D;。从而【确保整体应用是在正常有序的状态下退出】的\n异常处理中也要shutdownGracefully ！\n&#x3D;&#x3D;Java8 Lambda表达式：@FunctionalInterface函数式接口&#x2F;功能性接口(单抽象方法接口) 可使用 Lambda 表达式,方法引用和构造函数引用来表示&#x3D;&#x3D;\n💡 异步提升的是什么！！！\n有些同学看到这里会有疑问：【为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接】\n\n还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的\n\n\n&#x3D;&#x3D;【异步+多核多线程！ 任务拆分！ 流水线pipeline！ 响应变慢(+协作时间)，吞吐变高！】&#x3D;&#x3D;思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：4 * 8 * 3 = 96\n\n经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下\n\n因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 4 * 8 * 12 效率几乎是原来的四倍\n\n要点\n\n单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势\n&#x3D;&#x3D;异步并没有缩短响应时间，反而有所增加【提高的是吞吐量：单位时间内处理任务的速度！】&#x3D;&#x3D;\n合理进行任务拆分，也是利用异步的关键\n\n3.3 Future &amp; Promise在异步处理时，经常用到这两个接口\n首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展\tjdk Future &lt;- Netty Future &lt;- netty Promise\n\njdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果\nnetty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束\nnetty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器\n\n\n\n\n功能&#x2F;名称\njdk Future\nnetty Future\nPromise\n\n\n\ncancel\n取消任务\n-\n-\n\n\nisCanceled\n任务是否取消\n-\n-\n\n\nisDone\n任务是否完成，不能区分成功失败\n-\n-\n\n\nget\n获取任务结果，阻塞等待[别的th填结果]  同步\n-\n-\n\n\ngetNow\n-\n获取任务结果，非阻塞，还未产生结果时返回 null\n-\n\n\nawait\n-\n等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断\n-\n\n\nsync\n-\n等待任务结束，如果任务失败，抛出异常       阻塞，不获取结果\n-\n\n\nisSuccess\n-\n判断任务是否成功\n-\n\n\ncause\n-\n获取失败信息，非阻塞，如果【没有失败，返回null】\n-\n\n\naddLinstener\n-\n添加【回调，异步接收】结果\n-\n\n\nsetSuccess\n-\n-\n【不等任务结束】self设置成功结果\n\n\nsetFailure\n-\n-\n设置失败结果\n\n\nexecute(Runnable)\nsubmit(Callable 有返回结果！) 配合Future拿结果\n向线程池中提交任务，get返回结果–&gt;主动创建 promise 结果容器\n@Slf4j\npublic class TestJdkFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 1. 线程池\n        ExecutorService service &#x3D; Executors.newFixedThreadPool(2);\n        &#x2F;&#x2F; 2. 提交任务\n        Future&lt;Integer&gt; future &#x3D; service.submit(new Callable&lt;Integer&gt;() &#123;&#x2F;&#x2F;\n            @Override\n            public Integer call() throws Exception &#123;\n                log.debug(&quot;执行计算&quot;);\n                Thread.sleep(1000);\n                return 50;&#x2F;&#x2F;\n            &#125;\n        &#125;);\n        &#x2F;&#x2F; 3. 主线程通过 future 来同步获取结果\n        log.debug(&quot;等待结果&quot;);\n        log.debug(&quot;结果是 &#123;&#125;&quot;, future.get());&#x2F;&#x2F;\n    &#125;\n&#125;\n\n\n@Slf4j\npublic class TestNettyFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        EventLoop eventLoop &#x3D; group.next();\n        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;\n            @Override\n            public Integer call() throws Exception &#123;\n                log.debug(&quot;执行计算&quot;);\n                Thread.sleep(1000);\n                return 70;\n            &#125;\n        &#125;);\n&#x2F;&#x2F;        log.debug(&quot;等待结果&quot;);\n&#x2F;&#x2F;        log.debug(&quot;结果是 &#123;&#125;&quot;, future.get());\n        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;()&#123;&#x2F;&#x2F;\n            @Override\n            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;\n                log.debug(&quot;接收结果:&#123;&#125;&quot;, future.getNow());&#x2F;&#x2F;\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n\n@Slf4j\npublic class TestNettyPromise &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 1. 准备 EventLoop 对象\n        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();\n        &#x2F;&#x2F; 2. 可以主动创建 promise：结果容器\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);\n        new Thread(() -&gt; &#123;\n            &#x2F;&#x2F; 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果\n            log.debug(&quot;开始计算...&quot;);\n            try &#123;\n                int i &#x3D; 1 &#x2F; 0;\n                Thread.sleep(1000);\n                promise.setSuccess(80);&#x2F;&#x2F;result&#x3D;80\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n                promise.setFailure(e);&#x2F;&#x2F;\n            &#125;\n\n        &#125;).start();\n        &#x2F;&#x2F; 4. 接收结果的线程\n        log.debug(&quot;等待结果...&quot;);\n        log.debug(&quot;结果是: &#123;&#125;&quot;, promise.get());&#x2F;&#x2F;\n    &#125;\n\n&#125;\n\n例1同步处理任务成功\nDefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\neventExecutors.execute(()-&gt;&#123;\n    try &#123;\n        Thread.sleep(1000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    log.debug(&quot;set success, &#123;&#125;&quot;,10);\n    promise.setSuccess(10);\n&#125;);\n\nlog.debug(&quot;start...&quot;);\nlog.debug(&quot;&#123;&#125;&quot;,promise.getNow()); &#x2F;&#x2F; 还没有结果\nlog.debug(&quot;&#123;&#125;&quot;,promise.get());\n\n输出\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10\n\n\n\n例2异步处理任务成功\nDefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\n&#x2F;&#x2F; 设置回调，异步接收结果\npromise.addListener(future -&gt; &#123;\n    &#x2F;&#x2F; 这里的 future 就是上面的 promise\n    log.debug(&quot;&#123;&#125;&quot;,future.getNow());\n&#125;);\n\n&#x2F;&#x2F; 等待 1000 后设置成功结果\neventExecutors.execute(()-&gt;&#123;\n    try &#123;\n        Thread.sleep(1000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    log.debug(&quot;set success, &#123;&#125;&quot;,10);\n    promise.setSuccess(10);\n&#125;);\n\nlog.debug(&quot;start...&quot;);\n\n输出\n11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10\n\n\n\n例3同步处理任务失败 - sync &amp; get\nDefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\n        eventExecutors.execute(() -&gt; &#123;\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            RuntimeException e &#x3D; new RuntimeException(&quot;error...&quot;);\n            log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());\n            promise.setFailure(e);\n        &#125;);\n\n        log.debug(&quot;start...&quot;);\n        log.debug(&quot;&#123;&#125;&quot;, promise.getNow());\n        promise.get(); &#x2F;&#x2F; sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常\n\n输出\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\nException in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...\n\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)\n\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)\nCaused by: java.lang.RuntimeException: error...\n\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n\n\n\n例4同步处理任务失败 - await\nDefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\neventExecutors.execute(() -&gt; &#123;\n    try &#123;\n        Thread.sleep(1000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    RuntimeException e &#x3D; new RuntimeException(&quot;error...&quot;);\n    log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());\n    promise.setFailure(e);\n&#125;);\n\nlog.debug(&quot;start...&quot;);\nlog.debug(&quot;&#123;&#125;&quot;, promise.getNow());\npromise.await(); &#x2F;&#x2F; 与 sync 和 get 区别在于，不会抛异常\nlog.debug(&quot;result &#123;&#125;&quot;, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());&#x2F;&#x2F;！！！\n\n输出\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n\n\n\n例5异步处理任务失败\nDefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\npromise.addListener(future -&gt; &#123;\n    log.debug(&quot;result &#123;&#125;&quot;, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());&#x2F;&#x2F;\n&#125;);\n\neventExecutors.execute(() -&gt; &#123;\n    try &#123;\n        Thread.sleep(1000);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    RuntimeException e &#x3D; new RuntimeException(&quot;error...&quot;);\n    log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());\n    promise.setFailure(e);\n&#125;);\n\nlog.debug(&quot;start...&quot;);\n\n输出\n12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n\n\n\n例6await 死锁检查？？？\nDefaultEventLoop eventExecutors &#x3D; new DefaultEventLoop();\nDefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventExecutors);\n\neventExecutors.submit(()-&gt;&#123;\n    System.out.println(&quot;1&quot;);\n    try &#123;\n        promise.await();\n        &#x2F;&#x2F; 注意不能仅捕获 InterruptedException 异常\n        &#x2F;&#x2F; 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播\n        &#x2F;&#x2F; 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出\n    &#125; catch (Exception e) &#123; \n        e.printStackTrace();\n    &#125;\n    System.out.println(&quot;2&quot;);\n&#125;);\neventExecutors.submit(()-&gt;&#123;\n    System.out.println(&quot;3&quot;);\n    try &#123;\n        promise.await();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    System.out.println(&quot;4&quot;);\n&#125;);\n\n输出\n1\n2\n3\n4\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n\n\n\n\n\n\n3.4 Handler &amp; PipelineChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline\n\n入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果\n出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工\n\n打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道[工序]，而后面要讲的 [ByteBuf 是原材料]，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品\n先搞清楚顺序，服务端\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        protected void initChannel(NioSocketChannel ch) &#123;\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    System.out.println(1);\n                    ctx.fireChannelRead(msg); &#x2F;&#x2F; 1\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    System.out.println(2);\n                    ctx.fireChannelRead(msg); &#x2F;&#x2F; 2\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    System.out.println(3);\n                    ctx.channel().write(msg); &#x2F;&#x2F; 3\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) &#123;\n                    System.out.println(4);\n                    ctx.write(msg, promise); &#x2F;&#x2F; 4\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) &#123;\n                    System.out.println(5);\n                    ctx.write(msg, promise); &#x2F;&#x2F; 5\n                &#125;\n            &#125;);\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) &#123;\n                    System.out.println(6);\n                    ctx.write(msg, promise); &#x2F;&#x2F; 6 &#x3D;super.write(ctx, msg, promise);\n                &#125;\n            &#125;);\n        &#125;\n    &#125;)\n    .bind(8080);\n\n客户端\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        protected void initChannel(Channel ch) &#123;\n            ch.pipeline().addLast(new StringEncoder());\n        &#125;\n    &#125;)\n    .connect(&quot;127.0.0.1&quot;, 8080)\n    .addListener((ChannelFutureListener) future -&gt; &#123;\n        future.channel().writeAndFlush(&quot;hello,world&quot;);\n    &#125;);\n\n服务器端打印：\n1\n2\n3\n6\n5\n4\n\n可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表\n\n\n入站处理器中，ctx.fireChannelRead(msg) 是 调用下一个入站处理器\n如果注释掉 1 处代码，则仅会打印 1\n如果注释掉 2 处代码，则仅会打印 1 2\n\n\n3 处的 ctx.channel().write(msg) 会 从尾部开始触发 后续出站处理器的执行\n如果注释掉 3 处代码，则仅会打印 1 2 3\n\n\n类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 触发上一个出站处理器\n如果注释掉 6 处代码，则仅会打印 1 2 3 6\n\n\nctx.channel().write(msg) vs ctx.write(msg)\n都是触发出站处理器的执行\nctx.channel().write(msg) 从尾部开始查找出站处理器\nctx.write(msg) 是从当前节点找上一个出站处理器\n3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了\n6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6…死循环！ 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己【应避免！！！】\n\n\n\n图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序\n\n&#x3D;&#x3D;in(包装 转换)-channel(tail倒)\tout(处理)-ctx&#x2F;super(cur倒)&#x3D;&#x3D;package cn.itcast.netty.c3;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\n@Slf4j\npublic class TestPipeline &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n                        &#x2F;&#x2F; 1. 通过 channel 拿到 pipeline\n                        ChannelPipeline pipeline &#x3D; ch.pipeline();\n                        &#x2F;&#x2F; 2. 添加处理器 head -&gt;  h1 -&gt; h2 -&gt;  h4 -&gt; h3 -&gt; h5 -&gt; h6 -&gt; tail\n                        pipeline.addLast(&quot;h1&quot;, new ChannelInboundHandlerAdapter()&#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                log.debug(&quot;1&quot;);\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                String name &#x3D; buf.toString(Charset.defaultCharset());&#x2F;&#x2F;ByteBuf2str\n                                super.channelRead(ctx, name);\n                            &#125;\n                        &#125;);\n\n                        pipeline.addLast(&quot;h2&quot;, new ChannelInboundHandlerAdapter()&#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object name) throws Exception &#123;\n                                log.debug(&quot;2&quot;);\n                                Student student &#x3D; new Student(name.toString());\n                                super.channelRead(ctx, student); &#x2F;&#x2F; 将数据传递给下个 Inboundhandler，如果不调用，调用链会断开 或者调用 ctx.fireChannelRead(student);\n                            &#125;\n                        &#125;);\n                        &#x2F;&#x2F;只有向channel里写了数据writeAndFlush，才会触发 出站Handler 【处理数据】 123 | 654\n                        pipeline.addLast(&quot;h4&quot;, new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                log.debug(&quot;4&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n\n                        pipeline.addLast(&quot;h3&quot;, new ChannelInboundHandlerAdapter()&#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                log.debug(&quot;3, 结果&#123;&#125;, class:&#123;&#125;&quot;, msg, msg.getClass());\n&#x2F;&#x2F;                                ctx.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;server...&quot;.getBytes()));&#x2F;&#x2F;从【当前handler开始倒着找out：1243】\n                                ch.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;server...&quot;.getBytes()));&#x2F;&#x2F;从tail开始倒着找out     str2ByteBuf\n                            &#125;\n                        &#125;);\n\n                        pipeline.addLast(&quot;h5&quot;, new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                log.debug(&quot;5&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                        pipeline.addLast(&quot;h6&quot;, new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                log.debug(&quot;6&quot;);\n                                super.write(ctx, msg, promise);&#x2F;&#x2F;&#x3D;ctx.write(msg, promise); 从cur\n&#x2F;&#x2F;                                ctx.channel().write(msg, promise); &#x2F;&#x2F; 从tail： 12366666...死循环！避免out用channel写！！！\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n    @Data\n    @AllArgsConstructor\n    static class Student &#123;\n        private String name;\n    &#125;\n&#125;\n\n\nTestEmbeddedChannel\nEmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);&#x2F;&#x2F;用于快捷测试handler效果！\n        &#x2F;&#x2F; 模拟入站操作 12\n&#x2F;&#x2F;        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes()));\n        &#x2F;&#x2F; 模拟出站操作 43\n        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;world&quot;.getBytes()));\n\n\n\n3.5 ByteBuf是对字节数据的封装\n1）创建ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(10);\nlog(buffer);\n\n上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10\n输出\nread index:0 write index:0 capacity:10\n\n其中 log 方法参考如下\nprivate static void log(ByteBuf buffer) &#123;\n    int length &#x3D; buffer.readableBytes();\n    int rows &#x3D; length &#x2F; 16 + (length % 15 &#x3D;&#x3D; 0 ? 0 : 1) + 4;\n    StringBuilder buf &#x3D; new StringBuilder(rows * 80 * 2)\n        .append(&quot;read index:&quot;).append(buffer.readerIndex())\n        .append(&quot; write index:&quot;).append(buffer.writerIndex())\n        .append(&quot; capacity:&quot;).append(buffer.capacity())\n        .append(NEWLINE);\n    appendPrettyHexDump(buf, buffer);\n    System.out.println(buf.toString());\n&#125;\n\n\n\n2）直接内存 vs 堆内存可以使用下面的代码来创建池化基于堆的 ByteBuf\nByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(10);\n\n也可以使用下面的代码来创建池化基于直接内存的 ByteBuf\nByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(10);\n\n\n&#x3D;&#x3D;直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用&#x3D;&#x3D;\n直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放\n\n3）池化 vs 非池化池化的最大意义在于可以重用 ByteBuf，优点有\n\n没有池化，则【每次都得创建新的 ByteBuf 实例】，这个操作【对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力】\n有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率\n高并发时，池化功能更节约内存，减少内存溢出的可能\n\n池化功能是否开启，可以通过下面的系统环境变量来设置\n-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125;\n\n\n4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现\n4.1 之前，池化功能还不成熟，默认是非池化实现\n\npublic class TestByteBuf &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;VM option:-Dio.netty.allocator.type&#x3D;unpooled\n        ByteBuf buf &#x3D; ByteBufAllocator.DEFAULT.buffer();&#x2F;&#x2F;默认256 ByteBuf可扩容\n        System.out.println(buf.getClass());&#x2F;&#x2F;\n        System.out.println(buf.maxCapacity());&#x2F;&#x2F;2^31-1&#x3D;Integer.Max_VALUE\n        log(buf);\n        StringBuilder sb &#x3D; new StringBuilder();\n        for (int i &#x3D; 0; i &lt; 257; i++) &#123;&#x2F;&#x2F;\n            sb.append(&quot;a&quot;);\n        &#125;\n        buf.writeBytes(sb.toString().getBytes());\n        log(buf);\n    &#125;\n&#125;\n\nclass io.netty.buffer.PooledUnsafeDirectByteBuf\n2147483647\nread index:0 write index:0 capacity:256\nread index:0 write index:257 capacity:512\n\n\n\n4）组成ByteBuf 由四部分组成\n\n最开始读写指针都在 0 位置\nflip compact–&gt;Ridx Widx 可扩容\n5）写入方法列表，省略一些不重要的方法\n\n\n\n方法签名\n含义\n备注\n\n\n\nwriteBoolean(boolean value)\n写入 boolean 值\n用一字节 01|00 代表 true|false\n\n\nwriteByte(int value)\n写入 byte 值\n\n\n\nwriteShort(int value)\n写入 short 值\n\n\n\nwriteInt(int value)\n写入 int 值\nBig Endian，即 0x250，写入后 00 00 02 50 【高-低】\n\n\nwriteIntLE(int value)\n写入 int 值\nLittle Endian，即 0x250，写入后 50 02 00 00\n\n\nwriteLong(long value)\n写入 long 值\n\n\n\nwriteChar(int value)\n写入 char 值\n\n\n\nwriteFloat(float value)\n写入 float 值\n\n\n\nwriteDouble(double value)\n写入 double 值\n\n\n\nwriteBytes(ByteBuf src)\n写入 netty 的 ByteBuf\n\n\n\nwriteBytes(byte[] src)\n写入 byte[]\n\n\n\nwriteBytes(ByteBuffer src)\n写入 nio 的 ByteBuffer\n\n\n\nint writeCharSequence(CharSequence sequence, Charset charset)\n写入字符串\nString StringBuffer StringBuilder 的父类！\n\n\n\n\n\n\n\n\n\n\n\n 注意\n\n这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用\n网络传输，默认习惯是 Big Endian\n\n先写入 4 个字节\nbuffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\nlog(buffer);\n\n结果是\nread index:0 write index:4 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n再写入一个 int 整数，也是 4 个字节\nbuffer.writeInt(5);\nlog(buffer);\n\n结果是\nread index:0 write index:8 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n\n\n还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置\n6）扩容再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容\nbuffer.writeInt(6);\nlog(buffer);\n\n扩容规则是\n\n如果写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16\n如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10&#x3D;1024（2^9&#x3D;512 已经不够了）\n扩容不能超过 max capacity 会报错\n\n结果是\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |\n+--------+-------------------------------------------------+----------------+\n\n\n\n7）读取例如读了 4 次，每次一个字节\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nlog(buffer);\n\n读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分\n1\n2\n3\n4\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n如果需要重复读取 int 整数 5，怎么办？\n可以在 read 前先做个标记 mark\nbuffer.markReaderIndex();&#x2F;&#x2F;\nSystem.out.println(buffer.readInt());\nlog(buffer);\n\n结果\n5\nread index:8 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 06                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n这时要重复读取的话，重置到标记位置 reset\nbuffer.resetReaderIndex();&#x2F;&#x2F;\nlog(buffer);\n\n这时\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index\n&#x3D;&#x3D;write read &#x2F; set get&#x3D;&#x3D;\n8）retain &amp; release由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。\n\nUnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可\nUnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存\nPooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存【还回内存池！】\n\n\n\n\n\n\n\n\n\n\n回收内存的源码实现，请关注下面方法的不同实现\nprotected abstract void deallocate()\nNetty 这里采用了**&#x3D;&#x3D;引用计数法&#x3D;&#x3D;来控制回收**内存，每个 ByteBuf 都实现了 ReferenceCounted 接口\n\n每个 ByteBuf 对象的初始计数为 1\n调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收\n调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收\n当计数为 0 时，【底层内存会被回收：见&#x3D;&#x3D;deallocate()不同实现方式&#x3D;&#x3D;】，这时即使 ByteBuf 对象还在，其各个【方法均无法正常使用】\n\n谁来负责 release 呢？\n不是我们想象的（一般情况下）\nByteBuf buf &#x3D; ...\ntry &#123;\n    ...\n&#125; finally &#123;\n    buf.release();\n&#125;\n\n请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）\n基本规则是，**谁是&#x3D;&#x3D;最后使用者，谁负责 release&#x3D;&#x3D;**，详细分析如下\n\n起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）\n入站 ByteBuf 处理原则\n对原始 ByteBuf 【不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release】\n将原始 ByteBuf &#x3D;&#x3D;转换为其它类型的 Java 对象&#x3D;&#x3D;，这时 ByteBuf 就没用了，必须 release\n如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release\n注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release\n假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）\n\n\n出站 ByteBuf 处理原则\n出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release\n\n\n异常处理原则\n有时候【不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true】\n\n\n\n传到了首尾，head&#x2F;tail才释放；传不到或不用了，就要自己释放！！！\nTailContext 释放未处理消息逻辑：引用计数ed_msg.release()\n&#x2F;&#x2F; io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)\nprotected void onUnhandledInboundMessage(Object msg) &#123;\n    try &#123;\n        logger.debug(\n            &quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot; +\n            &quot;Please check your pipeline configuration.&quot;, msg);\n    &#125; finally &#123;\n        ReferenceCountUtil.release(msg);\n    &#125;\n&#125;\n\n具体代码\n&#x2F;&#x2F; io.netty.util.ReferenceCountUtil#release(java.lang.Object)\npublic static boolean release(Object msg) &#123;\n    if (msg instanceof ReferenceCounted) &#123;\n        return ((ReferenceCounted) msg).release();\n    &#125;\n    return false;\n&#125;\n\nHeadContext:\nctrl+F12 write  ctrl+alt+鼠标左键：implement\trelease() &#x2F; -&gt;outboundBuffer！！！\n9）slice【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针\n\n例，原始 ByteBuf 进行一些初始操作\nByteBuf origin &#x3D; ByteBufAllocator.DEFAULT.buffer(10);\norigin.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\norigin.readByte();&#x2F;&#x2F;\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n\n这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，【切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write】\nByteBuf slice &#x3D; origin.slice();\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n&#x2F;&#x2F; slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常\n带参构造：\nbuf.slice(index, length);\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n\n如果原始 ByteBuf 再次读操作（又读了一个字节）\norigin.readByte();&#x2F;&#x2F;\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 04                                           |..              |\n+--------+-------------------------------------------------+----------------+\n\n这时的 slice 不受影响，因为它有独立的读写指针\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n\n如果 slice 的内容发生了更改 setByte\nslice.setByte(2, 5);&#x2F;&#x2F;\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 05                                        |...             |\n+--------+-------------------------------------------------+----------------+\n\n这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 05                                           |..              |\n+--------+-------------------------------------------------+----------------+\n\nslice.retain();&#x2F;&#x2F;refCnt+1\nrelease();&#x2F;&#x2F;refCnt-1\n10）duplicate 浅拷贝【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的\n\n11）copy深拷贝会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关\n12）CompositeByteBuf【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝\n有两个 ByteBuf 如下\nByteBuf buf1 &#x3D; ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]&#123;1, 2, 3, 4, 5&#125;);\nByteBuf buf2 &#x3D; ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]&#123;6, 7, 8, 9, 10&#125;);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf1));\nSystem.out.println(ByteBufUtil.prettyHexDump(buf2));\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n\n现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？\n方法1：\nByteBuf buf3 &#x3D; ByteBufAllocator.DEFAULT\n    .buffer(buf1.readableBytes()+buf2.readableBytes());&#x2F;&#x2F;\nbuf3.writeBytes(buf1);&#x2F;&#x2F;\nbuf3.writeBytes(buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n\n结果\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n\n这种方法好不好？回答是不太好，因为进行了[数据的内存复制]操作\n方法2：\nCompositeByteBuf buf3 &#x3D; ByteBufAllocator.DEFAULT.compositeBuffer();\n&#x2F;&#x2F; true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0\nbuf3.addComponents(true, buf1, buf2);&#x2F;&#x2F;默认不增Widx！+入参true！\n\n结果是一样的\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n\nCompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。\n\n优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制\n缺点，复杂了很多，多次操作会带来性能的损耗\n\n13）UnpooledUnpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作\n这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf\nByteBuf buf1 &#x3D; ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]&#123;1, 2, 3, 4, 5&#125;);\nByteBuf buf2 &#x3D; ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]&#123;6, 7, 8, 9, 10&#125;);\n\n&#x2F;&#x2F; 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf\nByteBuf buf3 &#x3D; Unpooled.wrappedBuffer(buf1, buf2);&#x2F;&#x2F;\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n\n输出\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n\n也可以用来包装普通字节数组，底层也不会有拷贝操作\nByteBuf buf4 &#x3D; Unpooled.wrappedBuffer(new byte[]&#123;1, 2, 3&#125;, new byte[]&#123;4, 5, 6&#125;);&#x2F;&#x2F;\nSystem.out.println(buf4.getClass());\nSystem.out.println(ByteBufUtil.prettyHexDump(buf4));\n\n输出\nclass io.netty.buffer.CompositeByteBuf\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06                               |......          |\n+--------+-------------------------------------------------+----------------+\n\n\n\n💡 ByteBuf 优势\n池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能\n读写指针分离，不需要像 ByteBuffer 一样切换读写模式\n可以自动扩容\n支持链式调用，使用更流畅\n很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf\n\n4. 双向通信4.1 练习实现一个 echo server\n编写 server\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(NioSocketChannel ch) &#123;\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    ByteBuf buffer &#x3D; (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    &#x2F;&#x2F; 建议使用 ctx.alloc() 创建 ByteBuf\n                    ByteBuf response &#x3D; ctx.alloc().buffer();\n                    response.writeBytes(buffer);\n                    ctx.writeAndFlush(response);\n\n                    &#x2F;&#x2F; 思考：需要释放 buffer 吗\n                    &#x2F;&#x2F; 思考：需要释放 response 吗\n                &#125;\n            &#125;);\n        &#125;\n    &#125;).bind(8080);\n\n编写 client\nNioEventLoopGroup group &#x3D; new NioEventLoopGroup();\nChannel channel &#x3D; new Bootstrap()\n    .group(group)\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(NioSocketChannel ch) throws Exception &#123;\n            ch.pipeline().addLast(new StringEncoder());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n                    ByteBuf buffer &#x3D; (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    &#x2F;&#x2F; 思考：需要释放 buffer 吗\n                &#125;\n            &#125;);\n        &#125;\n    &#125;).connect(&quot;127.0.0.1&quot;, 8080).sync().channel();\n\nchannel.closeFuture().addListener(future -&gt; &#123;\n    group.shutdownGracefully();\n&#125;);\n\nnew Thread(() -&gt; &#123;\n    Scanner scanner &#x3D; new Scanner(System.in);\n    while (true) &#123;\n        String line &#x3D; scanner.nextLine();\n        if (&quot;q&quot;.equals(line)) &#123;\n            channel.close();\n            break;\n        &#125;\n        channel.writeAndFlush(line);\n    &#125;\n&#125;).start();\n\n\n\n💡 读和写的误解我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是【全双工】的：在任意时刻，线路上存在A 到 B 和 B 到 A 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用【读线程和写线程】即可，读不会阻塞写、写也不会阻塞读\n例如\npublic class TestServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket ss &#x3D; new ServerSocket(8888);\n        Socket s &#x3D; ss.accept();\n\n        new Thread(() -&gt; &#123;\n            try &#123;\n                BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(s.getInputStream()));&#x2F;&#x2F;\n                while (true) &#123;\n                    System.out.println(reader.readLine());\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n\n        new Thread(() -&gt; &#123;\n            try &#123;\n                BufferedWriter writer &#x3D; new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));&#x2F;&#x2F;\n                &#x2F;&#x2F; 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据\n                for (int i &#x3D; 0; i &lt; 100; i++) &#123;\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n\n客户端\npublic class TestClient &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Socket s &#x3D; new Socket(&quot;localhost&quot;, 8888);\n\n        new Thread(() -&gt; &#123;\n            try &#123;\n                BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) &#123;\n                    System.out.println(reader.readLine());\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n\n        new Thread(() -&gt; &#123;\n            try &#123;\n                BufferedWriter writer &#x3D; new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                for (int i &#x3D; 0; i &lt; 100; i++) &#123;\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n\n\n\n三. Netty 进阶1. 粘包与半包1.1 粘包现象服务端代码\npublic class HelloWorldServer &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldServer.class);\n    void start() &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            &#x2F;&#x2F;serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);&#x2F;&#x2F;半包\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());\n                            super.channelActive(ctx);\n                        &#125;\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());\n                            super.channelInactive(ctx);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);\n            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());\n            channelFuture.sync();&#x2F;&#x2F;\n            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());\n            channelFuture.channel().closeFuture().sync();&#x2F;&#x2F;\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug(&quot;stoped&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new HelloWorldServer().start();\n    &#125;\n&#125;\n\n客户端代码希望发送 10 个消息，每个消息是 16 字节\npublic class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connected...&quot;);\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            Random r &#x3D; new Random();\n                            char c &#x3D; &#39;a&#39;;\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n                                ctx.writeAndFlush(buffer);&#x2F;&#x2F;160B 粘包\n                            &#125;\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:&#x2F;0:0:0:0:0:0:0:0:8080] bound...\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177] REGISTERED\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177] ACTIVE\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177]\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58177] READ COMPLETE\n\n\n\n1.2 半包现象客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为\nByteBuf buffer &#x3D; ctx.alloc().buffer();\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n&#125;\nctx.writeAndFlush(buffer);\n\n为现象明显，服务端修改一下接收缓冲区，其它代码不变\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);&#x2F;&#x2F;\n\n服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:&#x2F;0:0:0:0:0:0:0:0:8080] bound...\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] REGISTERED\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] ACTIVE\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221]\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] READ: 20B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] READ COMPLETE\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] READ: 140B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:59221] READ COMPLETE\n\n\n\n\n\n\n\n\n\n\n注意\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 【netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍】\n&#x3D;&#x3D;only TCP&#x3D;&#x3D;\n1.3 现象分析粘包\n\n现象，发送 abc def，接收 abcdef\n原因\n应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）\n滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包\nNagle 算法：会造成粘包\n\n\n\n半包\n\n现象，发送 abcdef，接收 abc def\n原因\n应用层：接收方 ByteBuf 小于实际发送数据量\n滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包\nMSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包\n\n\n\n【 IP分片与重组：if大TCP报文被IP层MTU分片:1500B，&#x3D;&#x3D;只有第一个分片才具有TCP头部&#x3D;&#x3D;，重组才认为是TCP给上层】\n如果一个大的TCP报文被MSS分片，那么所有分片都具有TCP头部，因为每个MSS分片的是具有TCP头部的TCP报文，其中一个MSS分片丢失，就只需要重传这一个分片就可以。\n本质是因为 TCP 是流式协议，消息无边界\n\n\n\n\n\n\n\n\n\n滑动窗口\n\nTCP 以一个段（segment）为单位[MSS]，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是 包的往返时间RTT越长性能就越差\n\n\n为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值\n\n\n窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用\n\n图中深色的部分即要发送的数据，高亮的部分即窗口\n窗口内的数据才允许被发送，当 应答未到达前，窗口必须停止滑动\n如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动\n接收方也会维护 一个窗口，只有落在窗口内的数据才能 允许接收\n\n\n\n\n\n\n\n\n\n\n\n\n MSS 限制\n\n链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如\n\n以太网的 MTU 是 1500\n\nFDDI（光纤分布式数据接口）的 MTU 是 4352\n\n本地回环地址的 MTU 是 65535 - 本地测试不走网卡\n\nMSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数\n\nipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 &#x3D; 1460\n\nTCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送\n\nMSS 的值在&#x3D;&#x3D;三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS&#x3D;&#x3D;\n\n\n \n\n\n\n\n\n\n\n\n\nNagle 算法\n\n【即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据】，这就是 Nagle 算法产生的缘由\n该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送\n如果 SO_SNDBUF 的数据达到 MSS，则需要发送\n如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭\n如果 TCP_NODELAY &#x3D; true，则需要发送\n已发送的数据都收到 ack 时，则需要发送\n上述条件不满足，但发生超时（一般为 200ms）则需要发送\n\n除上述情况，延迟发送\n\n\n\n1.4 解决方案\n短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低\n每一条消息采用固定长度，缺点浪费空间\n每一条消息采用分隔符，例如 \\n，缺点需要转义\n每一条消息分为 head 和 body，head 中包含 body 的长度\n\n方法1，短链接以解决粘包为例\npublic class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 分 10 次发送\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            send();\n        &#125;\n    &#125;\n\n    private static void send() &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;conneted...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                            buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n                            ctx.writeAndFlush(buffer);\n                            &#x2F;&#x2F; 发完即关\n                            ctx.close();&#x2F;&#x2F;\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n输出，略\n\n\n\n\n\n\n\n\n\n半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的\npublic class HelloWorldServer &#123;\n static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldServer.class);\n void start() &#123;\n     NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);\n     NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n     try &#123;\n         ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n         serverBootstrap.channel(NioServerSocketChannel.class);\n         &#x2F;&#x2F;调整系统的接收缓冲区（滑动窗口）\n         &#x2F;&#x2F;serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);&#x2F;&#x2F;半包\n         &#x2F;&#x2F;调整netty额接收缓冲区（byteBuf）\n         serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, new AdaptiveRecvByteBufAllocator(16, 16, 16));\n\n\n         serverBootstrap.group(boss, worker);\n         serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n             @Override\n             protected void initChannel(SocketChannel ch) throws Exception &#123;\n                 ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                 ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                     @Override\n                     public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                         log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());\n                         super.channelActive(ctx);\n                     &#125;\n\n                     @Override\n                     public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n                         log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());\n                         super.channelInactive(ctx);\n                     &#125;\n                 &#125;);\n             &#125;\n         &#125;);\n         ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);\n         log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());\n         channelFuture.sync();&#x2F;&#x2F;\n         log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());\n         channelFuture.channel().closeFuture().sync();&#x2F;&#x2F;\n     &#125; catch (InterruptedException e) &#123;\n         log.error(&quot;server error&quot;, e);\n     &#125; finally &#123;\n         boss.shutdownGracefully();\n         worker.shutdownGracefully();\n         log.debug(&quot;stoped&quot;);\n     &#125;\n &#125;\n\n public static void main(String[] args) &#123;\n     new HelloWorldServer().start();\n &#125;\n&#125;\n\n\n16B 2B 16 2 ……\n方法2，固定长度 FixedLengthFrameDecoder让所有数据包长度固定（假设长度为 8 字节），服务器端加入\nch.pipeline().addLast(new FixedLengthFrameDecoder(8));\n\n客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以\npublic class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connetted...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            &#x2F;&#x2F; 发送内容随机的数据包\n                            Random r &#x3D; new Random();\n                            char c &#x3D; &#39;a&#39;;\n                            ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                byte[] bytes &#x3D; new byte[8];\n                                for (int j &#x3D; 0; j &lt; r.nextInt(8); j++) &#123;\n                                    bytes[j] &#x3D; (byte) c;\n                                &#125;\n                                c++;\n                                buffer.writeBytes(bytes);\n                            &#125;\n                            ctx.writeAndFlush(buffer);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n客户端输出 【粘包】\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: &#x2F;192.168.0.103:9090\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:&#x2F;192.168.0.103:53155 - R:&#x2F;192.168.0.103:9090] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:&#x2F;192.168.0.103:53155 - R:&#x2F;192.168.0.103:9090] WRITE: 80B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|\n|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|\n|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|\n|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|\n|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:&#x2F;192.168.0.103:53155 - R:&#x2F;192.168.0.103:9090] FLUSH\n\n服务端输出 【正确接收】\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:&#x2F;192.168.0.103:9090] bound...\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155]\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 00 00 00 00 00 00 00                         |b.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00                         |cc......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 00 00 00 00 00 00 00                         |d.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 00 00 00 00 00                         |........        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 00 00 00 00 00 00 00                         |h.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:53155] READ COMPLETE\n\n缺点是，数据包的大小不好把握\n\n长度定的太大，浪费\n长度定的太小，对某些数据包又显得不够\n\n方法3，固定分隔符 LineBasedFrameDecoder服务端加入，默认以 \\n 或 \\r\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常\nch.pipeline().addLast(new LineBasedFrameDecoder(1024));&#x2F;&#x2F; linux&#39;\\n&#39; win&#39;\\r\\n&#39;\n\n&#x2F;&#x2F;ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();\n&#x2F;&#x2F;buffer.writeBytes(&quot;\\n&quot;.getBytes());\n&#x2F;&#x2F;ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buffer));&#x2F;&#x2F;delimiter分隔符\n\n客户端在每条消息之后，加入 \\n 分隔符\npublic class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connetted...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            Random r &#x3D; new Random();\n                            char c &#x3D; &#39;a&#39;;\n                            ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                for (int j &#x3D; 1; j &lt;&#x3D; r.nextInt(16)+1; j++) &#123;\n                                    buffer.writeByte((byte) c);\n                                &#125;\n                                buffer.writeByte(10);&#x2F;&#x2F;\n                                c++;\n                            &#125;\n                            ctx.writeAndFlush(buffer);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n客户端输出\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: &#x2F;192.168.0.103:9090\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:&#x2F;192.168.0.103:63641 - R:&#x2F;192.168.0.103:9090] ACTIVE\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:&#x2F;192.168.0.103:63641 - R:&#x2F;192.168.0.103:9090] WRITE: 60B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|\n|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|\n|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|\n|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:&#x2F;192.168.0.103:63641 - R:&#x2F;192.168.0.103:9090] FLUSH\n\n\n\n服务端输出\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641]\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 1B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61                                              |a               |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63                                        |ccc             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64                                           |dd              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66                                           |ff              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 67 67 67 67                            |ggggggg         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68 68 68                                     |hhhh            |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:63641] READ COMPLETE\n\n缺点，处理字符数据比较合适，但【如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误】\n方法4，预设长度 LengthFieldBasedFrameDecoder(max,len前中后,S收去尾)server：在发送消息前，先约定 用定长字节表示接下来数据的长度\n&#x2F;&#x2F; 最大长度，长度偏移(长度前)，长度占用字节(长度长)，长度调整(长度后|内容前)，剥离字节数(S接收端：去首)\nch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));\n\n客户端代码\npublic class HelloWorldClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connetted...&quot;);\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            Random r &#x3D; new Random();\n                            char c &#x3D; &#39;a&#39;;\n                            ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                byte length &#x3D; (byte) (r.nextInt(16) + 1);\n                                &#x2F;&#x2F; 先写入长度\n                                buffer.writeByte(length);&#x2F;&#x2F;\n                                &#x2F;&#x2F; 再\n                                for (int j &#x3D; 1; j &lt;&#x3D; length; j++) &#123;&#x2F;&#x2F;\n                                    buffer.writeByte((byte) c);&#x2F;&#x2F;\n                                &#125;\n                                c++;\n                            &#125;\n                            ctx.writeAndFlush(buffer);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n\n\n客户端输出\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: &#x2F;192.168.0.103:9090\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:&#x2F;192.168.0.103:49979 - R:&#x2F;192.168.0.103:9090] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:&#x2F;192.168.0.103:49979 - R:&#x2F;192.168.0.103:9090] WRITE: 97B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|\n|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|\n|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|\n|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|\n|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|\n|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|\n|00000060| 6a                                              |j               |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:&#x2F;192.168.0.103:49979 - R:&#x2F;192.168.0.103:9090] FLUSH\n\n\n\n服务端输出\n14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...\n14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:&#x2F;192.168.0.103:9090] bound...\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979]\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63 63 63 63                               |cccccc          |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 15B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 13B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67                                           |gg              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68                                           |hh              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:&#x2F;192.168.0.103:9090 - R:&#x2F;192.168.0.103:49979] READ COMPLETE\n\n\n\n\n2. 协议设计与解析2.1 为什么需要协议？TCP&#x2F;IP 中消息传输  基于流的方式，没有边界。\n协议的目的就是：划定消息的边界，制定通信双方要共同遵守的通信规则\n例如：在网络上传输\n下雨天留客天留我不留\n\n是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性\n一种解读\n下雨天留客，天留，我不留\n\n另一种解读\n下雨天，留客天，留我不？留\n\n\n\n如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用\n定长字节表示内容长度 + 实际内容\n\n例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了\n0f下雨天留客06天留09我不留\n\n\n\n\n\n\n\n\n\n\n\n\n小故事\n很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。\n年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”\n私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”\n双方唇枪舌战，你来我往，真个是不亦乐乎！\n这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬\n2.2 redis 协议举例NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\nbyte[] LINE &#x3D; &#123;13, 10&#125;;&#x2F;&#x2F; 回车+换行 win:\\r\\n\ntry &#123;\n    Bootstrap bootstrap &#x3D; new Bootstrap();\n    bootstrap.channel(NioSocketChannel.class);\n    bootstrap.group(worker);\n    bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(SocketChannel ch) &#123;\n            ch.pipeline().addLast(new LoggingHandler());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                &#x2F;&#x2F; 会在连接 channel 建立成功后，会触发 active 事件\n                @Override\n                public void channelActive(ChannelHandlerContext ctx) &#123;\n                    set(ctx);\n                    get(ctx);\n                &#125;\n                private void get(ChannelHandlerContext ctx) &#123;\n                    ByteBuf buf &#x3D; ctx.alloc().buffer();\n                    buf.writeBytes(&quot;*2&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;get&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;aaa&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                &#125;\n                private void set(ChannelHandlerContext ctx) &#123;\n                    ByteBuf buf &#x3D; ctx.alloc().buffer();\n                    buf.writeBytes(&quot;*3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;set&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;aaa&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;$3&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(&quot;bbb&quot;.getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                &#125;\n\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                    ByteBuf buf &#x3D; (ByteBuf) msg;\n                    System.out.println(buf.toString(Charset.defaultCharset()));\n                &#125;\n            &#125;);\n        &#125;\n    &#125;);\n    ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;localhost&quot;, 6379).sync();&#x2F;&#x2F;\n    channelFuture.channel().closeFuture().sync();\n&#125; catch (InterruptedException e) &#123;\n    log.error(&quot;client error&quot;, e);\n&#125; finally &#123;\n    worker.shutdownGracefully();\n&#125;\n\n起redis:【run】 get aaa\n2.3 http 协议举例NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\nNioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\ntry &#123;\n    ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.group(boss, worker);\n    serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception &#123;\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(new HttpServerCodec());&#x2F;&#x2F;\n            ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception &#123;\n                    &#x2F;&#x2F; 获取请求\n                    log.debug(msg.uri());&#x2F;&#x2F;-&#x2F;bxl.html\n\n                    &#x2F;&#x2F; 返回响应\n                    DefaultFullHttpResponse response &#x3D;\n                            new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n\n                    byte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;&quot;.getBytes();\n\n                    response.headers().setInt(CONTENT_LENGTH, bytes.length);&#x2F;&#x2F;&#x2F;&#x2F;k,v 否则浏览器一直转圈读！！！\n                    response.content().writeBytes(bytes);\n\n                    &#x2F;&#x2F; 写回响应\n                    ctx.writeAndFlush(response);\n                &#125;\n            &#125;);\n            &#x2F;*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());\n\n                    if (msg instanceof HttpRequest) &#123; &#x2F;&#x2F; 请求行，请求头\n\n                    &#125; else if (msg instanceof HttpContent) &#123; &#x2F;&#x2F;请求体\n\n                    &#125;\n                &#125;\n            &#125;);*&#x2F;\n        &#125;\n    &#125;);\n    ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080).sync();\n    channelFuture.channel().closeFuture().sync();\n&#125; catch (InterruptedException e) &#123;\n    log.error(&quot;server error&quot;, e);\n&#125; finally &#123;\n    boss.shutdownGracefully();\n    worker.shutdownGracefully();\n&#125;\n\nhttp://localhost:8080/bxl.html\n&#x3D;&#x3D;2.4 自定义协议要素&#x3D;&#x3D;【紧凑，高效，省带宽】\n魔数cafebaby，用来在第一时间判定是否是无效数据包\n版本号，可以支持协议的升级 新增消息…\n序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、xml、protobuf(bin)、hessian(bin)、jdk(不跨平台|性能低)\n指令类型，是登录、注册、单聊、群聊… 跟业务相关\n[请求序号]，为了[双工通信]，提供[异步]能力\n正文长度\n消息正文 username,pwd…    json&#x2F;xml&#x2F;bin对象流…\n\nmsg编解码器【netty-demo项目】根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发\n@Slf4j\npublic class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;\n        &#x2F;&#x2F; 1. 4 字节的魔数\n        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        &#x2F;&#x2F; 2. 1 字节的版本,\n        out.writeByte(1);\n        &#x2F;&#x2F; 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        &#x2F;&#x2F; 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 无意义，对齐填充\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 6. 获取内容的字节数组\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n        &#x2F;&#x2F; 7. 长度\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 8. 写入内容\n        out.writeBytes(bytes);\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        int magicNum &#x3D; in.readInt();\n        byte version &#x3D; in.readByte();\n        byte serializerType &#x3D; in.readByte();\n        byte messageType &#x3D; in.readByte();\n        int sequenceId &#x3D; in.readInt();\n        in.readByte();\n        int length &#x3D; in.readInt();\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(&quot;&#123;&#125;&quot;, message);\n        out.add(message);\n    &#125;\n&#125;\n\n测试\tprotocol.TestMessageCodec类：\nEmbeddedChannel channel &#x3D; new EmbeddedChannel(\n    new LoggingHandler(),\n    new LengthFieldBasedFrameDecoder(\n        1024, 12, 4, 0, 0),\n    new MessageCodec()\n);\n&#x2F;&#x2F; encode\nLoginRequestMessage message &#x3D; new LoginRequestMessage(&quot;zhangsan&quot;, &quot;123&quot;, &quot;张三&quot;);\n&#x2F;&#x2F;        channel.writeOutbound(message);&#x2F;&#x2F;ByteBuf&lt;-msg out编码\n&#x2F;&#x2F; decode    ByteBuf-&gt;msg in解码\nByteBuf buf &#x3D; ByteBufAllocator.DEFAULT.buffer();\nnew MessageCodec().encode(null, message, buf);\n\nByteBuf s1 &#x3D; buf.slice(0, 100);\nByteBuf s2 &#x3D; buf.slice(100, buf.readableBytes() - 100);\ns1.retain(); &#x2F;&#x2F; 引用计数 2\nchannel.writeInbound(s1); &#x2F;&#x2F; release 1\n&#x2F;&#x2F;ByteBuf有限[半包问题！不完整,无法反序列化为msg]\n&#x2F;&#x2F;       报错： java.lang.IndexOutOfBoundsException: readerIndex(16) + length(198) exceeds writerIndex(100)\n\n        &#x2F;&#x2F;+new LengthFieldBasedFrameDecoder(),：发现数据不完整，不会传递给下一个handler，而是等待接下来的数据\nchannel.writeInbound(s2);\n\n\n\n解读\n\n💡 什么时候可以加 @Sharable\n当 handler 不保存状态时，就可以@Sharable安全地在多线程下被共享\n但要注意对于编解码器类(S)：不能继承 ByteToMessageCodec(需拼凑,有状态!S) 或 CombinedChannelDuplexHandler 父类(!S)，他们的构造方法对 @Sharable 有限制：报错\n如果&#x3D;&#x3D;【能确保编解码器不会保存状态(S)，可以继承 MessageToMessageCodec 父类】&#x3D;&#x3D;\n\nMessageCodecSharable【对标MessageCodec】    父类不同！\n@Slf4j\n@ChannelHandler.Sharable&#x2F;&#x2F;\n&#x2F;**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，[确保]接到的 ByteBuf 消息是[完整]的\n *&#x2F;\npublic class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;&#x2F;&#x2F;S\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        ByteBuf out &#x3D; ctx.alloc().buffer();\n        &#x2F;&#x2F; 1. 4 字节的魔数\n        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        &#x2F;&#x2F; 2. 1 字节的版本,\n        out.writeByte(1);\n        &#x2F;&#x2F; 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        &#x2F;&#x2F; 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 无意义，对齐填充\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 6. 获取内容的字节数组\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n        &#x2F;&#x2F; 7. 长度\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        int magicNum &#x3D; in.readInt();\n        byte version &#x3D; in.readByte();\n        byte serializerType &#x3D; in.readByte();\n        byte messageType &#x3D; in.readByte();\n        int sequenceId &#x3D; in.readInt();\n        in.readByte();\n        int length &#x3D; in.readInt();\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(&quot;&#123;&#125;&quot;, message);\n        out.add(message);\n    &#125;\n&#125;\n\n\n\npublic class TestMessageCodec &#123;\n    public static void main(String[] args) throws Exception &#123;\n\n        &#x2F;&#x2F;[无状态]线程安全：加了@Sharable\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler();&#x2F;&#x2F;可抽取到外面被共享！\n\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(\n                LOGGING_HANDLER,\n                &#x2F;&#x2F;被多个EventLoop用到，记录多次msg间的状态，[有状态]线程不安全:需要每次new！！！\n                &#x2F;&#x2F;worker1ch 1234\n                &#x2F;&#x2F;worker2ch 1234\n                new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0),\n                new MessageCodec());&#x2F;&#x2F;or FRAME_DECODER+MessageCodecSharable?\n\n\n\n\n3. &#x3D;&#x3D;【QQ】聊天室案例&#x3D;&#x3D;3.1 聊天室业务介绍&#x2F;**\n * 用户管理接口\n *&#x2F;\npublic interface UserService &#123;\n\n    &#x2F;**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     *&#x2F;\n    boolean login(String username, String password);\n&#125;\n\n\n\n&#x2F;**\n * 会话管理接口\n *&#x2F;\npublic interface Session &#123;\n\n    &#x2F;**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     *&#x2F;\n    void bind(Channel channel, String username);\n\n    &#x2F;**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     *&#x2F;\n    void unbind(Channel channel);\n\n    &#x2F;**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     *&#x2F;\n    Object getAttribute(Channel channel, String name);\n\n    &#x2F;**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     *&#x2F;\n    void setAttribute(Channel channel, String name, Object value);\n\n    &#x2F;**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     *&#x2F;\n    Channel getChannel(String username);\n&#125;\n\n\n\n&#x2F;**\n * 聊天组会话管理接口\n *&#x2F;\npublic interface GroupSession &#123;\n\n    &#x2F;**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     *&#x2F;\n    Group createGroup(String name, Set&lt;String&gt; members);\n\n    &#x2F;**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group joinMember(String name, String member);\n\n    &#x2F;**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeMember(String name, String member);\n\n    &#x2F;**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeGroup(String name);\n\n    &#x2F;**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 没有成员会返回 empty set\n     *&#x2F;\n    Set&lt;String&gt; getMembers(String name);\n\n    &#x2F;**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     *&#x2F;\n    List&lt;Channel&gt; getMembersChannel(String name);\n&#125;\n\n\n\n3.2 聊天室业务-登录@Slf4j\npublic class ChatServer &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;() &#123;&#x2F;&#x2F;待抽取出来！LoginRequestMessageHandler\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;\n                            String username &#x3D; msg.getUsername();\n                            String password &#x3D; msg.getPassword();\n                            boolean login &#x3D; UserServiceFactory.getUserService().login(username, password);\n                            LoginResponseMessage message;\n                            if(login) &#123;\n                                message &#x3D; new LoginResponseMessage(true, &quot;登录成功&quot;);\n                            &#125; else &#123;\n                                message &#x3D; new LoginResponseMessage(false, &quot;用户名或密码不正确&quot;);\n                            &#125;\n                            ctx.writeAndFlush(message);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n\n\n@Slf4j\npublic class ChatClient &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN &#x3D; new CountDownLatch(1);&#x2F;&#x2F;\n        AtomicBoolean LOGIN &#x3D; new AtomicBoolean(false);&#x2F;&#x2F;\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n&#x2F;&#x2F;                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(&quot;client handler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                        &#x2F;&#x2F; 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                            log.debug(&quot;msg: &#123;&#125;&quot;, msg);\n                            if ((msg instanceof LoginResponseMessage)) &#123;\n                                LoginResponseMessage response &#x3D; (LoginResponseMessage) msg;\n                                if (response.isSuccess()) &#123;\n                                    &#x2F;&#x2F; 如果登录成功\n                                    LOGIN.set(true);\n                                &#125;\n                                &#x2F;&#x2F; 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            &#125;\n                        &#125;\n\n                        &#x2F;&#x2F; 在连接建立后触发 active 事件\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            &#x2F;&#x2F; 负责接收用户在控制台的输入，负责向服务器发送各种消息\n                            new Thread(() -&gt; &#123;\n                                Scanner scanner &#x3D; new Scanner(System.in);\n                                System.out.println(&quot;请输入用户名:&quot;);\n                                String username &#x3D; scanner.nextLine();\n                                System.out.println(&quot;请输入密码:&quot;);\n                                String password &#x3D; scanner.nextLine();\n                                &#x2F;&#x2F; 构造消息对象\n                                LoginRequestMessage message &#x3D; new LoginRequestMessage(username, password);\n                                &#x2F;&#x2F; 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println(&quot;等待后续操作...&quot;);\n                                try &#123;\n                                    WAIT_FOR_LOGIN.await();\n                                &#125; catch (InterruptedException e) &#123;\n                                    e.printStackTrace();\n                                &#125;\n                                &#x2F;&#x2F; 如果登录失败\n                                if (!LOGIN.get()) &#123;\n                                    ctx.channel().close();\n                                    return;\n                                &#125;\n                                while (true) &#123;\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    System.out.println(&quot;send [username] [content]&quot;);\n                                    System.out.println(&quot;gsend [group name] [content]&quot;);\n                                    System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);\n                                    System.out.println(&quot;gmembers [group name]&quot;);\n                                    System.out.println(&quot;gjoin [group name]&quot;);\n                                    System.out.println(&quot;gquit [group name]&quot;);\n                                    System.out.println(&quot;quit&quot;);\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    String command &#x3D; scanner.nextLine();\n                                    String[] s &#x3D; command.split(&quot; &quot;);\n                                    switch (s[0])&#123;\n                                        case &quot;send&quot;:\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gsend&quot;:\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gcreate&quot;:\n                                            Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(s[2].split(&quot;,&quot;)));\n                                            set.add(username); &#x2F;&#x2F; 加入自己！易忘！\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case &quot;gmembers&quot;:\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case &quot;gjoin&quot;:\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;gquit&quot;:\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;quit&quot;:\n                                            ctx.channel().close();\n                                            return;\n                                    &#125;\n                                &#125;\n                            &#125;, &quot;system in&quot;).start();\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n\n\n3.3 聊天室业务-单聊服务器端将 handler 独立出来：利用idea的重构功能\nSimpleChannelInboundHandler  右键refactor、convert anonymous to inner…【F6】\nprivate static class LoginRequestMessageHandler：右键refactor、move inner class【选first：move to upper level】 到server.handler包中,main.下的\n无状态：@Sharable\n登录 handler\n@ChannelHandler.Sharable\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;\n        String username &#x3D; msg.getUsername();\n        String password &#x3D; msg.getPassword();\n        boolean login &#x3D; UserServiceFactory.getUserService().login(username, password);&#x2F;&#x2F;\n        LoginResponseMessage message;\n        if(login) &#123;\n            SessionFactory.getSession().bind(ctx.channel(), username);&#x2F;&#x2F;name&lt;-&gt;channel双向ConcurrentHashMap\n            message &#x3D; new LoginResponseMessage(true, &quot;登录成功&quot;);\n        &#125; else &#123;\n            message &#x3D; new LoginResponseMessage(false, &quot;用户名或密码不正确&quot;);\n        &#125;\n        ctx.writeAndFlush(message);\n    &#125;\n&#125;\n\n单聊 handler\n@ChannelHandler.Sharable\npublic class ChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;ChatRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception &#123;\n        String to &#x3D; msg.getTo();\n        Channel channel &#x3D; SessionFactory.getSession().getChannel(to);&#x2F;&#x2F;\n        &#x2F;&#x2F; 在线\n        if(channel !&#x3D; null) &#123;\n            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));\n        &#125;\n        &#x2F;&#x2F; 不在线\n        else &#123;\n            ctx.writeAndFlush(new ChatResponseMessage(false, &quot;对方用户不存在或者不在线&quot;));\n        &#125;\n    &#125;\n&#125;\n\n1Server 2Client：  zhangsan123  lisi123\nsend lisi 你好         send zhangsan hello！\n3.4 聊天室业务-群聊创建群聊\n@ChannelHandler.Sharable\npublic class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupCreateRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception &#123;\n        String groupName &#x3D; msg.getGroupName();\n        Set&lt;String&gt; members &#x3D; msg.getMembers();\n        &#x2F;&#x2F; 群管理器\n        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();\n        Group group &#x3D; groupSession.createGroup(groupName, members);&#x2F;&#x2F;ConcurrentHashMap groupMap.putIfAbsent()\n        if (group &#x3D;&#x3D; null) &#123;\n            &#x2F;&#x2F; 发送成功消息\n            ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + &quot;创建成功&quot;));\n            &#x2F;&#x2F; 群发拉群消息\n            List&lt;Channel&gt; channels &#x3D; groupSession.getMembersChannel(groupName);&#x2F;&#x2F;Java8 过滤出nonNull_members!!!\n            for (Channel channel : channels) &#123;\n                channel.writeAndFlush(new GroupCreateResponseMessage(true, &quot;您已被拉入&quot; + groupName));\n            &#125;\n        &#125; else &#123;\n            ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + &quot;已经存在&quot;));\n        &#125;\n    &#125;\n&#125;\n\n\n1Server 3Client：  zhangsan123  lisi123  wangwu123\nzhangsan发：gcreate 群聊1 lisi,wangwu\n群聊\n@ChannelHandler.Sharable\npublic class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupChatRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception &#123;\n        List&lt;Channel&gt; channels &#x3D; GroupSessionFactory.getGroupSession()\n                .getMembersChannel(msg.getGroupName());\n\n        for (Channel channel : channels) &#123;\n            channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));&#x2F;&#x2F;群内成员：收到来自from的msg_content\n        &#125;\n    &#125;\n&#125;\n\n1Server 3Client：  zhangsan123  lisi123  wangwu123 zhaoliu123\nzhangsan发：gcreate 群聊1 lisi,wangwu\ngsend 群聊1 大家好\n【作业】\n加入群聊\n@ChannelHandler.Sharable\npublic class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupJoinRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception &#123;\n        Group group &#x3D; GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());\n        if (group !&#x3D; null) &#123;\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群加入成功&quot;));\n        &#125; else &#123;\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群不存在&quot;));\n        &#125;\n    &#125;\n&#125;\n\ngjoin 群聊1\n退出群聊\n@ChannelHandler.Sharable\npublic class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupQuitRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception &#123;\n        Group group &#x3D; GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());\n        if (group !&#x3D; null) &#123;\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, &quot;已退出群&quot; + msg.getGroupName()));\n        &#125; else &#123;\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群不存在&quot;));\n        &#125;\n    &#125;\n&#125;\n\ngquit 群聊1\n查看成员\n@ChannelHandler.Sharable\npublic class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupMembersRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception &#123;\n        Set&lt;String&gt; members &#x3D; GroupSessionFactory.getGroupSession()\n                .getMembers(msg.getGroupName());&#x2F;&#x2F;getOrDefault！\n        ctx.writeAndFlush(new GroupMembersResponseMessage(members));\n    &#125;\n&#125;\n\ngmembers 群聊1\n3.5 聊天室业务-退出@Slf4j\n@ChannelHandler.Sharable\npublic class QuitHandler extends ChannelInboundHandlerAdapter &#123;\n\n    &#x2F;&#x2F; 当连接断开时触发 inactive 事件  [quit]ctx.channel().close();\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(&quot;&#123;&#125; 已经断开&quot;, ctx.channel());\n    &#125;\n\n    &#x2F;&#x2F; 当出现异常时触发 直接关闭！\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;&#x2F;&#x2F;\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;, ctx.channel(), cause.getMessage());\n    &#125;\n&#125;\n\n\n\n\n3.6 聊天室业务-空闲检测连接假死-心跳原因\n\n网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。\n公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着\n应用程序线程阻塞，无法进行数据读写\n\n问题\n\n假死的连接占用的资源不能自动释放\n向假死的连接发送数据，得到的反馈是发送超时\n\nS服务器端解决\n\n怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就[空闲检测]检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死\n\n&#x2F;&#x2F; 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n&#x2F;&#x2F; 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件（属于自定义的特殊事件！）\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));&#x2F;&#x2F;R,W,all  太小不好测，就断了，10s\n&#x2F;&#x2F; ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n    &#x2F;&#x2F; 用来触发【非io】特殊事件，例如IdleState#READER_IDLE 事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception&#123;\n        IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n        &#x2F;&#x2F; 触发了读空闲事件\n        if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE) &#123;\n            log.debug(&quot;已经 5s 没有读到数据了&quot;);\n            ctx.channel().close();\n        &#125;\n    &#125;\n&#125;);\n\n\n\nC客户端定时心跳\n\n客户端可以定时向服务器端[发送心跳]数据，只要这个时间间隔[小于服务器定义的空闲检测]的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器\n\n&#x2F;&#x2F; 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n&#x2F;&#x2F; 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n&#x2F;&#x2F; ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n    &#x2F;&#x2F; 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception&#123;\n        IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n        &#x2F;&#x2F; 触发了写空闲事件\n        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;\n            &#x2F;&#x2F;log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);&#x2F;&#x2F;注释掉，避免打断输入！\n            ctx.writeAndFlush(new PingMessage());\n        &#125;\n    &#125;\n&#125;);\n\n四. 优化与源码1. 优化1.1 扩展序列化算法序列化，反序列化主要用在消息正文的转换上\n\n序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）\n反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理\n\n目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下\n&#x2F;&#x2F; 反序列化\nbyte[] body &#x3D; new byte[bodyLength];\nbyteByf.readBytes(body);\nObjectInputStream in &#x3D; new ObjectInputStream(new ByteArrayInputStream(body));\nMessage message &#x3D; (Message) in.readObject();\nmessage.setSequenceId(sequenceId);\n\n&#x2F;&#x2F; 序列化\nByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();\nnew ObjectOutputStream(out).writeObject(message);\nbyte[] bytes &#x3D; out.toByteArray();\n\n为了支持更多序列化算法，抽象一个 Serializer 接口\npublic interface Serializer &#123;\n\n    &#x2F;&#x2F; 反序列化方法\n    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);\n\n    &#x2F;&#x2F; 序列化方法\n    &lt;T&gt; byte[] serialize(T object);\n\n&#125;\n\n提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中\nenum SerializerAlgorithm implements Serializer &#123;\n\t&#x2F;&#x2F; Java 实现\n    Java &#123;\n        @Override\n        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n            try &#123;\n                ObjectInputStream in &#x3D; \n                    new ObjectInputStream(new ByteArrayInputStream(bytes));\n                Object object &#x3D; in.readObject();\n                return (T) object;\n            &#125; catch (IOException | ClassNotFoundException e) &#123;\n                throw new RuntimeException(&quot;SerializerAlgorithm.Java 反序列化错误&quot;, e);\n            &#125;\n        &#125;\n\n        @Override\n        public &lt;T&gt; byte[] serialize(T object) &#123;\n            try &#123;\n                ByteArrayOutputStream out &#x3D; new ByteArrayOutputStream();\n                new ObjectOutputStream(out).writeObject(object);\n                return out.toByteArray();\n            &#125; catch (IOException e) &#123;\n                throw new RuntimeException(&quot;SerializerAlgorithm.Java 序列化错误&quot;, e);\n            &#125;\n        &#125;\n    &#125;, \n    &#x2F;&#x2F; Json 实现(引入了 Gson 依赖)\n    Json &#123;\n        @Override\n        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n            return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz);&#x2F;&#x2F;\n        &#125;\n\n        @Override\n        public &lt;T&gt; byte[] serialize(T object) &#123;\n            return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8);&#x2F;&#x2F;\n        &#125;\n    &#125;;\n\n    &#x2F;&#x2F; 需要从协议的字节中得到是哪种序列化算法【弃用，有API！】\n    public static SerializerAlgorithm getByInt(int type) &#123;\n        SerializerAlgorithm[] array &#x3D; SerializerAlgorithm.values();\n        if (type &lt; 0 || type &gt; array.length - 1) &#123;\n            throw new IllegalArgumentException(&quot;超过 SerializerAlgorithm 范围&quot;);\n        &#125;\n        return array[type];\n    &#125;\n&#125;\n\n我的做法：\npackage cn.itcast.protocol;\n\nimport com.google.gson.*;\n\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.nio.charset.StandardCharsets;\n\n&#x2F;**\n * 用于扩展序列化、反序列化算法\n *&#x2F;\npublic interface Serializer &#123;\n\n    &#x2F;&#x2F; 反序列化方法\n    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);\n\n    &#x2F;&#x2F; 序列化方法\n    &lt;T&gt; byte[] serialize(T object);\n\n    enum Algorithm implements Serializer &#123;\n\n        Java &#123;\n            @Override\n            public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n                try &#123;\n                    ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));&#x2F;&#x2F;ois-bis-byt[]\n                    return (T) ois.readObject();&#x2F;&#x2F;(T)\n                &#125; catch (IOException | ClassNotFoundException e) &#123;&#x2F;&#x2F;|\n                    throw new RuntimeException(&quot;反序列化失败&quot;, e);\n                &#125;\n            &#125;\n\n            @Override\n            public &lt;T&gt; byte[] serialize(T object) &#123;\n                try &#123;\n                    ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n                    ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n                    oos.writeObject(object);&#x2F;&#x2F;oos-bos-obj  bos-&gt;byte[]\n                    return bos.toByteArray();\n                &#125; catch (IOException e) &#123;\n                    throw new RuntimeException(&quot;序列化失败&quot;, e);\n                &#125;\n            &#125;\n        &#125;,\n\n        Json &#123;\n            @Override\n            public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;+ClassCodec\n                String json &#x3D; new String(bytes, StandardCharsets.UTF_8);\n&#x2F;&#x2F;                return new Gson().fromJson(json, clazz);&#x2F;&#x2F;\n                return gson.fromJson(json, clazz);\n            &#125;\n\n            @Override\n            public &lt;T&gt; byte[] serialize(T object) &#123;\n                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;+ClassCodec\n                String json &#x3D; gson.toJson(object);\n&#x2F;&#x2F;                String json &#x3D; new Gson().toJson(object);\n                return json.getBytes(StandardCharsets.UTF_8);\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;自定义ClassCodec\n    class ClassCodec implements JsonSerializer&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;\n\n        @Override\n        public Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123;\n            try &#123;\n                String str &#x3D; json.getAsString();\n                return Class.forName(str);\n            &#125; catch (ClassNotFoundException e) &#123;\n                throw new JsonParseException(e);\n            &#125;\n        &#125;\n\n        @Override             &#x2F;&#x2F;   String.class\n        public JsonElement serialize(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context) &#123;\n            &#x2F;&#x2F; class -&gt; json\n            return new JsonPrimitive(src.getName());\n        &#125;\n    &#125;\n&#125;\n\nregisterTypeAdapter(java.lang.reflect.Type type, java.lang.Object typeAdapter) 为type类型字段，指定特殊的类型适配器例子01：格式化日期类型\n@JsonAdapter 一样的方式可以支持 JsonDeserializer,JsonSerializer,InstanceCreator,TypeAdapter四种适配器类型————————————————版权声明：本文为CSDN博主「向上小蚂蚁」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/jieandan/article/details/109774650\n增加配置类和配置文件\npublic abstract class Config &#123;\n    static Properties properties;\n    static &#123;\n        try (InputStream in &#x3D; Config.class.getResourceAsStream(&quot;&#x2F;application.properties&quot;)) &#123;\n            properties &#x3D; new Properties();\n            properties.load(in);\n        &#125; catch (IOException e) &#123;\n            throw new ExceptionInInitializerError(e);\n        &#125;\n    &#125;\n    public static int getServerPort() &#123;\n        String value &#x3D; properties.getProperty(&quot;server.port&quot;);\n        if(value &#x3D;&#x3D; null) &#123;\n            return 8080;\n        &#125; else &#123;\n            return Integer.parseInt(value);\n        &#125;\n    &#125;\n    public static Serializer.Algorithm getSerializerAlgorithm() &#123;\n        String value &#x3D; properties.getProperty(&quot;serializer.algorithm&quot;);\n        if(value &#x3D;&#x3D; null) &#123;\n            return Serializer.Algorithm.Java;\n        &#125; else &#123;\n            return Serializer.Algorithm.valueOf(value);&#x2F;&#x2F;\n        &#125;\n    &#125;\n&#125;\n\n\n\n配置文件\nserializer.algorithm&#x3D;Json\n\n\n\n修改编解码器\nout.writeByte(Config.getSerializerAlgorithm().ordinal());&#x2F;&#x2F;Java-&gt;0\n&#x2F;&#x2F; 找到反序列化算法        Serializer.Algorithm algorithm &#x3D; Serializer.Algorithm.values()[serializerAlgorithm];&#x2F;&#x2F;.values()[0]&#x3D;Java 枚举类对象\n&#x2F;**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n *&#x2F;\npublic class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;\n    @Override\n    public void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        ByteBuf out &#x3D; ctx.alloc().buffer();\n        &#x2F;&#x2F; 1. 4 字节的魔数\n        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        &#x2F;&#x2F; 2. 1 字节的版本,\n        out.writeByte(1);\n        &#x2F;&#x2F; 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(Config.getSerializerAlgorithm().ordinal());&#x2F;&#x2F;Java-&gt;0\n        &#x2F;&#x2F; 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 无意义，对齐填充\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 6. 获取内容的字节数组\n        byte[] bytes &#x3D; Config.getSerializerAlgorithm().serialize(msg);\n        &#x2F;&#x2F; 7. 长度\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        int magicNum &#x3D; in.readInt();\n        byte version &#x3D; in.readByte();\n        byte serializerAlgorithm &#x3D; in.readByte(); &#x2F;&#x2F; 0 或 1\n        byte messageType &#x3D; in.readByte(); &#x2F;&#x2F; 0,1,2...\n        int sequenceId &#x3D; in.readInt();\n        in.readByte();\n        int length &#x3D; in.readInt();\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n\n&#x2F;&#x2F;        Message msg &#x3D; Serializer.Algorithm.Java.deserialize(Message.class, bytes);&#x2F;&#x2F;不行：1.写死Java 2.Message是抽象类！要确定具体msg.class！\n\n        &#x2F;&#x2F; 找到反序列化算法\n        Serializer.Algorithm algorithm &#x3D; Serializer.Algorithm.values()[serializerAlgorithm];&#x2F;&#x2F;.values()[0]&#x3D;Java 枚举类对象\n        &#x2F;&#x2F; 确定具体消息类型\n        Class&lt;? extends Message&gt; messageClass &#x3D; Message.getMessageClass(messageType);\n        Message message &#x3D; algorithm.deserialize(messageClass, bytes);\n&#x2F;&#x2F;        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);\n&#x2F;&#x2F;        log.debug(&quot;&#123;&#125;&quot;, message);\n        out.add(message);\n    &#125;\n&#125;\n\n\n\n其中确定具体消息类型，可以根据 消息类型字节 获取到对应的 消息 class\n@Data\npublic abstract class Message implements Serializable &#123;\n\n    &#x2F;**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     *&#x2F;\n    public static Class&lt;? extends Message&gt; getMessageClass(int messageType) &#123;\n        return messageClasses.get(messageType);\n    &#125;\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage &#x3D; 0;\n    public static final int LoginResponseMessage &#x3D; 1;\n    public static final int ChatRequestMessage &#x3D; 2;\n    public static final int ChatResponseMessage &#x3D; 3;\n    public static final int GroupCreateRequestMessage &#x3D; 4;\n    public static final int GroupCreateResponseMessage &#x3D; 5;\n    public static final int GroupJoinRequestMessage &#x3D; 6;\n    public static final int GroupJoinResponseMessage &#x3D; 7;\n    public static final int GroupQuitRequestMessage &#x3D; 8;\n    public static final int GroupQuitResponseMessage &#x3D; 9;\n    public static final int GroupChatRequestMessage &#x3D; 10;\n    public static final int GroupChatResponseMessage &#x3D; 11;\n    public static final int GroupMembersRequestMessage &#x3D; 12;\n    public static final int GroupMembersResponseMessage &#x3D; 13;\n    public static final int PingMessage &#x3D; 14;\n    public static final int PongMessage &#x3D; 15;\n    private static final Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);\n    &#125;\n&#125;\n\ntest.java下netty.c5.TestSerializer：\npackage cn.itcast.netty.c5;\n\npublic class TestSerializer &#123;\n\n    public static void main(String[] args)  &#123;\n        MessageCodecSharable CODEC &#x3D; new MessageCodecSharable();\n        LoggingHandler LOGGING &#x3D; new LoggingHandler();\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(LOGGING, CODEC, LOGGING);&#x2F;&#x2F;(handlers) log编解码前后\n\n        LoginRequestMessage message &#x3D; new LoginRequestMessage(&quot;zhangsan&quot;, &quot;123&quot;);\n        &#x2F;&#x2F;&lt;-out_编码_序列化  前log：Java对象msg-&gt;后log：buf[]_Json串【Jdk序列化：较长，bin看不懂】 ret boolean\n        channel.writeOutbound(message);\n        &#x2F;&#x2F;因为MessageCodecSharable.encode(ctx,)方法不能直接用:ByteBuf out &#x3D; 入参ctx.alloc().buffer();内部分配使用\n        ByteBuf buf &#x3D; messageToByteBuf(message);\n        &#x2F;&#x2F;-&gt;in_解码_反序列化  前log：buf[]_Json串-&gt;后log：Java对象\n        channel.writeInbound(buf);\n    &#125;\n\n    public static ByteBuf messageToByteBuf(Message msg) &#123;&#x2F;&#x2F;Java对象-&gt;ByteBuf\n        int algorithm &#x3D; Config.getSerializerAlgorithm().ordinal();\n        ByteBuf out &#x3D; ByteBufAllocator.DEFAULT.buffer();&#x2F;&#x2F;自己分配ByteBuf\n        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        out.writeByte(1);\n        out.writeByte(algorithm);\n        out.writeByte(msg.getMessageType());\n        out.writeInt(msg.getSequenceId());\n        out.writeByte(0xff);\n        byte[] bytes &#x3D; Serializer.Algorithm.values()[algorithm].serialize(msg);&#x2F;&#x2F;\n        out.writeInt(bytes.length);\n        out.writeBytes(bytes);\n        return out;\n    &#125;\n&#125;\n\n\n\n\n1.2 参数调优1）CONNECT_TIMEOUT_MILLIS\n属于 SocketChannal 参数\n用在客户端建立连接时(Server只有accept()接收连接)，如果在指定毫秒内无法连接，会抛出 timeout 异常\n易混淆：SO_TIMEOUT 主要用在[传统阻塞 IO]，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间【不用在nio、netty编程！】\n\ntest下的source包下：\n@Slf4j\npublic class TestConnectionTimeout &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1. 客户端通过 .option() 方法配置参数 给 SocketChannel 配置参数\n\n        &#x2F;&#x2F; 2. 服务器端\n&#x2F;&#x2F;        new ServerBootstrap().option() &#x2F;&#x2F; 是给 ServerSocketChannel 配置参数\n&#x2F;&#x2F;        new ServerBootstrap().childOption() &#x2F;&#x2F; 给 SocketChannel 配置参数\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap()\n                    .group(group)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)&#x2F;&#x2F;3000ms超时:等不到\n                    .channel(NioSocketChannel.class)\n                    .handler(new LoggingHandler());\n            ChannelFuture future &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080);\n            future.sync().channel().closeFuture().sync(); &#x2F;&#x2F; 断点1\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            log.debug(&quot;timeout&quot;);\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n2s就确认Server端没开，连接拒绝。不等超时就报错\nCaused by: java.net.ConnectException: Connection refused: no further information\n1.future.sync().channel().closeFuture().sync();\n2.抛异常处(AbstractNioChannel.java:263) \n两处+端点【右键，类型必须是：Thread类型！】，debug：\nfuture 右键mark object\n换nioTH：\n另外源码部分 io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect\neventLoop-监测nio事件 内有nioth &#x2F; th：提交(定时)任务 schedule 连接超时\n@Override\npublic final void connect(\n        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; Schedule connect timeout.\n    int connectTimeoutMillis &#x3D; config().getConnectTimeoutMillis();&#x2F;&#x2F;\n    if (connectTimeoutMillis &gt; 0) &#123;\n        connectTimeoutFuture &#x3D; eventLoop().schedule(new Runnable() &#123;\n            @Override\n            public void run() &#123;                \n                ChannelPromise connectPromise &#x3D; AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause &#x3D;\n                    new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress); &#x2F;&#x2F; 断点2 异常\n                if (connectPromise !&#x3D; null &amp;&amp; connectPromise.tryFailure(cause)) &#123;&#x2F;&#x2F;异常cause-唤醒主sync() catch...\n                    close(voidPromise());\n                &#125;\n            &#125;\n        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    &#125;\n\t&#x2F;&#x2F; ...\n&#125;\n\nPromise  定时任务\n2）SO_BACKLOG\n属于 ServerSocketChannal 参数（建立连接时设置）\n\nsequenceDiagram\n\nparticipant c as client\nparticipant s as server\nparticipant sq as sync queue\nparticipant aq as accept queue\n\ns -&gt;&gt; s : bind()\ns -&gt;&gt; s : listen()\nc -&gt;&gt; c : connect()\nc -&gt;&gt; s : 1. SYN\nNote left of c : SYN_SEND\ns -&gt;&gt; sq : put\nNote right of s : SYN_RCVD\ns -&gt;&gt; c : 2. SYN + ACK\nNote left of c : ESTABLISHED\nc -&gt;&gt; s : 3. ACK\nsq -&gt;&gt; aq : put\nNote right of s : ESTABLISHED\naq --&gt;&gt; s : \ns -&gt;&gt; s : accept()\n\n\n第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列\n第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server\n第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue(半连接队列) 放入 accept queue(全连接队列)\n\n其中\n\n在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制\n\nsync queue - 半连接队列\n\n大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog 指定，在 syncookies 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略\n\n\naccept queue - 全连接队列\n\n其大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值      \nmin(nio程序中bind(8080, backlog); , somaxconn)\n如果 accpet queue 队列满了，server 将发送一个【拒绝连接】的错误信息到 client\n\n\n\nnetty 中\n可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小  &#x2F;&#x2F; 全队列满了\nnetty处理能力强，处理不了了才会堆积到全连接队列里\n\n打断点，不让调accept()从全连接队列里取，造成堆积！\nqueue&#x3D;2  debug_server、run3个Client（Allow parallel run）：报错ConnectException: Connection refused\n可以通过下面源码查看默认大小\nServerSocketChannel中bind()被调用，backlog被赋值：find usage\nnetty中的，doBind()：javaChannel().bind(localAddress, config.getBacklog());\nServerSocketChannelConfig：Ctrl_Alt_B看实现：DefaultServerSocketChannelConfig\npublic class DefaultServerSocketChannelConfig extends DefaultChannelConfig\n                                              implements ServerSocketChannelConfig &#123;\n\n    private volatile int backlog &#x3D; NetUtil.SOMAXCONN;&#x2F;&#x2F;\n    &#x2F;&#x2F; ...\n&#125;\n\n\nNetUtil:\n        SOMAXCONN &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Integer&gt;() &#123;\n            @Override\n            public Integer run() &#123;\n                &#x2F;&#x2F; Determine the default somaxconn (server socket backlog) value of the platform.\n                &#x2F;&#x2F; The known defaults:\n                &#x2F;&#x2F; - Windows NT Server 4.0+: 200\n                &#x2F;&#x2F; - Linux and Mac OS X: 128\n                int somaxconn &#x3D; PlatformDependent.isWindows() ? 200 : 128;&#x2F;&#x2F;\n                File file &#x3D; new File(&quot;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn&quot;);&#x2F;&#x2F;\n                BufferedReader in &#x3D; null;\n                try &#123;\n                    &#x2F;&#x2F; file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the\n                    &#x2F;&#x2F; try &#x2F; catch block.\n                    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;4936\n                    if (file.exists()) &#123;\n                        in &#x3D; new BufferedReader(new FileReader(file));\n                        somaxconn &#x3D; Integer.parseInt(in.readLine());&#x2F;&#x2F;\n\n\n\n课堂调试关键断点为：io.netty.channel.nio.NioEventLoop#processSelectedKey\noio 中更容易说明，不用 debug 模式\npublic class Server &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket ss &#x3D; new ServerSocket(8888, 2);\n        Socket accept &#x3D; ss.accept();&#x2F;&#x2F;oio accept阻塞！\n        System.out.println(accept);\n        System.in.read();\n    &#125;\n&#125;\n\n客户端启动 4 个\npublic class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        try &#123;\n            Socket s &#x3D; new Socket();\n            System.out.println(new Date()+&quot; connecting...&quot;);\n            s.connect(new InetSocketAddress(&quot;localhost&quot;, 8888),1000);\n            System.out.println(new Date()+&quot; connected...&quot;);\n            s.getOutputStream().write(1);\n            System.in.read();\n        &#125; catch (IOException e) &#123;\n            System.out.println(new Date()+&quot; connecting timeout...&quot;);\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中\nTue Apr 21 20:30:28 CST 2020 connecting...\nTue Apr 21 20:30:28 CST 2020 connected...\n\n第 4 个客户端连接时\nTue Apr 21 20:53:58 CST 2020 connecting...\nTue Apr 21 20:53:59 CST 2020 connecting timeout...\njava.net.SocketTimeoutException: connect timed out\n\n\n\n\n\n3）ulimit -n\n属于操作系统参数\n\n一个thread能打开的fd(文件描述符)的最大数量【too many open file】，避免进程打开的文件&#x2F;Socket数太多\n应对高并发，临时调高，建议放在启动脚本中！\n4）TCP_NODELAY\n属于 SocketChannal 参数\nfalse：开启了Nagle，攒一批发有延迟\t建议改为true，用childOption\n\n\n5）SO_SNDBUF &amp; SO_RCVBUF[滑动窗口上限]\nSO_SNDBUF 属于 SocketChannal 参数\nSO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）\n\n[mem占用高了，OS自动会将其自适应调小] 不用调！\n6）ALLOCATOR\n属于 SocketChannal 参数\n\n用来分配 ByteBuf， ctx.alloc()\n\n&#96;&#96;&#96;测试类：TestByteBuf  TestBacklogClient\n\n* ctx.alloc().buffer()    PooledUnsafeDirectByteBuf\n\nChannelConfig  DefaultChannelConfig  ByteBufAllocator.DEFAULT;\n\n...ByteBufUtil：\n\n&#96;&#96;&#96;java\nstatic &#123;\n        String allocType &#x3D; SystemPropertyUtil.get(\n                &quot;io.netty.allocator.type&quot;, PlatformDependent.isAndroid() ? &quot;unpooled&quot; : &quot;pooled&quot;);&#x2F;&#x2F;\n        allocType &#x3D; allocType.toLowerCase(Locale.US).trim();\n\n        ByteBufAllocator alloc;\n        if (&quot;unpooled&quot;.equals(allocType)) &#123;\n            alloc &#x3D; UnpooledByteBufAllocator.DEFAULT;&#x2F;&#x2F;DEFAULT\n            logger.debug(&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;, allocType);\n   \n    public static final UnpooledByteBufAllocator DEFAULT &#x3D;\n            new UnpooledByteBufAllocator(PlatformDependent.directBufferPreferred());\n       \n            \n    public static boolean directBufferPreferred() &#123;\n        return DIRECT_BUFFER_PREFERRED;\n    &#125;\n            \nDIRECT_BUFFER_PREFERRED\n\n被使用处：\n&#x2F;&#x2F; We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.\nDIRECT_BUFFER_PREFERRED &#x3D; CLEANER !&#x3D; NOOP\n                          &amp;&amp; !SystemPropertyUtil.getBoolean(&quot;io.netty.noPreferDirect&quot;, false);\n\nTestByteBuf    VM option: \n-Dio.netty.allocator.type&#x3D;unpooled -Dio.netty.noPreferDirect&#x3D;true\n\nInstrumentedUnpooledUnsafeHeapByteBuf\n7）RCVBUF_ALLOCATOR\n属于 SocketChannal 参数\n控制 netty 接收缓冲区大小\n负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 上一个参数:6）allocator 决定\n\nio数据RW操作：统一direct\n测试类：TestByteBuf  TestBacklogClient\n\nTestByteBuf    VM option: \n-Dio.netty.allocator.type&#x3D;unpooled -Dio.netty.noPreferDirect&#x3D;true\n\nlog.debug(&quot;receive buf &#123;&#125;&quot;, msg);&#x2F;&#x2F;\nSystem.out.println(&quot;&quot;);&#x2F;&#x2F;打断点 debug\n\n\nDebugger：黄色区域is该线程的堆栈调用链\nHandler、pipeline、找到AbstractNioByteChannel\nbyteBuf &#x3D; allocHandle.allocate(allocator);\n\nfinal ChannelPipeline pipeline &#x3D; pipeline();\n            final ByteBufAllocator allocator &#x3D; config.getAllocator();&#x2F;&#x2F;byteBuf的分配器，(非)池化  ctrl+Alt+B:implement   ---&gt;   ByteBufAllocator.DEFAULT; 读VM参数\n            final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();&#x2F;&#x2F;\n\n            allocHandle.reset(config);\n\n            ByteBuf byteBuf &#x3D; null;\n            boolean close &#x3D; false;\n            try &#123;\n                do &#123;\n                    byteBuf &#x3D; allocHandle.allocate(allocator);&#x2F;&#x2F;是RecvByteBufAllocator的内部类，allocate方法（implement MaxMessageHandle），决定byte的大小和direct\n                    allocHandle.lastBytesRead(doReadBytes(byteBuf));\n\nallocate方法（implement MaxMessageHandle）–&gt;DefaultMaxMessagesRecvByteBufAllocator\n@Override\npublic ByteBuf allocate(ByteBufAllocator alloc) &#123;\n    return alloc.ioBuffer(guess());&#x2F;&#x2F;ioBuf强制Direct  这次发送多，ByteBuf分配更多\n&#125;\n\nAbstractNioByteChannel类：\nallocHandle &#x3D; recvBufAllocHandle();&#x2F;&#x2F;\ngetRecvByteBufAllocator()–&gt;implement\nsetRecvByteBufAllocator(allocator);\n外层函数调用者：\npublic DefaultChannelConfig(Channel channel) &#123;\n    this(channel, new AdaptiveRecvByteBufAllocator());&#x2F;&#x2F;\n&#125;\n\n    &#x2F;**\n     * Creates a new predictor with the default parameters.  With the default\n     * parameters, the expected buffer size starts from &#123;@code 1024&#125;, does not\n     * go down below &#123;@code 64&#125;, and does not go up above &#123;@code 65536&#125;.\n     *&#x2F;\n    public AdaptiveRecvByteBufAllocator() &#123;\n        this(DEFAULT_MINIMUM, DEFAULT_INITIAL, DEFAULT_MAXIMUM);&#x2F;&#x2F;64~1024~65536\n    &#125;\n\n\n\n1.3 &#x3D;&#x3D;典型应用-RPC 框架(基于聊天室ChatSC)【远程方法调用 反射：str-&gt;JavaClass】&#x3D;&#x3D;1）准备工作这些代码可以认为是现成的，无需从头编写练习\n为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息\n@Data\npublic abstract class Message implements Serializable &#123;\n\n    &#x2F;&#x2F; 省略旧的代码\n\n    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;\n\n    static &#123;\n        &#x2F;&#x2F; ...\n        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    &#125;\n\n&#125;\n\n请求消息\n@Getter\n@ToString(callSuper &#x3D; true)\npublic class RpcRequestMessage extends Message &#123;\n\n    &#x2F;**\n     * 调用的接口全限定名，服务端根据它找到实现\n     *&#x2F;\n    private String interfaceName;\n    &#x2F;**\n     * 调用接口中的方法名\n     *&#x2F;\n    private String methodName;\n    &#x2F;**\n     * 方法返回类型\n     *&#x2F;\n    private Class&lt;?&gt; returnType;\n    &#x2F;**\n     * 方法参数类型数组\n     *&#x2F;\n    private Class[] parameterTypes;\n    &#x2F;**\n     * 方法参数值数组\n     *&#x2F;\n    private Object[] parameterValue;\n\n    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue) &#123;\n        super.setSequenceId(sequenceId);\n        this.interfaceName &#x3D; interfaceName;\n        this.methodName &#x3D; methodName;\n        this.returnType &#x3D; returnType;\n        this.parameterTypes &#x3D; parameterTypes;\n        this.parameterValue &#x3D; parameterValue;\n    &#125;\n\n    @Override\n    public int getMessageType() &#123;\n        return RPC_MESSAGE_TYPE_REQUEST;\n    &#125;\n&#125;\n\n响应消息\n@Data\n@ToString(callSuper &#x3D; true)\npublic class RpcResponseMessage extends Message &#123;\n    &#x2F;**\n     * 返回值\n     *&#x2F;\n    private Object returnValue;\n    &#x2F;**\n     * 异常值\n     *&#x2F;\n    private Exception exceptionValue;\n\n    @Override\n    public int getMessageType() &#123;\n        return RPC_MESSAGE_TYPE_RESPONSE;\n    &#125;\n&#125;\n\n服务器架子\n@Slf4j\npublic class RpcServer &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        \n        &#x2F;&#x2F; rpc 请求消息处理器，待实现\n        RpcRequestMessageHandler RPC_HANDLER &#x3D; new RpcRequestMessageHandler();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n客户端架子\npublic class RpcClient &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        \n        &#x2F;&#x2F; rpc 响应消息处理器，待实现\n        RpcResponseMessageHandler RPC_HANDLER &#x3D; new RpcResponseMessageHandler();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n服务器端的 service 获取\npublic class ServicesFactory &#123;\n\n    static Properties properties;\n    static Map&lt;Class&lt;?&gt;, Object&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    static &#123;\n        try (InputStream in &#x3D; Config.class.getResourceAsStream(&quot;&#x2F;application.properties&quot;)) &#123;\n            properties &#x3D; new Properties();\n            properties.load(in);\n            Set&lt;String&gt; names &#x3D; properties.stringPropertyNames();\n            for (String name : names) &#123;\n                if (name.endsWith(&quot;Service&quot;)) &#123;\n                    Class&lt;?&gt; interfaceClass &#x3D; Class.forName(name);\n                    Class&lt;?&gt; instanceClass &#x3D; Class.forName(properties.getProperty(name));\n                    map.put(interfaceClass, instanceClass.newInstance());\n                &#125;\n            &#125;\n        &#125; catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;\n            throw new ExceptionInInitializerError(e);\n        &#125;\n    &#125;\n\n    public static &lt;T&gt; T getService(Class&lt;T&gt; interfaceClass) &#123;\n        return (T) map.get(interfaceClass);\n    &#125;\n&#125;\n\n相关配置 application.properties\nserializer.algorithm&#x3D;Json\ncn.itcast.server.service.HelloService&#x3D;cn.itcast.server.service.HelloServiceImpl\n\n\n\n！2）服务器 handler@Slf4j\n@ChannelHandler.Sharable\npublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) &#123;\n        RpcResponseMessage response &#x3D; new RpcResponseMessage();\n        response.setSequenceId(message.getSequenceId());&#x2F;&#x2F;\n        try &#123;\n            &#x2F;&#x2F; 获取真正的实现对象\n            HelloService service &#x3D; (HelloService)\n                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n            \n            &#x2F;&#x2F; 获取要调用的方法\n            Method method &#x3D; service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n            \n            &#x2F;&#x2F; 调用方法\n            Object invoke &#x3D; method.invoke(service, message.getParameterValue());\n            &#x2F;&#x2F; 调用成功\n            response.setReturnValue(invoke);&#x2F;&#x2F;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            &#x2F;&#x2F; 调用异常\n            response.setExceptionValue(e);&#x2F;&#x2F;\n        &#125;\n        &#x2F;&#x2F; 返回结果\n        ctx.writeAndFlush(response);&#x2F;&#x2F;\n    &#125;\n    &#x2F;*\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;\n        RpcRequestMessage message &#x3D; new RpcRequestMessage(\n                1,\n                &quot;cn.itcast.server.service.HelloService&quot;,\n                &quot;sayHello&quot;,\n                String.class,\n                new Class[]&#123;String.class&#125;,\n                new Object[]&#123;&quot;张三&quot;&#125;\n        );\n        HelloService service &#x3D; (HelloService)\n                ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n        Method method &#x3D; service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n        Object invoke &#x3D; method.invoke(service, message.getParameterValue());\n        System.out.println(invoke);\n    &#125;*&#x2F;\n&#125;\n\n\n\n\n\n3）客户端代码第一版【写死msg对象！自定义处理Handler！自己转换封装obj】只发消息 C：channel 向上出站-&gt;S：向下入站 RpcReqMsgHandler【接口-实现obj-反射调用】 ret-resp S-&gt;C RpcRespMsgHandler_log.debug\n@Slf4j\npublic class RpcClient &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER &#x3D; new RpcResponseMessageHandler();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();&#x2F;&#x2F;\n            &#x2F;&#x2F;channel里手写msg：writeAndFlush异步执行，成功还是失败，看返回值future。异步addListener\n            ChannelFuture future &#x3D; channel.writeAndFlush(new RpcRequestMessage(\n                    1,\n                    &quot;cn.itcast.server.service.HelloService&quot;,\n                    &quot;sayHello&quot;,\n                    String.class,\n                    new Class[]&#123;String.class&#125;,\n                    new Object[]&#123;&quot;张三&quot;&#125;\n            )).addListener(promise -&gt; &#123;\n                if (!promise.isSuccess()) &#123;&#x2F;&#x2F;\n                    Throwable cause &#x3D; promise.cause();&#x2F;&#x2F;\n                    log.error(&quot;error&quot;, cause);\n                &#125;\n            &#125;);\n\n            channel.closeFuture().sync();&#x2F;&#x2F;阻塞！！！待改！！！\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n\n\n4）客户端 handler 第一版@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;\n        log.debug(&quot;&#123;&#125;&quot;, msg);\n    &#125;\n&#125;\n\nrun RpcServer、RpcClient\n现象：active后，不log，不报错\nfuture &#x3D; channel.writeAndFlush\n.addListener(log：promise.cause();)\n打印异常信息：UnsupportedException\n\n修复Gson的Java.Class类型-&gt;Json字符串 的不支持报错：registerTypeAdapter\npublic class TestGson &#123;\n    public static void main(String[] args) &#123;\n        Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;重构Serializer！！！\n        System.out.println(gson.toJson(String.class));&#x2F;&#x2F;class类型-&gt;toJson\n        &#x2F;&#x2F;System.out.println(new Gson().toJson(String.class));&#x2F;&#x2F;class类型-&gt;toJson UnsupportedException!\n    &#125;\n&#125;\n\n\n\n\nprotocol包：\n&#x2F;**\n * 用于扩展序列化、反序列化算法\n *&#x2F;\npublic interface Serializer &#123;\n\n    &#x2F;&#x2F; 反序列化方法\n    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);\n\n    &#x2F;&#x2F; 序列化方法\n    &lt;T&gt; byte[] serialize(T object);\n\n    enum Algorithm implements Serializer &#123;\n\n        Java &#123;\n            @Override\n            public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n                try &#123;\n                    ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));&#x2F;&#x2F;ois-bis-byte[]\n                    return (T) ois.readObject();&#x2F;&#x2F;(T)\n                &#125; catch (IOException | ClassNotFoundException e) &#123;&#x2F;&#x2F;|\n                    throw new RuntimeException(&quot;反序列化失败&quot;, e);\n                &#125;\n            &#125;\n\n            @Override\n            public &lt;T&gt; byte[] serialize(T object) &#123;\n                try &#123;\n                    ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n                    ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n                    oos.writeObject(object);&#x2F;&#x2F;oos-bos-obj  bos-&gt;byte[]\n                    return bos.toByteArray();\n                &#125; catch (IOException e) &#123;\n                    throw new RuntimeException(&quot;序列化失败&quot;, e);\n                &#125;\n            &#125;\n        &#125;,\n\n        Json &#123;\n            @Override\n            public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;+ClassCodec    registerTypeAdapter\n                String json &#x3D; new String(bytes, StandardCharsets.UTF_8);\n&#x2F;&#x2F;                return new Gson().fromJson(json, clazz);&#x2F;&#x2F;\n                return gson.fromJson(json, clazz);\n            &#125;\n\n            @Override\n            public &lt;T&gt; byte[] serialize(T object) &#123;\n                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(Class.class, new Serializer.ClassCodec()).create();&#x2F;&#x2F;+ClassCodec\n                String json &#x3D; gson.toJson(object);\n&#x2F;&#x2F;                String json &#x3D; new Gson().toJson(object);\n                return json.getBytes(StandardCharsets.UTF_8);\n            &#125;\n        &#125;\n    &#125;\n    class ClassCodec implements JsonSerializer&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;\n\n        @Override\n        public Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123;&#x2F;&#x2F;\n            try &#123;\n                String str &#x3D; json.getAsString();&#x2F;&#x2F;\n                return Class.forName(str);&#x2F;&#x2F;\n            &#125; catch (ClassNotFoundException e) &#123;\n                throw new JsonParseException(e);&#x2F;&#x2F;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;自定义ClassCodec\n        @Override             &#x2F;&#x2F;   String.class基本类型\n        public JsonElement serialize(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context) &#123;\n            &#x2F;&#x2F; class -&gt; json\n            return new JsonPrimitive(src.getName());&#x2F;&#x2F;\n        &#125;\n    &#125;\n&#125;\n\n\n通信ok！\n5）客户端代码 第二版【RpcClientManager版：异步网络结果用同步方式】包括 &#x3D;&#x3D;channel 管理(单例)，(JDK Proxy)代理，接收结果(promise.await();异步网络结果同步等待，不抛异常)&#x3D;&#x3D;protocol包：\npublic abstract class SequenceIdGenerator &#123;\n    private static final AtomicInteger id &#x3D; new AtomicInteger();\n\n    public static int nextId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n\n\nnio线程间通信：空promise对象类似于空书包，Client端mainTH-&gt;nio线程RespMsgHandler，接到S端响应msg，装入书包-&gt;mainTH拿出\npromise是个容器，用来在多THs间交换结果\n@Slf4j\npublic class RpcClientManager &#123;\n\n    public static void main(String[] args) &#123;\n        HelloService service &#x3D; getProxyService(HelloService.class);&#x2F;&#x2F;代理对象\n        System.out.println(service.sayHello(&quot;zhangsan&quot;));\n&#x2F;&#x2F;        System.out.println(service.sayHello(&quot;lisi&quot;));\n&#x2F;&#x2F;        System.out.println(service.sayHello(&quot;wangwu&quot;));\n\n    &#125;\n\n    &#x2F;&#x2F;创建代理类：将用户的方法调用转换成底层消息发送，屏蔽细节！\n    public static &lt;T&gt; T getProxyService(Class&lt;T&gt; serviceClass) &#123;\n        &#x2F;&#x2F;JDK Proxy:实现接口\n        ClassLoader loader &#x3D; serviceClass.getClassLoader();\n        Class&lt;?&gt;[] interfaces &#x3D; new Class[]&#123;serviceClass&#125;;\n        &#x2F;&#x2F;                                                           sayHello &quot;张三&quot;\n        Object o &#x3D; Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;\n            &#x2F;&#x2F; 1.将方法调用转换为 消息对象\n            int sequenceId &#x3D; SequenceIdGenerator.nextId();&#x2F;&#x2F;！！！\n            RpcRequestMessage msg &#x3D; new RpcRequestMessage(\n                    sequenceId,\n                    serviceClass.getName(),\n                    method.getName(),\n                    method.getReturnType(),\n                    method.getParameterTypes(),\n                    args\n            );\n            &#x2F;&#x2F; 2.将消息对象发送出去\n            getChannel().writeAndFlush(msg);\n\n            &#x2F;&#x2F; 3.准备一个空 Promise 对象，来接收结果                   指定Promise对象【异步】接收结果的线程\n            DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());&#x2F;&#x2F;父接口是EventExecutor，内有TH\n            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);\n\n&#x2F;&#x2F;            promise.addListener(future -&gt; &#123;\n&#x2F;&#x2F;                &#x2F;&#x2F;TH:Promise对象异步接收结果的线程\n&#x2F;&#x2F;            &#125;);\n\n            &#x2F;&#x2F; 4.mainTH等待 promise 结果\n            promise.await();&#x2F;&#x2F;相比sync(),await()不会抛异常,isSuccess()自己检查！\n            if(promise.isSuccess()) &#123;\n                &#x2F;&#x2F; 调用正常\n                return promise.getNow();\n            &#125; else &#123;\n                &#x2F;&#x2F; 调用失败\n                throw new RuntimeException(promise.cause());\n            &#125;\n        &#125;);\n        return (T)o;&#x2F;&#x2F;\n    &#125;\n\n\n    private static Channel channel &#x3D; null;\n    private static final Object LOCK &#x3D; new Object();\n\n    &#x2F;&#x2F; 获取唯一的 channel 对象\n    public static Channel getChannel() &#123;&#x2F;&#x2F;DCL单例\n        if(channel !&#x3D; null) &#123;\n            return channel;\n        &#125;\n        synchronized (LOCK) &#123;&#x2F;&#x2F;高效\n            if(channel !&#x3D; null) &#123; &#x2F;&#x2F;only one\n                return channel;\n            &#125;\n            initChannel();\n            return channel;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 初始化 channel 方法\n    private static void initChannel() &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC &#x3D; new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER &#x3D; new RpcResponseMessageHandler();\n        Bootstrap bootstrap &#x3D; new Bootstrap();\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.group(group);\n        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception &#123;\n                ch.pipeline().addLast(new ProcotolFrameDecoder());\n                ch.pipeline().addLast(LOGGING_HANDLER);\n                ch.pipeline().addLast(MESSAGE_CODEC);\n                ch.pipeline().addLast(RPC_HANDLER);\n            &#125;\n        &#125;);\n        try &#123;\n            channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();&#x2F;&#x2F;阻塞等channel连接建立好了，才可用\n            channel.closeFuture().addListener(future -&gt; &#123;&#x2F;&#x2F;改异步：否则getChannel()一直阻塞,等关闭\n                group.shutdownGracefully();\n            &#125;);\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125;\n    &#125;\n\n&#125;\n\n\n6）客户端 handler 第二版@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;\n\n    &#x2F;&#x2F;@Sharable:需要自己保证线程安全 [多次记录promises]有状态：ConcurrentHashMap且单步操作！OK！\n    &#x2F;&#x2F;                       序号id      用来接收结果的 promise 对象\n    public static final Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    @Override\n\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;\n        log.debug(&quot;&#123;&#125;&quot;, msg);\n        &#x2F;&#x2F; 拿到空的 promise\n        Promise&lt;Object&gt; promise &#x3D; PROMISES.remove(msg.getSequenceId());&#x2F;&#x2F;&lt;Object&gt; remove用过即弃！\n        if (promise !&#x3D; null) &#123;\n            Object returnValue &#x3D; msg.getReturnValue();\n            Exception exceptionValue &#x3D; msg.getExceptionValue();\n            if(exceptionValue !&#x3D; null) &#123;\n                promise.setFailure(exceptionValue);&#x2F;&#x2F;&lt;?&gt;只能get，不能set 例外：set(null)\n            &#125; else &#123;\n                promise.setSuccess(returnValue);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x3D;&#x3D;&lt;?&gt;泛型通配符：只能get取，不能set设置！！！应改为，不过set(null)是例外&#x3D;&#x3D;\nClient端-异常调用package cn.itcast.server.service;\n\npublic class HelloServiceImpl implements HelloService &#123;\n    @Override\n    public String sayHello(String msg) &#123;\n        int i &#x3D; 1 &#x2F; 0;&#x2F;&#x2F;\n        return &quot;你好, &quot; + msg;\n    &#125;\n&#125;\n\nRpcClientManager：报错 报错帧太长了【冗余信息过多】\n\nRpcServer\njava.lang.reflect.InvocationTargetException\n\tat cn.itcast.server.handler.RpcRequestMessageHandler.channelRead0(RpcRequestMessageHandler.java:27)\n\t...\n\tCaused by: java.lang.ArithmeticException: &#x2F; by zero\n\tat cn.itcast.server.service.HelloServiceImpl.sayHello(HelloServiceImpl.java:6)\n\t\n\t\n改RpcRequestMessageHandler:\n\t            Object invoke &#x3D; method.invoke(service, message.getParameterValue());\n            response.setReturnValue(invoke);&#x2F;&#x2F;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            &#x2F;&#x2F;response.setExceptionValue(e);\n            String msg &#x3D; e.getCause().getMessage();&#x2F;&#x2F;\n            response.setExceptionValue(new Exception(&quot;远程调用出错:&quot; + msg));\n        &#125;\n\nRpcClientManager:\nException in thread “main” java.lang.RuntimeException: java.lang.Exception: 远程调用出错:&#x2F; by zero\n2. 源码分析 [侧重netty执行流程]2.1 启动剖析我们就来看看 netty 中对下面的代码是怎样进行处理的\n&#x2F;&#x2F;1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector &#x3D; Selector.open(); \n\n&#x2F;&#x2F;2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment &#x3D; new NioServerSocketChannel();\n\n&#x2F;&#x2F;3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n&#x2F;&#x2F;4 启动 nio boss 线程执行接下来的操作\n\n&#x2F;&#x2F;5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey &#x3D; serverSocketChannel.register(selector, 0, attachment);\n\n&#x2F;&#x2F;6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor\n\n&#x2F;&#x2F;7 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n&#x2F;&#x2F;8 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);\n\n\n\n\ntest下source：\npublic class TestSourceServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())&#x2F;&#x2F;selector：监听事件、单th执行器：事件处理&amp;执行异步(定时)任务\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) &#123;\n                        ch.pipeline().addLast(new LoggingHandler());\n                    &#125;\n                &#125;).bind(8080);&#x2F;&#x2F;打断点\n    &#125;\n&#125;\n\n\ndebug\n\n【init：ssc.open(); |  register: selectionKey &#x3D; ssc.register(selector,0,nettySsc)；| dobind：8080】\n入口 io.netty.bootstrap.ServerBootstrap#bind\n关键代码 io.netty.bootstrap.AbstractBootstrap#doBind\nprivate ChannelFuture doBind(final SocketAddress localAddress) &#123;\n\t&#x2F;&#x2F; 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码\n    final ChannelFuture regFuture &#x3D; initAndRegister();\n    final Channel channel &#x3D; regFuture.channel();\n    if (regFuture.cause() !&#x3D; null) &#123;\n        return regFuture;\n    &#125;\n\n    &#x2F;&#x2F; 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分\n    &#x2F;&#x2F; 2.1 如果已经完成\n    if (regFuture.isDone()) &#123;\n        ChannelPromise promise &#x3D; channel.newPromise();\n        &#x2F;&#x2F; 3.1 立刻调用 doBind0\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    &#125; \n    &#x2F;&#x2F; 2.2 还没有完成\n    else &#123;\n        final PendingRegistrationPromise promise &#x3D; new PendingRegistrationPromise(channel);\n        &#x2F;&#x2F; 3.2 回调 doBind0\n        regFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                Throwable cause &#x3D; future.cause();\n                if (cause !&#x3D; null) &#123;\n                    &#x2F;&#x2F; 处理异常...\n                    promise.setFailure(cause);\n                &#125; else &#123;\n                    promise.registered();\n\t\t\t\t\t&#x2F;&#x2F; 3. 由注册线程去执行 doBind0\n                    doBind0(regFuture, channel, localAddress, promise);\n                &#125;\n            &#125;\n        &#125;);\n        return promise;\n    &#125;\n&#125;\n\n关键代码 io.netty.bootstrap.AbstractBootstrap#initAndRegister\nfinal ChannelFuture initAndRegister() &#123;\n    Channel channel &#x3D; null;\n    try &#123;\n        &#x2F;&#x2F;constructor:搜NioServerSocketChannel()-&gt; this(newSocket(DEFAULT_SELECTOR_PROVIDER));-&gt; return provider.openServerSocketChannel();&lt;-原生ServerSocketChannel.open()\n        channel &#x3D; channelFactory.newChannel();\n        &#x2F;&#x2F; 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer\n        init(channel);\n    &#125; catch (Throwable t) &#123;\n        &#x2F;&#x2F; 处理异常...\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    &#125;\n\n    &#x2F;&#x2F; 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上\n    ChannelFuture regFuture &#x3D; config().group().register(channel);\n    if (regFuture.cause() !&#x3D; null) &#123;\n        &#x2F;&#x2F; 处理异常...\n    &#125;\n    return regFuture;\n&#125;\n\n关键代码 io.netty.bootstrap.ServerBootstrap#init\n&#x2F;&#x2F; 这里 channel 实际上是 NioServerSocketChannel\nvoid init(Channel channel) throws Exception &#123;\n    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options &#x3D; options0();\n    synchronized (options) &#123;\n        setChannelOptions(channel, options, logger);\n    &#125;\n\n    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs &#x3D; attrs0();\n    synchronized (attrs) &#123;\n        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;\n            @SuppressWarnings(&quot;unchecked&quot;)\n            AttributeKey&lt;Object&gt; key &#x3D; (AttributeKey&lt;Object&gt;) e.getKey();\n            channel.attr(key).set(e.getValue());\n        &#125;\n    &#125;\n\n    ChannelPipeline p &#x3D; channel.pipeline();\n\n    final EventLoopGroup currentChildGroup &#x3D; childGroup;\n    final ChannelHandler currentChildHandler &#x3D; childHandler;\n    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;\n    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;\n    synchronized (childOptions) &#123;\n        currentChildOptions &#x3D; childOptions.entrySet().toArray(newOptionArray(0));\n    &#125;\n    synchronized (childAttrs) &#123;\n        currentChildAttrs &#x3D; childAttrs.entrySet().toArray(newAttrArray(0));\n    &#125;\n\t\n    &#x2F;&#x2F; 为 NioServerSocketChannel 添加初始化器\n    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        public void initChannel(final Channel ch) throws Exception &#123;&#x2F;&#x2F;1.2.2:register后真正调用\n            final ChannelPipeline pipeline &#x3D; ch.pipeline();\n            ChannelHandler handler &#x3D; config.handler();\n            if (handler !&#x3D; null) &#123;\n                pipeline.addLast(handler);\n            &#125;\n\n            &#x2F;&#x2F; 初始化器的职责是将 ServerBootstrapAcceptor handler(在accept事件发生后建立连接) 加入至 NioServerSocketChannel\n            ch.eventLoop().execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                &#125;\n            &#125;);\n        &#125;\n    &#125;);\n&#125;\n\n\n关键代码 io.netty.channel.AbstractChannel.AbstractUnsafe#register\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    &#x2F;&#x2F; 一些检查，略...\n\n    AbstractChannel.this.eventLoop &#x3D; eventLoop;\n\n    if (eventLoop.inEventLoop()) &#123;&#x2F;&#x2F;是main不是nioTH，走else！\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            &#x2F;&#x2F; 首次执行 execute 方法时，会启动 nio 线程（懒加载~），之后注册等操作在 nio 线程上执行\n            &#x2F;&#x2F; 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程\n            &#x2F;&#x2F; 这行代码完成的事实是 main -&gt; nio boss 线程的切换\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    register0(promise);&#x2F;&#x2F;\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n            &#x2F;&#x2F; 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        &#125;\n    &#125;\n&#125;\n\n\n\nio.netty.channel.AbstractChannel.AbstractUnsafe#register0\nprivate void register0(ChannelPromise promise) &#123;\n    try &#123;\n        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;\n            return;\n        &#125;\n        boolean firstRegistration &#x3D; neverRegistered;\n        &#x2F;&#x2F; 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel\n        doRegister();&#x2F;&#x2F;selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n        neverRegistered &#x3D; false;\n        registered &#x3D; true;\n\n        &#x2F;&#x2F; 1.2.2 [真正调用]执行 NioServerSocketChannel 初始化器的 [initChannel]\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        &#x2F;&#x2F; 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0\n        safeSetSuccess(promise);&#x2F;&#x2F;向【同一个】promise里填结果！\n        pipeline.fireChannelRegistered();\n        \n        &#x2F;&#x2F; 对应 server socket channel 还未绑定，isActive 为 false\n        if (isActive()) &#123;\n            if (firstRegistration) &#123;\n                pipeline.fireChannelActive();\n            &#125; else if (config().isAutoRead()) &#123;\n                beginRead();\n            &#125;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        &#x2F;&#x2F; Close the channel directly to avoid FD leak.\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    &#125;\n&#125;\n\n\n&#x2F;&#x2F; 初始化器的职责是将 ServerBootstrapAcceptor handler(在accept事件发生后建立连接) 加入至 NioServerSocketChannel\n\n\n断点右键All、F9： Mark object：regFuture@1837\n\n\nF9：operationComplete内 doBind0\n。。。\n\n\n关键代码 io.netty.channel.ChannelInitializer#initChannel\nprivate boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;\n    if (initMap.add(ctx)) &#123; &#x2F;&#x2F; Guard against re-entrance.\n        try &#123;\n            &#x2F;&#x2F; 1.2.2.1 执行初始化\n            initChannel((C) ctx.channel());\n        &#125; catch (Throwable cause) &#123;\n            exceptionCaught(ctx, cause);\n        &#125; finally &#123;\n            &#x2F;&#x2F; 1.2.2.2 移除初始化器\n            ChannelPipeline pipeline &#x3D; ctx.pipeline();\n            if (pipeline.context(this) !&#x3D; null) &#123;\n                pipeline.remove(this);\n            &#125;\n        &#125;\n        return true;\n    &#125;\n    return false;\n&#125;\n\n\n\n关键代码 io.netty.bootstrap.AbstractBootstrap#doBind0\n&#x2F;&#x2F; 3.1 或 3.2 执行 doBind0\nprivate static void doBind0(\n        final ChannelFuture regFuture, final Channel channel,\n        final SocketAddress localAddress, final ChannelPromise promise) &#123;\n\n    channel.eventLoop().execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            if (regFuture.isSuccess()) &#123;\n                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n            &#125; else &#123;\n                promise.setFailure(regFuture.cause());\n            &#125;\n        &#125;\n    &#125;);\n&#125;\n\n关键代码 io.netty.channel.AbstractChannel.AbstractUnsafe#bind\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123;\n    assertEventLoop();\n\n    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;\n        return;\n    &#125;\n\n    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;\n        localAddress instanceof InetSocketAddress &amp;&amp;\n        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;\n        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;\n        &#x2F;&#x2F; 记录日志...\n    &#125;\n\n    boolean wasActive &#x3D; isActive();\n    try &#123;\n        &#x2F;&#x2F; 3.3 执行端口绑定\n        doBind(localAddress);\n    &#125; catch (Throwable t) &#123;\n        safeSetFailure(promise, t);\n        closeIfClosed();\n        return;\n    &#125;\n\n    if (!wasActive &amp;&amp; isActive()) &#123;\n        invokeLater(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                &#x2F;&#x2F; 3.4 触发 active 事件\n                pipeline.fireChannelActive();&#x2F;&#x2F;[head]-&gt;Acceptor-&gt;tail\n            &#125;\n        &#125;);\n    &#125;\n\n    safeSetSuccess(promise);\n&#125;\n\n3.3 关键代码 io.netty.channel.socket.nio.NioServerSocketChannel#doBind\nprotected void doBind(SocketAddress localAddress) throws Exception &#123;\n    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;\n        javaChannel().bind(localAddress, config.getBacklog());&#x2F;&#x2F;\n    &#125; else &#123;\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    &#125;\n&#125;\n\n\n\n\n\n3.4 关键代码 io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive\n打断点！F9\npublic void channelActive(ChannelHandlerContext ctx) &#123;\n    ctx.fireChannelActive();\n\t&#x2F;&#x2F; 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)\n    readIfIsAutoRead();&#x2F;&#x2F;【selectionKey.interestOps(SelectionKey.OP_ACCEPT&#x3D;1&lt;&lt;&lt;4&#x3D;16)】\n&#125;\n\nF7。。。\n关键代码 io.netty.channel.nio.AbstractNioChannel#doBeginRead\nprotected void doBeginRead() throws Exception &#123;\n    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey &#x3D; this.selectionKey;\n    if (!selectionKey.isValid()) &#123;\n        return;\n    &#125;\n\n    readPending &#x3D; true;\n\n    final int interestOps &#x3D; selectionKey.interestOps();\n    &#x2F;&#x2F; readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件\n    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;\n        selectionKey.interestOps(interestOps | readInterestOp);\n    &#125;\n&#125;\n\n\n2.2 NioEventLoop 剖析[重量级 900+lines]\n本类selector、祖父类、曾祖父类scheduledTaskQueue\n\n构造里创建selector：final SelectorTuple selectorTuple &#x3D; openSelector();\n\n7.SelectedKeys优化：\n原生unwrappedSelector中的SelectionKeys集合底层基于HashSet（Hash表）拉链法遍历效率不高，仍保留。\n换为Selector，其中的SelectionKeys底层基于数组，遍历效率高！遍历key时用！！！\n\n\npackage cn.itcast.source;\n\nimport io.netty.channel.EventLoop;\nimport io.netty.channel.nio.NioEventLoopGroup;\n\npublic class TestEventLoop &#123;\n    public static void main(String[] args) &#123;\n        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();\n        eventLoop.execute(()-&gt;&#123;&#x2F;&#x2F;断点 debug\n            System.out.println(&quot;hello&quot;);\n        &#125;);\n    &#125;\n&#125;\n\n\n\n\nNioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），\n提交任务代码 io.netty.util.concurrent.SingleThreadEventExecutor#execute\npublic void execute(Runnable task) &#123;\n    if (task &#x3D;&#x3D; null) &#123;\n        throw new NullPointerException(&quot;task&quot;);\n    &#125;\n\n    boolean inEventLoop &#x3D; inEventLoop();&#x2F;&#x2F;\n    &#x2F;&#x2F; 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列\n    addTask(task);\n    if (!inEventLoop) &#123;\n        &#x2F;&#x2F; inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread\n        startThread();\n        if (isShutdown()) &#123;\n            &#x2F;&#x2F; 如果已经 shutdown，做拒绝逻辑，代码略...\n        &#125;\n    &#125;\n\n    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;\n        &#x2F;&#x2F; 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程\n        wakeup(inEventLoop);\n    &#125;\n&#125;\n\n\n\nprivate volatile int state &#x3D; ST_NOT_STARTED;\n\ndoStartThread()的run()死循环里：\nselect()：\nint selectedKeys &#x3D; selector.select(timeoutMillis);&#x2F;&#x2F;有超时的阻塞，一旦有任务就唤醒wakeup()\n\n唤醒 select 阻塞线程io.netty.channel.nio.NioEventLoop#wakeup\n@Override\nprotected void wakeup(boolean inEventLoop) &#123;\n    if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;&#x2F;&#x2F;\n        selector.wakeup();&#x2F;&#x2F;\n    &#125;\n&#125;\n\nprivate final AtomicBoolean wakenUp &#x3D; new AtomicBoolean();\n\n\n没事件没任务，应该进select阻塞一会儿，别空转！\n启动 EventLoop 主循环 io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread\nprivate void doStartThread() &#123;\n    assert thread &#x3D;&#x3D; null;\n    executor.execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            &#x2F;&#x2F; 将线程池的当前线程保存在成员变量中，以便后续使用\n            thread &#x3D; Thread.currentThread();\n            if (interrupted) &#123;\n                thread.interrupt();\n            &#125;\n\n            boolean success &#x3D; false;\n            updateLastExecutionTime();\n            try &#123;\n                &#x2F;&#x2F; 调用外部类 SingleThreadEventExecutor 的 [run 方法，进入死循环]，run 方法见下\n                SingleThreadEventExecutor.this.run();\n                success &#x3D; true;\n            &#125; catch (Throwable t) &#123;\n                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);\n            &#125; finally &#123;\n\t\t\t\t&#x2F;&#x2F; 清理工作，代码略...\n            &#125;\n        &#125;\n    &#125;);\n&#125;\n\n\n\n\nio.netty.channel.nio.NioEventLoop#run 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件\nprotected void run() &#123;\n    for (;;) &#123;\n        try &#123;\n            try &#123;\n                &#x2F;&#x2F; calculateStrategy 的逻辑如下：\n                &#x2F;&#x2F; 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch\n                &#x2F;&#x2F; 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;\n                    case SelectStrategy.CONTINUE:\n                        continue;\n\n                    case SelectStrategy.BUSY_WAIT:\n\n                    case SelectStrategy.SELECT:\n                        &#x2F;&#x2F; 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒\n                        &#x2F;&#x2F; 进行 select 阻塞，并设置唤醒状态为 false\n                        boolean oldWakenUp &#x3D; wakenUp.getAndSet(false);\n                        \n                        &#x2F;&#x2F; 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup\n                        &#x2F;&#x2F; 下面的 select 方法不会阻塞\n                        &#x2F;&#x2F; 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?\n                        &#x2F;&#x2F; 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时\n                        &#x2F;&#x2F; 才能执行，让 select 方法 无谓阻塞？\n                        select(oldWakenUp);\n\n                        if (wakenUp.get()) &#123;\n                            selector.wakeup();\n                        &#125;\n                    default:\n                &#125;\n            &#125; catch (IOException e) &#123;\n                rebuildSelector0();\n                handleLoopException(e);\n                continue;\n            &#125;\n\n            cancelledKeys &#x3D; 0;\n            needsToSelectAgain &#x3D; false;\n            &#x2F;&#x2F; ioRatio 默认是 50\n            final int ioRatio &#x3D; this.ioRatio;\n            if (ioRatio &#x3D;&#x3D; 100) &#123;\n                try &#123;\n                    processSelectedKeys();&#x2F;&#x2F;处理io事件！！！7.keys[i] 8.区分事件类型 unsafe.read()!\n                &#125; finally &#123;\n                    &#x2F;&#x2F; 【ioRatio 为 100】 时，【总是运行完所有！】【非 IO 任务】\n                    runAllTasks();&#x2F;&#x2F;并不好！finally，不超时！\n                &#125;\n            &#125; else &#123;                \n                final long ioStartTime &#x3D; System.nanoTime();\n                try &#123;\n                    processSelectedKeys();&#x2F;&#x2F;\n                &#125; finally &#123;\n                    &#x2F;&#x2F; 记录 【io 事件处理】耗时\n                    final long ioTime &#x3D; System.nanoTime() - ioStartTime;\n                    &#x2F;&#x2F; 运行非 IO 任务，一旦超时会退出 runAllTasks,下一次循环 【普通任务！】\n                    &#x2F;&#x2F; io时间*(非io)&#x2F;(io)&#x3D;非io任务超时时间:8s*20&#x2F;80&#x3D;2s\n                    runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);\n                &#125;\n            &#125;\n        &#125; catch (Throwable t) &#123;\n            handleLoopException(t);\n        &#125;\n        try &#123;\n            if (isShuttingDown()) &#123;\n                closeAll();\n                if (confirmShutdown()) &#123;\n                    return;\n                &#125;\n            &#125;\n        &#125; catch (Throwable t) &#123;\n            handleLoopException(t);\n        &#125;\n    &#125;\n&#125;\n\n\n⚠️ 注意\n\n\n\n\n\n\n\n\n这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：\n\n由非 EventLoop 线程调用，会**[唤醒当前]在执行 select 阻塞的 EventLoop 线程**\n由 EventLoop 自己调用，会本次的 wakeup 会[取消下一次的 select] 操作\n\n参考下图\n\n\nio.netty.channel.nio.NioEventLoop#select\nprivate void select(boolean oldWakenUp) throws IOException &#123;\n    Selector selector &#x3D; this.selector;\n    try &#123;\n        int selectCnt &#x3D; 0;\n        long currentTimeNanos &#x3D; System.nanoTime();\n        &#x2F;&#x2F; 计算等待时间\n        &#x2F;&#x2F; * 没有 scheduledTask，超时时间为 1s\n        &#x2F;&#x2F; * 有 scheduledTask，超时时间为 &#96;下一个定时任务执行时间 - 当前时间&#96;\n        long selectDeadLineNanos &#x3D; currentTimeNanos + delayNanos(currentTimeNanos);\n\n        for (;;) &#123;\n            long timeoutMillis &#x3D; (selectDeadLineNanos - currentTimeNanos + 500000L) &#x2F; 1000000L;\n            &#x2F;&#x2F; 如果超时，退出循环\n            if (timeoutMillis &lt;&#x3D; 0) &#123;\n                if (selectCnt &#x3D;&#x3D; 0) &#123;\n                    selector.selectNow();\n                    selectCnt &#x3D; 1;\n                &#125;\n                break;\n            &#125;\n\n            &#x2F;&#x2F; 如果期间又有 task: 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行\n            &#x2F;&#x2F; wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup\n            if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;\n                selector.selectNow();\n                selectCnt &#x3D; 1;\n                break;\n            &#125;\n\n            &#x2F;&#x2F; select 有限时阻塞\n            &#x2F;&#x2F; 注意【 (JDK)nio 有 bug】，当 bug 出现时，【select 方法即使没有事件发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%】\n            int selectedKeys &#x3D; selector.select(timeoutMillis);\n            &#x2F;&#x2F; 计数加 1\n            selectCnt ++;\n\n            &#x2F;&#x2F; 醒来后，如果【有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务：退出循环】\n            if (selectedKeys !&#x3D; 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;\n                break;\n            &#125;\n            if (Thread.interrupted()) &#123;\n               \t&#x2F;&#x2F; [线程被打断]，退出循环\n                &#x2F;&#x2F; 记录日志\n                selectCnt &#x3D; 1;\n                break;\n            &#125;\n\n            long time &#x3D; System.nanoTime();\n            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;&#x3D; currentTimeNanos) &#123;\n                &#x2F;&#x2F; 如果[超时]，[计数重置为 1，下次循环就会 break]\n                selectCnt &#x3D; 1;\n            &#125; \n            &#x2F;&#x2F; 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512\n            &#x2F;&#x2F; 这是为了解决 【nio 空轮询 bug】(不可修复，以新换旧)\n            else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;\n                    selectCnt &gt;&#x3D; SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;&#x2F;&#x2F;&gt;&#x3D;512\n                &#x2F;&#x2F; 重建 selector,替换旧的selector(selectionKey等信息复制过去)\n                selector &#x3D; selectRebuildSelector(selectCnt);\n                selectCnt &#x3D; 1;\n                break;\n            &#125;\n\n            currentTimeNanos &#x3D; time;\n        &#125;\n\n        if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;\n            &#x2F;&#x2F; 记录日志\n        &#125;\n    &#125; catch (CancelledKeyException e) &#123;\n        &#x2F;&#x2F; 记录日志\n    &#125;\n&#125;\n\n\n\nlinux下jdk nio支持有bug。法2：完全重写selector的实现。。。\n处理 keys io.netty.channel.nio.NioEventLoop#processSelectedKeys\nprivate void processSelectedKeys() &#123;\n    if (selectedKeys !&#x3D; null) &#123;\n        &#x2F;&#x2F; 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet \n        &#x2F;&#x2F; SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）\n        processSelectedKeysOptimized();&#x2F;&#x2F;\n    &#125; else &#123;\n        processSelectedKeysPlain(selector.selectedKeys());\n    &#125;\n&#125;\n\nprivate void processSelectedKeysOptimized() &#123;\n        for (int i &#x3D; 0; i &lt; selectedKeys.size; ++i) &#123;\n            final SelectionKey k &#x3D; selectedKeys.keys[i];\n            &#x2F;&#x2F; null out entry in the array to allow to have it GC&#39;ed once the Channel close\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363\n            selectedKeys.keys[i] &#x3D; null;&#x2F;&#x2F;\n\n            final Object a &#x3D; k.attachment();&#x2F;&#x2F;key关联的附件：NIO的channel (pipeline-handlers)\n\n            if (a instanceof AbstractNioChannel) &#123;\n                processSelectedKey(k, (AbstractNioChannel) a);&#x2F;&#x2F;！！！\n            &#125; else &#123;\n                @SuppressWarnings(&quot;unchecked&quot;)\n                NioTask&lt;SelectableChannel&gt; task &#x3D; (NioTask&lt;SelectableChannel&gt;) a;\n                processSelectedKey(k, task);\n            &#125;\n\n            if (needsToSelectAgain) &#123;\n                &#x2F;&#x2F; null out entries in the array to allow to have it GC&#39;ed once the Channel close\n                &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363\n                selectedKeys.reset(i + 1);\n\n                selectAgain();\n                i &#x3D; -1;\n            &#125;\n        &#125;\n    &#125;\n\n\nio.netty.channel.nio.NioEventLoop#processSelectedKey\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;\n    final AbstractNioChannel.NioUnsafe unsafe &#x3D; ch.unsafe();\n    &#x2F;&#x2F; 当 key 取消或关闭时会导致这个 key 无效\n    if (!k.isValid()) &#123;\n        &#x2F;&#x2F; 无效时处理...\n        return;\n    &#125;\n\n    try &#123;\n        int readyOps &#x3D; k.readyOps();&#x2F;&#x2F;\n        &#x2F;&#x2F; 连接事件\n        if ((readyOps &amp; SelectionKey.OP_CONNECT) !&#x3D; 0) &#123;\n            int ops &#x3D; k.interestOps();\n            ops &amp;&#x3D; ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        &#125;\n\n        &#x2F;&#x2F; 可写事件\n        if ((readyOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;\n            ch.unsafe().forceFlush();\n        &#125;\n\n        &#x2F;&#x2F; 可读或可接入事件\n        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\n            &#x2F;&#x2F; 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read\n            unsafe.read();&#x2F;&#x2F;【后两节:accept&#x2F;read】打断点，debug：TestSourceServer！！！\n        &#125;\n    &#125; catch (CancelledKeyException ignored) &#123;\n        unsafe.close(unsafe.voidPromise());\n    &#125;\n&#125;\n\n\n\n2.3 accept 剖析nio 中如下代码，在 netty 中的流程\n&#x2F;&#x2F;1 阻塞直到事件发生\nselector.select();\n\nIterator&lt;SelectionKey&gt; iter &#x3D; selector.selectedKeys().iterator();\nwhile (iter.hasNext()) &#123;    \n    &#x2F;&#x2F;2 拿到一个事件\n    SelectionKey key &#x3D; iter.next();\n    \n    &#x2F;&#x2F;3 如果是 accept 事件\n    if (key.isAcceptable()) &#123;\n        \n        &#x2F;&#x2F;4 执行 accept\n        SocketChannel channel &#x3D; serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        &#x2F;&#x2F;5 关注 read 事件\n        channel.register(selector, SelectionKey.OP_READ);\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n\n\ndebug TestSourceServer, run TestBacklogClient：\n&#x2F;&#x2F;readyOps&#x3D;16：accept (&#x3D;1：read)\nif ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n    unsafe.read();&#x2F;&#x2F;456)\n&#125;\n\n&#x3D;&#x3D;run to cursor:Alt+F9&#x3D;&#x3D;\n先来看可接入事件处理（accept）\nio.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\npublic void read() &#123;\n    assert eventLoop().inEventLoop();\n    final ChannelConfig config &#x3D; config();\n    final ChannelPipeline pipeline &#x3D; pipeline();    \n    final RecvByteBufAllocator.Handle allocHandle &#x3D; unsafe().recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    boolean closed &#x3D; false;\n    Throwable exception &#x3D; null;\n    try &#123;\n        try &#123;\n            do &#123;\n\t\t\t\t&#x2F;&#x2F;4) doReadMessages 中执行了 accept 并[创建 NioSocketChannel 作为消息放入 readBuf]\n                &#x2F;&#x2F; readBuf 是一个 ArrayList 用来缓存消息\n                int localRead &#x3D; doReadMessages(readBuf);&#x2F;&#x2F;4)\n                if (localRead &#x3D;&#x3D; 0) &#123;\n                    break;\n                &#125;\n                if (localRead &lt; 0) &#123;\n                    closed &#x3D; true;\n                    break;\n                &#125;\n\t\t\t\t&#x2F;&#x2F; localRead 为 1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            &#125; while (allocHandle.continueReading());\n        &#125; catch (Throwable t) &#123;\n            exception &#x3D; t;\n        &#125;\n\n        int size &#x3D; readBuf.size();\n        for (int i &#x3D; 0; i &lt; size; i ++) &#123;\n            readPending &#x3D; false;\n            &#x2F;&#x2F; 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理\n            &#x2F;&#x2F; io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\n            pipeline.fireChannelRead(readBuf.get(i));&#x2F;&#x2F;channelRead()+断点\n        &#125;\n        readBuf.clear();\n        allocHandle.readComplete();\n        pipeline.fireChannelReadComplete();\n\n        if (exception !&#x3D; null) &#123;\n            closed &#x3D; closeOnReadError(exception);\n\n            pipeline.fireExceptionCaught(exception);\n        &#125;\n\n        if (closed) &#123;\n            inputShutdown &#x3D; true;\n            if (isOpen()) &#123;\n                close(voidPromise());\n            &#125;\n        &#125;\n    &#125; finally &#123;\n        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;\n            removeReadOp();\n        &#125;\n    &#125;\n&#125;\n\n@Override\nprotected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;\n    &#x2F;&#x2F;4) -&gt;serverSocketChannel.accept();\n    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());\n    \n    try &#123;\n        if (ch !&#x3D; null) &#123;\n            buf.add(new NioSocketChannel(this, ch));&#x2F;&#x2F;设置非阻塞\n            return 1;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        ...\n\n\nhead-&gt;【ServerBootstrapAcceptor类】acceptor-&gt;tail\nchannelRead()方法打断点：\n关键代码 io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\npublic void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n    &#x2F;&#x2F; 这时的 msg 是 NioSocketChannel\n    final Channel child &#x3D; (Channel) msg;\n\n    &#x2F;&#x2F; NioSocketChannel 添加  childHandler 即初始化器\n    child.pipeline().addLast(childHandler);\n\n    &#x2F;&#x2F; 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;\n        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());\n    &#125;\n\n    try &#123;\n        &#x2F;&#x2F; 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程\n        childGroup.register(child).addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                if (!future.isSuccess()) &#123;\n                    forceClose(child, future.cause());\n                &#125;\n            &#125;\n        &#125;);\n    &#125; catch (Throwable t) &#123;\n        forceClose(child, t);\n    &#125;\n&#125;\n\n\n\n又回到了熟悉的 io.netty.channel.AbstractChannel.AbstractUnsafe#register  方法\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    &#x2F;&#x2F; 一些检查，略...\n\n    AbstractChannel.this.eventLoop &#x3D; eventLoop;\n\n    if (eventLoop.inEventLoop()) &#123;\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            &#x2F;&#x2F; 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    register0(promise);&#x2F;&#x2F;\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n            &#x2F;&#x2F; 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        &#125;\n    &#125;\n&#125;\n\n\ndoReadMessages()\n\n\nio.netty.channel.AbstractChannel.AbstractUnsafe#register0\nprivate void register0(ChannelPromise promise) &#123;\n    try &#123;\n        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;\n            return;\n        &#125;\n        boolean firstRegistration &#x3D; neverRegistered;\n        doRegister();&#x2F;&#x2F; 5) selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n        neverRegistered &#x3D; false;\n        registered &#x3D; true;\n\t\t\n        &#x2F;&#x2F; 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail\n        pipeline.invokeHandlerAddedIfNeeded();&#x2F;&#x2F;\n        &#x2F;&#x2F; 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) &#123;\n            if (firstRegistration) &#123;\n                &#x2F;&#x2F; 6) 触发 pipeline 上 active 事件，关注selectionKey的read事件\n                pipeline.fireChannelActive();&#x2F;&#x2F;\n            &#125; else if (config().isAutoRead()) &#123;\n                beginRead();\n            &#125;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    &#125;\n&#125;\n\n\n回到了熟悉的代码 io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive\npublic void channelActive(ChannelHandlerContext ctx) &#123;\n    ctx.fireChannelActive();\n\t&#x2F;&#x2F; 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();&#x2F;&#x2F;F7。。。\n&#125;\n\nio.netty.channel.nio.AbstractNioChannel#doBeginRead\nprotected void doBeginRead() throws Exception &#123;\n    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey &#x3D; this.selectionKey;\n    if (!selectionKey.isValid()) &#123;\n        return;\n    &#125;\n\n    readPending &#x3D; true;\n\t&#x2F;&#x2F; 这时候 interestOps 是 0\n    final int interestOps &#x3D; selectionKey.interestOps();\n    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 6) 关注 read 事件！\n        selectionKey.interestOps(interestOps | readInterestOp);\n    &#125;\n&#125;\n\n\n2.4 read 剖析NioEventLoop下：unsafe.read()加断点\nF9两次：readOps&#x3D;16:accept事件，  &#x3D;1:read事件 \nF7进：\n\n再来看可读事件 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete\npublic final void read() &#123;\n    final ChannelConfig config &#x3D; config();\n    if (shouldBreakReadReady(config)) &#123;\n        clearReadPending();\n        return;\n    &#125;\n    final ChannelPipeline pipeline &#x3D; pipeline();\n    &#x2F;&#x2F; io.netty.allocator.type 决定 allocator 的实现：(非)池化\n    final ByteBufAllocator allocator &#x3D; config.getAllocator();\n    &#x2F;&#x2F; 用来分配 byteBuf，确定单次读取大小【io事件强制用deirectIOBuf】\n    final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf &#x3D; null;\n    boolean close &#x3D; false;\n    try &#123;\n        do &#123;\n            byteBuf &#x3D; allocHandle.allocate(allocator);\n            &#x2F;&#x2F; 读取\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));&#x2F;&#x2F;&quot;hello!&quot; widx&#x3D;0变6\n            if (allocHandle.lastBytesRead() &lt;&#x3D; 0) &#123;\n                byteBuf.release();\n                byteBuf &#x3D; null;\n                close &#x3D; allocHandle.lastBytesRead() &lt; 0;\n                if (close) &#123;\n                    readPending &#x3D; false;\n                &#125;\n                break;\n            &#125;\n\n            allocHandle.incMessagesRead(1);\n            readPending &#x3D; false;\n            &#x2F;&#x2F; 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler\n            pipeline.fireChannelRead(byteBuf);&#x2F;&#x2F;head、logging、tail\n            byteBuf &#x3D; null;\n        &#125; \n        &#x2F;&#x2F; 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        &#x2F;&#x2F; 触发 read complete 事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) &#123;\n            closeOnRead(pipeline);\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    &#125; finally &#123;\n        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;\n            removeReadOp();\n        &#125;\n    &#125;\n&#125;\n\n\n\nio.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)\npublic boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) &#123;\n    return \n           &#x2F;&#x2F; 一般为 true\n           config.isAutoRead() &amp;&amp;\n           &#x2F;&#x2F; respectMaybeMoreData 默认为 true\n           &#x2F;&#x2F; maybeMoreDataSupplier 的逻辑是【如果预期读取字节与实际读取字节相等，返回 true】\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;\n           &#x2F;&#x2F; 小于最大次数，maxMessagePerRead 默认 16\n           totalMessages &lt; maxMessagePerRead &amp;&amp;\n           &#x2F;&#x2F; 实际读到了数据\n           totalBytesRead &gt; 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"学Netty-黑马满哥","date":"2022-04-26T14:11:41.000Z","categories_index":"Netty","tags_index":"Netty","author_index":"CodingSeed"},{"id":"128485c0403ac0ca82c74aaa720458ad","title":"sgg大数据高频面试题","content":"尚硅谷大数据技术之高频面试题\n（作者：尚硅谷大数据研发部）\n版本：V8.0.15\n目录项目涉及技术1.1 Linux&amp;Shell1.1.1 Linux常用高级命令\n  序号   命令                            命令解释  1      top                             查看内存  2      df -h                           查看磁盘存储情况  3      iotop                           查看磁盘IO读写(yum install iotop安装）  4      iotop -o                        直接查看比较高的磁盘读写程序  5      netstat -tunlp | grep 端口号   查看端口占用情况  6      uptime                          查看报告系统运行时长及平均负载  7      ps -ef                          查看进程\n\n1.1.2 Shell常用工具及写过的脚本1）awk、sed、cut、sort\n2）用Shell写过哪些脚本\n（1）集群启动，分发脚本\n\n\n\n\n\n\n\n\n\n#!&#x2F;bin&#x2F;bash\ncase $1 in\n“start”)\nfor i in hadoop102 hadoop103 hadoop104\ndo\nssh $i “绝对路径”\ndone\n;;\n“stop”)\n;;\nesac\n（2）数仓与MySQL的导入导出\n\n\n\n\n\n\n\n\n\nMySQL HDFS hive\nsqoop （4个map）\n除了sqoop之外还可以用：DataX、hadoop、java\n驱动\n主机名 端口号\n用户名\n密码\n路径\n删除\n同步策略： 全量 特殊 新增 新增和变化\nquery “select id , name from user where 创建时间&#x3D;今天 or 操作时间&#x3D;今天”\n压缩\n列式存储\n（3）数仓层级内部的导入：ods-&gt;dwd-&gt;dws-&gt;dwt-&gt;ads\n\n\n\n\n\n\n\n\n\n①#!&#x2F;bin&#x2F;bash\n②定义变量 APP&#x3D;gmall\n③获取时间\n传入 按照传入时间\n不传 T+1\n④sql&#x3D;”\n先按照当前天 写sql &#x3D;&gt; 遇到时间 $do_date 遇到表 {$APP}.\n自定义函数 UDF UDTF {$APP}.\n“\n⑤执行sql\n1.1.3 Shell中提交了一个脚本，进程号已经不知道了，但是需要kill掉这个进程，怎么操作?ssh $i “ps -ef | grep file-flume-kafka | grep -v grep |awk ‘{print$2}’ | xargs kill”\n1.1.4 Shell中单引号和双引号区别1）在&#x2F;home&#x2F;atguigu&#x2F;bin创建一个test.sh文件\n[atguigu@hadoop102 bin]$ vim test.sh\n在文件中添加如下内容\n#!&#x2F;bin&#x2F;bash\ndo_date&#x3D;$1\necho ‘$do_date’\necho “$do_date”\necho “‘$do_date’”\necho ‘“$do_date”‘\necho date\n2）查看执行结果\n[atguigu@hadoop102 bin]$ test.sh 2019-02-10\n$do_date\n2019-02-10\n‘2019-02-10’\n“$do_date”\n2019年 05月 02日 星期四 21:02:08 CST\n3）总结：\n（1）单引号不取变量值\n（2）双引号取变量值\n（3）反引号&#96;，执行引号中命令\n（4）双引号内部嵌套单引号，取出变量值\n（5）单引号内部嵌套双引号，不取出变量值\n1.2 Hadoop1.2.1 Hadoop常用端口号\n                   hadoop2.x   Hadoop3.x\n\n  访问HDFS端口         50070       9870  访问MR执行情况端口   8088        8088  历史服务器           19888       19888  客户端访问集群端口   9000        8020\n\n1.2.2 Hadoop配置文件配置文件：\n\n\n\n\n\n\n\n\n\nhadoop2.x core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xmlslaves\nhadoop3.x core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xmlworkers\n1.2.3 HDFS读流程和写流程1.2.4 HDFS小文件处理1）会有什么影响\n（1）存储层面：\n\n\n\n\n\n\n\n\n\n1个文件块，占用namenode多大内存150字节\n128G能存储多少文件块？ 128 g* 1024m1024kb1024byte&#x2F;150字节 &#x3D;9.1亿文件块\n（2）计算层面：\n每个小文件都会起到一个MapTask，1个MapTask默认内存1G。浪费资源。\n2）怎么解决\n（1）采用har归档方式，将小文件归档\n（2）采用CombineTextInputFormat\n（3）有小文件场景开启JVM重用；如果没有小文件，不要开启JVM重用，因为会一直占用使用到的task卡槽，直到任务完成才释放。\nJVM重用可以使得JVM实例在同一个job中重新使用N次，N的值可以在Hadoop的mapred-site.xml文件中进行配置。通常在10-20之间\n\n\n\n\n\n\n\n\n\n\n\nmapreduce.job.jvm.numtasks\n10\nHow many tasks to run per jvm,if set to -1 ,there is nolimit\n\n1.2.5 HDFS的NameNode内存1）Hadoop2.x系列，配置NameNode默认2000m\n2）Hadoop3.x系列，配置NameNode内存是动态分配的\nNameNode内存最小值1G，每增加100万个block，增加1G内存。\n1.2.6 NameNode心跳并发配置{width&#x3D;”5.768055555555556in”height&#x3D;”1.8868055555555556in”}\n企业经验：dfs.namenode.handler.count&#x3D;$20 times log_{e}^{text{Cluster Size}}$，比如集群规模（DataNode台数）为3台时，此参数设置为21。可通过简单的python代码计算该值，代码如下。\n1.2.7 纠删码原理CPU资源换取存储空间。\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.535416666666667in”}\n1.2.8 异构存储（冷热数据分离）期望经常使用的数据存储在固态硬盘或者内存镜像硬盘；不经常使用的历史数据存储在老旧的破旧硬盘。\n{width&#x3D;”5.768055555555556in”height&#x3D;”1.6479166666666667in”}\n1.2.9 Shuffle及优化1、Shuffle过程\n1.2.10 Yarn工作机制\n1.2.11 Yarn调度器1）Hadoop调度器重要分为三类：\n\n\n\n\n\n\n\n\n\nFIFO 、Capacity Scheduler（容量调度器）和Fair Sceduler（公平调度器）。\nApache默认的资源调度器是容量调度器；\nCDH默认的资源调度器是公平调度器。\n2）区别：\nFIFO调度器：支持单队列 、先进先出 生产环境不会用。\n容量调度器：支持多队列。队列资源分配，优先选择资源占用率最低的队列分配资源；作业资源分配，按照作业的优先级和提交时间顺序分配资源；容器资源分配，本地原则（同一节点&#x2F;同一机架&#x2F;不同节点不同机架）\n公平调度器：支持多队列，保证每个任务公平享有队列资源。资源不够时可以按照缺额分配。\n3）在生产环境下怎么选择？\n大厂：如果对并发度要求比较高，选择公平，要求服务器性能必须OK；\n中小公司，集群服务器资源不太充裕选择容量。\n4）在生产环境怎么创建队列？\n（1）调度器默认就1个default队列，不能满足生产要求。\n（2）按照框架：hive &#x2F;spark&#x2F; flink每个框架的任务放入指定的队列（企业用的不是特别多）\n（3）按照部门：业务部门1、业务部门2\n（4）按照业务模块：登录注册、购物车、下单\n5）创建多队列的好处？\n（1）因为担心员工不小心，写递归死循环代码，把所有资源全部耗尽。\n（2）实现任务的降级使用，特殊时期保证重要的任务队列资源充足。\n业务部门1（重要）&#x3D;》业务部门2（比较重要）&#x3D;》下单（一般）&#x3D;》购物车（一般）&#x3D;》登录注册（次要）\n1.2.12 项目经验之基准测试硬盘的读写速度和网络带宽影响集群吞吐量的两个核心因素。\n1.2.13 Hadoop宕机1）如果MR造成系统宕机。此时要控制Yarn同时运行的任务数，和每个任务申请的最大内存。调整参数：yarn.scheduler.maximum-allocation-mb（单个任务可申请的最多物理内存量，默认是8192MB）\n2）如果写入文件过快造成NameNode宕机。那么调高Kafka的存储大小，控制从Kafka到HDFS的写入速度。例如，可以调整Flume每批次拉取数据量的大小参数batchsize。\n1.2.14 Hadoop解决数据倾斜方法1）提前在map进行combine，减少传输的数据量\n在Mapper加上combiner相当于提前进行reduce，即把一个Mapper中的相同key进行了聚合，减少shuffle过程中传输的数据量，以及Reducer端的计算量。\n如果导致数据倾斜的key大量分布在不同的mapper的时候，这种方法就不是很有效了。\n2）导致数据倾斜的key 大量分布在不同的mapper\n（1）局部聚合加全局聚合。\n第一次在map阶段对那些导致了数据倾斜的key加上1到n的随机前缀，这样本来相同的key也会被分到多个Reducer中进行局部聚合，数量就会大大降低。\n第二次mapreduce，去掉key的随机前缀，进行全局聚合。\n思想：二次mr，第一次将key随机散列到不同reducer进行处理达到负载均衡目的。第二次再根据去掉key的随机前缀，按原key进行reduce处理。\n这个方法进行两次mapreduce，性能稍差。\n\n\n\n\n\n\n\n\n\n（2）增加Reducer，提升并行度JobConf.setNumReduceTasks(int)\n（3）实现自定义分区\n根据数据分布情况，自定义散列函数，将key均匀分配到不同Reducer\n1.3 Zookeeper1.3.1 常用命令ls、get、create、delete\n1.3.2 Paxos算法和ZAB协议（扩展）\n\n\n\n\n\n\n\n\n注意：暂时先不用看。如果后期准备面今日头条，需要认真准备，其他公司几乎都不问。\n关注尚硅谷教育公众号回复大数据。 找zookeeper视频。\n1.3.3 讲一讲什么是CAP法则？Zookeeper符合了这个法则的哪两个？（扩展）1.3.4 选举机制半数机制：2n+1，安装奇数台\n\n\n\n\n\n\n\n\n\n10台服务器：3台\n20台服务器：5台\n100台服务器：11台\n台数多，好处：提高可靠性；坏处：影响通信延时\n1.3.5 Follower和Leader状态同步1.4 Flume1.4.1 Flume组成，Put事务，Take事务1）taildir source\n（1）断点续传、多目录\n（2）哪个Flume版本产生的？Apache1.7、CDH1.6\n（3）没有断点续传功能时怎么做的？ 自定义\n（4）taildir挂了怎么办？\n不会丢数：断点续传\n重复数据：\n（5）怎么处理重复数据？\n不处理：生产环境通常不处理，出现重复的概率比较低。处理会影响传输效率。\n处理\n自身：在taildirsource里面增加自定义事务，影响效率\n找兄弟：下一级处理（hive dwd sparkstreamingflink布隆）、去重手段（groupby、开窗取窗口第一条、redis）\n（6）taildir source 是否支持递归遍历文件夹读取文件？\n不支持。 自定义 递归遍历文件夹 + 读取文件\n2）file channel &#x2F;memory channel&#x2F;kafka channel\n（1）File Channel\n数据存储于磁盘，优势：可靠性高；劣势：传输速度低\n默认容量：100万event\n注意：FileChannel可以通过配置dataDirs指向多个路径，每个路径对应不同的硬盘，增大Flume吞吐量。\n（2）Memory Channel\n数据存储于内存，优势：传输速度快；劣势：可靠性差\n默认容量：100个event\n（3）Kafka Channel\n数据存储于Kafka，基于磁盘；\n优势：可靠性高；\n传输速度快 Kafka Channel 大于Memory Channel + Kafka Sink原因省去了Sink阶段\n（4）Kafka Channel哪个版本产生的？\nFlume1.6 版本产生&#x3D;》并没有火；因为有bug\nevent(header body ) ture 和false控制是否包含header信息，很遗憾，都不起作用。增加了额外清洗的工作量。\nFlume1.7解决了这个问题，开始火了。\n（5）生产环境如何选择\n如果下一级是Kafka，优先选择Kafka Channel\n如果是金融、对钱要求准确的公司，选择File Channel\n如果就是普通的日志，通常可以选择Memory Channel\n每天丢几百万数据 pb级 亿万富翁，掉1块钱会捡？\n3）HDFS sink\n（1）时间（半个小时） or 大小128m、event个数（0禁止）\n具体参数：hdfs.rollInterval&#x3D;1800，hdfs.rollSize&#x3D;134217728，hdfs.rollCount&#x3D;0\n4）事务\nSource到Channel是Put事务\nChannel到Sink是Take事务\n1.4.2 Flume拦截器1）拦截器注意事项\n（1）ETL拦截器：主要是用来判断json是否完整。没有做复杂的清洗操作主要是防止过多的降低传输速率。\n（2）时间戳拦截器：主要是解决零点漂移问题\n2）自定义拦截器步骤\n（1）实现 Interceptor\n（2）重写四个方法\n\ninitialize 初始化\n\npublic Event intercept(Event event) 处理单个Event\n\npublic List intercept(List events)\n\n\n\n\n\n\n\n\n\n\n\n处理多个Event，在这个方法中调用Event intercept(Event event)\n\nclose方法\n\n（3）静态内部类，实现Interceptor.Builder\n3）拦截器可以不用吗？\nETL拦截器可以不用；需要在下一级Hive的dwd层和SparkSteaming里面处理\n时间戳拦截器建议使用。如果不用需要采用延迟15-20分钟处理数据的方式，比较麻烦。\n1.4.3 Flume Channel选择器Replicating：默认选择器。功能：将数据发往下一级所有通道\nMultiplexing：选择性发往指定通道。\n1.4.4 Flume监控器1）采用Ganglia监控器，监控到Flume尝试提交的次数远远大于最终成功的次数，说明Flume运行比较差。主要是内存不够导致的。\n2）解决办法？\n（1）自身：flume默认内存2000m。考虑增加flume内存，在flume-env.sh配置文件中修改flume内存为4-6g\n-Xmx与-Xms最好设置一致，减少内存抖动带来的性能影响，如果设置不一致容易导致频繁fullgc。\n（2）找朋友：增加服务器台数\n搞活动 618 &#x3D;》增加服务器&#x3D;》用完在退出\n日志服务器配置：8-16g内存、磁盘8T\n1.4.5 Flume采集数据会丢失吗?（防止数据丢失的机制）如果是FileChannel不会，Channel存储可以存储在File中，数据传输自身有事务。\n如果是MemoryChannel有可能丢。\n1.5 Kafka1.5.1 Kafka架构生产者、Broker、消费者、Zookeeper；\n注意：Zookeeper中保存Brokerid和消费者offsets等信息，但是没有生产者信息。\n1.5.2 Kafka的机器数量Kafka机器数量 &#x3D; 2 *（峰值生产速度 * 副本数 &#x2F; 100）+ 1\n1.5.3 副本数设定一般我们设置成2个或3个，很多企业设置为2个。\n副本的优势：提高可靠性；副本劣势：增加了网络IO传输\n1.5.4 Kafka压测Kafka官方自带压力测试脚本（kafka-consumer-perf-test.sh、kafka-producer-perf-test.sh）。Kafka压测时，可以查看到哪个地方出现了瓶颈（CPU，内存，网络IO）。一般都是网络IO达到瓶颈。\n1.5.5 Kafka日志保存时间默认保存7天；生产环境建议3天\n1.5.6 Kafka中数据量计算每天总数据量100g，每天产生1亿条日志，10000万&#x2F;24&#x2F;60&#x2F;60&#x3D;1150条&#x2F;每秒钟\n平均每秒钟：1150条\n低谷每秒钟：50条\n高峰每秒钟：1150条 *（2-20倍）&#x3D; 2300条 - 23000条\n每条日志大小：0.5k - 2k（取1k）\n每秒多少数据量：2.0M - 20MB\n1.5.7 Kafka的硬盘大小每天的数据量100g * 2个副本 * 3天 &#x2F; 70%\n1.5.8 Kafka监控公司自己开发的监控器；\n开源的监控器：KafkaManager、KafkaMonitor、KafkaEagle\n1.5.9 Kakfa分区数1）创建一个只有1个分区的topic\n2）测试这个topic的producer吞吐量和consumer吞吐量。\n3）假设他们的值分别是Tp和Tc，单位可以是MB&#x2F;s。\n4）然后假设总的目标吞吐量是Tt，那么分区数&#x3D;Tt &#x2F; min（Tp，Tc）\n例如：producer吞吐量 &#x3D; 20m&#x2F;s；consumer吞吐量 &#x3D; 50m&#x2F;s，期望吞吐量100m&#x2F;s；\n分区数 &#x3D; 100 &#x2F; 20 &#x3D; 5分区\n[https://blog.csdn.net/weixin_42641909&#x2F;article&#x2F;details&#x2F;89294698]{.underline}\n分区数一般设置为：3-10个\n1.5.10 多少个Topic通常情况：多少个日志类型就多少个Topic。也有对日志类型进行合并的。\n1.5.11 Kafka的ISR副本同步队列ISR（In-SyncReplicas），副本同步队列。ISR中包括Leader和Follower。如果Leader进程挂掉，会在ISR队列中选择一个服务作为新的Leader。有replica.lag.max.messages（延迟条数）和replica.lag.time.max.ms（延迟时间）两个参数决定一台服务是否可以加入ISR副本队列，在0.10版本移除了replica.lag.max.messages参数，防止服务频繁的进去队列。\n任意一个维度超过阈值都会把Follower剔除出ISR，存入OSR（Outof-SyncReplicas）列表，新加入的Follower也会先存放在OSR中。\n1.5.12 Kafka分区分配策略在 Kafka内部存在两种默认的分区分配策略：Range和 RoundRobin。\nRange是默认策略。Range是对每个Topic而言的（即一个Topic一个Topic分），首先对同一个Topic里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。然后用Partitions分区的个数除以消费者线程的总数来决定每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。\n例如：我们有10个分区，两个消费者（C1，C2），3个消费者线程，10 &#x2F; 3 &#x3D;3而且除不尽。\nC1-0 将消费 0, 1, 2, 3 分区\nC2-0 将消费 4, 5, 6 分区\nC2-1 将消费 7, 8, 9 分区\n第一步：将所有主题分区组成TopicAndPartition列表，然后对TopicAndPartition列表按照hashCode进行排序，最后按照轮询的方式发给每一个消费线程。\n1.5.13 Kafka挂掉\n\n\n\n\n\n\n\n\n1）Flume记录\n2）日志有记录\n3）短期没事\n1.5.14 Kafka丢不丢数据1）producer角度\n\nAck &#x3D; 0，相当于异步发送，消息发送完毕即offset增加，继续生产。\n\nAck &#x3D; 1，leader收到leader replica对一个消息的接受ack才增加offset，然后继续生产。\n\nAck &#x3D; -1，leader收到所有replica对一个消息的接受ack才增加offset，然后继续生产。\n\n\nack在生产者指定，不同生产者可以不同。\nack设为-1，需要ISR里的所有follower应答，想要真正不丢数据，需要配合参数：\n\nmin.insync.replicas: ack为-1时生效，ISR里应答的最小follower数量。\n\n默认为1（leader本身也算一个！），所以当ISR里除了leader本身，没有其他的follower，即使ack设为-1，相当于1的效果，不能保证不丢数据。\n需要将min.insync.replicas设置大于等于2，才能保证有其他副本同步到数据。\n\nretries &#x3D;Integer.MAX_VALUE，无限重试。如果上述两个条件不满足，写入一直失败，就会无限次重试，保证数据必须成功的发送给两个副本，如果做不到，就不停的重试，除非是面向金融级的场景，面向企业大客户，或者是广告计费，跟钱的计算相关的场景下，才会通过严格配置保证数据绝对不丢失\n\nkafka-topics.sh –bootstrap-server hadoop1:9092 –create –topictestisr2 –replication-factor 3 –partitions 4 –configmin.insync.replicas&#x3D;2\n完全不丢结论：ack&#x3D;-1 + min.insync.replicas&gt;&#x3D;2 +无限重试\n2）broker角度\n副本数大于1\nmin.insync.replicas大于1\n3）consumer角度\n手动提交offset，flink结合checkpoint\n1.5.15 Kafka数据重复重复指的是发生重试造成的重复。\n幂等性 + ack-1 + 事务\nKafka数据重复，可以在下一级：SparkStreaming、redis、Flink或者Hive中dwd层去重，去重的手段：分组、按照id开窗只取第一个值；\n了解：\nKafka幂等性原理（单分区单会话）：producer重试引起的乱序和重复\n1、重复问题的解决：\n1）Kafka增加了pid和seq。Producer中每个RecordBatch都有一个单调递增的seq;Broker上每个topic的partition也会维护pid-seq的映射，并且每Commit都会更新lastSeq。\n2）recordBatch到来时，broker会先检查RecordBatch再保存数据：\n如果batch中baseSeq（第一条消息的seq）比Broker维护的序号（lastSeq）大1，则保存数据，否则不保存。\n2、乱序问题的解决\n假设我们有5个请求，batch1、batch2、batch3、batch4、batch5；\n如果只有batch2 ackfailed，3、4、5都保存了，那2将会随下次batch重发而造成重复。\n可以设置max.in.flight.requests.per.connection&#x3D;1（客户端在单个连接上能够发送的未响应请求的个数）来解决乱序，但降低了系统吞吐。\n新版本kafka设置enable.idempotence&#x3D;true后能够动态调整max-in-flight-request。正常情况下max.in.flight.requests.per.connection大于1。当重试请求到来时，batch会根据seq重新添加到队列的合适位置，并把max.in.flight.requests.per.connection设为1，这样它前面的batch序号都比它小，只有前面的都发完了，它才能发。\n1.5.16 Kafka消息数据积压，Kafka消费能力不足怎么处理？1）如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费组的消费者数量，消费者数&#x3D; 分区数。（两者缺一不可）\n2）如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据&#x2F;处理时间&lt; 生产速度），使处理的数据小于生产的数据，也会造成数据积压。\n1.5.17 Kafka参数优化1）Broker参数配置（server.properties）\n\n\n\n\n\n\n\n\n\n1、日志保留策略配置\n保留三天，也可以更短 （log.cleaner.delete.retention.ms）log.retention.hours&#x3D;72\n2、Replica相关配置\ndefault.replication.factor:1 默认副本1个\n3、网络通信延时\nreplica.socket.timeout.ms:30000 #当集群之间网络不稳定时,调大该参数\nreplica.lag.time.max.ms&#x3D; 600000#如果网络不好,或者kafka集群压力较大,会出现副本丢失,然后会频繁复制副本,导致集群压力更大,此时可以调大该参数\n2）Producer优化（producer.properties）\n\n\n\n\n\n\n\n\n\ncompression.type:none gzip snappy lz4\n#默认发送不进行压缩，推荐配置一种适合的压缩算法，可以大幅度的减缓网络压力和Broker的存储压力。\n3）Kafka内存调整（kafka-server-start.sh）\n默认内存1个G，生产环境尽量不要超过6个G。\n\n\n\n\n\n\n\n\n\nexport KAFKA_HEAP_OPTS&#x3D;”-Xms4g -Xmx4g”\n1.5.18 Kafka高效读写数据1）Kafka本身是分布式集群，同时采用分区技术，并发度高。\n2）顺序写磁盘\nKafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端，为顺序写。官网有数据表明，同样的磁盘，顺序写能到600M&#x2F;s，而随机写只有100K&#x2F;s。\n3）零复制技术\n{width&#x3D;”2.9694444444444446in”height&#x3D;”1.429861111111111in”}\n1.5.19 Kafka单条日志传输大小Kafka对于消息体的大小默认为单条最大值是1M但是在我们应用场景中，常常会出现一条消息大于1M，如果不对Kafka进行配置。则会出现生产者无法将消息推送到Kafka或消费者无法去消费Kafka里面的数据，这时我们就要对Kafka进行以下配置：server.properties\n\n\n\n\n\n\n\n\n\nreplica.fetch.max.bytes: 1048576 broker可复制的消息的最大字节数,默认为1M\nmessage.max.bytes: 1000012 kafka 会接收单个消息size的最大限制，默认为1M左右\n注意：message.max.bytes必须小于等于replica.fetch.max.bytes，否则就会导致replica之间数据同步失败。\n1.5.20 Kafka过期数据清理保证数据没有被引用（没人消费他）\n日志清理的策略只有delete和compact两种\nlog.cleanup.policy &#x3D; delete启用删除策略\nlog.cleanup.policy &#x3D; compact启用压缩策略\nhttps://www.jianshu.com/p/fa6adeae8eb5\n1.5.21 Kafka可以按照时间消费数据Map&lt;TopicPartition, OffsetAndTimestamp&gt; startOffsetMap &#x3D;KafkaUtil.fetchOffsetsWithTimestamp(topic, sTime, kafkaProp);\n1.5.22 Kafka消费者角度考虑是拉取数据还是推送数据拉取数据\n1.5.23 Kafka中的数据是有序的吗！！！单分区内有序；多分区，分区与分区间无序；\n扩展：\nkafka producer发送消息的时候，可以指定key:\n{width&#x3D;”5.424305555555556in”height&#x3D;”2.609722222222222in”}\n这个key的作用是为消息选择存储分区，key可以为空，当指定key且不为空的时候，Kafka是根据key的hash值与分区数取模来决定数据存储到那个分区。\n{width&#x3D;”5.444444444444445in”height&#x3D;”2.959722222222222in”}\n有序解决方案：同一张表的数据 放到 同一个 分区\n&#x3D;&gt; ProducerRecord里传入key，会根据key取hash算出分区号\n&#x3D;&gt; key使用表名，如果有库名，拼接上库名\n1.5.24 Kafka的LeaderEpoch哪个版本引入的？Kafka 0.11版本以后采用的。\n1.5.25 Kafka生产者调优配置Properties props &#x3D; new Properties();\nprops.put(“bootstrap.servers”,\n“hadoop1:9092,hadoop2:9092,hadoop3:9092”);\nprops.put(“key.serializer”,“org.apache.kafka.common.serialization.StringSerializer”);\nprops.put(“value.serializer”,“org.apache.kafka.common.serialization.StringSerializer”);\n&#x2F;&#x2F;如果要想保证数据不丢失，得如下设置：\n&#x2F;&#x2F; min.insync.replicas &#x3D; 2\n&#x2F;&#x2F; acks &#x3D; -1\n&#x2F;&#x2F; retries &#x3D; Integer.MAX_VALUE\nprops.put(“acks”, “-1”);\n&#x2F;&#x2F;如果消息发送失败，就会重试，这里的3次代表重试的次数\nprops.put(“retries”, 3);\n&#x2F;&#x2F;重试的时间间隔\nprops.put(“retry.backoff.ms”,5000);\n&#x2F;&#x2F;设置是否开启压缩，默认是none不压缩\n&#x2F;&#x2F;如果要压缩的话，建议设置lz4,经过实际检验，效果还是不错的\nprops.put(“compression.type”,”lz4”);\n&#x2F;&#x2F;发送一次消息的批次大小，如果批次太小，会导致网络请求频繁，\n&#x2F;&#x2F;建议设置大一些,默认16384Byte（16k）,建议调大，这里用32k\nprops.put(“batch.size”, 32384);\n&#x2F;&#x2F;批次达到时间就发送。默认是0，意思是消息必须立即被发送，建议100ms\nprops.put(“linger.ms”, 100);\n&#x2F;&#x2F;设置的缓冲区大小,默认33554432（32M）,一般不用动\n&#x2F;&#x2F;验证何时该调整缓冲区的大小：\n&#x2F;&#x2F;用一般Java获取结束时间和开始时间: System.currentTime()\n&#x2F;&#x2F;当结束时间减去开始时间大于设置的linger.ms(100ms)，此时Sender线程处理速度慢，需要调大缓冲区大小。\nprops.put(“buffer.memory”, 33554432);\n&#x2F;&#x2F;发送消息的最大大小，默认是1048576(1M),上限可以调大到10M\nprops.put(“max.request.size”,10485760);\n&#x2F;&#x2F;保证一个消息发送成功，再发另外一个消息,保证单分区有序\nprops.put(“max.in.flight.requests.per.connection”,1);\n&#x2F;&#x2F;最大阻塞时间，RecordAccumulator缓存不足时或者没有可用的元数据时，KafkaProducer的send()方法调用要么被阻塞，要么抛出异常，此参数的默认值为60000，即60s\nprops.put(“max.block.ms”, 3000);\n&#x2F;&#x2F; 创建一个Producer实例\nKafkaProducer&lt;String, String&gt; producer &#x3D;\nnew KafkaProducer&lt;String, String&gt;(props);\n&#x2F;&#x2F; 有序性考虑，可以指定生产者的key\nProducerRecord&lt;String, String&gt; record &#x3D;\nnew ProducerRecord&lt;&gt;(“mytopic”, “mykey”, “myvalue”);\n&#x2F;&#x2F;可以计算开始时间\nlong startTime&#x3D;System.currentTime();\n&#x2F;&#x2F;发送消息的模式有两种，一种是异步的，一种是同步的，我们在实际生产中一般是使用异步的发送方式\nproducer.send(record, new Callback() {\n@Override\npublic void onCompletion(RecordMetadata metadata, Exception exception) {\nif(exception &#x3D;&#x3D; null) {\n&#x2F;&#x2F; 消息发送成功\nSystem.out.println(“消息发送成功”);\n} else {\n&#x2F;&#x2F; 消息发送失败，需要重新发送\n}\n}\n});\n&#x2F;&#x2F;计算结束时间\nlong endTime&#x3D;System.currentTime();\nif(endTime - startTime &gt; 100){&#x2F;&#x2F;说明内存被压满了\n&#x2F;&#x2F;说明有问题，考虑调大buffer.memory\n}\n&#x2F;&#x2F; 这是同步发送的模式\n&#x2F;&#x2F;producer.send(record).get();\nproducer.close();\n1.6 Hive1.6.1 Hive的架构及HQL转换为MR流程Hive元数据默认存储在derby数据库，不支持多客户端访问，所以将元数据存储在MySQl，支持多客户端访问。\n\n\n\n\n\n\n\n\n\n{width&#x3D;”3.2708333333333335in”height&#x3D;”2.5347222222222223in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.9138888888888888in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.140277777777778in”}\n1.6.2 Hive和数据库比较Hive 和数据库除了拥有类似的查询语言，再无类似之处。\n1）数据存储位置\nHive 存储在 HDFS 。数据库将数据保存在块设备或者本地文件系统中。\n2）数据更新\nHive中不建议对数据的改写。而数据库中的数据通常是需要经常进行修改的，\n3）执行延迟\nHive 执行延迟较高。数据库的执行延迟较低。当然，这个是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。\n4）数据规模\nHive支持很大规模的数据计算；数据库可以支持的数据规模较小。\n1.6.3 内部表和外部表元数据、原始数据\n1）删除数据时：\n内部表：元数据、原始数据，全删除\n外部表：元数据 只删除\n2）在公司生产环境下，什么时候创建内部表，什么时候创建外部表？\n在公司中绝大多数场景都是外部表。\n自己使用的临时表，才会创建内部表；\n1.6.4 4个By区别1）Order By：全局排序，只有一个Reducer；\n2）Sort By：分区内有序；\n3）Distrbute By：类似MR中Partition，进行分区，结合sort by使用。\n4） Cluster By：当Distribute by和Sorts by字段相同时，可以使用Clusterby方式。Cluster by除了具有Distribute by的功能外还兼具Sortby的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。\n在生产环境中Order By用的比较少，容易导致OOM。\n在生产环境中Sort By + Distrbute By用的多。\n1.6.5 系统函数1）date_add、date_sub函数（加减日期）\n2）next_day函数（周指标相关）\n3）date_format函数（根据格式整理日期）\n4）last_day函数（求当月最后一天日期）\n5）CONCAT、CONCAT_WS、COLLECT_SET\n6）EXPLODE\n7）collect_set函数\n8）get_json_object解析json函数\n9）NVL（表达式1，表达式2）\n如果表达式1为空值，NVL返回值为表达式2的值，否则返回表达式1的值。\n1.6.6 自定义UDF、UDTF函数1）在项目中是否自定义过UDF、UDTF函数，以及用他们处理了什么问题，及自定义步骤？\n（1）用UDF函数解析公共字段；用UDTF函数解析事件字段。\n（2）自定义UDF：继承UDF，重写evaluate方法\n（3）自定义UDTF：继承自GenericUDTF，重写3个方法：initialize（自定义输出的列名和类型），process（将结果返回forward(result)），close\n2）为什么要自定义UDF&#x2F;UDTF？\n因为自定义函数，可以自己埋点Log打印日志，出错或者数据异常，方便调试。\n引入第三方jar包时，也需要。\n1.6.7 窗口函数1）Rank\n\n\n\n\n\n\n\n\n\n（1）RANK() 排序相同时会重复，总数不会变\n（2）DENSE_RANK() 排序相同时会重复，总数会减少\n（3）ROW_NUMBER() 会根据顺序计算\n2） OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化\n（1）CURRENT ROW：当前行\n（2）n PRECEDING：往前n行数据\n（3） n FOLLOWING：往后n行数据\n（4）UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点，UNBOUNDED FOLLOWING表示到后面的终点\n（5） LAG(col,n)：往前第n行数据\n（6）LEAD(col,n)：往后第n行数据\n（7） NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。\n3）手写：分组TopN、行转列、列转行\n1.6.8 Hive优化1）MapJoin\n如果不指定MapJoin或者不符合MapJoin的条件，那么Hive解析器会将Join操作转换成CommonJoin，即：在Reduce阶段完成join。容易发生数据倾斜。可以用MapJoin把小表全部加载到内存在map端进行join，避免reducer处理。\n2）行列过滤\n列处理：在SELECT中，只拿需要的列，如果有，尽量使用分区过滤，少用SELECT*。\n行处理：在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where后面，那么就会先全表关联，之后再过滤。\n3）列式存储\n4）采用分区技术\n5）合理设置Map数\nmapred.min.split.size: 指的是数据的最小分割单元大小；min的默认值是1B\nmapred.max.split.size: 指的是数据的最大分割单元大小；max的默认值是256MB\n通过调整max可以起到调整map数的作用，减小max可以增加map数，增大max可以减少map数。\n需要提醒的是，直接调整mapred.map.tasks这个参数是没有效果的。\n[https://www.cnblogs.com/swordfall/p/11037539.html]{.underline}\n6）合理设置Reduce数\nReduce个数并不是越多越好\n（1）过多的启动和初始化Reduce也会消耗时间和资源；\n（2）另外，有多少个Reduce，就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；\n在设置Reduce个数的时候也需要考虑这两个原则：处理大数据量利用合适的Reduce数；使单个Reduce任务处理数据量大小要合适；\n7）小文件如何产生的？\n（1）动态分区插入数据，产生大量的小文件，从而导致map数量剧增；\n（2）reduce数量越多，小文件也越多（reduce的个数和输出文件是对应的）；\n（3）数据源本身就包含大量的小文件。\n8）小文件解决方案\n（1）在Map执行前合并小文件，减少Map数：CombineHiveInputFormat具有对小文件进行合并的功能（系统默认的格式）。HiveInputFormat没有对小文件合并功能。\n\n\n\n\n\n\n\n\n\n（2）merge\n&#x2F;&#x2F; 输出合并小文件\nSET hive.merge.mapfiles &#x3D; true; –默认true，在map-only任务结束时合并小文件\nSET hive.merge.mapredfiles &#x3D; true; –默认false，在map-reduce任务结束时合并小文件\nSET hive.merge.size.per.task &#x3D; 268435456; – 默认256M\nSET hive.merge.smallfiles.avgsize &#x3D; 16777216; –当输出文件的平均大小小于16m该值时，启动一个独立的map-reduce任务进行文件merge\n\n\n\n\n\n\n\n\n\n（3）开启JVM重用\nset mapreduce.job.jvm.numtasks&#x3D;10\n9）开启map端combiner（不影响最终业务逻辑）\nset hive.map.aggr&#x3D;true；\n10）压缩（选择快的）\n设置map端输出、中间结果压缩。（不完全是解决数据倾斜的问题，但是减少了IO读写和网络传输，能提高很多效率）\nset hive.exec.compress.intermediate&#x3D;true –启用中间数据压缩\nset mapreduce.map.output.compress&#x3D;true –启用最终数据压缩\nset mapreduce.map.outout.compress.codec&#x3D;…; –设置压缩方式\n11）采用tez引擎或者spark引擎\n1.6.9 Hive解决数据倾斜方法1）数据倾斜长啥样？\n{width&#x3D;”5.768055555555556in”height&#x3D;”1.882638888888889in”}\n{width&#x3D;”5.647222222222222in”height&#x3D;”4.199305555555555in”}\n2）怎么产生的数据倾斜？\n（1）不同数据类型关联产生数据倾斜\n情形：比如用户表中user_id字段为int，log表中user_id字段string类型。当按照user_id进行两个表的Join操作时。\n解决方式：把数字类型转换成字符串类型\nselect * from users a\nleft outer join logs b\non a.usr_id &#x3D; cast(b.user_id as string)\nbug记录：[https://www.jianshu.com/p/2181e00d74dc]{.underline}\n（2）控制空值分布\n在生产环境经常会用大量空值数据进入到一个reduce中去，导致数据倾斜。\n解决办法：\n自定义分区，将为空的key转变为字符串加随机数或纯随机数，将因空值而造成倾斜的数据分不到多个Reducer。\n注意：对于异常值如果不需要的话，最好是提前在where条件里过滤掉，这样可以使计算量大大减少\n3) 单表 – group by id\n(1) 按照id分组计算count值\n-&gt; 单个Key\n-&gt; 多个Key\n(2) 单个Key\n加随机数，双重聚合\n配置参数，双重聚合 set hive.groupby.skewindata &#x3D; true;\n过滤出这个Key单独处理\n(3) 多个Key\n增加Reducer个数,一定程度上解决问题\n自定义分区器\n加随机数，双重聚合\n配置参数，双重聚合 set hive.groupby.skewindata &#x3D; true;\n4) JOIN ON 关联字段\n(1) 大表JOIN小表 mapJoin 避免了Reducer\n(2) 大表JOIN大表 A表加随机数 B表扩容 聚合\nA concat(name,’_’,随机数[1,2])\nB\nconcat(name,’_’,1)\nunion all\nconcat(name,’_’,2)\n\n\n\n\n\n\n\n\n\nname a1 name b1\nname a2 name b2\nname_1 a1 name_1 b1\nname_2 a2 name_2 b2\nname_1 a1 name_1 b1\nname_2 b1\nname_2 a2 name_1 b2\nname_2 b2\n1.6.10 Hive里边字段的分隔符用的什么？为什么用t？有遇到过字段里边有t的情况吗，怎么处理的？hive 默认的字段分隔符为ascii码的控制符001（^A）,建表的时候用fieldsterminated by‘001’。注意：如果采用t或者001等为分隔符，需要要求前端埋点和javaEE后台传递过来的数据必须不能出现该分隔符，通过代码规范约束。一旦传输过来的数据含有分隔符，需要在前一级数据中转义或者替换（ETL）。\n可以设置参数（导入HDFS同样有效）：\n–hive-drop-import-delims 导入到hive时删除 n, r, 001\n–hive-delims-replacement 导入到hive时用自定义的字符替换掉 n, r,001\n\n字段包含分隔符存在的问题：\n\n{width&#x3D;”5.432638888888889in”height&#x3D;”3.4340277777777777in”}\n\n添加参数的效果：\n\n{width&#x3D;”5.313194444444444in”height&#x3D;”4.254861111111111in”}\n\n在Hive表里的体现：\n\n{width&#x3D;”5.322222222222222in”height&#x3D;”1.4118055555555555in”}\n1.6.11 Tez引擎优点？Tez可以将多个有依赖的作业转换为一个作业，这样只需写一次HDFS，且中间节点较少，从而大大提升作业的计算性能。\nMr&#x2F;tez&#x2F;spark区别：\nMr引擎：多job串联，基于磁盘，落盘的地方比较多。虽然慢，但一定能跑出结果。一般处理，周、月、年指标。\nSpark引擎：虽然在Shuffle过程中也落盘，但是并不是所有算子都需要Shuffle，尤其是多算子过程，中间过程不落盘DAG有向无环图。 兼顾了可靠性和效率。一般处理天指标。\nTez引擎：完全基于内存。注意：如果数据量特别大，慎重使用。容易OOM。一般用于快速出结果，数据量比较小的场景。\n1.6.12 MySQL元数据备份1）MySQL之元数据备份（项目中遇到的问题）\n元数据备份（重点，如数据损坏，可能整个集群无法运行，至少要保证每日零点之后备份到其它服务器两个复本）\nKeepalived或者用mycat\n2）MySQL utf8超过字节数问题\nMySQL的utf8编码最多存储3个字节，当数据中存在表情号、特色符号时会占用超过3个字节数的字节，那么会出现错误Incorrect string value: ‘xF0x9Fx91x91xE5xB0…’\n解决办法：将utf8修改为utf8mb4\n首先修改库的基字符集和数据库排序规则\n{width&#x3D;”4.0368055555555555in”height&#x3D;”2.1638888888888888in”}\n再使用 SHOW VARIABLES LIKE ‘%char%’; 命令查看参数\n{width&#x3D;”2.2868055555555555in”height&#x3D;”1.8145833333333334in”}\n确保这几个参数的value值为utf8mb4 如果不是使用set命令修改\n如：set character_set_server &#x3D; utf8mb4;\n1.6.13 Union与Union all区别1）union会将联合的结果集去重，效率较union all差\n2）union all不会对结果集去重，所以效率高\n1.7 Sqoop1.7.1 Sqoop参数&#x2F;opt&#x2F;module&#x2F;sqoop&#x2F;bin&#x2F;sqoop import \n–connect \n–username \n–password \n–target-dir \n–delete-target-dir \n–num-mappers \n–fields-terminated-by   \n–query   “$2” ‘ and $CONDITIONS;’\n1.7.2 Sqoop导入导出Null存储一致性问题Hive中的Null在底层是以”N”来存储，而MySQL中的Null在底层就是Null，为了保证数据两端的一致性。在导出数据时采用–input-null-string和–input-null-non-string两个参数。导入数据时采用–null-string和–null-non-string。\n1.7.3 Sqoop数据导出一致性问题场景1：如Sqoop在导出到Mysql时，使用4个Map任务，过程中有2个任务失败，那此时MySQL中存储了另外两个Map任务导入的数据，此时老板正好看到了这个报表数据。而开发工程师发现任务失败后，会调试问题并最终将全部数据正确的导入MySQL，那后面老板再次看报表数据，发现本次看到的数据与之前的不一致，这在生产环境是不允许的。\n官网：http://sqoop.apache.org/docs/1.4.6/SqoopUserGuide.html\nSince Sqoop breaks down export process into multiple transactions, it ispossible that a failed export job may result in partial data beingcommitted to the database. This can further lead to subsequent jobsfailing due to insert collisions in some cases, or lead to duplicateddata in others. You can overcome this problem by specifying a stagingtable via the –staging-table option which acts as an auxiliary tablethat is used to stage exported data. The staged data is finally moved tothe destination table in a single transaction.\n–staging-table方式\nsqoop export –connect jdbc:mysql:&#x2F;&#x2F;192.168.137.10:3306&#x2F;user_behavior–username root –password 123456 –table app_cource_study_report–columns watch_video_cnt,complete_video_cnt,dt–fields-terminated-by “t” –export-dir“&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;tmp.db&#x2F;app_cource_study_analysis_${day}”–staging-table app_cource_study_report_tmp –clear-staging-table–input-null-string ‘N’\n1.7.4 Sqoop底层运行的任务是什么只有Map阶段，没有Reduce阶段的任务。默认是4个MapTask。\n1.7.5 Sqoop一天导入多少数据100万日活&#x3D;》10万订单，1人10条，每天1g左右业务数据\nSqoop每天将1G的数据量导入到数仓。\n1.7.6 Sqoop数据导出的时候一次执行多长时间每天晚上00:10开始执行，Sqoop任务一般情况20-30分钟的都有。取决于数据量（11.11，6.18等活动在1个小时左右）。\n1.7.7 Sqoop在导入数据的时候数据倾斜Sqoop参数撇嘴： split-by：按照自增主键来切分表的工作单元。\nnum-mappers：启动N个map来并行导入数据，默认4个；\n1.7.8 Sqoop数据导出Parquet（项目中遇到的问题）Ads层数据用Sqoop往MySql中导入数据的时候，如果用了orc（Parquet）不能导入，需转化成text格式\n（1）创建临时表，把Parquet中表数据导入到临时表，把临时表导出到目标表用于可视化\n（2）ads层建表的时候就不要建Parquet表\n1.8 Azkaban 1.8.1 每天集群运行多少指标?每天跑100多个指标，有活动时跑200个左右。\n1.8.2 任务挂了怎么办？\n\n\n\n\n\n\n\n\n1）运行成功或者失败都会发邮件、发钉钉、集成自动打电话（项目中遇到的问题）\n2）最主要的解决方案就是重新跑。\n3）报警网站[http://www.onealert.com/]{.underline}\n1.9 HBase1.9.1 HBase存储结构\n1.9.2 RowKey设计原则1）rowkey长度原则\n2）rowkey散列原则\n3）rowkey唯一原则\n1.9.3 RowKey如何设计使用场景:\n电信案例:查询某个人(手机号)某年某月某日的通话详情。\n\n预分区\n\n\n\n\n\n\n\n\n\n\n(1) 评估未来半年到一年的数据增长,不让其自动分区(10G)\n(2) 确定分区键\n\n\n\n\n\n\n\n\n\n00| 01| 02| …\n000| 001| …\n\n设计RowKey\n\n\n\n\n\n\n\n\n\n\n(1) 确定分区号 (散列性)\n00_ 01_ 02_…\n手机号%分区数 不够散列\n(手机号+年月日)%分区数 按照月份、年进行查询 不方便\n(手机号+年月)%分区数\n(2) 拼接字段 (唯一性、长度)\nXX_手机号_时间戳\nXX_手机号_年月日 时分秒\nXX_时间戳_手机号\nXX_年月日 时分秒_手机号\n(3) 校验\n13412341234 2021-09-07\nXX_手机号_年月日 时分秒\nstartRow:05_13412341234_2021-09-07\nstopRow :05_13412341234_2021-09-08\n05_13412341234_2021-09-07|\nXX_年月日 时分秒_手机号\nstartRow:05_2021-09-07 00:00:00_13412341234\nstopRow :05_2021-09-08 00:00:00_13412341234\n13412341234 2021-09 2021-11\nXX_手机号_年月日 时分秒\nstartRow:05_13412341234_2021-09\nstopRow :05_13412341234_2021-09|\n05_13412341234_2021-10\nstartRow:03_13412341234_2021-10\nstopRow :03_13412341234_2021-11\nstartRow:04_13412341234_2021-11\nstopRow :04_13412341234_2021-12\n1.9.4 Phoenix二级索引（讲原理）\n\n\n\n\n\n\n\n\n\n一级索引\n\nRowKey\n\n原理\n\n协处理器(HBase) coprocessor\n\n种类及用法\n\n(1) 全局:另外创建一张表专门存储索引\n读多写少 索引RowKey zs_1001\n(2) 本地:将索引数据直接写入原表(原Region)\n写多读少 索引RowKey 没有预分区 __zs_1001\n预分区 分区键_zs_1001\n1.10 Scala1.10.1 开发环境要求掌握必要的Scala开发环境搭建技能。\n1.10.2 变量和数据类型掌握var和val的区别\n掌握数值类型（Byte、Short、Int、Long、Float、Double、Char）之间的转换关系\n1.10.3 流程控制掌握if-else、for、while等必要的流程控制结构，掌握如何实现break、continue的功能。\n1.10.4 函数式编程函数可以作为参数进行传递（spark 移动数据不如移动逻辑）\n_\n掌握高阶函数、匿名函数、函数柯里化、函数参数以及函数至简原则。\n1.10.5 面向对象掌握Scala与Java继承方面的区别、单例对象（伴生对象）、特质的用法及功能。\n1.10.6 集合map flatmap\n掌握常用集合的使用、集合常用的计算函数。\n1.10.7 模式匹配switch case 样例类\n掌握模式匹配的用法\n1.10.8 异常掌握异常常用操作即可\n1.10.9 隐式转换掌握隐式方法、隐式参数、隐式类，以及隐式解析机制\n1.10.10 泛型掌握泛型语法\n1.11 Spark Core &amp; SQL1.11.1 Spark解决什么问题回顾：Hadoop主要解决，海量数据的存储和海量数据的分析计算。\nSpark主要解决海量数据的分析计算。\n1.11.2 Spark为什么会有自己的资源调度器Hadoop的Yarn框架比Spark框架诞生的晚，所以Spark自己也设计了一套资源调度框架。\n1.11.3 Spark运行模式1）Local：运行在一台机器上。 测试用。\n2）Standalone：是Spark自身的一个调度系统。对集群性能要求非常高时用。国内很少使用。\n3）Yarn：采用Hadoop的资源调度器。 国内大量使用。\n4）Mesos：国内很少使用。\n1.11.4 Spark常用端口号1）4040 spark-shell任务端口\n2）7077 内部通讯端口。 类比Hadoop的8020&#x2F;9000\n3）8080 查看任务执行情况端口。 类比Hadoop的8088\n4）18080 历史服务器。类比Hadoop的19888\n注意：由于Spark只负责计算，所有并没有Hadoop中存储数据的端口50070\n1.11.5 简述Spark的架构与作业提交流程（画图讲解，注明各个部分的作用）（重点）1.11.6 Spark任务使用什么进行提交，JavaEE界面还是脚本Shell脚本。\n1.11.7 Spark提交作业参数（重点）参考答案：\nhttps://blog.csdn.net/gamer_gyt/article/details/79135118\n1）在提交任务时的几个重要参数\n\n\n\n\n\n\n\n\n\nexecutor-cores ——每个executor使用的内核数，默认为1，官方建议2-5个，我们企业是4个\nnum-executors —— 启动executors的数量，默认为2\nexecutor-memory —— executor内存大小，默认1G\ndriver-cores —— driver使用内核数，默认为1\ndriver-memory —— driver内存大小，默认512M\n2）边给一个提交任务的样式\n\n\n\n\n\n\n\n\n\nspark-submit \n–master local[5] \n–driver-cores 2 \n–driver-memory 8g \n–executor-cores 4 \n–num-executors 10 \n–executor-memory 8g \n–class PackageName.ClassName XXXX.jar \n–name “Spark Job Name” \nInputPath \nOutputPath\n1.11.8 RDD五大属性1.11.9 Spark的transformation算子（不少于8个）（重点）1）单Value\n（1）map\n（2）mapPartitions\n（3）mapPartitionsWithIndex\n（4）flatMap\n（5）glom\n（6）groupBy\n（7）filter\n（8）sample\n（9）distinct\n（10）coalesce\n（11）repartition\n（12）sortBy\n（13）pipe\n2）双vlaue\n（1）intersection\n（2）union\n（3）subtract\n（4）zip\n3）Key-Value\n（1）partitionBy\n（2）reduceByKey\n（3）groupByKey\n（4）aggregateByKey\n（5）foldByKey\n（6）combineByKey\n（7）sortByKey\n（8）mapValues\n（9）join\n（10）cogroup\n1.11.10 Spark的action算子（不少于6个）（重点）（1）reduce\n（2）collect\n（3）count\n（4）first\n（5）take\n（6）takeOrdered\n（7）aggregate\n（8）fold\n（9）countByKey\n（10）save\n（11）foreach\n1.11.11 map和mapPartitions区别1）map：每次处理一条数据\n2）mapPartitions：每次处理一个分区数据\n1.11.12 Repartition和Coalesce区别1）关系：\n两者都是用来改变RDD的partition数量的，repartition底层调用的就是coalesce方法：coalesce(numPartitions,shuffle &#x3D; true)\n2）区别：\nrepartition一定会发生shuffle，coalesce根据传入的参数来判断是否发生shuffle\n一般情况下增大rdd的partition数量使用repartition，减少partition数量时使用coalesce\n1.11.13 reduceByKey与groupByKey的区别reduceByKey：具有预聚合操作\ngroupByKey：没有预聚合\n在不影响业务逻辑的前提下，优先采用reduceByKey。\n1.11.14 reduceByKey、foldByKey、aggregateByKey、combineByKey区别ReduceByKey 没有初始值 分区内和分区间逻辑相同\nfoldByKey 有初始值 分区内和分区间逻辑相同\naggregateByKey 有初始值 分区内和分区间逻辑可以不同\ncombineByKey 初始值可以变化结构 分区内和分区间逻辑不同\n1.11.15 Kryo序列化Kryo序列化比Java序列化更快更紧凑，但Spark默认的序列化是Java序列化并不是Spark序列化，因为Spark并不支持所有序列化类型，而且每次使用都必须进行注册。注册只针对于RDD。在DataFrames和DataSet当中自动实现了Kryo序列化。\n1.11.16 Spark中的血缘（笔试重点）宽依赖和窄依赖。有Shuffle的是宽依赖。\n1.11.17 Spark任务的划分（1）Application：初始化一个SparkContext即生成一个Application；\n（2）Job：一个Action算子就会生成一个Job；\n（3）Stage：Stage等于宽依赖的个数加1；\n（4）Task：一个Stage阶段中，最后一个RDD的分区个数就是Task的个数。\n1.11.18 cache缓存级别DataFrame的cache默认采用 MEMORY_AND_DISK\nRDD 的cache默认方式采用MEMORY_ONLY\n1.11.19 释放缓存和缓存缓存：(1)dataFrame.cache (2)sparkSession.catalog.cacheTable(“tableName”)\n释放缓存：(1)dataFrame.unpersist(2)sparkSession.catalog.uncacheTable(“tableName”)\n1.11.20 缓存和检查点区别1）Cache缓存只是将数据保存起来，不切断血缘依赖。Checkpoint检查点切断血缘依赖。\n2）Cache缓存的数据通常存储在磁盘、内存等地方，可靠性低。Checkpoint的数据通常存储在HDFS等容错、高可用的文件系统，可靠性高。\n3）建议对checkpoint()的RDD使用Cache缓存，这样checkpoint的job只需从Cache缓存中读取数据即可，否则需要再从头计算一次RDD。\n1.11.21 Spark分区1）默认采用Hash分区\n缺点：可能导致每个分区中数据量的不均匀，极端情况下会导致某些分区拥有RDD的全部数据。\n2）Ranger分区\n要求RDD中的KEY类型必须可以排序。\n3）自定义分区\n根据需求，自定义分区。\n1.11.22 Spark累加器1.11.23 Spark广播变量1.11.24 SparkSQL中RDD、DataFrame、DataSet三者的转换 （笔试重点）{width&#x3D;”5.6715277777777775in”height&#x3D;”3.1569444444444446in”}\n1.11.25 请列举会引起Shuffle过程的Spark算子，并简述功能。reduceBykey：\ngroupByKey：\n…ByKey:\n1.11.26 当Spark涉及到数据库的操作时，如何减少Spark运行中的数据库连接数？使用foreachPartition代替foreach，在foreachPartition内获取数据库的连接。\n1.11.27 如何使用Spark实现TopN的获取（描述思路或使用伪代码）（重点）方法1：\n（1）按照key对数据进行聚合（groupByKey）\n（2）将value转换为数组，利用scala的sortBy或者sortWith进行排序（mapValues）数据量太大，会OOM。\n方法2：\n（1）取出所有的key\n（2）对key进行迭代，每次取出一个key利用spark的排序算子进行排序\n方法3：\n（1）自定义分区器，按照key进行分区，使不同的key进到不同的分区\n（2）对每个分区运用spark的排序算子进行排序\n1.11.28 京东：调优之前与调优之后性能的详细对比（例如调整map个数，map个数之前多少、之后多少，有什么提升）这里举个例子。比如我们有几百个文件，会有几百个map出现，读取之后进行join操作，会非常的慢。这个时候我们可以进行coalesce操作，比如240个map，我们合成60个map，也就是窄依赖。这样再shuffle，过程产生的文件数会大大减少。提高join的时间性能。\n1.11.29 Spark Shuffle默认并行度参数spark.sql.shuffle.partitions 决定 默认并行度200\n1.11.30 控制Spark reduce缓存 调优shufflespark.reducer.maxSizeInFilght 此参数为reducetask能够拉取多少数据量的一个参数默认48MB，当集群资源足够时，增大此参数可减少reduce拉取数据量的次数，从而达到优化shuffle的效果，一般调大为96MB,，资源够大可继续往上调。\nspark.shuffle.file.buffer此参数为每个shuffle文件输出流的内存缓冲区大小，调大此参数可以减少在创建shuffle文件时进行磁盘搜索和系统调用的次数，默认参数为32k一般调大为64k。\n1.11.31 Spark内核源码（重点）1.12 Spark Streaming1.12.1 Spark Streaming第一次运行不丢失数据kafka参数 auto.offset.reset 参数设置成earliest从最初始偏移量开始消费数据\n1.12.2 Spark Streaming精准一次消费\n手动维护偏移量\n\n处理完业务数据后，再进行提交偏移量操作\n\n\n极端情况下，如在提交偏移量时断网或停电会造成spark程序第二次启动时重复消费问题，所以在涉及到金额或精确性非常高的场景会使用事物保证精准一次消费\n1.12.3 Spark Streaming控制每秒消费数据的速度通过spark.streaming.kafka.maxRatePerPartition参数来设置SparkStreaming从kafka分区每秒拉取的条数\n1.12.4 Spark Streaming背压机制把spark.streaming.backpressure.enabled参数设置为ture，开启背压机制后SparkStreaming会根据延迟动态去kafka消费数据，上限由spark.streaming.kafka.maxRatePerPartition参数控制，所以两个参数一般会一起使用。\n1.12.5 Spark Streaming一个stage耗时Spark Streamingstage耗时由最慢的task决定，所以数据倾斜时某个task运行慢会导致整个SparkStreaming都运行非常慢。\n1.12.6 Spark Streaming优雅关闭把spark.streaming.stopGracefullyOnShutdown参数设置成ture，Spark会在JVM关闭时正常关闭StreamingContext，而不是立马关闭\nKill 命令：yarn application -kill 后面跟 applicationid\n1.12.7 Spark Streaming默认分区个数Spark Streaming默认分区个数与所对接的kafka topic分区个数一致，SparkStreaming里一般不会使用repartition算子增大分区，因为repartition会进行shuffle增加耗时。\n1.12.8 SparkStreaming有哪几种方式消费Kafka中的数据，它们之间的区别是什么？一、基于Receiver的方式\n这种方式使用Receiver来获取数据。Receiver是使用Kafka的高层次ConsumerAPI来实现的。receiver从Kafka中获取的数据都是存储在SparkExecutor的内存中的（如果突然数据暴增，大量batch堆积，很容易出现内存溢出的问题），然后SparkStreaming启动的job会去处理那些数据。\n然而，在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用SparkStreaming的预写日志机制（Write AheadLog，WAL）。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。\n二、基于Direct的方式\n这种新的不基于Receiver的直接方式，是在Spark1.3中引入的，从而能够确保更加健壮的机制。替代掉使用Receiver来接收数据后，这种方式会周期性地查询Kafka，来获得每个topic+partition的最新的offset，从而定义每个batch的offset的范围。当处理数据的job启动时，就会使用Kafka的简单consumerapi来获取Kafka指定offset范围的数据。\n**优点如下： **\n简化并行读取：如果要读取多个partition，不需要创建多个输入DStream然后对它们进行union操作。Spark会创建跟Kafkapartition一样多的RDD partition，并且会并行从Kafka中读取数据。所以在Kafkapartition和RDD partition之间，有一个一对一的映射关系。\n高性能：如果要保证零数据丢失，在基于receiver的方式中，需要开启WAL机制。这种方式其实效率低下，因为数据实际上被复制了两份，Kafka自己本身就有高可靠的机制，会对数据复制一份，而这里又会复制一份到WAL中。而基于direct的方式，不依赖Receiver，不需要开启WAL机制，只要Kafka中作了数据的复制，那么就可以通过Kafka的副本进行恢复。\n一次且仅一次的事务机制。\n三、对比：\n基于receiver的方式，是使用Kafka的高阶API来在ZooKeeper中保存消费过的offset的。这是消费Kafka数据的传统方式。这种方式配合着WAL机制可以保证数据零丢失的高可靠性，但是却无法保证数据被处理一次且仅一次，可能会处理两次。因为Spark和ZooKeeper之间可能是不同步的。\n基于direct的方式，使用kafka的简单api，SparkStreaming自己就负责追踪消费的offset，并保存在checkpoint中。Spark自己一定是同步的，因此可以保证数据是消费一次且仅消费一次。\n在实际生产环境中大都用Direct方式\n1.12.9 简述SparkStreaming窗口函数的原理（重点）窗口函数就是在原来定义的SparkStreaming计算批次大小的基础上再次进行封装，每次计算多个批次的数据，同时还需要传递一个滑动步长的参数，用来设置当次计算任务完成之后下一次从什么地方开始计算。\n图中time1就是SparkStreaming计算批次大小，虚线框以及实线大框就是窗口的大小，必须为批次的整数倍。虚线框到大实线框的距离（相隔多少批次），就是滑动步长。\n1.13 数据倾斜公司一：总用户量1000万，5台64G内存的服务器。\n公司二：总用户量10亿，1000台64G内存的服务器。\n1.公司一的数据分析师在做join的时候发生了数据倾斜，会导致有几百万用户的相关数据集中到了一台服务器上，几百万的用户数据，说大也不大，正常字段量的数据的话64G还是能轻松处理掉的。\n2.公司二的数据分析师在做join的时候也发生了数据倾斜，可能会有1个亿的用户相关数据集中到了一台机器上了（相信我，这很常见）。这时候一台机器就很难搞定了，最后会很难算出结果。\n1.13.1 数据倾斜表现1）hadoop中的数据倾斜表现：\n\n有一个多几个Reduce卡住，卡在99.99%，一直不能结束。\n\n各种container报错OOM\n\n异常的Reducer读写的数据量极大，至少远远超过其它正常的Reducer\n\n伴随着数据倾斜，会出现任务被kill等各种诡异的表现。\n\n\n2）hive中数据倾斜\n一般都发生在Sql中group by和join on上，而且和数据逻辑绑定比较深。\n3）Spark中的数据倾斜\nSpark中的数据倾斜，包括Spark Streaming和Spark Sql，表现主要有下面几种：\n\nExecutor lost，OOM，Shuffle过程出错；\n\nDriver OOM；\n\n单个Executor执行时间特别久，整体任务卡在某个阶段不能结束；\n\n正常运行的任务突然失败；\n\n\n1.13.2 数据倾斜产生原因我们以Spark和Hive的使用场景为例。\n他们在做数据运算的时候会涉及到，count distinct、group by、joinon等操作，这些都会触发Shuffle动作。一旦触发Shuffle，所有相同key的值就会被拉到一个或几个Reducer节点上，容易发生单点计算问题，导致数据倾斜。\n一般来说，数据倾斜原因有以下几方面：\n1）key分布不均匀；\n{width&#x3D;”4.779166666666667in”height&#x3D;”3.988888888888889in”}\n2）建表时考虑不周\n我们举一个例子，就说数据默认值的设计吧，假设我们有两张表：\nuser（用户信息表）：userid，register_ip\nip（IP表）：ip，register_user_cnt\n这可能是两个不同的人开发的数据表。如果我们的数据规范不太完善的话，会出现一种情况：\nuser表中的register_ip字段，如果获取不到这个信息，我们默认为null；\n但是在ip表中，我们在统计这个值的时候，为了方便，我们把获取不到ip的用户，统一认为他们的ip为0。\n两边其实都没有错的，但是一旦我们做关联了，这个任务会在做关联的阶段，也就是sql的on的阶段卡死。\n3）业务数据激增\n比如订单场景，我们在某一天在北京和上海两个城市多了强力的推广，结果可能是这两个城市的订单量增长了10000%，其余城市的数据量不变。\n然后我们要统计不同城市的订单情况，这样，一做group操作，可能直接就数据倾斜了。\n1.13.3 解决数据倾斜思路很多数据倾斜的问题，都可以用和平台无关的方式解决，比如更好的数据预处理，异常值的过滤等。因此，解决数据倾斜的重点在于对数据设计和业务的理解，这两个搞清楚了，数据倾斜就解决了大部分了。\n1）业务逻辑\n我们从业务逻辑的层面上来优化数据倾斜，比如上面的两个城市做推广活动导致那两个城市数据量激增的例子，我们可以单独对这两个城市来做count，单独做时可用两次MR，第一次打散计算，第二次再最终聚合计算。完成后和其它城市做整合。\n2）程序层面\n比如说在Hive中，经常遇到count(distinct)操作，这样会导致最终只有一个Reduce任务。\n我们可以先groupby，再在外面包一层count，就可以了。比如计算按用户名去重后的总用户量：\n（1）优化前 只有一个reduce，先去重再count负担比较大：\nselect name,count(distinct name)from user;\n（2）优化后\n&#x2F;&#x2F; 设置该任务的每个job的reducer个数为3个。Hive默认-1，自动推断。\nset mapred.reduce.tasks&#x3D;3;\n&#x2F;&#x2F; 启动两个job，一个负责子查询(可以有多个reduce)，另一个负责count(1)：\nselect count(1) from (select name from user group by name) tmp;\n3）调参方面\nHadoop和Spark都自带了很多的参数和机制来调节数据倾斜，合理利用它们就能解决大部分问题。\n4）从业务和数据上解决数据倾斜\n很多数据倾斜都是在数据的使用上造成的。我们举几个场景，并分别给出它们的解决方案。\n\n有损的方法：找到异常数据，比如ip为0的数据，过滤掉\n\n无损的方法：对分布不均匀的数据，单独计算\n\n先对key做一层hash，先将数据随机打散让它的并行度变大，再汇集\n\n数据预处理\n\n\n1.13.4 定位导致数据倾斜代码Spark数据倾斜只会发生在shuffle过程中。\n这里给大家罗列一些常用的并且可能会触发shuffle操作的算子：distinct、groupByKey、reduceByKey、aggregateByKey、join、cogroup、repartition等。\n出现数据倾斜时，可能就是你的代码中使用了这些算子中的某一个所导致的。\n1.13.4.1 某个task执行特别慢的情况首先要看的，就是数据倾斜发生在第几个stage中：\n如果是用yarn-client模式提交，那么在提交的机器本地是直接可以看到log，可以在log中找到当前运行到了第几个stage；\n如果是用yarn-cluster模式提交，则可以通过Spark WebUI来查看当前运行到了第几个stage。\n此外，无论是使用yarn-client模式还是yarn-cluster模式，我们都可以在SparkWebUI上深入看一下当前这个stage各个task分配的数据量，从而进一步确定是不是task分配的数据不均匀导致了数据倾斜。\n看task运行时间和数据量\ntask运行时间\n比如下图中，倒数第三列显示了每个task的运行时间。明显可以看到，有的task运行特别快，只需要几秒钟就可以运行完；而有的task运行特别慢，需要几分钟才能运行完，此时单从运行时间上看就已经能够确定发生数据倾斜了。\ntask数据量\n此外，倒数第一列显示了每个task处理的数据量，明显可以看到，运行时间特别短的task只需要处理几百KB的数据即可，而运行时间特别长的task需要处理几千KB的数据，处理的数据量差了10倍。此时更加能够确定是发生了数据倾斜。\n推断倾斜代码\n知道数据倾斜发生在哪一个stage之后，接着我们就需要根据stage划分原理，推算出来发生倾斜的那个stage对应代码中的哪一部分，这部分代码中肯定会有一个shuffle类算子。\n精准推算stage与代码的对应关系，需要对Spark的源码有深入的理解，这里我们可以介绍一个相对简单实用的推算方法：只要看到Spark代码中出现了一个shuffle类算子或者是SparkSQL的SQL语句中出现了会导致shuffle的语句（比如groupby语句），那么就可以判定，以那个地方为界限划分出了前后两个stage。\n这里我们就以如下单词计数来举例。\nval conf &#x3D; new SparkConf()val sc &#x3D; new SparkContext(conf)val lines &#x3D;sc.textFile(“hdfs:&#x2F;&#x2F;…”)val words &#x3D; lines.flatMap(.split(““))val pairs &#x3D; words.map((, 1))val wordCounts &#x3D; pairs.reduceByKey(_\n\n)wordCounts.collect().foreach(println())\n\n在整个代码中只有一个reduceByKey是会发生shuffle的算子，也就是说这个算子为界限划分出了前后两个stage：\nstage0，主要是执行从textFile到map操作，以及shuffle write操作（对pairsRDD中的数据进行分区操作，每个task处理的数据中，相同的key会写入同一个磁盘文件内）。\nstage1，主要是执行从reduceByKey到collect操作，以及stage1的各个task一开始运行，就会首先执行shuffleread操作（会从stage0的各个task所在节点拉取属于自己处理的那些key，然后对同一个key进行全局性的聚合或join等操作，在这里就是对key的value值进行累加）\nstage1在执行完reduceByKey算子之后，就计算出了最终的wordCountsRDD，然后会执行collect算子，将所有数据拉取到Driver上，供我们遍历和打印输出。\n123456789\n通过对单词计数程序的分析，希望能够让大家了解最基本的stage划分的原理，以及stage划分后shuffle操作是如何在两个stage的边界处执行的。然后我们就知道如何快速定位出发生数据倾斜的stage对应代码的哪一个部分了。\n比如我们在Spark WebUI或者本地log中发现，stage1的某几个task执行得特别慢，判定stage1出现了数据倾斜，那么就可以回到代码中，定位出stage1主要包括了reduceByKey这个shuffle类算子，此时基本就可以确定是是该算子导致了数据倾斜问题。\n此时，如果某个单词出现了100万次，其他单词才出现10次，那么stage1的某个task就要处理100万数据，整个stage的速度就会被这个task拖慢。\n1.13.4.2 某个task莫名其妙内存溢出的情况这种情况下去定位出问题的代码就比较容易了。我们建议直接看yarn-client模式下本地log的异常栈，或者是通过YARN查看yarn-cluster模式下的log中的异常栈。一般来说，通过异常栈信息就可以定位到你的代码中哪一行发生了内存溢出。然后在那行代码附近找找，一般也会有shuffle类算子，此时很可能就是这个算子导致了数据倾斜。\n但是大家要注意的是，不能单纯靠偶然的内存溢出就判定发生了数据倾斜。因为自己编写的代码的bug，以及偶然出现的数据异常，也可能会导致内存溢出。因此还是要按照上面所讲的方法，通过SparkWebUI查看报错的那个stage的各个task的运行时间以及分配的数据量，才能确定是否是由于数据倾斜才导致了这次内存溢出。\n1.13.5 查看导致数据倾斜的key分布情况先对pairs采样10%的样本数据，然后使用countByKey算子统计出每个key出现的次数，最后在客户端遍历和打印样本数据中各个key的出现次数。\nval sampledPairs &#x3D; pairs.sample(false, 0.1)\nval sampledWordCounts &#x3D; sampledPairs.countByKey()\nsampledWordCounts.foreach(println(_))\n1.13.6 Spark 数据倾斜的解决方案1.13.6.1 使用Hive ETL预处理数据1.13.6.1.1 适用场景导致数据倾斜的是Hive表。如果该Hive表中的数据本身很不均匀（比如某个key对应了100万数据，其他key才对应了10条数据），而且业务场景需要频繁使用Spark对Hive表执行某个分析操作，那么比较适合使用这种技术方案。\n1.13.6.1.2 实现思路此时可以评估一下，是否可以通过Hive来进行数据预处理（即通过HiveETL预先对数据按照key进行聚合，或者是预先和其他表进行join），然后在Spark作业中针对的数据源就不是原来的Hive表了，而是预处理后的Hive表。此时由于数据已经预先进行过聚合或join操作了，那么在Spark作业中也就不需要使用原先的shuffle类算子执行这类操作了。\n1.13.6.1.3 方案实现原理这种方案从根源上解决了数据倾斜，因为彻底避免了在Spark中执行shuffle类算子，那么肯定就不会有数据倾斜的问题了。但是这里也要提醒一下大家，这种方式属于治标不治本。因为毕竟数据本身就存在分布不均匀的问题，所以HiveETL中进行group by或者join等shuffle操作时，还是会出现数据倾斜，导致HiveETL的速度很慢。我们只是把数据倾斜的发生提前到了HiveETL中，避免Spark程序发生数据倾斜而已。\n1.13.6.1.4 方案优缺点优点：实现起来简单便捷，效果还非常好，完全规避掉了数据倾斜，Spark作业的性能会大幅度提升。\n缺点：治标不治本，Hive ETL中还是会发生数据倾斜。\n1.13.6.1.5 方案实践经验在一些Java系统与Spark结合使用的项目中，会出现Java代码频繁调用Spark作业的场景，而且对Spark作业的执行性能要求很高，就比较适合使用这种方案。将数据倾斜提前到上游的HiveETL，每天仅执行一次，只有那一次是比较慢的，而之后每次Java调用Spark作业时，执行速度都会很快，能够提供更好的用户体验。\n1.13.6.1.6 项目实践经验在美团·点评的交互式用户行为分析系统中使用了这种方案，该系统主要是允许用户通过JavaWeb系统提交数据分析统计任务，后端通过Java提交Spark作业进行数据分析统计。要求Spark作业速度必须要快，尽量在10分钟以内，否则速度太慢，用户体验会很差。所以我们将有些Spark作业的shuffle操作提前到了HiveETL中，从而让Spark直接使用预处理的Hive中间表，尽可能地减少Spark的shuffle操作，大幅度提升了性能，将部分作业的性能提升了6倍以上。\n1.13.6.2 过滤少数导致倾斜的key1.13.6.2.1 方案适用场景如果发现导致倾斜的key就少数几个，而且对计算本身的影响并不大的话，那么很适合使用这种方案。比如99%的key就对应10条数据，但是只有一个key对应了100万数据，从而导致了数据倾斜。\n1.13.6.2.2 方案实现思路如果我们判断那少数几个数据量特别多的key，对作业的执行和计算结果不是特别重要的话，那么干脆就直接过滤掉那少数几个key。\n比如，在Spark SQL中可以使用where子句过滤掉这些key或者在SparkCore中对RDD执行filter算子过滤掉这些key。\n如果需要每次作业执行时，动态判定哪些key的数据量最多然后再进行过滤，那么可以使用sample算子对RDD进行采样，然后计算出每个key的数量，取数据量最多的key过滤掉即可。\n1.13.6.2.3 方案实现原理将导致数据倾斜的key给过滤掉之后，这些key就不会参与计算了，自然不可能产生数据倾斜。\n1.13.6.2.4 方案优缺点优点：实现简单，而且效果也很好，可以完全规避掉数据倾斜。\n缺点：适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。\n1.13.6.2.5 方案实践经验在项目中我们也采用过这种方案解决数据倾斜。有一次发现某一天Spark作业在运行的时候突然OOM了，追查之后发现，是Hive表中的某一个key在那天数据异常，导致数据量暴增。因此就采取每次执行前先进行采样，计算出样本中数据量最大的几个key之后，直接在程序中将那些key给过滤掉。\n1.13.6.3 提高shuffle操作的并行度1.13.6.3.1 方案适用场景如果我们必须要对数据倾斜迎难而上，那么建议优先使用这种方案，因为这是处理数据倾斜最简单的一种方案。\n1.13.6.3.2 方案实现思路在对RDD执行shuffle算子时，给shuffle算子传入一个参数，比如reduceByKey(1000)，该参数就设置了这个shuffle算子执行时shuffleread task的数量，即spark.sql.shuffle.partitions，该参数代表了shuffleread task的并行度，默认是200，对于很多场景来说都有点过小。\n1.13.6.3.3 方案实现原理增加shuffle readtask的数量，可以让原本分配给一个task的多个key分配给多个task，从而让每个task处理比原来更少的数据。举例来说，如果原本有5个key，每个key对应10条数据，这5个key都是分配给一个task的，那么这个task就要处理50条数据。\n而增加了shuffle readtask以后，每个task就分配到一个key，即每个task就处理10条数据，那么自然每个task的执行时间都会变短了。具体原理如下图所示。\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.517361111111111in”}\n1.13.6.3.4 方案优缺点优点：实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。\n缺点：只是缓解了数据倾斜而已，没有彻底根除问题，根据实践经验来看，其效果有限。\n1.13.6.3.5 方案实践经验该方案通常无法彻底解决数据倾斜，因为如果出现一些极端情况，比如某个key对应的数据量有100万，那么无论你的task数量增加到多少，这个对应着100万数据的key肯定还是会分配到一个task中去处理，因此注定还是会发生数据倾斜的。所以这种方案只能说是在发现数据倾斜时尝试使用的第一种手段，尝试去用最简单的方法缓解数据倾斜而已，或者是和其他方案结合起来使用。\n1.13.6.4 两阶段聚合（局部聚合+全局聚合）1.13.6.4.1 方案适用场景对RDD执行reduceByKey等聚合类shuffle算子或者在Spark SQL中使用groupby语句进行分组聚合时，比较适用这种方案。\n1.13.6.4.2 方案实现思路这个方案的核心实现思路就是进行两阶段聚合：\n第一次是局部聚合，先给每个key都打上一个随机数，比如10以内的随机数，此时原先一样的key就变成不一样的了，比如(hello,\n\n(hello, 1) (hello, 1) (hello, 1)，就会变成(1_hello, 1) (1_hello, 1)(2_hello, 1) (2_hello, 1)。\n\n接着对打上随机数后的数据，执行reduceByKey等聚合操作，进行局部聚合，那么局部聚合结果，就会变成了(1_hello,2) (2_hello, 2)。\n然后将各个key的前缀给去掉，就会变成(hello,2)(hello,2)，再次进行全局聚合操作，就可以得到最终结果了，比如(hello,4)。\n\n\n\n\n\n\n\n\n\n示例代码如下：\n&#x2F;&#x2F; 第一步，给RDD中的每个key都打上一个随机前缀。JavaPairRDD&lt;String, Long&gt; randomPrefixRdd &#x3D; rdd.mapToPair(new PairFunction&lt;Tuple2&lt;Long,Long&gt;, String, Long&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Tuple2&lt;String, Long&gt; call(Tuple2&lt;Long, Long&gt; tuple)throws Exception {Random random &#x3D; new Random();int prefix &#x3D; random.nextInt(10);return new Tuple2&lt;String, Long&gt;(prefix + “_” + tuple._1,tuple._2);}});\n&#x2F;&#x2F; 第二步，对打上随机前缀的key进行局部聚合。JavaPairRDD&lt;String, Long&gt; localAggrRdd &#x3D; randomPrefixRdd.reduceByKey(new Function2&lt;Long, Long, Long&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Long call(Long v1, Long v2) throws Exception {return v1 + v2;}});\n&#x2F;&#x2F; 第三步，去除RDD中每个key的随机前缀。JavaPairRDD&lt;Long, Long&gt; removedRandomPrefixRdd &#x3D;localAggrRdd.mapToPair(new PairFunction&lt;Tuple2&lt;String,Long&gt;, Long, Long&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Tuple2&lt;Long, Long&gt; call(Tuple2&lt;String, Long&gt; tuple)throws Exception {long originalKey &#x3D; Long.valueOf(tuple.1.split(““)[1]);return new Tuple2&lt;Long, Long&gt;(originalKey, tuple._2);}});\n&#x2F;&#x2F; 第四步，对去除了随机前缀的RDD进行全局聚合。JavaPairRDD&lt;Long, Long&gt; globalAggrRdd &#x3D;removedRandomPrefixRdd.reduceByKey(new Function2&lt;Long, Long, Long&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Long call(Long v1, Long v2) throws Exception {return v1 + v2;}});\n1.13.6.4.3 方案实现原理将原本相同的key通过附加随机前缀的方式，变成多个不同的key，就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，进而解决单个task处理数据量过多的问题。接着去除掉随机前缀，再次进行全局聚合，就可以得到最终的结果。具体原理见下图。\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.45in”}\n1.13.6.4.4 方案优缺点优点对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。\n缺点仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案。\n1.13.6.5 将reduce join转为map join1.13.6.5.1 方案适用场景在对RDD使用join类操作，或者是在SparkSQL中使用join语句时，而且join操作中的一个RDD或表的数据量比较小（比如几百M或者一两G），比较适用此方案。\n1.13.6.5.2 方案实现思路不使用join算子进行连接操作，而使用Broadcast变量与map类算子实现join操作，进而完全规避掉shuffle类的操作，彻底避免数据倾斜的发生和出现。将较小RDD中的数据直接通过collect算子拉取到Driver端的内存中来，然后对其创建一个Broadcast变量，广播给其他Executor节点；\n接着对另外一个RDD执行map类算子，在算子函数内，从Broadcast变量中获取较小RDD的全量数据，与当前RDD的每一条数据按照连接key进行比对，如果连接key相同的话，那么就将两个RDD的数据用你需要的方式连接起来。\n示例如下：\n&#x2F;&#x2F; 首先将数据量比较小的RDD的数据，collect到Driver中来。List&lt;Tuple2&lt;Long, Row&gt;&gt; rdd1Data &#x3D; rdd1.collect()&#x2F;&#x2F;然后使用Spark的广播功能，将小RDD的数据转换成广播变量，这样每个Executor就只有一份RDD的数据。&#x2F;&#x2F; 可以尽可能节省内存空间，并且减少网络传输性能开销。final Broadcast&lt;List&lt;Tuple2&lt;Long, Row&gt;&gt;&gt; rdd1DataBroadcast &#x3D;sc.broadcast(rdd1Data);\n&#x2F;&#x2F; 对另外一个RDD执行map类操作，而不再是join类操作。JavaPairRDD&lt;String, Tuple2&lt;String, Row&gt;&gt; joinedRdd &#x3D;rdd2.mapToPair(new PairFunction&lt;Tuple2&lt;Long,String&gt;, String, Tuple2&lt;String,Row&gt;&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Tuple2&lt;String, Tuple2&lt;String, Row&gt;&gt; call(Tuple2&lt;Long,String&gt; tuple)throws Exception {&#x2F;&#x2F; 在算子函数中，通过广播变量，获取到本地Executor中的rdd1数据。List&lt;Tuple2&lt;Long, Row&gt;&gt; rdd1Data &#x3D; rdd1DataBroadcast.value();&#x2F;&#x2F; 可以将rdd1的数据转换为一个Map，便于后面进行join操作。Map&lt;Long, Row&gt; rdd1DataMap &#x3D; new HashMap&lt;Long, Row&gt;();for(Tuple2&lt;Long, Row&gt; data : rdd1Data) {rdd1DataMap.put(data._1, data._2);}&#x2F;&#x2F; 获取当前RDD数据的key以及value。String key &#x3D; tuple._1;String value &#x3D; tuple._2;&#x2F;&#x2F; 从rdd1数据Map中，根据key获取到可以join到的数据。Row rdd1Value &#x3D; rdd1DataMap.get(key);return new Tuple2&lt;String, String&gt;(key, new Tuple2&lt;String,Row&gt;(value, rdd1Value));}});\n&#x2F;&#x2F; 这里得提示一下。&#x2F;&#x2F; 上面的做法，仅仅适用于rdd1中的key没有重复，全部是唯一的场景。&#x2F;&#x2F;如果rdd1中有多个相同的key，那么就得用flatMap类的操作，在进行join的时候不能用map，而是得遍历rdd1所有数据进行join。&#x2F;&#x2F; rdd2中每条数据都可能会返回多条join后的数据。\n1.13.6.5.3 方案实现原理普通的join是会走shuffle过程的，而一旦shuffle，就相当于会将相同key的数据拉取到一个shuffleread task中再进行join，此时就是reduce join。\n但是如果一个RDD是比较小的，则可以采用广播小RDD全量数据+map算子来实现与join同样的效果，也就是mapjoin，此时就不会发生shuffle操作，也就不会发生数据倾斜。具体原理如下图所示。\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.035416666666667in”}\n1.13.6.5.4 方案优缺点优点：对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。\n缺点：适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。\n1.13.6.6 采样倾斜key并分拆join操作1.13.6.6.1 方案适用场景两个RDD&#x2F;Hive表进行join的时候，如果数据量都比较大，无法采用”解决方案五”，那么此时可以看一下两个RDD&#x2F;Hive表中的key分布情况。\n如果出现数据倾斜，是因为其中某一个RDD&#x2F;Hive表中的少数几个key的数据量过大，而另一个RDD&#x2F;Hive表中的所有key都分布比较均匀，那么采用这个解决方案是比较合适的。\n1.13.6.6.2 方案实现思路对包含少数几个数据量过大的key的那个RDD，通过sample算子采样出一份样本来，然后统计一下每个key的数量，计算出来数据量最大的是哪几个key。\n然后将这几个key对应的数据从原来的RDD中拆分出来，形成一个单独的RDD，并给每个key都打上n以内的随机数作为前缀；\n而不会导致倾斜的大部分key形成另外一个RDD。\n接着将需要join的另一个RDD，也过滤出来那几个倾斜key对应的数据并形成一个单独的RDD，将每条数据膨胀成n条数据，这n条数据都按顺序附加一个0~n的前缀；\n不会导致倾斜的大部分key也形成另外一个RDD。\n再将附加了随机前缀的独立RDD与另一个膨胀n倍的独立RDD进行join，此时就可以将原先相同的key打散成n份，分散到多个task中去进行join了。\n而另外两个普通的RDD就照常join即可。\n最后将两次join的结果使用union算子合并起来即可，就是最终的join结果。\n示例如下：\n&#x2F;&#x2F; 首先从包含了少数几个导致数据倾斜key的rdd1中，采样10%的样本数据。JavaPairRDD&lt;Long, String&gt; sampledRDD &#x3D; rdd1.sample(false, 0.1);\n&#x2F;&#x2F; 对样本数据RDD统计出每个key的出现次数，并按出现次数降序排序。&#x2F;&#x2F; 对降序排序后的数据，取出top 1或者top100的数据，也就是key最多的前n个数据。&#x2F;&#x2F;具体取出多少个数据量最多的key，由大家自己决定，我们这里就取1个作为示范。\n&#x2F;&#x2F; 每行数据变为&lt;key,1&gt;JavaPairRDD&lt;Long, Long&gt; mappedSampledRDD &#x3D; sampledRDD.mapToPair(new PairFunction&lt;Tuple2&lt;Long,String&gt;, Long, Long&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Tuple2&lt;Long, Long&gt; call(Tuple2&lt;Long, String&gt; tuple)throws Exception {return new Tuple2&lt;Long, Long&gt;(tuple._1, 1L);}});\n&#x2F;&#x2F; 按key累加行数JavaPairRDD&lt;Long, Long&gt; countedSampledRDD &#x3D;mappedSampledRDD.reduceByKey(new Function2&lt;Long, Long, Long&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Long call(Long v1, Long v2) throws Exception {return v1 + v2;}});\n&#x2F;&#x2F; 反转key和value,变为&lt;value,key&gt;JavaPairRDD&lt;Long, Long&gt; reversedSampledRDD &#x3D;countedSampledRDD.mapToPair(new PairFunction&lt;Tuple2&lt;Long,Long&gt;, Long, Long&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Tuple2&lt;Long, Long&gt; call(Tuple2&lt;Long, Long&gt; tuple)throws Exception {return new Tuple2&lt;Long, Long&gt;(tuple._2, tuple._1);}});\n&#x2F;&#x2F; 以行数排序key，取最多行数的keyfinal Long skewedUserid &#x3D;reversedSampledRDD.sortByKey(false).take(1).get(0)._2;\n&#x2F;&#x2F; 从rdd1中分拆出导致数据倾斜的key，形成独立的RDD。JavaPairRDD&lt;Long, String&gt; skewedRDD &#x3D; rdd1.filter(new Function&lt;Tuple2&lt;Long,String&gt;, Boolean&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Boolean call(Tuple2&lt;Long, String&gt; tuple) throws Exception {return tuple._1.equals(skewedUserid);}});\n&#x2F;&#x2F; 从rdd1中分拆出不导致数据倾斜的普通key，形成独立的RDD。JavaPairRDD&lt;Long, String&gt; commonRDD &#x3D; rdd1.filter(new Function&lt;Tuple2&lt;Long,String&gt;, Boolean&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Boolean call(Tuple2&lt;Long, String&gt; tuple) throws Exception {return !tuple._1.equals(skewedUserid);}});\n&#x2F;&#x2F; rdd2，就是那个所有key的分布相对较为均匀的rdd。&#x2F;&#x2F;这里将rdd2中，前面获取到的key对应的数据，过滤出来，分拆成单独的rdd，并对rdd中的数据使用flatMap算子都扩容100倍。&#x2F;&#x2F; 对扩容的每条数据，都打上0～100的前缀。JavaPairRDD&lt;String, Row&gt; skewedRdd2 &#x3D; rdd2.filter(new Function&lt;Tuple2&lt;Long,Row&gt;, Boolean&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Boolean call(Tuple2&lt;Long, Row&gt; tuple) throws Exception {return tuple.1.equals(skewedUserid);}}).flatMapToPair(new PairFlatMapFunction&lt;Tuple2&lt;Long,Row&gt;, String,Row&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Iterable&lt;Tuple2&lt;String, Row&gt;&gt; call(Tuple2&lt;Long, Row&gt; tuple) throws Exception {Random random &#x3D; new Random();List&lt;Tuple2&lt;String, Row&gt;&gt; list &#x3D; new ArrayList&lt;Tuple2&lt;String,Row&gt;&gt;();for(int i &#x3D; 0; i &lt; 100; i++) {list.add(new Tuple2&lt;String, Row&gt;(i + ““ + tuple._1, tuple._2));}return list;}\n});\n&#x2F;&#x2F;将rdd1中分拆出来的导致倾斜的key的独立rdd，每条数据都打上100以内的随机前缀。&#x2F;&#x2F;然后将这个rdd1中分拆出来的独立rdd，与上面rdd2中分拆出来的独立rdd，进行join。JavaPairRDD&lt;Long, Tuple2&lt;String, Row&gt;&gt; joinedRDD1 &#x3D;skewedRDD.mapToPair(new PairFunction&lt;Tuple2&lt;Long,String&gt;, String, String&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Tuple2&lt;String, String&gt; call(Tuple2&lt;Long, String&gt; tuple)throws Exception {Random random &#x3D; new Random();int prefix &#x3D; random.nextInt(100);return new Tuple2&lt;String, String&gt;(prefix + “_” + tuple._1,tuple._2);}}).join(skewedUserid2infoRDD).mapToPair(new PairFunction&lt;Tuple2&lt;String,Tuple2&lt;String,Row&gt;&gt;,Long, Tuple2&lt;String, Row&gt;&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Tuple2&lt;Long, Tuple2&lt;String, Row&gt;&gt; call(Tuple2&lt;String, Tuple2&lt;String, Row&gt;&gt; tuple)throws Exception {long key &#x3D; Long.valueOf(tuple.1.split(““)[1]);return new Tuple2&lt;Long, Tuple2&lt;String, Row&gt;&gt;(key, tuple._2);}});\n&#x2F;&#x2F; 将rdd1中分拆出来的包含普通key的独立rdd，直接与rdd2进行join。JavaPairRDD&lt;Long, Tuple2&lt;String, Row&gt;&gt; joinedRDD2 &#x3D;commonRDD.join(rdd2);\n&#x2F;&#x2F; 将倾斜key join后的结果与普通key join后的结果，uinon起来。&#x2F;&#x2F; 就是最终的join结果。JavaPairRDD&lt;Long, Tuple2&lt;String, Row&gt;&gt; joinedRDD &#x3D;joinedRDD1.union(joinedRDD2);\n1.13.6.6.3 方案实现原理对于join导致的数据倾斜，如果只是某几个key导致了倾斜，可以将少数几个key分拆成独立RDD，并附加随机前缀打散成n份去进行join，此时这几个key对应的数据就不会集中在少数几个task上，而是分散到多个task进行join了。具体原理见下图。\n{width&#x3D;”5.708333333333333in”height&#x3D;”6.489583333333333in”}\n1.13.6.6.4 方案优缺点优点：对于join导致的数据倾斜，如果只是某几个key导致了倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容。避免了占用过多内存。\n缺点：如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜，那么这种方式也不适合。\n1.13.6.7 使用随机前缀和扩容RDD进行join1.13.6.7.1 方案适用场景如果在进行join操作时，RDD中有大量的key导致数据倾斜，那么进行分拆key也没什么意义，此时就只能使用最后一种方案来解决问题了。\n1.13.6.7.2 方案实现思路该方案的实现思路基本和”解决方案六”类似，首先查看RDD&#x2F;Hive表中的数据分布情况，找到那个造成数据倾斜的RDD&#x2F;Hive表，比如有多个key都对应了超过1万条数据。\n然后将该RDD的每条数据都打上一个n以内的随机前缀。\n同时对另外一个正常的RDD进行扩容，将每条数据都扩容成n条数据，扩容出来的每条数据都依次打上一个0~n的前缀。\n最后将两个处理后的RDD进行join即可。\n示例代码如下：\n&#x2F;&#x2F; 首先将其中一个key分布相对较为均匀的RDD膨胀100倍。JavaPairRDD&lt;String, Row&gt; expandedRDD &#x3D; rdd1.flatMapToPair(new PairFlatMapFunction&lt;Tuple2&lt;Long,Row&gt;, String, Row&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Iterable&lt;Tuple2&lt;String, Row&gt;&gt; call(Tuple2&lt;Long, Row&gt;tuple)throws Exception {List&lt;Tuple2&lt;String, Row&gt;&gt; list &#x3D; new ArrayList&lt;Tuple2&lt;String,Row&gt;&gt;();for(int i &#x3D; 0; i &lt; 100; i++) {list.add(new Tuple2&lt;String, Row&gt;(0 + “_” + tuple._1, tuple._2));}return list;}});\n&#x2F;&#x2F; 其次，将另一个有数据倾斜key的RDD，每条数据都打上100以内的随机前缀。JavaPairRDD&lt;String, String&gt; mappedRDD &#x3D; rdd2.mapToPair(new PairFunction&lt;Tuple2&lt;Long,String&gt;, String, String&gt;() {private static final long serialVersionUID &#x3D; 1L;@Overridepublic Tuple2&lt;String, String&gt; call(Tuple2&lt;Long, String&gt; tuple)throws Exception {Random random &#x3D; new Random();int prefix &#x3D; random.nextInt(100);return new Tuple2&lt;String, String&gt;(prefix + “_” + tuple._1,tuple._2);}});\n&#x2F;&#x2F; 将两个处理后的RDD进行join即可。JavaPairRDD&lt;String, Tuple2&lt;String, Row&gt;&gt; joinedRDD &#x3D;mappedRDD.join(expandedRDD);\n1.13.6.7.3 方案实现原理将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的”不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。\n该方案与”解决方案六”的不同之处就在于，上一种方案是尽量只对少数倾斜key对应的数据进行特殊处理，由于处理过程需要扩容RDD，因此上一种方案扩容RDD后对内存的占用并不大；\n而这一种方案是针对有大量倾斜key的情况，没法将部分key拆分出来进行单独处理，因此只能对整个RDD进行数据扩容，对内存资源要求很高。\n1.13.6.7.4 方案优缺点优点：对join类型的数据倾斜基本都可以处理，而且效果也相对比较显著，性能提升效果非常不错。\n缺点：该方案更多的是缓解数据倾斜，而不是彻底避免数据倾斜。而且需要对整个RDD进行扩容，对内存资源要求很高。\n1.13.6.7.5 方案实践经验曾经开发一个数据需求的时候，发现一个join导致了数据倾斜。优化之前，作业的执行时间大约是60分钟左右；使用该方案优化之后，执行时间缩短到10分钟左右，性能提升了6倍。\n1.13.6.8 多种方案组合使用在实践中发现，很多情况下，如果只是处理较为简单的数据倾斜场景，那么使用上述方案中的某一种基本就可以解决。但是如果要处理一个较为复杂的数据倾斜场景，那么可能需要将多种方案组合起来使用。\n比如说，我们针对出现了多个数据倾斜环节的Spark作业，可以先运用解决方案一HiveETL预处理和过滤少数导致倾斜的k，预处理一部分数据，并过滤一部分数据来缓解；\n其次可以对某些shuffle操作提升并行度，优化其性能；\n最后还可以针对不同的聚合或join操作，选择一种方案来优化其性能。\n大家需要对这些方案的思路和原理都透彻理解之后，在实践中根据各种不同的情况，灵活运用多种方案，来解决自己的数据倾斜问题。\n1.13.7 Spark数据倾斜处理小结{width&#x3D;”5.768055555555556in”height&#x3D;”4.545138888888889in”}\n1.14 Flink 1.14.1 简单介绍一下 FlinkFlink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。并且Flink提供了数据分布、容错机制以及资源管理等核心功能。Flink提供了诸多高抽象层的API以便用户编写分布式任务：\nDataSet API，对静态数据进行批处理操作，将静态数据抽象成分布式的数据集，用户可以方便地使用Flink提供的各种操作符对分布式数据集进行处理，支持Java、Scala和Python。\nDataStreamAPI，对数据流进行流处理操作，将流式的数据抽象成分布式的数据流，用户可以方便地对分布式数据流进行各种操作，支持Java和Scala。\nTableAPI，对结构化数据进行查询操作，将结构化数据抽象成关系表，并通过类SQL的DSL对关系表进行各种查询操作，支持Java和Scala。\n此外，Flink 还针对特定的应用领域提供了领域库，例如： Flink ML，Flink的机器学习库，提供了机器学习Pipelines API并实现了多种机器学习算法。Gelly，Flink 的图计算库，提供了图计算的相关API及多种图计算算法实现。\n1.14.2 Flink跟Spark Streaming的区别这个问题是一个非常宏观的问题，因为两个框架的不同点非常之多。但是在面试时有非常重要的一点一定要回答出来：Flink是标准的实时处理引擎，基于事件驱动。而 Spark Streaming是微批（Micro-Batch）的模型。\n下面我们就分几个方面介绍两个框架的主要区别：\n1）架构模型Spark Streaming在运行时的主要角色包括：Master、Worker、Driver、Executor，Flink在运行时主要包含：Jobmanager、Taskmanager和Slot。\n2）任务调度Spark Streaming连续不断的生成微小的数据批次，构建有向无环图DAG，Spark Streaming会依次创建 DStreamGraph、JobGenerator、JobScheduler。Flink根据用户提交的代码生成 StreamGraph，经过优化生成 JobGraph，然后提交给JobManager进行处理，JobManager 会根据 JobGraph 生成ExecutionGraph，ExecutionGraph 是 Flink 调度最核心的数据结构，JobManager根据 ExecutionGraph 对 Job 进行调度。\n3）时间机制Spark Streaming 支持的时间机制有限，只支持处理时间。 Flink支持了流处理程序在时间上的三个定义：处理时间、事件时间、注入时间。同时也支持watermark 机制来处理滞后数据。\n4）容错机制对于 Spark Streaming 任务，我们可以设置checkpoint，然后假如发生故障并重启，我们可以从上次 checkpoint之处恢复，但是这个行为只能使得数据不丢失，可能会重复处理，不能做到恰好一次处理语义。Flink则使用两阶段提交协议来解决这个问题。\n1.14.3 Flink集群有哪些角色？各自有什么作用？{width&#x3D;”5.768055555555556in”height&#x3D;”4.245833333333334in”}\nFlink程序在运行时主要有TaskManager，JobManager，Client三种角色。\nJobManager扮演着集群中的管理者Master的角色，它是整个集群的协调者，负责接收FlinkJob，协调检查点，Failover故障恢复等，同时管理Flink集群中从节点TaskManager。\nTaskManager是实际负责执行计算的Worker，在其上执行FlinkJob的一组Task，每个TaskManager负责管理其所在节点上的资源信息，如内存、磁盘、网络，在启动的时候将资源的状态向JobManager汇报。\nClient是Flink程序提交的客户端，当用户提交一个Flink程序时，会首先创建一个Client，该Client首先会对用户提交的Flink程序进行预处理，并提交到Flink集群中处理，所以Client需要从用户提交的Flink程序配置中获取JobManager的地址，并建立到JobManager的连接，将FlinkJob提交给JobManager。\n1.14.4 Flink的编程模型是什么？Environment -&gt; Source -&gt; Transform -&gt; Sink\n分层API\n1.14.5 公司怎么提交的实时任务，有多少Job Manager？ 有多少TaskManager？1）我们使用yarn per-job模式提交任务\n2）集群默认只有一个 JobManager。但为了防止单点故障，我们配置了高可用。对于standlone模式，我们公司一般配置一个主Job Manager，两个备用 Job Manager，然后结合 ZooKeeper的使用，来达到高可用；对于yarn模式，yarn在JobMananger故障会自动进行重启，所以只需要一个，我们配置的最大重启次数是10次。\n3）基于yarn，动态申请TaskManager的数量\n1.14.6 Flink的并行度了解吗？Flink的并行度设置是怎样的？Flink中的任务被分为多个并行任务来执行，其中每个并行的实例处理一部分数据。这些并行实例的数量被称为并行度。我们在实际生产环境中可以从四个不同层面设置并行度：\n操作算子层面(Operator Level)\n执行环境层面(Execution Environment Level)\n客户端层面(Client Level)\n系统层面(System Level)\n需要注意的优先级：算子层面&gt;环境层面&gt;客户端层面&gt;系统层面。\n并行度的设置：一般设为kafka的分区数，达到1：1\n遵循2的n次方：比如2、4、8、16…..\n1.14.7 Flink的keyby怎么实现的分区？分区、分组的区别是什么？Keyby实现原理：\n对指定的key调用自身的hashCode方法&#x3D;》hash1\n调用murmruhash算法，进行第二次hash &#x3D;》键组ID\n通过一个公式，计算出当前数据应该去往哪个下游分区：\n键组id * 下游算子并行度 &#x2F; 最大并行度（默认128）\n分区：算子的一个并行实例可以理解成一个分区，是物理上的资源\n分组：数据根据key进行区分，是一个逻辑上的划分\n一个分区可以有多个分组，同一个分组的数据肯定在同一个分区\n1.14.8 Flink的interval join的实现原理？join不上的怎么办？底层调用的是keyby+connect ，处理逻辑：\n1）判断是否迟到（迟到就不处理了）\n2）每条流都存了一个Map类型的状态（key是时间戳，value是List存数据）\n3）任一条流，来了一条数据，遍历对方的map状态，能匹配上就发往join方法\n4）超过有效时间范围，会删除对应Map中的数据（不是clear，是remove）\nInterval join不会处理join不上的数据，如果需要没join上的数据，可以用coGroup+connect算子实现，或者直接使用flinksql里的left join或rightjoin语法。\n1.14.9 介绍一下Flink的状态编程、状态机制？算子状态：作用范围是算子，算子的多个并行实例各自维护一个状态\n键控状态：每个分组维护一个状态\n状态后端：两件事&#x3D;》 本地状态存哪里、checkpoint存哪里\n本地状态 Checkpoint\n内存 TaskManager的内存 JobManager内存\n文件 TaskManager的内存 HDFS\nRocksDB RocksDB HDFS\n1.14.10 Flink的三种时间语义EventTime：是事件创建的时间。它通常由事件中的时间戳描述，例如采集的日志数据中，每一条日志都会记录自己的生成时间，Flink通过时间戳分配器访问事件时间戳。\nIngestion Time：是数据进入Flink的时间。\nProcessingTime：是每一个执行基于时间操作的算子的本地系统时间，与机器相关，默认的时间属性就是ProcessingTime。\n1.14.11 Flink 中的Watermark机制1）Watermark 是一种衡量 Event Time 进展的机制，可以设定延迟触发\n2）Watermark 是用于处理乱序事件的，而正确的处理乱序事件，通常用Watermark机制结合 window 来实现；\n3）基于事件时间，用来触发窗口、定时器等\n4）watermark主要属性就是时间戳，可以理解一个特殊的数据，插入到流里面\n5）watermark是单调不减的\n6）数据流中的 Watermark 用于表示 timestamp 小于 Watermark的数据，都已经到达了，如果后续还有timestamp 小于 Watermark的数据到达，称为迟到数据\n1.14.12 Watermark是数据吗？怎么生成的？怎么传递的？Watermark是一条携带时间戳的特殊数据，从代码指定生成的位置，插入到流里面。\n一对多：广播\n多对一：取最小\n多对多：拆分来看，其实就是上面两种的结合\n1.14.13 Watermark的生成方式？间歇性：来一条数据，更新一次watermark\n周期性：固定周期更新watermark\n官方提供的api是基于周期的，默认200ms，因为间歇性会给系统带来压力。\nWatermark&#x3D;当前最大事件时间-乱序时间-1ms\n1.14.14 说说Flink中的窗口（分类、生命周期、触发、划分）1）窗口分类： Keyed Window和Non-keyed Window\n基于时间：滚动、滑动、会话\n基于数量：滚动、滑动\n2）Window口的4个相关重要组件：\n\nassigner（分配器）：如何将元素分配给窗口\n\nfunction（计算函数）：为窗口定义的计算。其实是一个计算函数，完成窗口内容的计算。\n\ntriger（触发器）：在什么条件下触发窗口的计算\n\nevictor（退出器）：定义从窗口中移除数据\n\n\n3）窗口的划分：如，基于事件时间的滚动窗口\n\n\n\n\n\n\n\n\n\nstart&#x3D;按照数据的事件时间向下取窗口长度的整数倍\nend&#x3D;start+size\n比如开了一个10s的滚动窗口，第一条数据是857s，那么它属于[850s,860s)\n4）窗口的创建：当属于某个窗口的第一个元素到达，Flink就会创建一个窗口，\n5）窗口的销毁：当时间超过其结束时间+用户指定的允许延迟时间（Flink保证只删除基于时间的窗口，而不能删除其他类型的窗口，例如全局窗口）。\n6）窗口为什么左闭右开：属于窗口的最大时间戳&#x3D;end-1ms\n7）窗口什么时候触发：如基于事件时间的窗口 watermark&gt;&#x3D;end-1ms\n1.14.15 Exactly-Once的保证一般说的是端到端一致性，要考虑source和sink：\nSource：可重发\nFlink内部：Checkpoint机制（介绍Chandy-Lamport算法、barrier对齐）\nSink：幂等性 或 事务性 写入\n我们使用的Source和Sink主要是Kafka：\n作为source可以重发，由Flink维护offset，作为状态存储\n作为sink官方的实现类是基于两阶段提交，能保证写入的Exactly-Once\n如果下级存储不支持事务：\n具体实现是幂等写入，需要下级存储具有幂等性写入特性。\n比如结合HBase的rowkey的唯一性、数据的多版本，实现幂等\n1.14.16 Flink分布式快照的原理是什么Flink的容错机制的核心部分是制作分布式数据流和操作算子状态的一致性快照。这些快照充当一致性checkpoint，系统可以在发生故障时回滚。Flink用于制作这些快照的机制在”分布式数据流的轻量级异步快照”中进行了描述。它受到分布式快照的标准Chandy-Lamport算法的启发，专门针对Flink的执行模型而定制。\n{width&#x3D;”5.768055555555556in”height&#x3D;”1.7861111111111112in”}\nbarriers在数据流源处被注入并行数据流中。快照n的barriers被插入的位置（我们称之为Sn）是快照所包含的数据在数据源中最大位置。\n例如，在Apache Kafka中，此位置将是分区中最后一条记录的偏移量。将该位置Sn报告给checkpoint协调器（Flink的JobManager）。\n然后barriers向下游流动。当一个中间操作算子从其所有输入流中收到快照n的barriers时，它会为快照n发出barriers进入其所有输出流中。\n一旦sink操作算子（流式DAG的末端）从其所有输入流接收到barriersn，它就向checkpoint协调器确认快照n完成。\n在所有sink确认快照后，意味快照着已完成。一旦完成快照n，job将永远不再向数据源请求Sn之前的记录，因为此时这些记录（及其后续记录）将已经通过整个数据流拓扑，也即是已经被处理结束。\n1.14.17 Checkpoint的参数怎么设置的？1）间隔、语义： 1min~10min，3min，语义默认精准一次\n因为一些异常原因可能导致某些barrier无法向下游传递，造成job失败，对于一些时效性要求高、精准性要求不是特别严格的指标，可以设置为至少一次。\n2）超时 ： 参考间隔， 0.5~2倍之间， 建议0.5倍\n3）最小等待间隔：上一次ck结束 到 下一次ck开始之间的时间间隔，设置间隔的0.5倍\n4）设置保存ck：Retain\n5）失败次数：5\n6）Task重启策略（Failover）：\n固定延迟重启策略： 重试几次、每次间隔多久\n失败率重启策略： 重试次数、重试区间、重试间隔\n1.14.18 介绍一下Flink的CEP机制CEP全称为Complex Event Processing，复杂事件处理\nFlink CEP是在 Flink 中实现的复杂事件处理（CEP）库\nCEP 允许在无休止的事件流中检测事件模式，让我们有机会掌握数据中重要的部分\n一个或多个由简单事件构成的事件流通过一定的规则匹配，然后输出用户想得到的数据—— 满足规则的复杂事件\n1.14.19 Flink CEP 编程中当状态没有到达的时候会将数据保存在哪里？在流式处理中，CEP 当然是要支持 EventTime的，那么相对应的也要支持数据的迟到现象，也就是watermark的处理逻辑。CEP对未匹配成功的事件序列的处理，和迟到数据是类似的。在FlinkCEP的处理逻辑中，状态没有满足的和迟到的数据，都会存储在一个Map数据结构中，也就是说，如果我们限定判断事件序列的时长为5分钟，那么内存中就会存储5分钟的数据，这在我看来，也是对内存的极大损伤之一。\n1.14.20 Flink SQL的工作机制？通过Calcite对编写的 Sql 进行解析、验证、优化等操作。\n{width&#x3D;”3.75in”height&#x3D;”1.0743055555555556in”}\nBlink Planner与Calcite进行对接,对接流程如下：\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.527083333333333in”}\n1）在Table&#x2F;SQL 编写完成后，通过Calcite中的parse、validate、rel阶段，以及Blink额外添加的convert阶段,将其先转为Operation；\n2）通过Blink Planner的translateToRel、optimize、translateToExecNodeGraph和translateToPlan四个阶段，将Operation转换成DataStreamAPI的 Transformation；\n3）再经过StreamJraph -&gt; JobGraph -&gt;ExecutionGraph等一系列流程，SQL最终被提交到集群。\n1.14.21 FlinkSQL怎么对SQL语句进行优化的？会使用两个优化器:RBO(基于规则的优化器) 和 CBO(基于代价的优化器)\n1）RBO(基于规则的优化器)会将原有表达式裁剪掉，遍历一系列规则（Rule），只要满足条件就转换，生成最终的执行计划。一些常见的规则包括分区裁剪（PartitionPrune）、列裁剪、谓词下推（Predicate Pushdown）、投影下推（ProjectionPushdown）、聚合下推、limit下推、sort下推、常量折叠（ConstantFolding）、子查询内联转join等。\n2）CBO(基于代价的优化器)会将原有表达式保留，基于统计信息和代价模型，尝试探索生成等价关系表达式，最终取代价最小的执行计划。CBO的实现有两种模型，Volcano模型，Cascades模型。这两种模型思想很是相似，不同点在于Cascades模型一边遍历SQL逻辑树，一边优化，从而进一步裁剪掉一些执行计划。\n1.14.22 Flink提交流程、组件通讯、调度机制、任务执行、内存模型（重点）0.1 Flink提交流程（Yarn-Per-Job）\n**0.2 Flink通讯过程 **\n0.3 Task调度\n{width&#x3D;”5.176388888888889in”height&#x3D;”5.402777777777778in”}\n0.4 内存模型\n1.14.23 Flink优化、背压、数据倾斜（重点）1.14.24 Flink常见的维表Join方案1）预加载： open（）方法，查询维表，存储下来 &#x3D;&#x3D;》 定时查询\n2）热存储： 存在外部系统redis、hbase等\n缓存\n异步查询： 异步io功能\n3）广播维表\n4）Temporal join：外部存储，connector创建\n第2章 项目架构2.1 提高自信云上数据仓库解决方案：[https://www.aliyun.com/solution/datavexpo/datawarehouse]{.underline}\n{width&#x3D;”3.884027777777778in”height&#x3D;”4.625in”}\n{width&#x3D;”5.345138888888889in”height&#x3D;”2.6993055555555556in”}\n2.2 数仓概念数据仓库的输入数据源和输出系统分别是什么？\n输入系统：埋点产生的用户行为数据、JavaEE后台产生的业务数据、个别公司有爬虫数据。\n输出系统：报表系统、用户画像系统、推荐系统\n2.3 系统数据流程设计\n2.4 框架版本选型1）Apache：运维麻烦，组件间兼容性需要自己调研。（一般大厂使用，技术实力雄厚，有专业的运维人员）\n2）CDH6.3.2：国内使用最多的版本，但CM不开源，但其实对中、小公司使用来说没有影响（建议使用）10000美金一个节点CDP7.0\n3）HDP：开源，可以进行二次开发，但是没有CDH稳定，国内使用较少\n4）云服务选择\n\n\n\n\n\n\n\n\n\n（1）阿里云的EMR、MaxCompute、DataWorks\n（2）亚马逊云EMR\n（3）腾讯云EMR\n（4）华为云EMR\nApache框架版本\n+—————–+—————–+—————–+—————–+| 产品            | 旧版本          | 新版本          | 版本新增        |+—————–+—————–+—————–+—————–+| Hadoop          | 2.7.2           | 3.1.3           | HDFS的web端口号由500 ||                 |                 |                 | 70变为9870，    ||                 |                 |                 |                 ||                 |                 |                 | 客户端访问端口号9820&#x2F;80 ||                 |                 |                 | 20&#x2F;9000         |+—————–+—————–+—————–+—————–+| Zookeeper       | 3.4.10          | 3.5.7           |                 |+—————–+—————–+—————–+—————–+| Mysql           | 5.6.24          | 5.7.16          | ①原生json支持：不需要遍历 ||                 |                 |                 | 所有字符串、通过虚拟列的功能对 ||                 |                 |                 | json的数据进行索引 ||                 |                 |                 |                 ||                 |                 |                 |                 ||                 |                 |                 | ②多源复制：多主一从 ||                 |                 |                 |                 ||                 |                 |                 |                 ||                 |                 |                 | ③InnoDB优化：为inno ||                 |                 |                 | DB_buffer_poo ||                 |                 |                 | l_size、       ||                 |                 |                 |                 ||                 |                 |                 | innoDB_log_fi ||                 |                 |                 | le_size、innoDB ||                 |                 |                 | _flush_method ||                 |                 |                 | 提供了更加合适的默认值 |+—————–+—————–+—————–+—————–+| Hive            | 1.2.1           | 3.1.2           | （没有查到，查到的都是说不再支 ||                 |                 |                 | 持mr引擎）      |+—————–+—————–+—————–+—————–+| Flume           | 1.7.0           | 1.9.0           |                 |+—————–+—————–+—————–+—————–+| Kafka           | 0.11-0.2        | _2.11-2.4.1、2. | ①kafka         ||                 |                 | 8.0、3.0.0      | 0.9版本之前，offset保 ||                 |                 |                 | 存在Zookeeper中；从0 ||                 |                 |                 | .9版本开始，consumer ||                 |                 |                 | 自己维护了一个offset ||                 |                 |                 |                 ||                 |                 |                 |                 ||                 |                 |                 | ②允许使用者从最近的副本中获取 |+—————–+—————–+—————–+—————–+| Kafka Eagle     | 1.3.7           | 1.4.5           |                 |+—————–+—————–+—————–+—————–+| Azkaban         | 2.5.0           | 3.84.4          | 集成了给用户打电话的功能 |+—————–+—————–+—————–+—————–+| Spark           | 2.1.1           | 3.0.0           | 不支持scala     ||                 |                 |                 | 2.11.x，升级为2.12. ||                 |                 |                 | x               |+—————–+—————–+—————–+—————–+| Hbase           | 1.3.1           | 2.0.5           |                 |+—————–+—————–+—————–+—————–+| Phoenix         | 4.14.1          | 5.0.0           | 支持Apache      ||                 |                 |                 | HBase 2.0       |+—————–+—————–+—————–+—————–+| Redis           | 3.2.5           | 3.2.5           |                 |+—————–+—————–+—————–+—————–+| Canal           | 1.1.2           | 1.1.2           |                 |+—————–+—————–+—————–+—————–+| ElasticSearch+K | 6.3.1           | 6.3.1           |                 || ibana           |                 |                 |                 |+—————–+—————–+—————–+—————–+\nAzkaban、hive、kylin需要重新编译\n2.5 服务器选型服务器使用物理机还是云主机？\n1）机器成本考虑：\n（1）物理机：以128G内存，20核物理CPU，40线程，8THDD和2TSSD硬盘，单台报价4W出头，惠普品牌。一般物理机寿命5年左右。\n（2）云主机，以阿里云为例，差不多相同配置，每年5W\n2）运维成本考虑：\n（1）物理机：需要有专业的运维人员（1万*13个月）、电费（商业用户）、安装空调、场地\n（2）云主机：很多运维工作都由阿里云已经完成，运维相对较轻松\n3）企业选择\n（1）金融有钱公司选择阿里云（上海）\n（2）中小公司、为了融资上市，选择阿里云，拉到融资后买物理机。\n（3）有长期打算，资金比较足，选择物理机。\n2.6 集群规模20核物理CPU 40线程 * 7 &#x3D; 280线程\n内存128g * 7台 &#x3D; 896g （计算任务内存700g，其他安装框架需要内存）\n128m &#x3D;》1g内存\n&#x3D;》\n87g数据 、700g内存\n根据数据规模大家集群（在企业，干了三年 通常服务器集群 5-20台之间）\n\n  1         2         3       4       5       6    7    8       9       10  nn        nn        dn      dn      dn      dn   dn   dn      dn      dn                      rm      rm      nm      nm   nm   nm      nm      nm                      nm      nm                                                        zk      zk      zk                                                        kafka   kafka   kafka                                                        Flume   Flume   flume                      Hbase   Hbase   Hbase  hive      hive  mysql     mysql  spark     spark  Azkaban   Azkaban                           ES   ES                   \n\n1）消耗内存的分开；\n2）kafka 、zk 、flume 传输数据比较紧密的放在一起；\n3）客户端尽量放在一到两台服务器上，方便外部访问；\n4）有依赖关系的尽量放到同一台服务器（例如：Hive和Azkaban Executor）\n2.7 人员配置参考2.7.1 整体架构属于研发部&#x2F;技术部&#x2F;数据部，我们属于大数据组，其他还有后端项目组，前端组、测试组、UI组等。其他的还有产品部、运营部、人事部、财务部、行政部等。\n大数据开发工程师&#x3D;&gt;大数据组组长&#x3D;》项目经理&#x3D;&gt;部门经理&#x3D;》技术总监CTO\n2.7.2 你们部门的职级等级，晋升规则职级就分初级，中级，高级。晋升规则不一定，看公司效益和职位空缺。\n京东：T1、T2应届生；T3 14k左右 T4 18K左右 T5 24k-28k左右\n阿里：p5、p6、p7、p8\n字节：\n{width&#x3D;”4.191666666666666in”height&#x3D;”2.703472222222222in”}\n2.7.3 人员配置参考小型公司（1-3人左右）：组长1人，剩余组员无明确分工，并且可能兼顾javaEE和前端。\n中小型公司（3~6人左右）：组长1人，离线2人左右，实时1人左右（离线一般多于实时），组长兼顾和JavaEE、前端。\n中型公司（510人左右）：组长1人，离线35人左右（离线处理、数仓），实时2人左右，组长和技术大牛兼顾和javaEE、前端。\n中大型公司（1020人左右）：组长1人，离线510人（离线处理、数仓），实时5人左右，JavaEE1人左右（负责对接JavaEE业务），前端1人（有或者没有人单独负责前端）。（发展比较良好的中大型公司可能大数据部门已经细化拆分，分成多个大数据组，分别负责不同业务）\n上面只是参考配置，因为公司之间差异很大，例如ofo大数据部门只有5个人左右，因此根据所选公司规模确定一个合理范围，在面试前必须将这个人员配置考虑清楚，回答时要非常确定。\nIOS多少人 安卓多少人 前端多少人 JavaEE多少人 测试多少人\n（IOS、安卓） 1-2个人 前端3个人；JavaEE一般是大数据的1-1.5倍，测试：有的有，有的没有。1个左右。产品经理1个、产品助理1-2个，运营1-3个\n公司划分：\n\n\n\n\n\n\n\n\n\n0-50 小公司\n50-500 中等\n500-1000 大公司\n1000以上 大厂 领军的存在\n第3章 数仓分层3.1 数据仓库建模（绝对重点）3.1.1 建模工具是什么？PowerDesigner&#x2F;SQLYog&#x2F;EZDML\n3.1.2 ODS层（1）保持数据原貌不做任何修改，起到备份数据的作用。\n（2）数据采用压缩，减少磁盘存储空间（例如：原始数据100G，可以压缩到10G左右）\n（3）创建分区表，防止后续的全表扫描\n3.1.3 DWD层DWD层需构建维度模型，一般采用星型模型，呈现的状态一般为星座模型。\n维度建模一般按照以下四个步骤：\n选择业务过程→声明粒度→确认维度→确认事实\n（1）选择业务过程\n在业务系统中，如果业务表过多，挑选我们感兴趣的业务线，比如下单业务，支付业务，退款业务，物流业务，一条业务线对应一张事实表。如果小公司业务表比较少，建议选择所有业务线。\n（2）声明粒度\n数据粒度指数据仓库的数据中保存数据的细化程度或综合程度的级别。\n声明粒度意味着精确定义事实表中的一行数据表示什么，应该尽可能选择最小粒度，以此来应各种各样的需求。\n典型的粒度声明如下：\n订单当中的每个商品项作为下单事实表中的一行，粒度为每次\n每周的订单次数作为一行，粒度为每周。\n每月的订单次数作为一行，粒度为每月。\n如果在DWD层粒度就是每周或者每月，那么后续就没有办法统计细粒度的指标了。所有建议采用最小粒度。\n（3）确定维度\n维度的主要作用是描述业务是事实，主要表示的是”谁，何处，何时”等信息。例如：时间维度、用户维度、地区维度等常见维度。\n（4）确定事实\n此处的”事实”一词，指的是业务中的度量值，例如订单金额、下单次数等。\n在DWD层，以业务过程为建模驱动，基于每个具体业务过程的特点，构建最细粒度的明细层事实表。事实表可做适当的宽表化处理。\n通过以上步骤，结合本数仓的业务事实，得出业务总线矩阵表如下表所示。业务总线矩阵的原则，主要是根据维度表和事实表之间的关系，如果两者有关联则使用√标记。\n表 业务总线矩阵表\n\n           时间   用户   地区   商品   优惠券   活动   编码   度量值\n\n  订单         √      √      √                      √             件数&#x2F;金额  订单详情     √             √      √                             件数&#x2F;金额  支付         √             √                                    次数&#x2F;金额  加购         √      √             √                             件数&#x2F;金额  收藏         √      √             √                             个数  评价         √      √             √                             个数  退款         √      √             √                             件数&#x2F;金额  优惠券领用   √      √                    √                      个数\n\n根据维度建模中的星型模型思想，将维度进行退化。例如下图所示：地区表和省份表退化为地区维度表，商品表、品类表、spu表、商品三级分类、商品二级分类、商品一级分类表退化为商品维度表，活动信息表和活动规则表退化为活动维度表。\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.363888888888889in”}\n至此，数仓的维度建模已经完毕，DWS、DWT和ADS和维度建模已经没有关系了。\nDWS和DWT都是建宽表，宽表都是按照主题去建。主题相当于观察问题的角度。对应着维度表。\n3.1.4 DWS层DWS层统计各个主题对象的当天行为，服务于DWT层的主题宽表。如图所示，DWS层的宽表字段，是站在不同维度的视角去看事实表，重点关注事实表的度量值，通过与之关联的事实表，获得不同的事实表的度量值。\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.3340277777777776in”}\n3.1.5 DWT层以分析的主题对象为建模驱动，基于上层的应用和产品的指标需求，构建主题对象的全量宽表。\nDWT层主题宽表都记录什么字段？\n如图所示，每个维度关联的不同事实表度量值以及首次、末次时间、累积至今的度量值、累积某个时间段的度量值。\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.3625in”}\n3.1.6 ADS层分别对设备主题、会员主题、商品主题和营销主题进行指标分析，其中营销主题是用户主题和商品主题的跨主题分析案例\n3.2 ODS层做了哪些事？1）保持数据原貌，不做任何修改\n2）压缩采用LZO，压缩比是100g数据压缩完10g左右。\n3）创建分区表\n3.3 DWD层做了哪些事？3.3.1 数据清洗\n\n\n\n\n\n\n\n\n（1）空值去除\n（2）过滤核心字段无意义的数据，比如订单表中订单id为null，支付表中支付id为空\n（3）将用户行为宽表和业务表进行数据一致性处理\nselect case when a is null then b else a end as JZR,\n…\nfrom A\n3.3.2 清洗的手段HQL、MR、SparkSQL、Kettle、Python（项目中采用sql进行清除）\n3.3.3 清洗掉多少数据算合理1万条数据清洗掉1条。\n3.3.4 脱敏\n\n\n\n\n\n\n\n\n对手机号、身份证号等敏感数据脱敏\n3.3.5 维度退化\n\n\n\n\n\n\n\n\n对业务数据传过来的表进行维度退化和降维。（商品一级二级三级、省市县、年月日）\n商品表、spu表、品类表、商品一级分类、二级分类、三级分类&#x3D;》商品表\n省份表、地区表&#x3D;》地区表\n3.3.6 压缩LZO3.3.7 列式存储parquet3.4 DWS层做了哪些事？3.4.1 DWS层有6张宽表（处理100-200个指标 70%以上的需求）具体宽表名称：用户行为宽表，商品宽表，访客宽表、活动宽表、优惠卷、地区表等。\n3.4.2 哪个宽表最宽？大概有多少个字段？最宽的是用户行为宽表。大概有60-100个字段\n3.4.3 具体用户行为宽表字段名称评论、打赏、收藏、关注–商品、关注–人、点赞、分享、好价爆料、文章发布、活跃、签到、补签卡、幸运屋、礼品、金币、电商点击、gmv\n\n\n\n\n\n\n\n\n\nCREATE TABLE app_usr_interact(\nstat_dt date COMMENT ‘互动日期’,\nuser_id string COMMENT ‘用户id’,\nnickname string COMMENT ‘用户昵称’,\nregister_date string COMMENT ‘注册日期’,\nregister_from string COMMENT ‘注册来源’,\nremark string COMMENT ‘细分渠道’,\nprovince string COMMENT ‘注册省份’,\npl_cnt bigint COMMENT ‘评论次数’,\nds_cnt bigint COMMENT ‘打赏次数’,\nsc_add bigint COMMENT ‘添加收藏’,\nsc_cancel bigint COMMENT ‘取消收藏’,\ngzg_add bigint COMMENT ‘关注商品’,\ngzg_cancel bigint COMMENT ‘取消关注商品’,\ngzp_add bigint COMMENT ‘关注人’,\ngzp_cancel bigint COMMENT ‘取消关注人’,\nbuzhi_cnt bigint COMMENT ‘点不值次数’,\nzhi_cnt bigint COMMENT ‘点值次数’,\nzan_cnt bigint COMMENT ‘点赞次数’,\nshare_cnts bigint COMMENT ‘分享次数’,\nbl_cnt bigint COMMENT ‘爆料数’,\nfb_cnt bigint COMMENT ‘好价发布数’,\nonline_cnt bigint COMMENT ‘活跃次数’,\ncheckin_cnt bigint COMMENT ‘签到次数’,\nfix_checkin bigint COMMENT ‘补签次数’,\nhouse_point bigint COMMENT ‘幸运屋金币抽奖次数’,\nhouse_gold bigint COMMENT ‘幸运屋积分抽奖次数’,\npack_cnt bigint COMMENT ‘礼品兑换次数’,\ngold_add bigint COMMENT ‘获取金币’,\ngold_cancel bigint COMMENT ‘支出金币’,\nsurplus_gold bigint COMMENT ‘剩余金币’,\nevent bigint COMMENT ‘电商点击次数’,\ngmv_amount bigint COMMENT ‘gmv’,\ngmv_sales bigint COMMENT ‘订单数’)\nPARTITIONED BY ( dt string)\n3.4.4 哪张表数据量最多用户行为宽表：\ndws &#x3D;》 6张\n100g &#x3D;》 40g &#x2F; 6 &#x3D; 6.7 g 2* 3倍 &#x3D; 15g &#x3D;》 1500万条\n3.5 ADS层分析过哪些指标3.5.1 分析过的指标（一分钟至少说出30个指标）日活、月活、周活、留存、留存率、新增（日、周、年）、转化率、流失、回流、七天内连续3天登录（点赞、收藏、评价、购买、加购、下单、活动）、连续3周（月）登录、GMV、复购率、复购率排行、点赞、评论、收藏、领优惠卷人数、使用优惠卷人数、沉默、值不值得买、退款人数、退款率topn 热门商品\n产品经理最关心的：留转G复活\n{width&#x3D;”5.768055555555556in”height&#x3D;”6.031944444444444in”}\n3.5.2 留转G复活指标（1）活跃\n\n\n\n\n\n\n\n\n\n日活：100万 ；周活是日活的1.1-1.3倍；月活：是日活的2-3倍 300万\n总注册的用户多少？1000万-3000万之间\n渠道来源：app 公众号 抖音 百度 36 头条 地推\n（2）GMV\n\n\n\n\n\n\n\n\n\nGMV：每天 10万订单 （50 – 100元） 500万-1000万\n10%-20% 100万-200万（人员：程序员、人事、行政、财务、房租、收电费）\n（3）复购率\n\n\n\n\n\n\n\n\n\n某日常商品复购；（手纸、面膜、牙膏）10%-20%\n电脑、显示器、手表 1%\n（4）转化率\n商品详情 &#x3D;》 加购物车 &#x3D;》下单 &#x3D;》 支付\n5%-10% 60-70% 90%-95%\n（5）留存率\n1&#x2F;2&#x2F;3、周留存、月留存\n搞活动： 10-20%\n3.5.3 哪个商品卖的好？面膜、手纸，每天销售5000个\n3.6 ADS层手写指标3.6.1 如何分析用户活跃？在启动日志中统计不同设备id出现次数。去重\n3.6.2 如何分析用户新增？vivo用活跃用户表 left join 用户新增表，用户新增表中mid为空的即为用户新增。\n3.6.3 如何分析用户1天留存？留存用户&#x3D;前一天新增 join 今天活跃\n用户留存率&#x3D;留存用户&#x2F;前一天新增\n3.6.4 如何分析沉默用户？（登录时间为7天前，且只出现过一次）\n按照设备id对日活表分组，登录次数为1，且是在一周前登录。\n3.6.5 如何分析本周回流用户？本周活跃left join本周新增 leftjoin上周活跃，且本周新增id和上周活跃id都为null\n3.6.6 如何分析流失用户？（登录时间为7天前）\n按照设备id对日活表分组，且七天内没有登录过。\n3.6.7 如何分析最近连续3周活跃用户数？按照设备id对周活进行分组，统计次数大于3次。\n3.6.8 如何分析最近七天内连续三天活跃用户数？1）查询出最近7天的活跃用户，并对用户活跃日期进行排名\n2）计算用户活跃日期及排名之间的差值\n3）对同用户及差值分组，统计差值个数\n4）将差值相同个数大于等于3的数据取出，然后去重(去的是什么重???)，即为连续3天及以上活跃的用户\n7天连续收藏、点赞、购买、加购、付款、浏览、商品点击、退货\n1个月连续7天\n连续两周：\n3.7 分析过最难的指标3.7.1 最近连续3周活跃用户\n3.7.2 最近7天连续3天活跃用户数\n3.7.3 运费分摊3.7.4 城市备注第4章 生产经验—业务4.1 电商常识4.1.1 SKU和SPU\n\n\n\n\n\n\n\n\nSKU：一台银色、128G内存的、支持联通网络的iPhoneX\nSPU：iPhoneX\nTm_id：品牌Id苹果，包括IPHONE，耳机，MAC等\n4.1.2 订单表跟订单详情表区别？订单表的订单状态会变化，订单详情表不会，因为没有订单状态。\n订单表记录user_id，订单id订单编号，订单的总金额order_status，支付方式，订单状态等。\n订单详情表记录user_id，商品sku_id，具体的商品信息（商品名称sku_name，价格order_price，数量sku_num）\n4.2 埋点行为数据基本格式（基本字段）我们要收集和分析的数据主要包括页面数据、事件数据、曝光数据、启动数据和错误数据。\n4.2.1 页面页面数据主要记录一个页面的用户访问情况，包括访问时间、停留时间、页面路径等信息。\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.2993055555555557in”}\n所有页面id如下\n\n\n\n\n\n\n\n\n\nhome(“首页”),\ncategory(“分类页”),\ndiscovery(“发现页”),\ntop_n(“热门排行”),\nfavor(“收藏页”),\nsearch(“搜索页”),\ngood_list(“商品列表页”),\ngood_detail(“商品详情”),\ngood_spec(“商品规格”),\ncomment(“评价”),\ncomment_done(“评价完成”),\ncomment_list(“评价列表”),\ncart(“购物车”),\ntrade(“下单结算”),\npayment(“支付页面”),\npayment_done(“支付完成”),\norders_all(“全部订单”),\norders_unpaid(“订单待支付”),\norders_undelivered(“订单待发货”),\norders_unreceipted(“订单待收货”),\norders_wait_comment(“订单待评价”),\nmine(“我的”),\nactivity(“活动”),\nlogin(“登录”),\nregister(“注册”);\n所有页面对象类型如下：\n\n\n\n\n\n\n\n\n\nsku_id(“商品skuId”),\nkeyword(“搜索关键词”),\nsku_ids(“多个商品skuId”),\nactivity_id(“活动id”),\ncoupon_id(“购物券id”);\n所有来源类型如下：\n\n\n\n\n\n\n\n\n\npromotion(“商品推广”),\nrecommend(“算法推荐商品”),\nquery(“查询结果商品”),\nactivity(“促销活动”);\n4.2.2 事件事件数据主要记录应用内一个具体操作行为，包括操作类型、操作对象、操作对象描述等信息。\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.188888888888889in”}\n所有动作类型如下：\n\n\n\n\n\n\n\n\n\nfavor_add(“添加收藏”),\nfavor_canel(“取消收藏”),\ncart_add(“添加购物车”),\ncart_remove(“删除购物车”),\ncart_add_num(“增加购物车商品数量”),\ncart_minus_num(“减少购物车商品数量”),\ntrade_add_address(“增加收货地址”),\nget_coupon(“领取优惠券”);\n注：对于下单、支付等业务数据，可从业务数据库获取。\n所有动作目标类型如下：\n\n\n\n\n\n\n\n\n\nsku_id(“商品”),\ncoupon_id(“购物券”);\n4.2.3 曝光曝光数据主要记录页面所曝光的内容，包括曝光对象，曝光类型等信息。\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.0194444444444444in”}\n所有曝光类型如下：\n\n\n\n\n\n\n\n\n\npromotion(“商品推广”),recommend(“算法推荐商品”),query(“查询结果商品”),activity(“促销活动”);\n所有曝光对象类型如下：\n\n\n\n\n\n\n\n\n\nsku_id(“商品skuId”),\nactivity_id(“活动id”);\n4.2.4 启动启动数据记录应用的启动信息。\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.0548611111111112in”}\n所有启动入口类型如下：\n\n\n\n\n\n\n\n\n\nicon(“图标”),notification(“通知”),install(“安装后启动”);\n4.2.5 错误错误数据记录应用使用过程中的错误信息，包括错误编号及错误信息。\n4.2.6 埋点数据日志格式我们的日志结构大致可分为两类，一是普通页面埋点日志，二是启动日志。\n普通页面日志结构如下，每条日志包含了，当前页面的页面信息，所有事件（动作）、所有曝光信息以及错误信息。除此之外，还包含了一系列公共信息，包括设备信息，地理位置，应用信息等，即下边的common字段。\n\n\n\n\n\n\n\n\n\n{\n“common”: { – 公共信息\n“ar”: “230000”, – 地区编码\n“ba”: “iPhone”, – 手机品牌\n“ch”: “Appstore”, – 渠道\n“md”: “iPhone 8”, – 手机型号\n“mid”: “YXfhjAYH6As2z9Iq”, – 设备id\n“os”: “iOS 13.2.9”, – 操作系统\n“uid”: “485”, – 会员id\n“vc”: “v2.1.134” – app版本号\n},\n“actions”: [ –动作(事件)\n{\n“action_id”: “favor_add”, –动作id\n“item”: “3”, –目标id\n“item_type”: “sku_id”, –目标类型\n“ts”: 1585744376605 –动作时间戳\n}\n]，\n“displays”: [\n{\n“displayType”: “query”, – 曝光类型\n“item”: “3”, – 曝光对象id\n“item_type”: “sku_id”, – 曝光对象类型\n“order”: 1 –出现顺序\n},\n{\n“displayType”: “promotion”,\n“item”: “6”,\n“item_type”: “sku_id”,\n“order”: 2\n},\n{\n“displayType”: “promotion”,\n“item”: “9”,\n“item_type”: “sku_id”,\n“order”: 3\n},\n{\n“displayType”: “recommend”,\n“item”: “6”,\n“item_type”: “sku_id”,\n“order”: 4\n},\n{\n“displayType”: “query “,\n“item”: “6”,\n“item_type”: “sku_id”,\n“order”: 5\n}\n],\n“page”: { –页面信息\n“during_time”: 7648, – 持续时间毫秒\n“item”: “3”, – 目标id\n“item_type”: “sku_id”, – 目标类型\n“last_page_id”: “login”, – 上页类型\n“page_id”: “good_detail”, – 页面ID\n“sourceType”: “promotion” – 来源类型\n},\n“err”:{ –错误\n“error_code”: “1234”, –错误码\n“msg”: “***********” –错误信息\n},\n“ts”: 1585744374423 –跳入时间戳\n}\n启动日志结构相对简单，主要包含公共信息，启动信息和错误信息。\n\n\n\n\n\n\n\n\n\n{\n“common”: {\n“ar”: “370000”,\n“ba”: “Honor”,\n“ch”: “wandoujia”,\n“md”: “Honor 20s”,\n“mid”: “eQF5boERMJFOujcp”,\n“os”: “Android 11.0”,\n“uid”: “76”,\n“vc”: “v2.1.134”\n},\n“start”: {\n“entry”: “icon”, –icon手机图标 notice 通知 install 安装后启动\n“loading_time”: 18803, –启动加载时间\n“open_ad_id”: 7, –广告页ID\n“open_ad_ms”: 3449, – 广告总共播放时间\n“open_ad_skip_ms”: 1989 – 用户跳过广告时点\n},\n“err”:{ –错误\n“error_code”: “1234”, –错误码\n“msg”: “***********” –错误信息\n},\n“ts”: 1585744304000\n}\n4.3 电商业务流程1）记住表与表之间的关系\n2）每个表记住2-3个字段\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.2583333333333333in”}\n4.4 维度表和事实表（重点）4.4.1 维度表维度表：一般是对事实的描述信息。每一张维表对应现实世界中的一个对象或者概念。例如：用户、商品、日期、地区等。\n4.4.2 事实表事实表中的每行数据代表一个业务事件（下单、支付、退款、评价等）。”事实”这个术语表示的是业务事件的度量值（可统计次数、个数、件数、金额等），例如，订单事件中的下单金额。\n每一个事实表的行包括：具有可加性的数值型的度量值、与维表相连接的外键、通常具有两个和两个以上的外键、外键之间表示维表之间多对多的关系。\n1）事务型事实表\n以每个事务或事件为单位，例如一个销售订单记录，一笔支付记录等，作为事实表里的一行数据。一旦事务被提交，事实表数据被插入，数据就不再进行更改，其更新方式为增量更新。\n2）周期型快照事实表\n周期型快照事实表中不会保留所有数据，只保留固定时间间隔的数据，例如每天或者每月的销售额，或每月的账户余额等。\n3）累积型快照事实表\n累计快照事实表用于跟踪业务事实的变化。例如，数据仓库中可能需要累积或者存储订单从下订单开始，到订单商品被打包、运输、和签收的各个业务阶段的时间点数据来跟踪订单声明周期的进展情况。当这个业务过程进行时，事实表的记录也要不断更新。\n\n  订单id   用户id   下单时间   打包时间   发货时间   签收时间   订单金额                            3-8            3-8            3-9            3-10           \n\n4.5 同步策略（重点）{width&#x3D;”5.768055555555556in”height&#x3D;”2.9659722222222222in”}\n4.6 关系型数据库范式理论（ER建模）1NF：属性不可再分割（例如不能存在5台电脑的属性，坏处：表都没法用）\n2NF：不能存在部分函数依赖（例如主键（学号+课名）–&gt;成绩，姓名，但学号–》姓名，所以姓名部分依赖于主键（学号+课名），所以要去除，坏处：数据冗余）\n3NF：不能存在传递函数依赖（学号–》宿舍种类–》价钱，坏处：数据冗余和增删异常）\nMySQL关系模型：关系模型主要应用与OLTP系统中，为了保证数据的一致性以及避免冗余，所以大部分业务系统的表都是遵循第三范式的。\nHive维度模型：维度模型主要应用于OLAP系统中，因为关系模型虽然冗余少，但是在大规模数据，跨表分析统计查询过程中，会造成多表关联，这会大大降低执行效率。所以HIVE把相关各种表整理成两种：事实表和维度表两种。所有维度表围绕着事实表进行解释。\n4.7 数据模型雪花模型、星型模型和星座模型\n（在维度建模的基础上又分为三种模型：星型模型、雪花模型、星座模型）\n星型模型（一级维度表），雪花（多级维度），星座模型（星型模型+多个事实表）\n4.8 拉链表（重点）拉链表处理的业务场景：主要处理缓慢变化维的业务场景。（用户表、订单表）\n4.9 即席查询数据仓库{width&#x3D;”5.768055555555556in”height&#x3D;”3.2430555555555554in”}\nKylin: T+1\nImpala: CDH\nPresto: Apache版本框架\n4.10 数据仓库每天跑多少张表，大概什么时候运行，运行多久？基本一个项目建一个库，表格个数为初始的原始数据表格加上统计结果表格的总数。（一般70-100张表格）\n用户行为5张；业务数据33张表 &#x3D;》ods34 &#x3D;》dwd&#x3D;&gt;32张&#x3D;》dws6张宽表&#x3D;&gt;dwt6张宽表&#x3D;&gt;ads&#x3D;》30张 &#x3D;》108张\n每天0：10开始运行。&#x3D;》sqoop 20-30分钟：1点：&#x3D;》 5-6个小时运行完指标\n所有离线数据报表控制在8小时之内\n大数据实时处理部分控制在5分钟之内。（分钟级别、秒级别）\n如果是实时推荐系统，需要秒级响应\n4.11 活动的话，数据量会增加多少？怎么解决？日活增加50%，GMV增加多少20%。（留转G复活）情人节，促销手纸。\n集群资源都留有预量。11.11，6.18，数据量过大，提前动态增加服务器。\n4.12 并发峰值多少？大概哪个时间点？ 高峰期晚上7-12点。Kafka里面20m&#x2F;s 2万&#x2F;s 并发峰值在1-2万人\n4.13 数仓中使用的哪种文件存储格式常用的包括：textFile，ORC，Parquet，一般企业里使用ORC或者Parquet，因为是列式存储，且压缩比非常高，所以相比于textFile，查询速度快，占用硬盘空间少\n4.14 哪张表最费时间，有没有优化用户行为宽表，数据量过大。数据倾斜的相关优化手段。（hadoop、hive、spark）\n哪两张表和哪两张表发生数据倾斜：\n11.11 数据量大 按照地区统计销售额\n订单表（10万* 50倍 * 1k &#x3D;500万 1k&#x3D;5g ） 和 订单详情（50万 50倍 *1k&#x3D;2500万1k&#x3D;25g） 用户、商品 、地区（县）\n数据倾斜时，执行多久 2-5小时\n采取办法：解决数据倾斜 将key打散 自定义分区\n采用解决数据倾斜办法：执行40分钟搞定\n4.14 哪张表数据量最大，是多少用户行为数据：100g(1亿条)&#x2F;5 &#x3D; 2千万 * 2-3倍动作、曝光、页面、故障、启动\n业务数据：10万人下单，详情（50-100万条） -》加购-》下单-》支付-》物流\n4.15 用什么工具做权限管理Ranger或Sentry（用户认证kerberos（张三、李四、王五）&#x3D;&gt;表级别权限（张三、李四）、字段级别权限（李四））\n4.16 数仓当中数据多久删除一次1）部分公司永久不删\n2）有一年、两年”删除”一次的，这里面说的删除是，先将超时数据压缩下载到单独安装的磁盘上。然后删除集群上数据。很少有公司不备份数据，直接删除的。\n第5章 生产经验–测试上线相关5.1 测试相关5.1.1 公司有多少台测试服务器？测试服务器一般三台\n5.1.2 测试环境什么样？有钱的公司和生产环境电脑配置一样。\n一般公司测试环境的配置是生产的一半。\n5.1.3 测试数据哪来的？一部分自己写Java程序自己造（更灵活），一部分从生产环境上取一部分（更真实）。\n5.1.4 如何保证写的sql正确性（重点）先在mysql的业务库里面把结果计算出来；在给你在ads层计算的结果进行比较；\n需要造一些特定的测试数据，测试。\n从生产环境抓取一部分数据，数据有多少你是知道的，运算完毕应该符合你的预期。\n离线数据和实时数据分析的结果比较。（日活1万 实时10100），倾向取离线。\n5.1.5 测试之后如何上线？大公司：上线的时候，将脚本打包，提交git。先发邮件抄送经理和总监，运维。运维负责上线。\n小公司：跟项目经理说一下，项目经理技术把关，项目经理通过了就可以上线了。风险意识。\n所谓的上线就是编写脚本，并在azkaban中进行作业调度。\n5.2 项目实际工作流程以下是活跃用户需求的整体开发流程。\n产品经理负责收集需求：需求来源与客户反馈、老板的意见\n第1步：确定指标的业务口径\n由产品经理主导，找到提出该指标的运营负责人沟通。首先要问清楚指标是怎么定义的，比如活跃用户是指启动过APP的用户。设备id还是用户id。\n邮件&#x2F;需求文档-》不要口头\n第2步：需求评审\n由产品经理主导设计原型，对于活跃主题，我们最终要展示的是最近n天的活跃用户数变化趋势，效果如下图所示。此处大数据开发工程师、后端开发工程师、前端开发工程师一同参与，一起说明整个功能的价值和详细的操作流程，确保大家理解的一致。\n{width&#x3D;”5.768055555555556in”height&#x3D;”1.7236111111111112in”}\n第3步：大数据开发\n大数据开发工程师，通过数据同步的工具如Flume、Sqoop等将数据同步到ODS层，然后就是一层一层的通过SQL计算到DWD、DWS层，最后形成可为应用直接服务的数据填充到ADS层。\n第4步：后端开发\n后端工程师负责，为大数据工程师提供业务数据接口；\n同时还负责读取ADS层分析后，写入MySQL中的数据。\n第5步：前端开发\n前端工程师负责，前端埋点。\n对分析后的结果数据进行可视化展示。\n第6步：联调\n此时大数据开发工程师、前端开发工程师、后端开发工程师都要参与进来。此时会要求大数据开发工程师基于历史的数据执行计算任务，大数据开发工程师承担数据准确性的校验。前后端解决用户操作的相关BUG保证不出现低级的问题完成自测。\n第7步：测试\n测试工程师对整个大数据系统进行测试。测试的手段包括，边界值、等价类等。\n提交测试异常的软件有：禅道、bugzila（测试人员记录测试问题1.0，输入是什么，结果是什么，跟预期不一样-&gt;需要开发人员解释，是一个bug，下一个版本解决1.1-&gt;测试人员再测试。测试1.1ok-&gt;测试经理关闭bug）\n1周开发写代码 &#x3D;》2周测试时间\n第8步：上线\n运维工程师会配合我们的前后端开发工程师更新最新的版本到服务器。此时产品经理要找到该指标的负责人长期跟进指标的准确性。重要的指标还要每过一个周期内部再次验证，从而保证数据的准确性。\n5.3 项目中实现一个需求大概多长时间刚入职第一个需求大概需要7天左右。\n对业务熟悉后，平均一天一个需求。\n影响时间的因素：测试服务器购买获取环境准备、对业务熟悉、开会讨论需求、表的权限申请、测试等。新员工培训（公司规章制度、代码规范）\n5.4 项目在3年内迭代次数，每一个项目具体是如何迭代的。公司版本迭代多久一次，迭代到哪个版本瀑布式开发、敏捷开发\n差不多一个月会迭代一次。每月都有节日（元旦、春节、情人节、3.8妇女节、端午节、618、国庆、中秋、1111&#x2F;6.1&#x2F;5.1、生日、周末）新产品、新区域\n就产品或我们提出优化需求，然后评估时间。每周我们都会开会做下周计划和本周总结。（日报、周报、月报、季度报、年报）需求1周的时间，周三一定完成。周四周五（帮同事写代码、自己学习工作额外的技术）\n5.1.2\n5是大版本号：必须是重大升级\n1：一般是核心模块变动\n2：一般版本变化\n5.5 项目开发中每天做什么事1）新需求（活动、优化、新产品、新市场）。 60%\n2）故障分析：数仓的任何步骤出现问题，需要查看问题，比如日活，月活下降或快速上升等。20%\n3）新技术的预言（比如湖仓一体 数据湖 doris 实时数据质量监控）10%\n4）其临时任务 10%\n5）晨会-》10做操-》讨论中午吃什么-》12点出去吃1点-》睡到2点-》3点茶歇水果-》晚上吃啥-》吃加班餐-》开会-》晚上6点吃饭-》7点开始干活-10点-》11点\n5.6 实时项目数据计算5.6.1 跑实时任务，怎么分配内存和CPU资源128m数据对应1g内存\n1个Kafka分区对应1个CPU\n5.6.2 跑实时任务，每天数据量多少？用户行为：实时任务用到了用户行为多少张表（20g） 100g&#x2F;5张表\n业务数据：实时任务用到了业务数据多少张表（34m） 1g&#x2F;30张表\n活动、风控、销售、流量\n第6章 生产经验—技术6.1 可视化报表工具Echarts（百度开源）、Kibana（开源）、Tableau（功能强大的收费软件）、Superset（功能一般免费）、QuickBI（阿里云收费的离线）、DataV（阿里云收费的实时）suga（百度，收费）\n6.2 集群监控工具Zabbix+ Grafana Prometheus&amp;Grafana监控 睿象云\n6.3 项目中遇到的问题怎么解决的（重点*****）Shell 中Flume停止脚本\nHadoop宕机\nHadoop解决数据倾斜方法\n集群资源分配参数（项目中遇到的问题）\nHDFS小文件处理\nHadoop优化\nFlume挂掉\nFlume优化\nKafka挂掉\nKafka丢失\nKafka数据重复\nKafka消息数据积压\nKafka优化\nKafka单条日志传输大小\n自定义UDF、UDTF函数\nHive优化\nHive解决数据倾斜方法\n7天内连续3次活跃\n1 7 30指标\n分摊\n备注\nSqoop空值、一致性、数据倾斜\nAzkaban任务挂了怎么办？\nAzkaban故障报警\nSpark数据倾斜\nSpark优化\nSparkStreaming精确一次性消费\nFlink 数据倾斜\nFlink水位线\nFlink反压\nFlink处理函数\nFlink SQL\nFlink多流join\n6.4 Linux+Shell+Hadoop+ZK+Flume+kafka+Hive+Sqoop+Azkaban那些事{width&#x3D;”5.768055555555556in”height&#x3D;”2.21875in”}\n第7章 生产经验—热点问题7.1 元数据管理（Atlas血缘系统）insert into table ads_user\nselect id, name from dwt_user\n依赖关系能够做到：表级别和字段级别\n用处：作业执行失败，评估他的影响范围。 主要用于表比较多的公司。\n版本问题：\n\n\n\n\n\n\n\n\n\n0.84版本：2019-06-21\n2.0版本：2019-05-13\n框架版本：\nApache 0.84 2.0 2.1\nCDH 2.0\n7.2 数据质量监控（Griffin）7.2.1 监控原则1）单表数据量监控\n一张表的记录数在一个已知的范围内，或者上下浮动不会超过某个阈值\n\nSQL结果：var 数据量 &#x3D; select count（*）from 表 where 时间等过滤条件\n\n报警触发条件设置：如果数据量不在[数值下限, 数值上限]， 则触发报警\n\n同比增加：如果((本周的数据量 -上周的数据量)&#x2F;上周的数据量*100)不在 [比例下线，比例上限]，则触发报警\n\n环比增加：如果((今天的数据量 -昨天的数据量)&#x2F;昨天的数据量*100)不在 [比例下线，比例上限]，则触发报警\n\n报警触发条件设置一定要有。如果没有配置的阈值，不能做监控\n\n\n\n\n\n\n\n\n\n\n\n日活、周活、月活、留存（日周月）、转化率（日、周、月）GMV（日、周、月）\n复购率（日周月） 30%\n2）单表空值检测\n某个字段为空的记录数在一个范围内，或者占总量的百分比在某个阈值范围内\n\n目标字段：选择要监控的字段，不能选”无”\n\nSQL结果：var 异常数据量 &#x3D; select count(*) from 表 where 目标字段 isnull\n\n单次检测：如果（异常数据量）不在[数值下限, 数值上限]，则触发报警\n\n\n3）单表重复值检测\n一个或多个字段是否满足某些规则\n\n目标字段：第一步先正常统计条数；select count(*) form 表；\n\n第二步，去重统计；select count(*) from 表 group by 某个字段\n\n第一步的值和第二步不的值做减法，看是否在上下线阀值之内\n\n单次检测：如果（异常数据量）不在[数值下限, 数值上限]， 则触发报警\n\n\n4）单表值域检测\n一个或多个字段没有重复记录\n\n目标字段：选择要监控的字段，支持多选\n\n检测规则：填写”目标字段”要满足的条件。其中$1表示第一个目标字段，$2表示第二个目标字段，以此类推。上图中的”检测规则”经过渲染后变为”delivery_fee&#x3D; delivery_fee_base+delivery_fee_extra”\n\n阈值配置与”空值检测”相同\n\n\n5）跨表数据量对比\n主要针对同步流程，监控两张表的数据量是否一致\n\nSQL结果：count（本表） - count（关联表）\n\n阈值配置与”空值检测”相同\n\n\n7.2.2 数据质量实现7.3 权限管理（Ranger）7.4 数据治理包括：数据质量管理、元数据管理、权限管理（ranger sentry）、数仓\nCDH cloudmanager-》sentry； HDP ambari&#x3D;&gt;ranger\n2019年下半年国家出了一本白皮书，要求给政府做的数仓项目，要具备如下功能：\n数据治理是一个复杂的系统工程，涉及到企业和单位多个领域，既要做好顶层设计，又要解决好统一标准、统一流程、统一管理体系等问题，同时也要解决好数据采集、数据清洗、数据对接和应用集成等相关问题。\n数据治理实施要点主要包含数据规划、制定数据标准、整理数据、搭建数据管理工具、构建运维体系及推广贯标六大部分，其中数据规划是纲领、制定数据标准是基础、整理数据是过程、搭建数据管理工具是技术手段、构建运维体系是前提，推广贯标是持续保障。\n{width&#x3D;”3.09375in”height&#x3D;”2.1902777777777778in”}\n7.5 数据中台[https://mp.weixin.qq.com/s/nXI0nSSOneteIClA7dming]{.underline}\n7.5.1 什么是中台？在传统IT企业，项目的物理结构是什么样的呢？无论项目内部的如何复杂，都可分为”前台”和”后台”这两部分。\n什么是前台？\n首先，这里所说的”前台”和”前端”并不是一回事。所谓前台即包括各种和用户直接交互的界面，比如web页面，手机app；也包括服务端各种实时响应用户请求的业务逻辑，比如商品查询、订单系统等等。\n什么是后台？\n后台并不直接面向用户，而是面向运营人员的配置管理系统，比如商品管理、物流管理、结算管理。后台为前台提供了一些简单的配置。\n{width&#x3D;”2.441666666666667in”height&#x3D;”2.5625in”}\n7.5.2 传统项目痛点痛点：重复造轮子。\n{width&#x3D;”3.013888888888889in”height&#x3D;”2.9479166666666665in”}\n7.5.3 各家中台1）SuperCell公司\n{width&#x3D;”3.441666666666667in”height&#x3D;”1.6576388888888889in”}\n2）阿里巴巴提出了”大中台，小前台”的战略\n{width&#x3D;”3.782638888888889in”height&#x3D;”2.422222222222222in”}\n3）华为提出了”平台炮火支撑精兵作战”的战略\n{width&#x3D;”3.7680555555555557in”height&#x3D;”2.442361111111111in”}\n7.5.4 中台具体划分1）业务中台\n{width&#x3D;”2.8125in”height&#x3D;”1.6979166666666667in”}\n2）技术中台\n{width&#x3D;”2.8541666666666665in”height&#x3D;”1.7430555555555556in”}\n3）数据中台\n{width&#x3D;”2.7395833333333335in”height&#x3D;”1.5465277777777777in”}\n4）算法中台\n{width&#x3D;”2.69375in”height&#x3D;”1.6736111111111112in”}\n7.5.5 中台使用场景1）从0到1的阶段，没有必要搭建中台。\n从0到1的创业型公司，首要目的是生存下去，以最快的速度打造出产品，证明自身的市场价值。\n这个时候，让项目野蛮生长才是最好的选择。如果不慌不忙地先去搭建中台，恐怕中台还没搭建好，公司早就饿死了。\n2）从1到N的阶段，适合搭建中台。\n当企业有了一定规模，产品得到了市场的认可，这时候公司的首要目的不再是活下去，而是活的更好。\n这个时候，趁着项目复杂度还不是特别高，可以考虑把各项目的通用部分下沉，组建中台，以方便后续新项目的尝试和旧项目的迭代。\n3）从N到N+1的阶段，搭建中台势在必行。\n当企业已经有了很大的规模，各种产品、服务、部门错综复杂，这时候做架构调整会比较痛苦。\n但是长痛不如短痛，为了项目的长期发展，还是需要尽早调整架构，实现平台化，以免日后越来越难以维护。\n7.6 数据湖数据湖（DataLake）**是一个存储企业的各种各样原始数据的大型仓库，其中的数据可供存取、处理、分析及传输。**\nhudi、iceberg、Data Lake\n目前，Hadoop是最常用的部署数据湖的技术，所以很多人会觉得数据湖就是Hadoop集群。数据湖是一个概念，而Hadoop是用于实现这个概念的技术。\n{width&#x3D;”4.124305555555556in”height&#x3D;”1.6222222222222222in”}\n+———————————–+———————————–+| 数据仓库                      | 数据湖                        |+———————————–+———————————–+| 主要处理历史的、结构化的数据，而且这些数据必须与数据仓库事 | 能处理所有类型的数据，如结构化数据，非结构化数据，半结构化数据等， || 先定义的模型吻合。                | 数据的类型依赖于数据源系统的原始数据格式。非结构化数据（语音、图片 ||                                   | 、视频等）                        |+———————————–+———————————–+| 数据仓库分析的指标都是产品经理提前规定好的。按需分析数据。（日活、 | 根据海量的数据，挖掘出规律，反应给运营部门。 || 新增、留存、转化率）              |                                   ||                                   |                                   ||                                   | 从海量的数据中找寻规律。拥有非常强的计算能力用于处理数据。 ||                                   |                                   ||                                   |                                   ||                                   | 数据挖掘                          |+———————————–+———————————–+\n7.7 埋点免费的埋点：上课演示。\n收费的埋点：神策[https://mp.weixin.qq.com/s/Xp3-alWF4XHvKDP9rNWCoQ]{.underline}\n百度统计、友盟统计\n目前主流的埋点方式，有代码埋点（前端&#x2F;后端）、可视化埋点、全埋点三种。\n代码埋点是通过调用埋点SDK函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据。例如，我们对页面中的某个按钮埋点后，当这个按钮被点击时，可以在这个按钮对应的OnClick 函数里面调用SDK提供的数据发送接口，来发送数据。\n可视化埋点只需要研发人员集成采集SDK，不需要写埋点代码，业务人员就可以通过访问分析平台的”圈选”功能，来”圈”出需要对用户行为进行捕捉的控件，并对该事件进行命名。圈选完毕后，这些配置会同步到各个用户的终端上，由采集SDK 按照圈选的配置自动进行用户行为数据的采集和发送。\n全埋点是通过在产品中嵌入SDK，前端自动采集页面上的全部用户行为事件，上报埋点数据，相当于做了一个统一的埋点。然后再通过界面配置哪些数据需要在系统里面进行分析。\n7.8 电商运营经验7.8.1 电商8类基本指标{width&#x3D;”5.768055555555556in”height&#x3D;”2.7493055555555554in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.4069444444444446in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”6.302083333333333in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.482638888888889in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.6534722222222222in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”3.022222222222222in”}\n{width&#x3D;”5.768055555555556in”height&#x3D;”2.638888888888889in”}\n8）市场竞争指标：主要分析市场份额以及网站排名，进一步进行调整\n{width&#x3D;”5.768055555555556in”height&#x3D;”1.6423611111111112in”}\n7.8.2 直播指标{width&#x3D;”3.7729166666666667in”height&#x3D;”3.561111111111111in”}\n{width&#x3D;”3.7395833333333335in”height&#x3D;”6.854166666666667in”}{width&#x3D;”5.768055555555556in”height&#x3D;”3.626388888888889in”}\n{width&#x3D;”4.377083333333333in”height&#x3D;”6.40625in”}\n{width&#x3D;”2.4923611111111112in”height&#x3D;”3.1527777777777777in”}\n{width&#x3D;”3.31875in”height&#x3D;”3.4770833333333333in”}\n第8章 实时数仓项目8.1 数据采集到ods层做了哪些事8.1.1 前端埋点的行为数据为什么又采集一份？时效性\nkafka保存3天，磁盘够：原来1T，现在2T，没压力\n8.1.2为什么选择kafka？实时写、实时读\n&#x3D;》 消息队列适合，其他数据库受不了\n8.1.3为什么用maxwell？历史数据同步怎么保证一致性？flinkcdc在20年7月才发布\ncanal与maxwell区别：\nmaxwell支持同步历史数据\nmaxwell支持断点还原（存在元数据库）\n数据格式更轻量\n保证至少一次，不丢\n8.1.4 kafka保存多久？如果需要以前的数据怎么办？跟离线项目保持一致：3天\n我们的项目不需要，如果需要的话可以去数据库或Hive现查，ClickHouse也有历史的宽表数据\n8.2 ods层1）存储原始数据\n2个topic ：\n埋点的行为数据 ods_base_log\n业务数据 ods_base_db\n2）业务数据的有序性： maxwell配置，指定生产者分区的key为 table\n8.3 dwd+dim层8.3.1 存储位置，为什么维度表存Hbase？事实表存Kafka、维度表存Hbase\n基于热存储加载维表的join方案：\n随机查\n长远考虑\n适合实时读写\n8.3.2 埋点行为数据分流1）修复新老访客（选择性）：以前是前端试别新老访客，不够准确\n2）分流：侧输出流\n分了3个topic： 启动、页面、曝光\n8.3.3 业务数据动态分流1）动态分流：将事实表写入kafka的dwd层，将维度表写入hbase。为了避免因表的变化而重启Flink任务，在mysql存一张表来动态配置。\n动态实现：使用广播状态\n&#x3D;》 读取一张配置表 &#x3D;&#x3D;&#x3D;》 维护这张配置表\nsource来源 sink写到哪 操作类型 字段 主键 扩展\n&#x3D;》实时获取配置表的变化 &#x3D;&#x3D;》CDC工具\n&#x3D;》 FlinkCDC\n&#x3D;》 使用了sql的方式，去同步这张配置表\n&#x3D;》sql的数据格式比较方便\n2）怎么写HBase：借助phoenix\n没有做维度退化\n维表数据量小、变化频率慢\n3）Hbase的rowkey怎么设计的？有没有数据热点问题？\n最大的维表：用户维表\n&#x3D;》百万日活，2000万注册用户为例，1条平均1k：2000万*1k&#x3D;约20G\n使用Phoenix创建的盐表，避免数据热点问题\n[https://developer.aliyun.com/article/532313]{.underline}\n8.4 dwm层8.4.1 为什么要加一个dwm层？DWM层主要服务DWS，因为部分需求直接从DWD层到DWS层中间会有一定的计算量，而且这部分计算的结果很有可能被多个DWS层主题复用，所以部分DWD层会形成一层DWM，我们这里主要涉及业务\n\n访问UV计算\n\n跳出明细计算\n\n订单宽表\n\n支付宽表\n\n\n8.4.2 事实表与事实表join1）事实表与事实表的双流join,使用了interval join\n2）Join不上的数据怎么办？\n在flink中的流join大体分为两种，一种是基于时间窗口的join（Time WindowedJoin），比如join、coGroup等。另一种是基于状态缓存的join（Temporal TableJoin），比如intervalJoin。\n这里选用intervalJoin，因为相比较窗口join，intervalJoin使用更简单，而且避免了应匹配的数据处于不同窗口的问题。intervalJoin目前只有一个问题，就是还不支持leftjoin。\n但是我们这里是订单主表与订单从表之间的关联不需要leftjoin，所以intervalJoin是较好的选择。\n8.4.3 事实表与维度表join维度关联采用了热存储加载的join方案，实际上就是在流中查询存储在hbase中的数据表。但是即使通过主键的方式查询，hbase速度的查询也是不及流之间的join。外部数据源的查询常常是流式计算的性能瓶颈，所以在这个基础上还有进行一定的优化。\n1）使用了旁路缓存\n旁路缓存模式是一种非常常见的按需分配缓存的模式。如图，任何请求优先访问缓存，缓存命中，直接获得数据返回请求。如果未命中则，查询数据库，同时把结果写入缓存以备后续请求使用。\n{width&#x3D;”1.8972222222222221in”height&#x3D;”1.9104166666666667in”}\n2）异步IO\nFlink 在1.2中引入了AsyncI&#x2F;O，在异步模式下，将IO操作异步化，单个并行可以连续发送多个请求，哪个请求先返回就先处理，从而在连续的请求间不需要阻塞式等待，大大提高了流处理效率。\nAsync I&#x2F;O是阿里巴巴贡献给社区的一个呼声非常高的特性，解决与外部系统交互时网络延迟成为了系统瓶颈的问题。\n{width&#x3D;”4.8625in”height&#x3D;”2.5854166666666667in”}\n异步查询实际上是把维表的查询操作托管给单独的线程池完成，这样不会因为某一个查询造成阻塞，单个并行可以连续发送多个请求，提高并发效率。\n这种方式特别针对涉及网络IO的操作，减少因为请求等待带来的消耗。\n8.4.4怎么保证缓存一致性当我们获取到维表更新的数据，也就是拿到维度表操作类型为update时：\n1）更新Hbase的同时，删除redis里对应的之前缓存的数据\n2）redis设置了过期时间：24小时\n8.5 dws层8.5.1 为什么选择ClickHouse1）适合大宽表、数据量多、聚合统计分析 &#x3D;》 快\n2）宽表已经不再需要join，很合适\n8.5.2 轻度聚合1）DWS层要应对很多实时查询，如果是完全的明细那么查询的压力是非常大的。将更多的实时数据以主题的方式组合起来便于管理，同时也能减少维度查询的次数。\n2）开一个小窗口，5s的滚动窗口\n3）同时减轻了写ClickHouse的压力，减少后续聚合的时间\n4）几张表？ 表名、字段\n访客、商品、地区、关键词\n8.6 ads层8.6.1 实现方案为可视化大屏服务，提供一个数据接口用来查询ClickHouse中的数据。\n{width&#x3D;”4.84375in”height&#x3D;”3.0in”}\n8.6.2 怎么保证ClickHouse的一致性？ReplacingMergeTree只能保证最终一致性，查询时的sql语法加上去重逻辑\n8.7 监控Flink和ClickHouse都使用了Prometheus + Grafana\n第9章 手写代码9.1 基本算法9.1.1 冒泡排序&#x2F;**\n\n冒泡排序 时间复杂度 O(n^2) 空间复杂度O(1)\n\n*&#x2F;\npublic class BubbleSort {\npublic static void bubbleSort(int[] data) {\nSystem.out.println(“开始排序”);\nint arrayLength &#x3D; data.length;\nfor (int i &#x3D; 0; i &lt; arrayLength - 1; i++) {\nboolean flag &#x3D; false;\nfor (int j &#x3D; 0; j &lt; arrayLength - 1 - i; j++) {\nif(data[j] &gt; data[j + 1]){\nint temp &#x3D; data[j + 1];\ndata[j + 1] &#x3D; data[j];\ndata[j] &#x3D; temp;\nflag &#x3D; true;\n}\n}\nSystem.out.println(java.util.Arrays.toString(data));\nif (!flag)\nbreak;\n}\n}\npublic static void main(String[] args) {\nint[] data &#x3D; { 9, -16, 21, 23, -30, -49, 21, 30, 30 };\nSystem.out.println(“排序之前：n” + java.util.Arrays.toString(data));\nbubbleSort(data);\nSystem.out.println(“排序之后：n” + java.util.Arrays.toString(data));\n}\n}\n9.1.2 二分查找\n图4-二分查找核心思路\n实现代码：\n&#x2F;**\n * 二分查找 时间复杂度O(log2n);空间复杂度O(1)\n *&#x2F;\n \ndef binarySearch(arr:Array[Int],left:Int,right:Int,findVal:Int): Int&#x3D;{\n  if(left&gt;right){&#x2F;&#x2F;递归退出条件，找不到，返回-1\n    -1\n  }\n  val midIndex &#x3D; (left+right)&#x2F;2\n  if (findVal &lt; arr(midIndex)){&#x2F;&#x2F;向左递归查找\n    binarySearch(arr,left,midIndex-1,findVal)\n  }else if(findVal &gt; arr(midIndex)){&#x2F;&#x2F;向右递归查找\n    binarySearch(arr,midIndex+1,right,findVal)\n  }else{&#x2F;&#x2F;查找到，返回下标\n    midIndex\n  }\n}\n拓展需求：当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到。\n代码实现如下：\n&#x2F;*\n{1,8, 10, 89, 1000, 1000，1234}当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的1000.\n&#x2F;&#x2F;分析\n\n返回的结果是一个可变数组 ArrayBuffer\n\n在找到结果时，向左边扫描，向右边扫描 [条件]\n\n找到结果后，就加入到ArrayBuffer\n\n\n*&#x2F;\ndef binarySearch2(arr: Array[Int], l: Int, r: Int,\nfindVal: Int): ArrayBuffer[Int] &#x3D; {\n&#x2F;&#x2F;找不到条件?\nif (l &gt; r) {\nreturn ArrayBuffer()\n}\nval midIndex &#x3D; (l + r) &#x2F; 2\nval midVal &#x3D; arr(midIndex)\nif (midVal &gt; findVal) {\n&#x2F;&#x2F;向左进行递归查找\nbinarySearch2(arr, l, midIndex - 1, findVal)\n} else if (midVal &lt; findVal) { &#x2F;&#x2F;向右进行递归查找\nbinarySearch2(arr, midIndex + 1, r, findVal)\n} else {\nprintln(“midIndex&#x3D;” + midIndex)\n&#x2F;&#x2F;定义一个可变数组\nval resArr &#x3D; ArrayBufferInt\n&#x2F;&#x2F;向左边扫描\nvar temp &#x3D; midIndex - 1\nbreakable {\nwhile (true) {\nif (temp &lt; 0 || arr(temp) !&#x3D; findVal) {\nbreak()\n}\nif (arr(temp) &#x3D;&#x3D; findVal) {\nresArr.append(temp)\n}\ntemp -&#x3D; 1\n}\n}\n&#x2F;&#x2F;将中间这个索引加入\nresArr.append(midIndex)\n&#x2F;&#x2F;向右边扫描\ntemp &#x3D; midIndex + 1\nbreakable {\nwhile (true) {\nif (temp &gt; arr.length - 1 || arr(temp) !&#x3D; findVal) {\nbreak()\n}\nif (arr(temp) &#x3D;&#x3D; findVal) {\nresArr.append(temp)\n}\ntemp +&#x3D; 1\n}\n}\nreturn resArr\n}\n9.1.3 快排图1-快速排序核心思想\n代码实现：\n&#x2F;**\n\n快排\n\n时间复杂度:平均时间复杂度为O(nlogn)\n\n空间复杂度:O(logn)，因为递归栈空间的使用问题\n\n\n*&#x2F;\ndef quickSort(list: List[Int]): List[Int] &#x3D; list match {\ncase Nil &#x3D;&gt; Nil\ncase List() &#x3D;&gt; List()\ncase head :: tail &#x3D;&gt;\nval (left, right) &#x3D; tail.partition(_ &lt; head)\nquickSort(left) ::: head :: quickSort(right)\n}\n9.1.4 归并归并排序核心思想\n核心思想：不断的将大的数组分成两个小数组，直到不能拆分为止，即形成了单个值。此时使用合并的排序思想对已经有序的数组进行合并，合并为一个大的数据，不断重复此过程，直到最终所有数据合并到一个数组为止。\n\n图3-归并排序”治”流程\n代码实现：\n&#x2F;**\n\n快排\n\n时间复杂度:O(nlogn)\n\n空间复杂度:O(n)\n\n\n*&#x2F;\ndef merge(left: List[Int], right: List[Int]): List[Int] &#x3D; (left,right) match {\ncase (Nil, _) &#x3D;&gt; right\ncase (_, Nil) &#x3D;&gt; left\ncase (x :: xTail, y :: yTail) &#x3D;&gt;\nif (x &lt;&#x3D; y) x :: merge(xTail, right)\nelse y :: merge(left, yTail)\n}\n9.1.5 二叉树之Scala实现1）二叉树概念\n2）二叉树的特点\n（1）树执行查找、删除、插入的时间复杂度都是O(logN)\n（2）遍历二叉树的方法包括前序、中序、后序\n（3）非平衡树指的是根的左右两边的子节点的数量不一致\n（4）在非空二叉树中，第i层的结点总数不超过 , i&gt;&#x3D;1；\n（5）深度为h的二叉树最多有个结点(h&gt;&#x3D;1)，最少有h个结点；\n（6）对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0&#x3D;N2+1；\n3） 二叉树的Scala代码实现\n定义节点以及前序、中序、后序遍历\nclass TreeNode(treeNo:Int){\nval no &#x3D; treeNo\nvar left:TreeNode &#x3D; null\nvar right:TreeNode &#x3D; null\n&#x2F;&#x2F;后序遍历\ndef postOrder():Unit&#x3D;{\n&#x2F;&#x2F;向左递归输出左子树\nif(this.left !&#x3D; null){\nthis.left.postOrder\n}\n&#x2F;&#x2F;向右递归输出右子树\nif (this.right !&#x3D; null) {\nthis.right.postOrder\n}\n&#x2F;&#x2F;输出当前节点值\nprintf(“节点信息 no&#x3D;%d n”,no)\n}\n&#x2F;&#x2F;中序遍历\ndef infixOrder():Unit&#x3D;{\n&#x2F;&#x2F;向左递归输出左子树\nif(this.left !&#x3D; null){\nthis.left.infixOrder()\n}\n&#x2F;&#x2F;输出当前节点值\nprintf(“节点信息 no&#x3D;%d n”,no)\n&#x2F;&#x2F;向右递归输出右子树\nif (this.right !&#x3D; null) {\nthis.right.infixOrder()\n}\n}\n&#x2F;&#x2F;前序遍历\ndef preOrder():Unit&#x3D;{\n&#x2F;&#x2F;输出当前节点值\nprintf(“节点信息 no&#x3D;%d n”,no)\n&#x2F;&#x2F;向左递归输出左子树\nif(this.left !&#x3D; null){\nthis.left.postOrder()\n}\n&#x2F;&#x2F;向右递归输出右子树\nif (this.right !&#x3D; null) {\nthis.right.preOrder()\n}\n}\n&#x2F;&#x2F;后序遍历查找\ndef postOrderSearch(no:Int): TreeNode &#x3D; {\n&#x2F;&#x2F;向左递归输出左子树\nvar resNode:TreeNode &#x3D; null\nif (this.left !&#x3D; null) {\nresNode &#x3D; this.left.postOrderSearch(no)\n}\nif (resNode !&#x3D; null) {\nreturn resNode\n}\nif (this.right !&#x3D; null) {\nresNode &#x3D; this.right.postOrderSearch(no)\n}\nif (resNode !&#x3D; null) {\nreturn resNode\n}\nprintln(“ttt~~”)\nif (this.no &#x3D;&#x3D; no) {\nreturn this\n}\nresNode\n}\n&#x2F;&#x2F;中序遍历查找\ndef infixOrderSearch(no:Int): TreeNode &#x3D; {\nvar resNode : TreeNode &#x3D; null\n&#x2F;&#x2F;先向左递归查找\nif (this.left !&#x3D; null) {\nresNode &#x3D; this.left.infixOrderSearch(no)\n}\nif (resNode !&#x3D; null) {\nreturn resNode\n}\nprintln(“yyy~~”)\nif (no &#x3D;&#x3D; this.no) {\nreturn this\n}\n&#x2F;&#x2F;向右递归查找\nif (this.right !&#x3D; null) {\nresNode &#x3D; this.right.infixOrderSearch(no)\n}\nreturn resNode\n}\n&#x2F;&#x2F;前序查找\ndef preOrderSearch(no:Int): TreeNode &#x3D; {\nif (no &#x3D;&#x3D; this.no) {\nreturn this\n}\n&#x2F;&#x2F;向左递归查找\nvar resNode : TreeNode &#x3D; null\nif (this.left !&#x3D; null) {\nresNode &#x3D; this.left.preOrderSearch(no)\n}\nif (resNode !&#x3D; null){\nreturn resNode\n}\n&#x2F;&#x2F;向右边递归查找\nif (this.right !&#x3D; null) {\nresNode &#x3D; this.right.preOrderSearch(no)\n}\nreturn resNode\n}\n&#x2F;&#x2F;删除节点\n&#x2F;&#x2F;删除节点规则\n&#x2F;&#x2F;1如果删除的节点是叶子节点，则删除该节点\n&#x2F;&#x2F;2如果删除的节点是非叶子节点，则删除该子树\ndef delNode(no:Int): Unit &#x3D; {\n&#x2F;&#x2F;首先比较当前节点的左子节点是否为要删除的节点\nif (this.left !&#x3D; null &amp;&amp; this.left.no &#x3D;&#x3D; no) {\nthis.left &#x3D; null\nreturn\n}\n&#x2F;&#x2F;比较当前节点的右子节点是否为要删除的节点\nif (this.right !&#x3D; null &amp;&amp; this.right.no &#x3D;&#x3D; no) {\nthis.right &#x3D; null\nreturn\n}\n&#x2F;&#x2F;向左递归删除\nif (this.left !&#x3D; null) {\nthis.left.delNode(no)\n}\n&#x2F;&#x2F;向右递归删除\nif (this.right !&#x3D; null) {\nthis.right.delNode(no)\n}\n}\n}\n定义二叉树，前序、中序、后序遍历，前序、中序、后序查找，删除节点\nclass BinaryTree{\nvar root:TreeNode &#x3D; null\n&#x2F;&#x2F;后序遍历\ndef postOrder(): Unit &#x3D; {\nif (root !&#x3D; null){\nroot.postOrder()\n}else {\nprintln(“当前二叉树为空，不能遍历”)\n}\n}\n&#x2F;&#x2F;中序遍历\ndef infixOrder(): Unit &#x3D; {\nif (root !&#x3D; null){\nroot.infixOrder()\n}else {\nprintln(“当前二叉树为空，不能遍历”)\n}\n}\n&#x2F;&#x2F;前序遍历\ndef preOrder(): Unit &#x3D; {\nif (root !&#x3D; null){\nroot.preOrder()\n}else {\nprintln(“当前二叉树为空，不能遍历”)\n}\n}\n&#x2F;&#x2F;后序遍历查找\ndef postOrderSearch(no:Int): TreeNode &#x3D; {\nif (root !&#x3D; null) {\nroot.postOrderSearch(no)\n}else{\nnull\n}\n}\n&#x2F;&#x2F;中序遍历查找\ndef infixOrderSeacher(no:Int): TreeNode &#x3D; {\nif (root !&#x3D; null) {\nreturn root.infixOrderSearch(no)\n}else {\nreturn null\n}\n}\n&#x2F;&#x2F;前序查找\ndef preOrderSearch(no:Int): TreeNode &#x3D; {\nif (root !&#x3D; null) {\nreturn root.preOrderSearch(no)\n}else{\n&#x2F;&#x2F;println(“当前二叉树为空，不能查找”)\nreturn null\n}\n}\n&#x2F;&#x2F;删除节点\ndef delNode(no:Int): Unit &#x3D; {\nif (root !&#x3D; null) {\n&#x2F;&#x2F;先处理一下root是不是要删除的\nif (root.no &#x3D;&#x3D; no){\nroot &#x3D; null\n}else {\nroot.delNode(no)\n}\n}\n}\n9.2 开发代码9.2.1 手写Spark-WordCountval conf: SparkConf &#x3D;\nnew SparkConf().setMaster(“local[*]”).setAppName(“WordCount”)\nval sc &#x3D; new SparkContext(conf)\nsc.textFile(“&#x2F;input”)\n.flatMap(_.split(“ “))\n.map((_, 1))\n.reduceByKey(_ + _)\n.saveAsTextFile(“&#x2F;output”)\nsc.stop()\n9.3 手写HQL9.3.1 手写HQL 第1题表结构：uid,subject_id,score\n求：找出所有科目成绩都大于某一学科平均成绩的学生\n数据集如下\n1001 01 90\n1001 02 90\n1001 03 90\n1002 01 85\n1002 02 85\n1002 03 70\n1003 01 70\n1003 02 70\n1003 03 85\n1）建表语句\ncreate table score(\nuid string,\nsubject_id string,\nscore int)\nrow format delimited fields terminated by ‘t’;\n2）求出每个学科平均成绩\nselect\nuid,\nscore,\navg(score) over(partition by subject_id) avg_score\nfrom\nscore;t1\n3）根据是否大于平均成绩记录flag，大于则记为0否则记为1\nselect\nuid,\nif(score&gt;avg_score,0,1) flag\nfrom\nt1;t2\n4）根据学生id进行分组统计flag的和，和为0则是所有学科都大于平均成绩\nselect\nuid\nfrom\nt2\ngroup by\nuid\nhaving\nsum(flag)&#x3D;0;\n5）最终SQL\nselect\nuid\nfrom\n(select\nuid,\nif(score&gt;avg_score,0,1) flag\nfrom\n(select\nuid,\nscore,\navg(score) over(partition by subject_id) avg_score\nfrom\nscore)t1)t2\ngroup by\nuid\nhaving\nsum(flag)&#x3D;0;\n9.3.2 手写HQL 第2题我们有如下的用户访问数据\n\n  userId   visitDate   visitCount  u01      2017&#x2F;1&#x2F;21   5  u02      2017&#x2F;1&#x2F;23   6  u03      2017&#x2F;1&#x2F;22   8  u04      2017&#x2F;1&#x2F;20   3  u01      2017&#x2F;1&#x2F;23   6  u01      2017&#x2F;2&#x2F;21   8  U02      2017&#x2F;1&#x2F;23   6  U01      2017&#x2F;2&#x2F;22   4\n\n要求使用SQL统计出每个用户的累积访问次数，如下表所示：\n\n  用户id   月份      小计   累积  u01      2017-01   11     11  u01      2017-02   12     23  u02      2017-01   12     12  u03      2017-01   8      8  u04      2017-01   3      3\n\n数据集\nu01 2017&#x2F;1&#x2F;21 5\nu02 2017&#x2F;1&#x2F;23 6\nu03 2017&#x2F;1&#x2F;22 8\nu04 2017&#x2F;1&#x2F;20 3\nu01 2017&#x2F;1&#x2F;23 6\nu01 2017&#x2F;2&#x2F;21 8\nu02 2017&#x2F;1&#x2F;23 6\nu01 2017&#x2F;2&#x2F;22 4\n1）创建表\ncreate table action\n(userId string,\nvisitDate string,\nvisitCount int)\nrow format delimited fields terminated by “t”;\n2）修改数据格式\nselect\nuserId,\ndate_format(regexp_replace(visitDate,’&#x2F;‘,’-‘),’yyyy-MM’) mn,\nvisitCount\nfrom\naction;t1\n3）计算每人单月访问量\nselect\nuserId,\nmn,\nsum(visitCount) mn_count\nfrom\nt1\ngroup by\nuserId,mn;t2\n4）按月累计访问量\nselect\nuserId,\nmn,\nmn_count,\nsum(mn_count) over(partition by userId order by mn)\nfrom t2;\n5）最终SQL\nselect\nuserId,\nmn,\nmn_count,\nsum(mn_count) over(partition by userId order by mn)\nfrom\n( select\nuserId,\nmn,\nsum(visitCount) mn_count\nfrom\n(select\nuserId,\ndate_format(regexp_replace(visitDate,’&#x2F;‘,’-‘),’yyyy-MM’) mn,\nvisitCount\nfrom\naction)t1\ngroup by userId,mn)t2;\n9.3.3 手写HQL 第3题有50W个京东店铺，每个顾客访客访问任何一个店铺的任何一个商品时都会产生一条访问日志，访问日志存储的表名为Visit，访客的用户id为user_id，被访问的店铺名称为shop，请统计：\n1）每个店铺的UV（访客数）\n2）每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数\n数据集\nu1 a\nu2 b\nu1 b\nu1 a\nu3 c\nu4 b\nu1 a\nu2 c\nu5 b\nu4 b\nu6 c\nu2 c\nu1 b\nu2 a\nu2 a\nu3 a\nu5 a\nu5 a\nu5 a\n1）建表\ncreate table visit(user_id string,shop string) row format delimitedfields terminated by ‘t’;\n2）每个店铺的UV（访客数）\nselect shop,count(distinct user_id) from visit group by shop;\n3）每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数\n（1）查询每个店铺被每个用户访问次数\nselect shop,user_id,count(*) ct\nfrom visit\ngroup by shop,user_id;t1\n（2）计算每个店铺被用户访问次数排名\nselect shop,user_id,ct,rank() over(partition by shop order by ct) rk\nfrom t1;t2\n（3）取每个店铺排名前3的\nselect shop,user_id,ct\nfrom t2\nwhere rk&lt;&#x3D;3;\n（4）最终SQL\nselect\nshop,\nuser_id,\nct\nfrom\n(select\nshop,\nuser_id,\nct,\nrank() over(partition by shop order by ct) rk\nfrom\n(select\nshop,\nuser_id,\ncount(*) ct\nfrom visit\ngroup by\nshop,\nuser_id)t1\n)t2\nwhere rk&lt;&#x3D;3;\n9.3.4 手写HQL 第4题已知一个表STG.ORDER，有如下字段:Date，Order_id，User_id，amount。请给出sql进行统计:数据样例:2017-01-01,10029028,1000003251,33.57。\n1）给出 2017年每个月的订单数、用户数、总成交金额。\n2）给出2017年11月的新客数(指在11月才有第一笔订单)\n建表\ncreate table order_tab(dt string,order_id string,user_idstring,amount decimal(10,2)) row format delimited fields terminated by‘t’;\n1）给出 2017年每个月的订单数、用户数、总成交金额。\nselect\ndate_format(dt,’yyyy-MM’),\ncount(order_id),\ncount(distinct user_id),\nsum(amount)\nfrom\norder_tab\nwhere\ndate_format(dt,’yyyy’)&#x3D;’2017’\ngroup by\ndate_format(dt,’yyyy-MM’);\n2）给出2017年11月的新客数(指在11月才有第一笔订单)\nselect\ncount(user_id)\nfrom\norder_tab\ngroup by\nuser_id\nhaving\ndate_format(min(dt),’yyyy-MM’)&#x3D;’2017-11’;\n9.3.5 手写HQL 第5题有日志如下，请写出代码求得所有用户和活跃用户的总数及平均年龄。（活跃用户指连续两天都有访问记录的用户）日期用户 年龄\n数据集\n2019-02-11,test_1,23\n2019-02-11,test_2,19\n2019-02-11,test_3,39\n2019-02-11,test_1,23\n2019-02-11,test_3,39\n2019-02-11,test_1,23\n2019-02-12,test_2,19\n2019-02-13,test_1,23\n2019-02-15,test_2,19\n2019-02-16,test_2,19\n1）建表\ncreate table user_age(dt string,user_id string,age int)row formatdelimited fields terminated by ‘,’;\n2）按照日期以及用户分组，按照日期排序并给出排名\nselect\ndt,\nuser_id,\nmin(age) age,\nrank() over(partition by user_id order by dt) rk\nfrom\nuser_age\ngroup by\ndt,user_id;t1\n3）计算日期及排名的差值\nselect\nuser_id,\nage,\ndate_sub(dt,rk) flag\nfrom\nt1;t2\n4）过滤出差值大于等于2的，即为连续两天活跃的用户\nselect\nuser_id,\nmin(age) age\nfrom\nt2\ngroup by\nuser_id,flag\nhaving\ncount(*)&gt;&#x3D;2;t3\n5）对数据进行去重处理（一个用户可以在两个不同的时间点连续登录），例如：a用户在1月10号1月11号以及1月20号和1月21号4天登录。\nselect\nuser_id,\nmin(age) age\nfrom\nt3\ngroup by\nuser_id;t4\n6）计算活跃用户（两天连续有访问）的人数以及平均年龄\nselect\ncount(*) ct,\ncast(sum(age)&#x2F;count(*) as decimal(10,2))\nfrom t4;\n7）对全量数据集进行按照用户去重\nselect\nuser_id,\nmin(age) age\nfrom\nuser_age\ngroup by\nuser_id;t5\n8）计算所有用户的数量以及平均年龄\nselect\ncount(*) user_count,\ncast((sum(age)&#x2F;count(*)) as decimal(10,1))\nfrom\nt5;\n9）将第5步以及第7步两个数据集进行union all操作\nselect\n0 user_total_count,\n0 user_total_avg_age,\ncount(*) twice_count,\ncast(sum(age)&#x2F;count(*) as decimal(10,2)) twice_count_avg_age\nfrom\n(\nselect\nuser_id,\nmin(age) age\nfrom\n(select\nuser_id,\nmin(age) age\nfrom\n(\nselect\nuser_id,\nage,\ndate_sub(dt,rk) flag\nfrom\n(\nselect\ndt,\nuser_id,\nmin(age) age,\nrank() over(partition by user_id order by dt) rk\nfrom\nuser_age\ngroup by\ndt,user_id\n)t1\n)t2\ngroup by\nuser_id,flag\nhaving\ncount(*)&gt;&#x3D;2)t3\ngroup by\nuser_id\n)t4\nunion all\nselect\ncount(*) user_total_count,\ncast((sum(age)&#x2F;count(*)) as decimal(10,1)),\n0 twice_count,\n0 twice_count_avg_age\nfrom\n(\nselect\nuser_id,\nmin(age) age\nfrom\nuser_age\ngroup by\nuser_id\n)t5;t6\n10）求和并拼接为最终SQL\nselect\nsum(user_total_count),\nsum(user_total_avg_age),\nsum(twice_count),\nsum(twice_count_avg_age)\nfrom\n(select\n0 user_total_count,\n0 user_total_avg_age,\ncount(*) twice_count,\ncast(sum(age)&#x2F;count(*) as decimal(10,2)) twice_count_avg_age\nfrom\n(\nselect\nuser_id,\nmin(age) age\nfrom\n(select\nuser_id,\nmin(age) age\nfrom\n(\nselect\nuser_id,\nage,\ndate_sub(dt,rk) flag\nfrom\n(\nselect\ndt,\nuser_id,\nmin(age) age,\nrank() over(partition by user_id order by dt) rk\nfrom\nuser_age\ngroup by\ndt,user_id\n)t1\n)t2\ngroup by\nuser_id,flag\nhaving\ncount(*)&gt;&#x3D;2)t3\ngroup by\nuser_id\n)t4\nunion all\nselect\ncount(*) user_total_count,\ncast((sum(age)&#x2F;count(*)) as decimal(10,1)),\n0 twice_count,\n0 twice_count_avg_age\nfrom\n(\nselect\nuser_id,\nmin(age) age\nfrom\nuser_age\ngroup by\nuser_id\n)t5)t6;\n9.3.6 手写HQL 第6题请用sql写出所有用户中在今年10月份第一次购买商品的金额，表ordertable字段（购买用户：userid，金额：money，购买时间：paymenttime(格式：2017-10-01)，订单id：orderid）\n1）建表\ncreate table ordertable(\nuserid string,\nmoney int,\npaymenttime string,\norderid string)\nrow format delimited fields terminated by ‘t’;\n2）查询出\nselect\nuserid,\nmin(paymenttime) paymenttime\nfrom\nordertable\nwhere\ndate_format(paymenttime,’yyyy-MM’)&#x3D;’2017-10’\ngroup by\nuserid;t1\nselect\nt1.userid,\nt1.paymenttime,\nod.money\nfrom\nt1\njoin\nordertable od\non\nt1.userid&#x3D;od.userid\nand\nt1.paymenttime&#x3D;od.paymenttime;\nselect\nt1.userid,\nt1.paymenttime,\nod.money\nfrom\n(select\nuserid,\nmin(paymenttime) paymenttime\nfrom\nordertable\nwhere\ndate_format(paymenttime,’yyyy-MM’)&#x3D;’2017-10’\ngroup by\nuserid)t1\njoin\nordertable od\non\nt1.userid&#x3D;od.userid\nand\nt1.paymenttime&#x3D;od.paymenttime;\n9.3.7 手写HQL 第7题有一个线上服务器访问日志格式如下（用sql答题）\n时间 接口 ip地址\n2016-11-09 11：22：05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.33\n2016-11-09 11：23：10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16\n…..\n2016-11-09 23：59：40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166\n求11月9号下午14点（14-15点），访问api&#x2F;user&#x2F;login接口的top10的ip地址\n数据集\n2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.33\n2016-11-09 11:23:10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16\n2016-11-09 14:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166\n2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.34\n2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.34\n2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.34\n2016-11-09 11:23:10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16\n2016-11-09 23:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166\n2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.34\n2016-11-09 11:23:10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16\n2016-11-09 23:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166\n2016-11-09 14:22:05 &#x2F;api&#x2F;user&#x2F;login 110.23.5.35\n2016-11-09 14:23:10 &#x2F;api&#x2F;user&#x2F;detail 57.3.2.16\n2016-11-09 23:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166\n2016-11-09 14:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166\n2016-11-09 14:59:40 &#x2F;api&#x2F;user&#x2F;login 200.6.5.166\n1）建表\ncreate table ip(\ntime string,\ninterface string,\nip string)\nrow format delimited fields terminated by ‘t’;\n2）最终SQL\nselect\nip,\ninterface,\ncount(*) ct\nfrom\nip\nwhere\ndate_format(time,’yyyy-MM-dd HH’)&gt;&#x3D;’2016-11-09 14’\nand\ndate_format(time,’yyyy-MM-dd HH’)&lt;&#x3D;’2016-11-09 15’\nand\ninterface&#x3D;’&#x2F;api&#x2F;user&#x2F;login’\ngroup by\nip,interface\norder by\nct desc\nlimit 2;t1\n9.3.8 手写SQL 第8题有一个账号表如下，请写出SQL语句，查询各自区组的money排名前十的账号（分组取前10）\n1）建表（MySQL）\nCREATE TABLE account\n( dist_id int（11）DEFAULT NULL COMMENT ‘区组id’,\naccount varchar（100）DEFAULT NULL COMMENT ‘账号’,\ngold int（11）DEFAULT 0 COMMENT ‘金币’）;\n2）最终SQL\nselect\n\n\n\nfrom\naccount as a\nwhere\n(select\ncount(distinct(a1.gold))\nfrom\naccount as a1\nwhere\na1.dist_id&#x3D;a.dist_id\nand\na1.gold&gt;a.gold)&lt;3;\n9.3.9 手写HQL 第9题1）有三张表分别为会员表（member）销售表（sale）退货表（regoods）\n（1）会员表有字段memberid（会员id，主键）credits（积分）；\n（2）销售表有字段memberid（会员id，外键）购买金额（MNAccount）；\n（3）退货表中有字段memberid（会员id，外键）退货金额（RMNAccount）。\n2）业务说明\n（1）销售表中的销售记录可以是会员购买，也可以是非会员购买。（即销售表中的memberid可以为空）；\n（2）销售表中的一个会员可以有多条购买记录；\n（3）退货表中的退货记录可以是会员，也可是非会员；\n（4）一个会员可以有一条或多条退货记录。\n查询需求：分组查出销售表中所有会员购买金额，同时分组查出退货表中所有会员的退货金额，把会员id相同的购买金额-退款金额得到的结果更新到表会员表中对应会员的积分字段（credits）\n数据集\nsale\n1001 50.3\n1002 56.5\n1003 235\n1001 23.6\n1005 56.2\n25.6\n33.5\nregoods\n1001 20.1\n1002 23.6\n1001 10.1\n23.5\n10.2\n1005 0.8\n1）建表\ncreate table member(memberid string,credits double) row format delimitedfields terminated by ‘t’;\ncreate table sale(memberid string,MNAccount double) row format delimitedfields terminated by ‘t’;\ncreate table regoods(memberid string,RMNAccount double) row formatdelimited fields terminated by ‘t’;\n2）最终SQL\ninsert into table member\nselect\nt1.memberid,\nMNAccount-RMNAccount\nfrom\n(select\nmemberid,\nsum(MNAccount) MNAccount\nfrom\nsale\nwhere\nmemberid!&#x3D;’’\ngroup by\nmemberid\n)t1\njoin\n(select\nmemberid,\nsum(RMNAccount) RMNAccount\nfrom\nregoods\nwhere\nmemberid!&#x3D;’’\ngroup by\nmemberid\n)t2\non\nt1.memberid&#x3D;t2.memberid;\n9.3.10 手写HQL 第10题1.用一条SQL语句查询出每门课都大于80分的学生姓名\nname   kecheng   fenshu\n张三    语文    81\n张三    数学    75\n李四    语文    76\n李四    数学    90\n王五    语文    81\n王五    数学    100\n王五    英语    90\nA: select distinct name from table where name not in (select distinctname from table where fenshu&lt;&#x3D;80)\nB：select name from table group by name having min(fenshu)&gt;80\n2. 学生表 如下:自动编号   学号  姓名 课程编号 课程名称 分数1     2005001 张三  0001   数学   692     2005002 李四  0001   数学   893     2005001 张三  0001   数学   69删除除了自动编号不同, 其他都相同的学生冗余信息\nA: delete tablename where 自动编号 not in(select min(自动编号) fromtablename group by学号, 姓名, 课程编号, 课程名称, 分数)\n3.一个叫team的表，里面只有一个字段name,一共有4条纪录，分别是a,b,c,d,对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合.\n答：select a.name, b.namefrom team a, team bwhere a.name &lt; b.name\n4.面试题：怎么把这样一个year   month amount1991   1     1.11991   2     1.21991   3     1.31991   4     1.41992   1     2.11992   2     2.21992   3     2.31992   4     2.4查成这样一个结果year m1  m2  m3 m41991 1.1 1.2 1.3 1.41992 2.1 2.2 2.3 2.4 \n答案select year, (select amount from aaa m where month&#x3D;1 and m.year&#x3D;aaa.year) as m1,(select amount from aaa m where month&#x3D;2 and m.year&#x3D;aaa.year) as m2,(select amount from aaa m where month&#x3D;3 and m.year&#x3D;aaa.year) as m3,(select amount from aaa m where month&#x3D;4 and m.year&#x3D;aaa.year) as m4from aaa group by year\n\n*5.说明：复制表(只复制结构,源表名：a新表名：b) \nSQL: select * into b from a where 1&lt;&gt;1(where1&#x3D;1，拷贝表结构和数据内容)ORACLE:create table b\nAs\nSelect * from a where 1&#x3D;2\n \n[&lt;&gt;（不等于）(SQL Server Compact)\n比较两个表达式。当使用此运算符比较非空表达式时，如果左操作数不等于右操作数，则结果为TRUE。 否则，结果为 FALSE。]\n\n\n\n原表:courseid coursename score\n\n1 java 702 oracle 903 xml 404 jsp 305 servlet 80\n\n为了便于阅读,查询此表后的结果显式如下(及格分数为60):courseid coursename score mark\n\n1 java 70 pass2 oracle 90 pass3 xml 40 fail4 jsp 30 fail5 servlet 80 pass\n\n写出此查询语句select courseid, coursename ,score ,if(score&gt;&#x3D;60, “pass”,”fail”) asmark from course\n7.表名：购物信息\n购物人 商品名称 数量\nA 甲 2\nB 乙 4\nC 丙 1\nA 丁 2\nB 丙 5\n……\n给出所有购入商品为两种或两种以上的购物人记录\n答：select * from 购物信息 where 购物人 in (select 购物人 from 购物信息group by 购物人 having count(*) &gt;&#x3D; 2);\n\n\n\ninfo 表\ndate result\n2005-05-09 win\n2005-05-09 lose\n2005-05-09 lose\n2005-05-09 lose\n2005-05-10 win\n2005-05-10 lose\n2005-05-10 lose\n如果要生成下列结果, 该如何写sql语句?\n　　 win lose\n2005-05-09 2 2\n2005-05-10 1 2\n答案：\n(1) select date, sum(case when result &#x3D; “win” then 1 else 0 end) as“win”, sum(case when result &#x3D; “lose” then 1 else 0 end) as “lose”from info group by date;\n(2) select a.date, a.result as win, b.result as lose\n　　from\n　　(select date, count(result) as result from info where result &#x3D;“win” group by date) as a\n　　join\n　　(select date, count(result) as result from info where result &#x3D;“lose” group by date) as b\non a.date &#x3D; b.date;\n9.3.11 手写HQL 第11题有一个订单表order。已知字段有：order_id(订单ID),user_id(用户ID),amount(金额),pay_datetime(付费时间),channel_id(渠道ID),dt(分区字段)。\n\n在Hive中创建这个表。\n\n查询dt&#x3D;’2018-09-01’里每个渠道的订单数，下单人数（去重），总金额。\n\n查询dt&#x3D;’2018-09-01’里每个渠道的金额最大3笔订单。\n\n有一天发现订单数据重复，请分析原因\n\n\ncreate external table order(\norder_id int,\nuser_id int,\namount double,\npay_datatime timestamp,\nchannel_id int\n)partitioned by(dt string)\nrow format delimited fields terminated by ‘t’;\nselect\ncount(order_id),\ncount(distinct(user_id))\nsum(amount)\nfrom\norder\nwhere dt&#x3D;”2019-09-01”\nselect\norder_id\nchannel_id\nchannel_id_amount\nfrom(\nselect\norder_id\nchannel_id,\namount,\nmax(amount) over(partition by channel_id)\nmin(amount) over(partition by channel_id)\nrow_number()\nover(\npartition by channel_id\norder by amount desc\n)rank\nfrom\norder\nwhere dt&#x3D;”2019-09-01”\n)t\nwhere t.rank&lt;4\n订单属于业务数据，在关系型数据库中不会存在数据重复\nhive建表时也不会导致数据重复，\n我推测是在数据迁移时，迁移失败导致重复迁移数据冗余了\nt_order订单表\norder_id,&#x2F;&#x2F;订单id\nitem_id, &#x2F;&#x2F;商品id\ncreate_time,&#x2F;&#x2F;下单时间\namount&#x2F;&#x2F;下单金额\nt_item商品表\nitem_id,&#x2F;&#x2F;商品id\nitem_name,&#x2F;&#x2F;商品名称\ncategory&#x2F;&#x2F;品类\nt_item商品表\nitem_id,&#x2F;&#x2F;商品id\nitem_name,&#x2F;&#x2F;名称\ncategory_1,&#x2F;&#x2F;一级品类\ncategory_2,&#x2F;&#x2F;二级品类\n\n最近一个月，销售数量最多的10个商品\n\nselect\nitem_id,\ncount(order_id)a\nfrom\nt_order\nwhere\ndataediff(create_time,current_date)&lt;&#x3D;30\ngroup by\nitem_id\norder by a desc;\n\n最近一个月，每个种类里销售数量最多的10个商品\n\n#一个订单对应一个商品 一个商品对应一个品类\nwith(\nselect\norder_id,\nitem_id,\nitem_name,\ncategory\nfrom\nt_order\njoin\nt_item\non\nt_order.item_id &#x3D; t_item.item_id\n) t\nselect\norder_id,\nitem_id,\nitem_name,\ncategory,\ncount(item_id)over(\npartition by category\n)item_count\nfrom\nt\ngroup by category\norder by item_count desc\nlimit 10;\n计算平台的每一个用户发过多少日记、获得多少点赞数\nwith t3 as(\nselect * from\nt1 left join t2\non t1.log_id &#x3D; t2.log_id\n)\nselect\nuid,&#x2F;&#x2F;用户Id\ncount(log_id)over(partition by uid)log_cnt,&#x2F;&#x2F;\ncount(like_uid)over(partition by log_id)liked_cnt&#x2F;&#x2F;获得多少点赞数\nfrom\nt3\n处理产品版本号\n1、需求A:找出T1表中最大的版本号\n思路：列转行 切割版本号 一列变三列\n主版本号 子版本号 阶段版本号\nwith t2 as(&#x2F;&#x2F;转换\nselect\nv_id v1,&#x2F;&#x2F;版本号\nv_id v2 &#x2F;&#x2F;主\nfrom\nt1\nlateral view explode(v2) tmp as v2\n)\nselect &#x2F;&#x2F;第一层 找出第一个\nv1,\nmax(v2)\nfrom\nt2\n\n1、需求A:找出T1表中最大的版本号\nselect\nv_id,&#x2F;&#x2F;版本号\nmax(split(v_id,”.”)[0]) v1,&#x2F;&#x2F;主版本不会为空\nmax(if(split(v_id,”.”)[1]&#x3D;””,0,split(v_id,”.”)[1]))v2,&#x2F;&#x2F;取出子版本并判断是否为空，并给默认值\nmax(if(split(v_id,”.”)[2]&#x3D;””,0,split(v_id,”.”)[2]))v3&#x2F;&#x2F;取出阶段版本并判断是否为空，并给默认值\nfrom\nt1\n2、需求B：计算出如下格式的所有版本号排序，要求对于相同的版本号，顺序号并列：\nselect\nv_id,\nrank() over(partition by v_id order by v_id)seq\nfrom\nt1\n9.3.12 连续问题如下数据为蚂蚁森林中用户领取的减少碳排放量\n\n\n\n\n\n\n\n\n\nid dt lowcarbon\n1001 2021-12-12 123\n1002 2021-12-12 45\n1001 2021-12-13 43\n1001 2021-12-13 45\n1001 2021-12-13 23\n1002 2021-12-14 45\n1001 2021-12-14 230\n1002 2021-12-15 45\n1001 2021-12-15 23\n… …\n找出连续3天及以上减少碳排放量在100以上的用户\n1)按照用户ID及时间字段分组,计算每个用户单日减少的碳排放量\nselect\nid,\ndt,\nsum(lowcarbon) lowcarbon\nfrom test1\ngroup by id,dt\nhaving lowcarbon&gt;100;t1\n1001 2021-12-12 123\n1001 2021-12-13 111\n1001 2021-12-14 230\n等差数列法:两个等差数列如果等差相同,则相同位置的数据相减等到的结果相同\n2)按照用户分组,同时按照时间排序,计算每条数据的Rank值\nselect\nid,\ndt,\nlowcarbon,\nrank() over(partition by id order by dt) rk\nfrom t1;t2\n3)将每行数据中的日期减去Rank值\nselect\nid,\ndt,\nlowcarbon,\ndate_sub(dt,rk) flag\nfrom t2;t3\n4)按照用户及Flag分组,求每个组有多少条数据,并找出大于等于3条的数据\nselect\nid,\nflag,\ncount(*) ct\nfrom t3\ngroup by id,flag\nhaving ct&gt;&#x3D;3;\n5)最终HQL\nselect\nid,\nflag,\ncount(*) ct\nfrom\n(select\nid,\ndt,\nlowcarbon,\ndate_sub(dt,rk) flag\nfrom\n(select\nid,\ndt,\nlowcarbon,\nrank() over(partition by id order by dt) rk\nfrom\n(select\nid,\ndt,\nsum(lowcarbon) lowcarbon\nfrom test1\ngroup by id,dt\nhaving lowcarbon&gt;100)t1)t2)t3\ngroup by id,flag\nhaving ct&gt;&#x3D;3;\n9.3.13 分组问题如下为电商公司用户访问时间数据\n\n\n\n\n\n\n\n\n\nid ts(秒)\n1001 17523641234\n1001 17523641256\n1002 17523641278\n1001 17523641334\n1002 17523641434\n1001 17523641534\n1001 17523641544\n1002 17523641634\n1001 17523641638\n1001 17523641654\n某个用户连续的访问记录如果时间间隔小于60秒，则分为同一个组，结果为：\n\n\n\n\n\n\n\n\n\nid ts(秒) group\n1001 17523641234 1\n1001 17523641256 1\n1001 17523641334 2\n1001 17523641534 3\n1001 17523641544 3\n1001 17523641638 4\n1001 17523641654 4\n1002 17523641278 1\n1002 17523641434 2\n1002 17523641634 3\n1)将上一行时间数据下移\nlead:领导\nlag:延迟\nselect\nid,\nts,\nlag(ts,1,0) over(partition by id order by ts) lagts\nfrom\ntest2;t1\n1001 17523641234 0\n1001 17523641256 17523641234\n1001 17523641334 17523641256\n1001 17523641534 17523641334\n1001 17523641544 17523641534\n1001 17523641638 17523641544\n1001 17523641654 17523641638\n1002 17523641278 0\n1002 17523641434 17523641278\n1002 17523641634 17523641434\n2)将当前行时间数据减去上一行时间数据\nselect\nid,\nts,\nts-lagts tsdiff\nfrom\nt1;t2\nselect\nid,\nts,\nts-lagts tsdiff\nfrom\n(select\nid,\nts,\nlag(ts,1,0) over(partition by id order by ts) lagts\nfrom\ntest2)t1;t2\n1001 17523641234 17523641234\n1001 17523641256 22\n1001 17523641334 78\n1001 17523641534 200\n1001 17523641544 10\n1001 17523641638 94\n1001 17523641654 16\n1002 17523641278 17523641278\n1002 17523641434 156\n1002 17523641634 200\n3)计算每个用户范围内从第一行到当前行tsdiff大于等于60的总个数(分组号)\nselect\nid,\nts,\nsum(if(tsdiff&gt;&#x3D;60,1,0)) over(partition by id order by ts) groupid\nfrom\nt2;\n4)最终HQL\nselect\nid,\nts,\nsum(if(tsdiff&gt;&#x3D;60,1,0)) over(partition by id order by ts) groupid\nfrom\n(select\nid,\nts,\nts-lagts tsdiff\nfrom\n(select\nid,\nts,\nlag(ts,1,0) over(partition by id order by ts) lagts\nfrom\ntest2)t1)t2;\n9.3.14 间隔连续问题某游戏公司记录的用户每日登录数据\n\n\n\n\n\n\n\n\n\nid dt\n1001 2021-12-12\n1002 2021-12-12\n1001 2021-12-13\n1001 2021-12-14\n1001 2021-12-16\n1002 2021-12-16\n1001 2021-12-19\n1002 2021-12-17\n1001 2021-12-20\n计算每个用户最大的连续登录天数，可以间隔一天。解释：如果一个用户在1,3,5,6登录游戏，则视为连续6天登录。\n思路一：等差数列\n1001 2021-12-12 1\n1001 2021-12-13 2\n1001 2021-12-14 3\n1001 2021-12-16 4\n1001 2021-12-19 5\n1001 2021-12-20 6\n1001 2021-12-12 1 2021-12-11\n1001 2021-12-13 2 2021-12-11\n1001 2021-12-14 3 2021-12-11\n1001 2021-12-16 4 2021-12-12\n1001 2021-12-19 5 2021-12-14\n1001 2021-12-20 6 2021-12-14\n1001 2021-12-11 3\n1001 2021-12-12 1\n1001 2021-12-14 1\n1001 2021-12-11 3 1\n1001 2021-12-12 1 2\n1001 2021-12-14 1 3\n1001 2021-12-11 3 1 2021-12-10\n1001 2021-12-12 1 2 2021-12-10\n1001 2021-12-14 1 3 2021-12-11\n思路二：分组\n1001 2021-12-12\n1001 2021-12-13\n1001 2021-12-14\n1001 2021-12-16\n1001 2021-12-19\n1001 2021-12-20\n1)将上一行时间数据下移\n1001 2021-12-12 1970-01-01\n1001 2021-12-13 2021-12-12\n1001 2021-12-14 2021-12-13\n1001 2021-12-16 2021-12-14\n1001 2021-12-19 2021-12-16\n1001 2021-12-20 2021-12-19\nselect\nid,\ndt,\nlag(dt,1,’1970-01-01’) over(partition by id order by dt) lagdt\nfrom\ntest3;t1\n2)将当前行时间减去上一行时间数据(datediff(dt1,dt2))\n1001 2021-12-12 564564\n1001 2021-12-13 1\n1001 2021-12-14 1\n1001 2021-12-16 2\n1001 2021-12-19 3\n1001 2021-12-20 1\nselect\nid,\ndt,\ndatediff(dt,lagdt) flag\nfrom\nt1;t2\n3)按照用户分组,同时按照时间排序,计算从第一行到当前行大于2的数据的总条数(sum(if(flag&gt;2,1,0)))\n1001 2021-12-12 1\n1001 2021-12-13 1\n1001 2021-12-14 1\n1001 2021-12-16 1\n1001 2021-12-19 2\n1001 2021-12-20 2\nselect\nid,\ndt,\nsum(if(flag&gt;2,1,0)) over(partition by id order by dt) flag\nfrom\nt2;t3\n4)按照用户和flag分组,求最大时间减去最小时间并加上1\nselect\nid,\nflag,\ndatediff(max(dt),min(dt)) days\nfrom\nt3\ngroup by id,flag;t4\n5)取连续登录天数的最大值\nselect\nid,\nmax(days)+1\nfrom\nt4\ngroup by id;\n6)最终HQL\nselect\nid,\nmax(days)+1\nfrom\n(select\nid,\nflag,\ndatediff(max(dt),min(dt)) days\nfrom\n(select\nid,\ndt,\nsum(if(flag&gt;2,1,0)) over(partition by id order by dt) flag\nfrom\n(select\nid,\ndt,\ndatediff(dt,lagdt) flag\nfrom\n(select\nid,\ndt,\nlag(dt,1,’1970-01-01’) over(partition by id order by dt) lagdt\nfrom\ntest3)t1)t2)t3\ngroup by id,flag)t4\ngroup by id;\n9.3.15 打折日期交叉问题如下为平台商品促销数据：字段为品牌，打折开始日期，打折结束日期\n\n\n\n\n\n\n\n\n\nbrand stt edt\noppo 2021-06-05 2021-06-09\noppo 2021-06-11 2021-06-21\nvivo 2021-06-05 2021-06-15\nvivo 2021-06-09 2021-06-21\nredmi 2021-06-05 2021-06-21\nredmi 2021-06-09 2021-06-15\nredmi 2021-06-17 2021-06-26\nhuawei 2021-06-05 2021-06-26\nhuawei 2021-06-09 2021-06-15\nhuawei 2021-06-17 2021-06-21\n计算每个品牌总的打折销售天数，注意其中的交叉日期，比如vivo品牌，第一次活动时间为2021-06-05到2021-06-15，第二次活动时间为2021-06-09到2021-06-21其中9号到15号为重复天数，只统计一次，即vivo总打折天数为2021-06-05到2021-06-21共计17天。\n1)将当前行以前的数据中最大的edt放置当前行\nselect\nid,\nstt,\nedt,\nmax(edt) over(partition by id order by stt rows between UNBOUNDEDPRECEDING and 1 PRECEDING) maxEdt\nfrom test4;t1\nredmi 2021-06-05 2021-06-21 null\nredmi 2021-06-09 2021-06-15 2021-06-21\nredmi 2021-06-17 2021-06-26 2021-06-21\n2)比较开始时间与移动下来的数据,如果开始时间大,则不需要操作,\n反之则需要将移动下来的数据加一替换当前行的开始时间\n如果是第一行数据,maxEDT为null,则不需要操作\nselect\nid,\nif(maxEdt is null,stt,if(stt&gt;maxEdt,stt,date_add(maxEdt,1))) stt,\nedt\nfrom t1;t2\nredmi 2021-06-05 2021-06-21\nredmi 2021-06-22 2021-06-15\nredmi 2021-06-22 2021-06-26\n3)将每行数据中的结束日期减去开始日期\nselect\nid,\ndatediff(edt,stt) days\nfrom\nt2;t3\nredmi 16\nredmi -4\nredmi 4\n4)按照品牌分组,计算每条数据加一的总和\nselect\nid,\nsum(if(days&gt;&#x3D;0,days+1,0)) days\nfrom\nt3\ngroup by id;\nredmi 22\n5)最终HQL\nselect\nid,\nsum(if(days&gt;&#x3D;0,days+1,0)) days\nfrom\n(select\nid,\ndatediff(edt,stt) days\nfrom\n(select\nid,\nif(maxEdt is null,stt,if(stt&gt;maxEdt,stt,date_add(maxEdt,1))) stt,\nedt\nfrom\n(select\nid,\nstt,\nedt,\nmax(edt) over(partition by id order by stt rows between UNBOUNDEDPRECEDING and 1 PRECEDING) maxEdt\nfrom test4)t1)t2)t3\ngroup by id;\n9.3.16 同时在线问题如下为某直播平台主播开播及关播时间，根据该数据计算出平台最高峰同时在线的主播人数。\n\n\n\n\n\n\n\n\n\nid stt edt\n1001 2021-06-14 12:12:12 2021-06-14 18:12:12\n1003 2021-06-14 13:12:12 2021-06-14 16:12:12\n1004 2021-06-14 13:15:12 2021-06-14 20:12:12\n1002 2021-06-14 15:12:12 2021-06-14 16:12:12\n1005 2021-06-14 15:18:12 2021-06-14 20:12:12\n1001 2021-06-14 20:12:12 2021-06-14 23:12:12\n1006 2021-06-14 21:12:12 2021-06-14 23:15:12\n1007 2021-06-14 22:12:12 2021-06-14 23:10:12\n… …\n1)对数据分类,在开始数据后添加正1,表示有主播上线,同时在关播数据后添加-1,表示有主播下线\nselect id,stt dt,1 p from test5\nunion\nselect id,edt dt,-1 p from test5;t1\n1001 2021-06-14 12:12:12 1\n1001 2021-06-14 18:12:12 -1\n1001 2021-06-14 20:12:12 1\n1001 2021-06-14 23:12:12 -1\n1002 2021-06-14 15:12:12 1\n1002 2021-06-14 16:12:12 -1\n1003 2021-06-14 13:12:12 1\n1003 2021-06-14 16:12:12 -1\n1004 2021-06-14 13:15:12 1\n1004 2021-06-14 20:12:12 -1\n1005 2021-06-14 15:18:12 1\n1005 2021-06-14 20:12:12 -1\n1006 2021-06-14 21:12:12 1\n1006 2021-06-14 23:15:12 -1\n1007 2021-06-14 22:12:12 1\n1007 2021-06-14 23:10:12 -1\n2)按照时间排序,计算累加人数\nselect\nid,\ndt,\nsum(p) over(order by dt) sum_p\nfrom\n(select id,stt dt,1 p from test5\nunion\nselect id,edt dt,-1 p from test5)t1;t2\n3)找出同时在线人数最大值\nselect\nmax(sum_p)\nfrom\n(select\nid,\ndt,\nsum(p) over(order by dt) sum_p\nfrom\n(select id,stt dt,1 p from test5\nunion\nselect id,edt dt,-1 p from test5)t1)t2;\n第10章 JavaSE10.1 HashMap底层源码，数据结构hashMap的底层结构在jdk1.7中由数组+链表实现，在jdk1.8中由数组+链表+红黑树实现，以数组+链表的结构为例。\n{width&#x3D;”5.761805555555555in”height&#x3D;”2.2090277777777776in”}\n{width&#x3D;”5.7659722222222225in”height&#x3D;”3.183333333333333in”}\nJDK1.8之前Put方法：\n{width&#x3D;”5.405555555555556in”height&#x3D;”5.988888888888889in”}\nJDK1.8之后Put方法：\n{width&#x3D;”5.708333333333333in”height&#x3D;”7.023611111111111in”}\n10.2 Java自带哪几种线程池？\n\n\n\n\n\n\n\n\n1）newCachedThreadPool\n创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：\n工作线程的创建数量几乎没有限制（其实也有限制的，数目为Interger.MAX_VALUE）, 这样可灵活的往线程池中添加线程。\n如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为1分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。\n在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n\n\n\n\n\n\n\n\n2）newFixedThreadPool\n创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n\n\n\n\n\n\n\n\n3）newSingleThreadExecutor\n创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO,LIFO,优先级）执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。\n\n\n\n\n\n\n\n\n\n4）newScheduleThreadPool\n创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。延迟3秒执行。\n10.3 HashMap和HashTable区别\n线程安全性不同\n\nHashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTabl，但是使用HashMap时必须自己增加同步处理。\n\n是否提供contains方法\n\nHashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。\n\nkey和value是否允许null值\n\nHashtable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。\n\n数组初始化和扩容机制\n\n HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。\n Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。\n10.4 TreeSet和HashSet区别HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。\nTreeSet是采用树结构实现（红黑树算法）。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log(n))的方法。它还提供了一些方法来处理排序的set，如first()，last()，headSet()，tailSet()等等。\n10.5 String buffer和String build区别1、StringBuffer与StringBuilder中的方法和功能完全是等价的。\n2、只是StringBuffer中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而StringBuilder没有这个修饰，可以被认为是线程不安全的。 \n3、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低\n10.6 Final、Finally、Finalizefinal：修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。\nfinally：通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。\nfinalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。\n10.7 &#x3D;&#x3D;和Equals区别 &#x3D;&#x3D; : 如果比较的是基本数据类型，那么比较的是变量的值\n如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）\n equals:如果没重写equals方法比较的是两个对象的地址值。\n 如果重写了equals方法后我们往往比较的是对象中的属性的内容\nequals方法是从Object类中继承的，默认的实现就是使用&#x3D;&#x3D;\n{width&#x3D;”4.454861111111111in”height&#x3D;”0.6979166666666666in”}\n第11章 Redis11.1 缓存穿透、缓存雪崩、缓存击穿1）缓存穿透是指查询一个一定不存在的数据。由于缓存命不中时会去查询数据库，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。\n解决方案：\n\n是将空对象也缓存起来，并给它设置一个很短的过期时间，最长不超过5分钟\n\n②采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力\n2）如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就会造成缓存雪崩。\n解决方案：\n尽量让失效的时间点不分布在同一个时间点\n3）缓存击穿，是指一个key非常热点，在不停的扛着大并发，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n解决方案：\n可以设置key永不过期\n11.2 哨兵模式主从复制中反客为主的自动版，如果主机Down掉，哨兵会从从机中选择一台作为主机，并将它设置为其他从机的主机，而且如果原来的主机再次启动的话也会成为从机。\n10.3 数据类型\n  string              字符串  list                可以重复的集合  set                 不可以重复的集合  hash                类似于Map&lt;String,String&gt;  zset(sorted set）   带分数的set\n\n11.4 持久化1）RDB持久化：\n\n在指定的时间间隔内持久化\n\n服务shutdown会自动持久化\n\n\n③ 输入bgsave也会持久化\n2）AOF : 以日志形式记录每个更新操作\nRedis重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。\n保存策略：\n推荐（并且也是默认）的措施为每秒持久化一次，这种策略可以兼顾速度和安全性。\n缺点：\n1 比起RDB占用更多的磁盘空间\n2 恢复备份速度要慢\n3 每次读写都同步的话，有一定的性能压力\n4 存在个别Bug，造成恢复不能\n选择策略：\n官方推荐：\n如果对数据不敏感，可以选单独用RDB；不建议单独用AOF，因为可能出现Bug;如果只是做纯内存缓存，可以都不用\n11.5 悲观锁执行操作前假设当前的操作肯定（或有很大几率）会被打断（悲观）。基于这个假设，我们在做操作前就会把相关资源锁定，不允许自己执行期间有其他操作干扰。\n11.6 乐观锁执行操作前假设当前操作不会被打断（乐观）。基于这个假设，我们在做操作前不会锁定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。Redis使用的就是乐观锁。\n第12章 MySql12.1 MyISAM与InnoDB的区别+———————–+———————–+———————–+| 对比项            | MyISAM            | InnoDB            |+———————–+———————–+———————–+| 外键              | 不支持            | 支持              |+———————–+———————–+———————–+| 事务              | 不支持            | 支持              |+———————–+———————–+———————–+| 行表锁            | 表锁，即使操作一条记录也会锁住整个表， | 行锁,操作时只锁某一行，不对其它行有影 ||                       | 不适合高并发的操作  | 响，                ||                       |                       |                       ||                       |                       | 适合高并发的操作  |+———————–+———————–+———————–+| 缓存              | 只缓存索引，不缓存真实数据 | *不仅缓存索引还要缓存真实数据，对内存要 ||                       |                       | 求较高，而且内存大小对性能有决定性的影响 ||                       |                       | *                     |+———————–+———————–+———————–+\n12.2 索引优化数据结构：B+Tree\n一般来说能够达到range就可以算是优化了 idx name_deptId\n口诀（两个法则加6种索引失效的情况）\n全值匹配我最爱，最左前缀要遵守；\n带头大哥不能死，中间兄弟不能断；\n索引列上少计算，范围之后全失效；\nLIKE百分写最右，覆盖索引不写*；\n不等空值还有OR，索引影响要注意；\nVAR引号不可丢，SQL优化有诀窍。\n12.3 b-tree和b+tree的区别\nB-树的关键字、索引和记录是放在一起的，B+树的[非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。]{.underline}\n\n在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中[每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。]{.underline}\n\n\n12.4 redis是单线程的，为什么那么快1)完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。\n2)数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的\n3)采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗\n4)使用多路I&#x2F;O复用模型，非阻塞IO\n5)使用[底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求]{.underline}\n12.5 MySQL的事务一、事务的基本要素（ACID）\n1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位\n2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。\n3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。\n4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。\n二、事务的并发问题\n1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n2、不可重复读：事务 A 多次读取同一数据，事务 B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致\n3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表\n三、MySQL事务隔离级别\n事务隔离级别 脏读 不可重复读 幻读\n读未提交（read-uncommitted） 是 是 是\n不可重复读（read-committed） 否 是 是\n可重复读（repeatable-read） 否 否 是\n串行化（serializable） 否 否 否\n第13章 JVM13.1 JVM内存分哪几个区，每个区的作用是什么?{width&#x3D;”5.458333333333333in”height&#x3D;”4.927083333333333in”}\njava虚拟机主要分为以下几个区:\n\n方法区：\n\n\n\na.  有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载\nb.  方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。\nc.  该区域是被线程共享的。\nd.  方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。\n\n\n\n虚拟机栈:\n\n\n\na.  虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。\nb.  虚拟机栈是线程私有的，它的生命周期与线程相同。\nc.  局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定\nd.  操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式\ne.  每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。\n\n\n\n本地方法栈：本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。\n\n堆：\n\n\njava堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。\n\n程序计数器：\n\n内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。\n13.2 Java类加载过程?Java类加载需要经历一下几个过程：\n\n加载\n\n加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：\na.  通过一个类的全限定名获取该类的二进制流。\nb.  将该二进制流中的静态存储结构转化为方法去运行时数据结构。 \nc.  在内存中生成该类的Class对象，作为该类的数据访问入口。\n\n\n\n验证\n\n验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:\na.  文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.\nb.  元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。\nc.  字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。\nd.  符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。\ne.  准备\n准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。\n\n解析\n\n该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。\n\n初始化\n\n初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。\n13.3 java中垃圾收集的方法有哪些?1）引用计数法   应用于：微软的COM&#x2F;ActionScrip3&#x2F;Python等\na) 如果对象没有被引用，就会被回收，缺点：需要维护一个引用计算器\n2）复制算法 年轻代中使用的是MinorGC，这种GC算法采用的是复制算法(Copying)\na) 效率高，缺点：需要内存容量大，比较耗内存\nb) 使用在占空间比较小、刷新次数多的新生区\n3）标记清除 老年代一般是由标记清除或者是标记清除与标记整理的混合实现\na) 效率比较低，会差生碎片。\n4）标记压缩 老年代一般是由标记清除或者是标记清除与标记整理的混合实现\na) 效率低速度慢，需要移动对象，但不会产生碎片。\n5）标记清除压缩标记清除-标记压缩的集合，多次GC后才Compact\na) 使用于占空间大刷新次数少的养老区，是3 4的集合体\n13.4 如何判断一个对象是否存活?(或者GC对象的判定方法)判断一个对象是否存活有两种方法:\n\n引用计数法\n\n可达性算法(引用链法)\n\n\n13.5 什么是类加载器，类加载器有哪些?实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。\n主要有一下四种类加载器:\n\n启动类加载器(BootstrapClassLoader)用来加载java核心类库，无法被java程序直接引用。\n\n扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载Java 类。\n\n系统类加载器（system class loader）也叫应用类加载器：它根据 Java应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。\n\n用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。\n\n\n13.6 简述Java内存分配与回收策略以及Minor GC和Major GC（full GC）内存分配：\n\n栈区：栈分为java虚拟机栈和本地方法栈\n\n堆区：堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，Fromsurvivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比8:1:1。\n\n方法区：被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanmentgeneration）\n\n程序计数器：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。线程私有的。\n\n\n回收策略以及Minor GC和Major GC：\n\n对象优先在堆的Eden区分配。\n\n大对象直接进入老年代。\n\n长期存活的对象将直接进入老年代。\n\n\n当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.MinorGC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;FullGc&#x2F;Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发MinorGC,但是通过配置，可以在Full GC之前进行一次MinorGC这样可以加快老年代的回收速度。\n第14章 JUC14.1 Synchronized与Lock的区别\n1）Synchronized能实现的功能Lock都可以实现，而且Lock比Synchronized更好用，更灵活。\n2）Synchronized可以自动上锁和解锁；Lock需要手动上锁和解锁\n14.2 Runnable和Callable的区别\n1）Runnable接口中的方法没有返回值；Callable接口中的方法有返回值\n2）Runnable接口中的方法没有抛出异常；Callable接口中的方法抛出了异常\n3）Runnable接口中的落地方法是call方法；Callable接口中的落地方法是run方法\n14.3 什么是分布式锁\n当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如Redis，通过set (key,value,nx,px,timeout)方法添加分布式锁。\n14.4 什么是分布式事务\n分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。\n第15章 面试说明15.1 面试过程最关键的是什么？1）大大方方的聊，放松\n2）体现优势，避免劣势\n15.2 面试时该怎么说？1）语言表达清楚\n（1）思维逻辑清晰，表达流畅\n（2）一二三层次表达\n2）所述内容不犯错\n（1）不说前东家或者自己的坏话\n（2）往自己擅长的方面说\n（3）实质，对考官来说，内容听过，就是自我肯定；没听过，那就是个学习的过程。\n15.3 面试技巧15.3.1 六个常见问题1）你的优点是什么？\n大胆的说出自己各个方面的优势和特长\n2）你的缺点是什么？\n不要谈自己真实问题；用”缺点”衬托自己的优点\n3）你的离职原因是什么？\n\n不说前东家坏话，哪怕被伤过\n\n合情合理合法\n\n不要说超过1个以上的原因\n\n\n4）您对薪资的期望是多少？\n\n非终面不深谈薪资\n\n只说区间，不说具体数字\n\n底线是不低于当前薪资\n\n非要具体数字，区间取中间值，或者当前薪资的+20%\n\n\n5）您还有什么想问的问题？\n\n这是体现个人眼界和层次的问题\n\n问题本身不在于面试官想得到什么样的答案，而在于你跟别的应聘者的对比\n\n标准答案：\n\n\n\n\n\n\n\n\n\n\n\n公司希望我入职后的3-6个月内，给公司解决什么样的问题\n公司（或者对这个部门）未来的战略规划是什么样子的？\n以你现在对我的了解，您觉得我需要多长时间融入公司？\n6）您最快多长时间能入职？\n一周左右，如果公司需要，可以适当提前。\n15.3.2 两个注意事项1）职业化的语言\n2）职业化的形象\n15.3.3 自我介绍（控制在4分半以内，不超过5分钟）1）个人基本信息\n2）工作履历\n时间、公司名称、任职岗位、主要工作内容、工作业绩、离职原因\n3）深度沟通（也叫压力面试）\n刨根问底下沉式追问（注意是下沉式，而不是发散式的）\n基本技巧：往自己熟悉的方向说\n第16章 LeetCode题目精选[https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa]{.underline}\n16.1 两数之和问题链接：https://leetcode-cn.com/problems/two-sum/\n16.1.1 问题描述给定一个整数数组 nums 和一个目标值target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n\n\n\n\n\n\n\n\n\n给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9\n\n因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9\n\n所以返回 [0, 1]\n\n16.1.2 参考答案\n\n\n\n\n\n\n\n\n\n\n\nclass Solution &#123;\n\npublic int[] twoSum(int[] nums, int target) &#123;\n\nMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n\nfor (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n\nint complement &#x3D; target - nums[i];\n\nif (map.containsKey(complement)) &#123;\n\nreturn new int[] &#123; map.get(complement), i &#125;;\n\n&#125;\n\nmap.put(nums[i], i);\n\n&#125;\n\nthrow new IllegalArgumentException(&quot;No two sum solution&quot;);\n\n&#125;\n\n&#125;\n\n\n\n16.2 爬楼梯问题链接：https://leetcode-cn.com/problems/climbing-stairs/\n16.2.1 问题描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意：给定 n 是一个正整数。\n示例 1：\n\n输入： 2\n\n输出： 2\n\n解释： 有两种方法可以爬到楼顶。\n\n1. 1 阶 + 1 阶\n\n2. 2 阶\n\n\n示例 2：\n\n输入： 3\n\n输出： 3\n\n解释： 有三种方法可以爬到楼顶。\n\n1. 1 阶 + 1 阶 + 1 阶\n\n2. 1 阶 + 2 阶\n\n3. 2 阶 + 1 阶\n\n\n16.2.2 参考答案\npublic class Solution &#123;\n\npublic int climbStairs(int n) &#123;\n\nif (n &#x3D;&#x3D; 1) &#123;\n\nreturn 1;\n\n&#125;\n\nint[] dp &#x3D; new int[n + 1];\n\ndp[1] &#x3D; 1;\n\ndp[2] &#x3D; 2;\n\nfor (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;\n\ndp[i] &#x3D; dp[i - 1] + dp[i - 2];\n\n&#125;\n\nreturn dp[n];\n\n&#125;\n\n&#125;\n\n\n16.3 翻转二叉树链接：https://leetcode-cn.com/problems/invert-binary-tree/\n16.3.1 问题描述翻转一棵二叉树。\n示例：\n输入：\n\n4\n\n&#x2F; \n\n2 7\n\n&#x2F;  &#x2F; \n\n1 3 6 9\n\n\n输出：\n\n4\n\n&#x2F; \n\n7 2\n\n&#x2F;  &#x2F; \n\n9 6 3 1\n\n\n16.3.2 参考答案\npublic TreeNode invertTree(TreeNode root) &#123;\n\nif (root &#x3D;&#x3D; null) &#123;\n\nreturn null;\n\n&#125;\n\nTreeNode right &#x3D; invertTree(root.right);\n\nTreeNode left &#x3D; invertTree(root.left);\n\nroot.left &#x3D; right;\n\nroot.right &#x3D; left;\n\nreturn root;\n\n&#125;\n\n\n16.4 反转链表链接：https://leetcode-cn.com/problems/reverse-linked-list/\n16.4.1 问题描述反转一个单链表。\n示例:\n\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n\n输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n\n\n16.4.2 参考答案\npublic ListNode reverseList(ListNode head) &#123;\n\nListNode prev &#x3D; null;\n\nListNode curr &#x3D; head;\n\nwhile (curr !&#x3D; null) &#123;\n\nListNode nextTemp &#x3D; curr.next;\n\ncurr.next &#x3D; prev;\n\nprev &#x3D; curr;\n\ncurr &#x3D; nextTemp;\n\n&#125;\n\nreturn prev;\n\n&#125;\n\n\n16.5 LRU缓存机制链接：https://leetcode-cn.com/problems/lru-cache/\n16.5.1 问题描述运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用)缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n获取数据 get(key) - 如果密钥 (key)存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。\n写入数据 put(key, value) -如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。\n进阶:\n你是否可以在 O(1) 时间复杂度内完成这两种操作？\n示例:\n\nLRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );\n\ncache.put(1, 1);\n\ncache.put(2, 2);\n\ncache.get(1); &#x2F;&#x2F; 返回 1\n\ncache.put(3, 3); &#x2F;&#x2F; 该操作会使得密钥 2 作废\n\ncache.get(2); &#x2F;&#x2F; 返回 -1 (未找到)\n\ncache.put(4, 4); &#x2F;&#x2F; 该操作会使得密钥 1 作废\n\ncache.get(1); &#x2F;&#x2F; 返回 -1 (未找到)\n\ncache.get(3); &#x2F;&#x2F; 返回 3\n\ncache.get(4); &#x2F;&#x2F; 返回 4\n\n\n16.5.2 参考答案\nclass LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;\n\nprivate int capacity;\n\npublic LRUCache(int capacity) &#123;\n\nsuper(capacity, 0.75F, true);\n\nthis.capacity &#x3D; capacity;\n\n&#125;\n\npublic int get(int key) &#123;\n\nreturn super.getOrDefault(key, -1);\n\n&#125;\n\npublic void put(int key, int value) &#123;\n\nsuper.put(key, value);\n\n&#125;\n\n@Override\n\nprotected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt;\neldest) &#123;\n\nreturn size() &gt; capacity;\n\n&#125;\n\n&#125;\n\n&#x2F;**\n\n* LRUCache 对象会以如下语句构造和调用:\n\n* LRUCache obj &#x3D; new LRUCache(capacity);\n\n* int param_1 &#x3D; obj.get(key);\n\n* obj.put(key,value);\n\n*&#x2F;\n\n\n16.6 最长回文子串链接：https://leetcode-cn.com/problems/longest-palindromic-substring/\n16.6.1 问题描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。\n示例 1：\n\n输入: &quot;babad&quot;\n\n输出: &quot;bab&quot;\n\n注意: &quot;aba&quot; 也是一个有效答案。\n\n\n示例 2：\n\n输入: &quot;cbbd&quot;\n\n输出: &quot;bb&quot;\n\n\n16.6.2 参考答案\npublic String longestPalindrome(String s) &#123;\n\nif (s &#x3D;&#x3D; null || s.length() &lt; 1) return &quot;&quot;;\n\nint start &#x3D; 0, end &#x3D; 0;\n\nfor (int i &#x3D; 0; i &lt; s.length(); i++) &#123;\n\nint len1 &#x3D; expandAroundCenter(s, i, i);\n\nint len2 &#x3D; expandAroundCenter(s, i, i + 1);\n\nint len &#x3D; Math.max(len1, len2);\n\nif (len &gt; end - start) &#123;\n\nstart &#x3D; i - (len - 1) &#x2F; 2;\n\nend &#x3D; i + len &#x2F; 2;\n\n&#125;\n\n&#125;\n\nreturn s.substring(start, end + 1);\n\n&#125;\n\nprivate int expandAroundCenter(String s, int left, int right) &#123;\n\nint L &#x3D; left, R &#x3D; right;\n\nwhile (L &gt;&#x3D; 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) &#x3D;&#x3D; s.charAt(R)) &#123;\n\nL--;\n\nR++;\n\n&#125;\n\nreturn R - L - 1;\n\n&#125;\n\n\n16.7 有效的括号链接：https://leetcode-cn.com/problems/valid-parentheses/\n16.7.1 问题描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n\n左括号必须以正确的顺序闭合。\n\n\n注意空字符串可被认为是有效字符串。\n示例 1:\n\n输入: &quot;()&quot;\n\n输出: true\n\n\n示例 2:\n\n输入: &quot;()[]&#123;&#125;&quot;\n\n输出: true\n\n\n示例 3:\n\n输入: &quot;(]&quot;\n\n输出: false\n\n\n示例 4:\n\n输入: &quot;([)]&quot;\n\n输出: false\n\n\n示例 5:\n\n输入: &quot;&#123;[]&#125;&quot;\n\n输出: true\n\n\n16.7.2 参考答案\nclass Solution &#123;\n\n&#x2F;&#x2F; Hash table that takes care of the mappings.\n\nprivate HashMap&lt;Character, Character&gt; mappings;\n\n&#x2F;&#x2F; Initialize hash map with mappings. This simply makes the code easier\nto read.\n\npublic Solution() &#123;\n\nthis.mappings &#x3D; new HashMap&lt;Character, Character&gt;();\n\nthis.mappings.put(&#39;)&#39;, &#39;(&#39;);\n\nthis.mappings.put(&#39;&#125;&#39;, &#39;&#123;&#39;);\n\nthis.mappings.put(&#39;]&#39;, &#39;[&#39;);\n\n&#125;\n\npublic boolean isValid(String s) &#123;\n\n&#x2F;&#x2F; Initialize a stack to be used in the algorithm.\n\nStack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();\n\nfor (int i &#x3D; 0; i &lt; s.length(); i++) &#123;\n\nchar c &#x3D; s.charAt(i);\n\n&#x2F;&#x2F; If the current character is a closing bracket.\n\nif (this.mappings.containsKey(c)) &#123;\n\n&#x2F;&#x2F; Get the top element of the stack. If the stack is empty, set a dummy\nvalue of &#39;#&#39;\n\nchar topElement &#x3D; stack.empty() ? &#39;#&#39; : stack.pop();\n\n&#x2F;&#x2F; If the mapping for this bracket doesn&#39;t match the stack&#39;s top\nelement, return false.\n\nif (topElement !&#x3D; this.mappings.get(c)) &#123;\n\nreturn false;\n\n&#125;\n\n&#125; else &#123;\n\n&#x2F;&#x2F; If it was an opening bracket, push to the stack.\n\nstack.push(c);\n\n&#125;\n\n&#125;\n\n&#x2F;&#x2F; If the stack still contains elements, then it is an invalid\nexpression.\n\nreturn stack.isEmpty();\n\n&#125;\n\n&#125;\n\n\n16.8 数组中的第K个最大元素链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\n16.8.1 问题描述在未排序的数组中找到第 k个最大的元素。请注意，你需要找的是数组排序后的第 k个最大的元素，而不是第 k 个不同的元素。\n示例 1:\n\n输入: [3,2,1,5,6,4] 和 k &#x3D; 2\n\n输出: 5\n\n\n示例 2:\n\n输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4\n\n输出: 4\n\n\n说明:\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n16.8.2 参考答案\nimport java.util.Random;\n\nclass Solution &#123;\n\nint [] nums;\n\npublic void swap(int a, int b) &#123;\n\nint tmp &#x3D; this.nums[a];\n\nthis.nums[a] &#x3D; this.nums[b];\n\nthis.nums[b] &#x3D; tmp;\n\n&#125;\n\npublic int partition(int left, int right, int pivot_index) &#123;\n\nint pivot &#x3D; this.nums[pivot_index];\n\n&#x2F;&#x2F; 1. move pivot to end\n\nswap(pivot_index, right);\n\nint store_index &#x3D; left;\n\n&#x2F;&#x2F; 2. move all smaller elements to the left\n\nfor (int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;\n\nif (this.nums[i] &lt; pivot) &#123;\n\nswap(store_index, i);\n\nstore_index++;\n\n&#125;\n\n&#125;\n\n&#x2F;&#x2F; 3. move pivot to its final place\n\nswap(store_index, right);\n\nreturn store_index;\n\n&#125;\n\npublic int quickselect(int left, int right, int k_smallest) &#123;\n\n&#x2F;*\n\nReturns the k-th smallest element of list within left..right.\n\n*&#x2F;\n\nif (left &#x3D;&#x3D; right) &#x2F;&#x2F; If the list contains only one element,\n\nreturn this.nums[left]; &#x2F;&#x2F; return that element\n\n&#x2F;&#x2F; select a random pivot_index\n\nRandom random_num &#x3D; new Random();\n\nint pivot_index &#x3D; left + random_num.nextInt(right - left);\n\npivot_index &#x3D; partition(left, right, pivot_index);\n\n&#x2F;&#x2F; the pivot is on (N - k)th smallest position\n\nif (k_smallest &#x3D;&#x3D; pivot_index)\n\nreturn this.nums[k_smallest];\n\n&#x2F;&#x2F; go left side\n\nelse if (k_smallest &lt; pivot_index)\n\nreturn quickselect(left, pivot_index - 1, k_smallest);\n\n&#x2F;&#x2F; go right side\n\nreturn quickselect(pivot_index + 1, right, k_smallest);\n\n&#125;\n\npublic int findKthLargest(int[] nums, int k) &#123;\n\nthis.nums &#x3D; nums;\n\nint size &#x3D; nums.length;\n\n&#x2F;&#x2F; kth largest is (N - k)th smallest\n\nreturn quickselect(0, size - 1, size - k);\n\n&#125;\n\n&#125;\n\n\n16.9 实现 Trie (前缀树)16.9.1 问题描述实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。\n示例:\n\nTrie trie &#x3D; new Trie();\n\ntrie.insert(&quot;apple&quot;);\n\ntrie.search(&quot;apple&quot;); &#x2F;&#x2F; 返回 true\n\ntrie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 false\n\ntrie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 true\n\ntrie.insert(&quot;app&quot;);\n\ntrie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 true\n\n\n说明:\n\n你可以假设所有的输入都是由小写字母 a-z 构成的。\n\n保证所有输入均为非空字符串。\n\n\n16.9.2 参考答案\nclass Trie &#123;\n\nprivate TrieNode root;\n\npublic Trie() &#123;\n\nroot &#x3D; new TrieNode();\n\n&#125;\n\n&#x2F;&#x2F; Inserts a word into the trie.\n\npublic void insert(String word) &#123;\n\nTrieNode node &#x3D; root;\n\nfor (int i &#x3D; 0; i &lt; word.length(); i++) &#123;\n\nchar currentChar &#x3D; word.charAt(i);\n\nif (!node.containsKey(currentChar)) &#123;\n\nnode.put(currentChar, new TrieNode());\n\n&#125;\n\nnode &#x3D; node.get(currentChar);\n\n&#125;\n\nnode.setEnd();\n\n&#125;\n\n&#x2F;&#x2F; search a prefix or whole key in trie and\n\n&#x2F;&#x2F; returns the node where search ends\n\nprivate TrieNode searchPrefix(String word) &#123;\n\nTrieNode node &#x3D; root;\n\nfor (int i &#x3D; 0; i &lt; word.length(); i++) &#123;\n\nchar curLetter &#x3D; word.charAt(i);\n\nif (node.containsKey(curLetter)) &#123;\n\nnode &#x3D; node.get(curLetter);\n\n&#125; else &#123;\n\nreturn null;\n\n&#125;\n\n&#125;\n\nreturn node;\n\n&#125;\n\n&#x2F;&#x2F; Returns if the word is in the trie.\n\npublic boolean search(String word) &#123;\n\nTrieNode node &#x3D; searchPrefix(word);\n\nreturn node !&#x3D; null &amp;&amp; node.isEnd();\n\n&#125;\n\n&#125;\n\n\n16.10 编辑距离链接：https://leetcode-cn.com/problems/edit-distance/\n16.10.1 问题描述给定两个单词 word1 和 word2，计算出将 word1 转换成 word2所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：\n\n插入一个字符\n\n删除一个字符\n\n替换一个字符\n\n\n示例 1:\n\n输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;\n\n输出: 3\n\n解释:\n\nhorse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)\n\nrorse -&gt; rose (删除 &#39;r&#39;)\n\nrose -&gt; ros (删除 &#39;e&#39;)\n\n\n示例 2:\n\n输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;\n\n输出: 5\n\n解释:\n\nintention -&gt; inention (删除 &#39;t&#39;)\n\ninention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)\n\nenention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)\n\nexention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)\n\nexection -&gt; execution (插入 &#39;u&#39;)\n\n\n16.10.2 参考答案\nclass Solution &#123;\n\npublic int minDistance(String word1, String word2) &#123;\n\nint n &#x3D; word1.length();\n\nint m &#x3D; word2.length();\n\n&#x2F;&#x2F; if one of the strings is empty\n\nif (n * m &#x3D;&#x3D; 0)\n\nreturn n + m;\n\n&#x2F;&#x2F; array to store the convertion history\n\nint [][] d &#x3D; new int[n + 1][m + 1];\n\n&#x2F;&#x2F; init boundaries\n\nfor (int i &#x3D; 0; i &lt; n + 1; i++) &#123;\n\nd[i][0] &#x3D; i;\n\n&#125;\n\nfor (int j &#x3D; 0; j &lt; m + 1; j++) &#123;\n\nd[0][j] &#x3D; j;\n\n&#125;\n\n&#x2F;&#x2F; DP compute\n\nfor (int i &#x3D; 1; i &lt; n + 1; i++) &#123;\n\nfor (int j &#x3D; 1; j &lt; m + 1; j++) &#123;\n\nint left &#x3D; d[i - 1][j] + 1;\n\nint down &#x3D; d[i][j - 1] + 1;\n\nint left_down &#x3D; d[i - 1][j - 1];\n\nif (word1.charAt(i - 1) !&#x3D; word2.charAt(j - 1))\n\nleft_down +&#x3D; 1;\n\nd[i][j] &#x3D; Math.min(left, Math.min(down, left_down));\n\n&#125;\n\n&#125;\n\nreturn d[n][m];\n\n&#125;\n\n&#125;\n\n","slug":"sgg大数据高频面试题","date":"2021-12-26T12:18:53.000Z","categories_index":"大数据","tags_index":"大数据","author_index":"CodingSeed"},{"id":"b4b469edf0864513cb59986e5c3c8faf","title":"TiKV学习","content":"[TOC]\n开源\n\n$ git config –global http.sslBackend “openssl”\n$ git config –global http.sslCAInfo “D:&#x2F;Software&#x2F;Program Files&#x2F;Git&#x2F;mingw64&#x2F;ssl&#x2F;cert.pem”\ngit clone https://github.com/tidb-incubator/tinysql.git\n建议课外阅读材料 \n◦ ⾸推 TinyKV 中的 reading list https://github.com/tidb-incubator/tinykv/blob/course/doc/reading_list.md \n◦ PCTP 课程 TinyKV 学习营专版（稍晚附上链接） \n◦ TiKV 源码系列 https://pingcap.com/zh/search?keywords=TiKV%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97\n\nSQL优化器\n统计信息–代价模型：最优执行计划\n\n\n\n\n\ntidb&#x2F;community:\n\n\n◦ TiKV 源码系列 https://pingcap.com/zh/search?keywords=TiKV%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97\nTiDB源码阅读系列文章：\nhttps://pingcap.com/zh/blog/?tag=TiDB%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB\nDDL：\nhttps://pingcap.com/zh/blog/tidb-source-code-reading-17\n\n\nmysql 改好了~\n\nlinux个人英雄主义\nhadoop竞争\n大佬主持管理  公开招募（开源3.0）   带薪开源！\nTiDB—知乎底层          学习、写论文\n———-mobaik摩拜单车\n\n\n\ngithub流程\n\n\n\n\n\n\n\n。。。\n\n\n\n\ntidb CICD\n\nmerge； contributor了\n开始学吧hhhhhhhhhhhh：\nhttps://github.com/pingcap/talent-plan\nCNCF基金会 有钱-&gt;CUB  云原生 灵活\nchaos mesh 测试平台\nhttps://www.codedump.info/post/20180921-raft/\nhttps://github.com/baidu/braft/blob/master/docs/cn/raft_protocol.md\nhttps://github.com/roseduan/rosedb\n可以在asktug（https://asktug.com）上 “学习与认证” 板块， Talent Plan 标签下提出、解答互助。（注意标题下面选择“学习认证”、“Talent Plan”标签）\n⑤第一次分享课时间为11月17号晚上8:00到9:40，zoom会议连接：https://pingcap.zoom.us/j/99814310864zoom会议号：998 1431 0864\nTalent Plan 分布式 KV 数据库编程线上学习营开营了 (creatby.com)\nGitHub - tidb-incubator&#x2F;tinykv: A course to build distributed key-value service based on TiKV model\n他的设计和raft论文还有差别，我想知道他是哪里调用的tick，他这里把心跳和日志都分开了\ntick函数干嘛的，那个上面注释说是给逻辑时钟提前一个时间步，什么情况会调用tick啊\nraftworker里面\netcd的raft module\nkv&#x2F;raftstore&#x2F;peer_msg_handler.go\nraft&#x2F;doc.go\n测试好评，raft层可以面向测试编程（不是\nhxdm,project1的意思是需要做这些事情吗？需要填满kv&#x2F;storage&#x2F;standalone_storage&#x2F;standalone_storage.go和kv&#x2F;server&#x2F;raw_api.go，然后涉及到的api是util&#x2F;engine_util下面的api？ （这些api是包装的badger）\n一些涉及到cf的操作engine_util里面都提供了\nutil&#x2F;engine_util下面的\nhttps://www.codedump.info/post/20180922-etcd-raft/\n翻译过raft作者的博士论文，相比ATC会议版多了不少细节的。大家感兴趣可以看看 https://github.com/LebronAl/raft-thesis-zh_cn\n谭新宇 你的github上6.824的lab笔记\nraft 的内容主要在博士论文上的前 6 章\n之前在研究tidb时想用c++来重新实现一遍tidb，然后写了一个golang to cpp的转换工具（基于AST来进行解析的）：https://github.com/awfeequdng/px_golang2cpp\n你用go的库函数，就可以把go源码解析成ast，然后把这个 ast -&gt; cpp 难度就不是很大了。\n6.824Lab3：\nhttps://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html\nhttps://blog.csdn.net/weixin_43116322/category_11250854.html\nPDCA\nhttps://learn.pingcap.com/learner/course/390002课程大纲\nTiDB 数据库架构概述\n\nonline DDL不会阻塞读写？？？\nhttps://www.jb51.net/article/40359.htm\nhttps://www.jb51.net/article/89030.htm\nDML（data manipulation language）：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言DDL（data definition language）：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用DCL（Data Control Language）：是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL\nhttps://blog.csdn.net/q2878948/article/details/96430129\n\nLSM tree（HBase存储引擎）的RocksDB引擎，WAL机制保证数据不丢持久化\nCFLock列簇\n+PD的全局TSO授时&#x3D;去中心化的2PC\n乐观悲观\n5.0后：2PC二阶异步提交\n提升性能-&gt;OLTP：高并发小SQL场景  降写入延迟\n3.多Raft\nregion动态扩展\nPD调度将热点数据块向其他节点拆分\n4.MVCC-&gt;并发控制 隔离级别 分布式事务 数据快速恢复\nk+version，v\nhistory GC回收\n5.提前SQL计算：过滤 部分聚合 max min\n并行\n\nhttps://www.cnblogs.com/lingchen-liang/p/1069019.html\n数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。\n\nOLTP：系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；\nOLAP：系统则强调数据分析，强调SQL执行时长，强调磁盘I&#x2F;O，强调分区等。\n\n联机事务处理（OLTP,On-line Transaction Processing），数据量少，DML频繁，并行事务处理多，但是一般都很短。使用一般用途或事务处理模板。\n联机分析处理（OLAP,On-line Analytical Processing），数据量大，DML少。使用数据仓库模板；\n决策支持系统（DDS，Decision support system)，典型的操作是全表扫描，长查询，长事务，但是一般事务的个数很少，往往是一个事务独占系统。\n\n【OLTP：Cache  批量buffer降IO  绑定变量存结果 简化SQL 分批快速提交  热块：分布不均 反向索引 增加回滚段             \n​    OLAP：SQL优化  分区技术、MV技术、并行技术及位图索引】\nOLTP系统最容易出现瓶颈的地方就是CPU与磁盘子系统。\n（1）CPU出现瓶颈常表现在逻辑读总量与计算性函数或者是过程上，【逻辑读总量&#x3D;单个语句的逻辑读*执行次数】，设计的方法与优化的方法就是减少单个语句的逻辑读，或者是减少它们的执行次数。另外，一些计算型的函数，如自定义函数、decode等的频繁使用，也会消耗大量的CPU时间，造成系统的负载升高，正确的设计方法或者是优化方法，需要尽量避免计算过程，如【保存计算结果到统计表就是一个好的方法】。\n（2）磁盘子系统在OLTP环境中，它的承载能力一般取决于它的【IOPS处理能力】. 因为在OLTP环境中，磁盘物理读一般都是db file sequential read，也就是单块读，但是这个读的次数非常频繁。如果频繁到磁盘子系统都不能承载其IOPS的时候，就会出现大的性能问题。\nOLTP比较常用的设计与优化方式为【Cache技术与B-tree索引技术】，Cache决定了很多语句不需要从磁盘子系统获得数据，所以，Web cache与Oracle data buffer对OLTP系统是很重要的。\n另外，在索引使用方面，语句越简单越好，这样执行计划也稳定，而且一定要使用绑定变量，减少语句解析，\n【尽量减少表关联，尽量减少分布式事务，基本不使用分区技术、MV技术、并行技术及位图索引。因为并发量很高，批量更新时要分批快速提交，以避免阻塞的发生。】\nOLTP 系统是一个数据块变化非常频繁，SQL 语句提交非常频繁的系统。 \n对于数据块来说，应尽可能让数据块保存在内存当中，对于SQL来说，尽可能使用变量绑定技术来达到SQL重用，减少物理I&#x2F;O 和重复的SQL 解析，从而极大的改善数据库的性能。\n这里影响性能除了绑定变量，还有可能是热块（hot block）。 当一个块被多个用户同时读取时，Oracle 为了维护数据的一致性，需要使用Latch来串行化用户的操作。当一个用户获得了latch后，其他用户就只能等待，获取这个数据块的用户越多，等待就越明显。 这就是热块的问题。 这种热快可能是数据块，也可能是回滚端块。 \n对于数据块来讲，通常是数据库的数据分布不均匀导致，如果是索引的数据块，可以考虑创建反向索引来达到重新分布数据的目的，对于回滚段数据块，可以适当多增加几个回滚段来避免这种争用。\nOLAP，也叫联机分析处理（Online Analytical Processing）系统，有的时候也叫DSS决策支持系统，就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB&#x2F;s的流量。\n磁盘子系统的吞吐量则往往取决于磁盘的个数，这个时候，Cache基本是没有效果的，数据库的读写类型基本上是db file scattered read与direct path read&#x2F;write。应尽量采用个数比较多的磁盘以及比较大的带宽，如4Gb的光纤接口。\n在OLAP系统中，常使用【分区技术、并行技术】。\n分区技术在OLAP系统中的重要性主要体现在数据库管理上，比如数据库加载，可以通过分区交换的方式实现，备份可以通过备份分区表空间实现，删除数据可以通过分区进行删除，至于分区在性能上的影响，它可以使得一些大表的扫描变得很快（只扫描单个分区）。另外，如果分区结合并行的话，也可以使得整个表的扫描会变得很快。总之，分区主要的功能是管理上的方便性，它并不能绝对保证查询性能的提高，有时候分区会带来性能上的提高，有时候会降低。\n并行技术除了与分区技术结合外，在Oracle 10g中，与RAC结合实现多节点的同时扫描，效果也非常不错，可把一个任务，如select的全表扫描，平均地分派到多个RAC的节点上去。\n在OLAP系统中，不需要使用绑定（BIND）变量，因为整个系统的执行量很小，分析时间对于执行时间来说，可以忽略，而且可避免出现错误的执行计划。但是OLAP中可以大量使用位图索引，物化视图，对于大的事务，尽量寻求速度上的优化，没有必要像OLTP要求快速提交，甚至要刻意减慢执行的速度。\n绑定变量真正的用途是在OLTP系统中，这个系统通常有这样的特点，用户并发数很大，用户的请求十分密集，并且这些请求的SQL 大多数是可以重复使用的。\n对于OLAP系统来说，绝大多数时候数据库上运行着的是报表作业，执行基本上是聚合类的SQL 操作，比如group by，这时候，把优化器模式设置为all_rows是恰当的。 而对于一些分页操作比较多的网站类数据库，设置为first_rows会更好一些。 但【有时候对于OLAP 系统，我们又有分页的情况下，我们可以考虑在每条SQL 中用hint。 如：Select a.* from table a;】\n分开设计与优化\n在设计上要特别注意，如在高可用的OLTP环境中，不要盲目地把OLAP的技术拿过来用。\n如分区技术，假设不是大范围地使用分区关键字，而采用其它的字段作为where条件，那么，【如果是本地索引，将不得不扫描多个索引，而性能变得更为低下。如果是全局索引，又失去分区的意义。】\n并行技术也是如此，一般在完成大型任务时才使用，如在实际生活中，翻译一本书，可以先安排多个人，每个人翻译不同的章节，这样可以提高翻译速度。如果只是翻译一页书，也去分配不同的人翻译不同的行，再组合起来，就没必要了，因为在分配工作的时间里，一个人或许早就翻译完了。\n位图索引也是一样，如果用在OLTP环境中，很容易造成阻塞与死锁。但是，在OLAP环境中，可能会因为其特有的特性，提高OLAP的查询速度。【MV也是基本一样，包括触发器等，在DML频繁的OLTP系统上，很容易成为瓶颈，甚至是Library Cache等待？？？】，而在OLAP环境上，则可能会因为使用恰当而提高查询速度。\n对于【OLAP系统，在内存上可优化的余地很小，增加CPU 处理速度和磁盘I&#x2F;O 速度】是最直接的提高数据库性能的方法，当然这也意味着系统成本的增加。\n比如我们要对几亿条或者几十亿条数据进行聚合处理，这种海量的数据，全部放在内存中操作是很难的，同时也没有必要，因为这些数据快很少重用，缓存起来也没有实际意义，而且还会造成物理I&#x2F;O相当大。 所以这种系统的瓶颈往往是磁盘I&#x2F;O上面的。\n对于【OLAP系统，SQL 的优化非常重要，因为它的数据量很大，做全表扫描和索引】对性能上来说差异是非常大的。\n\n  Namenode元数据存储  分配ID  授时  心跳ZK 监控面板\n\nHive   最有名的列式存储引擎是Parquet和ORC\nkudu\n1.OLAP\nMPB MapReduce 并行计算\n2.deltaMain组件实时更新多版本读取\nlearner角色\n3.TP AP分开\n&#x3D;&#x3D;4.【智能区分！！！】&#x3D;&#x3D;\n&#x2F;1. 【多选题】下列功能是由 TiKV 或 TiFlash 实现的为？（ 选 2 项 ）B、F\nA. 根据集群中 Region 的信息，发出调度指令  PD\nB. 对于 OLAP 和 OLTP 进行业务隔离\nC. 将关系型数据转化为 KV 存储进行持久化      TiDB Server\nD. 将 KV 存储转化为关系型数据返回给客户端  TiDB Server\nE. 配合 TiDB Server 生成事务的唯一 ID             PD\nF. 副本的高可用和一致性\n&#x2F;2. 【单选题】关于 TiKV 或 TiDB Server，下列说法不正确的是？C\n A. 数据被持久化在 TiKV 的 RocksDB 引擎中  \n B. 对于老版本数据的回收（GC），是由 TiDB Server 在 TiKV 上完成的  \n C. 两阶段提交的锁信息被持久化到 TiDB Server 中        TiKV\n D. Region 可以在多个 TiKV 节点上进行调度，但是需要 PD 节点发出调度指令 \nTiDB Server 架构原理简介\n\nSQL层：解析编译优化 执行计划分批执行 事务 Client用于交互STO时间戳等 onlineDDL    \nNoSQL转化  GC  cache\n无状态 LB\n\n\ntoken\nAST\n\nSQL合法性验证\n？？？？逻辑优化：列裁剪  maxmin消除 投影消除 谓词下推 子查询 外联变内联\n物理优化：依据数据分布大小行数统计信息看用哪个算子，走哪个索引还是全表扫描\n​                     优化表的连接&#x2F;读取方式 顺序排序\n“导游图”取数据\n【KV转化】\n\n聚簇表：主键做Key\n\n\n非聚簇表：生成唯一ID\n\nNode Region k-&gt;v\n\nDistSQL处理复杂SQL：范围查询 表联接 嵌套查询          拆为单表多Region操作的组合\nPointCat点查  等值查询  简单 单行：  走KV\nRow KV req   &#x2F;  过滤聚合投影\n获取TSO事务提交时间！\n\n&#x3D;&#x3D;online DDL？？？&#x3D;&#x3D;\nowner Server：取job执行    选举、任期。。。\n上任后同步schema缓存\nhttps://zhuanlan.zhihu.com/p/60746830\n1. SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL\n1、数据定义语言DDL数据定义语言DDL用来创建数据库中的各种对象—–表、视图、—————————索引、同义词、聚簇等如：&#x3D;&#x3D;CREATE&#x3D;&#x3D; TABLE&#x2F;VIEW&#x2F;INDEX&#x2F;SYN&#x2F;CLUSTER————–表 —-视图- 索引- 同义词— 簇\n2.数据操纵语言DML主要有三种形式：\n–1) 插入：INSERT–2) 更新：UPDATE–3) 删除：DELETE数据查\n3.询语言DQL（data query language）基本结构–1）选择：SELECT子句\n&#x2F;4. 数据控制语言DCL数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：\n\nGRANT：授权。\nROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。—-回滚—ROLLBACK—-回滚命令使数据库状态回到上次最后提交的状态。其格式为：——SQL&gt;ROLLBACK;\nCOMMIT [WORK]：提交。\n\n【KV持久化】\n\nMVCC：history data+时间戳\nversion过多  定期清理\nsafepoint&#x3D;10:00  保留10:00以后的\n保留GC lifetime&#x3D;10min 内的历史版本\n过期数据unlock，drop 、delete数据清除\n\nmaxsize\n中断error &#x2F;记日志\n下列哪些模块直接与 TiDB 的事务处理有关？（ 选 2 项 ） A. KV 点查、D. Transaction\n关于关系型数据与 KV 的转化，下列说法不正确的是？ C\n A. 如果没有定义主键，key 中包含 RowID，Index ID 和 Table ID，都是 int64 类型  \n B. Table ID 在整个集群内唯一  \n C. 如果定义了主键，那么将使用主键作为 RowID  【聚簇表：tableID+PK主键   非聚簇表：可选！】\n D. 不需要为每张表指定主键 \nTiKV 架构原理简介\n持久化\nraft log\nCF:Column Family\n多raft group\n单节点纵向RW：rocksdb\nraft：多节点region副本 横向RW\n5.并行 计算project join maxmin\n\n单机KV map\nSSD\n\n合并 批量IO\n完全顺序写入，不会随机写或排序\nLSM Tree（HBase存储引擎）：MT iMT  SST文件\nhttps://www.baidu.com/s?wd=HBase%20%E5%AD%98%E5%82%A8%20LSM&amp;rsv_spt=1&amp;rsv_iqid=0xeb03ecb20000002e&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=17&amp;rsv_sug1=12&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=14612&amp;rsv_sug4=14613\n预写日志WAL：保证原子性 持久性\n故障恢复 Crash-safe：\nMySQL\n小黑板写满了怎么办？？？？：和人一样，小黑板在人流量多的时候会出现写满的时候\n（一般不会出现，redolog分配内存足够大），那么只能暂停一切写入操作，\n把小黑板的计算写入账本后才能继续写入，所以老板会先算完帐后再进行新的收账。\n但是这里我们就要聊到一个概念叫做crash-safe，也就是这里还有一个【专门计算的伙计\n，老板一边记录，这边有个小伙子计算并擦除掉计算好了的记录，并保存到账本上去，\n速度上肯定是老板写入要快的多，但是这样下来不至于导致整个黑板快速的写满，基本上就是\n老板一边写，伙计一边算，写满后，要停一段时间等伙计。】\n\nsync_log&#x3D;true：fsync   不经过OS缓存，直接入盘\n跳表，搜索B+树来sort\n唯一MT的write-buffer-size到，转存入iMTs\n否则IO落盘写阻塞，有一个就刷磁盘\niMT&#x3D;5后，触发write stall 自我保护，限流流控 写入速度变慢 log里有，可调高~\n\n4个level0&#x3D;iMT  compaction压缩 key排序 合并\n二分查找key\n1次磁盘IO 1次memIO：     优于B+树 3+次磁盘iO\ndel W： 只入MT             对W友好\n查询比B+树慢一点\n\n最近最常读的data放入Block Cache\n永远把新数据读到MT，不用管老版本数据了\n文件key的min max区间判断，二分查找 + 【BloomFilter判断不在肯定不在】，判断在有误报率\n\n【&#x3D;&#x3D;数据分片(CF列簇)技术&#x3D;&#x3D;】\n\n没指定，都进入default列簇\n一类CF\n共享WAL不分列簇\n分布式事务  MVCC\n破坏原子性\npercolator模型的2PC:改数据 加锁    ；   提交 解锁\n\n3类CF\nput&#x2F;delete &lt;key_startTs, v&gt;\nW写锁,pk行，k,ts,v\nWrite: put&lt;k_commitTs, startTs&gt;    —-&gt;读Write已提交 拼3_100查询v\nLock：D。。。锁被删除\n\n@1是指针，指向pk   事务中。。。\n\n【MVCC多版本并发控制】\n\nput delete新值追加      读最新commitTs的已提交记录\n支持【读取旧值      已提交的最新版本数据，不读事务中的现版本】即可\n\n已C：Default Write    R时从Write拼id+startTs去default找\n未C：Default Lock\nDefault列簇：key（userID）升序 &amp;&amp; startTs降序：便于检索latest值\n\n2没锁：Candy\n1Jack、4Tony同理：有W无D 事务中，读旧值\nRaft   分布式数据执行\nRW走leader   follower定时：心跳 WAL       candidate发起投票\nfollower大半收到log：leader committed，apply为kv\nkey无间隙[1,1k) [1k,2k)… region最大96M \n5w region向PD回报心跳，网络压力大，需要性能优化！\n\n1.propose：写日志 redionID + raft log id， log{put k,v}\n2.append：replicate复制log\n3.committed：大半follower持久化了响应了\napply  data到rocksDB(kv)\n\n\nterm任期\n计时器：election_timeout&#x3D;10s【没leader】\nelection_timeout先超时的follower作candidate，发起投票，term+1\n同意term大的当leader\n\nheartbeat_time_interval【leader挂了&#x2F;延迟】  &lt; min（election_timeout&#x3D;10s ） 避免leader心跳没发到follower就要求选举\n\nrandom_election_timeout  避免多次重复选举\nhttp://thesecretlivesofdata.com/raft/\n读取&#x2F;Coprocessor关注RW一致性\n不涉及SQL冲突检测 scheduler（RW原理）\n线程池：raft log一致性  、 sql apply\npropose 序列化为raft log\nappend\nreplica\n过半 committed\n【写成功后，不一定立刻能读到  没apply到kv】\napply\n\n【解决commit apply异步问题：】\n记最新commitIndex值到ReadIndex\n等到ApplyIndex&#x3D;4_100&#x3D;ReadIndex时才能读\n【保证node2还是leader】\n发心跳（走网络 慢！）确认自己是leader，再读\n\n改进：不发心跳     心跳间隔&lt;min(随机选举超时时间)\n\nFollower分担R压力：follower慢，就等leader同步         leader慢，就R（leader压力大！）\n分布式ReadIndex Read~\n\n计算下推\n物理算子？\ntable scan 、index scan、selection过滤、limit、max、min、aggregate聚合\n分析统计采样，对表校验\n\nTiDB 数据库事务设计分布式事务基本原理\n\n1都成都败\n2数据完整性 提交修改不丢失：   效率 应用开发易用性\n3互斥 不影响：  事务安全 并发能力\n4提交落盘：  数据安全落地\n\n\n\n\n\n\n\n\n本地事务\n分布式事务：伪分布式系统 麻烦\nTCC：try confirm-commit rolloback-cancel\n\n\n业务侵入性大！ 完全由应用程序控制\nSAGA构造长活事务：大事务拆解为小事务\n\n微服务按数据分片来分\n\n3个缺点\npercolator对2PC优化\n！【文章】分布式数据库的核心知识https://www.sohu.com/a/470146217_121124363\n1主流的分布式数据库有两种架构，PGXC和NewSql。\n\n\nNewSQL还有两个改进：\n\n对于HA，放弃传统数据库的主从复制，使用Paxos、Raft等共识算法来保证多副本的一致性。\n对于存储，使用LSM树模型替换B+树，写入性能更高。\n\n2全局时钟。。。\n3 HTAP\nHTAP英文全称是 Hybrid Transaction and Analytical Processing，即混合事务和分析处理，能够将事务处理(OLTP)和数据分析(OLAP)请求在同一个数据库系统中完成。\nHTAP需要在计算和存储两个层面支持OLTP和OLAP，存储是基础。OLTP通常使用行式存储，OLAP则一般使用列式存储，差异很大。HTAP解决这个差异的方式有两种：\n\nGoogle Spanner的PAX，一种新的融合性存储，即在行存储的基础上融合列存储的特点。\nTiDB的思路，借助Raft协议在OLTP与OLAP之间异步复制数据，通过OLAP的特殊设计来弥补异步带来的数据不一致。\n\nOceanBase采用独创的分布式计算引擎，能让系统中多个计算节点同时运行OLTP类型的应用和OLAP类型的应用，实现了用一套计算引擎同时支持混合负载的能力。\n4 RANGE动态分区\n下图有4条数据，\n\n如果按照HASH进行分片，一般会选择【id作为key进行HASH计算，之后根据计算结果把数据分配到不同的分片】中。这样做的好处是实现简单，但也存在两个问题：\n\n分片【不具备业务属性，可能会存在业务热点访问的问题】。\n分片【规模变化时，迁移数据问题】。\n\nRange分片技术跟HASH相比，很大的不同是数据并【没有被打散】。比如上表中，我们可以把数据按照城市进行分片，这样数据读取效率会更高。\nRange动态分区用在NewSQL架构的分布式数据库中，一般具有下面的特性：\n4.1 自动合并和拆分\n可以给分配的数据量设置阈值，当某个分片的数据量超过最大阈值时，可以自动拆分成2个分片，当分片数据量小于最小阈值时，进行分片合并。\n4.2 自动负载\n当某个分片上的热点数据较多时，节点访问压力会很大，系统可以【自动地将这些热点数据访问调度到不同节点，以均衡访问压力】。\n4.3 减少分布式事务\n分布式事务的开销会远远大于本地事务，分布式数据库可以【把频繁参与同一个分布式事务的数据调度到同一个分片上】，这样就避开了分布式事务。\n\n\n\n\n\n\n\n\n\nSpanner支持\n4.4 就近访问\n在全球部署的场景下，给用户分配最近节点的分片，可以减少访问延时。\n\n\n\n\n\n\n\n\n\nSpanner支持\n4.5 高可靠\n分布式数据库的高可靠是【分区（Region）级别的高可靠】，下图是OceanBase中【一个Zone的架构图】：\n\nOceanBase基于Paxos算法来实现系统的高可用，最小的粒度可以做到分区级别。集群中数据的【每一个分区会被保存到所有的Zone】上，分区的多个副本采用Paxos协议进行日志同步。【每个分区和它的副本构成一个独立的Paxos复制组（raft group）】，其中一个分区为Leader，其它分区为Follower。【所有针对这个副本的写请求，都会自动路由到对应的主分区上进行。主分区可以分布在不同的OBServer上】，这样对于不同副本的写操作也会分布到不同的数据节点上，从而实现【数据多点写入，提高系统性能】。\n5 percalator模型\n参考1: https://open.oceanbase.com/\n参考2: https://www.cs.princeton.edu/courses/archive/fall10/cos597B/papers/percolator-osdi10.pdf\nLarge-scale Incremental Processing Using Distributed Transactions and Notifications\nGoogle的incremental web index update system\n[[OSDI&#x2F;] Large-scale Incremental Processing Using Distributed Transactions and Notifications - 知乎 (zhihu.com)\npercolator是有代价的，当处理的部分超过一定程度的时候（这里是30%），那么处理速度是比不上直接跑一个全局map reduce的。\nPercolator 事务模型原理\n\nBigTable：分布式结构化数据存储系统\n+单行控制分布式事务\n隔离级别 对应 并发控制协议\n\n可重复读（会幻读 +看得到）  MySQL\n无幻读 +看不到\n&#x3D;&#x3D;TiDB悲观锁&#x3D;MySQL的RR&#x3D;&#x3D;\n我看到的都是我事务开始时刻能看到的所有数据！\n线性一致性要求，任何一个客户端读取返回新值后，后面所有客户端(包括相同客户端和不同客户端)读取也必须返回新值\n\nstartTs endTs 确定时间序号：全局发号器  、时钟\nGPS + 原子时钟 有硬件要求 多点授时        物理时钟 麻烦      全球化\nHLC(Hybrid Logical Clock)时钟+NTP 有误差          混合时钟：Unix物理时钟ms+ms等分逻辑时钟\n单点-全局发号器            混合时钟序列           用一个全局唯一的时间戳作为xid(全局事务id)【TiDB OceanBase】\n优点：\n\n实现简单\n单时间源单调递增，可以减少事务冲突\n\n缺点也很明显\n\n单点授时，性能会有瓶颈\n不适合大规模集群部署\n\n\n\n找主行(随机)   加锁 WW冲突 报错：prewrite不回滚\n\n\n\n\n没提交失败就回滚 Tx\n\n异步提交 冲突解决\n\nTiDB 事务的实现方式与优化\n\nPD：Route TSO\nmemBuffer 内存溢出\n版本检查  eg10：00之前的\n\nWW冲突 W没加锁  上次TX提交了cur才能开始\n\n【乐观锁：commit时才真正做锁检测  大量修改用时长，改了20min全回滚。。。】\n\n\n\n悲观锁：\n\n\n版本检测\n\n锁冲突检测\n\nDML加行锁 占位符\n\n占位符-&gt;info  prewrite工作减轻\n\n\n\n&#x3D;&#x3D;【优化】悲观锁（DML阻塞等事务提交）、RR+select…for update;启动当前读&#x3D;&#x3D;\n\n冲突敏感：悲观锁\n乐观锁 commit时才报错写冲突\n\n\n悲观锁\n\n\n还是原值，看不到新值，因为左边没提交  不支持賍读\n\nDML时就做冲突检测 检查到锁，阻塞等待\n\n提交解锁了 DML成功\n写偏斜write skew！select … for update; 启动当前读！\n写偏斜通常发生在RR隔离级别  snapshot isolation\n改自己使两球同色\n改的是不同对象，无锁冲突（可以乐观锁&#x2F;悲观锁），就成这样了。。。\n【都白黑】\n左边白改黑 提交\n\n右边没变：因为RR 不賍读\n右边黑改白 提交\n\n再查：都黑白\n&#x3D;&#x3D;【solution：RR  +  select … for update; 读取当前值】&#x3D;&#x3D;\n都begin\nL:白改黑 提交\n\nselect … for update; 启动当前读！【排它锁(X)】 都黑 那就不改了 commit  OK\n\n&#x2F;1. 【多选题】下列关于 TiDB 数据库事务实现，正确的是？（ 选 2 项 ）BD\nA. TiDB 数据库乐观锁不需要在 Lock 列族中写入锁信息\nB. Write 列族记录的是事务提交信息，或者说版本信息\nC. 悲观锁下，我们需要将 prewrite 阶段提到 DML 操作中来做  -&gt;  加锁操作提前\nD. 乐观锁下，事务在 prewrite 阶段检测写写冲突和锁冲突\n&#x2F;2. 【单选题】 下列关于 TiDB 的事务，不正确的是？B\n A. 写偏斜可以出现悲观锁模式或者乐观锁模式  \n B. 写偏斜可以出现在可重复读隔离级别或者提交读隔离级别            读已提交不会写偏斜\n C. 是否使用 for update 在可重复读隔离级别有可能读到不同的值  \n D. 悲观锁模式遇到锁冲突时，默认会阻塞 \n&#x2F;1. 【多选题】下列属于 TiKV 相关功能的是？（ 选 4 项 ）ACDF\nA. 系统参数和元数据信息的持久化\nB. 产生 TSO\nC. 分布式事务实现\nD. MVCC\nE. 生成物理执行计划\nF. 表统计信息的持久化\n&#x2F;2. 【单选题】关于 TiKV 数据持久化，下列说法不正确的是？C\n A. RocksDB 有 2 个实例，分别用来持久化 raft log 和 key value 数据  \n B. RocksDB 中 WAL 用来保证写不丢失  \n C. 对于删除操作，只需要在原 key value 数据上标记已删除即可     【不标记已有删除，而是**&#x3D;&#x3D;插入一条新的delete…数据&#x3D;&#x3D;**即可】\n D. RocksDB 中，除了 Level 0 层的数据，其他 Level 都是单一排序持久化的 \nPD（Placement Driver） 简介\n\n集成了etcd，支持自动故障转移auto fail-over不担心单点故障； etcd-raft保证强一致性\n奇数个 3个节点：1L2F\nstore就是TiKV Node节点\n副本Peer 角色1L2F\n管理多Region（96M）：multi-raft\n\n1大脑  xID  3.始&#x2F;终TSO  4.元数据热点调度  5.label高可用   监控\n\nLF变化 backoff延迟 region分裂：Region Cache信息过久 重查PD\n\n\n1ms&#x3D;262144TSO\n\n校验tsFuture异步对象拿对应的TSO\n保证单增 需要同步TSO  出现IO瓶颈 ！-&gt;时间窗口：mem批量分配 只定时存end编号 降IOPS\n\n\n可能使用TSO非连续但保证递增\n\n\n心跳： 健康，mem usage、容量、busy情况                 副本分布状况，数据量，RW流量\n均不均匀\n\nleaderRW均衡  region存储均衡\n写热点：打散 分散\ndrop del trucate: 空region合并\n【生成 operator】\n\n分裂 合并 转移\n\n3数据中心 6机柜 12台主机\nDC2挂了：region 1 多半没了！\nDC1挂了：region 2 多半没了！\n挂哪个DC，region3都不受影响\n\n不同peer副本要在不同zone。zone是一个逻辑概念：可能是dc，也可能是rack&#x2F;host\n&#x2F;1. 【单选题】下列关于 PD（Placement Driver）架构和功能正确的是？ B\n A. 访问 PD 集群中的任何一个节点都可以获得 TSO   【只有Leader 单点】\n B. TiKV 会周期性地向 PD 【上报】集群状态  心跳   \n C. PD 会周期性地查询 TiKV 的状态，不需要 TiKV 上报，目的是为了高效       反了  \n D. PD 的调度功能只能平衡 region 的分布，无法对 leader 进行调度     &#x3D;&#x3D;【生成调度：leaderRW均衡  region存储均衡】&#x3D;&#x3D;\n&#x2F;2. 【单选题】2. 关于 label ，下列说法不正确的是？ C\n A. label 的本质是个调度系统，可以人为控制 region 副本的存放位置   【粒度不同  影响&#x2F;控制】 \n B. label 需要在 PD 和 TiKV 上进行配置  【知道…     info】\n C. zone 一般和数据中心（DC）对应，这样可以获得最大的可用性  【只是逻辑概念！】\n D. 如果某个 region 不可用，有可能造成整个 TiDB 数据库不可用  &#x3D;&#x3D;【if region存元数据 包括schema info…那就不可用了】&#x3D;&#x3D;\n深入了解 TiKV 架构原理TiKV整体架构\n\n\n\n\n\n\n&#x3D;&#x3D;3.用于数据搬运：直接搬运文件，不用逐行扫描挨个插入？？？&#x3D;&#x3D;\n\n\n\n4Batch来优化Multi-Raft  ？？？\n\nPD-&gt;KV：LB（DC间） 分裂（热点）  合并（碎片过多）\n\n&#x3D;&#x3D;只是元数据改变范围&#x3D;&#x3D;： new一个新的raft group管理空出来的分片范围~\n\n【分布式事务】\n\n\n\n主提交，副异步提交\n【Coprocessor】\n&#x3D;&#x3D;本地计算思想？？？&#x3D;&#x3D;\nhadoop MR数据计算本地化是指的map任务\nhttps://haokan.baidu.com/v?pd=wisenatural&amp;vid=2263116146187548309\n\n\n\n\n&#x3D;&#x3D;gRPC？？？&#x3D;&#x3D;\nPD-&gt;KV：LB命令&#x2F;执行\n存储引擎\n\n只append追加不改\n定期重组数据！分新旧level\n\n所以append对块擦除的SSD友好！\n\n\n\n\n合并后range变大，要找：Write每层O(T)      append范围&#x3D;，Write每层O(1)\n\n\nFB \n\n\nmemtable实际是跳表SkipList\n\n\nOS文件格式   \nindex Block：存key的range范围\n前缀压缩：Trie？？？？\nBloomFilter 排除key用\n\n相当于系统日志 宕机重启可redo\n\nlevel0 SST的key range交错重叠，不能并发sub-compaction，\n其他level： 将job分割，多段range交给多个线程并发执行\n\n\n\n选出max compaction score的文件 —找range重叠的文件：归并排序\n\nL0 range交错 都要读！\n\nCF逻辑分区\n副本快速迁移复制\n\n\nFi：引用计数  &#x3D;&#x3D; 0,才真正物理删除 （JVM GC）\nin-&gt;out 生成即只读，不能更改               compaction了，也不影响iter1的实际读取！\n\n有共享block-cache\n\n不引入写放大，尽量放入最底层\n\n告诉你存在，实际没读到，也不影响正确性\n因为hash冲突了，多对一了，就会误认为存在\n\n单点查询–&gt;前缀范围查询\n\nCPU–IO的tradeoff\n\n\n\n减少compaction写放大\nvlaue变ptr，所指向的v可能被GC\nSSD并行性：prefetch！\n\n&#x3D;&#x3D;WiscKey论文？？？&#x3D;&#x3D;\n\nvalue被删idx不知道，定期GC\ntail：按v查k ，k没失效：tail前移+头插；value位置变化，还需更新LSM tr中的index。                          key失效：tail前移\n\n更改配置项即可升级\n\n随着compaction逐渐将大value写入Blob\n\ncompaction：input文件 - output文件 的TableProperties            失效value累加\n逻辑删除   \n并发写入时：先检查v，value被改了，就不更新blob index了 放弃操作     ？？？？？？？具体？？？？？？？\n\nGC score\n&#x3D;&#x3D;DISCARD_RATIO？？？&#x3D;&#x3D;\nRaft复制状态机\n\n\nzk会话一致性：另一个Client session不一定能读到\nCAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。\n\n&#x3D;&#x3D;全部节点失败不可用：Kafka&#x3D;&#x3D;            全W成功才能确认，延迟取决于最慢的那一台！        2挂–&gt;3\n过半：etcd, zk, tikv                            过半W成功能确认，延迟取决于最快的那3台！         2挂–&gt;5   \n延迟稳定！\n\n\n\n\n\np3和p1: 虽然last idx小但term大，agree term大的\n\n同一term只投一次\n\n某个follower失联（未过半 sys正常）重连后，会term+1 req选举，Leader变FL，发起新选举，整体被干扰影响。。。\nif过半节点有leader，就忽略pre-vote，此FL老实待着！\n\n\n\n\n\n高term日志覆盖低term日志\n&#x3D;&#x3D;why leader重新发：term&#x3D;5？？？看论文 解答！！！&#x3D;&#x3D;VIP问题：\n\n\n\n&#x3D;&#x3D;S1比S5被确认速度快？？？，确认了4、2，2不会被3覆盖&#x3D;&#x3D;【看论文！】\n\n类似TCP滑动窗口\n\n\n去热点\n\n\n\n\nraftstore \n\n\n\n+线程 +TiKV实例   扩容机器数\n\n\npropose  apply管道排队的时间\n\nTiDB事务原理与实现\n一、\n多语句原子操作\n\n二、事务隔离级别：RU RC RR 串\n\n\n\n\n\nTiDB解决了RR下的幻读！\n三、Percolator\n\nSI\n\n基于事务开始时间\n2PC\n\n\n\n\n\nPK主键 单行控制\nMVCC 2PC交互多\n\n\nSQL-&gt;NoSQL 唯一kv方式\n\n\n\n\nautocommit  更新k  可重试事务\n\n\n\n\n没有select… for update 没加写锁，就要关掉auto retry 避免出现这种情况\n\n限制事务大小\n\n【Client端：】3事务auto commit 合并为一条事务commit\nnew\n\npay forward,创业公司基础软件：开源\n\nwin make：\nwget https://dl.google.com/go/go1.14.5.linux-amd64.tar.gz\nhttps://blog.csdn.net/weixin_38383877/article/details/103612131\n\n\n\nGitHub - pingcap&#x2F;tidb: TiDB is an open source distributed HTAP database compatible with the MySQL protocol\nGitHub - tidb-incubator&#x2F;tinysql: A course to build the SQL layer of a distributed database.\ntinysql&#x2F;material.md at course · tidb-incubator&#x2F;tinysql · GitHub\nDDIA系统设计：http://ddia.vonng.com/\nGO语言设计与实现https://draveness.me/golang/\nhttps://learnku.com/docs/effective-go/2020\nhttp://getrust.tech\n内存泄漏的定位与排查：Heap Profiling 原理解析https://mp.weixin.qq.com/s/vncOjgrSomLx5je-ywD5Ng\ngit\nhttps://blog.csdn.net/fwhezfwhez/article/details/79399072\nfatal: remote origin already exists.https://blog.csdn.net/top_code/article/details/50381432\n1、先输入$ git remote rm origin(删除关联的origin的远程库)\n2、再输入$ git remote add origin &#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;:(github名)&#x2F;(git项目名).git 就不会报错了！\n3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容\n4、找到你的github的安装路径，我的是C:&#x2F;Users&#x2F;ASUS&#x2F;AppData&#x2F;Local&#x2F;GitHub&#x2F;PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8&#x2F;etc\n5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！————————————————版权声明：本文为CSDN博主「码知秋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_40428678/article/details/84074207\n\n\n\ngit将现有已经修改代码提交到新的分支\nhttps://blog.csdn.net/cssxn/article/details/109673887\n1）首先需要将已经修改的代码保存到git暂存区，使用命令：git stash\n2）创建并切换到新的代码分支git checkout -b 分支名称\n3）将修改的代码恢复到新的分支git stash pop\n4）保存已经修改的代码增加修改的文件：git add 文件名本地暂存：git commit -m “注释”远程保存：git push origin 远程分支名\ngit中使用make\nhttps://blog.csdn.net/z69183787/article/details/96290717\ngit branch –delete dev\ngit修改分支名\n需要将分支br_rename_old修改为br_rename_new，执行如下步骤：1、执行命令git checkout br_rename_old切换到br_rename_old分支，如果已经在这个分支下，可以不执行此步骤2、执行命令git pull origin br_rename_old将代码更新到和远程仓库一致3、执行命令git branch -m br_rename_old br_rename_new将本地仓库的br_rename_old的名称修改为br_rename_new4、执行命令git push –set-upstream origin br_rename_new将本地分支push到远程仓库5、执行命令git push origin –delete br_rename_old将远程分支br_rename_old删除————————————————版权声明：本文为CSDN博主「花一样的阿衰」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_33242956/article/details/105856965\n\nwindows查看某个文件正在被哪些进程使用\nhttps://jingyan.baidu.com/article/0aa223758230b588cd0d6458.html\n性能 资源监视器 磁盘 文件 PID\nserver-test.exe\n还是用goland单元测试吧。。。\n","slug":"TiKV学习","date":"2021-12-17T03:10:40.000Z","categories_index":"分布式存储引擎TiKV","tags_index":"TiKV","author_index":"CodingSeed"},{"id":"ab2eededdd25843ff0dfd005b352f815","title":"Leetcode1-500","content":"1.两数之和 找sum的2个idx:2sum (枚举Si,find之前是否存在target-Si [hash表 O(1)search])平衡树：map O(logn) –&gt; hash表：unordered_map O(1):target-Si\nhash[val] &#x3D; idx:             hash[nums[i]] &#x3D; i; &#x2F;&#x2F;没找到，就放入hash表\n&#x2F;&#x2F;枚举Si,find之前是否存在target-Si [hash表 O(1)search]\n&#x2F;&#x2F;sort:pair&lt;num,idx&gt;下标会变...\n&#x2F;&#x2F;平衡树：map O(logn) --&gt; hash表：unordered_map O(1):target-Si\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tunordered_map&lt;int, int&gt; hash;&#x2F;&#x2F;存下标版\n\n\t\tfor(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n\t\t\tint r &#x3D; target - nums[i];\n\t\t\tif(hash.count(r))\n\t\t\t\treturn &#123;hash[r], i&#125;;\n\t\t\thash[nums[i]] &#x3D; i; &#x2F;&#x2F;没找到，就放入hash表\n\t\t&#125;\n\t\treturn vector&lt;int&gt;();&#x2F;&#x2F;&#123;,&#125;&#x3D;&#x3D;make_pair(,) 或 &#123;&#125;   :降T(n)\n\t&#125;\n&#125;;\n\n\n\n\n2.两数相加 竖式加法（链表-个十百 秦九韶）dummy cur 进位t + l1 + l2 %10 &#x2F;10\nclass Solution &#123;\npublic:\n\tListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n\t\tauto dummy &#x3D; new ListNode(-1), cur &#x3D; dummy;&#x2F;&#x2F;虚拟头结点dummy\n\t\tint t &#x3D; 0;&#x2F;&#x2F;进位\n\t\twhile(l1 || l2 || t) &#123; &#x2F;&#x2F;如果最高位有进位t，则需在最前面补1.\n\t\t\tif(l1) t +&#x3D; l1-&gt;val, l1 &#x3D; l1-&gt;next;\n\t\t\tif(l2) t +&#x3D; l2-&gt;val, l2 &#x3D; l2-&gt;next;\n\t\t\tcur &#x3D; cur-&gt;next &#x3D; new ListNode(t % 10);\n\t\t\tt &#x2F;&#x3D; 10;\n\t\t&#125;\n\t\treturn dummy-&gt;next;\n\t&#125;\n&#125;;\n\n\n\n3 无重复字符的最长(连续)子串:双指针+hash表&#x2F;&#x2F;3. 无重复字符的最长(连续)子串  aabcdde : abcd 4\n&#x2F;&#x2F;双指针 滑动窗口 (优化：单调性j-&gt;j&#39;,i-&gt;i&#39; 2n次：O(n)不回头)  \n&#x2F;&#x2F;对S[i+1],hash表中S(i+1)若存在：j右移到剔除前一个S(i+1)为止 len&#x3D;max\n&#x2F;&#x2F;hash[val] &#x3D; cnt\nclass Solution &#123;\npublic:\n\tint lengthOfLongestSubstring(string s) &#123;\n\t\tunordered_map&lt;char, int&gt; hash;&#x2F;&#x2F;或unordered_mulset 记录次数\n\t\tint res &#x3D; 0;\n\t\tfor(int i &#x3D; 0, j &#x3D; 0; i &lt; s.size(); i++) &#123;\n\t\t\thash[s[i]]++;\n\t\t\twhile(hash[s[i]] &gt; 1) hash[s[j++]]--; &#x2F;&#x2F;\n\t\t\tres &#x3D; max(res, i - j + 1);\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n4. 寻找两个正序数组的中位数 套（找K-th）\n&#x2F;&#x2F;4. 寻找两个正序数组的中位数 难 (递归):O(log(n+m))  (二分):O(log(min(m,n))\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;50&#x2F;\n\nclass Solution &#123;\npublic:\n\tdouble findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n\t\tint total &#x3D; nums1.size() + nums2.size(); &#x2F;&#x2F; 分奇偶\n\t\tif (total % 2 &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tint left &#x3D; findKthNumber(nums1, 0, nums2, 0, total &#x2F; 2);\n\t\t\tint right &#x3D; findKthNumber(nums1, 0, nums2, 0, total &#x2F; 2 + 1);\n\t\t\treturn (left + right) &#x2F; 2.0;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn findKthNumber(nums1, 0, nums2, 0, total &#x2F; 2 + 1);\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;从idx &#x3D; i,j打头\n\tint findKthNumber(vector&lt;int&gt; &amp;nums1, int i, vector&lt;int&gt; &amp;nums2, int j, int k)\n\t&#123;\n\t\tif (nums1.size() - i &gt; nums2.size() - j) return findKthNumber(nums2, j, nums1, i, k);&#x2F;&#x2F;swap12:1短2长\n\t\tif (k &#x3D;&#x3D; 1) return min(nums1[i], nums2[j]);\n\t\tif (nums1.size() &#x3D;&#x3D; i) return nums2[j + k - 1];&#x2F;&#x2F;n1到头,k&#x3D;1时：n2[j]\n\t\t&#x2F;&#x2F;1短，min(n1.size())防越界！！！\n\t\tint si &#x3D; min(i + k &#x2F; 2, int(nums1.size())), sj &#x3D; j + k &#x2F; 2; &#x2F;&#x2F; k&#x2F;2的后一个\n\t\tif (nums1[si - 1] &gt; nums2[sj - 1])\n\t\t\treturn findKthNumber(nums1, i, nums2, sj, k - (sj - j));\n\t\telse\n\t\t\treturn findKthNumber(nums1, si, nums2, j, k - (si - i));\n\t&#125;\n&#125;;\n\n5. 最长回文子串 (枚举中点i，更新max_res: O(n*n))&#x2F;&#x2F;5. 最长回文子串 N&#x3D;1000 枚举中点i，更新max_res: O(n*n)  优于  DP还要开数组:S(n)大点\n&#x2F;*\nO(nlogn) str_hash(Karp_Rabin)+二分:Acwing139 0x10ds(N&#x3D;100w)    O(n):Manacher\nhash的O(n)解法:\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;893&#x2F;\n*&#x2F;\nclass Solution &#123;\npublic:\n\tstring longestPalindrome(string s) &#123;\n\t\tstring res;\n\t\tfor (int i &#x3D; 0; i &lt; s.size(); i++)&#x2F;&#x2F;枚举中心点i\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;回文串(l,r)长：奇 \n\t\t\tint l &#x3D; i - 1, r &#x3D; i + 1;\n\t\t\twhile(l &gt;&#x3D; 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] &#x3D;&#x3D; s[r]) l--, r++; &#x2F;&#x2F; end:l!&#x3D;r [l+1,r-1]\n\t\t\tif(res.size() &lt; r - l - 1) res &#x3D; s.substr(l + 1, r - l - 1); &#x2F;&#x2F;更新max_res\n\t\t\t&#x2F;&#x2F;偶  \n\t\t\tl &#x3D; i, r &#x3D; i + 1;\n\t\t\twhile(l &gt;&#x3D; 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] &#x3D;&#x3D; s[r]) l--, r++;\n\t\t\tif(res.size() &lt; r - l - 1) res &#x3D; s.substr(l + 1, r - l - 1);\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n6. Z字形变换(找规律)\n&#x2F;&#x2F;6. Z字形变换 (加密机制) n&#x3D;4 1234...草稿纸找规律\n&#x2F;*\n输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 4\n输出: &quot;LDREOEIIECIHNTSG&quot;\n解释:\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n\n从中我们发现，对于行数是 n 的情况：\n1.对于第一行和最后一行，是公差为 2(n−1) 的等差数列，首项是 0 和 n−1；\n2.对于第 i 行(0&lt;i&lt;n−1)，是两个公差为 2(n−1) 的等差数列交替排列，首项分别是 i 和 2n−2−i；\n*&#x2F;\n\nclass Solution &#123;\npublic:\n\tstring convert(string s, int n) &#123;\n\t\tstring res;\n\t\tif(n &#x3D;&#x3D; 1) return s; &#x2F;&#x2F;特判n&#x3D;&#x3D;1,影响for loop\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tif(i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) &#123; &#x2F;&#x2F;首 尾\n\t\t\t\tfor (int j &#x3D; i; j &lt; s.size(); j +&#x3D; 2 * n - 2)\n\t\t\t\t\tres +&#x3D; s[j];\n\t\t\t&#125; else &#123; &#x2F;&#x2F; j,k首项不同，交替打印\n\t\t\t\tfor (int j &#x3D; i, k &#x3D; 2 * n - 2 - i; j &lt; s.size() || k &lt; s.size(); j +&#x3D; 2 * n - 2, k +&#x3D; 2 * n - 2) &#123;\n\t\t\t\t\tif(j &lt; s.size()) res +&#x3D; s[j];\n\t\t\t\t\tif(k &lt; s.size()) res +&#x3D; s[k];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;类似：剑指Acwing40 蛇形矩阵 顺时针打印矩阵\n\n7.整数反转(秦九韶res &#x3D; res * 10 + x % 10; x &#x2F;&#x3D; 10;)class Solution &#123;\npublic:\n\tint reverse(int x) &#123;\n\t\tint res &#x3D; 0;\n\t\twhile(x) &#123; \n\t\t\t&#x2F;&#x2F;res &#x3D; res*10+x%10&gt;INT_MAX 就溢出:return 0\n\t\t\tif(x &gt; 0 &amp;&amp; res &gt; (INT_MAX - x % 10) &#x2F; 10) return 0;\n\t\t\tif(x &lt; 0 &amp;&amp; res &lt; (INT_MIN - x % 10) &#x2F; 10) return 0;&#x2F;&#x2F;负-负&#x3D;负+正 不会溢出\n\t\t\tres &#x3D; res * 10 + x % 10; &#x2F;&#x2F; 负数 % 10 &#x3D; 负数\n\t\t\tx &#x2F;&#x3D; 10;\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n8.atoi&#x2F;&#x2F;8. 字符串转换整数 (atoi)\nclass Solution &#123;\npublic:\n\tint myAtoi(string str) &#123;\n\t\tint k &#x3D; 0;\n\t\twhile(k &lt; str.size() &amp;&amp; str[k] &#x3D;&#x3D; &#39; &#39;) k++;\n\t\tif(k &#x3D;&#x3D; str.size()) return 0;\n\n\t\tint minus &#x3D; 1;\n\t\tif(str[k] &#x3D;&#x3D; &#39;-&#39;) minus &#x3D; -1, k++;\n\t\telse if(str[k] &#x3D;&#x3D; &#39;+&#39;) k++;\n\n\t\tint res &#x3D; 0;\n\t\twhile(k &lt; str.size() &amp;&amp; str[k] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[k] &lt;&#x3D; &#39;9&#39;) &#123;\n\t\t\tint x &#x3D; str[k] - &#39;0&#39;;\n\t\t\tif (minus &gt; 0 &amp;&amp; res &gt; (INT_MAX - x) &#x2F; 10) return INT_MAX;\n\t\t\tif (minus &lt; 0 &amp;&amp; -res &lt; (INT_MIN + x) &#x2F; 10) return INT_MIN;\n\t\t\tif(-res * 10 - x &#x3D;&#x3D; INT_MIN) return INT_MIN;&#x2F;&#x2F;MIN比MAX绝对值多一:特判!(-2^31-1~2^31)\n\t\t\tres &#x3D; res * 10 + x;\n\t\t\tk++;\n\t\t\tif(res &gt; INT_MAX) break;\n\t\t&#125;\n\n\t\tres *&#x3D; minus;\n\t\tif(res &gt; INT_MAX) res &#x3D; INT_MAX;\n\t\tif(res &lt; INT_MIN) res &#x3D; INT_MIN;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n9.回文数(to_string,if (x &lt; 0 || x &amp;&amp; x % 10 &#x3D;&#x3D; 0) return false; if (s &#x3D;&#x3D; x || s &#x3D;&#x3D; x &#x2F; 10) return true;)&#x2F;&#x2F;9. 回文数\n&#x2F;&#x2F;to_string法: str反转&#x3D;&#x3D;self\nclass Solution &#123;\npublic:\n\tbool isPalindrome(int x) &#123;\n\t\tif(x &lt; 0) return 0;\n\t\tstring s &#x3D; to_string(x);\n\t\treturn s &#x3D;&#x3D; string(s.rbegin(), s.rend());\n\t&#125;\n&#125;;\n&#x2F;&#x2F;数值法(不防溢出 LL)\nclass Solution &#123;\npublic:\n\tbool isPalindrome(int x) &#123;\n\t\tif(x &lt; 0) return 0;\n\t\tint y &#x3D; x;\n\t\tlong long res &#x3D; 0;\n\t\twhile(x) &#123;\n\t\t\tres &#x3D; res * 10 + x % 10;&#x2F;&#x2F;倒序\n\t\t\tx &#x2F;&#x3D; 10;\n\t\t&#125;\n\t\treturn res &#x3D;&#x3D; y;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;只算后一半逆序 &#x3D;&#x3D; 前一半   防溢出\nclass Solution &#123;\npublic:\n\tbool isPalindrome(int x) &#123;\n\t\tif (x &lt; 0 || x &amp;&amp; x % 10 &#x3D;&#x3D; 0) return false;&#x2F;&#x2F;负号 个位为0\n\t\tint s &#x3D; 0;\n\t\twhile (s &lt;&#x3D; x)\n\t\t&#123;\n\t\t\ts &#x3D; s * 10 + x % 10;\n\t\t\tif (s &#x3D;&#x3D; x || s &#x3D;&#x3D; x &#x2F; 10) return true;\n\t\t\t&#x2F;&#x2F; 分别处理整数长度是奇数121或者偶数1221的情况\n\t\t\tx &#x2F;&#x3D; 10;\n\t\t&#125;\n\t\treturn false;\n\t&#125;\n&#125;;\n\n\n10.DP：.*正则匹配 “-*”作为整体https://www.acwing.com/video/932/\n\n\n&#x2F;*\nDP优化(类似完全背包)：\n前缀 O(n^3)-&gt;O(n^2): p[j]&#x3D;&#x3D;&#39;*&#39;时\nf[i,j] &#x3D; f[i,j-2] || (f[i-1,j-2] &amp;&amp; s[i] || f[i-2,j-2] &amp;&amp; s[i] &amp;&amp; s[i-1]||...)\nf[i,j] &#x3D; f[i,j-2] || (f[i-1,j] &amp;&amp; s[i]可以和p[j - 1]匹配)\n*&#x2F;\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;bool&gt;&gt;f;\n\tint n, m;\n\tbool isMatch(string s, string p) &#123;\n\t\tn &#x3D; s.size(), m &#x3D; p.size();\n\t\ts &#x3D; &#39; &#39; + s, p &#x3D; &#39; &#39; + p; &#x2F;&#x2F; str_idx从1开始!!!\n\t\tf &#x3D; vector&lt;vector&lt;bool&gt;&gt;(n + 1, vector&lt;bool&gt;(m + 1));\n\t\tf[0][0] &#x3D; true;\n\t\tfor (int i &#x3D; 0; i &lt;&#x3D; n; i++)\n\t\t\tfor (int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123; &#x2F;&#x2F;00init了，i0没意义。j0&#x3D;&#39; &#39;匹i1：匹不了没意义 pass\n\t\t\t\tif(j + 1 &lt;&#x3D; m &amp;&amp;  p[j + 1] &#x3D;&#x3D; &#39;*&#39;) continue; &#x2F;&#x2F; 不单独考虑p[j]\n\t\t\t\tif(i &amp;&amp; p[j] !&#x3D; &#39;*&#39;) &#123; &#x2F;&#x2F;idx从1开始\n\t\t\t\t\tf[i][j] &#x3D; f[i - 1][j - 1] &amp;&amp; (s[i] &#x3D;&#x3D; p[j] || p[j] &#x3D;&#x3D; &#39;.&#39;);\n\t\t\t\t&#125; else if(p[j] &#x3D;&#x3D; &#39;*&#39;) &#123;\n\t\t\t\t\tf[i][j] &#x3D; f[i][j - 2] || i &amp;&amp; f[i - 1][j] &amp;&amp; (s[i] &#x3D;&#x3D; p[j - 1] || p[j - 1] &#x3D;&#x3D; &#39;.&#39;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\treturn f[n][m];\n\t&#125;\n&#125;;\n\n\n后缀解法：\nhttps://www.acwing.com/solution/content/102/\n11.盛最多水的容器(移动较短边，判断面积是否有可能增大)\nAcwing1575\n&#x2F;*\n单调栈+二分：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;13804&#x2F;\n双指针O(n)，思维跳跃：LR比较，低的向中间靠拢，更新max_area(L定，R低，&lt;-靠)\ncorrectness proof:反证法，if L&lt;&#x3D;R 1-6-4，存在更大的best，矛盾。\n！！！移动较短边，判断面积是否有可能增大~属于贪心题！\n*&#x2F;\nclass Solution &#123;\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0, j &#x3D; height.size() - 1; i &lt; j;) &#123;\n            res &#x3D; max(res, min(height[i], height[j]) * (j - i));\n            if(height[i] &gt; height[j]) j--;\n            else i++;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n12. int2罗马数字\n&#x2F;&#x2F;12 整数转罗马数字\nclass Solution &#123;\npublic:\n    string intToRoman(int num) &#123;\n        int values[] &#x3D; &#123;\n            1000,\n            900, 500, 400, 100,\n            90, 50, 40, 10,\n            9, 5, 4, 1\n        &#125;;\n        string reps[] &#x3D; &#123; &#x2F;&#x2F; 单位representations\n            &quot;M&quot;,\n            &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;,\n            &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;,\n            &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;\n        &#125;;\n        string res;\n        for(int i &#x3D; 0; i &lt; 13; i++) &#123;\n            while(num &gt;&#x3D; values[i]) &#123; &#x2F;&#x2F; &gt;&#x3D;\n                num -&#x3D; values[i];\n                res +&#x3D; reps[i];\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n13. 罗马数字2int hash+ [&lt;-,&gt;+]\nclass Solution &#123;\npublic:\n    int romanToInt(string s) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        hash[&#39;I&#39;] &#x3D; 1, hash[&#39;V&#39;] &#x3D; 5;\n        hash[&#39;X&#39;] &#x3D; 10, hash[&#39;L&#39;] &#x3D; 50;\n        hash[&#39;C&#39;] &#x3D; 100, hash[&#39;D&#39;] &#x3D; 500;\n        hash[&#39;M&#39;] &#x3D; 1000;\n\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(i + 1 &lt; s.size() &amp;&amp; hash[s[i]] &lt; hash[s[i+1]]) res -&#x3D; hash[s[i]];\n            else res +&#x3D; hash[s[i]];\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n14. LCP [for(auto&amp; str : strs)  能匹配上才接c]class Solution &#123;\npublic:\n    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;\n        string res;\n        if(!strs.size()) return res;\n\n        for(int i &#x3D; 0;;i++) &#123;\n            if(i &gt; strs[0].size()) return res;\n            char c &#x3D; strs[0][i];\n            for(auto&amp; str : strs) &#x2F;&#x2F;auto&amp; str\n                if(str.size() &lt;&#x3D; i || str[i] !&#x3D; c) &#x2F;&#x2F;匹配不上：end或!&#x3D;\n                    return res;\n            res +&#x3D; c; &#x2F;&#x2F;能匹配上才接c\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n15[~18]. 3sum (sort+dedup+min(3sum&gt;&#x3D;0) + if&#x3D;&#x3D;0 &#x2F; 双指针)双指针：\n\ntarget&#x3D;-n[i],value&#x3D;n[i]\nmin(3sum&gt;&#x3D;0) + if&#x3D;&#x3D;0\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        sort(nums.begin(), nums.end());\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            if(i &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;\n            for(int j &#x3D; i + 1, k &#x3D; nums.size() - 1; j &lt; k; j++) &#123;\n                if(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;\n                while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;&#x3D; 0) k--; &#x2F;&#x2F;k-1 !!!\n                if(nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0) &#x2F;&#x2F;&#x3D;&#x3D;0\n                    res.push_back(&#123;nums[i], nums[j], nums[k]&#125;);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n16. 最接近的三数之和\nclass Solution &#123;\npublic:\n\tint threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tpair&lt;int, int&gt; res(INT_MAX, INT_MAX); &#x2F;&#x2F; &#123;residual,val&#125;\n\t\tsort(nums.begin(), nums.end());\n\t\tfor(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n\t\t\tif(i &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;\n\t\t\tfor(int j &#x3D; i + 1, k &#x3D; nums.size() - 1; j &lt; k; j++) &#123;\n\t\t\t\tif(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;\n\t\t\t\t&#x2F;&#x2F;+n[k-1]&lt; , n[k] is left !!!故+n[k-1]一定&lt;target\n                while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;&#x3D; target) k--; \n\t\t\t\tint s &#x3D; nums[i] + nums[j] + nums[k];\n\t\t\t\tres &#x3D; min(res, &#123;abs(s - target), s&#125;);&#x2F;&#x2F;\n\t\t\t\tif( j &lt; k - 1) &#123;\n\t\t\t\t\tint s &#x3D; nums[i] + nums[j] + nums[k - 1]; &#x2F;&#x2F;\n\t\t\t\t\tres &#x3D; min(res, &#123;target - s, s&#125;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn res.second;\n\t&#125;\n&#125;;\n\n\n\n\n17. 2(abc)~9字母组合     爆搜dfs$$ T(n)&#x3D;4^n*n$$\nclass Solution &#123;\npublic:\n\tvector&lt;string&gt; ans;\n\tstring strs[10] &#x3D; &#123;\n\t\t&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;,\n\t\t&quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, \n\t\t&quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;\n\t&#125;;\n\n\tvector&lt;string&gt; letterCombinations(string digits) &#123;\n\t\tif(digits.empty()) return ans; &#x2F;&#x2F;\n\t\tdfs(digits, 0, &quot;&quot;);\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(string&amp; digits, int u, string path) &#123;\n\t\tif(u &#x3D;&#x3D; digits.size()) ans.push_back(path);\n\t\telse &#123;\n\t\t\tfor(auto c : strs[digits[u] - &#39;0&#39;])\n\t\t\t\tdfs(digits, u + 1, path + c);\n\t\t&#125;\n\t&#125;\n&#125;;\n\n\n\n18. 4sum &lt;– 3sum , 0–&gt;targetclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tsort(nums.begin(), nums.end());\n\t\tfor(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n\t\t\tif(i &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;\n\t\t\tfor(int j &#x3D; i + 1; j &lt; nums.size(); j++) &#123; &#x2F;&#x2F;\n\t\t\t\tif(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;\n\t\t\t\tfor(int k &#x3D; j + 1, u &#x3D; nums.size() - 1; k &lt; u; k++) &#123;\n\t\t\t\t\tif(k &gt; j + 1 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) continue;\n\t\t\t\t\twhile(k &lt; u - 1 &amp;&amp; nums[i] + nums[j] + nums[k] + nums[u - 1] &gt;&#x3D; target) u--; &#x2F;&#x2F;u-1 !!!\n\t\t\t\t\tif(nums[i] + nums[j] + nums[k] + nums[u] &#x3D;&#x3D; target) &#x2F;&#x2F;&#x3D;&#x3D;target\n\t\t\t\t\t\tres.push_back(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);\n\t\t\t\t&#125;\t\t\t\t\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n19. 删除链表的倒数第 N 个节点\n+dummy(first):0~n    倒数第k+1&#x3D;&#x3D;正数第n+1-(k+1)&#x3D;n-k个点，要跳n-k-1步！\nclass Solution &#123;\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int k) &#123; &#x2F;&#x2F;n--&gt;k\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n\n        int n &#x3D; 0;\n        for(auto p &#x3D; dummy; p; p &#x3D; p-&gt;next) n++;\n\n        auto p &#x3D; dummy;\n        for(int i &#x3D; 0; i &lt; n - k - 1; i++) p &#x3D; p-&gt;next;\n        p-&gt;next &#x3D; p-&gt;next-&gt;next;\n\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n20.有效的括号 stk\nclass Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        stack&lt;char&gt; stk;\n\n        for(auto c : s) &#123;\n            if(c &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;[&#39; || c &#x3D;&#x3D; &#39;&#123;&#39;) stk.push(c);\n            else &#123;\n                if(stk.size() &amp;&amp; abs(stk.top() - c) &lt;&#x3D; 2) stk.pop();\n                else return false; &#x2F;&#x2F;不匹配\n            &#125;\n        &#125;\n        return stk.empty(); &#x2F;&#x2F;落单\n    &#125;\n&#125;;\n\n\n\n21. 合并两个有序链表 2路归并class Solution &#123;\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;\n        auto dummy &#x3D; new ListNode(-1), tail &#x3D; dummy;\n        while(l1 &amp;&amp; l2) &#123;\n            if(l1-&gt;val &lt; l2-&gt;val) &#123;\n                tail &#x3D; tail-&gt;next &#x3D; l1;\n                l1 &#x3D; l1-&gt;next;\n            &#125;\n            else &#123;\n                tail &#x3D; tail-&gt;next &#x3D; l2;\n                l2 &#x3D; l2-&gt;next;\n            &#125;\n        &#125;\n        if(l1) tail-&gt;next &#x3D; l1;\n        if(l2) tail-&gt;next &#x3D; l2;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n\n\n22.生成n个合法()seq  递归&#x2F;*\n递归。\n每次可以放置左括号的条件是当前[左括号的数目不超过n]。\n每次可以放置右括号的条件是当前[右括号的数目不超过左括号的数目]。\ncase数&#x3D;Catalan&#x3D;C(n,m)&#x2F;(n+1)\n*&#x2F;\n&#x2F;&#x2F;正：已有cnt\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;string&gt; generateParenthesis(int n) &#123;\n        dfs(n, 0, 0, &quot;&quot;);\n        return ans;\n    &#125;\n     void dfs(int n,int lc,int rc, string seq) &#123;\n         if(lc &#x3D;&#x3D; n &amp;&amp; rc &#x3D;&#x3D; n) ans.push_back(seq);\n         else &#123;\n             if(lc &lt; n) dfs(n, lc + 1, rc, seq + &#39;(&#39;);\n             if(rc &lt; n &amp;&amp; lc &gt; rc) dfs(n, lc, rc + 1, seq + &#39;)&#39;);\n         &#125;\n     &#125;\n&#125;;\n\n&#x2F;&#x2F;反：还需要cnt\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;string&gt; generateParenthesis(int n) &#123;\n        dfs(n, n, &quot;&quot;);\n        return ans;\n    &#125;\n     void dfs(int lc,int rc, string seq) &#123;\n         if(!lc &amp;&amp; !rc) ans.push_back(seq);\n         else &#123;\n             if(lc &lt; rc) dfs(lc, rc - 1, seq + &#39;)&#39;);\n             if(lc) dfs(lc - 1, rc, seq + &#39;(&#39;);\n         &#125;\n     &#125;\n&#125;;\n\n\n\n\n！！！23. K路归并  heap  （148）&#x2F;&#x2F;小根堆，K个min入堆，insert:O(logK)\n&#x2F;&#x2F; priority_queue &lt;int,vector&lt;int&gt; ,greater&lt;int&gt;&gt; q;\nclass Solution &#123;\npublic:\n\n    struct Cmp &#123;\n        bool operator() (ListNode* a, ListNode* b) &#123;\n            return a-&gt;val &gt; b-&gt;val;\n        &#125;\n    &#125;;\n\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        priority_queue &lt;ListNode*,vector&lt;ListNode*&gt; , Cmp&gt; heap;\n        auto dummy &#x3D; new ListNode(-1), tail &#x3D; dummy;\n        for(auto l : lists) if(l) heap.push(l);\n\n        while(heap.size()) &#123;\n            auto t &#x3D; heap.top();\n            heap.pop();\n\n            tail &#x3D; tail-&gt;next &#x3D; t;\n            if(t-&gt;next) heap.push(t-&gt;next);\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n&#x2F;*\n(二分治合并) O(nlogk)  mergesort变形\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;71&#x2F;\n*&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) &#123;\n        ListNode *head &#x3D; new ListNode(0);\n        ListNode *cur &#x3D; head;\n        while (l1 !&#x3D; NULL &amp;&amp; l2 !&#x3D; NULL) &#123;\n            if (l1 -&gt; val &lt; l2 -&gt; val) &#123;\n                cur -&gt; next &#x3D; l1;\n                l1 &#x3D; l1 -&gt; next;\n            &#125;\n            else &#123;\n                cur -&gt; next &#x3D; l2;\n                l2 &#x3D; l2 -&gt; next;\n            &#125;\n            cur &#x3D; cur -&gt; next;\n        &#125;\n        cur -&gt; next &#x3D; (l1 !&#x3D; NULL ? l1 : l2);\n        return head -&gt; next;\n    &#125;\n\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        if (lists.size() &#x3D;&#x3D; 0)\n            return NULL;\n        if (lists.size() &#x3D;&#x3D; 1)\n            return lists[0];\n\n        int mid &#x3D; lists.size() &#x2F; 2;\n        vector&lt;ListNode*&gt; left &#x3D; vector&lt;ListNode*&gt;(lists.begin(), lists.begin() + mid);\n        vector&lt;ListNode*&gt; right &#x3D; vector&lt;ListNode*&gt;(lists.begin() + mid, lists.end());\n        ListNode *l1 &#x3D; mergeKLists(left);\n        ListNode *l2 &#x3D; mergeKLists(right);\n        return merge2Lists(l1, l2);\n    &#125;\n&#125;;\n\n\nJava O(NlogK)\n\n【堆】  22归并 自底向上\n\n\n\nDP向上 【链表模拟每层merge】（用于148题：排序链表）\n\n\n\n3.归并  自顶向下 [分治]\n\n\n24. 两两交换链表中的节点 pabclass Solution &#123;\npublic:\n    ListNode* swapPairs(ListNode* head) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n\n        for(auto p &#x3D; dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;\n            auto a &#x3D; p-&gt;next, b &#x3D; a-&gt;next;\n            p-&gt;next &#x3D; b;\n            a-&gt;next &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            p &#x3D; a;\n        &#125;\n         return dummy-&gt;next;\n    &#125;\n&#125;;\n\n\n\n25.&lt;-24  K_swap\nclass Solution &#123;\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n        for(auto p &#x3D; dummy;;) &#123;\n            auto q &#x3D; p;\n            for(int i &#x3D; 0; i &lt; k &amp;&amp; q; i++) q &#x3D; q-&gt;next;\n            if(!q) break;\n            auto a &#x3D; p-&gt;next, b &#x3D; a-&gt;next;\n            for(int i &#x3D; 0; i &lt; k - 1; i++) &#123; &#x2F;&#x2F;a+&#x3D;2 &#x3D; k-1\n                auto c &#x3D; b-&gt;next;\n                b-&gt;next &#x3D; a;\n                a &#x3D; b, b &#x3D; c;\n            &#125;\n            auto c &#x3D; p-&gt;next; &#x2F;&#x2F;c\n            p-&gt;next &#x3D; a, c-&gt;next &#x3D; b;\n            p &#x3D;  c;\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n\n\n26. 删除排序数组中的重复项：双指针原地覆盖&#x2F;*\n原地覆盖val：不开数组不递归\nSTL:unique  双指针\n*&#x2F;\nclass Solution &#123;\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        int k &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)\n            if(!i || nums[i] !&#x3D; nums[i - 1]) &#x2F;&#x2F;i&#x3D;&#x3D;0 or !&#x3D;\n                nums[k++] &#x3D; nums[i];\n        \n        return k;\n    &#125;\n&#125;;\n\n\n\n27.&lt;-26   val去重&#x2F;&#x2F;27&lt;-26   val去重\nclass Solution &#123;\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;\n\t\tint k &#x3D; 0;\n\t\tfor(int i &#x3D; 0; i &lt; nums.size(); i++)\n\t\t\tif(nums[i] !&#x3D; val) &#x2F;&#x2F;\n\t\t\t\tnums[k++] &#x3D; nums[i];\n\t\treturn k;\n    &#125;\n&#125;;\n\n\n\n\n\n28. 实现 strStr()    裸KMP&#x2F;&#x2F;KMP 字符串哈希 BM Sunday\nclass Solution &#123;\npublic:\n\tint strStr(string s, string p) &#123;\n\t\tif(p.empty()) return 0;\n\t\tint n &#x3D; s.size(), m &#x3D; p.size();\n\t\ts &#x3D; &#39; &#39; + s, p &#x3D; &#39; &#39; + p;\n\n\t\tvector&lt;int&gt; next(m + 1);\n\t\t&#x2F;&#x2F;next[1] &#x3D; 0; &#x2F;&#x2F;求next\n\t\tfor(int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i++) &#123;\n\t\t\twhile(j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; next[j];\n\t\t\tif(p[i] &#x3D;&#x3D; p[j + 1]) j++;\n\t\t\tnext[i] &#x3D; j;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 匹配\n\t\tfor(int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n\t\t\twhile(j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; next[j];\n\t\t\tif(s[i] &#x3D;&#x3D; p[j + 1]) j++;\n\t\t\tif(j &#x3D;&#x3D; m) return i - m; &#x2F;&#x2F; (i - m + 1)-1 ,idx from 1\n\t\t&#125;\n\n\t\treturn -1;\n\t&#125;\n&#125;;\n\n\n\n\n\n29. 两数相除(only+-  qmi二进制划分)\n\n如果除法结果溢出(所以要LL！！！！！)，则返回 2^31^ − 1。\n&#x2F;&#x2F;29 两数相除 a&#x2F;b&#x3D;(110)&#x3D;2^1+2^2 O(log30)\n&#x2F;&#x2F;思想：2分&#x2F;倍增&#x2F;快速幂&#x2F;二进制划分\nclass Solution &#123;\npublic:\n\tint divide(int x, int y) &#123;\n\t\ttypedef long long LL;\n\t\tvector&lt;LL&gt; exp;\n\t\tbool is_minus &#x3D; false;\n\t\tif(x &gt; 0 &amp;&amp; y &lt; 0 || x &lt; 0 &amp;&amp; y &gt; 0) is_minus &#x3D; true;\n\n\t\tLL a &#x3D; abs((LL) x), b &#x3D; abs((LL) y);&#x2F;&#x2F;(LL) (-2^31)&#x2F;(-1)&#x3D;2^31溢出\n\t\tfor(LL i &#x3D; b; i &lt;&#x3D; a; i &#x3D; i + i) exp.push_back(i); &#x2F;&#x2F;LL i qmi思想变形\n\n\t\tLL res &#x3D; 0;\n\t\tfor(int i &#x3D; exp.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n\t\t\tif(a &gt;&#x3D; exp[i]) &#123;\n\t\t\t\ta -&#x3D; exp[i];\n\t\t\t\tres +&#x3D; 1ll &lt;&lt; i; &#x2F;&#x2F;二进制划分 2^31溢出 1ll!!!!!\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif(is_minus) res &#x3D; -res;\n\t\tif(res &lt; INT_MIN || res &gt; INT_MAX) res &#x3D; INT_MAX;&#x2F;&#x2F;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n30.串联所有[等长]单词的子串(分组+滑动窗口 2*hash表:tot wd 同LC76~)\n&#x2F;&#x2F;–  (tot-1)&lt;tot [tot内]\n&#x2F;&#x2F;(tot-1)++  &lt;&#x3D;tot [tot内]\nif(cnt &#x3D;&#x3D; m) res.push_back(j - (m - 1) * w); &#x2F;&#x2F;“j_end”右移了一个w\n&#x2F;&#x2F;30 串联所有单词的子串\n&#x2F;&#x2F;best解法 str_hash&#x2F;Rabin_Karp: O(n)&#x3D;O(n&#x2F;w)*w\n&#x2F;&#x2F;双指针： O(n*w)&#x3D;O(n&#x2F;w*w)*w     一些【长度相同】的单词 words  等长，可优化\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;\n        vector&lt;int&gt; res;\n        if(words.empty()) return res;\n        int n &#x3D; s.size(), m &#x3D; words.size(), w &#x3D; words[0].size();\n        unordered_map&lt;string, int&gt; tot;\n        for(auto&amp; word : words) tot[word] ++;\n\n        for(int i &#x3D; 0; i &lt; w; i++) &#123;\n            unordered_map&lt;string, int&gt; wd;\n            int cnt &#x3D; 0;\n            for(int j &#x3D; i; j + w &lt;&#x3D; n; j +&#x3D; w) &#123; &#x2F;&#x2F;m * w固定滑动窗口\n                if(j &gt;&#x3D; i + m * w) &#123;\n                    auto word &#x3D; s.substr(j - m * w, w);\n                    wd[word]--;\n                    if(wd[word] &lt; tot[word]) cnt--; &#x2F;&#x2F;--  (tot-1)&lt;tot [tot内]\n                &#125;\n                auto word &#x3D; s.substr(j, w);\n                wd[word]++;\n                if(wd[word] &lt;&#x3D; tot[word]) cnt++; &#x2F;&#x2F;(tot-1)++  &lt;&#x3D;tot [tot内]\n                if(cnt &#x3D;&#x3D; m) res.push_back(j - (m - 1) * w); &#x2F;&#x2F;&quot;j_end&quot;右移了一个w\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n31. nextPermutation 13,542-&gt;14,235“&lt;-“找到第一个非降序: 与【&gt;它的min】 swap，reverse(降序)为升序\nclass Solution &#123;\npublic:\n\tvoid nextPermutation(vector&lt;int&gt;&amp; nums) &#123;\n\t\tint k &#x3D; nums.size() - 1;\n\t\twhile(k &gt; 0 &amp;&amp; nums[k - 1] &gt;&#x3D; nums[k]) k--;\n\t\tif(k &lt;&#x3D; 0) &#123;\n\t\t\treverse(nums.begin(), nums.end());\n\t\t&#125; else &#123;\n\t\t\tint t &#x3D; k;&#x2F;&#x2F;需要小升一下的数\n\t\t\twhile(t &lt; nums.size() &amp;&amp; nums[t] &gt; nums[k - 1]) t++;&#x2F;&#x2F;t恰好&lt;&#x3D;\n\t\t\tswap(nums[t - 1], nums[k - 1]);&#x2F;&#x2F;t-1恰好&gt; min(&gt;) swap\n\t\t\treverse(nums.begin() + k, nums.end());\n\t\t&#125;\n\t&#125;\n&#125;;\n\n\n\n32. 最长有效括号 分段合法stk&#x2F;cnt&#x2F;DP（反证）[合法序列]分段思想！！！ \n\n&#x2F;&#x2F;yxc stack\nclass Solution &#123;\npublic:\n\tint longestValidParentheses(string s) &#123;\n\t\tstack&lt;int&gt; stk;\n\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0, start &#x3D; -1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F;start&#x3D;&#x3D;区间的prev\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;(&#39;) stk.push(i);\n\t\t\telse &#123;\n\t\t\t\tif (stk.size()) &#123;\n\t\t\t\t\tstk.pop();\n\t\t\t\t\tif (stk.size())\n\t\t\t\t\t\tans &#x3D; max(ans, i - stk.top());\n\t\t\t\t\telse\n\t\t\t\t\t\tans &#x3D; max(ans, i - start);\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tstart &#x3D; i;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;;\n\n&#x2F;*\nO(n) 3种解法 https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;114&#x2F;\n双向扫描cnt法：\n(+1 )-1 [start,i]区间 &lt;0更新start&#x3D;i+1;&#x3D;&#x3D;0更新答案;&gt;0略过 &quot;()(((&quot;反向扫描&lt;-解决\n*&#x2F;\nclass Solution &#123;\npublic:\n\tint longestValidParentheses(string s) &#123;\n\t\tint n &#x3D; s.length();\n\t\tint start &#x3D; 0, val &#x3D; 0, ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;(&#39;) val++;\n\t\t\telse val--;\n\t\t\tif (val &lt; 0) &#123;\n\t\t\t\tval &#x3D; 0;\n\t\t\t\tstart &#x3D; i + 1;&#x2F;&#x2F;合法段：分段合法\n\t\t\t&#125;\n\t\t\telse if (val &#x3D;&#x3D; 0)\n\t\t\t\tans &#x3D; max(ans, i - start + 1);\n\t\t&#125;\n\n\t\tstart &#x3D; n - 1; val &#x3D; 0;\n\t\tfor (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;)&#39;) val++;\n\t\t\telse val--;\n\t\t\tif (val &lt; 0) &#123;\n\t\t\t\tval &#x3D; 0;\n\t\t\t\tstart &#x3D; i - 1;\n\t\t\t&#125;\n\t\t\telse if (val &#x3D;&#x3D; 0)\n\t\t\t\tans &#x3D; max(ans, start - i + 1);\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;;\n\n\n&#x2F;*\n(栈) O(n)  类似于法一！\n1.用栈维护当前待匹配的左括号的位置。同时用start记录一个新的可能合法的子串的起始位置。初始设为 0。\n2.遇到左括号，当前位置进栈。\n3.遇到右括号，如果当前栈不空，则当前栈顶出栈。\n出栈后，如果栈为空，则更新答案 i - start + 1；否则更新答案 i - st.top()。\n4.遇到右括号且当前栈为空，则当前的 start 开始的子串不再可能为合法子串了，下一个合法子串的起始位置是 i + 1，\n更新 start &#x3D; i + 1。\n*&#x2F;\nclass Solution &#123;\npublic:\n\tint longestValidParentheses(string s) &#123;\n\t\tint n &#x3D; s.length();\n\t\tstack&lt;int&gt; st;\n\n\t\tint start &#x3D; 0, ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;(&#39;)\n\t\t\t\tst.push(i);\n\t\t\telse &#123;\n\t\t\t\tif (!st.empty()) &#123;\n\t\t\t\t\tst.pop();\n\t\t\t\t\tif (st.empty())\n\t\t\t\t\t\tans &#x3D; max(ans, i - start + 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tans &#x3D; max(ans, i - st.top());\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tstart &#x3D; i + 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;;\n\n&#x2F;*\n(动态规划) O(n)  难想！\n1.设 f(i) 为以 i 为结尾的最长合法子串。\n2.初始时，f(0)&#x3D;0。\n3.转移时，我们仅考虑当前字符是 ) 的时候。如果上一个字符是 (，即 ...() 结尾的情况，则 f(i)&#x3D;f(i−1)+2。\n4.如果上一个字符是 )，即 ...)) 的情况，则我们通过上一个字符的动规结果，判断是否能匹配末尾的 )。判断 s[i - f(i - 1) - 1] 是 (，即 ...((合法))，则可以转移 f(i)&#x3D;f(i−1)+2+f(i−f(i−1)−2)。\n5.最终答案为动规数组中的最大值。\n*&#x2F;\nclass Solution &#123;\npublic:\n\tint longestValidParentheses(string s) &#123;\n\t\tint n &#x3D; s.length();\n\t\tvector&lt;int&gt; f(n, 0);\n\t\tfor (int i &#x3D; 1; i &lt; n; i++)\n\t\t\tif (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;\n\t\t\t\tif (s[i - 1] &#x3D;&#x3D; &#39;(&#39;) &#123;\n\t\t\t\t\tif (i &gt;&#x3D; 2) f[i] &#x3D; f[i - 2] + 2;\n\t\t\t\t\telse f[i] &#x3D; 2;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tif (i - f[i - 1] - 1 &gt;&#x3D; 0 &amp;&amp; s[i - f[i - 1] - 1] &#x3D;&#x3D; &#39;(&#39;)\n\t\t\t\t\t\tif (i - f[i - 1] - 2 &gt;&#x3D; 0)\n\t\t\t\t\t\t\tf[i] &#x3D; f[i - 1] + 2 + f[i - f[i - 1] - 2];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tf[i] &#x3D; f[i - 1] + 2;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\tint ans &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t\tans &#x3D; max(ans, f[i]);\n\n\t\treturn ans;\n\t&#125;\n&#125;;\n\n\n\n33.搜索旋转排序数组H (二分l &#x3D; mid;—-&gt;+1 两段性:&gt;&#x3D; nums[0] 1段满足 2段不满足)分界点二分  find性质 &gt;&#x3D; nums[0]：1段满足 2段不满足\nelse l &#x3D; mid + 1;&#x2F;&#x2F;mid属于左半边 版本一\nelse r &#x3D; mid - 1;&#x2F;&#x2F;mid属于右半边 版本二 l &#x3D; mid;—-&gt;+1【l &#x3D; mid;—–&gt; int mid &#x3D; l + r + 1 &gt;&gt; 1;】\nclass Solution &#123;\npublic:\n\tint search(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tif(nums.empty()) return -1;\n\t\t&#x2F;&#x2F;二分两段\n\t\tint l &#x3D; 0, r &#x3D; nums.size() - 1;\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; nums[0]) l &#x3D; mid;\n\t\t\telse r &#x3D; mid - 1;&#x2F;&#x2F;mid属于右半边 版本二 +1\n\t\t&#125;\n\t\t&#x2F;&#x2F;l&#x3D;r&#x3D;mid &gt;&#x3D;n[0]:target定在哪一段\n\t\tif(target &gt;&#x3D; nums[0]) l &#x3D; 0;\n\t\telse l &#x3D; r + 1, r &#x3D; nums.size() - 1;\n\t\t\n\t\t&#x2F;&#x2F; 二分 &gt;&#x3D;target的min\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; target) r &#x3D; mid;\n\t\t\telse l &#x3D; mid + 1;&#x2F;&#x2F;mid属于左半边 版本一\n\t\t&#125;\n\t\t&#x2F;&#x2F; (不)存在\n\t\tif(nums[r] &#x3D;&#x3D; target) return r;\n\t\treturn -1;\n\t&#125;\n&#125;;\n\n\n\n34.在排序数组中查找元素的第一个和最后一个位置M(-&gt;二分&lt;-二分   &gt;&#x3D;&#x2F;&lt;&#x3D;target)\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tif(nums.empty()) return &#123;-1, -1&#125;;\n\t\t&#x2F;&#x2F;左端点\n\t\tint l &#x3D; 0, r &#x3D; nums.size() - 1;\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; target) r &#x3D; mid;\n\t\t\telse l &#x3D; mid + 1;\n\t\t&#125;\n\t\t&#x2F;&#x2F;不存在\n\t\tif(nums[r] !&#x3D; target) return &#123;-1, -1&#125;;\n\t\tint L &#x3D; r;\n\t\t&#x2F;&#x2F;右端点\n\t\tl &#x3D; 0, r &#x3D; nums.size() - 1;\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\t\tif(nums[mid] &lt;&#x3D; target) l &#x3D; mid;&#x2F;&#x2F;mid属右\n\t\t\telse r &#x3D; mid - 1;\n\t\t&#125;\n\t\treturn &#123;L, r&#125;;\n\t&#125;\n&#125;;\n\n\n\n\n\n35. 搜索【插入位置】E(&gt;&#x3D; target的min(first)  &lt;-二分  r&#x3D;size)class Solution &#123;\npublic:\n\tint searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\t&#x2F;&#x2F; &gt;&#x3D; target的min(first)  &lt;-二分\n\t\tint l &#x3D; 0, r &#x3D; nums.size(); &#x2F;&#x2F;size\n\n\t\twhile(l &lt; r) &#123; &#x2F;&#x2F;&lt;size 不加哨兵\n\t\t\tint mid &#x3D; l + r &gt;&gt; 1; &#x2F;&#x2F;下取整floor\n\t\t\tif(nums[mid] &gt;&#x3D; target) r &#x3D; mid;\n\t\t\telse l &#x3D; mid + 1;\n\t\t&#125;\n\t\treturn l;\n\t&#125;\n&#125;;\n\n\n\n36.有效的数独 判断行&#x2F;列&#x2F;九宫格不同 ( 模拟题 bool st[9];      ij &#x2F; ji &#x2F; ij+xy)class Solution &#123;\npublic:\n\tbool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n\t\tbool st[9];\n\n\t\t&#x2F;&#x2F;判断行\n\t\tfor (int i &#x3D; 0; i &lt; 9; i++) &#123;\n\t\t\tmemset(st, 0, sizeof st);\n\t\t\tfor (int j &#x3D; 0; j &lt; 9; j++) &#123;\n\t\t\t\tif(board[i][j] !&#x3D; &#39;.&#39;) &#123;\n\t\t\t\t\tint t &#x3D; board[i][j] - &#39;1&#39;;\n\t\t\t\t\tif(st[t]) return false; &#x2F;&#x2F;visited &#x3D;&#x3D;\n\t\t\t\t\tst[t] &#x3D; true;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;判断列 [j][i]\n\t\tfor (int i &#x3D; 0; i &lt; 9; i++) &#123;\n\t\t\tmemset(st, 0, sizeof st);\n\t\t\tfor (int j &#x3D; 0; j &lt; 9; j++) &#123;\n\t\t\t\tif(board[j][i] !&#x3D; &#39;.&#39;) &#123; &#x2F;&#x2F;\n\t\t\t\t\tint t &#x3D; board[j][i] - &#39;1&#39;; &#x2F;&#x2F;\n\t\t\t\t\tif(st[t]) return false;\n\t\t\t\t\tst[t] &#x3D; true;\n\t\t\t\t&#125;\n\t\t\t&#125; \n\t\t&#125;\n\n\t\t&#x2F;&#x2F;判断小方格[i + x][j + y]\n\t\tfor (int i &#x3D; 0; i &lt; 9; i +&#x3D; 3) &#123;\n\t\t\tfor (int j &#x3D; 0; j &lt; 9; j +&#x3D; 3) &#123;&#x2F;&#x2F;anchor:i j\n\t\t\t\tmemset(st, 0, sizeof st);\n\t\t\t\tfor (int x &#x3D; 0; x &lt; 3; x++)\n\t\t\t\t\tfor (int y &#x3D; 0; y &lt; 3; y++)&#x2F;&#x2F;offset:x y\n\t\t\t\t\t\tif(board[i + x][j + y] !&#x3D; &#39;.&#39;) &#123;\n\t\t\t\t\t\t\tint t &#x3D; board[i + x][j + y] - &#39;1&#39;;\n\t\t\t\t\t\t\tif(st[t]) return false;\n\t\t\t\t\t\t\tst[t] &#x3D; true;\n\t\t\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n&#125;;\n\n\n\n37.解数独 (r c  cell dfs 回溯)进阶： (0x20搜索9*9状压优化 )、16*16 \nrow[i][t] = col[j][t] = cell[i / 3][j / 3][t]\n填  变flag  dfs_next next行不通：回溯!\nclass Solution &#123;\npublic:\n\tbool row[9][9], col[9][9], cell[3][3][9];&#x2F;&#x2F;i行j列num出现过&#x3D;T&#x2F;F\n\n\tvoid solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n\t\tmemset(row, 0, sizeof row);\n\t\tmemset(col, 0, sizeof col);\n\t\tmemset(cell, 0, sizeof cell);\n\t\t\n\t\tfor (int i &#x3D; 0; i &lt; 9; i++)\n\t\t\tfor (int j &#x3D; 0; j &lt; 9; j++)\n\t\t\t\tif(board[i][j] !&#x3D; &#39;.&#39;) &#123;\n\t\t\t\t\tint t &#x3D; board[i][j] - &#39;1&#39;;\n\t\t\t\t\trow[i][t] &#x3D; col[j][t] &#x3D; cell[i &#x2F; 3][j &#x2F; 3][t] &#x3D; true;&#x2F;&#x2F;\n\t\t\t\t&#125;\n\t\tdfs(board, 0, 0);\n\t&#125;\n\n\tbool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123;\n\t\tif(y &#x3D;&#x3D; 9) x++, y &#x3D; 0;\n\t\tif(x &#x3D;&#x3D; 9) return true;\n\t\t&#x2F;&#x2F;cur不可填：next\n\t\tif(board[x][y] !&#x3D; &#39;.&#39;) return dfs(board, x, y + 1);\n\t\t&#x2F;&#x2F;可填：dfs搜cur填i\n\t\tfor (int i &#x3D; 0; i &lt; 9; i++)\n\t\t\tif(!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x &#x2F; 3][y &#x2F; 3][i]) &#123;\n\t\t\t\tboard[x][y] &#x3D; &#39;1&#39; + i;\n\t\t\t\trow[x][i] &#x3D; col[y][i] &#x3D; cell[x &#x2F; 3][y &#x2F; 3][i] &#x3D; true;\n\t\t\t\t&#x2F;&#x2F;递归更新next答案\n\t\t\t\tif(dfs(board, x, y + 1)) return true;\n\t\t\t\t&#x2F;&#x2F;next行不通：回溯!\n\t\t\t\tboard[x][y] &#x3D; &#39;.&#39;;\n\t\t\t\trow[x][i] &#x3D; col[y][i] &#x3D; cell[x &#x2F; 3][y &#x2F; 3][i] &#x3D; false;\n\t\t\t&#125;\n\t\treturn false;\n\t&#125;\n&#125;;\n\n\n\n\n\n\n38.外观数列(序列中的每一项都是对前一项的描述。 cnt+num) 双指针[j,k)class Solution &#123;\npublic:\n\tstring countAndSay(int n) &#123;\n\t\tstring s &#x3D; &quot;1&quot;;\n\t\tfor (int i &#x3D; 0; i &lt; n - 1; i++) &#123;&#x2F;&#x2F;第n项 变换n-1次\n\t\t\tstring t; &#x2F;&#x2F;t &#x3D; s;错！\n\t\t\t&#x2F;&#x2F;s[j,k):num&#x3D;&#x3D;\n\t\t\tfor (int j &#x3D; 0; j &lt; s.size();) &#123;\n\t\t\t\tint k &#x3D; j + 1;\n\t\t\t\twhile(k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; s[j]) k++;&#x2F;&#x2F;s[k]!&#x3D;s[j]\n\t\t\t\tt +&#x3D; to_string(k - j) + s[j];&#x2F;&#x2F;k-j个连续s[j]\n\t\t\t\tj &#x3D; k; &#x2F;&#x2F;别忘！！！\n\t\t\t&#125;\n\t\t\ts &#x3D; t;\n\t\t&#125;\n\t\treturn s;\n\t&#125;\n&#125;;\n\n\n\n\n\n39.组合总和(递归   无限制重复被选)&#x2F;*\n找出 不重复集candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的数字可以[无限制重复被选取]。\n\n说明：\n所有数字（包括 target）都是正整数。\n解集不能包含重复的组合。 \n*&#x2F;\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; ans;\n\tvector&lt;int&gt; path;\n\t\n\tvector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; c, int target) &#123;\n\t\tdfs(c, 0 , target);\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(vector&lt;int&gt;&amp; c, int u, int target) &#123; &#x2F;&#x2F;target&#x3D;剩余和\n\t\tif(target &#x3D;&#x3D; 0) &#123;\n\t\t\tans.push_back(path);\n\t\t\treturn;\n\t\t&#125;\n\t\tif(u &#x3D;&#x3D; c.size()) return;\n\t\t&#x2F;&#x2F;枚举选i个c[u]\n\t\tfor (int i &#x3D; 0; c[u] * i &lt;&#x3D; target; i++) &#123;\n\t\t\tdfs(c, u+1, target - c[u] * i);&#x2F;&#x2F;0 i&#x3D;1 2 3 4\n\t\t\tpath.push_back(c[u]);&#x2F;&#x2F;i&#x3D;1(用于next loop) 2 3 4 5F\n\t\t&#125;\n\t\t&#x2F;&#x2F;回溯所有c[u]\n\t\tfor (int i &#x3D; 0; c[u] * i &lt;&#x3D; target; i++) &#123;\n\t\t\tpath.pop_back();\n\t\t&#125;\n\t&#125;\n&#125;;\n\n\n\n\n40.组合总和II +个数限制cnt(有重复，sort)!!!\t\tsort(c.begin(),c.end());\n\t\t\n\t\tint k &#x3D; u + 1;\n\t\twhile(k &lt; c.size() &amp;&amp; c[k] &#x3D;&#x3D; c[u]) k++;\n\t\tint cnt &#x3D; k - u;&#x2F;&#x2F;c[u, k)&#x3D;&#x3D;  集合中共cnt个u\n\n\n\n&#x2F;*\n可重复集中所有可以使数字和为 target 的组合。\n每个数字在每个组合中只能使用一次\n【+given number个数限制：多重背包】\n解法：sort c[u, k)&#x3D;&#x3D; &#x2F; hash表:unordered_map\nc[u] * i &lt;&#x3D; target &amp;&amp; i &lt;&#x3D; cnt\n*&#x2F;\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; ans;\n\tvector&lt;int&gt; path;\n\n\tvector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; c, int target) &#123;\n\t\tsort(c.begin(),c.end());\n\t\tdfs(c, 0 , target);\n\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(vector&lt;int&gt;&amp; c, int u,  int target) &#123;\n\t\tif(target &#x3D;&#x3D; 0) &#123;\n\t\t\tans.push_back(path);\n\t\t\treturn;\n\t\t&#125;\n\t\tif(u &#x3D;&#x3D; c.size()) return;\n\n\t\tint k &#x3D; u + 1;\n\t\twhile(k &lt; c.size() &amp;&amp; c[k] &#x3D;&#x3D; c[u]) k++;\n\t\tint cnt &#x3D; k - u;&#x2F;&#x2F;集合中共cnt个u\n\t\t&#x2F;&#x2F;c[u]可用&lt;&#x3D;cnt个\n\t\tfor (int i &#x3D; 0; c[u] * i &lt;&#x3D; target &amp;&amp; i &lt;&#x3D; cnt; i++) &#123;\n\t\t\tdfs(c, k, target - c[u] * i);\n\t\t\tpath.push_back(c[u]);\n\t\t&#125;\n\n\t\tfor (int i &#x3D; 0; c[u] * i &lt;&#x3D; target &amp;&amp; i &lt;&#x3D; cnt; i++) &#123;\n\t\t\tpath.pop_back();\n\t\t&#125;\n\t&#125;\n&#125;;\n\n\n\n41. 缺失的第一个正数  unordered_setsort+scan,从1开始 ：O(nlogn)\nhash表：O(n) \nclass Solution &#123;\npublic:\n    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;int&gt; hash;\n        for(auto x : nums) hash.insert(x); &#x2F;&#x2F;for(auto x : nums)\n\n        int ans &#x3D; 1;\n        while(hash.count(ans)) ans ++; &#x2F;&#x2F;while\n\n        return ans;\n    &#125;\n&#125;;\n\n\n\n42. 接雨水(单调栈变形 难)\n\n算法1\n(三次线性扫描) O(n)\n观察整个图形，考虑对水的面积按 列 进行拆解\n注意到，每个矩形条上方所能接受的水的高度，是由它左边 最高的 矩形，和右边 最高的 矩形决定的。具体地，假设第 i 个矩形条的高度为 height[i]，且矩形条左边 最高的 矩形条的高度为 left_max[i]，右边 最高的 矩形条高度为 right_max[i]，则该矩形条上方能接受水的高度为 min(left_max[i], right_max[i]) - height[i]。\n需要分别从左向右扫描求 left_max，从右向左求 right_max，最后统计答案即可。\n注意特判 n 为 0。\n时间复杂度\n三次线性扫描，故只需要 O(n) 的时间。\n空间复杂度\n需要额外 O(n) 的空间记录每个位置左边最高的高度和右边最高的高度。\nC++ 代码\nclass Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        int n &#x3D; height.size(), ans &#x3D; 0;\n        if (n &#x3D;&#x3D; 0)\n            return 0;\n\n        vector&lt;int&gt; left_max(n), right_max(n);\n\n        left_max[0] &#x3D; height[0];\n        for (int i &#x3D; 1; i &lt; n; i++) \n            left_max[i] &#x3D; max(left_max[i - 1], height[i]);\n\n        right_max[n - 1] &#x3D; height[n - 1];\n        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--)\n            right_max[i] &#x3D; max(right_max[i + 1], height[i]);\n\n        for (int i &#x3D; 0; i &lt; n; i++)\n            ans +&#x3D; min(left_max[i], right_max[i]) - height[i]; &#x2F;&#x2F;\n\n        return ans;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;改进版：双指针\nclass Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        int n &#x3D; height.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int l &#x3D; 0, r &#x3D; n - 1;\n        int leftmost &#x3D; height[l], rightmost &#x3D; height[r];\n        int res &#x3D; 0;\n        while (l &lt;&#x3D; r) &#123;\n            if (leftmost &lt; rightmost) &#123;\n                res +&#x3D; leftmost - height[l++];\n                leftmost &#x3D; max(leftmost, height[l]);\n            &#125; else &#123;\n                res +&#x3D; rightmost - height[r--];\n                rightmost &#x3D; max(rightmost, height[r]);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n作者：小雨\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;499&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n    \n\n算法2\n(单调栈) O(n)\n换一种思路，考虑每个位置左边和右边 第一个 比自身不低的矩形条，以及三个矩形条构成的 U 型，相当于对水的面积按 行 进行拆解。\n维护严格单调递减的单调栈。在每次检查栈顶要出栈时，i 为右边第一个比 st.top() 不低的矩形，st.top() 弹出栈顶，并将其记为 top。\n假设此时栈中仍然存在矩形，现在 st.top()（弹栈后的栈顶）、top 与 i 三个位置构成一个 U 型，其中 top 位置代表 U 型的底部，此时可以计算出该 U 型所能接受的水的面积为 (i - st.top() - 1) * (min(height[st.top()], height[i]) - height[top])。\n最后当前矩形进栈。\n时间复杂度\n每个元素最多进栈一次出栈一次，故只需要 O(n) 的时间。\n空间复杂度\n需要额外 O(n) 的空间存储单调栈。\nC++ 代码\nclass Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        int n &#x3D; height.size(), ans &#x3D; 0;\n        stack&lt;int&gt; st;\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            while (!st.empty() &amp;&amp; height[st.top()] &lt;&#x3D; height[i]) &#123;\n                int top &#x3D; st.top();\n                st.pop();\n                if (st.empty()) break;\n                ans +&#x3D; (i - st.top() - 1) \n                        * (min(height[st.top()], height[i]) - height[top]);\n            &#125;\n            st.push(i);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;121&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n43 字符串相乘(str竖式乘&#x2F;高精度乘法的基本模板)     C[i + j] +&#x3D; A[i] * B[j];  统一进位 去首0\nclass Solution &#123;\npublic:\n    string multiply(string num1, string num2) &#123;\n        vector&lt;int&gt; A, B;\n        int n &#x3D; num1.size(), m &#x3D; num2.size();\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) A.push_back(num1[i] - &#39;0&#39;);&#x2F;&#x2F;+-&#39;0&#39;\n        for(int i &#x3D; m - 1; i &gt;&#x3D; 0; i--) B.push_back(num2[i] - &#39;0&#39;);\n\n        vector&lt;int&gt; C(n + m);\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; m; j++)\n                C[i + j] +&#x3D; A[i] * B[j];\n\n        for(int i &#x3D; 0, t &#x3D; 0; i &lt; C.size(); i++) &#123;\n            t +&#x3D; C[i];\n            C[i] &#x3D; t % 10; &#x2F;&#x2F;t % 10\n            t &#x2F;&#x3D; 10;\n        &#125;\n\n        int k &#x3D;  C.size() - 1;\n        while(k &gt; 0 &amp;&amp; !C[k]) k--; &#x2F;&#x2F;去除首0     k&gt;&#x3D;0错！:0*0&#x3D;&quot;&quot; !&#x3D;&quot;0&quot;\n\n        string res;\n        while(k &gt;&#x3D; 0) res +&#x3D; C[k--] + &#39;0&#39;;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n\n—44.通配符匹配(10.简化版)DP *单独匹一切\n&#x2F;*\n&#39;?&#39; 可以匹配任何单个字符。\n&#39;*&#39; 可以匹配任意字符串（包括空字符串）。 可以不同\n*&#x2F;\nclass Solution &#123;\npublic:\n    bool isMatch(string s, string p) &#123;\n        int n &#x3D; s.size(), m &#x3D; p.size();\n        s &#x3D; &#39; &#39; + s, p &#x3D; &#39; &#39; + p; &#x2F;&#x2F; 1开始  易忘！！！\n        vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1));\n        f[0][0] &#x3D; true;\n\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++)\n            for(int j &#x3D; 1; j &lt;&#x3D; m; j++)\n                if(p[j] &#x3D;&#x3D; &#39;*&#39;)\n                    f[i][j] &#x3D; f[i][j - 1] || i &amp;&amp; f[i - 1][j];\n                else if(s[i] &#x3D;&#x3D; p[j] || p[j] &#x3D;&#x3D; &#39;?&#39;)\n                    f[i][j] &#x3D; i &amp;&amp; f[i - 1][j - 1];\n\n        return f[n][m]; \n    &#125;\n&#125;;\n\n&#x2F;*法二：贪心 AC自动机 wildcard matchinghttps://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/*&#x2F;\n45.跳跃游戏 II  贪心(优化逆DP) last:最早的可以一步到达 i 的位置, 随着 i 单调递增&#x2F;*\n给定一个非负整数数组，你最初位于数组的第一个位置。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n目标是out[使用最少的跳跃次数]到达数组的最后一个位置。\n\n最短路模型时间复杂度必然会到 O(n*n)\n\n对方法一优化：(动态规划，+贪心优化) O(n*n)--&gt;O(n)\n首先定义两个指针 last 和 i，数组 f[i] 表示到达 i 所需要的最少步数。\n定义 last 为第一次到达 i 时上一步的位置，last 从 0 开始。\n根据贪心得知，令 f[i] &#x3D; f[last] + 1 后，f[i] 就会是最优值。\n故可以根据 i 来让 last 向后移动，找到【最早的可以一步到达 i 的位置】，然后根据 f[last] 更新 f[i]。\n\n核心思想是动态规划，即 f[i] 表示到达 i 的最少步数。转移时，可以利用贪心来优化，免除了循环 n 来寻找可以转移到位置 i 的最优决策。\n【最早的可以一步到达 i 的位置】：\n这里的贪心思想为，如果在某个位置 last 可以一步到达 i，则 last 之后的位置就都不必再枚举了，\n而且这个 last 是随着 i 单调递增的，所以我们在动态规划的过程中，维护 last 变量。\n\nlast 一定是随着 i 递增的：\n如果有小于 last 的点可以到达 i，会产生矛盾\n假设 last′&lt;last 且也可以到达 i，可以考虑在什么情况下会放弃 last′ 的位置继续向后移动呢？根据算法定义，\n一定存在某个点 j，满足 j&gt;last′+num(last′)，而 i&gt;j，所以 i&gt;last′+num(last′)，即 last′ 一定无法到达 i，矛盾。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; f(n);\n        f[0] &#x3D; 0;\n        int last &#x3D; 0;\n\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            &#x2F;&#x2F; 依次求 f[i] 的值。\n            while (i &gt; last + nums[last]) &#x2F;&#x2F; 【最早的可以一步到达 i 的位置】 根据 i 来更新 last。\n                last++; &#x2F;&#x2F;[last 一定是随着 i 递增的]\n\n            f[i] &#x3D; f[last] + 1; &#x2F;&#x2F; 根据 f[last] 更新 f[i]。\n        &#125;\n        return f[n - 1];\n    &#125;\n&#125;;\n\n&#x2F;*方法一：&lt;-反向查找出发位置 递推 O(n*n)如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？直观上来看，我们可以「贪心」地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。因此，我们可以从左到右遍历数组，选择第一个满足要求的位置。\n方法二：正向查找可到达的最大位置  O(n)从下标 0 出发，[最远可到达]下标 2（max_far）。下标 0 可到达的位置中，下标 1 的值是 3，[从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。]！且last有单调性！在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。*&#x2F;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/\nclass Solution &#123;\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) \n    &#123;\n        int max_far &#x3D; 0;&#x2F;&#x2F; 目前能跳到的最远位置\n        int step &#x3D; 0;   &#x2F;&#x2F; 跳跃次数\n        int end &#x3D; 0;    &#x2F;&#x2F; 上次跳跃可达范围右边界（下次的最右起跳点）\n        for (int i &#x3D; 0; i &lt; nums.size() - 1; i++)\n        &#123;\n            max_far &#x3D; std::max(max_far, i + nums[i]);\n            &#x2F;&#x2F; 到达上次跳跃能到达的右边界了\n            if (i &#x3D;&#x3D; end)\n            &#123;\n                end &#x3D; max_far;  &#x2F;&#x2F; 目前能跳到的最远位置变成了下次起跳位置的有边界\n                step++;         &#x2F;&#x2F; 进入下一次跳跃\n            &#125;\n        &#125;\n        return step;\n    &#125;\n&#125;;\n\n\n\n46.全排列搜索树一共有 n!+n!&#x2F;2!+n!&#x2F;3!+…&#x3D;n!(1+1&#x2F;2!+1&#x2F;3!+…)≤n!(1+1&#x2F;2+1&#x2F;4+1&#x2F;8+…)&#x3D;2n!个内部节点，在每个内部节点内均会for循环 n 次，因此内部节点的计算量也是 O(n×n!)。 所以总时间复杂度是 O(n×n!)。\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;bool&gt; st;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) st.push_back(false);\n        dfs(nums, 0);\n        return ans;\n    &#125;\n\n    void dfs(vector&lt;int&gt; &amp;nums, int u)\n    &#123;\n        if (u &#x3D;&#x3D; nums.size())\n        &#123;\n            ans.push_back(path);\n            return ;\n        &#125;\n\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ )\n            if (!st[i])\n            &#123;\n                st[i] &#x3D; true;\n                path.push_back(nums[i]); &#x2F;&#x2F; path[u] &#x3D; nums[i];\n                dfs(nums, u + 1);\n                st[i] &#x3D; false;\n                path.pop_back(); &#x2F;&#x2F; 没有了vector&lt;bool&gt;(nums.size()); 就必须pop！！！\n            &#125;\n    &#125;\n&#125;;\n\n\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;bool&gt; st;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        st &#x3D; vector&lt;bool&gt;(nums.size()); &#x2F;&#x2F;\n        path &#x3D; vector&lt;int&gt;(nums.size()); &#x2F;&#x2F;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) st.push_back(false);\n        dfs(nums, 0);\n        return ans;\n    &#125;\n\n    void dfs(vector&lt;int&gt; &amp;nums, int u)\n    &#123;\n        if (u &#x3D;&#x3D; nums.size())\n        &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ )\n            if (!st[i])\n            &#123;\n                path[u] &#x3D; nums[i];\n                st[i] &#x3D; true;\n                dfs(nums, u + 1);\n                st[i] &#x3D; false;\n                &#x2F;&#x2F;path[u] &#x3D; 0; &#x2F;&#x2F;false 就会覆盖,需要配合&#x2F;&#x2F; &#x2F;&#x2F; !!!\n            &#125;\n    &#125;\n&#125;;\n\n\npolicy2: 字母枚举位置：字典序\nhttps://www.acwing.com/solution/content/4340/\n这两段代码只有两个字母之差：path[u] &#x3D; nums[i]; &#x2F;&#x2F;将未使用过的数字放到指定位置\npath[i] &#x3D; nums[u]; &#x2F;&#x2F;将指定数字放入未使用的位置\n47. 全排列II（有重复数字）\n&#x2F;*\n相同数字不可跳着用，必须挨个用！\n本质就是对于重复的点之间相对位置不变。如[1,1,1,3,3],在放第一个1的位置后，后面的1不能放在其前面，\n这样就避免了重复\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;bool&gt; st;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(), nums.end()); &#x2F;&#x2F;\n        st &#x3D; vector&lt;bool&gt;(nums.size()); &#x2F;&#x2F;\n        path &#x3D; vector&lt;int&gt;(nums.size()); &#x2F;&#x2F;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) st.push_back(false);\n        dfs(nums, 0);\n        return ans;\n    &#125;\n\n    void dfs(vector&lt;int&gt; &amp;nums, int u)\n    &#123;\n        if (u &#x3D;&#x3D; nums.size())\n        &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ )\n            if (!st[i])\n            &#123;\n            \tif(i &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i] &amp;&amp; ! st[i - 1]) continue; &#x2F;&#x2F;跳着用\n                path[u] &#x3D; nums[i];\n                st[i] &#x3D; true;\n                dfs(nums, u + 1);\n                st[i] &#x3D; false;\n            &#125;\n    &#125;\n&#125;;\n\n\n\n\n\n48.旋转图像\n方阵  顺时针旋转90度&#x3D;&#x3D;沿对角线翻转+沿纵轴翻转（swap）\nclass Solution &#123;\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; i; j++)\n                swap(matrix[i][j], matrix[j][i]);\n\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0, k &#x3D; n - 1; j &lt; k; j++, k--)\n                swap(matrix[i][j], matrix[i][k]);\n    &#125;\n&#125;;\n\n\n\n\n49.字母异位词分组(sort正序做hash索引)\n或者想出一种与字母顺序无关的str_hash法\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;\n        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;\n        for(auto&amp; str: strs) &#123;\n            string nstr &#x3D; str;\n            sort(nstr.begin(), nstr.end());\n            hash[nstr].push_back(str);\n        &#125;\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n        for(auto&amp; item: hash) res.push_back(item.second);\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n\n\n\n50.Pow(x, n) qmi模板  二进制拆分\nclass Solution &#123;\npublic:\n    double myPow(double x, int n) &#123;\n        typedef long long LL;\n        bool is_minus &#x3D; n &lt; 0;\n        double res &#x3D; 1;\n        for(LL k &#x3D; abs(LL(n)); k; k &gt;&gt;&#x3D; 1) &#123;\n            if(k &amp; 1) res *&#x3D; x;\n            x *&#x3D; x;\n        &#125;\n        if(is_minus) res &#x3D; 1 &#x2F; res;\n        return res;\n    &#125;\n&#125;;\n\n\n\n51.N皇后：case  col[i] dg[u - i + n] udg[u + i]  O(n*n!)\nclass Solution &#123;\npublic:\n    int n;\n    vector&lt;bool&gt; col, dg, udg;\n    vector&lt;vector&lt;string&gt;&gt; ans;\n    vector&lt;string&gt; path;\n\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int _n) &#123;\n        n &#x3D; _n;\n        col &#x3D; vector&lt;bool&gt;(n);\n        dg &#x3D; udg &#x3D; vector&lt;bool&gt;(n * 2);\n        path &#x3D; vector&lt;string&gt;(n, string(n, &#39;.&#39;));\n\n        dfs(0);\n        return ans;\n    &#125;\n\n    void dfs(int u) &#123;\n        if(u &#x3D;&#x3D; n) &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            if(!col[i] &amp;&amp; !dg[u - i + n] &amp;&amp; !udg[u + i]) &#123;\n                col[i] &#x3D; dg[u - i + n] &#x3D; udg[u + i] &#x3D; true;\n                path[u][i] &#x3D; &#39;Q&#39;;\n                dfs(u + 1);\n                path[u][i] &#x3D; &#39;.&#39;;\n                col[i] &#x3D; dg[u - i + n] &#x3D; udg[u + i] &#x3D; false;\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n52.N皇后II   case数   if(u &#x3D;&#x3D; n) return 1;  res +&#x3D; dfs(u + 1);  O(n!)&#x2F;&#x2F;52 N皇后II    51---&gt;res.size() if(u &#x3D;&#x3D; n) return 1;  res +&#x3D; dfs(u + 1);\nclass Solution &#123;\npublic:\n    int n;\n    vector&lt;bool&gt; col, dg, udg;\n    \n    int totalNQueens(int _n) &#123;\n        n &#x3D; _n;\n        col &#x3D; vector&lt;bool&gt;(n);\n        dg &#x3D; udg &#x3D; vector&lt;bool&gt;(n * 2);\n\n        return dfs(0);\n    &#125;\n\n    int dfs(int u) &#123;\n        if(u &#x3D;&#x3D; n) return 1;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            if(!col[i] &amp;&amp; !dg[u - i + n] &amp;&amp; !udg[u + i]) &#123;\n                col[i] &#x3D; dg[u - i + n] &#x3D; udg[u + i] &#x3D; true;\n                res +&#x3D; dfs(u + 1);\n                col[i] &#x3D; dg[u - i + n] &#x3D; udg[u + i] &#x3D; false;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n—[why? yxc版分治是O(n)?] 53.最大子序和  DP：f[i] &#x3D; max(nums[i], nums[i] + f[i-1])、 分治：&lt;–mid–&gt; lmax:区间前一半的最大后缀和  rmax:区间后一半的最大前缀和\n&#x2F;&#x2F;DP T&#x3D;O(n)  S&#x3D;O(1)   f[i] &#x3D; max(nums[i], nums[i] + f[i-1])\nclass Solution &#123;\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; INT_MIN;\n        for(int i &#x3D; 0, last &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            last &#x3D; nums[i] + max(last, 0);\n            res &#x3D; max(res, last);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n&#x2F;&#x2F;分治 O(n) why？？？\n&#x2F;* yxc\n(不)跨  前后半区间和sum\nres.ls &#x3D; max(L.ls, L.sum + R.ls);\nres.rs &#x3D; max(R.rs, R.sum + L.rs);\n*&#x2F;\nclass Solution &#123;\npublic:\n    struct Node &#123;\n        int sum, s, ls, rs;\n    &#125;;\n\n    Node build(vector&lt;int&gt;&amp; nums, int l, int r) &#123;\n        if(l &#x3D;&#x3D; r) &#123;\n            int v &#x3D; max(nums[l], 0); &#x2F;&#x2F;所以特判全负\n            return &#123;nums[l], v, v, v&#125;;\n        &#125;\n        int mid &#x3D; (l + r) &gt;&gt; 1;\n        auto L &#x3D; build(nums, l, mid), R &#x3D; build(nums, mid + 1, r);\n        Node res;\n        res.sum &#x3D; L.sum + R.sum;\n        res.s &#x3D; max(max(L.s, R.s), L.rs + R.ls);\n        res.ls &#x3D; max(L.ls, L.sum + R.ls);\n        res.rs &#x3D; max(R.rs, R.sum + L.rs);\n        return res;\n    &#125;\n\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; INT_MIN;\n        for(auto x: nums) res &#x3D; max(res, x);\n        if(res &lt; 0) return res; &#x2F;&#x2F;特判：全为负数\n        auto t &#x3D; build(nums, 0, nums.size() - 1);\n        return  t.s;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;分治 O(n*logn)\n&#x2F;&#x2F; &lt;--mid--&gt; lmax:区间前一半的最大后缀和  rmax:区间后一半的最大前缀和\nclass Solution &#123;\npublic:\n    int calc(int l, int r, vector&lt;int&gt;&amp; nums) &#123;\n        if (l &#x3D;&#x3D; r)\n            return nums[l];\n        int mid &#x3D; (l + r) &gt;&gt; 1;\n        int lmax &#x3D; nums[mid], lsum &#x3D; 0, rmax &#x3D; nums[mid + 1], rsum &#x3D; 0;\n\n        for (int i &#x3D; mid; i &gt;&#x3D; l; i--) &#123;\n            lsum +&#x3D; nums[i];\n            lmax &#x3D; max(lmax, lsum);\n        &#125;\n\n        for (int i &#x3D; mid + 1; i &lt;&#x3D; r; i++) &#123;\n            rsum +&#x3D; nums[i];\n            rmax &#x3D; max(rmax, rsum);\n        &#125;\n\n        return max(max(calc(l, mid, nums), calc(mid + 1, r, nums)), lmax + rmax);\n    &#125;\n\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        return calc(0, n - 1, nums);\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;133&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;拓展：acwing245 你能回答这些问题吗？  线段树 algo提高课\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;1608&#x2F;1&#x2F;\n\n\n\n\n54. 螺旋矩阵\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n\t\tvector&lt;int&gt; res;\n\t\tif(matrix.empty()) return res;\n\t\tint n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n\t\tvector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m, false));&#x2F;&#x2F;\n\t\t\n\t\tint dx[] &#x3D; &#123;0, 1, 0, -1&#125;, dy[] &#x3D; &#123;1, 0 ,-1, 0&#125;;\n\t\t&#x2F;&#x2F;先向右\n\t\tfor (int i &#x3D; 0, x &#x3D; 0, y &#x3D; 0, d &#x3D; 0; i &lt; n * m; i++)\n\t\t&#123;\n\t\t\tres.push_back(matrix[x][y]);\n\t\t\tst[x][y] &#x3D; true;\n\t\t\t&#x2F;&#x2F;合法next_pos\n\t\t\tint a &#x3D; x + dx[d], b &#x3D; y + dy[d];\n\t\t\tif(a &lt; 0 || a &gt;&#x3D; n || b &lt; 0 || b &gt;&#x3D; m || st[a][b])&#x2F;&#x2F;st可省： res[a][b]\n\t\t\t&#123;\n\t\t\t\td &#x3D; (d + 1) % 4;\n\t\t\t\ta &#x3D; x + dx[d], b &#x3D; y + dy[d];\n\t\t\t&#125;\n\t\t\tx &#x3D; a, y &#x3D; b;&#x2F;&#x2F;更新\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n\n55. 跳跃游戏:能否跳到（45 II:到最后min steps）&#x2F;*\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断【是否能够到达】最后一个下标。\n输入：nums &#x3D; [3,2,1,0,4]\n输出：false\n能跳到的区间必然是连续的一段：No、Yes矛盾\nj&#x3D;最远能到达&#x3D;i+n[i] 有i到达不了，就到不了最后\n*&#x2F;\nclass Solution &#123;\npublic:\n    bool canJump(vector&lt;int&gt;&amp; nums) &#123;\n        for(int i &#x3D; 0, j &#x3D; 0; i &lt; nums.size() ; i++) &#123;\n            if(j &lt; i) return false;\n            j &#x3D; max(j, i + nums[i]);\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n\n\n56.合并区间\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; a) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n\n        sort(a.begin(), a.end());\n        int l &#x3D; a[0][0], r &#x3D; a[0][1];\n        for(int i &#x3D; 1; i &lt; a.size(); i++) &#123;\n            if(r &lt; a[i][0]) &#123; &#x2F;&#x2F;没交集\n                res.push_back(&#123;l, r&#125;);\n                l &#x3D; a[i][0], r &#x3D; a[i][1];\n            &#125; else &#123; &#x2F;&#x2F;有交集\n                r &#x3D; max(r, a[i][1]); &#x2F;&#x2F;r &#x3D; a[i][1];错！没考虑前包含后！\n            &#125;\n        &#125;\n        res.push_back(&#123;l, r&#125;);\n        return res;\n    &#125;\n&#125;;\n\n\n\n57.插入区间 模拟\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int k &#x3D; 0;\n        while(k &lt; a.size() &amp;&amp; a[k][1] &lt; b[0]) res.push_back(a[k++]);\n        \n        if(k &lt; a.size()) &#123;\n            b[0] &#x3D; min(b[0], a[k][0]); &#x2F;&#x2F;定bl\n            while(k &lt; a.size() &amp;&amp; a[k][0] &lt;&#x3D; b[1]) b[1] &#x3D; max(b[1], a[k++][1]); &#x2F;&#x2F;没断，定br\n        &#125;\n        res.push_back(b);\n\n        while(k &lt; a.size()) res.push_back(a[k++]);\n        return res;\n    &#125;\n&#125;;\n\n\n\n58.最后一个单词的长度(stringstream、双指针)&#x2F;&#x2F;stringstream ssin(s);   while(ssin &gt;&gt; word)\nclass Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        stringstream ssin(s);\n        int res &#x3D; 0;\n        string word;\n        while(ssin &gt;&gt; word) res &#x3D; word.size();\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;双指针\nclass Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        for(int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n            if(s[i] &#x3D;&#x3D; &#39; &#39;) continue;\n            int j &#x3D; i - 1;\n            while(j &gt;&#x3D; 0 &amp;&amp; s[j] !&#x3D; &#39; &#39;) j--;\n            return  i - j;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n\n\n\n\n59. 螺旋矩阵 II 同54class Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n));\n\n\t\tint dx[] &#x3D; &#123;0, 1, 0, -1&#125;, dy[] &#x3D; &#123;1, 0 ,-1, 0&#125;;\n\t\tfor (int i &#x3D; 1, x &#x3D; 0, y &#x3D; 0, d &#x3D; 0; i &lt;&#x3D; n * n; i++) &#123;\n\t\t\tres[x][y] &#x3D; i;\n\t\t\tint a &#x3D; x + dx[d], b &#x3D; y + dy[d];\n\t\t\tif(a &lt; 0 || a &gt;&#x3D; n || b &lt; 0 || b &gt;&#x3D; n || res[a][b])\n\t\t\t&#123;\n\t\t\t\td &#x3D; (d + 1) % 4;\n\t\t\t\ta &#x3D; x + dx[d], b &#x3D; y + dy[d];\n\t\t\t&#125;\n\t\t\tx &#x3D; a, y &#x3D; b;&#x2F;&#x2F;更新\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n\n60. 第k个排列   if(fact &lt; k) k -&#x3D; fact;\n&#x2F;&#x2F;next_permutation k-1次 O(n!*k)\nclass Solution &#123;\npublic:\n    string getPermutation(int n, int k) &#123;\n        string res;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) res +&#x3D; to_string(i);\n        for(int i &#x3D; 0; i &lt; k - 1; i++)\n            next_permutation(res.begin(), res.end()); \n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;O(n*n)\nclass Solution &#123;\npublic:\n    string getPermutation(int n, int k) &#123;\n        string res;\n        vector&lt;bool&gt; st(10);\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            int fact &#x3D; 1;\n            for(int j &#x3D; 1; j &lt;&#x3D; n - i - 1; j++) fact *&#x3D; j; &#x2F;&#x2F;(n-1)!\n\n            for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n                if(!st[j]) &#123;\n                    if(fact &lt; k) k -&#x3D; fact; &#x2F;&#x2F;！！！\n                    else &#123;\n                        res +&#x3D; to_string(j);\n                        st[j] &#x3D; true;\n                        break; &#x2F;&#x2F;枚举填j，填完退出循环\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n61.旋转链表:rotateRight_k       k %&#x3D; n;  tail  p\nclass Solution &#123;\npublic:\n    ListNode* rotateRight(ListNode* head, int k) &#123;\n        if(!head) return head;\n        int n &#x3D; 0;\n        ListNode* tail;\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next) &#123;\n            tail &#x3D; p;\n            n++;\n        &#125;\n        k %&#x3D; n; &#x2F;&#x2F;k &gt;&#x3D; n \n        if(!k) return head;\n\n        auto p &#x3D; head;\n        for(int i &#x3D; 0; i &lt; n - k - 1; i++) p &#x3D; p-&gt;next;\n        tail-&gt;next &#x3D; head;\n        head &#x3D; p-&gt;next;\n        p-&gt;next &#x3D; nullptr;\n        return head;\n    &#125;\n&#125;;\n\n\n\n\n62.[-64]不同路径    m*n 左上-&gt;右下class Solution &#123;\npublic:\n    int uniquePaths(int m, int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m));\n\n        for(int i &#x3D; 0; i &lt; n; i++) \n            for(int j &#x3D; 0; j &lt; m; j++)\n                if(!i &amp;&amp; !j) f[i][j] &#x3D; 1;\n                else &#123;\n                    if(i) f[i][j] +&#x3D; f[i - 1][j]; &#x2F;&#x2F;\n                    if(j) f[i][j] +&#x3D; f[i][j - 1]; &#x2F;&#x2F;\n                &#125;\n        return f[n - 1][m - 1]; &#x2F;&#x2F;nm mn都行\n    &#125;\n&#125;;\n\n\n\n63.不同路径II  默认f[有障碍物1]&#x3D;0class Solution &#123;\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; o) &#123;\n        int m &#x3D; o.size();\n        if(!m) return 0;\n        int n &#x3D; o[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(n));\n\n        for(int i &#x3D; 0; i &lt; m; i++) \n            for(int j &#x3D; 0; j &lt; n; j++)\n                if(!o[i][j] &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F;无障碍\n                    if(!i &amp;&amp; !j) f[i][j] &#x3D; 1;\n                    else &#123;\n                        if(i) f[i][j] +&#x3D; f[i - 1][j]; &#x2F;&#x2F;\n                        if(j) f[i][j] +&#x3D; f[i][j - 1]; &#x2F;&#x2F;\n                    &#125;\n                &#125;\n                \n        return f[m - 1][n - 1];\n    &#125;\n&#125;;\n\n\n\n\n64.最小路径和  +weight 算min\nclass Solution &#123;\npublic:\n    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int n &#x3D; grid.size();\n        if(!n) return 0;\n        int m &#x3D; grid[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, INT_MAX));&#x2F;&#x2F;min init&#x3D;INT_MAX\n\n        for(int i &#x3D; 0; i &lt; n; i++) \n            for(int j &#x3D; 0; j &lt; m; j++)\n                if(!i &amp;&amp; !j) f[i][j] &#x3D; grid[i][j];\n                else &#123;\n                    if(i) f[i][j] &#x3D; min(f[i][j], f[i - 1][j] + grid[i][j]); &#x2F;&#x2F;\n                    if(j) f[i][j] &#x3D; min(f[i][j], f[i][j - 1] + grid[i][j]); &#x2F;&#x2F;\n                &#125;\n        return f[n - 1][m - 1];\n    &#125;\n&#125;;\n\n\n\n65.有效数字     bool:s2f 模拟 +- .e NeN e. e+-\n&#x2F;*\n(模拟，字符串处理) O(n)\n先去除行首和行尾空格；\n行首如果有一个正负号，直接忽略；\n如果字符串为空或只有一个&#39;.&#39;，则不是一个合法数；\n循环整个字符串，去掉以下几种情况：\n(1) &#39;.&#39;或&#39;e&#39;多于1个;\n(2) &#39;.&#39;在&#39;e&#39;后面出现；\n(3) &#39;e&#39;后面或前面为空，或者&#39;e&#39;前面紧跟着&#39;.&#39;；  &quot;.e&quot;\n(4) &#39;e&#39;后面紧跟着正负号，但正负号后面为空；    &quot;e+&quot;\n剩下的情况都合法；\n*&#x2F;\nclass Solution &#123;\npublic:\n    bool isNumber(string s) &#123;\n        int l &#x3D; 0, r &#x3D; s.size() - 1;\n        while (l &lt;&#x3D; r &amp;&amp; s[l] &#x3D;&#x3D; &#39; &#39;) l ++ ;\n        while (l &lt;&#x3D; r &amp;&amp; s[r] &#x3D;&#x3D; &#39; &#39;) r -- ;\n        if (l &gt; r) return false;\n        s &#x3D; s.substr(l, r - l + 1);\n        if (s[0] &#x3D;&#x3D; &#39;-&#39; || s[0] &#x3D;&#x3D; &#39;+&#39;) s &#x3D; s.substr(1);\n        if (s.empty() || s[0] &#x3D;&#x3D; &#39;.&#39; &amp;&amp; (s.size() &#x3D;&#x3D; 1 || s[1] &#x3D;&#x3D; &#39;e&#39; || s[1] &#x3D;&#x3D; &#39;E&#39;)) \n            return false; &#x2F;&#x2F;&quot;.e&quot;\n\n        int dot &#x3D; 0, e &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            if (s[i] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                if(dot &gt; 0 || e &gt; 0) return false; &#x2F;&#x2F;&quot;e.&quot;\n                dot ++ ;\n            &#125; else if (s[i] &#x3D;&#x3D; &#39;e&#39; || s[i] &#x3D;&#x3D; &#39;E&#39;) &#123;\n                e ++ ;\n                if (!i || i + 1 &#x3D;&#x3D; s.size() || e &gt; 1 ) return false;\n                if (s[i + 1] &#x3D;&#x3D; &#39;+&#39; || s[i + 1] &#x3D;&#x3D; &#39;-&#39;)\n                &#123;\n                    if (i + 2 &#x3D;&#x3D; s.size()) return false;&#x2F;&#x2F;&quot;e+-&quot;\n                    i ++ ;\n                &#125;\n            &#125;\n            else if (s[i] &lt; &#39;0&#39; || s[i] &gt; &#39;9&#39;) return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n\n\n66.(array)加一  reverse 进位tclass Solution &#123;\npublic:\n    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;\n        reverse(digits.begin(), digits.end());\n        int t &#x3D; 1;\n        for(auto&amp; x: digits) &#123;\n            t +&#x3D; x;\n            x &#x3D; t % 10;\n            t &#x2F;&#x3D; 10;\n        &#125;\n        if(t) digits.push_back(t);\n\n        reverse(digits.begin(), digits.end());\n        return digits;\n    &#125;\n&#125;;\n\n\n\n67.二进制求和 reverse t 同66class Solution &#123;\npublic:\n    string addBinary(string a, string b) &#123;\n        reverse(a.begin(), a.end());\n        reverse(b.begin(), b.end());\n        \n        string c;\n        for(int i &#x3D; 0, t &#x3D; 0; i &lt; a.size() || i &lt; b.size() || t; i++) &#123; &#x2F;&#x2F; || t\n            if(i &lt; a.size()) t +&#x3D; a[i] - &#39;0&#39;;\n            if(i &lt; b.size()) t +&#x3D; b[i] - &#39;0&#39;;\n            c +&#x3D; to_string(t % 2);\n            t &#x2F;&#x3D; 2;\n        &#125;\n\n        reverse(c.begin(), c.end());\n        return c;\n    &#125;\n&#125;;\n\n\n\n\n68.文本左右对齐if (j &#x3D;&#x3D; words.size() || j &#x3D;&#x3D; i + 1) { &#x2F;&#x2F;左对齐\nint cnt &#x3D; j - i - 1, r &#x3D; maxWidth - len + cnt; &#x2F;&#x2F;均分space\nwhile (k &lt; r % cnt) line +&#x3D; string(r &#x2F; cnt + 1, ‘ ‘) + words[i + k + 1], k++;while (k &lt; cnt) line +&#x3D; string(r &#x2F; cnt, ‘ ‘) + words[i + k + 1], k++;\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123;\n        vector&lt;string&gt; res;\n        for (int i &#x3D; 0; i &lt; words.size();)\n        &#123;\n            int j &#x3D; i + 1, len &#x3D; words[i].size();\n            while (j &lt; words.size() &amp;&amp; len + 1 + words[j].size() &lt;&#x3D; maxWidth)\n                len +&#x3D; 1 + words[j ++ ].size();\n\n            string line &#x3D; words[i];\n            if (j &#x3D;&#x3D; words.size() || j &#x3D;&#x3D; i + 1) &#123; &#x2F;&#x2F;左对齐\n                for (int k &#x3D; i + 1; k &lt; j; k ++ ) line +&#x3D; &#39; &#39; + words[k];\n                while (line.size() &lt; maxWidth) line +&#x3D; &#39; &#39;;\n            &#125; else &#123; &#x2F;&#x2F;左右对齐\n                int cnt &#x3D; j - i - 1, r &#x3D; maxWidth - len + cnt; &#x2F;&#x2F;均分space\n                int k &#x3D; 0;\n                while (k &lt; r % cnt) line +&#x3D; string(r &#x2F; cnt + 1, &#39; &#39;) + words[i + k + 1], k++;\n                while (k &lt; cnt) line +&#x3D; string(r &#x2F; cnt, &#39; &#39;) + words[i + k + 1], k++;\n            &#125;\n            res.push_back(line);\n            i &#x3D; j;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n69.x 的平方根 sqrt+floor  二分找 max_y^2 &lt;&#x3D; x&#x2F;*\n&lt;防止x&#x3D;&#x3D;INT_MAX  mid*mid越界&gt;\nl + 1ll + r\nif(mid &lt;&#x3D; x &#x2F; mid)\n*&#x2F;\nclass Solution &#123;\npublic:\n    int mySqrt(int x) &#123;\n        int l &#x3D; 0, r &#x3D; x;\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + 1ll + r &gt;&gt; 1;\n            if(mid &lt;&#x3D; x &#x2F; mid) l &#x3D; mid;\n            else r &#x3D; mid - 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n\n70.爬楼梯 每次你可以爬1或2个台阶 fib(0)&#x3D;1 fib(1)&#x3D;1 fib(2)&#x3D;2 滚动abc while(–n) { &#x2F;&#x2F; loop:n-1\nclass Solution &#123;\npublic:\n    int climbStairs(int n) &#123;\n        int a &#x3D; 1, b &#x3D; 1;\n        while(--n) &#123; &#x2F;&#x2F; loop:n-1\n            int c &#x3D; a + b;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n        return b;\n    &#125;\n&#125;;\n\n\n\n71 简化路径 模拟stk操作  back() string res.pop_back(); +&#x3D; clear&#x2F;*\n如果遇到 &quot;..&quot;，则返回上级目录；\n如果遇到 &quot;.&quot;或多余的斜杠，则不做任何处理：\n其它情况，表示进入某个子目录，我们在 res 后面补上新路径即可；\n*&#x2F;\nclass Solution &#123;\npublic:\n    string simplifyPath(string path) &#123;\n        if (path.back() !&#x3D; &#39;&#x2F;&#39;) path +&#x3D; &#39;&#x2F;&#39;; &#x2F;&#x2F; &quot;..http:&#x2F;&#x2F;cache.itzy8.top&#x2F;为一个单位&quot;\n        string res, name;\n        for (auto c : path) &#123;\n            if(c !&#x3D; &#39;&#x2F;&#39;) name +&#x3D; c;\n            else &#123;\n                if (name &#x3D;&#x3D; &quot;..&quot;) &#123;\n                    while (res.size() &amp;&amp; res.back() !&#x3D; &#39;&#x2F;&#39;) res.pop_back(); &#x2F;&#x2F; del name\n                    if (res.size()) res.pop_back(); &#x2F;&#x2F; del &#x2F;\n                &#125; else if (name !&#x3D; &quot;&quot; &amp;&amp; name !&#x3D; &quot;.&quot;) &#123;\n                    res +&#x3D; &#39;&#x2F;&#39; + name;\n                &#125;\n                name.clear();\n            &#125;\n        &#125;\n        if (res.empty()) res &#x3D; &quot;&#x2F;&quot;;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n72.编辑距离a-&gt;b_steps  DP 三类\nclass Solution &#123;\npublic:\n    int minDistance(string a, string b) &#123;\n        int n &#x3D; a.size(), m &#x3D; b.size();\n        a &#x3D; &#39; &#39; + a, b &#x3D; &#39; &#39; + b; &#x2F;&#x2F; 1...\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1));\n\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) f[i][0] &#x3D; i;\n        for(int i &#x3D; 1; i &lt;&#x3D; m; i++) f[0][i] &#x3D; i;\n        \n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            for(int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123;\n                f[i][j] &#x3D; min(f[i - 1][j], f[i][j - 1]) + 1;&#x2F;&#x2F;type 1 2\n                int t &#x3D; a[i] !&#x3D; b[j];\n                f[i][j] &#x3D; min(f[i][j], f[i - 1][j - 1] + t);&#x2F;&#x2F;type 3\n            &#125;\n        return f[n][m];\n    &#125;\n&#125;;\n\n\n\n73.矩阵置零：原地  0就刷\nclass Solution &#123;\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if (matrix.empty()) return;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        int col0 &#x3D; 1, row0 &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            if (!matrix[i][0]) col0 &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; m; i ++ )\n            if (!matrix[0][i]) row0 &#x3D; 0;\n        for (int i &#x3D; 1; i &lt; n; i ++ )\n            for (int j &#x3D; 1; j &lt; m; j ++ )\n                if (!matrix[i][j])\n                &#123;\n                    matrix[i][0] &#x3D; 0;\n                    matrix[0][j] &#x3D; 0;\n                &#125;\n        for (int i &#x3D; 1; i &lt; n; i ++ )\n            if (!matrix[i][0])\n                for (int j &#x3D; 1; j &lt; m; j ++ )\n                    matrix[i][j] &#x3D; 0;\n\n        for (int i &#x3D; 1; i &lt; m; i ++ )\n            if (!matrix[0][i])\n                for (int j &#x3D; 1; j &lt; n; j ++ )\n                    matrix[j][i] &#x3D; 0;\n\n        if (!col0)\n            for (int i &#x3D; 0; i &lt; n; i ++ )\n                matrix[i][0] &#x3D; 0;\n\n        if (!row0)\n            for (int i &#x3D; 0; i &lt; m; i ++ )\n                matrix[0][i] &#x3D; 0;\n    &#125;\n&#125;;\n\n\n\n74. 搜索二维矩阵 1D二分+坐标变换(mid&#x2F;m,mid%m)class Solution &#123;\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;\n        if(matrix.empty()) return false;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        int l &#x3D; 0, r &#x3D; n * m - 1;\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if(matrix[mid &#x2F; m][mid % m] &gt;&#x3D; target) r &#x3D; mid;\n            else l &#x3D; mid + 1;\n        &#125;\n        return matrix[r &#x2F; m][r % m] &#x3D;&#x3D; target;\n    &#125;\n&#125;;\n\n\n\n75.颜色分类 荷兰国旗问题 00111222 cnt ijk\n&#x2F;*\nArrays.sort(nums);\nsort(nums.begin(),nums.end());\ncnt012 重写\n&lt;仅使用常数空间的一趟扫描算法&gt;\n三指针做法：[i)[j)[k)\n*&#x2F;\nclass Solution &#123;\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) &#123;\n        for (int i &#x3D; 0, j &#x3D; 0, k &#x3D; nums.size() - 1; i &lt;&#x3D; k;) &#123;&#x2F;&#x2F;i&gt;k结束\n            if (nums[i] &#x3D;&#x3D; 0) swap(nums[i ++ ], nums[j ++ ]);\n            else if (nums[i] &#x3D;&#x3D; 2) swap(nums[i], nums[k -- ]);&#x2F;&#x2F;i不++ 不确定！！！\n            else i ++ ;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;leetcode&#x2F;content&#x2F;91&#x2F;\n&#x2F;&#x2F; 计数+覆盖！！！\nclass Solution &#123;\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) &#123;\n        int count[3] &#x3D; &#123;0&#125;;\n\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)\n            ++count[nums[i]];\n\n        for(int i &#x3D; 0, t &#x3D; 0;i &lt; 3; ++i)\n            for(int j &#x3D; 0; j &lt; count[i]; ++j)\n                nums[t++] &#x3D; i;\n\n    &#125;\n&#125;;\n\n\n\n\n\n\n\n？76.最小覆盖子串(双指针 2*hash表 同LC30~)\nclass Solution &#123;\npublic:\n    string minWindow(string s, string t) &#123;\n        unordered_map&lt;char, int&gt; hs, ht;\n        for(auto c: t) ht[c]++;\n\n        string res;\n        int cnt &#x3D; 0;\n        for(int i &#x3D; 0, j &#x3D; 0; i &lt; s.size(); i++) &#123;\n            hs[s[i]]++;\n            if(hs[s[i]] &lt;&#x3D; ht[s[i]]) cnt++;\n\n            while(hs[s[j]] &gt; ht[s[j]]) hs[s[j++]]--; &#x2F;&#x2F;\n            if(cnt &#x3D;&#x3D; t.size()) &#123;\n                if(res.empty() || i - j + 1 &lt; res.size()) &#x2F;&#x2F;最小子串\n                res &#x3D; s.substr(j, i - j + 1);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n77.组合  枚举n取k的所有方案 爆搜class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;\n        dfs(n, k, 1); &#x2F;&#x2F; n, residual_need, 枚举i允许的start\n        return ans;\n    &#125;\n\n    void dfs(int n, int k, int start) &#123;\n        if(!k) &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        for(int i &#x3D; start; i &lt;&#x3D; n; i++) &#123;\n            path.push_back(i);\n            dfs(n, k - 1,  i + 1); &#x2F;&#x2F;只准顺序遍历\n            path.pop_back();\n        &#125;\n    &#125;\n&#125;;\n\n\n\n78.子集  不重复nums的幂集 n位01bin表示case 1就选递归：枚举每个数选不选 [若不记录方案：$O(2^n)$]\n迭代：二进制划分 都是$O(2^n*n)$，两重loop\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int n &#x3D; nums.size();\n        for(int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i++) &#123; &#x2F;&#x2F;0~2^n-1\n            vector&lt;int&gt; path;\n            for(int j &#x3D; 0; j &lt; n; j++)\n                if(i &gt;&gt; j &amp; 1) &#x2F;&#x2F;i的第j位是1\n                    path.push_back(nums[j]); &#x2F;&#x2F;\n            res.push_back(path);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n79.单词搜索  爆搜起点+4方向 不回头’.’回溯不能走回头路，所以除了单词首字母外，仅有三种选择。所以总时间复杂度是 $O(n^2*3^k)$.\nclass Solution &#123;\npublic:\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;\n        for(int i &#x3D; 0; i &lt; board.size(); i++) \n            for(int j &#x3D; 0; j &lt; board[i].size(); j++) \n                if(dfs(board, word, 0, i, j)) return true;\n        return false;\n    &#125;\n    \n    int  dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int u, int x, int y) &#123;\n        if(board[x][y] !&#x3D; word[u]) return false;\n        if(u &#x3D;&#x3D; word.size() - 1) return true;\n\n        char t &#x3D; board[x][y];\n        board[x][y] &#x3D; &#39;.&#39;; &#x2F;&#x2F;visited\n        for(int i &#x3D; 0; i &lt; 4; i++) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if(a &lt; 0 || a &gt;&#x3D; board.size() || b &lt; 0 || b &gt;&#x3D; board[0].size() || board[a][b] &#x3D;&#x3D; &#39;.&#39;) continue; &#x2F;&#x2F;换方向\n            if(dfs(board, word, u + 1, a, b)) return true; &#x2F;&#x2F;递归\n        &#125;\n        board[x][y] &#x3D; t; &#x2F;&#x2F;回溯\n        return false;\n    &#125;\n&#125;;\n\n\n80. 删除排序数组中的重复项 II (LC16)  &#x3D;&#x3D;最多保留2个 (k &lt; 2 || nums[k - 1] !&#x3D; x || nums[k - 2] !&#x3D; x)class Solution &#123;\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        int k &#x3D; 0;\n        for(auto x: nums) &#123;\n            if(k &lt; 2 || nums[k - 1] !&#x3D; x || nums[k - 2] !&#x3D; x) &#x2F;&#x2F;\n                nums[k++] &#x3D; x;\n        &#125;\n        return k;\n    &#125;\n&#125;;\n\n\n\n81.搜索旋转排序数组 II(33)有重复    二分  while(R &gt;&#x3D; 0 &amp;&amp; nums[R] &#x3D;&#x3D; nums[0]) R–; &#x2F;&#x2F;保持两段性\nwhile(R &gt;&#x3D; 0 &amp;&amp; nums[R] &#x3D;&#x3D; nums[0]) R–;  &#x2F;&#x2F;保持两段性\n&#x2F;&#x2F;最坏O(n)\nclass Solution &#123;\npublic:\n    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n\t\tif(nums.empty()) return false;\n        int R &#x3D; nums.size() - 1;\n        while(R &gt;&#x3D; 0 &amp;&amp; nums[R] &#x3D;&#x3D; nums[0]) R--; &#x2F;&#x2F;保持两段性\n        if(R &lt; 0) return nums[0] &#x3D;&#x3D; target;\n\n\t\t&#x2F;&#x2F;二分两段\n\t\tint l &#x3D; 0, r &#x3D; R;\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r + 1 &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; nums[0]) l &#x3D; mid;\n\t\t\telse r &#x3D; mid - 1;\n\t\t&#125;\n\t\t&#x2F;&#x2F;l&#x3D;r&#x3D;mid &gt;&#x3D;n[0]:target定在哪一段\n\t\tif(target &gt;&#x3D; nums[0]) l &#x3D; 0;\n\t\telse l &#x3D; r + 1, r &#x3D; R;\n\t\t\n\t\t&#x2F;&#x2F; 二分 &gt;&#x3D;target的min\n\t\twhile(l &lt; r) &#123;\n\t\t\tint mid &#x3D; l + r &gt;&gt; 1;\n\t\t\tif(nums[mid] &gt;&#x3D; target) r &#x3D; mid; &#x2F;&#x2F;的min\n\t\t\telse l &#x3D; mid + 1;\n\t\t&#125;\n\n\t\treturn nums[r] &#x3D;&#x3D; target;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;最坏O(n)，线性扫描\nclass Solution &#123;\npublic:\n    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        for (auto &amp;v : nums)\n            if (v &#x3D;&#x3D; target)\n                return true;\n        return false;\n    &#125;\n&#125;;\n\n\n\n82.删除排序链表中的重复元素 II 83升序 删完 双指针\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n        auto p &#x3D; dummy;&#x2F;&#x2F;prev\n        while (p-&gt;next)&#x2F;&#x2F;first\n        &#123;\n            auto q &#x3D; p-&gt;next-&gt;next;\n            while (q &amp;&amp; q-&gt;val &#x3D;&#x3D; p-&gt;next-&gt;val) q &#x3D; q-&gt;next;\n            if (p-&gt;next-&gt;next &#x3D;&#x3D; q) p &#x3D; p-&gt;next;&#x2F;&#x2F;1\n            else p-&gt;next &#x3D; q;&#x2F;&#x2F;2\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n\n\n83.删除排序链表中的重复元素 82升序 留一个class Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if (!head) return head;\n        auto p &#x3D; head;\n        while (p-&gt;next)\n        &#123;\n            if (p-&gt;val &#x3D;&#x3D; p-&gt;next-&gt;val) p-&gt;next &#x3D; p-&gt;next-&gt;next;\n            else p &#x3D; p-&gt;next;\n        &#125;\n        return head;\n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if (!head) return head;\n        auto cur &#x3D; head;\n        for(auto p &#x3D; head-&gt;next; p; p &#x3D; p-&gt;next)\n            if ( p-&gt;val !&#x3D; cur-&gt;val) cur &#x3D; cur-&gt;next &#x3D; p;\n        \n        cur-&gt;next &#x3D; NULL;\n        return head;\n    &#125;\n&#125;;\n\n\n\n84.柱状图中最大的矩形 单调栈 heights[cur] * (i - st.top() - 1)\nwhile(比他高)pop\n&#x2F;&#x2F;84. 柱状图中最大的矩形\n&#x2F;&#x2F;单调栈：\n&#x2F;&#x2F;枚举上边界h：(L,R)第一个比它低的位置R-L-1就是宽度\nclass Solution &#123;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; h) &#123;\n        int n &#x3D; h.size();\n        vector&lt;int&gt; left(n), right(n);\n        stack&lt;int&gt; stk;\n\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            while(stk.size() &amp;&amp; h[stk.top()] &gt;&#x3D; h[i]) stk.pop();\n            if(stk.empty()) left[i] &#x3D; -1;\n            else left[i] &#x3D; stk.top();\n            stk.push(i);\n        &#125;\n    \n        stk &#x3D; stack&lt;int&gt;();\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;\n            while(stk.size() &amp;&amp; h[stk.top()] &gt;&#x3D; h[i]) stk.pop();\n            if(stk.empty()) right[i] &#x3D; n;\n            else right[i] &#x3D; stk.top();\n            stk.push(i);\n        &#125;\n\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, h[i] * (right[i] - left[i] - 1));\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;*\n(单调栈) O(n) 同李煜东~\n1.此题的本质是找到每个柱形条左边和右边最近的比自己低的矩形条，然后用宽度乘上当前柱形条的高度作为备选答案。\n2.解决此类问题的经典做法是单调栈，维护一个单调递增的栈，如果当前柱形条 i 的高度比栈顶要低，则栈顶元素 cur 出栈。\n【cur出栈后，cur 右边第一个比它低的柱形条就是 i，左边第一个比它低的柱形条是当前栈中的 top。】不断出栈直到栈为空或者柱形条 i 不再比 top 低。\n3.满足 2 之后，当前矩形条 i 进栈。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;\n        int n &#x3D; heights.size(), ans &#x3D; 0;\n        heights.push_back(-1);\n        &#x2F;&#x2F; 为了算法书写方便，在数组末尾添加高度 -1\n        &#x2F;&#x2F; 这会使得栈中所有数字在最后出栈。\n\n        stack&lt;int&gt; st;\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;\n                int cur &#x3D; st.top();\n                st.pop();\n\n                if (st.empty())\n                    ans &#x3D; max(ans, heights[cur] * i);&#x2F;&#x2F;0 ~ i-1\n                else\n                    ans &#x3D; max(ans, heights[cur] \n                            * (i - st.top() - 1)); &#x2F;&#x2F;!!!\n            &#125;\n            st.push(i);\n        &#125;\n\n        return ans;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;140&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n85.(全1的)最大矩形(的面积) 84-&gt;2D+DP\n&#x2F;&#x2F;85.(全1的 2D)最大矩形(的面积)\n&#x2F;&#x2F;拓展 最大正方形：DP\n&#x2F;&#x2F;左上(右下(全1：增量or前缀和 O1))&#x3D;n^4\n\n&#x2F;&#x2F;套上题单调栈O(n)、枚举下边界+排与排DP\n&#x2F;&#x2F;h:此处向上有多少个1\nclass Solution &#123;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; h) &#123;\n        int n &#x3D; h.size(), ans &#x3D; 0;\n        h.push_back(-1);\n        &#x2F;&#x2F; 为了算法书写方便，在数组末尾添加高度 -1\n        &#x2F;&#x2F; 这会使得栈中所有数字在最后出栈。\n\n        stack&lt;int&gt; st;\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            while (!st.empty() &amp;&amp; h[i] &lt; h[st.top()]) &#123;\n                int cur &#x3D; st.top();\n                st.pop();\n\n                if (st.empty())\n                    ans &#x3D; max(ans, h[cur] * i);&#x2F;&#x2F;0 ~ i-1\n                else\n                    ans &#x3D; max(ans, h[cur] * (i - st.top() - 1)); &#x2F;&#x2F;!!!\n            &#125;\n            st.push(i);\n        &#125;\n\n        return ans;\n    &#125;\n\n    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        if(matrix.empty() || matrix[0].empty()) return 0;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n\n        vector&lt;vector&lt;int&gt;&gt; h(n, vector&lt;int&gt;(m));\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; m; j++)\n                if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;\n                    if(i) h[i][j] &#x3D; 1 + h[i - 1][j]; &#x2F;&#x2F;DP\n                    else h[i][j] &#x3D; 1;\n                &#125;\n        \n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, largestRectangleArea(h[i]));&#x2F;&#x2F;2D最大矩形面积\n\n        return res; \n    &#125;\n&#125;;\n\n\n\n\n\n\n86. (L&lt;x、R&gt;&#x3D;x)分隔链表  qsort部分 稳定排lhlt\n&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* partition(ListNode* head, int x) &#123;\n        auto lh &#x3D;new ListNode(-1), rh &#x3D;new ListNode(-1);\n        auto lt &#x3D; lh, rt &#x3D; rh;\n\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next) &#123;\n            if(p-&gt;val &lt; x) lt &#x3D; lt-&gt;next &#x3D; p;\n            else rt &#x3D; rt-&gt;next &#x3D; p;\n        &#125;\n        lt-&gt;next &#x3D; rh-&gt;next;\n        rt-&gt;next &#x3D; NULL;\n\n        return lh-&gt;next;\n    &#125;\n&#125;;\n\n\n\n—87.扰乱字符串  区间dp!!!\n5. 最长回文子串\n516. 最长回文子序列\n312. 戳气球\n1246. 删除回文子数组（这个题微软面试问的很多）\n\n\n递归 O($5^n$)-&gt;记忆化搜索-&gt;dp O($n^4$)\n&#x2F;&#x2F;递归 TLE...\nclass Solution &#123;\npublic:\n    bool isScramble(string s1, string s2) &#123;\n        if (s1 &#x3D;&#x3D; s2) return true;\n        string bs1 &#x3D; s1, bs2 &#x3D; s2;\n        sort(bs1.begin(), bs1.end()), sort(bs2.begin(), bs2.end());\n        if (bs1 !&#x3D; bs2) return false;\n        int n &#x3D; s1.size();\n        for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i ++ ) &#123; &#x2F;&#x2F;str.substr(L,len)\n            if (isScramble(s1.substr(0, i), s2.substr(0, i))\n                &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true;\n            if (isScramble(s1.substr(0, i), s2.substr(n - i))\n                &amp;&amp; isScramble(s1.substr(i), s2.substr(0, n - i))) return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\nhttps:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;scramble-string&#x2F;solution&#x2F;miao-dong-de-qu-jian-xing-dpsi-lu-by-sha-yu-la-jia&#x2F;      Java\n\n&#x2F;&#x2F;C++\n#define vt std::vector\nclass Solution &#123;\npublic:\n    bool isScramble(string s, string t) &#123;\n        if (s.length() !&#x3D; t.length()) return false;\n\n        int n &#x3D; s.length();\n        vt&lt;vt&lt;vt&lt;int&gt;&gt;&gt; dp(n, vt&lt;vt&lt;int&gt;&gt;(n, vt&lt;int&gt;(n + 1, 0)));\n\n        for (int i &#x3D; 0; i &lt; n; ++ i)\n            for (int j &#x3D; 0; j &lt; n; ++ j)\n                dp[i][j][1] &#x3D; s[i] &#x3D;&#x3D; t[j];\n\n        for (int k &#x3D; 2; k &lt;&#x3D; n; ++ k)&#123;\n            for (int i &#x3D; 0; i + k &lt;&#x3D; n; ++ i)&#123;\n                for (int j &#x3D; 0; j + k &lt;&#x3D; n; ++ j)&#123;\n                    for (int ck &#x3D; 1; ck &lt; k; ++ ck)&#123;\n                        dp[i][j][k] |&#x3D; (\n                            (dp[i][j][ck] &amp;&amp; dp[i + ck][j + ck][k - ck]) ||\n                            (dp[i][j + k - ck][ck] &amp;&amp; dp[i + ck][j][k - ck])\n                        );\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n\n        return dp[0][0][n];\n    &#125;\n&#125;;\n\n作者：wen-mu-yang\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;scramble-string&#x2F;solution&#x2F;c-killhard-108-qu-jian-dphao-ti-by-wen-m-1mga&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n    \nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;15686&#x2F;   3法\n\n\n\n\n88.合并两个有序数组  mergesort  1+2–&gt;1 反遍历不覆盖 k&#x3D;n+m-1class Solution &#123;\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;\n        int k &#x3D; n + m - 1;\n        int i &#x3D; m - 1, j &#x3D; n - 1;\n        while(i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0)\n            if(nums1[i] &gt;&#x3D; nums2[j]) nums1[k--] &#x3D; nums1[i--];\n            else nums1[k--] &#x3D; nums2[j--];\n        while(j &gt;&#x3D; 0) nums1[k--] &#x3D; nums2[j--];\n    &#125;\n&#125;;\n\n\n\n89.格雷编码 轴对称 后补0&#x2F;1     前补:i^i&gt;&gt;1\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; grayCode(int n) &#123;\n        vector&lt;int&gt; res(1, 0);\n        while(n--) &#123;\n            for(int i &#x3D; res.size() - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F;后补01\n                res[i] *&#x3D; 2;\n                res.push_back(res[i] + 1);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;*\n格雷编码如何形成。同样以n &#x3D; 2解析。\n公式为 i ^ i&#x2F;2 (i &gt;&gt; 1)\n0 ^ 0 &#x3D; 00 ^ 00 &#x3D; 00 &#x3D; 0 计算(i&#x2F;2): 0&#x2F;2 &#x3D; 0\n1 ^ 0 &#x3D; 01 ^ 00 &#x3D; 01 &#x3D; 1 计算(i&#x2F;2): 1&#x2F;2 &#x3D; 0\n2 ^ 1 &#x3D; 10 ^ 01 &#x3D; 11 &#x3D; 3 计算(i&#x2F;2): 2&#x2F;2 &#x3D; 1\n3 ^ 1 &#x3D; 11 ^ 01 &#x3D; 10 &#x3D; 2 计算(i&#x2F;2): 3&#x2F;2 &#x3D; 1\n*&#x2F;\n&#x2F;&#x2F;前补01\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; grayCode(int n) &#123;\n        vector&lt;int&gt; ans;\n        int powN &#x3D; 1 &lt;&lt; n;\n        for(int i &#x3D; 0; i &lt; powN; ++i) &#x2F;&#x2F;\n            ans.push_back(i^i&gt;&gt;1); &#x2F;&#x2F;\n        return ans;\n    &#125;\n&#125;;\n\n作者：Xiaohu9527\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;gray-code&#x2F;solution&#x2F;c5xing-dai-ma-xiang-xi-jie-xi-dui-xin-sh-xrkw&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n—90&lt;-78.子集II 重复 多重背包  hash表&#x2F;(用)sort+dfs爆搜+放入0~k-u个nums[u]不能bin枚举，只能递归枚举\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; ans;\n\tvector&lt;int&gt; path;\n\n\tvector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;\n\t\tsort(nums.begin(), nums.end());\n\t\tdfs(0, nums);\n\t\treturn ans;\n\t&#125;\n&#x2F;&#x2F;先枚举每个不同的数，枚举到数x时，我们再求出x的个数k，然后我们枚举在集合中放入0,1,2,…k个x，共k+1种情况。\n\tvoid dfs(int u, vector&lt;int&gt;&amp;nums)\n\t&#123;\n\t\tif (u &#x3D;&#x3D; nums.size())\n\t\t&#123;\n\t\t\tans.push_back(path);\n\t\t\treturn;\n\t\t&#125;\n\t\tint k &#x3D; u;\n\t\twhile (k &lt; nums.size() &amp;&amp; nums[k] &#x3D;&#x3D; nums[u]) k ++ ;\n\t\t&#x2F;*\n\t\tfor (int i &#x3D; 0; i &lt;&#x3D; k - u; i ++ )\n\t\t&#123;\n\t\t\tdfs(k, nums);&#x2F;&#x2F;放0~k-u次\n\t\t\tpath.push_back(nums[u]);\n\t\t&#125;\n\t\t*&#x2F;\n\t\tdfs(k, nums);&#x2F;&#x2F;不放u\n\t\tfor (int i &#x3D; u; i &lt; k; i ++ )&#x2F;&#x2F;放u\n\t\t&#123;\n\t\t\tpath.push_back(nums[i]);\n\t\t\tdfs(k, nums);\n\t\t&#125;\n\t\tpath.erase(path.end() - (k - u), path.end());&#x2F;&#x2F;回溯\n\t&#125;\n&#125;;\n\n\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;16593&#x2F;\n&#x2F;&#x2F;Java\n&#x2F;*先对数组从小到大排序，每个数有选和不选两种情况，若选的话，\n假设上一个数与当前数一致，且上一个数没有选，则当前数一定不能选，否则会产生重复情况。\n时间复杂度 O(2^n) ?????\n*&#x2F;\nclass Solution &#123;\n    static List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    static List&lt;Integer&gt; path &#x3D; new ArrayList&lt;Integer&gt;();\n    static boolean[] st;\n    static void dfs(int[] nums,int u)\n    &#123;\n        if(u &#x3D;&#x3D; nums.length)\n        &#123;\n            ans.add(new ArrayList&lt;Integer&gt;(path));\n            return ;\n        &#125;\n\n        &#x2F;&#x2F;不放\n        dfs(nums,u + 1);\n\n        &#x2F;&#x2F;放\n        if(u &gt; 0 &amp;&amp; nums[u] &#x3D;&#x3D; nums[u - 1] &amp;&amp; !st[u - 1]) return ;\n        st[u] &#x3D; true;\n        path.add(nums[u]);\n        dfs(nums,u + 1);\n        path.remove(path.size() - 1);\n        st[u] &#x3D; false;\n    &#125;\n    \n    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;\n        ans.clear();\n        Arrays.sort(nums);\n        st &#x3D; new boolean[nums.length + 10];\n        dfs(nums,0);\n        return ans;\n    &#125;\n&#125;\n\n\n\n\n\n\n91.解码方法 DP输入：s &#x3D; &quot;12&quot;\n输出：2\n解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。\n\n\nclass Solution &#123;\npublic:\n    int numDecodings(string s) &#123;\n        int n &#x3D; s.size();\n        s &#x3D; &#39; &#39; + s;\n        vector&lt;int&gt; f(n + 1);\n        f[0] &#x3D; 1;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            if(s[i] &gt;&#x3D; &#39;1&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;) f[i] +&#x3D; f[i - 1];\n            if(i &gt; 1) &#123;\n                int t &#x3D; (s[i - 1] - &#39;0&#39;) * 10 + s[i] - &#39;0&#39;;\n                if(t &gt;&#x3D; 10 &amp;&amp; t &lt;&#x3D; 26) f[i] +&#x3D; f[i - 2];\n            &#125;\n        &#125;\n        return f[n];\n    &#125;\n&#125;;\n\n\n\n92.反转链表II（LR&#x3D;1~n 区间）a b&lt;-c&lt;-d【206.反转链表】\nclass Solution &#123;\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) &#123;\n        if(!head || !head-&gt;next) return head;\n\n        auto dummy &#x3D; new ListNode(-1); &#x2F;&#x2F;虚拟头结点，减少特判\n        dummy-&gt;next &#x3D; head;\n        auto a &#x3D; dummy;\n        for(int i &#x3D; 0; i &lt; left - 1; i++) a &#x3D; a-&gt;next; &#x2F;&#x2F;left-1步\n        auto b &#x3D; a-&gt;next, c &#x3D; b-&gt;next;\n        for(int i &#x3D; 0; i &lt; right - left; i++) &#123;\n            auto d &#x3D; c-&gt;next;\n            c-&gt;next &#x3D; b;\n            b &#x3D; c, c &#x3D; d;\n        &#125;\n        a-&gt;next-&gt;next &#x3D; c;\n        a-&gt;next &#x3D; b;\n        auto res &#x3D; dummy-&gt;next; &#x2F;&#x2F; 工程性：防止内存泄露\n        delete dummy;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n93.复原IP地址 dfs 0255 无前导0  ‘.’ u:bit k:03  过长&#x2F;&#x2F;93.复原IP地址 dfs\n&#x2F;*\n输入：s &#x3D; &quot;25525511135&quot;\n输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n0~255 无前导0\n\n(暴力搜索) O(C(3,n−1))\n直接暴力搜索出所有合法方案。\n我们直接枚举四个整数的位数，然后判断每个数的范围是否在0到255。\n\n时间复杂度分析：一共 n 个数字，n−1 个数字间隔，相当于从 n−1 个数字间隔中挑3个断点，所以计算量是 O(C(3,n−1))。\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;string&gt; restoreIpAddresses(string s) &#123;\n        dfs(s, 0 , 0, &quot;&quot;);\n        return ans;\n    &#125;\n\n    void dfs(string&amp; s, int u, int k, string path) &#123; &#x2F;&#x2F;u:bit k:0~3\n        if(u &#x3D;&#x3D; s.size()) &#123;\n            if(k &#x3D;&#x3D; 4) &#123;\n                path.pop_back(); &#x2F;&#x2F; 去&#39;.&#39;\n                ans.push_back(path);\n            &#125;\n            return;\n        &#125;\n        if(k &#x3D;&#x3D; 4) return;&#x2F;&#x2F;过长\n        for(int i &#x3D; u, t &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(i &gt; u &amp;&amp; s[u]&#x3D;&#x3D;&#39;0&#39;) break; &#x2F;&#x2F;有前导0\n            t &#x3D; t * 10 + s[i] - &#39;0&#39;;\n            if(t &lt;&#x3D; 255) dfs(s, i + 1, k + 1, path + to_string(t) + &#39;.&#39;);\n            else break;\n        &#125;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;写法2\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;int&gt; path; &#x2F;&#x2F;\n\n    vector&lt;string&gt; restoreIpAddresses(string s) &#123;\n        dfs(0, 0, s);\n        return ans;\n    &#125;\n\n    &#x2F;&#x2F; u表示枚举到的字符串下标，k表示当前截断的IP个数，s表示原字符串\n    void dfs(int u, int k, string &amp;s)\n    &#123;\n        if (u &#x3D;&#x3D; s.size())\n        &#123;\n            if (k &#x3D;&#x3D; 4)\n            &#123;\n                string ip &#x3D; to_string(path[0]);\n                for (int i &#x3D; 1; i &lt; 4; i ++ )\n                    ip +&#x3D; &#39;.&#39; + to_string(path[i]); &#x2F;&#x2F;\n                ans.push_back(ip);\n            &#125;\n            return;\n        &#125;\n        if (k &gt; 4) return;\n\n        unsigned t &#x3D; 0;\n        for (int i &#x3D; u; i &lt; s.size(); i ++ )\n        &#123;\n            t &#x3D; t * 10 + s[i] - &#39;0&#39;;\n            if (t &gt;&#x3D; 0 &amp;&amp; t &lt; 256)\n            &#123;\n                path.push_back(t);\n                dfs(i + 1, k + 1, s);\n                path.pop_back();\n            &#125;\n            if (!t) break; &#x2F;&#x2F;有前导0!!!\n        &#125;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;175&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n94.二叉树的中序遍历&#x2F;&#x2F;递归版\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; res;\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        dfs(root);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* root) &#123;\n        if (!root) return;\n        dfs(root-&gt;left);\n        res.push_back(root-&gt;val);\n        dfs(root-&gt;right);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;针对二叉树类型的非递归版\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;TreeNode*&gt; st;\n\n        auto p &#x3D; root;\n\n        while (p || !st.empty()) &#123;\n            while (p) &#123;\n                st.push(p);\n                p &#x3D; p-&gt;left;\n            &#125;\n            p &#x3D; st.top();\n            st.pop();\n            res.push_back(p-&gt;val);\n            p &#x3D; p-&gt;right;\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;*make_pair 标记法\n栈中每个元素存储两个值：TreeNode节点和一个整型的标记。\n标记 &#x3D; 0，表示还没遍历该节点的左子树；\n标记 &#x3D; 1，表示已经遍历完左子树，但还没遍历右子树；\n标记 &#x3D; 2，表示已经遍历完右子树；\n\n然后我们可以根据标记的值，来分别处理各种情况：\n标记 &#x3D; 0，则将该节点的标记改成1，然后将其左儿子压入栈中；\n标记 &#x3D; 1，则说明左子树已经遍历完，将根节点的值插入答案序列中，然后将该节点的标记改成2，并将右儿子压入栈中；\n标记 &#x3D; 2，则说明以该节点为根的子树已经遍历完，直接从栈中弹出即可；\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;pair&lt;TreeNode*, int&gt;&gt;sta;\n        sta.push(make_pair(root, 0));\n        while (!sta.empty())\n        &#123;\n            if (sta.top().first &#x3D;&#x3D; NULL)\n            &#123;\n                sta.pop();\n                continue;\n            &#125;\n            int t &#x3D; sta.top().second;\n            if (t &#x3D;&#x3D; 0)\n            &#123;\n                sta.top().second &#x3D; 1;\n                sta.push(make_pair(sta.top().first-&gt;left, 0));\n            &#125;\n            else if (t &#x3D;&#x3D; 1)\n            &#123;\n                res.push_back(sta.top().first-&gt;val);\n                sta.top().second &#x3D; 2;\n                sta.push(make_pair(sta.top().first-&gt;right, 0));\n            &#125;\n            else sta.pop();\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;176&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\nMorris遍历：S&#x3D;O(1)  \n95.不同的二叉搜索树 II dfs    new rootclass Solution &#123;\npublic:\n    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;\n        if (!n) return vector&lt;TreeNode*&gt;(); &#x2F;&#x2F;&#123;&#125;\n        return dfs(1, n);\n    &#125;\n\n    vector&lt;TreeNode*&gt; dfs(int l, int r) &#123;\n        vector&lt;TreeNode*&gt; res;\n        if (l &gt; r) return &#123;NULL&#125;;\n        \n        for (int i &#x3D; l; i &lt;&#x3D; r; i ++ ) &#123;\n            auto left &#x3D; dfs(l, i - 1), right &#x3D; dfs(i + 1, r);\n            for (auto lc : left)\n                for (auto rc : right) &#123;\n                    auto root &#x3D; new TreeNode(i); &#x2F;&#x2F;每次需要重新new root\n                    root-&gt;left &#x3D; lc, root-&gt;right &#x3D; rc;\n                    res.push_back(root);\n                &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n&#x2F;&#x2F;同样结构的子树123共用的同一段内存\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;177&#x2F;\n\n\n\n96.不同的二叉搜索树  求case数 DP [1,(j),i]&#x2F;&#x2F;f[n]&#x3D;∑k&#x3D;0~n−1 f[k]∗f[n−1−k]  DP：O(n*n)\n&#x2F;&#x2F;公式Catalan数&#x3D;C(n,2n)&#x2F;(n+1)\nclass Solution &#123;\npublic:\n    int numTrees(int n) &#123;\n        vector&lt;int&gt; f(n + 1);\n        f[0] &#x3D; 1;&#x2F;&#x2F;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#x2F;&#x2F;[1,i]\n        &#123;\n            f[i] &#x3D; 0; &#x2F;&#x2F;\n            for (int j &#x3D; 1; j &lt;&#x3D; i; j ++ ) &#x2F;&#x2F;[1,(j),i]\n                f[i] +&#x3D; f[j - 1] * f[i - j];&#x2F;&#x2F;DP 小-&gt;大 向上递推！\n        &#125;\n        return f[n];\n    &#125;\n&#125;;\n\n\n\n\n97. 交错字符串 DP ||class Solution &#123;\npublic:\n    bool isInterleave(string s1, string s2, string s3) &#123;\n        int n &#x3D; s1.size(), m &#x3D; s2.size();\n        if(s3.size() !&#x3D; n + m) return false;\n\n        vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1));\n        s1 &#x3D; &#39; &#39; + s1, s2 &#x3D; &#39; &#39; + s2, s3 &#x3D; &#39; &#39; + s3; &#x2F;&#x2F;空串\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++)\n            for(int j &#x3D; 0; j &lt;&#x3D; m; j++)\n                if(!i &amp;&amp; !j) f[i][j] &#x3D; true;&#x2F;&#x2F;\n                else &#123;\n                    if(i &amp;&amp; s1[i] &#x3D;&#x3D; s3[i + j]) f[i][j] &#x3D; f[i - 1][j];\n                    if(j &amp;&amp; s2[j] &#x3D;&#x3D; s3[i + j]) f[i][j] &#x3D; f[i][j] || f[i][j - 1]; &#x2F;&#x2F;!!!\n                &#125;\n        return f[n][m];\n    &#125;\n&#125;;\n\n\n\n98. 验证二叉搜索树{0F&#x2F;1T,m,M} &#x3D;&#x3D; LNR是否有序&#x2F;&#x2F;98. 验证二叉搜索树(min max) &#x3D;&#x3D; LNR是否有序\n&#x2F;*\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n*&#x2F;\n\n&#x2F;&#x2F;简洁版\nclass Solution &#123;\npublic:\n    bool isValidBST(TreeNode* root) &#123;\n        if (!root) return true;\n        return dfs(root)[0];\n    &#125;\n\n    vector&lt;int&gt; dfs(TreeNode* root) &#123;\n        vector&lt;int&gt; res(&#123;1, root-&gt;val, root-&gt;val&#125;);&#x2F;&#x2F;&#123;0F&#x2F;1T,m,M&#125;\n        if (root-&gt;left) &#123;\n            auto t &#x3D; dfs(root-&gt;left);\n            if (!t[0] || t[2] &gt;&#x3D; root-&gt;val) res[0] &#x3D; 0; &#x2F;&#x2F;0F\n            res[1] &#x3D; min(res[1], t[1]);\n            res[2] &#x3D; max(res[2], t[2]);\n        &#125;\n        if (root-&gt;right) &#123;\n            auto t &#x3D; dfs(root-&gt;right);\n            if (!t[0] || t[1] &lt;&#x3D; root-&gt;val) res[0] &#x3D; 0; &#x2F;&#x2F;0F\n            res[1] &#x3D; min(res[1], t[1]);\n            res[2] &#x3D; max(res[2], t[2]);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;原版\nclass Solution &#123;\npublic:\n    bool isValidBST(TreeNode* root) &#123;\n        if (!root) return true;\n        int maxv, minv;\n        return dfs(root, maxv, minv);\n    &#125;\n\n    bool dfs(TreeNode* root, int &amp;maxv, int &amp;minv)\n    &#123;\n        maxv &#x3D; minv &#x3D; root-&gt;val;\n        if (root-&gt;left)\n        &#123;\n            int nowMaxv, nowMinv;\n            if (!dfs(root-&gt;left, nowMaxv, nowMinv))\n                return false;\n            if (nowMaxv &gt;&#x3D; root-&gt;val)\n                return false;\n            maxv &#x3D; max(maxv, nowMaxv);\n            minv &#x3D; min(minv, nowMinv);\n        &#125;\n        if (root-&gt;right)\n        &#123;\n            int nowMaxv, nowMinv;\n            if (!dfs(root-&gt;right, nowMaxv, nowMinv))\n                return false;\n            if (nowMinv &lt;&#x3D; root-&gt;val)\n                return false;\n            maxv &#x3D; max(maxv, nowMaxv);\n            minv &#x3D; min(minv, nowMinv);\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;180&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n99. 恢复二叉搜索树 S&#x3D;O(1)：Morris遍历【线索二叉树】 遍历时记录这两个数！swap！两个节点被错误地交换：遍历时记录这两个数！swap！\n\n要求S&#x3D;O(1)：Morris遍历【线索二叉树】 &lt;–stk非递归\n\nhttps://www.acwing.com/solution/content/181/\n&#x2F;&#x2F;99. 恢复二叉搜索树\nclass Solution &#123;\npublic:\n\tvoid recoverTree(TreeNode* root) &#123;\n\t\tTreeNode *first &#x3D; NULL, *second, *prep &#x3D; NULL;\n\t\twhile (root) &#123;\n\t\t\tif (!root-&gt;left) &#123; &#x2F;&#x2F;无左子树\n\t\t\t\tif (prep &amp;&amp; prep-&gt;val &gt; root-&gt;val) &#123; &#x2F;&#x2F;遍历cur 记录\n\t\t\t\t\tif (!first) first &#x3D; prep, second &#x3D; root; &#x2F;&#x2F;第一个逆序对\n\t\t\t\t\telse second &#x3D; root;\n\t\t\t\t&#125;\n\t\t\t\tprep &#x3D; root;\n\t\t\t\troot &#x3D; root-&gt;right;\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tauto p &#x3D; root-&gt;left;\n\t\t\t\twhile (p-&gt;right &amp;&amp; p-&gt;right !&#x3D; root) p &#x3D; p-&gt;right; &#x2F;&#x2F;&amp;&amp;...!!!\n\t\t\t\tif (!p-&gt;right) &#123;\n\t\t\t\t\tp-&gt;right &#x3D; root; &#x2F;&#x2F;\n\t\t\t\t\troot &#x3D; root-&gt;left;\n\t\t\t\t&#125;\n\t\t\t\telse &#123;\n\t\t\t\t\tp-&gt;right &#x3D; NULL;\n\t\t\t\t\tif (prep &amp;&amp; prep-&gt;val &gt; root-&gt;val) &#123;\n\t\t\t\t\t\tif (!first) first &#x3D; prep, second &#x3D; root;\n\t\t\t\t\t\telse second &#x3D; root;\n\t\t\t\t\t&#125;\n\t\t\t\t\tprep &#x3D; root;\n\t\t\t\t\troot &#x3D; root-&gt;right;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tswap(first-&gt;val, second-&gt;val);\n\t&#125;\n&#125;;\n\n\n\n\n\n100.相同的树 !p &amp;&amp; !q、!p || !q ||!&#x3D; 递归class Solution &#123;\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) &#123;\n        if(!p &amp;&amp; !q) return true;\n        if(!p || !q || p-&gt;val !&#x3D; q-&gt;val) return false;\n        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);\n    &#125;\n&#125;;\n\n\n\n101. 对称二叉树 递归class Solution &#123;\npublic:\n\tbool isSymmetric(TreeNode* root) &#123;\n\t\treturn !root || dfs(root-&gt;left, root-&gt;right);\n\t&#125;\n\n\tbool dfs(TreeNode* p, TreeNode* q) &#123;\n\t\tif (!p || !q) return !p &amp;&amp; !q;&#x2F;&#x2F; 【学：if(||) return &amp;&amp; 】\n\t\treturn p-&gt;val &#x3D;&#x3D; q-&gt;val &amp;&amp; dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);\n\t&#125;\n&#x2F;*\tbool dfs(TreeNode* p, TreeNode* q) &#123;\n\t\tif (!p &amp;&amp; !q) return true;\n\t\tif (!p || !q || p-&gt;val !&#x3D; q-&gt;val) return false;\n\t\treturn dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);\n\t&#125;*&#x2F;\n&#125;;\n\n&#x2F;&#x2F;法二：迭代 stack p.LNR&#x3D;&#x3D;q.RNL \nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;182&#x2F;\nclass Solution &#123;\npublic:\n    bool isSymmetric(TreeNode* root) &#123;\n        if (!root) return true;\n        stack&lt;TreeNode*&gt; left, right;\n        TreeNode *lc &#x3D; root-&gt;left;\n        TreeNode *rc &#x3D; root-&gt;right;\n        while(lc || rc || left.size())\n        &#123;\n            while (lc &amp;&amp; rc)\n            &#123;\n                left.push(lc), right.push(rc);\n                lc &#x3D; lc-&gt;left, rc &#x3D; rc-&gt;right;\n            &#125;\n            if (lc || rc) return false;\n            lc &#x3D; left.top(), rc &#x3D; right.top(); &#x2F;&#x2F; -&gt;到top\n            left.pop(), right.pop();\n            if (lc-&gt;val !&#x3D; rc-&gt;val) return false;\n            lc &#x3D; lc-&gt;right, rc &#x3D; rc-&gt;left; &#x2F;&#x2F;NULL-&gt;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n\n\n\n\n\n102.二叉树的层序遍历 bfs q.push  q.front()&#x2F;&#x2F;102. 二叉树的层序输出bfs q.front()       to:103 107\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tqueue&lt;TreeNode*&gt; q;\n\t\tif(root) q.push(root);\n\n\t\twhile(q.size()) &#123;\n\t\t\tvector&lt;int&gt; level;\n\t\t\tint len &#x3D; q.size();\n\n\t\t\twhile(len--) &#123; &#x2F;&#x2F; len!&#x3D;\n\t\t\t\tauto t &#x3D; q.front();\n\t\t\t\tq.pop();\n\t\t\t\tlevel.push_back(t-&gt;val);\n\t\t\t\tif(t-&gt;left) q.push(t-&gt;left);\n\t\t\t\tif(t-&gt;right) q.push(t-&gt;right);\n\t\t\t&#125;\n\n\t\t\tres.push_back(level);\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n\n103&lt;-102.二叉树的锯齿形S层次遍历 cnt&#x2F;&#x2F;103. 二叉树的锯齿形S层次遍历  from:102\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tqueue&lt;TreeNode*&gt; q;\n\t\tif(root) q.push(root); &#x2F;&#x2F;\n\n\t\tint cnt &#x3D; 0;&#x2F;&#x2F;\n\t\twhile(q.size()) &#123;\n\t\t\tvector&lt;int&gt; level;\n\t\t\tint len &#x3D; q.size();\n\n\t\t\twhile(len--) &#123; &#x2F;&#x2F; 先限定层len!!!\n\t\t\t\tauto t &#x3D; q.front();\n\t\t\t\tq.pop();\n\t\t\t\tlevel.push_back(t-&gt;val);\n\t\t\t\tif(t-&gt;left) q.push(t-&gt;left);\n\t\t\t\tif(t-&gt;right) q.push(t-&gt;right);\n\t\t\t&#125;\n\t\t\tif( ++ cnt % 2 &#x3D;&#x3D; 0) reverse(level.begin(),level.end());&#x2F;&#x2F;\n\t\t\tres.push_back(level);\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n\n\n\n\n\n104.二叉树的最大深度 M&#x3D;M(L,R)+1&#x2F;&#x2F;104. 二叉树的最大深度     递归  dfs:stack bfs:queue\nclass Solution &#123;\npublic:\n\tint maxDepth(TreeNode* root) &#123;\n\t\tif(!root) return 0;\n\t\treturn max(maxDepth(root-&gt;left),maxDepth(root-&gt;right)) + 1;\n\t&#125;\n&#125;;\n\n\n\n105.从前序与中序遍历序列构造二叉树    剑指18\nclass Solution &#123;\npublic:\n\tunordered_map&lt;int, int&gt; pos;&#x2F;&#x2F;&#123;val,inorder_pos&#125;   idx_hash表\n\n\tTreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;\n\t\tfor (int i &#x3D; 0; i &lt; inorder.size(); i++) pos[inorder[i]] &#x3D; i;\n\t\treturn dfs(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);\n\t&#125;\n\n\tTreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir) &#123;\n\t\tif(pl &gt; pr) return NULL;\n\t\t\n\t\tauto root &#x3D; new TreeNode(preorder[pl]);\n\t\tint k &#x3D; pos[root-&gt;val];\n\t\troot-&gt;left &#x3D; dfs(preorder, inorder, pl + 1, pl + k - il, il, k - 1);\n\t\troot-&gt;right &#x3D; dfs(preorder, inorder, pl + k - il + 1, pr, k + 1, ir);\n&#x2F;*      \n \t\tint k &#x3D; pos[preorder[pl]] - il;\n\t\troot-&gt;left &#x3D; dfs(preorder, inorder, pl + 1, pl + k, il, il + k - 1);\n\t\troot-&gt;right &#x3D; dfs(preorder, inorder, pl + k + 1, pr, il + k + 1, ir);\n*&#x2F;\n\t\treturn root;\n\t&#125;\n&#125;;\n\n\n\n106.从中序与后序遍历序列构造二叉树class Solution &#123;\npublic:\n\tunordered_map&lt;int, int&gt; pos;&#x2F;&#x2F;inorder_pos   idx_hash表\n\n\tTreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;\n\t\tfor (int i &#x3D; 0; i &lt; inorder.size(); i++) pos[inorder[i]] &#x3D; i;\n\t\treturn dfs(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);\n\t&#125;\n\n\tTreeNode* dfs(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int il, int ir, int pl, int pr) &#123;\n\t\tif(il &gt; ir) return NULL;\n\t\tauto root &#x3D; new TreeNode(postorder[pr]);\n\t\tint k &#x3D; pos[root-&gt;val];\n\t\t\n\t\troot-&gt;left &#x3D; dfs(inorder, postorder, il, k - 1, pl, pl + k - 1 - il);\n\t\troot-&gt;right &#x3D; dfs(inorder, postorder, k + 1, ir, pl + k - il, pr - 1);\n\n\t\treturn root;\n\t&#125;\n&#125;;\n\n\n\n\n\n\n107&lt;-102.二叉树的层次遍历 II 自底向上 reverse(res)class Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;\n\t\tvector&lt;vector&lt;int&gt;&gt; res;\n\t\tqueue&lt;TreeNode*&gt; q;\n\t\tif(root) q.push(root);\n\n\t\twhile(q.size()) &#123;\n\t\t\tvector&lt;int&gt; level;\n\t\t\tint len &#x3D; q.size();\n\n\t\t\twhile(len--) &#123; &#x2F;&#x2F; 先限定层len!!!\n\t\t\t\tauto t &#x3D; q.front();\n\t\t\t\tq.pop();\n\t\t\t\tlevel.push_back(t-&gt;val);\n\t\t\t\tif(t-&gt;left) q.push(t-&gt;left);\n\t\t\t\tif(t-&gt;right) q.push(t-&gt;right);\n\t\t\t&#125;\n\t\t\tres.push_back(level);\n\t\t&#125;\n\t\treverse(res.begin(), res.end()); &#x2F;&#x2F;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n108.将有序数组(中序)转换为(高度平衡)二叉搜索树SeqTree AVL\n\n&#x2F;*\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;196&#x2F;\n每次以中点为根，以左半部分为左子树，右半部分为右子树。先分别递归建立左子树和右子树，然后令根节点的指针分别指向两棵子树。\n该算法得到的BST满足：任意节点的左右子树的所有高度的差不大于1（注意不是最大高度）。\nproof:\n在每一次递归过程中，左半部分的长度最多比右半部分的长度少1，那会不会有这种情况：\n左半部分的高度分别有 m−1,m，右半部分的高度有 m,m+1，则当前节点的高度就是 m,m+1,m+2\n（要加上当前根节点这一层，所以都要加1），则此时树的高度差为2，不平衡。\n实际上这种情况是不可能的：反证，对于左子树，由于存在高度 m−1，所以左半部分最多有 2m−2 个数；\n对于右子树，由于存在高度 m 和 m+1，所以右半部分最少有 2m 个数，此时左右两部分的数的个数最少差2，矛盾。\n*&#x2F;\nclass Solution &#123;\npublic:\n\tTreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;\n\t\treturn build(nums, 0, nums.size() - 1);\n\t&#125;\n\n\tTreeNode *build(vector&lt;int&gt;&amp;nums, int l, int r)\n\t&#123;\n\t\tif (l &gt; r) return 0;\n\t\tint mid &#x3D; (l + r) &gt;&gt; 1; &#x2F;&#x2F;\n\t\tauto root &#x3D; new TreeNode(nums[mid]); &#x2F;&#x2F;\n\t\troot-&gt;left &#x3D; build(nums, l, mid - 1);\n\t\troot-&gt;right &#x3D; build(nums, mid + 1, r);\n\t\treturn root;\n\t&#125;\n&#125;;\n\n\n\n109.有序链表转换(高度平衡)二叉搜索树 取中点O(n)  cur&#x3D;中点-1   cur-&gt;next &#x3D; NULL;O(nlogn)\nceil(b&#x2F;a) &#x3D;&#x3D; floor((b+a-1)&#x2F;a)\n\nclass Solution &#123;\npublic:\n\tTreeNode* sortedListToBST(ListNode* head) &#123;\n\t\tif(!head) return NULL;\n\t\tint n &#x3D; 0;\n\t\tfor (auto p &#x3D; head; p; p &#x3D; p-&gt;next) n++;\n\t\tif(n &#x3D;&#x3D; 1) return new TreeNode(head-&gt;val);\n\n\t\tauto cur &#x3D; head;\n\t\tfor (int i &#x3D; 0; i &lt; n &#x2F; 2 - 1; i++) cur &#x3D; cur-&gt;next;&#x2F;&#x2F;cur&#x3D;中点-1\n\t\tauto root &#x3D; new TreeNode(cur-&gt;next-&gt;val);&#x2F;&#x2F;root&#x3D;中点\n\t\troot-&gt;right &#x3D; sortedListToBST(cur-&gt;next-&gt;next);\n        \n\t\tcur-&gt;next &#x3D; NULL;&#x2F;&#x2F;!!!\n\t\troot-&gt;left &#x3D; sortedListToBST(head);\n\t\t\n        return root;\n\t&#125;\n&#125;;\n\n\n\n\n\n110.平衡二叉树judge  abs&gt;1:F   递归h&#x3D;max(lh, rh) + 1&#x2F;&#x2F;110. 平衡二叉树    递归h&#x3D;max(lh, rh) + 1   abs(lh-rh)&lt;&#x3D;1\n#include &lt;math.h&gt;\nclass Solution &#123;\npublic:\n\tbool ans;\n\n\tbool isBalanced(TreeNode* root) &#123;\n\t\tans &#x3D; true;\n\t\tdfs(root);\n\t\treturn ans;\n\t&#125;\n\n\tint dfs(TreeNode* root) &#123;\n\t\tif(!root) return 0;\n\t\tint lh &#x3D; dfs(root-&gt;left), rh &#x3D; dfs(root-&gt;right);\n\t\tif(abs(lh - rh) &gt; 1) ans &#x3D; false;&#x2F;&#x2F;\n\t\treturn max(lh, rh) + 1;&#x2F;&#x2F;\n\t&#125;\n\n\t&#x2F;*\n\tbool isBalanced(TreeNode* root) &#123;\n\t\treturn dfs(root)[0];\n\t&#125;\n\n\tvector&lt;int&gt; dfs(TreeNode* root) &#123;\n\t\tif(!root) return &#123;1, 0&#125;; &#x2F;&#x2F; &#123;subTreeIsBalanced&#x3D;T&#x2F;F,height&#125;\n\t\tauto l &#x3D; dfs(root-&gt;left), r &#x3D; dfs(root-&gt;right);\n\t\treturn &#123;l[0] &amp;&amp; r[0] &amp;&amp; abs(l[1] - r[1]) &lt;&#x3D; 1, max(l[1], r[1]) + 1&#125;;\n\t&#125;\n\t*&#x2F;\n&#125;;\n\n&#x2F;&#x2F;Acwing253 普通平衡树\n\n\n\n\n111.二叉树的最小深度class Solution &#123;\npublic:\n    int minDepth(TreeNode* root) &#123;\n        if (!root) return 0;\n        int res &#x3D; INT_MAX;\n        if (root-&gt;left) res &#x3D; min(res, minDepth(root-&gt;left) + 1);\n        if (root-&gt;right) res &#x3D; min(res, minDepth(root-&gt;right) + 1);\n        if (res &#x3D;&#x3D; INT_MAX) res &#x3D; 1;\n        return res;\n    &#125;\n&#125;;\n\n112.路径总和 tree 存在否 自上而下！class Solution &#123;\npublic:\n    bool hasPathSum(TreeNode* root, int sum) &#123;\n        if(!root) return false;\n        sum -&#x3D; root-&gt;val;\n        if(!root-&gt;left &amp;&amp; !root-&gt;right) return !sum;\n        return root-&gt;left &amp;&amp; hasPathSum(root-&gt;left, sum) || root-&gt;right &amp;&amp; hasPathSum(root-&gt;right, sum);\n    &#125;\n&#125;;\n\n\n\n\n113.路径总和II 记录所有路径class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;\n        if(root) dfs(root, sum);\n        return ans;\n    &#125;\n    void dfs(TreeNode* root, int sum) &#123;\n        path.push_back(root-&gt;val);\n        sum -&#x3D; root-&gt;val;\n        if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;\n            if(!sum) ans.push_back(path);\n        &#125; else &#123;\n            if(root-&gt;left) dfs(root-&gt;left, sum);\n            if(root-&gt;right) dfs(root-&gt;right, sum);\n        &#125;\n        path.pop_back();&#x2F;&#x2F;回溯\n    &#125;\n&#125;;\n\n\n\n\n\n114.二叉树展开为链表 斜向右NLR 左子树右链插入右节点处\nclass Solution &#123;\npublic:\n    void flatten(TreeNode* root) &#123;\n        TreeNode *now &#x3D; root;\n        while (now) &#123;\n            if (now-&gt;left) &#123;\n                TreeNode *p &#x3D; now-&gt;left;\n                while (p-&gt;right) p &#x3D; p-&gt;right;\n                p-&gt;right &#x3D; now-&gt;right;\n                now-&gt;right &#x3D; now-&gt;left; &#x2F;&#x2F;\n                now-&gt;left &#x3D; NULL;\n            &#125;\n            now &#x3D; now-&gt;right;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n115.不同的子序列 S有多少个T DP ≠不能匹 &#x3D;可以匹,也可以不匹DP：O(nm)可以换一种考虑问题的方式：用 S 中的字符，按顺序匹配 T 中的字符，问【S有多少种方式可以匹配完 T 中的所有字符。】\n可以用动态规划来做：f[i][j]表示用 S 的前 i 个字符，能匹配完 T 的前 j 个字符的方案数。 初始化：因为 S 可以从任意一个字符开始匹配，所以 $f[i][0]&#x3D;1,∀i∈[0,len(S)]$。状态转移：\n如果 S[i−1]≠T[j−1]，则 S[i−1] 不能匹配 T[j−1]，所以 $f[i][j]&#x3D;f[i−1][j]$如果 S[i−1]&#x3D;T[j−1]，则 S[i−1] 既可以匹配 T[j−1]，也可以不匹配 T[j−1]，所以 $f[i][j]&#x3D;f[i−1][j]+f[i−1][j−1]$；链接：https://www.acwing.com/solution/content/203/\nclass Solution &#123;\npublic:\n    int numDistinct(string s, string t) &#123;\n        int n &#x3D; s.size(), m &#x3D; t.size();\n        s &#x3D; &#39; &#39; + s, t &#x3D; &#39; &#39; + t;&#x2F;&#x2F;空串\n        &#x2F;&#x2F;防止中间值爆int越界：ULL\n        vector&lt;vector&lt;unsigned long long&gt;&gt; f(n + 1, vector&lt;unsigned long long&gt;(m + 1));\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i ++ ) f[i][0] &#x3D; 1;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ ) &#123;\n                f[i][j] &#x3D; f[i - 1][j];\n                if (s[i] &#x3D;&#x3D; t[j]) f[i][j] +&#x3D; f[i - 1][j - 1];\n            &#125;\n        return f[n][m];\n    &#125;\n&#125;;\n\n\n\n\n116.填充每个节点的下一个右侧节点指针 完美二叉树(满)\nclass Solution &#123;\npublic:\n    Node* connect(Node* root) &#123;\n        if (!root) return root;\n        auto last &#x3D; root;\n        while (last-&gt;left) &#123;\n            for (auto p &#x3D; last; p; p &#x3D; p-&gt;next) &#123;\n                p-&gt;left-&gt;next &#x3D; p-&gt;right;\n                if (p-&gt;next) p-&gt;right-&gt;next &#x3D; p-&gt;next-&gt;left;\n                else p-&gt;right-&gt;next &#x3D; NULL;&#x2F;&#x2F;可省\n            &#125;\n            last &#x3D; last-&gt;left; &#x2F;&#x2F;每层first\n        &#125;\n        return root;\n    &#125;\n&#125;;\n\n\n\n117.填充每个节点的下一个右侧节点指针II 非完美二叉树 虚拟头结点h&#x3D;t -&gt;next&#x3D;每层first:cur&#x2F;&#x2F;填充它的每个 next 指针，以指向其下一个右侧节点\nclass Solution &#123;\npublic:\n    Node* connect(Node* root) &#123;\n        if(!root) return root;\n        auto cur &#x3D; root;\n        while(cur) &#123;\n            auto head &#x3D; new Node(-1); &#x2F;&#x2F;虚拟头结点h&#x3D;t -&gt;next&#x3D;每层first\n            auto tail &#x3D; head;\n            for(auto p &#x3D; cur; p; p &#x3D; p-&gt;next) &#123; &#x2F;&#x2F;上层p\n                if(p-&gt;left) tail &#x3D; tail-&gt;next &#x3D; p-&gt;left;\n                if(p-&gt;right) tail &#x3D; tail-&gt;next &#x3D; p-&gt;right;\n            &#125;\n            cur &#x3D; head-&gt;next;&#x2F;&#x2F;每层first\n        &#125;\n        return root;\n    &#125;\n&#125;;\n\n\n\n\n118.杨辉三角 1~k输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f;\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            vector&lt;int&gt; line(i + 1);&#x2F;&#x2F;0行有1个\n            line[0] &#x3D; line[i] &#x3D; 1;&#x2F;&#x2F;\n            for(int j &#x3D; 1; j &lt; i; j++) \n                line[j] &#x3D; f[i - 1][j - 1] + f[i - 1][j];\n            f.push_back(line);\n        &#125;\n        return f;\n    &#125;\n&#125;;\n\n\n\n119.杨辉三角II  k  S&#x3D;O(k) 滚动数组 【2】 &amp;1 O(k) 空间复杂度:滚动数组\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; getRow(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1));\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            f[i][0] &#x3D; f[i][i] &#x3D; 1;&#x2F;&#x2F;\n            for(int j &#x3D; 1; j &lt; i; j++) \n                f[i][j] &#x3D; f[i - 1][j - 1] + f[i - 1][j];\n        &#125;\n        return f[n];\n    &#125;\n&#125;;\n\n&#x2F;*\nn%2 &#x3D;&#x3D; n&amp;1 \n +-  &gt;  &amp;\n第一维[2] &amp;1 即可\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; getRow(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(n + 1));\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;\n            f[i &amp; 1][0] &#x3D; f[i &amp; 1][i] &#x3D; 1;&#x2F;&#x2F;\n            for(int j &#x3D; 1; j &lt; i; j++) \n                f[i &amp; 1][j] &#x3D; f[i - 1 &amp; 1][j - 1] + f[i - 1 &amp; 1][j];\n        &#125;\n        return f[n &amp; 1];\n    &#125;\n&#125;;\n\n\n\n\n120.三角形最小路径和 向上DP&#x2F;*\nT&#x3D;O(2^(n-1)) DP优化：时间O(n*n) 空间O(1)\n向下要考虑边界特判,故向上递推\nf(i,j)表示从下往上走到位置(i,j)时的最小路径和\nf(i,j)&#x3D;(i,j)+min(f(i+1,j),f(i+1,j+1))\n*&#x2F;\nclass Solution &#123;\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; f) &#123;\n        for(int i &#x3D; f.size() - 2; i &gt;&#x3D; 0; i--)\n            for(int j &#x3D; 0; j &lt;&#x3D; i; j++)\n                f[i][j] +&#x3D; min(f[i + 1][j], f[i + 1][j + 1]);\n        return f[0][0];\n    &#125;\n&#125;;\n\n\n\n\n121.买卖股票的最佳时机  max(prices[i] - minp)\nclass Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0, minp &#x3D; INT_MAX; i &lt; prices.size(); i++) &#123;\n            res &#x3D; max(res, prices[i] - minp);\n            minp &#x3D; min(minp, prices[i]);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n122.买卖股票的最佳时机II 多次买卖不重叠 交易拆为单天！ max利&#x3D;+利日之和   +&#x3D;max(0, prices[i + 1] - prices[i])class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i + 1 &lt; prices.size(); i++) &#x2F;&#x2F;\n            res +&#x3D; max(0, prices[i + 1] - prices[i]);\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n—123.买卖股票的最佳时机 III 最多2次 前后缀分解\n&#x2F;&#x2F;123.买卖股票的最佳时机 III 最多2次\n&#x2F;*\nDP：最多k次 更通用\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;219&#x2F;\n遍历一遍数组，求[0,i−1]区间的最大利润f(i)，具体做法是找当前最低价格low，判断是要以low买入当天卖出，还是不动\n从后往前遍历，求[i,n−1]区间的最大利润g(i)，具体做法是找当前最高价格high，判断是要当天买入以high卖出，还是不动\n遍历，求最大利润max(f(i)+g(i))\n\n股票6题汇总:\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;yimingsilence&#x2F;article&#x2F;details&#x2F;79212621\n\n“最多2次”前后缀分解:预处理前后缀 枚举终点\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;211&#x2F;\n*&#x2F;\nclass Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n    \tint n &#x3D; prices.size();\n    \tvector&lt;int&gt; f(n + 2);&#x2F;&#x2F;\n    \tfor(int i &#x3D; 1, minp &#x3D; INT_MAX; i &lt;&#x3D; n; i++) &#123;\n            f[i] &#x3D; max(f[i - 1], prices[i - 1] - minp);&#x2F;&#x2F;i_day卖,不卖\n            minp &#x3D; min(minp, prices[i - 1]);\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; n, maxp &#x3D; 0; i; i--) &#123;\n        \tres &#x3D; max(res, maxp - prices[i - 1] + f[i - 1]);\n        \tmaxp &#x3D; max(maxp, prices[i - 1]);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n124.二叉树中的最大路径和[LC543] 树形DP法 枚举LCA为割点 ans&#x3D;max(LNR);点val return root+max(l,r);class Solution &#123;\npublic:\n    int ans;\n    int maxPathSum(TreeNode* root) &#123;\n        ans &#x3D; INT_MIN;\n        dfs(root);\n        return ans;\n    &#125;\n\n    int dfs(TreeNode* root)\n    &#123;\n        if (!root) return 0;\n        int left &#x3D; max(0, dfs(root-&gt;left)), right &#x3D; max(0, dfs(root-&gt;right));&#x2F;&#x2F;&gt;0\n        ans &#x3D; max(ans, left + root-&gt;val + right);\n        return root-&gt;val + max(left, right);&#x2F;&#x2F;子树的顶到底max路径和 只为递归\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;P369 0x63 求树的直径 树形DP法、两次BFS或DFS法\n&#x2F;*\n树的直径是指树的最长简单路。求法: \n两遍BFS:\n先任选一个起点BFS找到最长路的终点，再从终点进行BFS，则第二次BFS找到的最长路即为树的直径；\n原理:\n设起点为u,第一次BFS找到的终点v一定是树的直径的一个端点\n证明:\n1) 如果u 是直径上的点，则v显然是直径的终点(因为如果v不是的话，则必定存在另一个点w使得u到w的距离更长，则于BFS找到了v矛盾)\n2) 如果u不是直径上的点，则u到v必然于树的直径相交(反证),那么交点到v 必然就是直径的后半段了\n所以v一定是直径的一个端点，所以从v进行BFS得到的一定是直径长度\n*&#x2F;\n\n\n\n125.验证回文串 双指针 只考虑字母和数字字符，可以忽略字母的大小写。class Solution &#123;\npublic:\n    bool check(char c) &#123;\n        return c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39; || c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39; || c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;;\n    &#125;\n    bool isPalindrome(string s) &#123;\n        for(int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; i++, j--) &#123;\n            while(i &lt; j &amp;&amp; !check(s[i])) i++;\n            while(i &lt; j &amp;&amp; !check(s[j])) j--;\n            if(i &lt; j &amp;&amp; tolower(s[i]) !&#x3D; tolower(s[j])) return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n\n\n—126.单词接龙II 01最短路 bfs+dfs 输出方案 S.count(st)???\n&#x2F;*\nT&#x3D;O(2^(n&#x2F;3)) 至少指数级别\n最短路模型：\n01 bfs\n+ dijkstra\n- SPFA\n\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;217&#x2F;\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; ans;\n    vector&lt;string&gt; path;\n    unordered_set&lt;string&gt; S;\n    unordered_map&lt;string, int&gt; dist;&#x2F;&#x2F;到起点的距离\n\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        for (auto&amp; word: wordList) S.insert(word);\n        queue&lt;string&gt; q;\n        q.push(beginWord);\n        dist[beginWord] &#x3D; 0;\n        while (q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            string r &#x3D; t;\n            for (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n                t &#x3D; r;\n                for (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n                    if (j !&#x3D; r[i]) &#123;\n                        t[i] &#x3D; j;\n                        if (S.count(t) &amp;&amp; dist.count(t) &#x3D;&#x3D; 0) &#123;\n                            dist[t] &#x3D; dist[r] + 1;\n                            if (t &#x3D;&#x3D; endWord) break;\n                            q.push(t);\n                        &#125;\n                    &#125;\n            &#125;\n        &#125;\n\n        if (dist.count(endWord)) &#123;\n            path.push_back(beginWord);\n            dfs(beginWord, endWord);\n        &#125;\n\n        return ans;\n    &#125;\n\n    void dfs(string st, string ed) &#123;&#x2F;&#x2F;正的\n        if (st &#x3D;&#x3D; ed) &#123;\n            ans.push_back(path);\n            return;\n        &#125;\n\n        string r &#x3D; st;\n        for (int i &#x3D; 0; i &lt; st.size(); i ++ ) &#123;\n            st &#x3D; r;\n            for (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n                if (j !&#x3D; r[i]) &#123;\n                    st[i] &#x3D; j;\n                    &#x2F;&#x2F;S.count(st)???\n                    if (S.count(st) &amp;&amp; dist[r] + 1 &#x3D;&#x3D; dist[st]) &#123;&#x2F;&#x2F;start-&gt;r-&gt;st\n                        path.push_back(st);\n                        dfs(st, ed);\n                        path.pop_back();\n                    &#125;\n                &#125;\n        &#125;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;写法2\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; ans;\n    vector&lt;string&gt; path;\n    unordered_set&lt;string&gt; S;\n    unordered_map&lt;string, int&gt; dist;&#x2F;&#x2F;到起点的距离\n    string beginWord;\n\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string _beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        beginWord &#x3D; _beginWord;\n        for (auto&amp; word: wordList) S.insert(word);\n        queue&lt;string&gt; q;\n        q.push(beginWord);\n        dist[beginWord] &#x3D; 0;\n        while (q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            string r &#x3D; t;\n            for (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n                t &#x3D; r;\n                for (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n                    if (j !&#x3D; r[i]) &#123;\n                        t[i] &#x3D; j;\n                        if (S.count(t) &amp;&amp; dist.count(t) &#x3D;&#x3D; 0) &#123;\n                            dist[t] &#x3D; dist[r] + 1;&#x2F;&#x2F;start-&gt;r-&gt;t\n                            if (t &#x3D;&#x3D; endWord) break;\n                            q.push(t);\n                        &#125;\n                    &#125;\n            &#125;\n        &#125;\n\n        if (dist.count(endWord)) &#123;\n            path.push_back(endWord);\n            dfs(endWord);\n        &#125;\n\n        return ans;\n    &#125;\n\n    void dfs(string t) &#123;\n        if (t &#x3D;&#x3D; beginWord) &#123;\n        \treverse(path.begin(),path.end());\n            ans.push_back(path);\n           \treverse(path.begin(),path.end());\n            return;\n        &#125;\n        string r &#x3D; t;\n        for (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n            t &#x3D; r;\n            for (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n                if (j !&#x3D; r[i]) &#123;\n                    t[i] &#x3D; j;\n                    &#x2F;&#x2F;S.count(t)错 因为beginWord不一定在wordList里(上层过滤了)\n                    if (dist.count(t) &amp;&amp; dist[t] + 1 &#x3D;&#x3D; dist[r]) &#123;&#x2F;&#x2F;start&lt;-t&lt;-r\n                        path.push_back(t);\n                        dfs(t);\n                        path.pop_back();\n                    &#125;\n                &#125;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n\n\n127.单词接龙 min_node_stepclass Solution &#123;\npublic:\n\tint ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n\t\tunordered_set&lt;string&gt; S;\n\t\tfor (auto&amp; word: wordList) S.insert(word);\n\t\tunordered_map&lt;string, int&gt; dist;&#x2F;&#x2F;到起点的距离\n\t\tdist[beginWord] &#x3D; 0;\n\t\tqueue&lt;string&gt; q;\n\t\tq.push(beginWord);\n\t\t\n\t\twhile (q.size()) &#123;\n\t\t\tauto t &#x3D; q.front();\n\t\t\tq.pop();\n\n\t\t\tstring r &#x3D; t;\n\t\t\tfor (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n\t\t\t\tt &#x3D; r;\n\t\t\t\tfor (char j &#x3D; &#39;a&#39;; j &lt;&#x3D; &#39;z&#39;; j ++ )\n\t\t\t\t\tif (j !&#x3D; r[i]) &#123;\n\t\t\t\t\t\tt[i] &#x3D; j;\n\t\t\t\t\t\tif (S.count(t) &amp;&amp; dist.count(t) &#x3D;&#x3D; 0) &#123;\n\t\t\t\t\t\t\tdist[t] &#x3D; dist[r] + 1;&#x2F;&#x2F;start-&gt;r-&gt;t\n\t\t\t\t\t\t\tif (t &#x3D;&#x3D; endWord) return dist[t] + 1;\n\t\t\t\t\t\t\tq.push(t);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn 0;\n\t&#125;\n&#125;;\n\n\n\n\n—128.最长连续序列 找出【数字连续的最长】序列(可乱序 不连续) T&#x3D;O(n) hash 枚举段首 多次段首去重S.erase(x);  max[x,y]&#x2F;*\n！！！UF-set：路径压缩+按秩合并&#x3D;每步O(1)\n将数组中数值相邻的元素使用并查集合并，最后看一下哪一个连通块最大【单链表】\n在这里不能按秩合并：O(logn)-&gt;T&#x3D;O(nlogn)\n！！！\n\n最simple：\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;6379&#x2F; 未去重!\n枚举段首 多次段首去重S.erase(x);\n*&#x2F;\nclass Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;int&gt; S;\n        for(auto x: nums) S.insert(x);\n\n        int res &#x3D; 0;\n        for(auto x: nums) &#123;\n            if(S.count(x) &amp;&amp; !S.count(x - 1)) &#123;&#x2F;&#x2F;段首\n                int y &#x3D; x;\n                S.erase(x);&#x2F;&#x2F;&#x3D;&#x3D;去重\n                while(S.count(y + 1)) &#123;\n                    y++;\n                    S.erase(y);&#x2F;&#x2F;\n                &#125;\n                res &#x3D; max(res, y - x + 1);&#x2F;&#x2F;[x,y]\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;*!!!666\nhash表维护区间：yxc\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;222&#x2F;\n\n“tr_left[x-left] &#x3D; max(tr_left[x-left], left+1+right);”为什么要取max呢，\nleft+1+right不就应该是当前以x-left为左端点的序列长度最大值吗\n回复\n所有极大区间两端的点存储的tr_left和tr_right都是整个区间的长度，\n【但区间内的点存储的长度可能比实际值要小。】\n可以试试这个样例，正确答案是5，如果去掉max操作会得到4：\n[-6,8,-5,7,-9,-1,-7,-6,-9,-7,5,7,-1,-8,-8,-2,0]\n因为我们没有删除冗余的小区间，如果合并区间的同时把冗余小区间删除，就没有这个问题了。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; 0;\n        unordered_map&lt;int, int&gt; tr_left, tr_right;&#x2F;&#x2F;[cur]&#x3D;L,R端点的max区间\n        for (auto&amp; x : nums)\n        &#123;\n            int left &#x3D; tr_right[x - 1];\n            int right &#x3D; tr_left[x + 1];\n            tr_left[x - left] &#x3D; max(tr_left[x - left], left + 1 + right);\n            tr_right[x + right] &#x3D; max(tr_right[x + right], left + 1 + right);\n            res &#x3D; max(res, left + 1 + right);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;*\nwzc1995   2018-06-10 14:00  [--X--] 更新的是同一个F，无冗余小区间\n可以只用一个哈希表记录每个数字所能构成的最大长度\n当扫描到一个新数字时，找该数字左右数字的最大长度，合并后，更新该数字和新连续序列左右数字的哈希值。\n如果当前扫描到的数已经在哈希表中了，则直接跳过。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n\n        int res &#x3D; 0;\n        unordered_map&lt;int,int&gt;F;\n        for(auto x:nums)\n        &#123;\n          if(F[x])continue;&#x2F;&#x2F;三个点同时判重\n          F[x]&#x3D;1;&#x2F;&#x2F;标记\n          int left&#x3D;F[x-1];&#x2F;&#x2F;记录左右点包含的点个数\n          int right&#x3D;F[x+1];\n          F[x-left]&#x3D;right+left+1;&#x2F;&#x2F;更新左右边界区间内点的个数\n          F[x+right]&#x3D;right+left+1;\n          res&#x3D;max(res,right+left+1);\n        &#125;\n      return res;\n    &#125;\n\n\n&#125;;&#x2F;&#x2F;根据下面讨论区大佬的观点写的\n\n&#x2F;*\nyxc   2018-06-10 15:05     回复  端点lr 内部跳过了，一个range\n有道理！哈希表中记录每个数为边界的最大长度，则【只有区间边界的数有意义】，【如果遇到内部的数，我们直接跳过。】\n当遍历到 x 时，先求出 x−1 的最大长度，则由于 x 第一次遍历到，所以 x−1 如果存在，\n则一定是某个区间的右端点，同理 x+1 一定是某个区间的左端点。\n所以我们同时开两个哈希表，记录左右两边的哈希值是多余的，仅需一个哈希表即可。\n*&#x2F;\nclass Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        int maxs &#x3D; 0;\n        unordered_map&lt;int,int&gt; range;\n        for (int x: nums) &#123;\n            int l &#x3D; x;\n            int r &#x3D; x;\n            if (range[x] &gt; 0) continue;\n            l &#x3D; l - range[x - 1];\n            r &#x3D; r + range[x + 1];\n\n            range[l] &#x3D; r - l + 1;\n            range[r] &#x3D; r - l + 1;\n            range[x] &#x3D; max(range[x], 1); &#x2F;&#x2F;  注意这里\n            maxs &#x3D; max(maxs, r - l + 1);\n\n        &#125;\n        return maxs;\n    &#125; \n&#125;;\n\n\n\n129.求根节点到叶节点数字之和 路径 1-&gt;2 代表数字 12 数字总和 &#x3D; 12 + 13 &#x3D; 25\n&#x2F;&#x2F;129.求根节点到叶节点数字之和\n&#x2F;*\n输入：root &#x3D; [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1-&gt;2 代表数字 12\n从根到叶子节点路径 1-&gt;3 代表数字 13\n因此，数字总和 &#x3D; 12 + 13 &#x3D; 25\n*&#x2F;\nclass Solution &#123;\npublic:\n    int ans &#x3D;  0;\n    int sumNumbers(TreeNode* root) &#123;\n        if(root) dfs(root, 0);\n        return ans;\n    &#125;\n\n    void dfs(TreeNode* root, int number) &#123;\n        number &#x3D; number * 10 + root-&gt;val;\n        if(!root-&gt;left &amp;&amp; !root-&gt;right) ans +&#x3D; number;&#x2F;&#x2F;\n        if(root-&gt;left) dfs(root-&gt;left, number);\n        if(root-&gt;right) dfs(root-&gt;right, number);\n    &#125;\n&#125;;\n\n\n\n\n130.被围绕的区域 围棋 逆向思维：mark边界O，其余–&gt;X  floodfill_dfs标记连通块&#x2F;&#x2F;130.被围绕的区域 围棋\n&#x2F;&#x2F;floodfill找连通块 dfs不用queue\n&#x2F;&#x2F;逆向思维：mark边界O，其余--&gt;X\nclass Solution &#123;\npublic:\n    int n, m;\n    vector&lt;vector&lt;char&gt;&gt; board;\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n    \n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; _board) &#123;\n        board &#x3D;  _board;\n        n &#x3D; board.size();\n        if(!n) return;\n        m &#x3D; board[0].size();\n\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            if(board[i][0] &#x3D;&#x3D; &#39;O&#39;) dfs(i, 0);\n            if(board[i][m - 1] &#x3D;&#x3D; &#39;O&#39;) dfs(i, m - 1);\n        &#125;\n        \n        for(int i &#x3D; 0; i &lt; m; i++) &#123;\n            if(board[0][i] &#x3D;&#x3D; &#39;O&#39;) dfs(0, i);\n            if(board[n - 1][i] &#x3D;&#x3D; &#39;O&#39;) dfs(n - 1, i);\n        &#125;\n\n        for(int i &#x3D; 0; i &lt; n; i++) \n            for(int j &#x3D; 0; j &lt; m; j++)\n                if(board[i][j] &#x3D;&#x3D; &#39;#&#39;) board[i][j] &#x3D; &#39;O&#39;;&#x2F;&#x2F;recover\n                else board[i][j] &#x3D; &#39;X&#39;;\n\n        _board &#x3D; board;\n    &#125;\n    &#x2F;&#x2F;递归标记连通块\n    void dfs(int x, int y) &#123;\n        board[x][y] &#x3D; &#39;#&#39;;&#x2F;&#x2F;mark\n        for(int i &#x3D; 0; i &lt; 4; i++) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if(a &gt;&#x3D; 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; board[a][b] &#x3D;&#x3D; &#39;O&#39;)\n                dfs(a, b);\n        &#125;\n    &#125;\n&#125;;\n\n\n\n\n131.分割回文串 DP递推预处理+爆搜:O(n^2 + 2^n)\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;bool&gt;&gt; f;\n    vector&lt;vector&lt;string&gt;&gt; ans;\n    vector&lt;string&gt; path;\n\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;\n        int n &#x3D; s.size();\n        f &#x3D; vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(n));\n        for(int j &#x3D; 0; j &lt; n; j++)\n            for(int i &#x3D; 0; i &lt;&#x3D; j; i++) &#x2F;&#x2F; &lt;&#x3D; j(i())：f拓扑序\n                if(i &#x3D;&#x3D; j) f[i][j] &#x3D; true;\n                else if(s[i] &#x3D;&#x3D; s[j]) &#123;\n                    if(i + 1 &gt; j - 1 || f[i + 1][j - 1]) f[i][j] &#x3D; true;&#x2F;&#x2F;\n                &#125;\n        dfs(s, 0);\n        return ans;\n    &#125;\n    void dfs(string&amp; s, int u) &#123;\n        if(u &#x3D;&#x3D; s.size()) ans.push_back(path);\n        else &#123;\n            for(int i &#x3D; u; i &lt; s.size(); i++)\n                if(f[u][i]) &#123;\n                    path.push_back(s.substr(u, i - u + 1));\n                    dfs(s, i + 1);\n                    path.pop_back();\n                &#125;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n132.分割回文串 II DP min_cut&#x3D;min_part-1 if(g_ji) f[i] &#x3D; min(f[i], f[j - 1] + 1);\n&#x2F;&#x2F;132.分割回文串 II DP:O(n^2) min_cut&#x3D;min_part-1 if(g[j][i]) f[i] &#x3D; min(f[i], f[j - 1] + 1);\nclass Solution &#123;\npublic:\n    int minCut(string s) &#123;\n        int n &#x3D; s.size();\n        s &#x3D; &#39; &#39; + s;\n        vector&lt;vector&lt;bool&gt;&gt; g(n + 1, vector&lt;bool&gt;(n + 1));\n        vector&lt;int&gt; f(n + 1, INT_MAX);\n\n        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)\n            for(int i &#x3D; 1; i &lt;&#x3D; j; i++)\n                if(i &#x3D;&#x3D; j) g[i][j] &#x3D; true;\n                else if(s[i] &#x3D;&#x3D; s[j])\n                    g[i][j] &#x3D; i + 1 &gt; j - 1 || g[i + 1][j - 1];\n\n        f[0] &#x3D; 0;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            for(int j &#x3D; 1; j &lt;&#x3D; i; j++)\n                if(g[j][i]) f[i] &#x3D; min(f[i], f[j - 1] + 1);&#x2F;&#x2F;\n\n        return f[n] - 1;&#x2F;&#x2F;cut&#x3D;part-1\n    &#125;\n&#125;;\n\n\n\n\n133.克隆图 无相连通图 深克隆 邻接列表              d-&gt;neighbors.push_back(hash[ver]);&#x2F;&#x2F;133.克隆图 无相连通图 深克隆 邻接列表\nclass Solution &#123;\npublic:\n    unordered_map&lt;Node*, Node*&gt; hash;\n\n    Node* cloneGraph(Node* node) &#123;\n        if(!node) return NULL;\n        dfs(node); &#x2F;&#x2F; copy all nodes\n\n        for(auto [s, d]: hash)\n            for(auto ver: s-&gt;neighbors)\n                d-&gt;neighbors.push_back(hash[ver]);&#x2F;&#x2F;copy edges\n\n        return hash[node];\n    &#125;\n\n    void dfs(Node* node) &#123;\n        hash[node] &#x3D; new Node(node-&gt;val);\n\n        for(auto ver: node-&gt;neighbors)\n            if(!hash.count(ver)) dfs(ver);&#x2F;&#x2F;判重\n    &#125;\n&#125;;\n\n\n\n\n—134.加油站 O(n) 本质：贪心，基于：枚举+优化 O(n*n)-&gt;O(n)\n&#x2F;*\n---Acwing1088旅行问题 单调队列做法O(n) 更通用！\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;content&#x2F;description&#x2F;1090&#x2F;\n\n针对性O(n) 本质：贪心，基于：枚举+优化\n中间有left都走不到j+1，作为起点无油更不可能走到j+1！O(n*n)-&gt;O(n)\n*&#x2F;\nclass Solution &#123;\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;\n        int n &#x3D; gas.size();\n        for(int i &#x3D; 0, j; i &lt; n; ) &#123;&#x2F;&#x2F;枚举起点 i++ -&gt; i +&#x3D; j + 1;\n            int left &#x3D; 0;\n            for(j &#x3D; 0; j &lt; n; j++) &#123;\n                int k &#x3D; (i + j) % n;\n                left +&#x3D; gas[k] - cost[k];\n                if(left &lt; 0) break;\n            &#125;\n            if(j &#x3D;&#x3D; n) return i;\n            i +&#x3D; j + 1;\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n\n\n\n—135.分发糖果  &gt;&#x3D;1&#x2F;person min_sum 记忆化搜索DP:f[x]&#x3D;max(dp(x-1)+1,dp(x+1)+1)&#x2F;&#x2F;---135.分发糖果  &gt;&#x3D;1&#x2F;person min_sum 记忆化搜索DP:f[x]&#x3D;max(dp(x-1)+1,dp(x+1)+1)\n&#x2F;&#x2F;题解s：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;2505&#x2F;1&#x2F;\n&#x2F;&#x2F;正f反g两次扫描~ max(f,g)\n&#x2F;&#x2F;Acwing901滑雪 2Dhigh-&gt;low:max_step\n&#x2F;&#x2F;https:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;content&#x2F;description&#x2F;903&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; f;\n    vector&lt;int&gt; w;\n    int n;\n\n    int candy(vector&lt;int&gt;&amp; ratings) &#123;\n        n &#x3D; ratings.size();\n        w &#x3D; ratings;\n        f.resize(n, -1);&#x2F;&#x2F;\n\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res +&#x3D; dp(i);\n        return res;\n    &#125;\n    &#x2F;&#x2F;记忆化搜索 O(n)\n    int dp(int x) &#123;\n        if(f[x] !&#x3D; -1) return f[x];\n        f[x] &#x3D; 1;\n        if(x &amp;&amp; w[x - 1] &lt; w[x]) f[x] &#x3D; max(f[x], dp(x - 1) + 1);\n        if(x + 1 &lt; n &amp;&amp; w[x + 1] &lt; w[x]) f[x] &#x3D; max(f[x], dp(x + 1) + 1);\n        return f[x];\n    &#125;\n&#125;;\n\n\n\n136.只出现一次的数字 其余2次 x^x&#x3D;0 0^x&#x3D;x 全异或class Solution &#123;\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; 0;\n        for(auto x: nums) res ^&#x3D; x;\n        return res;\n    &#125;\n&#125;;\n\n\n\n—！！！137-&gt;260.只出现一次的数字II 其余3次 O(1) DFA有限状态机模型 &#x2F; 若第i位1出现次数为3k+1，则说明答案在第i位是1\n\n\n&#x2F;&#x2F;137.只出现一次的数字II 其余3次 位运算：32b并行\n&#x2F;&#x2F;有限状态机DFA: https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;single-number-ii&#x2F;solution&#x2F;single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891&#x2F;\nclass Solution &#123;\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int two &#x3D; 0, one &#x3D; 0;\n        for(auto x: nums) &#123;\n            one &#x3D; (one ^ x) &amp; ~two;\n            two &#x3D; (two ^ x) &amp; ~one;\n        &#125;\n        return one;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;若第i位1出现次数为3k+1，则说明答案在第i位是1\nclass Solution &#123;\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int ans &#x3D; 0;\n        for(int bit &#x3D; 0;bit &lt; 32;bit ++)\n        &#123;\n            int cnt &#x3D; 0;\n            for(int i &#x3D; 0;i &lt; n;i ++)\n            &#123;\n                if((nums[i] &gt;&gt; bit &amp; 1) &#x3D;&#x3D; 1) cnt ++; \n            &#125;\n            if(cnt % 3 !&#x3D; 0) ans +&#x3D; 1 &lt;&lt; bit;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n\nO(N)\nHashSet py\nclass Solution:\n    def singleNumber(self, nums):\n        return (3 * sum(set(nums)) - sum(nums)) &#x2F;&#x2F; 2\n\nHashMap py\nfrom collections import Counter\nclass Solution:\n    def singleNumber(self, nums):\n        hashmap &#x3D; Counter(nums)\n            \n        for k in hashmap.keys():\n            if hashmap[k] &#x3D;&#x3D; 1:\n                return k\n\n\n\n138&lt;-133.复制带随机指针的链表 “小弟”省hash表:S&#x3D;O(1)\nclass Solution &#123;\npublic:\n    Node* copyRandomList(Node* head) &#123;\n        &#x2F;&#x2F;复制一个小弟\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next-&gt;next) &#123;\n            auto q &#x3D; new Node(p-&gt;val);\n            q-&gt;next &#x3D; p-&gt;next;\n            p-&gt;next &#x3D; q;\n        &#125;\n        &#x2F;&#x2F;复制random指针\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next-&gt;next)\n            if(p-&gt;random)\n                p-&gt;next-&gt;random &#x3D; p-&gt;random-&gt;next;\n\n        &#x2F;&#x2F;拆分两个链表\n        auto dummy &#x3D; new Node(-1), cur &#x3D; dummy;\n        for(auto p &#x3D; head; p; p &#x3D; p-&gt;next) &#123;\n            auto q &#x3D; p-&gt;next;\n            cur &#x3D; cur-&gt;next &#x3D; q;\n            p-&gt;next &#x3D; q-&gt;next;\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n\n\n—139.单词拆分(类似132分割回文串II) DP优化+str_hash f[j] &#x3D; f[i] &amp;&amp; s[i+1~j]在hash里出现过\n&#x2F;&#x2F;类似132分割回文串II DP优化\n&#x2F;*\n《judge str在字典里出现过》\nunordered_set&lt;string&gt; CURD:O(n)\ns.substr  T&#x3D;O(n^3)\n\nT&#x3D;O(n^2) 我们一共有 O(n) 个状态需要计算，每次计算需要枚举 O(n) 个分割点，\n哈希表判断一个字符串是否出现在给定的字符串列表需要 O(1) 的时间。\n优化为O(1)：trie KMP str_hash(Acwing 841)\n*&#x2F;\n&#x2F;&#x2F;正推\nclass Solution &#123;\npublic:\n\tbool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n\t\ttypedef unsigned long long ULL;&#x2F;&#x2F;&#x3D;&#x3D;%2^64\n\t\tunordered_set&lt;ULL&gt; hash;\n\t\tconst int P &#x3D; 131;&#x2F;&#x2F;\n\t\tfor(auto&amp; word: wordDict) &#123;\n\t\t\tULL h &#x3D; 0;\n\t\t\tfor(auto c: word) h &#x3D; h * P + c;\n\t\t\thash.insert(h);\n\t\t&#125;\n\n\t\tint n &#x3D; s.size();\n\t\t&#x2F;&#x2F;f[i]&#x3D;dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[1~i] 是否能被空格拆分成若干个字典中出现的单词。\n\t\tvector&lt;bool&gt; f(n + 1);\n\t\tf[0] &#x3D; true;\n\t\ts &#x3D; &#39; &#39; + s;&#x2F;&#x2F;s[1]开始\n\t\tfor(int i &#x3D; 0; i &lt; n; i++)\n\t\t\tif(f[i]) &#123;&#x2F;&#x2F;f[j] &#x3D; f[i] &amp;&amp; s[i+1~j]在hash里出现过\n\t\t\t\tULL h &#x3D; 0;\n\t\t\t\t&#x2F;&#x2F;s[i+1~j]在hash里出现过 cur_state-&gt;?state\n\t\t\t\tfor(int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;\n\t\t\t\t\th &#x3D; h * P + s[j]; &#x2F;&#x2F;s[1]开始\n\t\t\t\t\tif(hash.count(h)) f[j] &#x3D; true;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\treturn f[n];\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;逆推\nclass Solution &#123;\npublic:\n\tbool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n\t\ttypedef unsigned long long ULL;\n\t\tunordered_set&lt;ULL&gt; hash;\n\t\tconst int P &#x3D; 131;&#x2F;&#x2F;\n\t\tfor(auto&amp; word: wordDict) &#123;\n\t\t\tULL h &#x3D; 0;\n\t\t\tfor(auto c: word) h &#x3D; h * P + c;\n\t\t\thash.insert(h);\n\t\t&#125;\n\n\t\tint n &#x3D; s.size();\n\t\t&#x2F;&#x2F;f[i]&#x3D;dp[i] 表示字符串 s[i~n-1] 是否能被空格拆分成若干个字典中出现的单词。\n\t\tvector&lt;bool&gt; f(n + 1);\n\t\tf[n] &#x3D; true;\n\n\t\tfor(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;\n\t\t\tULL h &#x3D; 0;\n\t\t\tfor(int j &#x3D; i; j &lt; n; j++) &#123;\n\t\t\t\th &#x3D; h * P + s[j];\n\t\t\t\tif(hash.count(h) &amp;&amp; f[j + 1]) &#123;\n\t\t\t\t\tf[i] &#x3D; true;&#x2F;&#x2F;f[i] &#x3D; f[j+1] &amp;&amp; s[i~j]出现在hash中\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\treturn f[0];\n\t&#125;\n&#125;;\n\n\n\n—140.单词拆分II cases:DP预处理f+dfs递归&#x2F;&#x2F;逆推\nclass Solution &#123;\npublic:\n\tvector&lt;bool&gt; f;\n\tvector&lt;string&gt; ans;\n\tunordered_set&lt;string&gt; hash;\n\tint n;\n\n\tvector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n\t\tfor(auto word: wordDict) hash.insert(word);&#x2F;&#x2F;瓶颈变为cases:O(2^n),O(n^3)不用优化了\n\n\t\tn &#x3D; s.size();\n\t\tf.resize(n + 1);\n\t\t&#x2F;&#x2F;f[i]&#x3D;dp[i] 表示字符串 s[i~n-1] 是否能被空格拆分成若干个字典中出现的单词。\n\t\tf[n] &#x3D; true;\n\t\t&#x2F;&#x2F;DP预处理f\n\t\tfor(int i &#x3D; n - 1; ~i; i--)\n\t\t\tfor(int j &#x3D; i; j &lt; n; j++)\n\t\t\t\tif(hash.count(s.substr(i, j - i + 1)) &amp;&amp; f[j + 1]) &#123;\n\t\t\t\t\tf[i] &#x3D; true;&#x2F;&#x2F;f[i] &#x3D; s[i~j]出现在hash中 &amp;&amp; f[j+1]\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\tdfs(s, 0, &quot;&quot;);\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(string&amp; s, int u, string path) &#123;\n\t\tif(u &#x3D;&#x3D; n) &#123;\n\t\t\tpath.pop_back();&#x2F;&#x2F;去&#39; &#39;\n\t\t\tans.push_back(path);\n\t\t&#125; else &#123;\n\t\t\tfor(int i &#x3D; u; i &lt; n; i++)\n\t\t\t\tif(hash.count(s.substr(u, i - u + 1)) &amp;&amp; f[i + 1])&#x2F;&#x2F;s[u~i]\n\t\t\t\t\tdfs(s, i + 1, path + s.substr(u, i - u + 1) + &#39; &#39;);\n\t\t&#125;\n\t&#125;\n&#125;;\n\n\n\n141.环形链表 S&#x3D;O(1)快慢指针 先next后判空不可能有连续环，因为会有分叉即2个next_ptr\nhash表：adr判重\n但要求S&#x3D;O(1)：故使用 ！快慢指针！2步1步[如果有环，保证能遇上不错过] 相遇有环 ！！！先next后判空！！！\nclass Solution &#123;\npublic:\n    bool hasCycle(ListNode *head) &#123;\n        if(!head || !head-&gt;next) return false;\n        auto s &#x3D; head, f &#x3D; head-&gt;next;\n        while(f) &#123;&#x2F;&#x2F;\n            s &#x3D; s-&gt;next, f &#x3D; f-&gt;next;&#x2F;&#x2F;slow+1\n            if(!f) return false;&#x2F;&#x2F;NULL\n            f &#x3D; f-&gt;next;&#x2F;&#x2F;fast+2\n            if(s &#x3D;&#x3D; f) return true;&#x2F;&#x2F;相遇有环\n        &#125;\n        return false;&#x2F;&#x2F;NULL\n    &#125;\n&#125;;\n\n\n\n142.环形链表II 环入口 相遇点c+x步&#x3D;入口b\n&#x2F;&#x2F;hash表\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        unordered_set&lt;ListNode *&gt; visited;\n        while (head !&#x3D; nullptr) &#123;\n            if (visited.count(head)) &#123;\n                return head;\n            &#125;\n            visited.insert(head);\n            head &#x3D; head-&gt;next;\n        &#125;\n        return nullptr;\n    &#125;\n&#125;;\n\n作者：LeetCode-Solution\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;linked-list-cycle-ii&#x2F;solution&#x2F;huan-xing-lian-biao-ii-by-leetcode-solution&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;相遇点c+x步&#x3D;入口b  f&#x3D;f-&gt;next是因为init时f&#x3D;head-&gt;next; 1+环3 纸上模拟！\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        if(!head || !head-&gt;next) return NULL;\n        auto s &#x3D; head, f &#x3D; head-&gt;next;\n        while(f) &#123;&#x2F;&#x2F;\n            s &#x3D; s-&gt;next, f &#x3D; f-&gt;next;&#x2F;&#x2F;slow+1\n            if(!f) return NULL;\n            f &#x3D; f-&gt;next;&#x2F;&#x2F;fast+2\n            if(s &#x3D;&#x3D; f) &#123;\n                s &#x3D; head, f &#x3D; f-&gt;next;&#x2F;&#x2F;f &#x3D; f-&gt;next是因为init时f&#x3D;head-&gt;next;\n                while(s !&#x3D; f) s &#x3D; s-&gt;next, f &#x3D; f-&gt;next;\n                return s;\n            &#125;\n        &#125;\n        return NULL;\n\n    &#125;\n&#125;;\n\n\n\n\n—143.重排链表 找链表中点!+ 链表逆序 + 合并链表 T&#x3D;O(n) S&#x3D;O(1) 细节多！https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;reorder-list&#x2F;solution&#x2F;zhong-pai-lian-biao-by-leetcode-solution&#x2F;\n&#x2F;&#x2F;(1)线性表重建\n&#x2F;&#x2F;(2)寻找链表中点 + 链表逆序 + 合并链表 T&#x3D;O(n) S&#x3D;O(1)\nclass Solution &#123;\npublic:\n    void reorderList(ListNode* head) &#123;\n        if (head &#x3D;&#x3D; nullptr) &#123;\n            return;\n        &#125;\n        ListNode* mid &#x3D; middleNode(head);\n        ListNode* l1 &#x3D; head;\n        ListNode* l2 &#x3D; mid-&gt;next;\n        mid-&gt;next &#x3D; nullptr;\n        l2 &#x3D; reverseList(l2);\n        mergeList(l1, l2);\n    &#125;\n    &#x2F;&#x2F;快慢指针\n    ListNode* middleNode(ListNode* head) &#123;\n        ListNode* slow &#x3D; head;\n        ListNode* fast &#x3D; head;\n        while (fast-&gt;next !&#x3D; nullptr &amp;&amp; fast-&gt;next-&gt;next !&#x3D; nullptr) &#123;\n            slow &#x3D; slow-&gt;next;\n            fast &#x3D; fast-&gt;next-&gt;next;\n        &#125;\n        return slow;\n    &#125;\n\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode* prev &#x3D; nullptr;\n        ListNode* curr &#x3D; head;\n        while (curr !&#x3D; nullptr) &#123;\n            ListNode* nextTemp &#x3D; curr-&gt;next;\n            curr-&gt;next &#x3D; prev;\n            prev &#x3D; curr;\n            curr &#x3D; nextTemp;\n        &#125;\n        return prev;\n    &#125;\n\n    void mergeList(ListNode* l1, ListNode* l2) &#123;\n        ListNode* l1_tmp;\n        ListNode* l2_tmp;\n        while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;\n            l1_tmp &#x3D; l1-&gt;next;\n            l2_tmp &#x3D; l2-&gt;next;\n\n            l1-&gt;next &#x3D; l2;\n            l1 &#x3D; l1_tmp;\n\n            l2-&gt;next &#x3D; l1;\n            l2 &#x3D; l2_tmp;\n        &#125;\n    &#125;\n&#125;;\n\n作者：LeetCode-Solution\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;reorder-list&#x2F;solution&#x2F;zhong-pai-lian-biao-by-leetcode-solution&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;240&#x2F;\nclass Solution &#123;\npublic:\n    void reorderList(ListNode* head) &#123;\n        if(!head) return;\n        int n &#x3D; 0;\n        for (auto p &#x3D; head; p; p &#x3D; p-&gt;next) n ++ ;\n        \n        auto mid &#x3D; head;\n        for (int i &#x3D; 0; i + 1 &lt; (n + 1) &#x2F; 2; i ++ )\n            mid &#x3D; mid-&gt;next;\n        auto a &#x3D; mid, b &#x3D; a-&gt;next;\n\n        while (b) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a, a &#x3D; b, b &#x3D; c;\n        &#125;\n\n        mid-&gt;next &#x3D; 0;\n        while (head &amp;&amp; head !&#x3D; a) &#123;\n            b &#x3D; a-&gt;next;\n            a-&gt;next &#x3D; head-&gt;next;\n            head-&gt;next &#x3D; a;\n            head &#x3D; head-&gt;next-&gt;next;\n            a &#x3D; b;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;直播2\nclass Solution &#123;\npublic:\n    void reorderList(ListNode* head) &#123;\n        if(!head) return;\n        int n &#x3D; 0;\n        for (auto p &#x3D; head; p; p &#x3D; p-&gt;next) n ++ ;\n        \n        auto mid &#x3D; head;\n        for (int i &#x3D; 0; i + 1 &lt; (n + 1) &#x2F; 2; i ++ )\n            mid &#x3D; mid-&gt;next;\n        auto a &#x3D; mid, b &#x3D; a-&gt;next;\n\n        while (b) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a, a &#x3D; b, b &#x3D; c;\n        &#125;\n\n        auto p &#x3D; head, q &#x3D; a;\n        for(int i &#x3D; 0; i &lt; n &#x2F; 2; i++) &#123;\n        \tauto o &#x3D; q-&gt;next;\n        \tq-&gt;next &#x3D; p-&gt;next;\n        \tp-&gt;next &#x3D; q;\n        \tif(n % 2 &#x3D;&#x3D; 0 &amp;&amp; i &#x3D;&#x3D; n &#x2F; 2 - 1) q-&gt;next &#x3D; NULL;&#x2F;&#x2F;偶\n        \tp &#x3D; q-&gt;next, q &#x3D; o;\n        &#125;\n        if(n % 2) p-&gt;next &#x3D; NULL;&#x2F;&#x2F;奇\n    &#125;\n&#125;;\n&#x2F;&#x2F;直播1（备课）：\n\n\n144. 二叉树的前序遍历 (94.中序)class Solution &#123;\npublic:\n    vector&lt;int&gt; ans;\n\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;\n        dfs(root);\n        return ans;\n    &#125;\n\n    void dfs(TreeNode* root) &#123;\n        if(!root) return;\n        ans.push_back(root-&gt;val);\n        dfs(root-&gt;left);\n        dfs(root-&gt;right);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;针对二叉树类型的非递归版\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;TreeNode*&gt; st;\n\n        auto p &#x3D; root;\n\n        while (p || !st.empty()) &#123;\n            while (p) &#123;\n            \tres.push_back(p-&gt;val);&#x2F;&#x2F;\n                st.push(p);\n                p &#x3D; p-&gt;left;\n            &#125;\n            p &#x3D; st.top()-&gt;right;\n            st.pop();\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n145. 二叉树的后序遍历   LRN&#x3D;&#x3D;NRL+reverse 【转化！】为144题&#x2F;&#x2F;针对二叉树类型的非递归版\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt; res;\n        stack&lt;TreeNode*&gt; st;\n\n        auto p &#x3D; root;\n\n        while (p || !st.empty()) &#123;\n            while (p) &#123;\n            \tres.push_back(p-&gt;val);&#x2F;&#x2F;\n                st.push(p);\n                p &#x3D; p-&gt;right;&#x2F;&#x2F;\n            &#125;\n            p &#x3D; st.top()-&gt;left;&#x2F;&#x2F;\n            st.pop();\n        &#125;\n        reverse(res.begin(), res.end());\n        return res;\n    &#125;\n&#125;;\n\n\n\n—！！！146. LRU 缓存机制 T&#x3D;O(1)remove+insert到L-&gt;right:双链表+hash\n&#x2F;&#x2F;双链表O(1)remove left! 左边新右边旧\nclass LRUCache &#123;\npublic:\n    struct Node &#123;\n        int key, val;\n        Node *left, *right;\n        Node(int _key, int _val): key(_key), val(_val), left(NULL), right(NULL) &#123;&#125;\n    &#125;*L, *R;\n    unordered_map&lt;int, Node*&gt; hash;&#x2F;&#x2F;\n    int n;\n\n    LRUCache(int capacity) &#123;\n        n &#x3D; capacity;\n        L &#x3D; new Node(-1, -1), R &#x3D; new Node(-1, -1);\n        L-&gt;right &#x3D; R, R-&gt;left &#x3D; L;\n    &#125;\n\n    void remove(Node* p) &#123;\n        p-&gt;right-&gt;left &#x3D; p-&gt;left;\n        p-&gt;left-&gt;right &#x3D; p-&gt;right;\n    &#125;\n\n    void insert(Node* p) &#123;\n        p-&gt;right &#x3D; L-&gt;right;\n        p-&gt;left &#x3D; L;\n        L-&gt;right-&gt;left &#x3D; p;\n        L-&gt;right &#x3D; p;\n    &#125;\n\n    int get(int key) &#123;\n        if(!hash.count(key)) return -1;\n        auto p &#x3D; hash[key];\n        remove(p);\n        insert(p);\n        return p-&gt;val;&#x2F;&#x2F;\n    &#125;\n    \n    void put(int key, int value) &#123;\n        if(hash.count(key)) &#123;\n            auto p &#x3D; hash[key];\n            p-&gt;val &#x3D; value;&#x2F;&#x2F;\n            remove(p);\n            insert(p); \n        &#125; else &#123;\n            if(hash.size() &#x3D;&#x3D; n) &#123;\n                auto p &#x3D; R-&gt;left;\n                remove(p);&#x2F;&#x2F;双链表删\n                hash.erase(p-&gt;key);&#x2F;&#x2F;hash表删\n                delete p;&#x2F;&#x2F;引用删\n            &#125;\n            auto p &#x3D; new Node(key, value);\n            hash[key] &#x3D; p;\n            insert(p);\n        &#125;\n    &#125;\n&#125;;\n\n\n\n\n147.对链表进行插入排序 cur&#x2F;p&#x2F;cur-&gt;next(first &gt;p) O(n^2)class Solution &#123;\npublic:\n    ListNode* insertionSortList(ListNode* head) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        for(auto p &#x3D; head; p;) &#123;\n            auto cur &#x3D; dummy, next &#x3D; p-&gt;next;&#x2F;&#x2F;备份next\n            while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &lt;&#x3D; p-&gt;val) cur &#x3D; cur-&gt;next;&#x2F;&#x2F;\n            p-&gt;next &#x3D; cur-&gt;next;\n            cur-&gt;next &#x3D; p;\n            p &#x3D; next;&#x2F;&#x2F;\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n\n\n\n148.排序链表【最难链表题】 T&#x3D;O(nlogn) S&#x3D;O(1):自底向上归并mergesort 细节多 （23）\n堆排序：数组O(nlogn)，链表不能用堆！！！\n&#x2F;&#x2F;最适合链表的排序算法是归并排序。基于分治,S&#x3D;O(1)自底向上递推。\n&#x2F;&#x2F;148.排序链表 T&#x3D;O(nlogn) S&#x3D;O(1):自底向上归并mergesort\n&#x2F;&#x2F;堆排序：数组O(nlogn)，链表不能用堆！！！\n&#x2F;&#x2F;最适合链表的排序算法是归并排序。基于分治,S&#x3D;O(1)自底向上递推。\nclass Solution &#123;\npublic:\n    ListNode* sortList(ListNode* head) &#123;\n        &#x2F;&#x2F;很不熟练，利用自底向上的归并思想，每次先归并好其中一小段，之后对两小段之间进行归并\n        int n &#x3D; 0;\n        for(auto p &#x3D; head; p ; p &#x3D; p-&gt;next) n ++;\n\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n\n        for(int i &#x3D; 1; i &lt; n; i *&#x3D; 2 )&#123; &#x2F;&#x2F;每次归并段的长度，每次长度依次为1,2,4,8...n&#x2F;2\n        &#x2F;&#x2F;小于n是因为等于n时说明所有元素均归并完毕，大于n时同理\n            auto cur &#x3D; dummy;\n            for(int j &#x3D; 1; j + i &lt;&#x3D; n; j +&#x3D; 2 * i)&#123;&#x2F;&#x2F;j代表每一段的开始，每次将两段有序段归并为一个大的有序段，故而每次+2i\n            &#x2F;&#x2F;必须保证每段中间序号是小于链表长度的，显然，如果大于表长，就没有元素可以归并了\n                auto p &#x3D; cur-&gt;next,q &#x3D; p;&#x2F;&#x2F;p表示第一段的起始点，q表示第二段的起始点，之后开始归并即可\n                for(int k &#x3D; 0; k &lt; i; k ++) q &#x3D; q-&gt;next;\n                &#x2F;&#x2F;归并排序基本套路\n                &#x2F;&#x2F;x,y用于计数第一段和第二段归并的节点个数，由于当链表长度非2的整数倍时表长会小于i,故而需要加上p &amp;&amp; q的边界判断\n                 int x &#x3D; 0, y &#x3D; 0;\n                 while(x &lt; i &amp;&amp; y &lt; i &amp;&amp; p &amp;&amp; q)&#123;\n                     if(p-&gt;val &lt;&#x3D; q-&gt;val) cur &#x3D; cur-&gt;next &#x3D; p,p &#x3D; p-&gt;next,x ++;\n                     else cur &#x3D; cur-&gt;next &#x3D; q,q &#x3D; q-&gt;next,y++;\n                 &#125;\n                 while(x &lt; i &amp;&amp; p) cur &#x3D; cur-&gt;next &#x3D; p,p &#x3D; p-&gt;next,x ++;\n                 while(y &lt; i &amp;&amp; q) cur &#x3D; cur-&gt;next &#x3D; q,q &#x3D; q-&gt;next,y ++;\n                 cur-&gt;next &#x3D; q; &#x2F;&#x2F;记得把排好序的链表尾链接到下一链表的表头，循环完毕后q为下一链表表头\n            &#125;\n        &#125; \n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n\n\n（23题 Java）DP向上 【链表模拟每层merge】（用于148题：排序链表）\n\n\n\n149.直线上最多的点数 枚举中心点 重叠中心点 垂线 LD&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        typedef long double LD;\n\n        int res &#x3D; 0;\n        for(auto&amp; p: points) &#123;&#x2F;&#x2F;枚举中心点\n            int ss &#x3D; 0, vs &#x3D; 0;\n            unordered_map&lt;LD, int&gt; cnt;\n            for(auto&amp; q: points)\n                if(p &#x3D;&#x3D; q) ss ++;&#x2F;&#x2F;重叠中心点\n                else if(p[0] &#x3D;&#x3D; q[0]) vs++;&#x2F;&#x2F;垂线\n                else &#123;\n                    LD k &#x3D; (LD)(q[1] - p[1]) &#x2F; (q[0] - p[0]);\n                    cnt[k]++;\n                &#125;\n            int c &#x3D; vs;\n            for(auto [k, t]: cnt) c &#x3D; max(c, t);\n            res &#x3D; max(res, c + ss);&#x2F;&#x2F;+中心点\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;分数 更精确\nclass Solution &#123;\npublic:\n    int gcd(int x,int y)\n    &#123;\n        if(y &#x3D;&#x3D; 0)\n            return x;\n        return gcd(y,x % y);\n    &#125;\n    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        int n &#x3D; points.size();\n        if(n &lt; 3) return n;\n        int res &#x3D; 1;\n        for(int i &#x3D; 0 ; i &lt; n ; i ++)\n        &#123;\n            int r &#x3D; points[i][0],c &#x3D; points[i][1];\n            unordered_map&lt;string,int&gt; hash;\n            int vertical &#x3D; 0,duplicate &#x3D; 0;\n            for(int j &#x3D; i + 1 ; j &lt; n ; j ++)\n            &#123;\n                if(points[j][0] &#x3D;&#x3D; points[i][0])\n                &#123;\n                    vertical ++;\n                    if(points[j][1] &#x3D;&#x3D; points[i][1])\n                        duplicate ++;\n                &#125;\n            &#125;\n            for(int j &#x3D; i + 1 ; j &lt; n ; j ++)\n            &#123;\n                if(points[j][0] !&#x3D; points[i][0])\n                &#123;\n                    int x &#x3D; points[j][0],y &#x3D; points[j][1],com &#x3D; gcd(y - c,x - r);\n                    string key &#x3D; to_string( (y - c) &#x2F; com) + &quot;&#x2F;&quot; + to_string((x - r) &#x2F; com);\n                    hash[key] ++;\n                &#125;\n            &#125;\n          &#x2F;&#x2F;    需要加上重复的点以及固定点\n            for(auto&amp; it : hash)\n                res &#x3D; max(res,it.second + duplicate + 1);\n          &#x2F;&#x2F;    需要加上固定点\n            res &#x3D; max(res,vertical + 1);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n作者：T-SHLoRk\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;5695&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n150.逆波兰表达式求值 stk stoi(s)   atoi(t.c_str())class Solution &#123;\npublic:\n    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;\n        stack&lt;int&gt; sta;\n        for (auto &amp;t : tokens)\n            if (t &#x3D;&#x3D; &quot;+&quot; || t &#x3D;&#x3D; &quot;-&quot; || t &#x3D;&#x3D; &quot;*&quot; || t &#x3D;&#x3D; &quot;&#x2F;&quot;)\n            &#123;\n                int b &#x3D; sta.top();\n                sta.pop();\n                int a &#x3D; sta.top();\n                sta.pop();\n                if (t &#x3D;&#x3D; &quot;+&quot;) sta.push(a + b);\n                else if (t &#x3D;&#x3D; &quot;-&quot;) sta.push(a - b);\n                else if (t &#x3D;&#x3D; &quot;*&quot;) sta.push(a * b);\n                else sta.push(a &#x2F; b);\n            &#125;\n            else sta.push(atoi(t.c_str()));&#x2F;&#x2F;\n        return sta.top();\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;写法2\nclass Solution &#123;\npublic:\n\tstack&lt;int&gt; stk;\n\tvoid eval(string s) &#123;\n        int b &#x3D; stk.top();\n        stk.pop();\n        int a &#x3D; stk.top();\n        stk.pop();\n        if (s &#x3D;&#x3D; &quot;+&quot;) stk.push(a + b);\n        else if (s &#x3D;&#x3D; &quot;-&quot;) stk.push(a - b);\n        else if (s &#x3D;&#x3D; &quot;*&quot;) stk.push(a * b);\n        else stk.push(a &#x2F; b);\n    &#125;\n\n    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;\n        unordered_set&lt;string&gt; S&#123;&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;&#x2F;&quot;&#125;;\n        for (auto&amp; s: tokens)\n            if(S.count(s)) eval(s);\n            else stk.push(stoi(s));&#x2F;&#x2F;\n        return stk.top();\n    &#125;\n&#125;;\n\n\n\n\n151.翻转字符串里的单词 翻词+翻串 S&#x3D;O(1)原地coverclass Solution &#123;\npublic:\n    string reverseWords(string s) &#123;\n        int k &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(s[i] &#x3D;&#x3D; &#39; &#39;) continue;&#x2F;&#x2F;跳过(多个)空格\n            int j &#x3D; i, t &#x3D; k;&#x2F;&#x2F;i~j--原地cover--&gt;k~t\n            while(j &lt; s.size() &amp;&amp; s[j] !&#x3D; &#39; &#39;) s[t++] &#x3D; s[j++];\n            reverse(s.begin() + k, s.begin() + t);&#x2F;&#x2F;1.翻词\n            s[t++] &#x3D; &#39; &#39;;\n            i &#x3D; j, k &#x3D; t;&#x2F;&#x2F;更新起点\n        &#125;\n        if(k) k--;\n        s.erase(s.begin() + k, s.end());&#x2F;&#x2F;删&#39; &#39;+&#39; &#39;\n        reverse(s.begin(), s.end());&#x2F;&#x2F;2.翻串\n        return s;\n    &#125;\n&#125;;\n\n\n\n152.乘积最大子数组 负*负&#x3D;正 T&#x3D;O(n) S&#x3D;O(1)滚动！M:f-fa m:g-ga\nclass Solution &#123;\npublic:\n    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; nums[0];\n        int f &#x3D; nums[0], g &#x3D; nums[0];\n        for(int i &#x3D; 1; i &lt; nums.size(); i++) &#123;\n            int a &#x3D; nums[i], fa &#x3D; f * a, ga &#x3D; g * a;\n            f &#x3D; max(a, max(fa, ga));\n            g &#x3D; min(a, min(fa, ga));\n            res &#x3D; max(res, f);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n153.寻找旋转排序数组中的最小值（33简化 二分一次）class Solution &#123;\npublic:\n    int findMin(vector&lt;int&gt;&amp; nums) &#123;\n        int l &#x3D; 0, r &#x3D; nums.size() - 1;\n        if(nums[r] &gt;&#x3D; nums[l]) return nums[0];\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if(nums[mid] &lt; nums[0]) r &#x3D; mid;&#x2F;&#x2F;\n            else l &#x3D; mid + 1;\n        &#125;\n        return nums[r];\n    &#125;\n&#125;;\n\n\n\n\n\n154.寻找旋转排序数组中的最小值II（33 81）有重复：删尾class Solution &#123;\npublic:\n    int findMin(vector&lt;int&gt;&amp; nums) &#123;\n        int l &#x3D; 0, r &#x3D; nums.size() - 1;\n        while(l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[0]) r--;&#x2F;&#x2F;\n        if(nums[r] &gt;&#x3D; nums[l]) return nums[0];\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if(nums[mid] &lt; nums[0]) r &#x3D; mid;&#x2F;&#x2F;\n            else l &#x3D; mid + 1;\n        &#125;\n        return nums[r];\n    &#125;\n&#125;;\n\n\n\n\n155.最小栈\n&#x2F;&#x2F;155.最小栈 2栈+鸡肋优化\nclass MinStack &#123;\npublic:\n    &#x2F;** initialize your data structure here. *&#x2F;\n    stack&lt;int&gt; stk, f;\n    MinStack() &#123;\n\n    &#125;\n    \n    void push(int x) &#123;\n        stk.push(x);\n        if(f.empty() || f.top() &gt;&#x3D; x) f.push(x);\n    &#125;\n    \n    void pop() &#123;\n        if(stk.top() &lt;&#x3D; f.top()) f.pop();\n        stk.pop();\n    &#125;\n    \n    int top() &#123;\n        return stk.top();\n    &#125;\n    \n    int getMin() &#123;\n        return f.top();\n    &#125;\n&#125;;\n\n\nclass MinStack &#123;\npublic:\n    &#x2F;** initialize your data structure here. *&#x2F;\n    MinStack() &#123;\n    &#125;\n    \n    void push(int x) &#123;\n        if (st.size() &#x3D;&#x3D; 0) &#123;\n            st.push(&#123;x, x&#125;);\n        &#125; else &#123;\n            st.push(&#123;x, min(x, st.top().second)&#125;);\n        &#125;\n    &#125;\n    \n    void pop() &#123;\n        st.pop();\n    &#125;\n    \n    int top() &#123;\n        return st.top().first;\n    &#125;\n    \n    int getMin() &#123;\n        return st.top().second;\n    &#125;\nprivate:\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n&#125;;\n\n作者：fuxuemingzhu\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;min-stack&#x2F;solution&#x2F;zui-yi-dong-yi-ge-zhan-tong-shi-bao-cun-dang-qian-&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;一个栈： https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;6720&#x2F;\n\n\n\n156.\n\n\n\n\n\n157.\n\n\n\n158.\n\n\n\n159.\n\n\n\n\n\n160.相交链表 交换遍历到相遇&#x3D;first交点\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        auto p &#x3D; headA, q &#x3D; headB;\n        while(p !&#x3D; q) &#123;\n            p &#x3D; p ? p-&gt;next : headB;&#x2F;&#x2F;\n            q &#x3D; q ? q-&gt;next : headA;\n        &#125;\n        return p;\n    &#125;\n&#125;;\n\n\n\nLocked！161. One Edit Distance 判断它们的编辑距离是否为1。&#x2F;*\nO(n)\n分三种情况考虑：\n1.字符串长度之差大于1，则编辑距离一定大于1，返回false；\n2.字符串长度相等，则有且只有一个字符不同时，才返回true；\n3.字符串长度差1，则只需判断短字符串是否是长字符串的子序列即可：\n 用指针 i 指向短字符串开头(不妨设短字符串是 s，长字符串是 t)，然后扫描长字符串，\n 如果当前字符等于 s[i]，则令 i 加1。如果最终 i 能遍历完 s，则 s 就是 t 的子序列；\n*&#x2F;\nclass Solution &#123;\npublic:\n    bool isOneEditDistance(string s, string t) &#123;\n        if (s.size() &gt; t.size()) swap(s, t);\n        if (s.size() + 1 &lt; t.size()) return false;\n        if (s.size() &#x3D;&#x3D; t.size())\n        &#123;\n            int res &#x3D; 0;\n            for (int i &#x3D; 0; i &lt; s.size(); i ++ ) res +&#x3D; s[i] !&#x3D; t[i];\n            return res &#x3D;&#x3D; 1;\n        &#125;\n        int k &#x3D; 0;\n        for (int i &#x3D; 0; k &lt; s.size() &amp;&amp; i &lt; t.size(); i ++ )\n            if (t[i] &#x3D;&#x3D; s[k])\n                k ++ ;\n        return k &#x3D;&#x3D; s.size();\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;257&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n162.寻找峰值 二分\n\nclass Solution &#123;\npublic:\n    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;\n        int l &#x3D; 0, r &#x3D; nums.size() - 1;\n        while(l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if(nums[mid] &gt; nums[mid + 1]) r &#x3D; mid;\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n\n163.\n\n\n\n164.(sorted)最大间距 T&#x3D;S&#x3D;O(n) 基数排序 分桶法\nhttps:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;maximum-gap&#x2F;solution&#x2F;zui-da-jian-ju-by-leetcode-solution&#x2F;\n\n&#x2F;&#x2F;yxc 分桶法\nclass Solution &#123;\npublic:\n    int maximumGap(vector&lt;int&gt;&amp; nums) &#123;\n        struct Range &#123;\n            int min, max;\n            bool used;&#x2F;&#x2F;该区间有数\n            Range() : min(INT_MAX), max(INT_MIN), used(false)&#123;&#125;\n        &#125;;\n        int n &#x3D; nums.size();\n        int Min &#x3D; INT_MAX, Max &#x3D; INT_MIN;\n        for(auto x: nums) &#123;\n            Min &#x3D; min(Min, x);\n            Max &#x3D; max(Max, x);\n        &#125;\n        if(n &lt; 2 || Max &#x3D;&#x3D; Min) return 0;\n        vector&lt;Range&gt; r(n - 1);&#x2F;&#x2F;\n        int len &#x3D; (Max- Min + n -2) &#x2F; (n - 1);&#x2F;&#x2F;区间数\n        for(auto x: nums) &#123;\n            if(x &#x3D;&#x3D; Min) continue;\n            int k &#x3D; (x - Min - 1) &#x2F; len;&#x2F;&#x2F;1~x k:x所属区间\n            r[k].used &#x3D; true;\n            r[k].min &#x3D; min(r[k].min, x);\n            r[k].max &#x3D; max(r[k].max, x);\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0, last &#x3D; Min; i &lt; n - 1; i++)\n            if(r[i].used) &#123;\n                res &#x3D; max(res, r[i].min - last);\n                last &#x3D; r[i].max;\n            &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n165.比较版本号 3.1.2 &gt; 3.1  return 1&#x2F;-1&#x2F;0class Solution &#123;\npublic:\n    int compareVersion(string v1, string v2) &#123;\n        for(int i &#x3D; 0, j &#x3D; 0; i &lt; v1.size() || j &lt; v2.size();) &#123;\n            int a &#x3D; i, b &#x3D; j;\n            while(a &lt; v1.size() &amp;&amp; v1[a] !&#x3D; &#39;.&#39;) a++;&#x2F;&#x2F;i~a-1\n            while(b &lt; v2.size() &amp;&amp; v2[b] !&#x3D; &#39;.&#39;) b++;&#x2F;&#x2F;j~b-1\n            int x &#x3D; a &#x3D;&#x3D; i ? 0 : stoi(v1.substr(i, a - i));\n            int y &#x3D; b &#x3D;&#x3D; j ? 0 : stoi(v2.substr(j, b - j));\n            if(x &gt; y) return 1;\n            if(x &lt; y) return -1;\n            i &#x3D; a + 1, j &#x3D; b + 1;&#x2F;&#x2F;jump over &#39;.&#39;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n\n\n\n166.分数到小数(有限+无限循环:(循环节)) INT_MIN&#x2F;-1&#x3D;INT_MAX+1 int越界 LL！\n&#x2F;&#x2F;166.分数到小数(有限+无限循环:(循环节)) 无限不循环小数：根号 π e(无穷连分数)\n&#x2F;&#x2F;INT_MIN&#x2F;-1&#x3D;INT_MAX+1 int越界 LL！\nclass Solution &#123;\npublic:\n    string fractionToDecimal(int numerator, int denominator) &#123;\n        typedef long long LL;\n        LL x &#x3D; numerator, y &#x3D; denominator;\n        if (x % y &#x3D;&#x3D; 0) return to_string(x &#x2F; y);\n        string res;\n        if((x &lt; 0) ^ (y &lt; 0)) res +&#x3D; &#39;-&#39;;&#x2F;&#x2F;^:2个有1个满足\n        x &#x3D; abs(x), y &#x3D; abs(y);\n        res +&#x3D; to_string(x &#x2F; y) + &#39;.&#39;, x %&#x3D; y;\n        unordered_map&lt;LL, int&gt; hash;\n        while(x) &#123;&#x2F;&#x2F;余数\n            hash[x] &#x3D; res.size();\n            x *&#x3D; 10;\n            res +&#x3D; to_string(x &#x2F; y), x %&#x3D; y;\n            if(hash.count(x)) &#123;\n                res &#x3D; res.substr(0, hash[x]) + &#39;(&#39; + res.substr(hash[x]) + &#39;)&#39;;\n                break;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n\n167.两数之和 II - 输入有序数组&#x2F;*\n(双指针扫描) O(n)\n用两个指针 i,j 分别从数组首尾往中间扫描，\n每次将 i 后移一位，然后不断前移 j，直到 numbers[i]+numbers[j]≤target 为止。\n如果 numbers[i]+numbers[j]&#x3D;&#x3D;target，则找到了一组方案。\n\nj不回退：单调性 反证 O(n)\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;\n        for(int i &#x3D; 0, j &#x3D; numbers.size() - 1; i &lt; j; i++) &#123;\n            while(i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target) j--;&#x2F;&#x2F;数组有序！\n            if(i &lt; j &amp;&amp; numbers[i] + numbers[j] &#x3D;&#x3D; target) return &#123;i + 1, j + 1&#125;;&#x2F;&#x2F;idx:1~\n        &#125;\n        return &#123;&#125;;\n    &#125;\n&#125;;\n\n\n\n168.Excel表列名称  27-&gt;AA k位的26进制数的第几个（同理：12.int2罗马数字）\n\nclass Solution &#123;\npublic:\n    string convertToTitle(int n) &#123;\n        int k &#x3D; 1;&#x2F;&#x2F;位数\n        for(long long p &#x3D; 26; n &gt; p; p *&#x3D; 26) &#123;\n            n -&#x3D; p;&#x2F;&#x2F;个 十 百 千...\n            k++;\n        &#125;\n        n--;&#x2F;&#x2F;0~\n        string res;\n        while(k--) &#123;&#x2F;&#x2F;k位的26进制数的第几个\n            res +&#x3D; n %26 + &#39;A&#39;;\n            n &#x2F;&#x3D; 26;\n        &#125;\n\n        reverse(res.begin(), res.end());\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n！！！169.多数元素[经典] 摩尔投票算法  求众数 邓P342&#x2F;&#x2F;---169.多数元素[经典！！！] 一半以上的数\n&#x2F;&#x2F;(投票算法) T&#x3D;O(n) S&#x3D;O(1)\nclass Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        int cnt &#x3D; 0, candidate;\n        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            if (!cnt) candidate &#x3D; nums[i];\n            if (candidate &#x3D;&#x3D; nums[i])&#x2F;&#x2F;不是else if,所以上句不用cnt &#x3D; 1;!!!\n                cnt++;\n            else\n                cnt--;\n        &#125;\n        return candidate;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        int r, cnt &#x3D; 0;&#x2F;&#x2F;r：候选 库存\n        for (auto x: nums) &#123;\n            if (!cnt) r &#x3D; x, cnt &#x3D; 1;\n            else if (r &#x3D;&#x3D; x) cnt++;&#x2F;&#x2F;else if!!!\n            else cnt--;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;unordered_map 单次插入和查询的T&#x3D;O(1),故T&#x3D;O(n) S&#x3D;O(n)\nclass Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_map&lt;int, int&gt; hash;\n        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            hash[nums[i]] +&#x3D; 1;\n            if (hash[nums[i]] &gt; nums.size() &#x2F; 2)&#x2F;&#x2F;\n                return nums[i];\n        &#125;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;277&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n170.\n\n\n\n171.Excel表列序号(反168)\nclass Solution &#123;\npublic:\n    int titleToNumber(string s) &#123;\n        int a &#x3D; 0;&#x2F;&#x2F;26+26^2+26^3\n        for(long long i &#x3D; 0, p &#x3D; 26; i &lt; s.size() - 1; i++, p *&#x3D; 26)\n            a +&#x3D; p;\n        \n        int b &#x3D; 0;&#x2F;&#x2F;4位26进制数的第几个\n        for(auto c: s) b &#x3D; b * 26 + c - &#39;A&#39;;\n        return a + b + 1;&#x2F;&#x2F;序号：1~\n    &#125;\n&#125;;\n\n\n\n172.阶乘后的零  经典数论  1~N每个数包含5的个数之和\n&#x2F;*\n蓝书P138阶乘分解   《王道机试指南》里也有\nn!中5的个数(&lt;2的个数)&#x3D;n!中10的个数\n&#x3D;&#x3D; 1~N每个数包含5的个数之和&#x3D;&#x3D;floor(n&#x2F;5)+floor(n&#x2F;5^2)+floor(n&#x2F;5^3)+...\n*&#x2F;\nclass Solution &#123;\npublic:\n    int trailingZeroes(int n) &#123;\n        int res &#x3D; 0;\n        while(n) res +&#x3D; n &#x2F; 5, n &#x2F;&#x3D; 5;\n        return res;\n    &#125;\n&#125;;\n\n\n\n173.\n\n\n\n174.地下城游戏(DP 类似62不同路径 63)\n\n&#x2F;*\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;259&#x2F;\n算法2：DP O(mn)\n状态表示：问什么设什么 f[i][j]&#x3D;从 (i, j) 成功到达终点，(i, j) 处需要具备的最少健康值。  return f[0][0]\n此题不能直接从正向动态规划的原因是不确定起始点的值，但我们可以发现，到终点之后健康值为 1 一定是最优的。\n可以考虑从终点到起点进行动态规划。\n倒推 (~i) &#x3D;&#x3D; (i!&#x3D;-1)  或 i &gt;&#x3D; 0\n    ~(-1)&#x3D;&#x3D;0  负数以其【正值的补码】形式表达：二进制记录负数&#x3D;绝对值取反加1  -1二进制表示: 00000001-&gt;11111110-&gt;11111111\n    f[i][j]+w[i][j] &gt;&#x3D; 1\n*&#x2F;\nclass Solution &#123;\npublic:\n    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; w) &#123;\n        int n &#x3D; w.size(), m &#x3D; w[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, 1e8));\n\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i--)&#x2F;&#x2F;~i\n            for(int j &#x3D; m - 1; j &gt;&#x3D; 0; j--)\n                if(i &#x3D;&#x3D; n- 1 &amp;&amp; j &#x3D;&#x3D; m - 1) f[i][j] &#x3D; max(1, 1 - w[i][j]);&#x2F;&#x2F;f[i][j]+w[i][j] &gt;&#x3D; 1\n                else &#123;\n                    if(i + 1 &lt; n) f[i][j] &#x3D; f[i + 1][j] - w[i][j];\n                    if(j + 1 &lt; m) f[i][j] &#x3D; min(f[i][j], f[i][j + 1] - w[i][j]);\n                    f[i][j] &#x3D; max(1, f[i][j]);&#x2F;&#x2F;\n                &#125;\n        return f[0][0];\n    &#125;\n&#125;;\n\n&#x2F;*\n算法1\n(二分答案 + 动态规划判定) O(mnlogS)\n1.可以看到骑士的起始健康值满足单调性，可以二分这个健康值，找到下界。\n2.二分时，通过动态规划来判定是否可以到达终点。\n3.动态规划的状态表示为 f(i,j) 表示从起点到 (i, j)，所剩下的最大健康值。\n4.初始时 f(0,0)&#x3D;init+dungeon[0][0]，其余为 0。\n5.转移时，若 f(i−1,j)&gt;0，则 f(i,j)&#x3D;max(f(i,j),f(i−1,j)+dungeon[i][j])；若 f(i,j−1)&gt;0，则 f(i,j)&#x3D;max(f(i,j),f(i,j−1))+dungeon[i][j])。\n6.最终判断 f(n, m)\n\n时间复杂度\n二分答案时间复杂度为 O(log⁡S)，S 为答案上限。\n动态规划的状态数为 O(mn)，转移时间为常数，所以每次需要 O(mn) 的时间判定。\n故总时间复杂度为O(mnlog⁡S)。\n\n空间复杂度\n需要额外 O(mn) 的空间存储状态。\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    bool check(int initial, vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;\n        int m &#x3D; dungeon.size(), n &#x3D; dungeon[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(n, 0));\n\n        f[0][0] &#x3D; initial + dungeon[0][0];\n        for (int i &#x3D; 0; i &lt; m; i++)\n            for (int j &#x3D; 0; j &lt; n; j++) &#123;\n                if (i &gt; 0 &amp;&amp; f[i - 1][j] &gt; 0)\n                    f[i][j] &#x3D; max(f[i][j], f[i - 1][j] + dungeon[i][j]);\n\n                if (j &gt; 0 &amp;&amp; f[i][j - 1] &gt; 0)\n                    f[i][j] &#x3D; max(f[i][j], f[i][j - 1] + dungeon[i][j]);\n            &#125;\n\n        return f[m - 1][n - 1] &gt; 0;\n    &#125;\n\n    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;\n        const int INF &#x3D; 1000000000;\n        int l &#x3D; 1, r &#x3D; INF;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (l + r) &gt;&gt; 1;\n            if (check(mid, dungeon)) r &#x3D; mid;\n            else l &#x3D; mid + 1;\n        &#125;\n\n        return l;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;259&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n175.\n\n\n\n176.\n\n\n\n\n\n177.\n\n\n\n178.\n\n\n\n！！！179.最大数 匿名函数重定义sort比较函数a + b &gt; b + a（证明该定义方式可比较：传递性！） 去除前导0，全0留最后一个0\n\n\n重新定义&lt;&#x3D;比较运算符，证明此自定义比较关系可比较！\n什么样的比较关系是能够排序的？全序关系：反对称性&gt;&#x3D;&amp;&amp;&lt;&#x3D; &#x3D;&#x3D;、完全性、传递性【xyz为abc位数】\n    ？还是偏序关系：自反性、反对称性和传递性。 自反性本身也包括了完全性。 所以，全序关系必是偏序关系。\n&#x2F;*\nhttps:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;93757835\n首先，我们将每个整数变成字符串。然后进行排序。\n如果仅按降序排序，有相同的开头数字的时候会出现问题。\n比方说，样例 2 按降序排序得到的数字是 95343303，然而交换 3 和 30 的位置可以得到正确答案 9534330。\n因此，每一对数在排序的比较过程中，我们【比较两种连接顺序】哪一种更好。\n我们可以证明这样的做法是正确的：\n假设（不失一般性），某一对整数 a 和 b，我们的比较结果是 a 应该在 b 前面，这意味着 a ⌢ b &gt; b ⌢ a，其中 ⌢ 表示连接。\n如果排序结果是错的，说明存在一个 c，b 在 c 前面且 c 在 a 的前面。这产生了矛盾，因为 a ⌢ b &gt; b ⌢ a 和 b ⌢ c &gt; c ⌢ b 意味着 a ⌢ c &gt; c ⌢ a。\n换言之，我们的【自定义比较方法保证了传递性，所以这样子排序是对的】。\n\n(贪心，排序) O(nlog⁡n)\n考虑简单的情况，如果只给了两个数字，那么只需要比较两个数字前后的拼接，即可确定顺序。\n扩展到多个数字时，存在偏序关系，即当 A 一定要在 B 前且 B 一定要在 C 前时，A 一定在 C 前。\n所以可以借助这个偏序关系直接对所有数字按照两个数字的情况进行排序。\n注意最后需要【去除前导 0】【特判0】。\n*&#x2F;\nclass Solution &#123;\npublic:\n    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(), nums.end(), [](int x, int y) &#123;\n            string sx &#x3D; to_string(x);\n            string sy &#x3D; to_string(y);\n            return sx + sy &gt; sy + sx;\n        &#125;);\n\n        string ans;\n        for (int i &#x3D; 0; i &lt; nums.size(); i++)\n            ans +&#x3D; to_string(nums[i]);\n\n        for (int i &#x3D; 0; i &lt; ans.length() - 1; i++)\n            if (ans[i] !&#x3D; &#39;0&#39;)\n                return ans.substr(i, ans.length() - i);&#x2F;&#x2F;substr(start,len)\n\n        return ans.substr(ans.length() - 1);&#x2F;&#x2F;0\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;260&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(), nums.end(), [](int x, int y) &#123;\n            string a &#x3D; to_string(x), b &#x3D; to_string(y);\n            return a + b &gt; b + a;\n        &#125;);&#x2F;&#x2F;匿名函数\n\n        string ans;\n        for (auto x: nums) ans +&#x3D; to_string(x);\n        int k &#x3D; 0;\n        while(k + 1 &lt; ans.size() &amp;&amp; ans[k] &#x3D;&#x3D; &#39;0&#39;) k++;&#x2F;&#x2F;去除前导0，全0留最后一个0\n        return ans.substr(k);\n    &#125;\n&#125;;\n\n\n\n\n\n\n180.\n\n\n\n181.\n\n\n\n182.\n\n\n\n183.\n\n\n\n184.\n\n\n\n185.\n\n\n\n186.\n\n\n\n\n\n187.重复的DNA序列 模拟：长度为10，出现次数超过一次&#x2F;&#x2F;187.重复的DNA序列 找出所有目标子串(长度为10，出现次数超过一次)。\n&#x2F;&#x2F;拓展：目标子串的长度为m:用str_hash T&#x3D;O(mn)-&gt;O(m)\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;\n        unordered_map&lt;string, int&gt; cnt;\n        for(int i &#x3D; 0; i + 10 &lt;&#x3D; s.size(); i++)&#x2F;&#x2F;\n            cnt[s.substr(i, 10)]++;\n        vector&lt;string&gt; res;\n        for(auto [s, c]: cnt)\n            if(c &gt; 1) \n                res.push_back(s);\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n188.买卖股票的最佳时机 IV  困难 k次\n&#x2F;&#x2F;188.买卖股票的最佳时机 IV  困难\nclass Solution &#123;\npublic:\n    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;\n        const int INF &#x3D; 1e8;\n        int n &#x3D; prices.size();\n        if (k &gt; n &#x2F; 2) &#123; &#x2F;&#x2F; 等价于可以交易无限次\n            int res &#x3D; 0;\n            &#x2F;&#x2F; 遍历每个买入点\n            for (int i &#x3D; 0; i + 1 &lt; n; i ++ )\n                if (prices[i + 1] &gt; prices[i]) &#x2F;&#x2F; 如果后一天的价格超过当天的价格\n                    res +&#x3D; prices[i + 1] - prices[i];\n            return res;\n        &#125;\n        &#x2F;&#x2F; 初始时所有状态是负无穷，对f和g都是\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(k + 1, -INF));&#x2F;&#x2F;2 滚动\n        auto g &#x3D; f;\n        int res &#x3D; 0;\n        f[0][0] &#x3D; 0; &#x2F;&#x2F; 唯一的边界，也是状态机唯一的入口\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 0; j &lt;&#x3D; k; j ++ ) &#123;&#x2F;&#x2F;&amp;1\n                f[i][j] &#x3D; max(f[i - 1][j], g[i - 1][j] + prices[i - 1]);\n                &#x2F;&#x2F; g[i][j] &#x3D; max(g[i - 1][j], f[i - 1][j - 1] - prices[i - 1]);\n                g[i][j] &#x3D; g[i - 1][j];\n                if (j) g[i][j] &#x3D; max(g[i][j], f[i - 1][j - 1] - prices[i - 1]);\n                res &#x3D; max(res, f[i][j]);\n            &#125;\n        return res;\n    &#125;\n&#125;;\n\n作者：LauZyHou\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;639467&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;*\n注意\nLeetCode增强了本题的数据，非常卡常。\n于是为了应对新数据，对视频中的代码做了如下优化：\n\n1.将vector换成了数组，大概会快50%。\n2.类似于背包问题优化空间，将原本的滚动二维数组(2)(&amp;1)，直接换成一维数组。\n\nj要从0开始:\nf[i,j]表示已经经过i条边，已完成了j圈；\n当j &#x3D;&#x3D; 0时表示没转过1圈，也就没一直没买入过一次，这种情况是存在的，合法的；\n只有不合法的情况会认为不存在，这种状态会被赋值为正负无穷，就是代码里的-0x3f 这个值。\n*&#x2F;\nint f[10001], g[10001];\n\nclass Solution &#123;\npublic:\n    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;\n        int INF &#x3D; 1e8;\n        int n &#x3D; prices.size();\n        if (k &gt; n &#x2F; 2) &#123;\n            int res &#x3D; 0;\n            for (int i &#x3D; 1; i &lt; n; i ++ )\n                if (prices[i] &gt; prices[i - 1])\n                    res +&#x3D; prices[i] - prices[i - 1];\n            return res;\n        &#125;\n        memset(f, -0x3f, sizeof f);\n        memset(g, -0x3f, sizeof g);\n        f[0] &#x3D; 0;\n        int res &#x3D; 0;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; k; j &gt;&#x3D; 0; j -- ) &#123;&#x2F;&#x2F;\n                g[j] &#x3D; max(g[j], f[j] - prices[i - 1]);&#x2F;&#x2F;\n                if (j) f[j] &#x3D; max(f[j], g[j - 1] + prices[i - 1]);&#x2F;&#x2F;\n            &#125;\n        for (int i &#x3D; 1; i &lt;&#x3D; k; i ++ ) res &#x3D; max(res, f[i]);\n        return res;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;417331&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;另 https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;2551&#x2F;1&#x2F;\n\n\n\n\n189.旋转数组 原地class Solution &#123;\npublic:\n    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        k %&#x3D; n;&#x2F;&#x2F;\n        reverse(nums.begin(), nums.end());&#x2F;&#x2F;收尾swap_iter\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    &#125;\n&#125;;\n\n\n\n190.颠倒二进制位 位运算 res &#x3D; (res &lt;&lt; 1) + (n &gt;&gt; i &amp; 1);&#x2F;&#x2F;取n的第k位：n&gt;&gt;k&amp;1\nclass Solution &#123;\npublic:\n    uint32_t reverseBits(uint32_t n) &#123;\n        uint32_t res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; 32; i++)\n            res &#x3D; (res &lt;&lt; 1) + (n &gt;&gt; i &amp; 1);&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n191.位1的个数 lowbit(x)&#x3D;x&amp;-x\n&#x2F;&#x2F;最后一位1：lowbit(x)&#x3D;x&amp;-x&#x3D;x&amp;(~x+1) 树状数组 位运算优化爆搜\nclass Solution &#123;\npublic:\n    uint32_t lowbit(uint32_t x) &#123;\n        return x &amp; -x;\n    &#125;\n    int hammingWeight(uint32_t n) &#123;\n        int cnt &#x3D; 0;\n        while(n) n -&#x3D; lowbit(n), cnt++;\n        return cnt;\n    &#125;\n&#125;;\n\n\n\n\n192.\n\n\n\n193.\n\n\n\n194.\n\n\n\n195.\n\n\n\n196.\n\n\n\n\n\n197.\n\n\n\n198.打家劫舍 DP 不相邻max\nclass Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; f(n + 1), g(n + 1);\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            f[i] &#x3D; g[i - 1] +  nums[i - 1];&#x2F;&#x2F;&#x3D;&#x3D;Wi，nums:0开始\n            g[i] &#x3D; max(f[i - 1], g[i - 1]);\n        &#125;\n        return max(f[n], g[n]);\n    &#125;\n&#125;;\n\n\n\n199. 二叉树的右视图  BFSclass Solution &#123;\npublic:\n    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;\n        queue&lt;TreeNode*&gt; q;\n        vector&lt;int&gt; res;\n        if (!root) return res;\n        q.push(root);\n        while (q.size()) &#123;\n            int len &#x3D; q.size();\n            for (int i &#x3D; 0; i &lt; len; i ++ ) &#123;\n                auto t &#x3D; q.front();\n                q.pop();\n                if (t-&gt;left) q.push(t-&gt;left);\n                if (t-&gt;right) q.push(t-&gt;right);\n                if (i &#x3D;&#x3D; len - 1) res.push_back(t-&gt;val);&#x2F;&#x2F;i &#x3D;&#x3D; len - 1\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n\n200.岛屿数量 floodfill模板题（1的【非斜】连通块数）class Solution &#123;\npublic:\n    vector&lt;vector&lt;char&gt;&gt; g;\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;\n        g &#x3D; grid;&#x2F;&#x2F;\n        int cnt &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; g.size(); i ++ )\n            for (int j &#x3D; 0; j &lt; g[i].size(); j ++ )\n                if (g[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;\n                    dfs(i, j);\n                    cnt ++ ;\n                &#125;\n        return cnt;\n    &#125;\n\n    void dfs(int x, int y) &#123;\n        g[x][y] &#x3D; 0;&#x2F;&#x2F;visited\n        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; g.size() &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; g[a].size() &amp;&amp; g[a][b] &#x3D;&#x3D; &#39;1&#39;)\n                dfs(a, b);\n        &#125;\n    &#125;\n&#125;;\n\n\n\n201. 数字范围按位与    xx(公共前缀)xxx00…0\n\nclass Solution &#123;\npublic:\n    int rangeBitwiseAnd(int m, int n) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;&#x2F;&#x2F;1~2^31 -1\n            if ((m &gt;&gt; i &amp; 1) !&#x3D; (n &gt;&gt; i &amp; 1)) break;\n            if (m &gt;&gt; i &amp; 1) res +&#x3D; 1 &lt;&lt; i;&#x2F;&#x2F;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n202.快乐数（141 环形链表） 1步2步，相遇则有环&#x2F;&#x2F;抽屉原理：0&lt;&#x3D;x&lt;&#x3D;810,&gt;812步，一定入圈\nclass Solution &#123;\npublic:\n    int get(int x) &#123;&#x2F;&#x2F;各位平方和，&lt;810&#x3D;9^2 * 10,唯一：不会分叉\n        int res &#x3D; 0;\n        while (x) &#123;\n            res +&#x3D; (x % 10) * (x % 10);\n            x &#x2F;&#x3D; 10;\n        &#125;\n        return res;\n    &#125;\n\n    bool isHappy(int n) &#123;\n        int fast &#x3D; get(n), slow &#x3D; n;&#x2F;&#x2F;\n        while (fast !&#x3D; slow) &#123;\n            fast &#x3D; get(get(fast));\n            slow &#x3D; get(slow);\n        &#125;\n        return fast &#x3D;&#x3D; 1;&#x2F;&#x2F;\n    &#125;\n&#125;;\n\n\n\n\n203. 移除链表元素\nclass Solution &#123;\npublic:\n    ListNode* removeElements(ListNode* head, int val) &#123;\n        auto dummy &#x3D; new ListNode(-1);\n        dummy-&gt;next &#x3D; head;\n        for(auto p &#x3D; dummy; p; p &#x3D; p-&gt;next) &#123;\n            auto q &#x3D; p-&gt;next;\n            while(q &amp;&amp; q-&gt;val &#x3D;&#x3D; val) q &#x3D; q-&gt;next;\n            p-&gt;next &#x3D; q;\n        &#125;\n        return dummy-&gt;next;\n    &#125;\n&#125;;\n\n\n\n\n\n204.计数质数(&lt;n)   线性筛素数O(n)模板题      if (i % primes[j] &#x3D;&#x3D; 0) break;&#x2F;&#x2F;204.计数质数(&lt;n)   线性筛法模板题\n&#x2F;*\n时间复杂度为O(N^0.75)的解法, 击败99.67%\nhttps:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;count-primes&#x2F;solution&#x2F;shi-jian-fu-za-du-wei-on075de-jie-fa-ji-9qmi6&#x2F;\nProjectEuler题解（更新到100题）\nhttps:&#x2F;&#x2F;github.com&#x2F;cloudzfy&#x2F;euler\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;metaquant&#x2F;article&#x2F;details&#x2F;114299146?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control\n欧拉计划中文题解站\nhttps:&#x2F;&#x2F;pe.metaquant.org&#x2F;index.html\n*&#x2F;\n&#x2F;*\n&#x2F;&#x2F;Acwing868：筛质数     线性筛素数O(n)\n算法流程：\n\n从小到大枚举每个数 i；\n如果 i 没有被标记，将 i 加入质数集合；\n对于每个 i，从小到大枚举已有的质数 primej，将 i∗primej 标记成合数。如果 i 能整除 primej，则直接break。\n下面证明该算法是正确的，且时间复杂度是线性的：\n\n首先，质数一定不是其它质数的倍数，所以质数一定会被找出来。然后我们证明，每个合数一定会被它的最小质因子标记，且只会被它的最小值因子标记，\n从而每个合数只会被标记一次，所以时间复杂度是线性的。\n\n我们先来证明每个合数可以被它的最小质因子标记：\n假设某个合数是 x，它的最小质因子是 p，令i&#x3D;x&#x2F;p，则 i 的所有质因子一定大于等于 p，\n所以当算法的第一层循环枚举到 i后，我们从小到大枚举质数时，i 一定不能整除比 p 小的质数，所以一定可以枚举到质数 p，从而可以把 x&#x3D;i∗p 标记为合数。\n\n然后我们证明每个合数仅会被它的最小质因子标记：\n假设某个合数是 x，它的某个非最小的质因子是 p，令 i&#x3D;x&#x2F;p，则 i 包含 x 的最小质因子，从而 i 存在某个质因子比 p 小。\n所以当算法的第一层循环枚举到 i 时，第二层循环枚举到 i 的最小质因子后会直接break，不会枚举 p，所以 x 一定不会被非最小的质因子标记。\n\n证毕。\n\n时间复杂度分析：每个合数仅会被它的最小质因子标记，所以每个合数只被标记1次，所以时间复杂度是 O(n)。\n\n*&#x2F;\nclass Solution &#123;\npublic:\n    int countPrimes(int n) &#123;\n        vector&lt;int&gt; primes;\n        vector&lt;bool&gt; st(n + 1);\n        for (int i &#x3D; 2; i &lt; n; i ++ )\n        &#123;\n            if (!st[i]) primes.push_back(i);\n            for (int j &#x3D; 0; i * primes[j] &lt; n; j ++ )&#x2F;&#x2F;用最小质因子Pj标记合数(i*Pj) &lt;n\n            &#123;\n                st[i * primes[j]] &#x3D; true;\n                if (i % primes[j] &#x3D;&#x3D; 0) break;&#x2F;&#x2F;枚举到 i 的最小质因子 Pj 后会直接break\n            &#125;\n        &#125;\n        return primes.size();\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;314&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n205.同构字符串 字符替换(单射：一一对应) unordered_map:s&lt;–&gt;tclass Solution &#123;\npublic:\n    bool isIsomorphic(string s, string t) &#123;\n        &#x2F;&#x2F;if(s.size() !&#x3D; t.size()) return false;\n        unordered_map&lt;char, char&gt; st, ts;\n        for(int i &#x3D; 0; i &lt; s.size(); i++)\n        &#123;\n            int a &#x3D; s[i], b &#x3D; t[i];\n            if(st.count(a) &amp;&amp; st[a] !&#x3D; b) return false;&#x2F;&#x2F;\n            st[a] &#x3D; b;&#x2F;&#x2F;\n            if(ts.count(b) &amp;&amp; ts[b] !&#x3D; a) return false;\n            ts[b] &#x3D; a;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n\n\n\n206.反转链表-&gt;92.II迭代    经典&#x2F;&#x2F;迭代\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode *prev &#x3D; nullptr;&#x2F;&#x2F;\n        ListNode *cur &#x3D; head;\n        while (cur)\n        &#123;\n            ListNode *next &#x3D; cur-&gt;next;\n            cur-&gt;next &#x3D; prev;\n            prev &#x3D; cur, cur &#x3D; next;\n        &#125;\n        return prev;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;递归\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        if (!head || !head-&gt;next) return head;\n        ListNode *tail &#x3D; reverseList(head-&gt;next);\n        head-&gt;next-&gt;next &#x3D; head;&#x2F;&#x2F;\n        head-&gt;next &#x3D; nullptr;&#x2F;&#x2F;\n        return tail;\n    &#125;\n&#125;;\n\n\n\n\n207.课程表 拓扑排序:d[u]&#x3D;0入队class Solution &#123;\npublic:\n    bool canFinish(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n        vector&lt;vector&lt;int&gt;&gt; g(n);&#x2F;&#x2F;邻接表：后继节点\n        vector&lt;int&gt; d(n);\n        for(auto&amp; e: edges) &#123;\n            int b &#x3D; e[0], a &#x3D; e[1];\n            g[a].push_back(b);&#x2F;&#x2F;a-&gt;b\n            d[b]++;\n        &#125;\n        queue&lt;int&gt; q;\n        for(int i &#x3D; 0; i &lt; n; i++)\n            if(d[i] &#x3D;&#x3D; 0) q.push(i);\n\n        int cnt &#x3D; 0;\n        while(q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            cnt++;\n            for(auto i : g[t])\n                if(--d[i] &#x3D;&#x3D; 0) q.push(i);\n        &#125;\n        return cnt &#x3D;&#x3D; n;&#x2F;&#x2F;\n    &#125;\n&#125;;\n\n\n\n208.实现Trie（前缀树）字典树class Trie &#123;\npublic:\n    struct Node &#123;\n        bool is_end;\n        Node *son[26];\n        Node() &#123;\n            is_end &#x3D; false;\n            for(int i &#x3D; 0; i &lt; 26; i++)\n                son[i] &#x3D; NULL;\n        &#125;\n    &#125;*root;\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    Trie() &#123;\n        root &#x3D; new Node();\n    &#125;\n    \n    &#x2F;** Inserts a word into the trie. *&#x2F;\n    void insert(string word) &#123;\n        auto p &#x3D; root;\n        for(auto c: word) &#123;\n            int u &#x3D; c - &#39;a&#39;;&#x2F;&#x2F;cur_idx\n            if(!p-&gt;son[u]) p-&gt;son[u] &#x3D; new Node();&#x2F;&#x2F;\n            p &#x3D; p-&gt;son[u]; \n        &#125;\n        p-&gt;is_end &#x3D; true;&#x2F;&#x2F;\n    &#125;\n    \n    &#x2F;** Returns if the word is in the trie. *&#x2F;\n    bool search(string word) &#123;\n        auto p &#x3D; root;\n        for(auto c: word) &#123;\n            int u &#x3D; c - &#39;a&#39;;&#x2F;&#x2F;cur_idx\n            if(!p-&gt;son[u]) return false;\n            p &#x3D; p-&gt;son[u]; \n        &#125;\n        return p-&gt;is_end;&#x2F;&#x2F;\n    &#125;\n    \n    &#x2F;** Returns if there is any word in the trie that starts with the given prefix. *&#x2F;\n    bool startsWith(string prefix) &#123;\n        auto p &#x3D; root;\n        for(auto c: prefix) &#123;\n            int u &#x3D; c - &#39;a&#39;;&#x2F;&#x2F;cur_idx\n            if(!p-&gt;son[u]) return false;\n            p &#x3D; p-&gt;son[u]; \n        &#125;\n        return true;&#x2F;&#x2F;\n    &#125;\n&#125;;\n&#x2F;&#x2F;delete words: mark p-&gt;is_end&#x3D;false;\n\n\n\n\n209.长度最小的子数组(正整数 &gt;&#x3D;sum) 双指针  while(sum - nums[j] &gt;&#x3D; s) sum -&#x3D; nums[j++];&#x2F;&#x2F;探地雷 j单调性证明\n\nclass Solution &#123;\npublic:\n    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; INT_MAX;\n        for(int i &#x3D; 0, j &#x3D; 0, sum &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            sum +&#x3D; nums[i];&#x2F;&#x2F;i\n            while(sum - nums[j] &gt;&#x3D; s) sum -&#x3D; nums[j++];&#x2F;&#x2F;探地雷 j\n            if(sum &gt;&#x3D; s) res &#x3D; min(res, i - j + 1);&#x2F;&#x2F;res\n        &#125;\n        if(res &#x3D;&#x3D; INT_MAX) res &#x3D; 0;\n        return res;\n    &#125;\n&#125;;\n\n\n\n210.课程表II 存单caseclass Solution &#123;\npublic:\n    vector&lt;int&gt; findOrder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n        vector&lt;vector&lt;int&gt;&gt; g(n);&#x2F;&#x2F;邻接表：后继节点\n        vector&lt;int&gt; d(n);\n        for(auto&amp; e: edges) &#123;\n            int b &#x3D; e[0], a &#x3D; e[1];&#x2F;&#x2F;b&lt;-a\n            g[a].push_back(b);&#x2F;&#x2F;a-&gt;b\n            d[b]++;\n        &#125;\n        queue&lt;int&gt; q;\n        for(int i &#x3D; 0; i &lt; n; i++)\n            if(d[i] &#x3D;&#x3D; 0) q.push(i);\n\n        vector&lt;int&gt; res;\n        while(q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            res.push_back(t);\n            for(int i : g[t])\n                if(--d[i] &#x3D;&#x3D; 0) q.push(i);\n        &#125;\n        if(res.size() &lt; n) res &#x3D; &#123;&#125;;&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n211.添加与搜索单词-数据结构设计 [正则 ]不重复 搜Trie:O(nL) &lt;&lt; 26^k&#x2F;&#x2F;211.添加与搜索单词-数据结构设计 [正则 ]不重复 搜Trie:O(nL) &lt;&lt; 26^k\n&#x2F;&#x2F;时间复杂度分析：假设单词的平均长度是 L，总共有 n 个单词。add操作会遍历 L 个节点，\n&#x2F;&#x2F;所以时间复杂度是 O(L)；search操作最坏情况下会遍历所有节点，所以时间复杂度是 O(nL)。\nclass WordDictionary &#123;\npublic:\n    struct Node &#123;\n        bool is_end;\n        Node *son[26];\n        Node() &#123;\n            is_end &#x3D; false;\n            for (int i &#x3D; 0; i &lt; 26; i ++ )\n                son[i] &#x3D; NULL;&#x2F;&#x2F;0\n        &#125;\n    &#125;*root;\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    WordDictionary() &#123;\n        root &#x3D; new Node();\n    &#125;\n\n    &#x2F;** Adds a word into the data structure. *&#x2F;\n    void addWord(string word) &#123;\n        Node *p &#x3D; root;\n        for (char c : word) &#123;\n            int u &#x3D; c - &#39;a&#39;;\n            if (!p-&gt;son[u]) p-&gt;son[u] &#x3D; new Node();\n            p &#x3D; p-&gt;son[u];\n        &#125;\n        p-&gt;is_end &#x3D; true;\n    &#125;\n\n    &#x2F;** Returns if the word is in the data structure. A word could contain the dot character &#39;.&#39; to represent any one letter. *&#x2F;\n    &#x2F;*\n    bool search(string word) &#123;\n        return dfs(root, word, 0);\n    &#125;\n\n    bool dfs(Node* p, string&amp; word, int i) &#123;\n        if (i &#x3D;&#x3D; word.size()) return p-&gt;is_end;\n        if (word[i] !&#x3D; &#39;.&#39;) &#123;\n        \tint u &#x3D; word[i] - &#39;a&#39;;\n        \tif(!p-&gt;son[u]) return false;&#x2F;&#x2F;\n            return dfs(p-&gt;son[u], word, i + 1);&#x2F;&#x2F;\n        &#125; else &#123;\n            for (int j &#x3D; 0; j &lt; 26; j ++ )\n                if (p-&gt;son[j] &amp;&amp; dfs(p-&gt;son[j], word, i + 1))\n                \treturn true;\n                return false;\n        &#125;\n    &#125;\n    *&#x2F;\n    bool search(string word) &#123;\n        return dfs(word, 0, root);\n    &#125;\n\n    bool dfs(string &amp;word, int k, Node *u)\n    &#123;\n        if (k &#x3D;&#x3D; word.size()) return u-&gt;is_end;\n        if (word[k] !&#x3D; &#39;.&#39;)\n        &#123;\n            if (u-&gt;son[word[k] - &#39;a&#39;]) return dfs(word, k + 1, u-&gt;son[word[k] - &#39;a&#39;]);&#x2F;&#x2F;\n        &#125;\n        else\n        &#123;\n            for (int i &#x3D; 0; i &lt; 26; i ++ )\n                if (u-&gt;son[i])\n                &#123;\n                    if (dfs(word, k + 1, u-&gt;son[i])) return true;\n                &#125;\n        &#125;\n        return false;&#x2F;&#x2F;\n    &#125;\n\n&#125;;\n\n\n\n\n212.单词搜索II(DFS+Trie)  words列表 入Trie，存idx用于输出\n&#x2F;&#x2F;212.单词搜索II words列表 入Trie，存idx用于输出\n&#x2F;&#x2F;“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。\nclass Solution &#123;\npublic:\n    struct Node &#123;\n        int id;\n        Node *son[26];\n        Node() &#123;\n            id &#x3D; -1;\n            for (int i &#x3D; 0; i &lt; 26; i ++ ) son[i] &#x3D; NULL;\n        &#125;\n    &#125;*root;\n\n    unordered_set&lt;int&gt; ids;&#x2F;&#x2F;判重\n    vector&lt;vector&lt;char&gt;&gt; g;\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    void insert(string&amp; word, int id) &#123;\n        auto p &#x3D; root;\n        for (auto c: word) &#123;\n            int u &#x3D; c - &#39;a&#39;;\n            if (!p-&gt;son[u]) p-&gt;son[u] &#x3D; new Node();\n            p &#x3D; p-&gt;son[u];\n        &#125;\n        p-&gt;id &#x3D; id;&#x2F;&#x2F;\n    &#125;\n\n    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123;\n        g &#x3D; board;\n        root &#x3D; new Node();\n        for (int i &#x3D; 0; i &lt; words.size(); i ++ ) insert(words[i], i);&#x2F;&#x2F;build Trie\n\n        for (int i &#x3D; 0; i &lt; g.size(); i ++ )\n            for (int j &#x3D; 0; j &lt; g[i].size(); j ++ ) &#123;\n                int u &#x3D; g[i][j] - &#39;a&#39;;\n                if (root-&gt;son[u]) dfs(i, j, root-&gt;son[u]);&#x2F;&#x2F;\n            &#125;\n\n        vector&lt;string&gt; res;\n        for (auto id: ids) res.push_back(words[id]);&#x2F;&#x2F;\n        return res;\n    &#125;\n\n    void dfs(int x, int y, Node* p) &#123;\n        if (p-&gt;id !&#x3D; -1) ids.insert(p-&gt;id);&#x2F;&#x2F;\n        char t &#x3D; g[x][y];\n        g[x][y] &#x3D; &#39;.&#39;;&#x2F;&#x2F;标记\n        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; g.size() &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; g[0].size() &amp;&amp; g[a][b] !&#x3D; &#39;.&#39;) &#123;\n                int u &#x3D; g[a][b] - &#39;a&#39;;\n                if (p-&gt;son[u]) dfs(a, b, p-&gt;son[u]);&#x2F;&#x2F;\n            &#125;\n        &#125;\n        g[x][y] &#x3D; t;&#x2F;&#x2F;恢复\n    &#125;\n&#125;;\n\n\n\n\n213.打家劫舍II（198） 围成一圈~\nclass Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (!n) return 0;\n        if (n &#x3D;&#x3D; 1) return nums[0];&#x2F;&#x2F;如果不特判：g[1] &#x3D; INT_MIN;\n        vector&lt;int&gt; f(n + 1), g(n + 1);\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ ) &#123;&#x2F;&#x2F;不选0号\n            f[i] &#x3D; g[i - 1] + nums[i - 1];&#x2F;&#x2F;nums从0开始\n            g[i] &#x3D; max(f[i - 1], g[i - 1]);\n        &#125;\n        int res &#x3D; max(f[n], g[n]);\n        &#x2F;&#x2F;选0号\n        f[1] &#x3D; nums[0];\n        g[1] &#x3D; INT_MIN;&#x2F;&#x2F;非法状态，负无穷\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ ) &#123;\n            f[i] &#x3D; g[i - 1] + nums[i - 1];\n            g[i] &#x3D; max(f[i - 1], g[i - 1]);\n        &#125;\n\n        return max(res, g[n]);\n    &#125;\n&#125;;\n\n\n另\n???\n根据闫氏DP分析法则中的不重不漏原则，由于情况1和2已经把情况3包含其中，所以我们只需要对情况1和情况2进行分析即可。\n我们的算法思路是分别从前往后和从后往前进行两次DP，区间分别为1 ~ n - 1 和 n ~ 2\n????????????????????????????\n\nclass Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (nums.empty()) return 0;\n        if (n &#x3D;&#x3D; 1) return nums[0];\n\n        vector&lt;int&gt; f(n + 1, 0), g(n + 1, 0);\n        f[1] &#x3D; nums[0];\n        for (int i &#x3D; 2; i &lt;&#x3D; n - 1; i ++)\n            f[i] &#x3D; max(f[i - 1], f[i - 2] + nums[i - 1]);\n\n        g[n - 1] &#x3D; nums[n - 1];\n        for (int i &#x3D; n - 2; i ; i --)\n            g[i] &#x3D; max(g[i + 1], g[i + 2] + nums[i]);\n\n        return max(f[n -1], g[1]);\n    &#125;\n&#125;;\n\n作者：Roger_3\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;14315&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n214.最短回文串 前面添加字符将其转换 &#x3D;&#x3D;find原串max_prefix回文串idx &#x3D;&#x3D; 构造串KMP_next[end]    难\n&#x2F;&#x2F;214.最短回文串 前面添加字符将其转换\n&#x2F;&#x2F;&#x3D;&#x3D;find原串max_prefix回文串idx &#x3D;&#x3D; 构造串KMP_next[end]\nclass Solution &#123;\npublic:\n    string shortestPalindrome(string s) &#123;\n        string t(s.rbegin(), s.rend());&#x2F;&#x2F;\n        int n &#x3D; s.size();\n        s &#x3D; &#39; &#39; + s + &#39;#&#39; + t; &#x2F;&#x2F;KMP从1开始\n        vector&lt;int&gt; ne(n * 2 + 2);\n        for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n * 2 + 1; i ++ ) &#123;&#x2F;&#x2F;KMP_next模板！！背！！\n            while (j &amp;&amp; s[i] !&#x3D; s[j + 1]) j &#x3D; ne[j];&#x2F;&#x2F;j: 1开始\n            if (s[i] &#x3D;&#x3D; s[j + 1]) j ++ ;\n            ne[i] &#x3D; j;\n        &#125;\n        int len &#x3D; ne[n * 2 + 1];&#x2F;&#x2F;原串max_prefix回文串idx &#x3D;&#x3D; 构造串KMP_next[end]\n        string left &#x3D; s.substr(1, len), right &#x3D; s.substr(1 + len, n - len);\n        return string(right.rbegin(), right.rend()) + left + right;\n    &#125;\n&#125;;\n\n\n\n!!![法二code有问题！]—215.数组中的第K个最大元素  BFPRT：快排最坏复杂度降至O(n) medianOfMedians 找居中 pivot！！！\n&#x2F;*\n拓：topK\nBFPRT O(n)：medianOfMedians 找居中 pivot\n\nhttps:&#x2F;&#x2F;ljt12138.github.io&#x2F;2019&#x2F;12&#x2F;01&#x2F;k-sorter-problem&#x2F;\n邓dsa quickselection 基于快速划分的k选取算法\n\nhttps:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;128524579\n*&#x2F;\n&#x2F;&#x2F;215.数组中的第K个最大元素 快速选择算法Acwing786\n&#x2F;&#x2F;法一\n&#x2F;&#x2F;idea from  https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;acwing&#x2F;content&#x2F;4502&#x2F;\n&#x2F;&#x2F;每次只需要判断[k在左区间还是右区间，一直递归查找k所在区间]\n&#x2F;&#x2F;最后只剩一个数时，只会有数组[k]一个数，返回数组[k]的值就是答案\nclass Solution &#123;\npublic:\n\n    int quick_sort(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123;\n        if (l &#x3D;&#x3D; r) return nums[k];\n        int x &#x3D; nums[l], i &#x3D; l - 1, j &#x3D; r + 1;&#x2F;&#x2F;-1 +1\n        while (i &lt; j) &#123;&#x2F;&#x2F;降序\n            do i ++ ; while (nums[i] &gt; x);&#x2F;&#x2F;&#x3D;&#x3D;  while(nums[++i] &gt; x);\n            do j -- ; while (nums[j] &lt; x);\n            if (i &lt; j) swap(nums[i], nums[j]);\n        &#125;\n        if (k &lt;&#x3D; j) return quick_sort(nums, l, j, k);&#x2F;&#x2F;k &lt;&#x3D; j ！！！\n        else return quick_sort(nums, j + 1, r, k);&#x2F;&#x2F;第k大在R中继续找\n    &#125;\n\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        return quick_sort(nums, 0, nums.size() - 1, k - 1);&#x2F;&#x2F;k从0开始\n    &#125;\n&#125;;\n&#x2F;&#x2F;另 https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;273&#x2F;\n\n\n&#x2F;&#x2F;法二 ？？？[3,2,3,1,2,4,5,5,6] 4--&gt;4  out:5???\n&#x2F;&#x2F;idea from https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;7585&#x2F;\nclass Solution &#123;\npublic:\n\n    int quick_sort(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123;\n        if (l &#x3D;&#x3D; r) return nums[k];\n        int x &#x3D; nums[l], i &#x3D; l - 1, j &#x3D; r + 1;&#x2F;&#x2F;-1 +1\n        while (i &lt; j) &#123;&#x2F;&#x2F;降序\n            do i ++ ; while (nums[i] &gt; x);&#x2F;&#x2F;&#x3D;&#x3D;  while(nums[++i] &gt; x);\n            do j -- ; while (nums[j] &lt; x);\n            if (i &lt; j) swap(nums[i], nums[j]);\n        &#125;\n        &#x2F;*\n        cout &lt;&lt; j;\n        for(auto x: nums)\n            cout &lt;&lt; x &lt;&lt; &#39; &#39;;\n        cout &lt;&lt; endl;\n        *&#x2F;\n        int s1 &#x3D; j - l + 1;\n        if (k &lt;&#x3D; s1) return quick_sort(nums, l, j, k);&#x2F;&#x2F;k &lt;&#x3D; s1 ！！！\n        else return quick_sort(nums, j + 1, r, k - s1);&#x2F;&#x2F;R中第k-s1大\n    &#125;\n\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        return quick_sort(nums, 0, nums.size() - 1, k - 1);&#x2F;&#x2F;k从0开始\n    &#125;\n&#125;;\n\n&#x2F;*\n(分治) 同上\n题解1:分治。\n借用快速排序的思想，第k大等于找第n - k + 1小的数。这里我们以找第k小为例，我们每次取区间头元素作为基准元素pivot，\n然后将区间内所有小于这个数的数字都放在基准元素之前，所有大于这个数的数字都放在基准元素之后。\n如果基准元素左边的数字个数len大于等于k，那么我们就去左边区间找第k小；如果基准元素恰好是第k小的，那么返回基准元素；\n否则我们去右半区间找到第k - len - 1小的元素。\n\n仅进入一侧递归在平均情况下数组长度会减半，故时间复杂度为 n+n&#x2F;2+n&#x2F;4+…+1&#x3D;O(n)n+n&#x2F;2+n&#x2F;4+…+1&#x3D;O(n)。\n*&#x2F;\n&#x2F;&#x2F;24ms\nclass Solution &#123;\npublic:\n    int getKth(vector&lt;int&gt;&amp;nums,int k,int l,int r)\n    &#123;\n        if(l &#x3D;&#x3D; r) return nums[l];\n        int pivot &#x3D; nums[l],i &#x3D; l , j &#x3D; r;\n        while(i &lt; j)\n        &#123;\n            while(i &lt; j &amp;&amp; nums[j] &gt;&#x3D; pivot) j --;\n            while(i &lt; j &amp;&amp; nums[i] &lt;&#x3D; pivot) i ++;\n            if(i &lt; j)\n                swap(nums[i],nums[j]);\n        &#125;\n        swap(nums[i],nums[l]);\n        if(i - l &gt;&#x3D; k) return getKth(nums,k,l, i - 1);&#x2F;&#x2F;\n        else if(i - l + 1 &#x3D;&#x3D; k) return nums[i];\n        else return getKth(nums,k - (i - l  + 1),i + 1,r);&#x2F;&#x2F;\n    &#125;\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        return getKth(nums, nums.size() - k + 1, 0 , nums.size() - 1);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;法三\n&#x2F;&#x2F;当然了，c++提供了nth_element函数，让我们把第k大&#x2F;小的元素（下标从0开始）放在对应的位置上，同时把小于该元素的元素都放在左边，大于该元素的元素都放在右边。\n&#x2F;&#x2F; 4ms\nclass Solution &#123;\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        nth_element(nums.begin(),nums.begin() + k - 1, nums.end(),greater&lt;int&gt;());\n        return nums[k - 1];\n    &#125;\n&#125;;\n\n作者：T-SHLoRk\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;4455&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n&#x2F;&#x2F;法四\n&#x2F;*\n(扫描一遍 维护一个小根堆） O(n∗logk)\n遍历数组，维护一个【大小为K的小根堆】\n为什么是小根堆，【堆顶元素是堆中最小，那么还在堆中的都比它大，没在堆内的都比它小。\n堆中有k个元素，那么他自然就是第K的最大元素了】\n找最大，用小根\n值得注意的是优先队列默认的是大根堆，所以声明的时候注意参数。\n\n时间复杂度 ： 线性扫描 O(n∗logk)\n空间复杂度 ： 额外的小根堆 O(k)\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;  &#x2F;&#x2F;小顶堆\n        for(auto x : nums)\n        &#123;\n            q.push(x);\n            if(q.size() &gt; k) q.pop();\n        &#125;\n        return q.top();\n    &#125;\n&#125;;\n\n作者：jasonlin\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;10789&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n—线性查找算法BFPRT小专题https:&#x2F;&#x2F;blog.csdn.net&#x2F;u012469528&#x2F;article&#x2F;details&#x2F;80762068\n&#x2F;**\n* BFPRT算法（前K小数问题）\n*\n* author    刘毅（Limer）\n* date      2017-01-25\n* mode      C++\n*&#x2F;\n \n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n \nint InsertSort(int  array[], int left, int right);                 &#x2F;&#x2F;插入排序，返回中位数下标\nint GetPivotIndex(int  array[], int left, int right);              &#x2F;&#x2F;返回中位数的中位数下标\nint Partition(int array[], int left, int right, int pivot_index);  &#x2F;&#x2F;利用中位数的中位数的下标进行划分，返回分界线下标\nint BFPRT(int array[], int left, int right, const int &amp; k);        &#x2F;&#x2F;求第k小，返回其位置的下标\n \nint main()\n&#123;\n    int k &#x3D; 5;\n    int array[10] &#x3D; &#123; 1,1,2,3,1,5,-1,7,8,-10 &#125;;\n \n    cout &lt;&lt; &quot;原数组：&quot;;\n    for (int i &#x3D; 0; i &lt; 10; i++)\n        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;第&quot; &lt;&lt; k &lt;&lt; &quot;小值为：&quot; &lt;&lt; array[BFPRT(array, 0, 9, k)] &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;变换后的数组：&quot;;\n    for (int i &#x3D; 0; i &lt; 10; i++)\n        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; endl;\n \n    return 0;\n&#125;\n \n&#x2F;* 插入排序，返回中位数下标 *&#x2F;\nint InsertSort(int array[], int left, int right)\n&#123;\n    int temp;\n    int j;\n    for (int i &#x3D; left + 1; i &lt;&#x3D; right; i++)\n    &#123;\n        temp &#x3D; array[i];\n        j &#x3D; i - 1;\n        while (j &gt;&#x3D; left &amp;&amp; array[j] &gt; temp)\n            array[j + 1] &#x3D; array[j--];\n        array[j + 1] &#x3D; temp;\n    &#125;\n \n    return ((right - left) &gt;&gt; 1) + left;\n&#125;\n \n&#x2F;* 返回中位数的中位数下标 *&#x2F;\nint GetPivotIndex(int array[], int left, int right)\n&#123;\n    if (right - left &lt; 5)\n        return InsertSort(array, left, right);\n \n    int sub_right &#x3D; left - 1;\n    for (int i &#x3D; left; i + 4 &lt;&#x3D; right; i +&#x3D; 5)\n    &#123;\n        int index &#x3D; InsertSort(array, i, i + 4);  &#x2F;&#x2F;找到五个元素的中位数的下标\n        swap(array[++sub_right], array[index]);   &#x2F;&#x2F;依次放在左侧\n    &#125;\n \n    return BFPRT(array, left, sub_right, ((sub_right - left + 1) &gt;&gt; 1) + 1);\n&#125;\n \n&#x2F;* 利用中位数的中位数的下标进行划分，返回分界线下标 *&#x2F;\nint Partition(int array[], int left, int right, int pivot_index)\n&#123;\n    swap(array[pivot_index], array[right]);  &#x2F;&#x2F;把基准放置于末尾\n \n    int divide_index &#x3D; left;  &#x2F;&#x2F;跟踪划分的分界线\n    for (int i &#x3D; left; i &lt; right; i++)\n    &#123;\n        if (array[i] &lt; array[right])\n            swap(array[divide_index++], array[i]);  &#x2F;&#x2F;比基准小的都放在左侧\n    &#125;\n \n    swap(array[divide_index], array[right]);  &#x2F;&#x2F;最后把基准换回来\n    return divide_index;\n&#125;\n \nint BFPRT(int array[], int left, int right, const int &amp; k)\n&#123;\n    int pivot_index &#x3D; GetPivotIndex(array, left, right);            &#x2F;&#x2F;得到中位数的中位数下标\n    int divide_index &#x3D; Partition(array, left, right, pivot_index);  &#x2F;&#x2F;进行划分，返回划分边界\n    int num &#x3D; divide_index - left + 1;\n    if (num &#x3D;&#x3D; k)\n        return divide_index;\n    else if (num &gt; k)\n        return BFPRT(array, left, divide_index - 1, k);\n    else\n        return BFPRT(array, divide_index + 1, right, k - num);\n&#125;\n\n\nBFPRT Java代码\nhttps:&#x2F;&#x2F;www.pianshen.com&#x2F;article&#x2F;390013042&#x2F;\n\n\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;5402&#x2F;\n\n\n\n\n216.组合总和III&#x2F;&#x2F;T&#x3D;k*C(k,9)\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    vector&lt;int&gt; path;\n\n    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;\n        dfs(1, n, k);\n        return ans;\n    &#125;\n\n    void dfs(int start, int n, int k) &#123;&#x2F;&#x2F;start~9 防止重复\n        if(!n) &#123;\n            if(!k) ans.push_back(path);\n        &#125; else if(k) &#123;\n            for(int i &#x3D; start; i &lt;&#x3D; 9; i++)&#x2F;&#x2F;\n                if(n &gt;&#x3D; i) &#123;\n                    path.push_back(i);\n                    dfs(i + 1, n - i, k - 1);&#x2F;&#x2F;min\n                    path.pop_back();\n                &#125;\n        &#125; &#x2F;&#x2F; else 不合法\n    &#125;\n&#125;;\n\n\n\n\n\n217.存在重复元素 unordered_set count insert&#x2F;&#x2F;217.存在重复元素 unordered_set count insert\nclass Solution &#123;\npublic:\n    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;int&gt; S;\n        for(auto x: nums)\n            if(S.count(x)) return true;\n            else S.insert(x);\n        return false;\n    &#125;\n&#125;;\n\n\n\n\n218.天际线问题 扫描线求轮廓 细节太多\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;2599&#x2F;1&#x2F;\n&#x2F;&#x2F;Acwing247亚特兰蒂斯 扫描线+求面积SegTree\n&#x2F;&#x2F;长条内max高度h，有+h&gt;max(入点)有-h&gt;max(出点)，堆不能删，用multiset，支持排序（java：TreeSet）\n&#x2F;&#x2F;vector&lt;pair&lt;int, int&gt;&gt; points;双关键字排序，&#123;L,-h&#125; &#123;R,h&#125; 保证正确的遍历顺序\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        vector&lt;pair&lt;int, int&gt;&gt; points;\n        multiset&lt;int&gt; heights;  &#x2F;&#x2F; *heights.rbegin()\n        for (auto&amp; b: buildings) &#123;\n            points.push_back(&#123;b[0], -b[2]&#125;);\n            points.push_back(&#123;b[1], b[2]&#125;);\n        &#125;\n        sort(points.begin(), points.end());\n        heights.insert(0);\n        for (auto&amp; p: points) &#123;  &#x2F;&#x2F; 注意+—顺序\n            int x &#x3D; p.first, h &#x3D; abs(p.second);\n            if (p.second &lt; 0) &#123;  &#x2F;&#x2F; 左端点\n                if (h &gt; *heights.rbegin())\n                    res.push_back(&#123;x, h&#125;);\n                heights.insert(h);\n            &#125; else &#123;  &#x2F;&#x2F; 右端点\n                heights.erase(heights.find(h));  &#x2F;&#x2F; 多删一，erase全删！\n                if (h &gt; *heights.rbegin()) \n                    res.push_back(&#123;x, *heights.rbegin()&#125;);\n            &#125;\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n\n\n219.存在重复元素 II(间隔&lt;&#x3D;k) unordered_map{val, idx}class Solution &#123;\npublic:\n    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int, int&gt; hash; &#x2F;&#x2F;&#123;val, idx&#125;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            int x &#x3D; nums[i];\n            if (hash.count(x) &amp;&amp; i - hash[x] &lt;&#x3D; k) return true;\n            hash[x] &#x3D; i;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n\n\n\n220.存在重复元素 III val差&lt;&#x3D;t, idx差&lt;&#x3D;k  multiset S;&#x2F;&#x2F;支持重复 +-1e18 LL哨兵\nclass Solution &#123;\npublic:\n    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;\n        typedef long long LL;\n        multiset&lt;LL&gt; S;&#x2F;&#x2F;支持重复 排序\n        S.insert(1e18), S.insert(-1e18);&#x2F;&#x2F;LL哨兵\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            if (i - j &gt; k) S.erase(S.find(nums[j ++ ]));&#x2F;&#x2F;\n            int x &#x3D; nums[i];\n            auto it &#x3D; S.lower_bound(x);&#x2F;&#x2F;&gt;&#x3D;x的min\n            if (*it - x &lt;&#x3D; t) return true;\n            -- it;&#x2F;&#x2F;&lt;x的max\n            if (x - *it &lt;&#x3D; t) return true;\n            S.insert(x);\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n\n\n221. 最大正方形 全1 DP（85最大矩形）反证 推矛盾\n\n\n【图片待修复。。。】\n![13021_4f46573090-leetcode221](C:\\Users\\bxl\\Desktop\\13021_4f46573090-leetcode221.png)？？\n&#x2F;&#x2F;221. 最大正方形 全1 DP（85最大矩形）\nclass Solution &#123;\npublic:\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        if (matrix.empty() || matrix[0].empty()) return 0;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1));\n\n        int res &#x3D; 0;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )\n                if (matrix[i - 1][j - 1] &#x3D;&#x3D; &#39;1&#39;) &#123;\n                    f[i][j] &#x3D; min(f[i - 1][j], min(f[i][j - 1], f[i - 1][j - 1])) + 1;&#x2F;&#x2F;\n                    res &#x3D; max(res, f[i][j]);&#x2F;&#x2F;\n                &#125;\n\n        return res * res;\n    &#125;\n&#125;;\n\n\n\n\n222.完全二叉树的节点个数[有点小意思~] 二分O(logn∗logn) 递归非均满\n&#x2F;*\n这道题相当于二分查找最后一层最后一个节点的位置，每次查找的复杂度是O(logn)，一共需要查找O(logn)次，所以复杂度为 O(logn∗logn)。\n最左点最右点深度&#x3D;&#x3D;：满二叉树 2^level - 1\n分界点(last one node) 在L(R)，L(R)非满\nn&#x3D;100w 2500倍增速！！！\n*&#x2F;\nclass Solution &#123;\npublic:\n    int countNodes(TreeNode* root) &#123;\n        if (!root) return 0;\n        auto l &#x3D; root-&gt;left, r &#x3D; root-&gt;right;\n        int x &#x3D; 1, y &#x3D; 1; &#x2F;&#x2F; 向L(R)走的次数\n        while (l) l &#x3D; l-&gt;left, x ++ ;\n        while (r) r &#x3D; r-&gt;right, y ++ ;\n        if (x &#x3D;&#x3D; y) return (1 &lt;&lt; x) - 1;&#x2F;&#x2F;\n        return countNodes(root-&gt;left) + 1 + countNodes(root-&gt;right);\n    &#125;\n&#125;;\n\n\n\n\n223.矩形面积 CG 并集 max(0, min(B,D)-max(A,C)) -&gt; 2D\n\n\ntypedef long long LL;\n\nclass Solution &#123;\npublic:\n    int computeArea(LL A, LL B, LL C, LL D, LL E, LL F, LL G, LL H) &#123;\n        LL X &#x3D; max(0ll, min(C, G) - max(A, E));&#x2F;&#x2F;\n        LL Y &#x3D; max(0ll, min(D, H) - max(B, F));\n        return (C - A) * (D - B) + (G - E) * (H - F) - X * Y;\n    &#125;\n&#125;;\n\n\n\n224.基本计算器 acw表达式求值(4) num.push(0)\n&#x2F;&#x2F;224.基本计算器 acw表达式求值(4)\n&#x2F;&#x2F;s 由数字、&#39;+&#39;、&#39;-&#39;、&#39;(&#39;、&#39;)&#39;、和 &#39; &#39; 组成\nclass Solution &#123;\npublic:\n    void eval(stack&lt;int&gt;&amp; num, stack&lt;char&gt;&amp; op) &#123;\n        auto b &#x3D; num.top(); num.pop();\n        auto a &#x3D; num.top(); num.pop();\n        auto c &#x3D; op.top(); op.pop();&#x2F;&#x2F;char\n        int r;\n        if (c &#x3D;&#x3D; &#39;+&#39;) r &#x3D; a + b;&#x2F;&#x2F;+-\n        else r &#x3D; a - b;\n        num.push(r);\n    &#125;\n\n    int calculate(string s) &#123;\n        stack&lt;int&gt; num;\n        stack&lt;char&gt; op;\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            auto c &#x3D; s[i];\n            if (c &#x3D;&#x3D; &#39; &#39;) continue;\n            if (isdigit(c)) &#123; &#x2F;&#x2F;\n                int x &#x3D; 0, j &#x3D; i;\n                while (j &lt; s.size() &amp;&amp; isdigit(s[j])) x &#x3D; x * 10 + (s[j ++ ] - &#39;0&#39;);&#x2F;&#x2F;()防溢出\n                i &#x3D; j - 1;&#x2F;&#x2F;j++ [i&#x3D;j-1] i++\n                num.push(x);\n            &#125; else if (c &#x3D;&#x3D; &#39;(&#39;) op.push(c);\n            else if (c &#x3D;&#x3D; &#39;)&#39;) &#123;\n                while (op.top() !&#x3D; &#39;(&#39;) eval(num, op);\n                op.pop();&#x2F;&#x2F;pop&#39;(&#39;\n            &#125; else &#123;\n                if (!i || s[i - 1] &#x3D;&#x3D; &#39;(&#39; || s[i - 1] &#x3D;&#x3D; &#39;+&#39; || s[i - 1] &#x3D;&#x3D; &#39;-&#39;)  &#x2F;&#x2F; 特殊处理符号和正号\n                    num.push(0);&#x2F;&#x2F;!!!!!\n                while (op.size() &amp;&amp; op.top() !&#x3D; &#39;(&#39;) eval(num, op);&#x2F;&#x2F;op.top() !&#x3D; &#39;(&#39;  result\n                op.push(c);&#x2F;&#x2F;push op\n            &#125;\n        &#125;\n        while (op.size()) eval(num, op);&#x2F;&#x2F;op.push(c);\n        return num.top();\n    &#125;\n&#125;;\n\n\n\n225.用队列实现栈 2q-&gt;1stkclass MyStack &#123;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n\n    queue&lt;int&gt; q, w;\n    MyStack() &#123;\n\n    &#125;\n\n    &#x2F;** Push element x onto stack. *&#x2F;\n    void push(int x) &#123;\n        q.push(x);\n    &#125;\n\n    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;\n    int pop() &#123;\n        while (q.size() &gt; 1) w.push(q.front()), q.pop();\n        int t &#x3D; q.front();\n        q.pop();&#x2F;&#x2F;\n        while (w.size()) q.push(w.front()), w.pop();\n        return t;\n    &#125;\n\n    &#x2F;** Get the top element. *&#x2F;\n    int top() &#123;\n        while (q.size() &gt; 1) w.push(q.front()), q.pop();\n        int t &#x3D; q.front();\n        q.pop();\n        while (w.size()) q.push(w.front()), w.pop();\n        q.push(t);&#x2F;&#x2F;\n        return t;\n    &#125;\n\n    &#x2F;** Returns whether the stack is empty. *&#x2F;\n    bool empty() &#123;\n        return q.empty();\n    &#125;\n&#125;;\n\n\n\n\n226.翻转二叉树 swap(l,r)&#x2F;&#x2F;226.翻转二叉树 swap(l,r)\nclass Solution &#123;\npublic:\n    TreeNode* invertTree(TreeNode* root) &#123;\n        if (!root) return NULL;\n        swap(root-&gt;left, root-&gt;right);&#x2F;&#x2F;\n        invertTree(root-&gt;left);\n        invertTree(root-&gt;right);\n        return root;\n    &#125;\n&#125;;\n\n\n\n\n\n227.基本计算器 II  模板题 *&#x2F;  unordered_map&lt;char, int&gt; pr&#x2F;&#x2F;227. 基本计算器 II  模板题\n&#x2F;&#x2F;+-*&#x2F; SPACE,无括号\nclass Solution &#123;\npublic:\n    stack&lt;int&gt; num;\n    stack&lt;char&gt; op;\n\n    void eval() &#123;\n        int b &#x3D; num.top(); num.pop();\n        int a &#x3D; num.top(); num.pop();\n        char c &#x3D; op.top(); op.pop();\n        int r;\n        if (c &#x3D;&#x3D; &#39;+&#39;) r &#x3D; a + b;\n        else if (c &#x3D;&#x3D; &#39;-&#39;) r &#x3D; a - b;\n        else if (c &#x3D;&#x3D; &#39;*&#39;) r &#x3D; a * b;\n        else r &#x3D; a &#x2F; b;\n        num.push(r);\n    &#125;\n\n    int calculate(string s) &#123;\n        unordered_map&lt;char, int&gt; pr;&#x2F;&#x2F;optr_priority\n        pr[&#39;+&#39;] &#x3D; pr[&#39;-&#39;] &#x3D; 1, pr[&#39;*&#39;] &#x3D; pr[&#39;&#x2F;&#39;] &#x3D; 2;\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            char c &#x3D; s[i];\n            if (c &#x3D;&#x3D; &#39; &#39;) continue;\n            if (isdigit(c)) &#123;\n                int x &#x3D; 0, j &#x3D; i;\n                while (j &lt; s.size() &amp;&amp; isdigit(s[j])) x &#x3D; x * 10 + (s[j ++ ] - &#39;0&#39;);\n                num.push(x);\n                i &#x3D; j - 1;\n            &#125; else &#123;\n                while (op.size() &amp;&amp; pr[op.top()] &gt;&#x3D; pr[c]) eval();\n                op.push(c);\n            &#125;\n        &#125;\n        while (op.size()) eval();\n        return num.top();\n    &#125;\n&#125;;\n\n\n\n\n228.汇总区间 连续i~j 双指针&#x2F;&#x2F;228.汇总区间 连续i~j 双指针\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;string&gt; res;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            int j &#x3D; i + 1;\n            while (j &lt; nums.size() &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1] + 1) j ++ ;\n            if (j &#x3D;&#x3D; i + 1) res.push_back(to_string(nums[i]));\n            else res.push_back(to_string(nums[i]) + &quot;-&gt;&quot; + to_string(nums[j - 1]));&#x2F;&#x2F;范围range\n            i &#x3D; j - 1;&#x2F;&#x2F;i ++\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n229.求众数 II &gt;n&#x2F;3 (169多数元素:n&#x2F;2 摩尔投票法n&#x2F;k BM！)\n&#x2F;&#x2F;229.求众数 II (169多数元素:n&#x2F;2 摩尔投票法n&#x2F;k BM！) &gt;n&#x2F;3\n&#x2F;&#x2F;https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;294&#x2F;\n&#x2F;&#x2F;摩尔投票算法(Boyer–Moore majority vote algorithm)又名多数投票算法，通过线性时间和常数空间来查找数组中的多数元素\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        int r1, r2, c1 &#x3D; 0, c2 &#x3D; 0;\n        for (auto x: nums)&#x2F;&#x2F;r12\n            if (c1 &amp;&amp; x &#x3D;&#x3D; r1) c1 ++ ;\n            else if (c2 &amp;&amp; x &#x3D;&#x3D; r2) c2 ++ ;\n            else if (!c1) r1 &#x3D; x, c1 ++ ;\n            else if (!c2) r2 &#x3D; x, c2 ++ ;\n            else c1 --, c2 -- ;\n        c1 &#x3D; 0, c2 &#x3D; 0;\n        for (auto x: nums)&#x2F;&#x2F;c12\n            if (x &#x3D;&#x3D; r1) c1 ++ ;\n            else if (x &#x3D;&#x3D; r2) c2 ++ ;\n\n        vector&lt;int&gt; res;\n        int n &#x3D; nums.size();\n        if (c1 &gt; n &#x2F; 3) res.push_back(r1);&#x2F;&#x2F;judge c12&gt;n&#x2F;3\n        if (c2 &gt; n &#x2F; 3) res.push_back(r2);\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n230.二叉搜索树中第K小的元素&#x2F;&#x2F;230.二叉搜索树中第K小的元素 bool dfs提前返回:O(k) --k&#x3D;&#x3D;0\nclass Solution &#123;\npublic:\n    int k, ans;\n\n    int kthSmallest(TreeNode* root, int _k) &#123;\n        k &#x3D; _k;\n        dfs(root);\n        return ans;\n    &#125;\n\n    bool dfs(TreeNode* root) &#123;\n        if (!root) return false;\n        if (dfs(root-&gt;left)) return true;&#x2F;&#x2F;bool dfs提前返回\n        if ( -- k &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;--k&#x3D;&#x3D;0\n            ans &#x3D; root-&gt;val;\n            return true;\n        &#125;\n        return dfs(root-&gt;right);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;进阶：如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？\n&#x2F;*\n如果该树经常被修改，那么树可能会变成不平衡的，即树高由 O(logn) 变为 O(n)。\n使用Splay树或者Treap等平衡二叉树可以保证树高 h 是 O(log⁡n)级别的，\n如果我们在结点中增加一个cnt属性来记录以该节点为根的子树的节点个数，那么我们就可以在 O(h) 的时间内找到第k大的元素。\n*&#x2F;\nclass Solution &#123;\npublic: \n    int kthSmallest(TreeNode* root, int k) &#123;\n        int num &#x3D; count(root-&gt;left);   \n        if(num &gt;&#x3D; k)&#123;\n            return kthSmallest(root-&gt;left, k);\n        &#125;else if(num + 1 &lt; k)&#123;\n            return kthSmallest(root-&gt;right, k - num - 1);\n        &#125;\n        return root-&gt;val;\n    &#125;\n    \n    int count(TreeNode* root)&#123;\n        if(!root) return 0;\n        return 1 + count(root-&gt;left) + count(root-&gt;right);\n    &#125;\n    &#x2F;&#x2F;实现insert delete函数。。。\n&#125;;\n\n\n\n\n231.2的幂 n &gt; 0 &amp;&amp; (n &amp; -n) &#x3D;&#x3D; n;class Solution &#123;\npublic:\n    bool isPowerOfTwo(int n) &#123;\n        return n &gt; 0 &amp;&amp; (n &amp; -n) &#x3D;&#x3D; n;\n    &#125;\n&#125;;\n\n\n\n232.用栈实现队列(225)class MyQueue &#123;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    stack&lt;int&gt; a, b;\n    MyQueue() &#123;\n\n    &#125;\n    \n    &#x2F;** Push element x to the back of queue. *&#x2F;\n    void push(int x) &#123;\n        a.push(x);\n    &#125;\n\n    &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;\n    int pop() &#123;\n        while (a.size() &gt; 1) b.push(a.top()), a.pop();\n        int t &#x3D; a.top();\n        a.pop();&#x2F;&#x2F;\n        while (b.size()) a.push(b.top()), b.pop();\n        return t;\n    &#125;\n\n    &#x2F;** Get the front element. *&#x2F;\n    int peek() &#123;\n        while (a.size() &gt; 1) b.push(a.top()), a.pop();\n        int t &#x3D; a.top();\n        while (b.size()) a.push(b.top()), b.pop();\n        return t;\n    &#125;\n\n    &#x2F;** Returns whether the queue is empty. *&#x2F;\n    bool empty() &#123;\n        return a.empty();\n    &#125;\n&#125;;\n\n\n\n\n—[难！]233.数字 1 的个数 分类讨论 L R 10^p acw338计数问题(基础课)蓝书DPacw338（更通用：数字 x(0~9) 的个数）\n\n本题x&#x3D;&#x3D;1 &gt;0\n\n\n\nclass Solution &#123;\npublic:\n    int countDigitOne(int n) &#123;\n        if (n &lt;&#x3D; 0) return 0;&#x2F;&#x2F;\n        vector&lt;int&gt; nums;\n        while (n) nums.push_back(n % 10), n &#x2F;&#x3D; 10;\n        reverse(nums.begin(), nums.end());\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            int d &#x3D; nums[i];\n            int left &#x3D; 0, right &#x3D; 0, p &#x3D; 1;\n            for (int j &#x3D; 0; j &lt; i; j ++ ) left &#x3D; left * 10 + nums[j];\n            for (int j &#x3D; i + 1; j &lt; nums.size(); j ++ ) &#123;\n                right &#x3D; right * 10 + nums[j];\n                p &#x3D; p * 10;&#x2F;&#x2F;\n            &#125;\n            if (d &#x3D;&#x3D; 0) res +&#x3D; left * p;\n            else if (d &#x3D;&#x3D; 1) res +&#x3D; left * p + right + 1;\n            else res +&#x3D; (left + 1) * p;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;另：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;280&#x2F;\n\n\n\n234.回文链表&#x2F;&#x2F;234.回文链表\n&#x2F;&#x2F;reverse 恢复 数数法：n-half half-1\nclass Solution &#123;\npublic:\n    bool isPalindrome(ListNode* head) &#123;\n        int n &#x3D; 0;\n        for (auto p &#x3D; head; p; p &#x3D; p-&gt;next) n ++ ;\n        if (n &lt;&#x3D; 1) return true;\n        int half &#x3D; n &#x2F; 2;\n        auto a &#x3D; head;\n        for (int i &#x3D; 0; i &lt; n - half; i ++ ) a &#x3D; a-&gt;next;\n        auto b &#x3D; a-&gt;next;\n        for (int i &#x3D; 0; i &lt; half - 1; i ++ ) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n\n        auto p &#x3D; head, q &#x3D; a;\n        bool success &#x3D; true;\n        for (int i &#x3D; 0; i &lt; half; i ++ ) &#123;\n            if (p-&gt;val !&#x3D; q-&gt;val) &#123;\n                success &#x3D; false;\n                break;\n            &#125;\n            p &#x3D; p-&gt;next;\n            q &#x3D; q-&gt;next;\n        &#125;\n\n        auto tail &#x3D; a;\n        b &#x3D; a-&gt;next;\n        &#x2F;&#x2F; 将链表恢复原状\n        for (int i &#x3D; 0; i &lt; half - 1; i ++ ) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n\n        tail-&gt;next &#x3D; NULL;\n        return success;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;快慢指针法\n\n\n\n\n235.二叉搜索树的最近公共祖先LCA 递归simple O(h)class Solution &#123;\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        if(p-&gt;val &gt; q-&gt;val) swap(p, q);&#x2F;&#x2F;SBT\n        if(p-&gt;val &lt;&#x3D; root-&gt;val &amp;&amp; q-&gt;val &gt;&#x3D; root-&gt;val) return root;\n        if(q-&gt;val &lt;&#x3D; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p , q);\n        else return lowestCommonAncestor(root-&gt;right, p, q);\n    &#125;\n&#125;;\n\n\n\n236. 二叉树的最近公共祖先 LR都递归 O(n) dfs 第一次找到同时包含pq(state &#x3D;&#x3D; 3)的子树class Solution &#123;\npublic:\n    TreeNode* ans &#x3D; NULL;\n\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        dfs(root, p, q);\n        return ans;\n    &#125;\n\n    int dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        if(!root) return 0;\n        \n        int state &#x3D; dfs(root-&gt;left, p, q);&#x2F;&#x2F;state&#x3D;[q][p]&#x3D;00&#x2F;01&#x2F;10&#x2F;11\n        if(root &#x3D;&#x3D; p) state |&#x3D; 1;\n        else if(root &#x3D;&#x3D; q) state |&#x3D; 2;\n        state |&#x3D; dfs(root-&gt;right, p, q);\n        \n        if(state &#x3D;&#x3D; 3 &amp;&amp; !ans) ans &#x3D; root;&#x2F;&#x2F;ans第一次赋值\n        return state;\n    &#125;\n&#125;;\n\n\n\n237. 删除链表中的节点：*node &#x3D; *node-&gt;next;class Solution &#123;\npublic:\n    void deleteNode(ListNode* node) &#123;\n        node-&gt;val &#x3D; node-&gt;next-&gt;val;&#x2F;&#x2F;后继val覆盖\n        node-&gt;next &#x3D; node-&gt;next-&gt;next;&#x2F;&#x2F;删后继\n    &#125;\n&#125;;\n&#x2F;&#x2F;等价写法\nclass Solution &#123;\npublic:\n    void deleteNode(ListNode* node) &#123;\n        *node &#x3D; *node-&gt;next;&#x2F;&#x2F;结构体赋值\n    &#125;\n&#125;;\n\n\n\n238. 除自身以外数组的乘积[前后缀分解！]常数空间，只能开一个数组Pi：Si&#x3D;S变量累乘  bi&#x3D;&#x3D;Pi*S\n\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; p(n, 1);&#x2F;&#x2F;vector&lt;int&gt; p(size, init)\n        for(int i &#x3D; 1; i &lt; n; i++) p[i] &#x3D; p[i - 1] * nums[i - 1];&#x2F;&#x2F;p0&#x3D;1 1~n-1\n        for(int i &#x3D; n - 1, s &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;&#x2F;&#x2F;s[n-1]&#x3D;1 n-2~0\n            p[i] *&#x3D; s;\n            s *&#x3D; nums[i];\n        &#125;\n        return p;\n    &#125;\n&#125;;\n\n\n\n239. 滑动窗口最大值[单调队列：在左还低&#x3D;被优化掉]\n左- 右—–+\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;\n        deque&lt;int&gt; q;&#x2F;&#x2F;存idx\n        vector&lt;int&gt; res;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;&#x2F;&#x2F;q[L:i-k+1&gt;&#x3D;0  ~k个~  R:i&gt;&#x3D;k-1]\n            if(q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front();&#x2F;&#x2F;idx: L&gt;front pop\n            while(q.size() &amp;&amp; nums[i] &gt;&#x3D; nums[q.back()]) q.pop_back();&#x2F;&#x2F;val\n            q.push_back(i);\n            if(i &gt;&#x3D; k - 1) res.push_back(nums[q.front()]);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n240. 搜索二维矩阵 II 右上角\nclass Solution &#123;\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;\n        if(matrix.empty() || matrix[0].empty()) return false;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        int i &#x3D; 0, j &#x3D; matrix[0].size();\n        while(i &lt; n &amp;&amp; j &gt;&#x3D; 0) &#123;\n            int t &#x3D; matrix[i][j];\n            if(t &#x3D;&#x3D; target) return true;\n            else if(t &lt; target) i++;\n            else j--;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n\n\n24. 为运算表达式设计优先级 加括号的所有运算结果:expr L+-*R LR递归dfs （同LC95）&#x2F;&#x2F;241. 为运算表达式设计优先级 加括号的所有运算结果:expr L+-*R LR递归dfs\n&#x2F;&#x2F;加括号的所有运算结果&#x3D;所有SBT 中缀表达式&#x3D;&#x3D;表达式树 ()&#x3D;子树 SBT子树不同，但中序遍历&#x3D;，结果&#x3D;\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; expr;\n\n    vector&lt;int&gt; diffWaysToCompute(string s) &#123;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(isdigit(s[i])) &#123;\n                int j &#x3D; i, x &#x3D; 0;\n                while(j &lt; s.size() &amp;&amp; isdigit(s[j])) x &#x3D; x * 10 + (s[j++] - &#39;0&#39;);\n                i &#x3D; j - 1; &#x2F;&#x2F; i++\n                expr.push_back(to_string(x));\n            &#125; else expr.push_back(s.substr(i, 1));\n        &#125;\n        return dfs(0, expr.size() - 1);\n    &#125;\n\n    vector&lt;int&gt; dfs(int l, int r) &#123;\n        if(l &#x3D;&#x3D; r) return &#123;stoi(expr[l])&#125;;&#x2F;&#x2F;\n        vector&lt;int&gt; res;\n        for(int i &#x3D; l + 1; i &lt; r; i +&#x3D; 2) &#123;\n            auto left &#x3D; dfs(l, i - 1), right &#x3D; dfs(i + 1, r);\n            for(auto x: left)\n                for(auto y: right) &#123;\n                    int z;\n                    if(expr[i] &#x3D;&#x3D; &quot;+&quot;) z &#x3D; x + y;\n                    else if(expr[i] &#x3D;&#x3D; &quot;-&quot;) z &#x3D; x - y;\n                    else z &#x3D; x * y;\n                    res.push_back(z);\n                &#125;\n        &#125;\n        return res;\n    &#125;  \n&#125;;\n\n\n\n\n\n242. 有效的字母异位词 哈希表 str：unicode1个字符&#x3D;2个char&#x2F;&#x2F;红黑树map:有序性 哈希表unordered_map:查找O(1)\nclass Solution &#123;\npublic:\n    bool isAnagram(string s, string t) &#123;\n        unordered_map&lt;char, int&gt; a, b;&#x2F;&#x2F;&#123;pair&#123;,&#125;&#125;\n        for(auto c: s) a[c] ++;&#x2F;&#x2F;cnt\n        for(auto c: t) b[c] ++;\n        return a &#x3D;&#x3D; b;\n    &#125;\n&#125;;\n\n\n\n243.\n\n\n\n244.\n\n\n\n245.\n\n\n\n246.\n\n\n\n\n\n247.\n\n\n\n248.\n\n\n\n249.\n\n\n\n250.\n\n\n\n251\n\n\n\n252.\n\n\n\n253.\n\n\n\n254.\n\n\n\n255.\n\n\n\n256.\n\n\n\n257.二叉树的所有路径 dfs\n完全二叉树\n\n要存路径，最坏O($n^2$)\n&#x2F;&#x2F;257. 二叉树的所有路径 不加&amp;str参：O(n*n) 不知道字符长度，不如vec好写\n&#x2F;&#x2F;存路径，要回溯，最坏O($n^2$)\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    vector&lt;int&gt; path; \n\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;\n        if(root) dfs(root);\n        return ans;\n    &#125;\n\n    void dfs(TreeNode* root) &#123;\n        path.push_back(root-&gt;val);&#x2F;&#x2F;root !&#x3D; NULL\n        if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;\n            string line &#x3D; to_string(path[0]);&#x2F;&#x2F;\n            for(int i &#x3D; 1; i &lt; path.size(); i++)\n                line +&#x3D; &quot;-&gt;&quot; + to_string(path[i]);\n            ans.push_back(line);\n        &#125; else &#123;\n            if(root-&gt;left) dfs(root-&gt;left);&#x2F;&#x2F;\n            if(root-&gt;right) dfs(root-&gt;right);\n        &#125;\n        path.pop_back();&#x2F;&#x2F;\n    &#125;\n&#125;;\n\n\n\n258.各位相加 直到结果为一位数 小学奥数 同余 (10^n)mod9&#x3D;1 f(x)%9&#x3D;x%9小学奥数：同余 $(10^n)mod9&#x3D;1$\n\n&#x2F;&#x2F;258.各位相加 直到结果为一位数。\n&#x2F;&#x2F;不使用循环或者递归【不模拟】，O(1)：小学奥数 同余 (10^n)mod9&#x3D;1\nclass Solution &#123;\npublic:\n    int addDigits(int num) &#123;\n        if(!num) return 0;&#x2F;&#x2F;0 0\n        if(num % 9) return num % 9;&#x2F;&#x2F;num%9&#x3D;1~8 1~8\n        return 9;&#x2F;&#x2F;num%9&#x3D;&#x3D;0 9\n    &#125;\n&#125;;\n\n\n\n\n259.\n\n\n\n260.只出现一次的数字 III  2次中[2个]1次val\n&#x2F;&#x2F;260.只出现一次的数字 III  2次中[2个]1次val\n&#x2F;&#x2F;2次中1次:^  分类，拆分成之前子问题\n&#x2F;&#x2F;lowbit(x) &#x3D; x&amp;(-x) &#x3D; x&amp;(x^(x-1)) &#x3D; 1 2 4 8 树状数组 状态压缩DP\nclass Solution &#123;\npublic:\n\tint get(vector&lt;int&gt;&amp; nums, int k, int t) &#123;\n\t\tint res &#x3D; 0;\n\t\tfor(auto x: nums)\n\t\t\tif((x &gt;&gt; k &amp; 1) &#x3D;&#x3D; t)&#x2F;&#x2F;第k位是0 1\n\t\t\t\tres ^&#x3D; x;\n\t\treturn res;\n\t&#125;\n\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n    \tint ab &#x3D; 0;\n    \tfor(auto x:nums) ab ^&#x3D; x;\n    \tint k &#x3D; 0;\n    \twhile((ab &gt;&gt; k &amp; 1) &#x3D;&#x3D; 0) k++;&#x2F;&#x2F;a b第k位不同\n        return &#123;get(nums, k, 0), get(nums, k, 1)&#125;;\n    &#125;\n&#125;;\n\n\n\n261\n\n\n\n\n\n262.\n\n\n\n263.丑数  只包含质因数 2 3 5 的正整数 把235除干净&#x3D;&#x3D;1&#x2F;&#x2F;263.丑数 只包含质因数 2 3 5 的正整数 把235除干净&#x3D;&#x3D;1\nclass Solution &#123;\npublic:\n    bool isUgly(int n) &#123;\n        if(n &lt;&#x3D; 0) return false;\n        while(n % 2 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 2;\n        while(n % 3 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 3;\n        while(n % 5 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 5;\n        return n &#x3D;&#x3D; 1;\n    &#125;\n&#125;;\n\n\n\n\n264.丑数II nth 多路归并包含因子2 3 5的所有丑数 并 1\n\n&#x2F;&#x2F;264.丑数II nth 多路归并\nclass Solution &#123;\npublic:\n    int nthUglyNumber(int n) &#123;\n        vector&lt;int&gt; q(1, 1);\n        for(int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0; q.size() &lt; n;) &#123;\n            int t &#x3D; min(q[i] * 2, min(q[j] * 3, q[k] * 5));&#x2F;&#x2F;嵌套丑数生成\n            q.push_back(t);\n            if(q[i] * 2 &#x3D;&#x3D; t) i ++ ;\n            if(q[j] * 3 &#x3D;&#x3D; t) j ++ ;&#x2F;&#x2F;不能else if,凡是&#x3D;&#x3D;t都要++后移\n            if(q[k] * 5 &#x3D;&#x3D; t) k ++ ;\n        &#125;\n        return q.back();\n    &#125;\n&#125;;\n\n\n\n265.\n\n\n\n266.\n\n\n\n\n\n267.\n\n\n\n268.缺失数字 0~n n(n+1)&#x2F;2-sum小学奥数：翻书页，找到撕掉哪一页\nclass Solution &#123;\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int res &#x3D; n * (n + 1) &#x2F; 2;\n        for(auto x: nums) res -&#x3D; x;\n        return res;\n    &#125;\n&#125;;\n\n\n\n269.\n\n\n\n270.\n\n\n\n271\n\n\n\n\n\n272.\n\n\n\n273.整数转换英文表示 难模拟\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;str_array\n    string num0_19[20] &#x3D; &#123;\n        &quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;,\n        &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;,\n        &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;,\n        &quot;Nineteen&quot;,\n    &#125;;\n    string num20_90[8] &#x3D; &#123;\n        &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;,\n        &quot;Eighty&quot;, &quot;Ninety&quot;,\n    &#125;;\n    string num1000[4] &#x3D; &#123;\n        &quot;Billion &quot;, &quot;Million &quot;, &quot;Thousand &quot;, &quot;&quot;,&#x2F;&#x2F;j++\n    &#125;;\n\n    string get(int x) &#123;  &#x2F;&#x2F; 返回1 ~ 999的英文表示\n        string res;\n        if (x &gt;&#x3D; 100) &#123;\n            res +&#x3D; num0_19[x &#x2F; 100] + &quot; Hundred &quot;;\n            x %&#x3D; 100;\n        &#125;\n        if (x &gt;&#x3D; 20) &#123;\n            res +&#x3D; num20_90[x &#x2F; 10 - 2] + &quot; &quot;;\n            x %&#x3D; 10;\n            if (x) res +&#x3D; num0_19[x] + &#39; &#39;;\n        &#125; else if (x) res +&#x3D; num0_19[x] + &#39; &#39;;&#x2F;&#x2F;else if\n        return res;\n    &#125;\n\n    string numberToWords(int num) &#123;\n        if (!num) return &quot;Zero&quot;;&#x2F;&#x2F;\n        string res;\n        for (int i &#x3D; 1e9, j &#x3D; 0; i &gt;&#x3D; 1; i &#x2F;&#x3D; 1000, j ++ )\n            if (num &gt;&#x3D; i) &#123;\n                res +&#x3D; get(num &#x2F; i) + num1000[j];\n                num %&#x3D; i;\n            &#125;\n        res.pop_back();&#x2F;&#x2F;去&#39; &#39;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n274.H指数 O(nlogn):sort\nclass Solution &#123;\npublic:\n    int hIndex(vector&lt;int&gt;&amp; c) &#123;\n        sort(c.begin(), c.end(), greater&lt;int&gt;());&#x2F;&#x2F;大-&gt;小\n        for(int h &#x3D; c.size(); h; h--)\n            if(c[h - 1] &gt;&#x3D; h) &#x2F;&#x2F;h_max\n                return h;\n        return 0;\n    &#125;\n&#125;;\n\n\n\n275.H指数II 二分O(logn)&#x2F;&#x2F;从小到大排好序的：在数组中找一个[最大的h]，使得后h个数大于等于h。 ！不能reverse，否则O(n)！\n&#x2F;&#x2F;我们发现：如果h满足，则小于h的数都满足；如果h不满足，则大于h的数都不满足。所以具有二分性质。\n&#x2F;&#x2F;倒数~正数：1~n-1  mid~n-mid\nclass Solution &#123;\npublic:\n    int hIndex(vector&lt;int&gt;&amp; c) &#123;\n        int n &#x3D; c.size();\n        int l &#x3D; 0, r &#x3D; n;\n        while (l &lt; r)\n        &#123;\n            int mid &#x3D; l + r + 1 &gt;&gt; 1;&#x2F;&#x2F;\n            if (c[n - mid] &gt;&#x3D; mid) l &#x3D; mid;&#x2F;&#x2F;h_max [-&gt;\n            else r &#x3D; mid - 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n\n\n276.\n\n\n\n\n\n277.\n\n\n\n278.第一个错误的版本 二分class Solution &#123;\npublic:\n    int firstBadVersion(int n) &#123;\n        int l &#x3D; 1, r &#x3D; n;\n        while(l &lt; r) &#123;\n            int mid &#x3D; (long long) l + r &gt;&gt; 1;&#x2F;&#x2F;防溢出\n            &#x2F;&#x2F;int mid &#x3D; l + (r - l) &#x2F; 2;\n            if(isBadVersion(mid)) r &#x3D; mid;&#x2F;&#x2F;min&lt;-]\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n\n\n279.完全平方数  n最少拆成几个…之和\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;300&#x2F;\n&#x2F;&#x2F;完全背包DP BFS:O(n√n)\n&#x2F;*\n(动态规划) O(n√n)\n设 f(i) 表示通过平方数组成 i 所需要完全平方数的最少数量。\n初始时，f(0)&#x3D;0，其余待定。\n转移时，对于一个 i，枚举 j，f(i)&#x3D;min(f(i−j∗j)+1)，其中 1≤j≤√i。\n最终答案为 f(n)。\n时间复杂度\n实际复杂度为 S&#x3D;∑i&#x3D;1~n √i，通过积分近似上界，得到 S&#x3D;O(n√n)。\n空间复杂度\n需要额外 O(n) 的空间存储状态。\nC++ 代码\n*&#x2F;\nclass Solution &#123;\npublic:\n    int numSquares(int n) &#123;\n        vector&lt;int&gt; f(n + 1, n);\n        f[0] &#x3D; 0;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            for (int j &#x3D; 1; j * j &lt;&#x3D; i; j++)&#x2F;&#x2F;\n                f[i] &#x3D; min(f[i], f[i - j * j] + 1);&#x2F;&#x2F;\n\n        return f[n];\n    &#125;\n&#125;;\n\n&#x2F;*\n(数学) O(√n+logn)\n根据 拉格朗日四平方和定理[每个正整数均可表示为4个整数的平方和]，可以得知答案必定为 1, 2, 3, 4 中的一个。\n其次根据 勒让德三平方和定理，可以得知 n 能写成 3 个数的平方和,当且仅当，n!&#x3D;4^a*(8b+7)。\n然后可以根据以上定理和枚举，判断出答案是否为 1, 2, 3，若都不是则答案为 4。\n时间复杂度\n判断平方数的时间复杂度为 $O(1)，枚举答案为 2 的时间复杂度为O(√n)，判断答案是否为 4 的时间复杂度为 O(log⁡n)，故总时间复杂度为 O(n√+logn)。\nC++ 代码\n*&#x2F;\nclass Solution &#123;\npublic:\n    int numSquares(int n) &#123;\n        if ((int)sqrt(n) * (int)sqrt(n) &#x3D;&#x3D; n)\n            return 1;\n        int t &#x3D; n;\n        while ((t &amp; 3) &#x3D;&#x3D; 0) t &gt;&gt;&#x3D; 2;&#x2F;&#x2F;t是4的倍数\n        if (((t - 7) &amp; 7) &#x3D;&#x3D; 0)&#x2F;&#x2F;t-7是8的倍数\n            return 4;\n\n        for (int i &#x3D; 1; i * i &lt;&#x3D; n; i++)\n            if ((int)(sqrt(n - i * i)) * (int)(sqrt(n - i * i)) &#x3D;&#x3D; n - i * i)\n                return 2;\n\n        return 3;\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;300&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    bool  check(int x) &#123;\n        int r &#x3D; sqrt(x);\n        return r * r &#x3D;&#x3D; x;\n    &#125;\n\n    int numSquares(int n) &#123;\n        if(check(n)) return 1;\n\n        for(int a &#x3D; 1; a &lt;&#x3D; n &#x2F; a; a++)\n            if(check(n - a * a)) return 2;\n\n        while(n % 4 &#x3D;&#x3D; 0) n &#x2F;&#x3D; 4;\n        if(n % 8 !&#x3D; 7) return 3;\n        return 4;\n    &#125;\n&#125;;\n\n\n\n280.\n\n\n\n281\n\n\n\n\n\n282.给表达式添加运算符 类似24点游戏 卡常 a+b×()递归\n&#x2F;&#x2F;282. 给表达式添加运算符 类似24点游戏\n&#x2F;&#x2F;线段树维护两段性的代数结构？？？\n&#x2F;&#x2F;+-*用代数结构优化爆搜，省掉stk，全局数组原地改不用str 递归 代数结构封闭性：经典a+b*_\n&#x2F;*\n(DFS) O(n*4^n)\n基本思路是暴力枚举所有表达式方案:\n\n每两个数字之间可以不填任何字符，也可以填加减乘，所以每个间隔有4种方案，直接暴力枚举所有方案即可。\n本题的难点在于常数优化，如果实现方式不好，那么本题就很容易超时。总结下来一共两点：\n\n如果先[暴搜出所有表达式的形式]，然后再用[表达式求值的模板]去求解，那么会超时；\n记录方案时如果[每次复制整个数组]，那么会超时；\n为了能尽量优化常数，我们在[递归过程中尽量不要使用栈来维护表达式]。本题中我们维护如下不变式：\n\na+b×()，其中括号中的数是我们枚举的下一个数；\n然后分类讨论下一个运算符，其中 c 是我们枚举的括号中的数：\n\n下一个运算符是加号，那么 a+b×(c)+()&#x3D;(a+b×c)+1×();\n下一个运算符是减号，那么 a+b×(c)−()&#x3D;(a+b×c)+(−1)×();\n下一个运算符是乘号，那么 a+b×(c)×()&#x3D;a+(b×c)×();\n为了方便，我们在表达式【最后统一添加一个加号，那么最终不变式就会变成 a+1×()，所以 a 就是我们枚举的表达式的值，判断一下和target是否相等即可。】\n\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;332&#x2F;\n*&#x2F;\ntypedef long long LL;\n\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; ans;\n    string path;\n\n    vector&lt;string&gt; addOperators(string num, int target) &#123;\n        path.resize(100);&#x2F;&#x2F;O(n*4^n) n&lt;50\n        dfs(num, 0, 0, 0, 1, target);&#x2F;&#x2F;u:cur_idx pathLen a b: a+b*_\n        return ans;\n    &#125;\n\n    void dfs(string&amp; num, int u, int len, LL a, LL b, LL target) &#123;\n        if (u &#x3D;&#x3D; num.size()) &#123;\n            if (a &#x3D;&#x3D; target) &#123;\n                ans.push_back(path.substr(0, len - 1));&#x2F;&#x2F;[a]+ 去+号\n            &#125;\n        &#125; else &#123;\n            LL c &#x3D; 0;&#x2F;&#x2F;c:cur_num\n            for (int i &#x3D; u; i &lt; num.size(); i ++ ) &#123;\n                c &#x3D; c * 10 + num[i] - &#39;0&#39;;\n                path[len ++ ] &#x3D; num[i];\n                &#x2F;&#x2F;+  [a]last+\n                path[len] &#x3D; &#39;+&#39;;\n                dfs(num, i + 1, len + 1, a + b * c, 1, target);\n                \n                if (i + 1 &lt; num.size()) &#123;&#x2F;&#x2F;not last one\n                    &#x2F;&#x2F;-\n                    path[len] &#x3D; &#39;-&#39;;\n                    dfs(num, i + 1, len + 1, a + b * c, -1, target);\n                    &#x2F;&#x2F;*\n                    path[len] &#x3D; &#39;*&#39;;\n                    dfs(num, i + 1, len + 1, a, b * c, target);\n                &#125;\n                if (num[u] &#x3D;&#x3D; &#39;0&#39;) break;\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n\n\n283.移动零 至末尾class Solution &#123;\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;\n        int k &#x3D; 0;\n        for(auto x: nums) \n            if (x)\n                nums[k++] &#x3D; x;\n        while(k &lt; nums.size()) nums[k++] &#x3D; 0;\n    &#125;\n&#125;;\n\n\n\n284.顶端迭代器 封装 手动增加一个类似展台的缓存cur&#x2F;*\n * Below is the interface for Iterator, which is already defined for you.\n * **DO NOT** modify the interface for Iterator.\n *\n *  class Iterator &#123;\n *\t\tstruct Data;\n * \t\tData* data;\n *  public:\n *\t\tIterator(const vector&lt;int&gt;&amp; nums);\n * \t\tIterator(const Iterator&amp; iter);\n *\n * \t\t&#x2F;&#x2F; Returns the next element in the iteration.\n *\t\tint next();\n *\n *\t\t&#x2F;&#x2F; Returns true if the iteration has more elements.\n *\t\tbool hasNext() const;\n *\t&#125;;\n *&#x2F;\n\nclass PeekingIterator : public Iterator &#123;\npublic:\n    int cur;\n    bool has_next;\n\n\tPeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123;\n\t    &#x2F;&#x2F; Initialize any member here.\n\t    &#x2F;&#x2F; **DO NOT** save a copy of nums and manipulate it directly.\n\t    &#x2F;&#x2F; You should only use the Iterator interface methods.\n        has_next &#x3D; Iterator::hasNext();\n        if(has_next) cur &#x3D; Iterator::next();\n\t&#125;\n\t\n    &#x2F;&#x2F; Returns the next element in the iteration without advancing the iterator.\n\tint peek() &#123;\n        return cur;\n\t&#125;\n\t\n\t&#x2F;&#x2F; hasNext() and next() should behave the same as in the Iterator interface.\n\t&#x2F;&#x2F; Override them if needed.\n\tint next() &#123;\n\t    int t &#x3D; cur;\n        has_next &#x3D; Iterator::hasNext();\n        if(has_next) cur &#x3D; Iterator::next();\n        return t;\n\t&#125;\n\t\n\tbool hasNext() const &#123;\n        return has_next;\n\t&#125;\n&#125;;\n\n\n\n285.\n\n\n\n286.\n\n\n\n287.寻找重复数 转化到LC142环的入口【n+1个数在1~n之间】可利用其转化！！！，有一个重复数\nacwing14剑指offer 不同：多个重复返回任意一个【二分】  也可用此法\n桶排序会修改数组\n\nclass Solution &#123;\npublic:\n    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        int a &#x3D; 0, b &#x3D; 0;\n        while(true) &#123;\n            a &#x3D; nums[a];\n            b &#x3D; nums[nums[b]];&#x2F;&#x2F;\n            if(a &#x3D;&#x3D; b) &#123;\n                a &#x3D; 0;\n                while(a !&#x3D; b) &#123;\n                    a &#x3D; nums[a];\n                    b &#x3D; nums[b];\n                &#125;\n                return a;\n            &#125;\n        &#125;\n        return -1;&#x2F;&#x2F;\n    &#125;\n&#125;;\n\n\n\n288.\n\n\n\n289.生命游戏 原地 32bit int技巧\n&#x2F;&#x2F;289.生命游戏 原地 __位技巧\nclass Solution &#123;\npublic:\n    void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;\n        if(board.empty() || board[0].empty()) return;\n        int n &#x3D; board.size(), m &#x3D; board[0].size();\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; m; j++) &#123;\n                int live &#x3D; 0;\n                for(int x &#x3D; max(0, i - 1); x &lt;&#x3D; min(n - 1, i + 1); x++)\n                    for(int y &#x3D; max(0, j - 1); y &lt;&#x3D; min(m - 1, j + 1); y++)\n                        if((x !&#x3D; i || y !&#x3D; j) &amp;&amp; (board[x][y] &amp; 1))&#x2F;&#x2F;跳过ij中心点\n                            live++;\n                int cur &#x3D; board[i][j] &amp; 1, next;\n                if (cur) &#123;\n                    if(live &lt; 2 || live &gt; 3) next &#x3D; 0;\n                    else next &#x3D; 1;\n                &#125; else &#123;\n                    if(live &#x3D;&#x3D; 3) next &#x3D; 1;\n                    else next &#x3D; 0;\n                &#125;\n                board[i][j] |&#x3D; next &lt;&lt; 1;\n            &#125;\n        for(int i &#x3D; 0; i &lt; n; i++)\n            for(int j &#x3D; 0; j &lt; m; j++)\n                board[i][j] &gt;&gt;&#x3D; 1;\n    &#125;\n&#125;;\n\n\n\n290.单词规律  双射：满射|A|&#x3D;|B| 单射B-&gt;A(唯一) 映射A-&gt;B(唯一)满射：|A|&#x3D;|B|\n\nB只有一个A\n\n是映射，是单值函数，x对应一个y    A只有一个B\n&#x2F;&#x2F;290.单词规律 双射：满射|A|&#x3D;|B| 单射B-&gt;A(唯一) 映射A-&gt;B(唯一)\nclass Solution &#123;\npublic:\n    bool wordPattern(string pattern, string s) &#123;\n        vector&lt;string&gt; words;\n        stringstream ssin(s);&#x2F;&#x2F;\n        string word;\n        while(ssin &gt;&gt; word) words.push_back(word);\n        if(pattern.size() !&#x3D; words.size()) return false;\n        unordered_map&lt;char, string&gt; pw;\n        unordered_map&lt;string, char&gt; wp;\n        for(int i &#x3D; 0; i &lt; pattern.size(); i++) &#123;\n            auto a &#x3D; pattern[i];\n            auto b &#x3D; words[i];\n            if(pw.count(a) &amp;&amp; pw[a] !&#x3D; b) return false;&#x2F;&#x2F;\n            pw[a] &#x3D; b;\n            if(wp.count(b) &amp;&amp; wp[b] !&#x3D; a) return false;\n            wp[b] &#x3D; a;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n\n\n\n291\n\n\n\n\n\n292.Nim游戏 小学数奥\n你作为先手。\n每一回合，轮到的人拿掉 1 - 3 块石头。\n拿掉最后一块石头的人就是获胜者。\nbest policy:\nn%4!&#x3D;0,我拿x&#x3D;n%4,Ta面对(n-x)%4&#x3D;&#x3D;0必败，我必胜\n同理n%4&#x3D;&#x3D;0，Ta必胜\n\n\nclass Solution &#123;\npublic:\n    bool canWinNim(int n) &#123;\n        return n%4;\n    &#125;\n&#125;;\n\n\n\n293.\n\n\n\n294.\n\n\n\n295.数据流的[中位数] 动态维护median：对顶堆动态维护有序序列：平衡树 set map\n\nn奇down多一个，多两个就上下移堆顶  t&lt;&#x3D;x入down\n插入O(logn) 查询O(1)\n100个桶 统计次数O(100)&gt;O(logn) 省空间！\n用对顶堆维护桶：O(log100)？？？？？how？？？？？？\nclass MedianFinder &#123;\npublic:\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;&#x2F;&#x2F;小根堆\n    priority_queue&lt;int&gt; down;\n\n    &#x2F;** initialize your data structure here. *&#x2F;\n    MedianFinder() &#123;\n\n    &#125;\n\n    void addNum(int num) &#123;\n        if (down.empty() || num &lt;&#x3D; down.top()) &#123;&#x2F;&#x2F;down空 || t&lt;&#x3D;x\n            down.push(num);\n            if (down.size() &gt; up.size() + 1) &#123;&#x2F;&#x2F;down多2\n                up.push(down.top());\n                down.pop();\n            &#125;\n        &#125; else &#123;\n            up.push(num);\n            if (up.size() &gt; down.size()) &#123;&#x2F;&#x2F;up多1\n                down.push(up.top());\n                up.pop();\n            &#125;\n        &#125;\n    &#125;\n\n    double findMedian() &#123;\n        if ((down.size() + up.size()) % 2) return down.top();\n        return (down.top() + up.top()) &#x2F; 2.0;&#x2F;&#x2F; !!!&#x2F;2.0!!!\n    &#125;\n&#125;;\n\n\n&#x2F;**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder* obj &#x3D; new MedianFinder();\n * obj-&gt;addNum(num);\n * double param_2 &#x3D; obj-&gt;findMedian();\n *&#x2F;\n\n\n\n296.\n\n\n\n\n\n297.二叉树的序列化与反序列化class Codec &#123;\npublic:\n    string path;\n\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    string serialize(TreeNode* root) &#123;\n        dfs_s(root);\n        return path;\n    &#125;\n\n    void dfs_s(TreeNode* root) &#123;\n        if(!root) path +&#x3D; &quot;#,&quot;;\n        else &#123;\n            path +&#x3D; to_string(root-&gt;val) + &#39;,&#39;;\n            dfs_s(root-&gt;left);\n            dfs_s(root-&gt;right);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) &#123;\n        int u &#x3D; 0;\n        return dfs_d(data, u);\n    &#125;\n\n    TreeNode* dfs_d(string&amp; data, int&amp; u) &#123;\n        if(data[u] &#x3D;&#x3D; &#39;#&#39;) &#123;\n            u +&#x3D; 2;\n            return NULL;\n        &#125; else &#123;\n            int k &#x3D; u;\n            while(data[u] !&#x3D; &#39;,&#39;) u++;\n            auto root &#x3D; new TreeNode(stoi(data.substr(k, u - k)));&#x2F;&#x2F;\n            u++;&#x2F;&#x2F;跳过,号\n            root-&gt;left &#x3D; dfs_d(data, u);\n            root-&gt;right &#x3D; dfs_d(data, u);\n            return root;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n\n298.\n\n\n\n299.猜数字游戏\nclass Solution &#123;\npublic:\n    string getHint(string secret, string guess) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        for(auto c: secret) hash[c]++;\n        int tot &#x3D; 0;\n        for(auto c: guess)\n            if(hash[c]) &#123;&#x2F;&#x2F;\n                tot++;\n                hash[c]--;\n            &#125;\n\n        int bulls &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; secret.size(); i++)\n            if(secret[i] &#x3D;&#x3D; guess[i]) \n                bulls ++;\n        return to_string(bulls) + &quot;A&quot; + to_string(tot - bulls) + &quot;B&quot;;\n    &#125;\n&#125;;\n\n\n\n！！！300.最长递增子序列 不连续 LIS:DP 二分 贪心 难！\n&#x2F;&#x2F;300.最长递增子序列 不连续\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;15256&#x2F;\n&#x2F;&#x2F; DP O(n*n)\nclass Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; f(n);\n        for(int i &#x3D; 0; i &lt; n; i++)\n        &#123;\n            f[i] &#x3D; 1;  &#x2F;&#x2F; 只有a[i]一个数\n            for(int j &#x3D; 0; j &lt; i; j++)\n                if(nums[j] &lt; nums[i])\n                    f[i] &#x3D; max(f[i], f[j] + 1);\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res &#x3D; max(res, f[i]);  &#x2F;&#x2F; 枚举所有的f[i]，取最大值\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;287&#x2F;\n&#x2F;&#x2F;（动态规划 贪心 二分查找）O(nlogn)\nclass Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; q;\n        for (auto x: nums) &#123;\n            if (q.empty() || x &gt; q.back()) q.push_back(x);\n            else &#123;\n                if (x &lt;&#x3D; q[0]) q[0] &#x3D; x;&#x2F;&#x2F;\n                else &#123;&#x2F;&#x2F; 找到&lt;x的最后一个元素-&gt;r\n                    int l &#x3D; 0, r &#x3D; q.size() - 1;\n                    while (l &lt; r) &#123;\n                        int mid &#x3D; l + r + 1 &gt;&gt; 1;\n                        if (q[mid] &lt; x) l &#x3D; mid;&#x2F;&#x2F;[-&gt;\n                        else r &#x3D; mid - 1;\n                    &#125;\n                    q[r + 1] &#x3D; x;&#x2F;&#x2F;更新下一个为x\n                &#125;\n            &#125;\n        &#125;\n        return q.size();\n    &#125;\n&#125;;\n\n\n\n\n-301. 删除无效的括号 最少删 所有结果 难! 递归回溯剪枝 O(n*2^n)&#x2F;&#x2F;301.删除无效的括号 最少删 所有结果 难 递归回溯剪枝 O(n*2^n)\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;3852&#x2F;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;470996&#x2F;\nclass Solution &#123;\npublic:\n\tvector&lt;string&gt; ans;\n\n\tvector&lt;string&gt; removeInvalidParentheses(string s) &#123;\n\t\tint l &#x3D; 0, r &#x3D; 0;&#x2F;&#x2F;要删除多少(和)\n\t\tfor (auto x: s)\n\t\t\tif (x &#x3D;&#x3D; &#39;(&#39;) l ++ ;\n\t\t\telse if (x &#x3D;&#x3D; &#39;)&#39;) &#123;\n\t\t\t\tif (l &#x3D;&#x3D; 0) r ++ ;\n\t\t\t\telse l -- ;&#x2F;&#x2F;抵消一个&#39;(&#39;\n\t\t\t&#125;\n\n\t\tdfs(s, 0, &quot;&quot;, 0, l, r);\n\t\treturn ans;\n\t&#125;\n\t&#x2F;&#x2F;cnt&#x3D;l-r 还要删几个lr\n\tvoid dfs(string&amp; s, int u, string path, int cnt, int l, int r) &#123;\n\t\tif (u &#x3D;&#x3D; s.size()) &#123;\n\t\t\tif (!cnt) ans.push_back(path);&#x2F;&#x2F;l&#x3D;r\n\t\t\treturn;\n\t\t&#125;\n\n\t\tif (s[u] !&#x3D; &#39;(&#39; &amp;&amp; s[u] !&#x3D; &#39;)&#39;) dfs(s, u + 1, path + s[u], cnt, l, r);&#x2F;&#x2F;&#39;a&#39;加入\n\t\telse if (s[u] &#x3D;&#x3D; &#39;(&#39;) &#123;\n\t\t\tint k &#x3D; u;\n\t\t\twhile (k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; &#39;(&#39;) k ++ ;\n\t\t\t&#x2F;&#x2F;枚举 删掉连续k-u~0个&#39;(&#39;\t[u,k)\n\t\t\tl -&#x3D; k - u;\n\t\t\tfor (int i &#x3D; k - u; i &gt;&#x3D; 0; i -- ) &#123;\n\t\t\t\tif (l &gt;&#x3D; 0) dfs(s, k, path, cnt, l, r);\n\t\t\t\tpath +&#x3D; &#39;(&#39;;&#x2F;&#x2F;枚举少删一个&#39;(&#39;\n\t\t\t\tcnt ++, l ++ ;\n\t\t\t&#125;\n\t\t&#125; else if (s[u] &#x3D;&#x3D; &#39;)&#39;) &#123;\n\t\t\tint k &#x3D; u;\n\t\t\twhile (k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; &#39;)&#39;) k ++ ;\n\t\t\tr -&#x3D; k - u;\n\t\t\tfor (int i &#x3D; k - u; i &gt;&#x3D; 0; i -- ) &#123;\n\t\t\t\tif (cnt &gt;&#x3D; 0 &amp;&amp; r &gt;&#x3D; 0) dfs(s, k, path, cnt, l, r);&#x2F;&#x2F;cnt-- &gt;&#x3D;0\n\t\t\t\tpath +&#x3D; &#39;)&#39;;\n\t\t\t\tcnt --, r ++ ;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;;\n\n\n\n\n\n302.\n\n\n\n&#x2F;&#x2F; 【基础课基础算法 前缀和与差分 的 1D2D前缀和：S从1开始！不处理边界！】 复习！&#x2F;&#x2F; https://www.acwing.com/activity/content/punch_the_clock/11/\n303.区域和检索-数组不可变 1D前缀和class NumArray &#123;\npublic:\n    vector&lt;int&gt; s;&#x2F;&#x2F;前缀和 1开始 S(lr)&#x3D;S(r)-S(l-1)\n\n    NumArray(vector&lt;int&gt;&amp; nums) &#123;\n        s.resize(nums.size() + 1);&#x2F;&#x2F;0 1~n,多一个\n        for(int i &#x3D; 1; i &lt;&#x3D; nums.size(); i++) s[i] &#x3D; s[i - 1] + nums[i - 1];&#x2F;&#x2F;nums.size()\n    &#125;\n    \n    int sumRange(int l, int r) &#123;\n        ++l, ++r;&#x2F;&#x2F;\n        return s[r] - s[l - 1];\n    &#125;\n&#125;;\n\n\n\n\n304.二维区域和检索 - 矩阵不可变\nclass NumMatrix &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; s;\n\n    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if(matrix.empty() || matrix[0].empty()) return;\n        int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();\n        s &#x3D; vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(m + 1));&#x2F;&#x2F;\n        for(int i &#x3D; 1; i &lt;&#x3D; matrix.size(); i++)\n            for(int j &#x3D; 1; j &lt;&#x3D; matrix[0].size(); j++)\n                 s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + matrix[i- 1][j - 1];\n    &#125;\n    \n    int sumRegion(int x1, int y1, int x2, int y2) &#123;\n        ++x1, ++y1, ++x2, ++y2;&#x2F;&#x2F;\n        return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];\n    &#125;\n&#125;;\n\n\n\n\n305.\n\n\n\n&#x2F;&#x2F; https://www.acwing.com/activity/content/punch_the_clock/11/&#x2F;&#x2F; 复习：acwing791.高精度加法\n306.累加数 judge:未分割的fib 枚举串长xyz abc+高精度加法列竖式\nclass Solution &#123;\npublic:\n    string add(string x, string y) &#123;&#x2F;&#x2F;高精度加法模板 列竖式\n        vector&lt;int&gt; A, B, C;\n        for(int i &#x3D; x.size() - 1; i &gt;&#x3D; 0; i --) A.push_back(x[i] - &#39;0&#39;);\n        for(int i &#x3D; y.size() - 1; i &gt;&#x3D; 0; i --) B.push_back(y[i] - &#39;0&#39;);\n        for(int i &#x3D; 0, t &#x3D; 0; i &lt; A.size() || i &lt; B.size() || t; i++) &#123;&#x2F;&#x2F;低位到高位\n            if(i &lt; A.size()) t +&#x3D; A[i];\n            if(i &lt; B.size()) t +&#x3D; B[i];\n            C.push_back(t % 10);\n            t &#x2F;&#x3D; 10;\n        &#125;\n        string z;\n        for(int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i--) z +&#x3D; to_string(C[i]);&#x2F;&#x2F;int2str\n        return z;\n    &#125;\n\n    bool isAdditiveNumber(string num) &#123;\n        for(int i &#x3D; 0; i &lt; num.size(); i++)\n            for(int j &#x3D; i + 1; j + 1 &lt; num.size(); j++) &#123;&#x2F;&#x2F;\n                int a &#x3D; -1, b &#x3D; i, c &#x3D; j;\n                while(true) &#123;\n                    if(b - a &gt; 1 &amp;&amp; num[a + 1] &#x3D;&#x3D; &#39;0&#39; || c - b &gt; 1 &amp;&amp; num[b + 1] &#x3D;&#x3D; &#39;0&#39;) break;&#x2F;&#x2F;有前导0\n                    auto x &#x3D; num.substr(a + 1, b - a), y &#x3D; num.substr(b + 1, c - b);\n                    auto z &#x3D; add(x, y);\n                    if(num.substr(c + 1, z.size()) !&#x3D; z) break;&#x2F;&#x2F;第三个数不匹配\n                    a &#x3D; b, b &#x3D; c, c +&#x3D; z.size();\n                    if(c + 1 &#x3D;&#x3D; num.size()) return true;\n                &#125;\n            &#125;\n        return false;\n    &#125;\n&#125;;\n\n\n\n\n307.区域和检索-数组可修改 树状数组&#x2F;&#x2F;307.区域和检索-数组可修改\n&#x2F;&#x2F; 树状数组【优先】:区间查询[&lt;-前缀和]+单点修改[增加-&gt;] 见蓝书0x42 P202\n\n&#x2F;&#x2F;线段树常数大，代码多。所以一般能用树状数组就不用线段树。\n&#x2F;&#x2F; 线段树：区间查询求和RMQ+单点修改&#x2F;增加 区间修改：延迟标记\n&#x2F;&#x2F; 区间反转：splay平衡树\nclass NumArray &#123;\npublic:\n\tint n;\n\tvector&lt;int&gt; tr, nums;\n\n\tint lowbit(int x) &#123;\n\t\treturn x &amp; -x;\n\t&#125;\n\n\tint query(int x) &#123;&#x2F;&#x2F;x&#x3D;idx\n\t\tint res &#x3D; 0;\n\t\tfor(int i &#x3D; x; i; i -&#x3D; lowbit(i)) res +&#x3D; tr[i];&#x2F;&#x2F;前缀和\n\t\treturn res;\n\t&#125;\n\n\tvoid add(int x, int v) &#123;\n\t\tfor(int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) tr[i] +&#x3D; v;\n\t&#125;\n\n\tNumArray(vector&lt;int&gt;&amp; _nums) &#123;\n\t\tnums &#x3D; _nums;\n\t\tn &#x3D; nums.size();\n\t\ttr.resize(n + 1);&#x2F;&#x2F;1~n\n\t\t&#x2F;&#x2F;init tr\n\t\t&#x2F;&#x2F;O(nlogn)\n\t\t&#x2F;&#x2F; for(int i &#x3D; 0; i &lt; n; i++) add(i + 1, nums[i]);\n\t\t&#x2F;&#x2F;O(n) 没必要！\n\t\tfor(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\t\ttr[i] &#x3D; nums[i - 1];\n\t\t\tfor(int j &#x3D; i - 1; j &gt; i - lowbit(i); j -&#x3D; lowbit(j))&#x2F;&#x2F;左兄弟\n\t\t\t\ttr[i] +&#x3D; tr[j];\n\t\t&#125;\n\t&#125;\n\t\n\tvoid update(int i, int val) &#123;\n\t\tadd(i + 1, val - nums[i]);\n\t\tnums[i] &#x3D; val;\n\t&#125;\n\t\n\tint sumRange(int l, int r) &#123;\n\t\treturn query(r + 1) - query(l);\n\t&#125;\n&#125;;\n\n\n\n308.\n\n\n\n309.最佳买卖股票时机含冷冻期 画状态机DP\nclass Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        if(prices.empty()) return 0;\n        int n &#x3D; prices.size(), INF &#x3D; 1e8;\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(3, -INF));&#x2F;&#x2F;n*3 [0 1 2] \n        f[0][1] &#x3D; -prices[0], f[0][0] &#x3D; 0;\n        for(int i &#x3D; 1; i &lt; n; i++) &#123;\n            f[i][0] &#x3D; max(f[i - 1][0], f[i - 1][2]);\n            f[i][1] &#x3D; max(f[i - 1][0] - prices[i], f[i - 1][1]);&#x2F;&#x2F;-Pi!!!\n            f[i][2] &#x3D; f[i - 1][1] + prices[i];\n        &#125;\n        return max(f[n - 1][0], max(f[n - 1][1], f[n - 1][2]));\n    &#125;\n&#125;;\n\n\n\n310.最小高度树 minHeight的所有根 树形DP O(n)\n&#x2F;&#x2F; 树形DP：比贪心法更通用\n&#x2F;&#x2F; 向上向下算都有\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; g;\n    vector&lt;int&gt; d1, d2, p1, p2, up;\n\n    void dfs1(int u, int father) &#123;\n        for(int x: g[u]) &#123;\n            if(x &#x3D;&#x3D; father) continue;\n            dfs1(x, u);&#x2F;&#x2F;down向上递推\n            int d &#x3D; d1[x] + 1;\n            if(d &gt;&#x3D; d1[u]) &#123;\n                d2[u] &#x3D; d1[u], d1[u] &#x3D; d; \n                p2[u] &#x3D; p1[u], p1[u] &#x3D; x;\n            &#125; else if(d &gt; d2[u]) &#123;\n                d2[u] &#x3D; d;\n                p2[u] &#x3D; x;\n            &#125;\n        &#125;\n    &#125;\n\n    void dfs2(int u, int father) &#123;\n        for(int x: g[u]) &#123;\n            if(x &#x3D;&#x3D; father) continue;\n            if(p1[u] &#x3D;&#x3D; x) up[x] &#x3D; max(up[u], d2[u]) + 1;\n            else up[x] &#x3D; max(up[u], d1[u]) + 1;\n            dfs2(x, u);&#x2F;&#x2F;up向下递推\n        &#125;\n    &#125;\n\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n        g.resize(n);\n        d1 &#x3D; d2 &#x3D; p1 &#x3D; p2 &#x3D; up &#x3D; vector&lt;int&gt;(n);\n        &#x2F;&#x2F;无向图&#x2F;无根树 init 邻接表\n        for(auto&amp; e: edges) &#123;\n            int a &#x3D; e[0], b &#x3D; e[1];\n            g[a].push_back(b), g[b].push_back(a);\n        &#125;\n        dfs1(0, -1);&#x2F;&#x2F;cur, father\n        dfs2(0, -1);\n        \n        int mind &#x3D; n + 1;\n        for(int i &#x3D; 0; i &lt; n; i++) mind &#x3D; min(mind, max(up[i], d1[i]));\n        vector&lt;int&gt; res;\n        for(int i &#x3D; 0; i &lt; n; i++)\n            if(max(up[i], d1[i]) &#x3D;&#x3D; mind)\n                res.push_back(i);\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;344&#x2F;\n&#x2F;&#x2F; (贪心删点) O(n)\n&#x2F;&#x2F; 从叶子结点开始，每一轮删除所有叶子结点。\n&#x2F;&#x2F; 删除后，会出现新的叶子结点，此时再删除。\n&#x2F;&#x2F; 重复以上过程直到剩余 1 个或 2 个结点，此时这 1 个或 2 个结点就是答案。\nclass Solution &#123;\npublic:\n\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n        if (n &#x3D;&#x3D; 1)\n            return vector&lt;int&gt;&#123;0&#125;;\n\n        vector&lt;vector&lt;int&gt;&gt; tree(n);\n        vector&lt;int&gt; deg(n, 0);\n        for (auto &amp;e : edges) &#123;\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n            deg[e[0]]++;\n            deg[e[1]]++;\n        &#125;\n\n        vector&lt;int&gt; res;\n        for (int i &#x3D; 0; i &lt; n; i++)\n            if (deg[i] &#x3D;&#x3D; 1)\n                res.push_back(i);\n\n        while (n &gt; 2) &#123;\n            vector&lt;int&gt; next_res;\n            for (auto &amp;u : res) &#123;\n                n--;\n                for (auto &amp;v : tree[u]) &#123;\n                    deg[v]--;\n                    if (deg[v] &#x3D;&#x3D; 1)\n                        next_res.push_back(v);\n                &#125;\n            &#125;\n            res &#x3D; next_res;\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n311.\n\n\n\n\n\n312.戳气球 区间DP i,j为哨兵\n\n1 &lt;= n &lt;= 500 1.25*$10^8$ &#x2F; 3 &#x3D; 4000w+   (i,k,j)三元组\n\n&#x2F;&#x2F;312.戳气球 区间DP i,j为哨兵\nclass Solution &#123;\npublic:\n    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; a(n + 2, 1);&#x2F;&#x2F;a在nums左右端点各补1\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) a[i] &#x3D; nums[i - 1];\n        vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2));&#x2F;&#x2F;\n        for(int len &#x3D; 3; len &lt;&#x3D; n + 2; len++)&#x2F;&#x2F;3\n            for(int i &#x3D; 0; i + len - 1 &lt;&#x3D; n + 1; i++) &#123;\n                int j &#x3D; i + len - 1;&#x2F;&#x2F;\n                for(int k &#x3D; i + 1; k &lt; j; k++)\n                    f[i][j] &#x3D; max(f[i][j], f[i][k] + f[k][j] + a[i] * a[k] * a[j]);\n            &#125;\n        return f[0][n + 1];\n    &#125;\n&#125;;\n\n\n\n313.超级丑数 LC264.丑数II[2 3 5]-&gt;p[k] nth   快速insert 快速求min：堆！ O(nlogk)&lt;10^7 太晕了…\n&#x2F;&#x2F;313.超级丑数 LC264.丑数II[2 3 5]-&gt;p[k] nth\n&#x2F;&#x2F;快速insert 快速求min：堆！ O(nlogk)&lt;10^7  容斥原理会TLE\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;471111&#x2F;\nclass Solution &#123;\npublic:\n    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123;\n        typedef pair&lt;int, int&gt; PII;\n        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n        for (int x: primes) heap.push(&#123;x, 0&#125;);&#x2F;&#x2F;&#123;Pi, i&#125;\n        vector&lt;int&gt; q(n);&#x2F;&#x2F;结果序列0~n-1\n        q[0] &#x3D; 1;\n        for (int i &#x3D; 1; i &lt; n;) &#123;\n            auto t &#x3D; heap.top(); heap.pop();\n            if (t.first !&#x3D; q[i - 1]) q[i ++ ] &#x3D; t.first;&#x2F;&#x2F;q去重\n            int idx &#x3D; t.second, p &#x3D; t.first &#x2F; q[idx];&#x2F;&#x2F;p!!!\n            heap.push(&#123;p * q[idx + 1], idx + 1&#125;);&#x2F;&#x2F; t.first&#x2F;qi*q(i+1) 晕...\n        &#125;\n        return q[n - 1];\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;更清晰\nclass Solution &#123;\npublic:\n    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123;\n        #define PI pair&lt;int, int&gt;\n\n        int k &#x3D; primes.size();\n        vector&lt;int&gt; res(n), idx(k, 0);\n        priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt;&gt; heap;\n\n        res[0] &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; k; i++)\n            heap.push(make_pair(primes[i], i));\n\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            int mi &#x3D; heap.top().first;\n            res[i] &#x3D; mi;\n\n            while (heap.top().first &#x3D;&#x3D; mi) &#123;&#x2F;&#x2F;while &#x3D;&#x3D; 去重\n                int p &#x3D; heap.top().second;\n                heap.pop();\n                idx[p]++;&#x2F;&#x2F;对Primes[p]右移&quot;倍数&quot;\n\n                if (1ll * res[idx[p]] * primes[p] &lt;&#x3D; INT_MAX)\n                    heap.push(make_pair(res[idx[p]] * primes[p], p));&#x2F;&#x2F;3*2 2*3 insert\n            &#125;\n        &#125;\n\n        return res[n - 1];\n    &#125;\n&#125;;\n\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;16606&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n314.\n\n\n\n315.计算右侧小于当前元素的个数  树状数组tr[in]&#x3D;cnt O(nlogn)idx：值域  val：cnt\n\n\n\nclass Solution &#123;\npublic:\n    int n &#x3D; 20001;\n    vector&lt;int&gt; tr;\n\n    int lowbit(int x) &#123;\n        return x &amp; -x;\n    &#125;\n\n    int query(int x) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; x; i; i -&#x3D; lowbit(i)) res +&#x3D; tr[i];\n        return res;\n    &#125;\n\n    void add(int x, int v) &#123;\n        for(int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) tr[i] +&#x3D; v;\n    &#125;\n\n    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;\n        tr.resize(n + 1);&#x2F;&#x2F;tr[in] &#x3D; cnt\n        vector&lt;int&gt; res(nums.size());\n        for(int i &#x3D; nums.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n            int x &#x3D; nums[i] + 10001;&#x2F;&#x2F;0 1~20001\n            res[i] &#x3D; query(x - 1);\n            add(x, 1);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n316[&#x3D;1081].去除重复字母 得min字典序 贪心栈O(n) string stk in_stk last 大 后面还有 非空就删stk.back()贪心：\n\nclass Solution &#123;\npublic:\n    string removeDuplicateLetters(string s) &#123;\n        string stk;\n        unordered_map&lt;char, bool&gt; ins;&#x2F;&#x2F;s[i]在结果stk里存在否 in_stk\n        unordered_map&lt;char, int&gt; last;&#x2F;&#x2F;s中last pos\n        for(int i &#x3D; 0; i &lt; s.size(); i++) last[s[i]]  &#x3D; i;&#x2F;&#x2F;后覆盖前\n\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(ins[s[i]]) continue;&#x2F;&#x2F;去重\n            while(stk.size() &amp;&amp; stk.back() &gt; s[i] &amp;&amp; last[stk.back()] &gt; i) &#123;&#x2F;&#x2F;大 后面还有 非空就删\n                ins[stk.back()] &#x3D; false;\n                stk.pop_back();\n            &#125;\n            stk +&#x3D; s[i];\n            ins[s[i]] &#x3D; true;\n        &#125;\n        return stk;\n    &#125;\n&#125;;\n\n\n\n317.\n\n\n\n318.最大单词长度乘积 不含公共字母: 26 state &amp;&#x3D;&#x3D;0\n&#x2F;&#x2F;318.最大单词长度乘积 不含公共字母: 26 state &amp;&#x3D;&#x3D;0\n&#x2F;&#x2F; (暴力枚举) O(max(n*n,nL))\n&#x2F;&#x2F; 预处理出每个单词的二进制数字表示，二进制表示一共有 26 位，如果该单词含有字母 a，则第 0 位为 1，依次类推。\n&#x2F;&#x2F; 暴力枚举单词对，[如果两个单词的 按位与(&amp;) 为 0，则这两个单词可以被选择]，求长度的乘积和最大值作比较即可。\n\n&#x2F;&#x2F;集合元素很多：用哈希表unordered_map bitset\nclass Solution &#123;\npublic:\n    int maxProduct(vector&lt;string&gt;&amp; words) &#123;\n        vector&lt;int&gt; state;\n        \n        for(auto word: words) &#123;\n            int s &#x3D; 0;\n            for(auto c: word)\n                s |&#x3D; 1 &lt;&lt; (c - &#39;a&#39;);\n            state.push_back(s);\n        &#125;\n        \n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; words.size(); i++)\n            for(int j &#x3D; i + 1; j &lt; words.size(); j++)&#x2F;&#x2F;\n                if((state[i] &amp; state[j]) &#x3D;&#x3D; 0)\n                    res &#x3D; max(res, (int)(words[i].size() * words[j].size()));\n        return res;\n    &#125;\n&#125;;\n\n\n\n319.灯泡开关 小数论：i的倍数按一下 第n次几个亮(sqrt(n)个平方数)  idx亮&#x3D;按【奇数】次&#x3D;因子个数为【奇数】&lt;&#x3D;&gt;完全平方数 1 [3] 9\n&#x2F;&#x2F;319.灯泡开关 小数论：i的倍数按一下 第n次几个亮(sqrt(n)个平方数) \n&#x2F;&#x2F; idx亮&#x3D;按【奇数】次&#x3D;因子个数为【奇数】&lt;&#x3D;&gt;完全平方数 1 [3] 9\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;346&#x2F;\nclass Solution &#123;\npublic:\n    int bulbSwitch(int n) &#123;\n        return sqrt(n);\n    &#125;\n&#125;;\n\n\n\n\n320.\n\n\n\n！321.拼接最大数 保序 max字典序【类似318】 贪心合并 先选大的：证明方法1087\n&#x2F;&#x2F;321.拼接最大数 保序 max字典序\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;create-maximum-number&#x2F;solution&#x2F;pin-jie-zui-da-shu-by-leetcode-solution&#x2F;\n&#x2F;&#x2F;官方 单调栈\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;create-maximum-number&#x2F;solution&#x2F;c-dong-gui-tan-xin-dan-diao-zhan-by-_dc-qr4o&#x2F;\n&#x2F;&#x2F; 贪心算法合并两个最大子序列，参考【1754.构造字典序最大的合并字符串。】\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;largest-merge-of-two-strings&#x2F;solution&#x2F;c-shuang-zhi-zhen-bian-li-zui-you-xuan-z-g2dx&#x2F;\n\n&#x2F;*\n解题思路\n首先看完题目，知道所求为最大字典序\n如此以来，我们每次都要最优的选择字符，可以使用双指针表示现在取到哪个字符\n选择判断如下：\n两个字符串都没拿完\n如果两个开头字符不一致，选择更大的加入结果\n如果两个的开头字符一致，需要向后查找，选择后续中更大的哪个\n举例说明上述情况并验证正确性：\nca、cb：开头c相等，后续b&gt;a,选择第二个c取走（其实这种情况无所谓，因为b比c小，下一次还是拿c）\nca、cd：开头c相等，后续d&gt;a，【选择第二个c取走，保证后续d可以先取】，更大字典序\ncd、ce：同理，选择第二c\ncabc、cabce：【长度不等，匹配到一个字符串匹配完也没分出胜负，这时候需要取更长】的那条，这是因为【后续可能会出现更大的，比如这个例子中的e，但是没有发现】\n有一个字符串拿完了，直接拼接另一个字符串的剩余结果即可\n这题思路不难，但是考验自己的严谨性，希望都能自己实现\n*&#x2F;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;347&#x2F;\n&#x2F;&#x2F; (贪心) O(n3)\n&#x2F;&#x2F; 第3步，也用贪心来做，每次要选择将哪个数列的开头插入结果数列。我们比较两个数列的字典序，【优先从字典序大的数列中选】。\n&#x2F;&#x2F; 考察思路 和 证明为什么该做法正确！【选择第二个c取走，保证后续d可以先取】【长度不等，匹配到一个字符串匹配完也没分出胜负，这时候需要取更长】\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;\n        int n &#x3D; nums1.size(), m &#x3D; nums2.size();\n        vector&lt;int&gt; res(k, INT_MIN);\n        for (int i &#x3D; max(0, k - m); i &lt;&#x3D; min(k, n); i ++ ) &#123;&#x2F;&#x2F;2 m&lt;k:1 最少选k-m&gt;0个\n            vector&lt;int&gt; N &#x3D; maxArray(nums1, i);\n            vector&lt;int&gt; M &#x3D; maxArray(nums2, k - i);\n            vector&lt;int&gt; temp &#x3D; merge(N, M);\n            res &#x3D; max(res, temp);\n        &#125;\n        return res;\n    &#125;\n\n    vector&lt;int&gt; merge(vector&lt;int&gt;&amp; N, vector&lt;int&gt;&amp; M) &#123;\n        vector&lt;int&gt; res;\n        while (N.size() &amp;&amp; M.size())\n            if (N &gt; M)\n                res.push_back(N[0]), N.erase(N.begin());\n            else\n                res.push_back(M[0]), M.erase(M.begin());\n        while (N.size()) res.push_back(N[0]), N.erase(N.begin());\n        while (M.size()) res.push_back(M[0]), M.erase(M.begin());\n        return res;\n    &#125;\n\n    vector&lt;int&gt; maxArray(vector&lt;int&gt;&amp; nums, int k) &#123;&#x2F;&#x2F;nums中选k个 最大字典序\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; res(k);\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ ) &#123;\n        \tint x &#x3D; nums[i];\n            while (j &amp;&amp; res[j - 1] &lt; x &amp;&amp; j + n - i &gt; k) j -- ;&#x2F;&#x2F;j+n-i&gt;k 有资本去删\n            if (j &lt; k) res[j ++ ] &#x3D; x;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n322.零钱兑换 acw3完全背包 体积v 价值1面额&#x3D;体积 求最少个数，个数&#x3D;价值\n\n&#x2F;&#x2F;322.零钱兑换 acw3完全背包 体积v 价值1\n&#x2F;&#x2F; 装满背包最少需要多少价值的物品？\n&#x2F;&#x2F; 状态表示： f[j] 表示凑出 j 体积的钱，最少需要多少价值。\nclass Solution &#123;\npublic:\n\n    int INF &#x3D; 1000000000;\n\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;\n        vector&lt;int&gt; f(amount + 1, INF);\n        f[0] &#x3D; 0;\n        for (auto v: coins)\n            for (int j &#x3D; v; j &lt;&#x3D; amount; j ++ )\n                f[j] &#x3D; min(f[j], f[j - v] + 1);&#x2F;&#x2F;完全背包\n        if (f[amount] &#x3D;&#x3D; INF) f[amount] &#x3D; -1;\n        return f[amount];\n    &#125;\n&#125;;\n\n\n\n\n323.\n\n\n\n324.摆动排序II nth_element LC75三数排序 A(i)Tn&#x3D;O(n) Sn&#x3D;O(logn)\n\n快速选择算法：acw786第k个数\n\n\n&lt;++ &gt;-- | &gt;&#x3D; &lt;&#x3D; swap | &lt;&#x3D; &gt;&#x3D;\n\n\n三数排序LC75 荷兰国旗 三指针 cnt+覆盖\n\n\nclass Solution &#123;\npublic:\n    void wiggleSort(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        auto midptr &#x3D; nums.begin() + n &#x2F; 2;\n        nth_element(nums.begin(), midptr, nums.end());&#x2F;&#x2F;快速选择算法 找中位数\n        int mid &#x3D; *midptr;\n\n        #define A(i) nums[(i * 2 + 1) % (n | 1)] &#x2F;&#x2F;\n        &#x2F;&#x2F;三数排序\n        for (int i &#x3D; 0, j &#x3D; 0, k &#x3D; n - 1; i &lt;&#x3D; k;) &#123;&#x2F;&#x2F;ji k i&gt;k结束\n            if (A(i) &gt; mid) swap(A(i ++ ), A(j ++ ));&#x2F;&#x2F;0 1\n            else if (A(i) &lt; mid) swap(A(i), A(k -- ));&#x2F;&#x2F;2 i不动\n            else i ++ ;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n\n325.\n\n\n\n326.3的幂 n|3^19&#x3D;1162261467 计算器class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;\n        return n &gt; 0 &amp;&amp; 1162261467 % n &#x3D;&#x3D; 0;&#x2F;&#x2F;n|3^19&#x3D;1162261467 计算器\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;解法1：循环\nclass Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;\n        if(n&#x3D;&#x3D;1) return true;\n        long m&#x3D;1;\n        while(m&lt;n)\n        &#123;\n            m*&#x3D;3;\n            if(m&#x3D;&#x3D;n)\n                return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n&#x2F;&#x2F;解法2：递归\nclass Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;\n        if(n&#x3D;&#x3D;1) return true;\n        else if(n&#x3D;&#x3D;0) return false;\n        else return isPowerOfThree(n &#x2F; 3) &amp;&amp; n % 3 &#x3D;&#x3D; 0;&#x2F;&#x2F;\n    &#125;\n&#125;;\n\n\n\n\n！327.区间和的个数 前缀和 离散化+树状数组\n&#x2F;&#x2F;327.区间和的个数 前缀和 离散化+树状数组\n&#x2F;&#x2F; 手写平衡树 set不行：快速求在区间[]内的个数\n&#x2F;&#x2F; 保序离散化[hash表不行]+树状数组&#x3D;山寨版平衡树 O(nlogn)\n&#x2F;*\n所求为si - upper ~ s1 - lower这个范围内满足的区间个数\n这个区间个数利用树状数组快速求除，即f(s1 - lower) - f(s1 - upper -1)\n所以树状树组中维护的是 前缀和的个数\n前缀和也有0的情况， 所以需要加入到树状数组 即 add(get(0), 1);\n因为对所有前缀和进行了离散化， 0属于前缀和，因此也需要离散化。\n*&#x2F;\ntypedef long long LL;\n\nclass Solution &#123;\npublic:\n    int m;&#x2F;&#x2F;tr_len\n    vector&lt;int&gt; tr;&#x2F;&#x2F;存&lt;&#x3D;x的前缀和的个数:f\n    vector&lt;LL&gt; numbers;&#x2F;&#x2F;离散化\n\n    int get(LL x) &#123;&#x2F;&#x2F;lower_bound：&gt;&#x3D;x的第一个idx+1\n        return lower_bound(numbers.begin(), numbers.end(), x) - numbers.begin() + 1;\n    &#125;\n\n    int lowbit(int x) &#123;\n        return x &amp; -x;\n    &#125;\n\n    void add(int x, int v) &#123;\n        for (int i &#x3D; x; i &lt;&#x3D; m; i +&#x3D; lowbit(i)) tr[i] +&#x3D; v;\n    &#125;\n\n    int query(int x) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; x; i; i -&#x3D; lowbit(i)) res +&#x3D; tr[i];\n        return res;\n    &#125;\n\n    int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;LL&gt; s(n + 1);\n        numbers.push_back(0);&#x2F;&#x2F;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;\n            s[i] &#x3D; s[i - 1] + nums[i - 1];\n            numbers.push_back(s[i]);\n            numbers.push_back(s[i] - lower);\n            numbers.push_back(s[i] - upper - 1);\n        &#125;\n        sort(numbers.begin(), numbers.end());\n        numbers.erase(unique(numbers.begin(), numbers.end()), numbers.end());&#x2F;&#x2F;重复置end后\n        \n        m &#x3D; numbers.size();\n        tr.resize(m + 1);&#x2F;&#x2F;1~\n\n        int res &#x3D; 0;\n        add(get(0), 1);&#x2F;&#x2F;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;\n            res +&#x3D; query(get(s[i] - lower)) - query(get(s[i] - upper - 1));\n            add(get(s[i]), 1);\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;477194&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F; AcWing802 离散化复习！\nint find(int x)\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)&#x2F;&#x2F;&gt;&#x3D;x的第一个位置\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1;&#x2F;&#x2F;1~n\n&#125;\n\nvector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a)\n&#123;\n    int j &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; a.size(); i ++ )\n        if (!i || a[i] !&#x3D; a[i - 1])\n            a[j ++ ] &#x3D; a[i];\n    &#x2F;&#x2F; a[0] ~ a[j - 1] 所有a中不重复的数\n\n    return a.begin() + j;\n&#125;\n\n&#x2F;&#x2F;?待看ing\nhttps:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;5007&#x2F;\n&#x2F;*\n算法2\n(分治) O(nlogn)\n我们采取分治的思想。首先求出前缀和数组（包括开头的 0）sum，在这个数组上采用分治算法：每次将数组平均分为两部分，递归处理左右两部分内部的答案，然后将左右两部分内部从小到大排序，最后归并跨越左右两部分的答案。\n接下来讨论如何求跨越两部分的答案：假设左右两部分已经从小到大排好序，我们设 i 为右部分的某个位置，对于每个 i，都有一个在左部分连续的区间 [j, k]， 对应着合法答案的区间，即 sum[i] - sum[j], sum[i] - sum[j + 1], ..., sum[i] - sum[k] 都是在 [lower, upper] 中。随着 i 向右移动，这个区间也会整体向右移动。这给我们提供了滑动窗口的思想，我们实时维护这个窗口，可以在均摊 O(1) 的时间内找到每个 i 对应的区间。\n然后利用归并排序的思想将当前区间排序。\n时间复杂度\n时间和归并排序一样，每一层内部的时间复杂度为 O(n)，共 O(log⁡n) 层，故总时间复杂度为 O(nlog⁡n)。\n空间复杂度\n归并排序需要线性的额外空间。\nC++ 代码\n*&#x2F; \n#define LL long long\n\nclass Solution &#123;\npublic:\n    int ans;\n\n    void solve(vector&lt;LL&gt;&amp; sum, int l, int r, int lower, int upper) &#123;\n        if (l &#x3D;&#x3D; r)\n            return;\n\n        int mid &#x3D; (l + r) &gt;&gt; 1;\n        solve(sum, l, mid, lower, upper);\n        solve(sum, mid + 1, r, lower, upper);\n\n        for (int i &#x3D; mid + 1, j &#x3D; l, k &#x3D; l; i &lt;&#x3D; r; i++) &#123;\n            while (j &lt;&#x3D; mid &amp;&amp; sum[i] - sum[j] &gt; upper) j++;\n            while (k &lt;&#x3D; mid &amp;&amp; sum[i] - sum[k] &gt;&#x3D; lower) k++;\n            ans +&#x3D; k - j;\n        &#125;\n\n        vector&lt;LL&gt; cpy(r - l + 1);\n        int cnt &#x3D; 0;\n\n        int i &#x3D; l, j &#x3D; mid + 1;\n        while (i &lt;&#x3D; mid || j &lt;&#x3D; r) &#123;\n            if (i &#x3D;&#x3D; mid + 1) cpy[cnt++] &#x3D; sum[j++];\n            else if (j &#x3D;&#x3D; r + 1) cpy[cnt++] &#x3D; sum[i++];\n            else &#123;\n                if (sum[i] &lt; sum[j]) cpy[cnt++] &#x3D; sum[i++];\n                else cpy[cnt++] &#x3D; sum[j++];\n            &#125;\n        &#125;\n        for (int i &#x3D; l; i &lt;&#x3D; r; i++) sum[i] &#x3D; cpy[i - l];\n    &#125;\n\n    int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;LL&gt; sum(n + 1);\n        sum[0] &#x3D; 0;\n\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            sum[i] &#x3D; sum[i - 1] + nums[i - 1];\n\n        ans &#x3D; 0;\n        solve(sum, 0, n, lower, upper);\n\n        return ans;\n    &#125;\n&#125;;\n\n\n\n328. 奇偶链表oh ot eh et p&#x2F;&#x2F;328.奇偶链表oh ot eh et\nclass Solution &#123;\npublic:\n    ListNode* oddEvenList(ListNode* head) &#123;\n        if(!head || !head-&gt;next) return head;\n        auto oh &#x3D; head, ot &#x3D; oh;\n        auto eh &#x3D; head-&gt;next, et &#x3D; eh;\n        for(auto p &#x3D; head-&gt;next-&gt;next; p;) &#123;\n            ot &#x3D; ot-&gt;next &#x3D; p;&#x2F;&#x2F;\n            p &#x3D; p-&gt;next;\n            if (p) &#123;\n                et &#x3D; et-&gt;next &#x3D; p;\n                p &#x3D; p-&gt;next;\n            &#125;\n        &#125;\n        ot-&gt;next &#x3D; eh;\n        et-&gt;next &#x3D; NULL;\n        return oh;\n    &#125;\n&#125;;\n\n\n\n\n329. 矩阵中的最长递增路径 poj滑雪 DP的记忆化搜索写法 dfs按拓扑序来算\n&#x2F;&#x2F;记忆化搜索的思想是对于每个状态，只要搜索一次以后，记录下这个状态的最优值，以后在需要用到这个状态就不必要搜索了，因为无后效性，最优永远都不变。\nclass Solution &#123;\npublic:\n    int n, m;\n    vector&lt;vector&lt;int&gt;&gt; f, w;\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    int dp(int x, int y) &#123;&#x2F;&#x2F;xy为起点的最长距离v\n        auto&amp; v &#x3D; f[x][y];\n        if (v !&#x3D; -1) return v;&#x2F;&#x2F;记忆化搜索\n        v &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; w[x][y] &lt; w[a][b])&#x2F;&#x2F;\n                v &#x3D; max(v, dp(a, b) + 1);&#x2F;&#x2F;\n        &#125;\n        return v;\n    &#125;\n\n    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if (matrix.empty() || matrix[0].empty()) return 0;\n        w &#x3D; matrix;\n        n &#x3D; w.size(), m &#x3D; w[0].size();\n        f &#x3D; vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m, -1));&#x2F;&#x2F;-1\n\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            for (int j &#x3D; 0; j &lt; m; j ++ )\n                res &#x3D; max(res, dp(i, j));\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n330.按要求补齐数组 分类+贪心\n&#x2F;&#x2F;330.按要求补齐数组 分类+贪心\nclass Solution &#123;\npublic:\n    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;\n        long long x &#x3D; 1;\n        int i &#x3D; 0, res &#x3D; 0;\n        while (x &lt;&#x3D; n) &#123;&#x2F;&#x2F;[0,x)\n            if (i &lt; nums.size() &amp;&amp; nums[i] &lt;&#x3D; x) x +&#x3D; nums[i ++ ];&#x2F;&#x2F;\n            else &#123;\n                x +&#x3D; x;&#x2F;&#x2F;补充x\n                res ++ ;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n\n331. 验证二叉树的前序序列化 #唯一&#x2F;&#x2F;331.验证二叉树的前序序列化\n&#x2F;&#x2F; 如果递归还没结束但数组已经遍历完，或者递归结束但数组还没遍历完，则说明给定的序列不是一个合法的前序遍历。\nclass Solution &#123;\npublic:\n    bool ans &#x3D; true;\n    bool isValidSerialization(string preorder) &#123;\n        preorder +&#x3D; &#39;,&#39;;&#x2F;&#x2F;\n        int u &#x3D; 0;\n        dfs(preorder, u);\n        return ans &amp;&amp; u &#x3D;&#x3D; preorder.size();&#x2F;&#x2F;在该结束的时候没结束\n    &#125;\n\n    void dfs(string &amp;preorder, int &amp;u)\n    &#123;\n        if (u &#x3D;&#x3D; preorder.size())&#x2F;&#x2F;在不该结束的时候结束了\n        &#123;\n            ans &#x3D; false;\n            return;\n        &#125;\n        if (preorder[u] &#x3D;&#x3D; &#39;#&#39;)\n        &#123;\n            u +&#x3D; 2;\n            return;\n        &#125;\n        while (preorder[u] !&#x3D; &#39;,&#39;) u ++ ; u ++ ;\n        dfs(preorder, u);\n        dfs(preorder, u);&#x2F;&#x2F;右子树\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;357&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n    \n    \nclass Solution &#123;\npublic:\n    int k;\n    string s;\n\n    bool isValidSerialization(string _s) &#123;\n        k &#x3D; 0;\n        s &#x3D; _s + &#39;,&#39;;&#x2F;&#x2F;\n        if (!dfs()) return false;\n        return k &#x3D;&#x3D; s.size();\n    &#125;\n\n    bool dfs() &#123;\n    \t&#x2F;&#x2F; 递归下去一定是这个点有东西，如果发现应该有东西但是字符串没有了那就不合法\n        if (k &#x3D;&#x3D; s.size()) return false;\n        if (s[k] &#x3D;&#x3D; &#39;#&#39;) return k +&#x3D; 2, true;\n        while (s[k] !&#x3D; &#39;,&#39;) k ++ ;\n        k ++ ;\n        &#x2F;&#x2F; 再依次遍历左子树和右子树\n        return dfs() &amp;&amp; dfs();\n    &#125;\n&#125;;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;481298&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;法2 Java\nclass Solution &#123;\n    public boolean isValidSerialization(String preorder) &#123;\n        if (preorder &#x3D;&#x3D; null || preorder.length() &#x3D;&#x3D; 0) return false;\n        String[] chrs &#x3D; preorder.split(&quot;,&quot;);\n        int cnt &#x3D; 1;&#x2F;&#x2F;root多1\n        &#x2F;&#x2F; 一棵树总是以 # 封口，看出口数和封口数是否相等\n        &#x2F;&#x2F; 【根节点有两个出口】【每多个非空节点则会多一个出口，每个空节点为一个封口】\n        for (String chr : chrs) &#123;\n            if (cnt &#x3D;&#x3D; 0) return false;&#x2F;&#x2F;&gt;0,提前结束！\n            cnt +&#x3D; chr.equals(&quot;#&quot;) ? -1 : 1;&#x2F;&#x2F;\n        &#125;\n        return cnt &#x3D;&#x3D; 0;\n    &#125;\n&#125;\n\n作者：我要番茄锅\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;475450&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n332.重新安排行程 有向图求字典序最小的欧拉路径 蓝书P409 multiset平衡树 erase 回溯 入模拟ans栈&#x2F;&#x2F;复习：提高课 欧拉路径 同acw1124骑马修栅栏\n&#x2F;&#x2F;332.重新安排行程 有向图求字典序最小的欧拉路径 蓝书P409\nclass Solution &#123;\npublic:\n    unordered_map&lt;string, multiset&lt;string&gt;&gt; g;\n    vector&lt;string&gt; ans;\n\n    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;\n        for(auto&amp; e: tickets) g[e[0]].insert(e[1]);\n        dfs(&quot;JFK&quot;);&#x2F;&#x2F;回溯push 栈逆序\n        reverse(ans.begin(), ans.end());\n        return ans;\n    &#125;\n\n    void dfs(string u) &#123;\n        while(g[u].size()) &#123;\n            auto ver &#x3D; *g[u].begin();&#x2F;&#x2F;multiset平衡树 第一个元素就是min\n            g[u].erase(g[u].begin());&#x2F;&#x2F;erase &#x3D;&#x3D; 自动跳过visited head[x]\n            dfs(ver);\n        &#125;\n        ans.push_back(u);&#x2F;&#x2F;回溯 入模拟ans栈\n    &#125;\n&#125;;\n\n\n\n\n333.\n\n\n\n334.递增的三元子序列 300.二分LIS简化版 len&gt;&#x3D;3即可\n&#x2F;&#x2F;334.递增的三元子序列 300.二分LIS简化版 len&gt;&#x3D;3即可\n&#x2F;&#x2F; O(n) O(1)\nclass Solution &#123;\npublic:\n    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt;q(2, INT_MAX);\n        for(auto a: nums) &#123;\n            int k &#x3D; 2;\n            while(k &gt; 0 &amp;&amp; q[k - 1] &gt;&#x3D; a) k -- ;&#x2F;&#x2F;k:first &gt;&#x3D;a q递增\n            if(k &#x3D;&#x3D; 2) return true;&#x2F;&#x2F;len&gt;&#x3D;3\n            q[k] &#x3D; a;&#x2F;&#x2F;q[k]：k+1长LIS末尾min值\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n\n\n335.路径交叉 模拟分类特判向内卷&#x3D;&#x3D;第一类\n\nclass Solution &#123;\npublic:\n    bool isSelfCrossing(vector&lt;int&gt;&amp; x) &#123;\n        int n &#x3D; x.size();\n        if(n &lt;&#x3D; 3) return false;\n        for(int i &#x3D; 3; i &lt; n; i++) &#123;\n            if(x[i - 1] &lt;&#x3D; x[i - 3] &amp;&amp; x[i] &gt;&#x3D; x[i - 2]) return true;\n            if(i &gt;&#x3D; 4 &amp;&amp; x[i - 3] &#x3D;&#x3D; x[i - 1] &amp;&amp; x[i] + x[i - 4] &gt;&#x3D;  x[i - 2]) return true;\n            if(i &gt;&#x3D; 5 &amp;&amp; x[i - 3] &gt;&#x3D; x[i - 1] &amp;&amp; x[i - 1] + x[i - 5] &gt;&#x3D; x[i - 3] &amp;&amp; x[i - 2] &gt;&#x3D; x[i - 4] &amp;&amp; x[i] + x[i - 4] &gt;&#x3D; x[i - 2]) \n                return true;&#x2F;&#x2F;x[i - 3] &gt;&#x3D; x[i - 1] 才有i交的可能，而不是i-3&gt;i-5!!!i-2&gt;&#x3D;i-4 向外扩\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n\n\n336.回文对 O(nL^2) hash[x]&#x3D;i &gt;&#x3D; &lt; check\n&#x2F;&#x2F;336.回文对\n&#x2F;&#x2F;给定一组互不相同的单词，找出所有不同的索引对(i,j)：两词拼成回文串\nclass Solution &#123;\npublic:\n    bool check(string&amp; s) &#123;&#x2F;&#x2F;首尾双指针\n        for (int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; i ++, j -- )\n            if (s[i] !&#x3D; s[j])\n                return false;\n        return true;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) &#123;\n        unordered_map&lt;string, int&gt; hash;\n        for (int i &#x3D; 0; i &lt; words.size(); i ++ ) &#123;\n            auto w &#x3D; words[i];\n            reverse(w.begin(), w.end());\n            hash[w] &#x3D; i;&#x2F;&#x2F;idx\n        &#125;\n\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (int i &#x3D; 0; i &lt; words.size(); i ++ ) &#123;\n            auto w &#x3D; words[i];\n            for (int j &#x3D; 0; j &lt;&#x3D; w.size(); j ++ ) &#123;&#x2F;&#x2F;枚举分界点\n                auto left &#x3D; w.substr(0, j), right &#x3D; w.substr(j);\n                if (check(right) &amp;&amp; hash.count(left) &amp;&amp; hash[left] !&#x3D; i) &#x2F;&#x2F;i!&#x3D;j ij串长相等 只在情况一中算 避免重复！\n                \tres.push_back(&#123;i, hash[left]&#125;);&#x2F;&#x2F;&gt;&#x3D;\n                if (check(left) &amp;&amp; hash.count(right) &amp;&amp; hash[right] !&#x3D; i &amp;&amp; w.size() !&#x3D; words[hash[right]].size())\n                    res.push_back(&#123;hash[right], i&#125;);&#x2F;&#x2F;&lt;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n\n337.打家劫舍III 相隔max 树形DP：局部递归{不选, 选}\n&#x2F;&#x2F;337.打家劫舍III 相隔max 树形DP：局部递归\n&#x2F;&#x2F; 扩展多叉：基础课树形DP acw285.没有上司的舞会\n&#x2F;&#x2F; 310.最小高度树 有上有下 换根DP 难\nclass Solution &#123;\npublic:\n    int rob(TreeNode* root) &#123;\n        auto f &#x3D; dfs(root);\n        return max(f[0], f[1]);\n    &#125;\n\n    vector&lt;int&gt; dfs(TreeNode* u) &#123;\n        if(!u) return &#123;0, 0&#125;;\n        auto x &#x3D; dfs(u-&gt;left), y &#x3D; dfs(u-&gt;right);\n        return &#123;max(x[0], x[1]) + max(y[0], y[1]), x[0] + y[0] + u-&gt;val&#125;;&#x2F;&#x2F;&#123;不选, 选&#125;\n    &#125;\n&#125;;\n\n\n\n\n\n\n338.比特位计数 前n_bin_cnt1[] f[i] &#x3D; f[i &gt;&gt; 1] + (i &amp; 1);&#x2F;&#x2F;递推class Solution &#123;\npublic:\n    vector&lt;int&gt; countBits(int n) &#123;\n        vector&lt;int&gt; f(n + 1);\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n            f[i] &#x3D; f[i &gt;&gt; 1] + (i &amp; 1);&#x2F;&#x2F;递推\n        return f;\n    &#125;\n&#125;;\n\n\n\n339.\n\n\n\n340.\n\n\n\n\n\n341.扁平化嵌套列表迭代器 递归dfs、stk jump 设计\n&#x2F;&#x2F;341.扁平化嵌套列表迭代器 stk 设计\n&#x2F;&#x2F;递归版dfs\nclass NestedIterator &#123;\npublic:\n    vector&lt;int&gt; q;\n    int k;\n\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;\n        k &#x3D; 0;\n        for(auto&amp; l: nestedList) dfs(l);&#x2F;&#x2F;\n    &#125;\n\n    void dfs(NestedInteger&amp; l) &#123;\n       if(l.isInteger()) q.push_back(l.getInteger());\n       else &#123;\n            for(auto&amp; x: l.getList())\n                dfs(x);\n       &#125;\n    &#125;\n    \n    int next() &#123;\n        return q[k++];\n    &#125;\n    \n    bool hasNext() &#123;\n        return k &lt; q.size();\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;转非递归版 易错，用处不大了 Linux默认栈空间1M调大至mem空间即可，且系统stk更快\nclass NestedIterator &#123;\npublic:\n    struct Node &#123;\n        vector&lt;NestedInteger&gt; l;\n        int k;\n    &#125;;\n    stack&lt;Node&gt; stk;\n\n    void jump() &#123;&#x2F;&#x2F;跳到下一个int\n        while(stk.size()) &#123;\n            auto t &#x3D; stk.top();\n            if(t.k &#x3D;&#x3D; t.l.size()) &#123;&#x2F;&#x2F;\n                stk.pop();\n                continue;\n            &#125;\n            if(t.l[t.k].isInteger()) break;\n            stk.pop();&#x2F;&#x2F;删cur\n            stk.push(&#123;t.l, t.k + 1&#125;);&#x2F;&#x2F;内部k&#x3D;&#x3D;l.size() pop,先存下k+1\n            stk.push(&#123;t.l[t.k].getList(), 0&#125;);\n        &#125;\n    &#125;\n\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;\n        stk.push(&#123;nestedList, 0&#125;);\n        jump();\n    &#125;\n    \n    int next() &#123;\n        auto t &#x3D; stk.top();\n        stk.pop();\n        stk.push(&#123;t.l, t.k + 1&#125;);\n        jump();\n        return t.l[t.k].getInteger();\n    &#125;\n    \n    bool hasNext() &#123;\n        return stk.size();\n    &#125;\n&#125;;\n\n\n\n\n\n\n342.4的幂 &gt;0 平方数 只含因子2\nclass Solution &#123;\npublic:\n    bool isPowerOfFour(int n) &#123;\n        if(n &lt;&#x3D; 0) return false;&#x2F;&#x2F;&gt;0\n        int r &#x3D; sqrt(n);\n        if(r * r !&#x3D; n) return false;&#x2F;&#x2F;平方数\n        return (1 &lt;&lt; 30) % n &#x3D;&#x3D; 0;&#x2F;&#x2F;只含因子2\n        &#x2F;&#x2F; return (n &amp; -n) &#x3D;&#x3D; n;&#x2F;&#x2F;2的幂\n    &#125;\n&#125;;\n\n\n\n343.整数拆分 小学数奥:求最大乘积 证明！ 尽量分成3和2 &lt;&#x3D;2个2(n&gt;&#x3D;5 先满足3)\nclass Solution &#123;\npublic:\n    int integerBreak(int n) &#123;\n        if(n &lt;&#x3D; 3) return 1 * (n - 1);&#x2F;&#x2F;至少分成两个\n        int p &#x3D; 1;&#x2F;&#x2F;product\n        while(n &gt;&#x3D; 5) n -&#x3D; 3, p *&#x3D; 3;&#x2F;&#x2F;先满足3\n        return p * n;&#x2F;&#x2F;2 3 4&#x3D;2*2\n\n    &#125;\n&#125;;\n\n\n\n344.反转字符串 双指针swapclass Solution &#123;\npublic:\n    void reverseString(vector&lt;char&gt;&amp; s) &#123;\n        for(int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; i++, j--)\n            swap(s[i], s[j]);\n    &#125;\n&#125;;\n\n\n\n345.反转字符串中的元音字母 s.find(tolower(c)) !&#x3D; -1class Solution &#123;\npublic:\n    string s &#x3D; &quot;aeiou&quot;;\n    bool check(char c) &#123;\n        return s.find(tolower(c)) !&#x3D; -1;\n    &#125;\n\n    string reverseVowels(string s) &#123;\n        for(int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; i++, j--) &#123;\n            while(i &lt; j &amp;&amp; !check(s[i])) i++;\n            while(i &lt; j &amp;&amp; !check(s[j])) j--;\n            swap(s[i], s[j]);\n        &#125;\n        return s;\n    &#125;\n&#125;;\n\n\n\n346.\n\n\n\n347.前 K 个高频元素 计数排序\n&#x2F;&#x2F;347.前K个高频元素\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int, int&gt; cnt;\n        for(auto x: nums) cnt[x]++;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; s(n + 1);\n        for(auto [x, c]: cnt) s[c] ++;&#x2F;&#x2F;cnt&#x3D;c的元素个数\n        int i &#x3D; n, t &#x3D; 0;\n        while(t &lt; k) t +&#x3D; s[i -- ];&#x2F;&#x2F;freq前k 定i\n        vector&lt;int&gt; res;\n        for(auto [x, c]: cnt)\n            if(c &gt; i)\n                res.push_back(x);\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n348.\n\n\n\n349.两个数组的交集 unordered_set eraseclass Solution &#123;\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        unordered_set&lt;int&gt; S;&#x2F;&#x2F;去重\n        for(auto x: nums1) S.insert(x);\n        vector&lt;int&gt; res;\n        for(auto x: nums2) \n            if(S.count(x)) &#123;\n                res.push_back(x);\n                S.erase(x);&#x2F;&#x2F;永久消失！\n            &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n350.两个数组的交集II unordered_multiset S.erase(S.find(x))class Solution &#123;\npublic:\n    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        unordered_multiset&lt;int&gt; S;&#x2F;&#x2F;不去重\n        for(auto x: nums1) S.insert(x);\n        vector&lt;int&gt; res;\n        for(auto x: nums2) \n            if(S.count(x)) &#123;\n                res.push_back(x);\n                S.erase(S.find(x));&#x2F;&#x2F;只删一个迭代器\n            &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n351\n\n\n\n352.将数据流变为多个不相交区间\n&#x2F;&#x2F; addNum多: upper_bound&gt; lower_bound&gt;&#x3D;[返回迭代器！-&gt;！ 不存在则返回end] 排序的set+- O(logn) \n&#x2F;&#x2F; getIntervals少: O(n)遍历\ntypedef long long LL;\nconst LL INF &#x3D; 1e18;\ntypedef pair&lt;LL, LL&gt; PLL;\n\n#define x first\n#define y second\n\nclass SummaryRanges &#123;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    set&lt;PLL&gt; S;&#x2F;&#x2F;存区间&#123;x, y&#125;\n    \n    SummaryRanges() &#123;\n        S.insert(&#123;-INF, -INF&#125;), S.insert(&#123;INF, INF&#125;);&#x2F;&#x2F;哨兵\n    &#125;\n    \n    void addNum(int x) &#123;\n        auto r &#x3D; S.upper_bound(&#123;x, INT_MAX&#125;);&#x2F;&#x2F;L&gt;x_first &#123;x,INT_MIN&#125;&lt;&#123;x, x&#125;会错误的判断成功 判小一个！\n        auto l &#x3D; r;&#x2F;&#x2F;返回迭代器！\n        --l;\n        if(l-&gt;y &gt;&#x3D; x) return;\n        if(l-&gt;y &#x3D;&#x3D; x - 1 &amp;&amp; r-&gt;x &#x3D;&#x3D; x + 1) &#123;\n            S.insert(&#123;l-&gt;x, r-&gt;y&#125;);\n            S.erase(l), S.erase(r);\n        &#125; else if(l-&gt;y &#x3D;&#x3D; x - 1) &#123;\n            S.insert(&#123;l-&gt;x, x&#125;);\n            S.erase(l);\n        &#125; else if(r-&gt;x &#x3D;&#x3D; x + 1) &#123;\n            S.insert(&#123;x, r-&gt;y&#125;);\n            S.erase(r);\n        &#125; else &#123;\n            S.insert(&#123;x, x&#125;);\n        &#125;\n    &#125;\n    \n    vector&lt;vector&lt;int&gt;&gt; getIntervals() &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for(auto&amp; p: S)\n            if(p.x !&#x3D; -INF &amp;&amp; p.x !&#x3D; INF)\n                res.push_back(&#123;(int)p.x, (int)p.y&#125;);&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;373&#x2F;\n&#x2F;&#x2F; (平衡树) addNum: O(logn), getIntervals: O(n)\n&#x2F;&#x2F; 我们用 map&lt;int,int&gt; L, R 来动态维护所有区间，假设有个区间是[x, y]，则L[y] &#x3D; x并且R[x] &#x3D; y。\nclass SummaryRanges &#123;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    map&lt;int,int&gt;L, R;\n    SummaryRanges() &#123;\n\n    &#125;\n\n    void addNum(int val) &#123;\n        if (R.size())\n        &#123;\n            auto it &#x3D; R.upper_bound(val);\n            if (it !&#x3D; R.begin())\n            &#123;\n                -- it;\n                if (it-&gt;second &gt;&#x3D; val) return;\n            &#125;\n        &#125;\n        int right &#x3D; R.count(val + 1), left &#x3D; L.count(val - 1);&#x2F;&#x2F;\n        if (left &amp;&amp; right)\n        &#123;\n            R[L[val - 1]] &#x3D; R[val + 1];&#x2F;&#x2F;\n            L[R[val + 1]] &#x3D; L[val - 1];\n            R.erase(val + 1), L.erase(val - 1);\n        &#125;\n        else if (right)\n        &#123;\n            L[R[val + 1]] &#x3D; val;\n            R[val] &#x3D; R[val + 1];\n            R.erase(val + 1);\n        &#125;\n        else if (left)\n        &#123;\n            R[L[val - 1]] &#x3D; val;\n            L[val] &#x3D; L[val - 1];\n            L.erase(val - 1);\n        &#125;\n        else\n        &#123;\n            R[val] &#x3D; val;\n            L[val] &#x3D; val;\n        &#125;\n    &#125;\n    \n    vector&lt;vector&lt;int&gt;&gt; getIntervals() &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (auto &amp;p : R) res.push_back(&#123;(int)p.first, (int)p.second&#125;);\n        return res;\n    &#125;\n&#125;;\n\n\n\n353.\n\n\n\n354.俄罗斯套娃信封问题 LIS DP\nclass Solution &#123;\npublic:\n    int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; w) &#123;\n        int n &#x3D; w.size();\n        sort(w.begin(), w.end());&#x2F;&#x2F;\n        vector&lt;int&gt; f(n);\n        &#x2F;&#x2F;LIS DP\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            f[i] &#x3D; 1;&#x2F;&#x2F;\n            for(int j &#x3D; 0; j &lt; i; j++)\n                if(w[j][0] &lt; w[i][0] &amp;&amp; w[j][1] &lt; w[i][1])&#x2F;&#x2F;\n                    f[i] &#x3D; max(f[i], f[j] + 1);\n            res &#x3D; max(res, f[i]);\n        &#125;\n        return res;\n    &#125;  \n&#125;;\n\n\n\n—355.设计推特\n&#x2F;&#x2F;355.设计推特\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;487669&#x2F;\n&#x2F;*\ntweets:map(userID, vec&#123;ts, tweetID&#125;)\nfollows:map(userID, set_[userID])\nheap:vec(ts, tweetID, ptr_idx, userID) &#x2F;&#x2F;ts大根堆\n*&#x2F;\ntypedef pair&lt;int, int&gt; PII;\n\n#define x first\n#define y second\n\nclass Twitter &#123;\npublic:\n\t&#x2F;** Initialize your data structure here. *&#x2F;\n\tunordered_map&lt;int, vector&lt;PII&gt;&gt; tweets;\n\tunordered_map&lt;int, unordered_set&lt;int&gt;&gt; follows;\n\tint ts;\n\n\tTwitter() &#123;\n\t\tts &#x3D; 0;\n\t&#125;\n\n\t&#x2F;** Compose a new tweet. *&#x2F;\n\tvoid postTweet(int userId, int tweetId) &#123;\n\t\ttweets[userId].push_back(&#123;ts++, tweetId&#125;);&#x2F;&#x2F;tweets:map(userID, vec&#123;ts, tweetID&#125;)\n\t&#125;\n\n\t&#x2F;** Retrieve the 10 most recent tweet ids in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. *&#x2F;\n\tvector&lt;int&gt; getNewsFeed(int u) &#123;\n\t\tpriority_queue&lt;vector&lt;int&gt;&gt; heap;\n\t\tfollows[u].insert(u);&#x2F;&#x2F;\n\t\tfor (auto user: follows[u]) &#123;\n\t\t\tauto &amp;ts &#x3D; tweets[user];&#x2F;&#x2F;\n\t\t\tif (ts.size()) &#123;\n\t\t\t\tint i &#x3D; ts.size() - 1;&#x2F;&#x2F;\n\t\t\t\theap.push(&#123;ts[i].x, ts[i].y, i, user&#125;);&#x2F;&#x2F;heap:vec(ts, tweetID, ptr_idx, userID)\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tvector&lt;int&gt; res;\n\t\tfor (int i &#x3D; 0; i &lt; 10 &amp;&amp; heap.size(); i ++ ) &#123;\n\t\t\tauto t &#x3D; heap.top();\n\t\t\theap.pop();\n\t\t\tres.push_back(t[1]);&#x2F;&#x2F;tID\n\t\t\tint j &#x3D; t[2];\n\t\t\tif (j) &#123;\n\t\t\t\tj -- ;&#x2F;&#x2F;idx\n\t\t\t\tint user &#x3D; t[3];\n\t\t\t\tauto&amp; ts &#x3D; tweets[user];\n\t\t\t\theap.push(&#123;ts[j].x, ts[j].y, j, user&#125;);&#x2F;&#x2F;keep 10\n\t\t\t&#125;\n\t\t&#125;\n\n\t\treturn res;\n\t&#125;\n\n\t&#x2F;** Follower follows a followee. If the operation is invalid, it should be a no-op. *&#x2F;\n\tvoid follow(int x, int y) &#123;\n\t\tfollows[x].insert(y);&#x2F;&#x2F;follows:map(userID, set_[userID])\n\t&#125;\n\n\t&#x2F;** Follower unfollows a followee. If the operation is invalid, it should be a no-op. *&#x2F;\n\tvoid unfollow(int x, int y) &#123;\n\t\tfollows[x].erase(y);\n\t&#125;\n&#125;;\n\n\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;394&#x2F;\nclass Twitter &#123;\npublic:\n\t&#x2F;** Initialize your data structure here. *&#x2F;\n\tunordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; posts;\n\tunordered_map&lt;int, unordered_set&lt;int&gt;&gt; follows;\n\tint id &#x3D; 0;\n\tTwitter() &#123;\n\t&#125;\n\n\t&#x2F;** Compose a new tweet. *&#x2F;\n\tvoid postTweet(int userId, int tweetId) &#123;\n\t\tposts[userId].push_back(make_pair(id ++, tweetId));\n\t&#125;\n\n\t&#x2F;** Retrieve the 10 most recent tweet ids in the user&#39;s news feed. \n\tEach item in the news feed must be posted by users who the user followed or by the user herself. \n\tTweets must be ordered from most recent to least recent. *&#x2F;\n\tvector&lt;int&gt; getNewsFeed(int userId) &#123;\n\t\tvector&lt;pair&lt;int,int&gt;&gt; ps;\n\t\tfor (auto x : posts[userId]) ps.push_back(x);&#x2F;&#x2F;too much data???\n\t\tfor (auto follow : follows[userId])\n\t\t\tfor (auto x : posts[follow])\n\t\t\t\tps.push_back(x);&#x2F;&#x2F;\n\t\tsort(ps.rbegin(), ps.rend());&#x2F;&#x2F;ts倒排\n\t\tvector&lt;int&gt; res;\n\t\tfor (int i &#x3D; 0; i &lt; 10 &amp;&amp; i &lt; ps.size(); i ++ )\n\t\t\tres.push_back(ps[i].second);&#x2F;&#x2F;postID\n\t\treturn res;\n\t&#125;\n\n\t&#x2F;** Follower follows a followee. If the operation is invalid, it should be a no-op. *&#x2F;\n\tvoid follow(int followerId, int followeeId) &#123;\n\t\tif (followerId !&#x3D; followeeId)\n\t\t\tfollows[followerId].insert(followeeId);\n\t&#125;\n\n\t&#x2F;** Follower unfollows a followee. If the operation is invalid, it should be a no-op. *&#x2F;\n\tvoid unfollow(int followerId, int followeeId) &#123;\n\t\tfollows[followerId].erase(followeeId);\n\t&#125;\n&#125;;\n\n\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;grandyang.com&#x2F;leetcode&#x2F;355&#x2F;\nclass Twitter &#123;\npublic:\n\tTwitter() &#123;\n\t\ttime &#x3D; 0;\n\t&#125;\n\n\tvoid postTweet(int userId, int tweetId) &#123;\n\t\tfollow(userId, userId);&#x2F;&#x2F;\n\t\ttweets[userId].insert(&#123;time++, tweetId&#125;);\n\t&#125;\n\n\tvector&lt;int&gt; getNewsFeed(int userId) &#123;\n\t\tvector&lt;int&gt; res;\n\t\tmap&lt;int, int&gt; top10;\n\t\tfor (auto id : friends[userId]) &#123;\n\t\t\tfor (auto a : tweets[id]) &#123;\n\t\t\t\ttop10.insert(&#123;a.first, a.second&#125;);\n\t\t\t\tif (top10.size() &gt; 10) top10.erase(top10.begin());&#x2F;&#x2F;!!!\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor (auto a : top10) &#123;\n\t\t\tres.insert(res.begin(), a.second);&#x2F;&#x2F;tID\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n\t\n&#x2F;*\n\tvector&lt;int&gt; getNewsFeed(int userId) &#123;\n\t\tvector&lt;int&gt; res;\n\t\tpriority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q; &#x2F;&#x2F; ts升序队列，小顶堆\n\t\tfor (auto id : friends[userId]) &#123;\n\t\t\tfor (auto a : tweets[id]) &#123;\n\t\t\t\tif (q.size() &gt; 0 &amp;&amp; q.top().first &gt; a.first &amp;&amp; q.size() &gt; 10) break; &#x2F;&#x2F; a_ts is older\n\t\t\t\tq.push(a);\n\t\t\t\tif (q.size() &gt; 10) q.pop();&#x2F;&#x2F;\n\t\t\t&#125;\n\t\t&#125;\n\t\twhile (!q.empty()) &#123;\n\t\t\tres.insert(res.begin(), q.top().second);\n\t\t\tq.pop();\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n*&#x2F;\n\t\n\tvoid follow(int followerId, int followeeId) &#123;\n\t\tfriends[followerId].insert(followeeId);\n\t&#125;\n\n\tvoid unfollow(int followerId, int followeeId) &#123;\n\t\tif (followerId !&#x3D; followeeId) &#123;\n\t\t\tfriends[followerId].erase(followeeId);\n\t\t&#125;\n\t&#125;\n\nprivate:\n\tint time;\n\tunordered_map&lt;int, unordered_set&lt;int&gt;&gt; friends;\n\tunordered_map&lt;int, map&lt;int, int&gt;&gt; tweets;\n&#125;;\n\n\n\n\n\n356.\n\n\n\n\n\n357.计算各个位数不同的数字个数 n&lt;&#x3D;10 9*9*8…\nclass Solution &#123;\npublic:\n    int countNumbersWithUniqueDigits(int n) &#123;\n        n &#x3D; min(n, 10);&#x2F;&#x2F;n&gt;10无意义\n        if(!n) return 1;\n        vector&lt;int&gt; f(n + 1);&#x2F;&#x2F;满足要求的n位数个数\n        f[1] &#x3D; 9;\n        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)\n            f[i] &#x3D; f[i - 1] * (11 - i);&#x2F;&#x2F;f2&#x3D;f1*9 9*9*8*7...\n\n        int res &#x3D; 1;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) res +&#x3D; f[i];\n        return res;\n    &#125;\n&#125;;\n\n\n\n358.\n\n\n\n359.\n\n\n\n360.\n\n\n\n\n\n361.\n\n\n\n\n\n362.\n\n\n\n363.矩形区域不超过 K 的最大数值和 n&gt;m\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; s;\n\n    int get(int x1, int y1, int x2, int y2) &#123;&#x2F;&#x2F;2D子矩阵和\n        return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];\n    &#125;\n\n    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; w, int K) &#123;&#x2F;&#x2F;\n        int n &#x3D; w.size(), m &#x3D; w[0].size();\n        s &#x3D; vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(m + 1));\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )&#x2F;&#x2F;2D_S\n                s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1];\n\n        int res &#x3D; INT_MIN;\n        for (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )\n            for (int j &#x3D; i; j &lt;&#x3D; m; j ++ ) &#123;&#x2F;&#x2F;枚举左右边界\n                set&lt;int&gt; S;&#x2F;&#x2F;n长 纵向前缀和 O(m*m*nlogn)\n                S.insert(0);&#x2F;&#x2F;S0\n                for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ ) &#123;&#x2F;&#x2F;枚举下边界\n                    int si &#x3D; get(1, i, k, j);\n                    auto it &#x3D; S.lower_bound(si - K);&#x2F;&#x2F;&gt;&#x3D; min 二分找上边界\n                    if (it !&#x3D; S.end()) res &#x3D; max(res, si - *it);&#x2F;&#x2F;&lt;&#x3D;k的max子矩阵和 \n                    S.insert(si);\n                &#125;\n            &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n364.\n\n\n\n365.水壶问题 裴蜀定理 gcd(a,b)|c法一：(a,b)爆搜 看能否搜到c\n\n两杯子不可能同时既不空也不满，故可看作一个整体，只有四种op：+a-a+b-b\n因为半满非最优解！\n\n\n&#x2F;&#x2F;365.水壶问题 [直到装满或者倒空 一或两个来盛放:c&lt;&#x3D;a+b] (数学) gcd:O(logn)\n&#x2F;&#x2F; 水壶倒水的操作类似于辗转相减，所以能得到的最小粒度就是最大公约数 g。\n&#x2F;&#x2F; a，b和c分别除以g，此时满足a和b互质。很容易发现，【两个互质的数字可以凑出任意小于等于a+b的数字。】\n&#x2F;&#x2F; 裴蜀[贝祖Bezout]定理：对任意整数a,b,存在一对整数x,y,使ax+by&#x3D;c &lt;&#x3D;&gt; gcd(a,b)|c\n&#x2F;&#x2F; 扩展欧几里得算法，专门用来求解 ax+by&#x3D;gcd(a,b) 的整数解的 进而求乘法逆元\nclass Solution &#123;\npublic:\n    int gcd(int a, int b) &#123;&#x2F;&#x2F;辗转相除法\n        return b ? gcd(b, a % b) : a;\n    &#125;\n\n    bool canMeasureWater(int a, int b, int c) &#123;\n        if(c &gt; a + b) return false;&#x2F;&#x2F;不可能\n        return !c || c % gcd(a, b) &#x3D;&#x3D; 0;&#x2F;&#x2F;裴蜀定理\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;17&#x2F;\n&#x2F;&#x2F;扩展版：【今日头条2018暑期实习在线笔试题解】题目5 顺带求op次数\n&#x2F;&#x2F; 某个电容（无所谓哪一个）中的电量值等于c: c&lt;&#x3D;a || c&lt;&#x3D;b\n&#x2F;&#x2F; 一满一空\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n\n&#x2F;&#x2F;模板一 只要递归求出x1, y1就能求出x, y。\nLL gcd(LL a, LL b, LL &amp;x, LL &amp;y)&#x2F;&#x2F;\n&#123;\n    if (b &#x3D;&#x3D; 0)\n    &#123;\n        x &#x3D; 1, y &#x3D; 0;\n        return a;\n    &#125;\n    &#x2F;&#x2F;x &#x3D; y1, y &#x3D; x1 - ⌊a &#x2F; b⌋ * y1\n    LL q &#x3D; gcd(b, a % b, y, x);&#x2F;&#x2F;x&#x3D;y1 y&#x3D;x1\n    y -&#x3D; a &#x2F; b * x;&#x2F;&#x2F;y -&#x3D; a &#x2F; b * [x&#x3D;y1]\n    return q;\n&#125;\n\nint main()\n&#123;\n    int T;\n    cin &gt;&gt; T;\n    while (T--)\n    &#123;\n        LL a, b, c, x, y;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        int d &#x3D; gcd(a, b, x, y);\n        if (c &gt; a &amp;&amp; c &gt; b || c % d)&#x2F;&#x2F;\n        &#123;\n            cout &lt;&lt; 0 &lt;&lt; endl;\n            continue;\n        &#125;\n        if (c &#x3D;&#x3D; a || c &#x3D;&#x3D; b)\n        &#123;\n            cout &lt;&lt; 1 &lt;&lt; endl;\n            continue;\n        &#125;\n        if (y &gt; 0) swap(x, y), swap(a, b);\n        LL a2 &#x3D; a &#x2F; d, b2 &#x3D; b &#x2F; d;\n        x *&#x3D; c &#x2F; d, y *&#x3D; c &#x2F; d;\n        LL k &#x3D; x &#x2F; b2;&#x2F;&#x2F;k???\n        x -&#x3D; k * b2, y +&#x3D; k * a2;\n        LL res;&#x2F;&#x2F;x&gt;y\n        if (c &gt; a) res &#x3D; 2 * (x - y);\n        else res &#x3D; 2 * (x - y - 1);\n        x -&#x3D; b2, y +&#x3D; a2;&#x2F;&#x2F;x&lt;y\n        if (c &gt; b) res &#x3D; min(res, 2 * (y - x));\n        else res &#x3D; min(res, 2 * (y - x - 1));\n        cout &lt;&lt; res &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;17&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n&#x2F;&#x2F;蓝书P154 另一模板 bx*(a%b)y&#x3D;&#x3D;a*y+b*(x-⌊a&#x2F;b⌋*y)\nLL gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123;&#x2F;&#x2F;&amp;\n    if (!b) &#123;\n        x &#x3D; 1, y &#x3D; 0;\n        return a;\n    &#125;\n    LL d &#x3D; gcd(b, a % b, x, y);\n    LL z &#x3D; x; x &#x3D; y; y &#x3D; z - a &#x2F; b * y;&#x2F;&#x2F;\n    return d;\n&#125;\n\n\n\nhttps://zhuanlan.zhihu.com/p/114568325\n\n\nhttps://oi-wiki.org/math/number-theory/inverse/\n求乘法逆元&#x3D;&#x3D;exgcd\nhttps://www.acwing.com/blog/content/17/366.\n\n\n\n\n\n367.有效的完全平方数 不能sqrt 二分 &lt;&#x3D;sqrt(n)的max\nclass Solution &#123;\npublic:\n    typedef long long LL;\n    bool isPerfectSquare(int num) &#123;\n       int l &#x3D; 1 ,r &#x3D; num;\n       while (l &lt; r) &#123;\n           int mid &#x3D; l + 1ll + r &gt;&gt; 1;\n           if (mid &lt;&#x3D; num &#x2F; mid) l &#x3D; mid;&#x2F;&#x2F;&lt;&#x3D;sqrt(n)的max\n           else r &#x3D; mid - 1;\n       &#125; \n       return l * l &#x3D;&#x3D; num;\n\n    &#125;\n&#125;;\n\n\nclass Solution &#123;\npublic:\n    typedef long long LL;\n    bool isPerfectSquare(int num) &#123;\n       LL l &#x3D; 0 ,r &#x3D; num;\n       while (l &lt; r) &#123;\n           LL mid &#x3D; l + r + 1ll &gt;&gt; 1;\n           if (mid * mid &lt;&#x3D; num) l &#x3D; mid;\n           else r &#x3D; mid - 1;\n       &#125; \n       return l * l &#x3D;&#x3D; num;\n\n    &#125;\n&#125;;\n\n\n\n368.最大整除子集 DP 类似LIS if (nums[i] % nums[j] &#x3D;&#x3D; 0) f[i] &#x3D; max(f[i], f[j] + 1); 反向递推出答案\n&#x2F;&#x2F;368.最大整除子集\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123;\n\t\tsort(nums.begin(), nums.end());\n\t\tint n &#x3D; nums.size();\n\t\tvector&lt;int&gt; f(n);\n\t\t\n\t\tint k &#x3D; 0;  &#x2F;&#x2F; 记录f最大时的下标，即f[k]最大\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\tf[i] &#x3D; 1;\n\t\t\tfor (int j &#x3D; i - 1; j &gt;&#x3D; 0; j--)\n\t\t\t\tif (nums[i] % nums[j] &#x3D;&#x3D; 0)\n\t\t\t\t\tf[i] &#x3D; max(f[i], f[j] + 1);\n\t\t\tif (f[k] &lt; f[i]) k &#x3D; i;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 反向递推出答案\n\t\tvector&lt;int&gt; res;\n\t\twhile (true) &#123;\n\t\t\tres.push_back(nums[k]);\n\t\t\tif(f[k] &#x3D;&#x3D; 1) break;\n\t\t\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\t\t\tif (nums[k] % nums[i] &#x3D;&#x3D; 0 &amp;&amp; f[k] &#x3D;&#x3D; f[i] + 1) &#123;\n\t\t\t\t\tk &#x3D; i;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;*\n\t\tvector&lt;int&gt; res(1, nums[k]);\n\t\twhile (f[k] &gt; 1) &#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; k; i++)\n\t\t\t\tif (nums[k] % nums[i] &#x3D;&#x3D; 0 &amp;&amp; f[k] &#x3D;&#x3D; f[i] + 1) &#123;\n\t\t\t\t\tres.push_back(nums[i]);\n\t\t\t\t\tk &#x3D; i;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t&#125;\n\t\t*&#x2F;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n369.\n\n\n\n370.\n\n\n\n371.两整数之和 不用+- ^:不进位加法 进位:(a&amp;b)&lt;&lt;1 (unsigned) getSum(sum, carry);class Solution &#123;\npublic:\n    int getSum(int a, int b) &#123;\n        if(!b) return a;\n        int sum &#x3D; a ^ b, carry &#x3D; (unsigned)(a &amp; b) &lt;&lt; 1;&#x2F;&#x2F;unsigned溢出不报错\n        return getSum(sum, carry);&#x2F;&#x2F;转化param_ab int最多32次 carry&#x3D;0&amp;b&#x3D;0 ret a;\n    &#125;\n&#125;;\n\n\n\n\n\n372. 超级次方 快速幂:b从低到高的二进制拆分 qmi(superPow(a, b), 10) * qmi(a, k) % p;qmi模板: $o(logk)$ 的时间求出$a^k%p$\n\n变换转化子问题 递归\n\nclass Solution &#123;\npublic:\n    const int p &#x3D; 1337;\n\n    int qmi(int a, int b) &#123;\n        a %&#x3D; p;\n        int res &#x3D; 1;\n        while (b) &#123;&#x2F;&#x2F;b的二进制拆分 低到高\n            if (b &amp; 1) res &#x3D; res * a % p;\n            a &#x3D; a * a % p;\n            b &gt;&gt;&#x3D; 1;\n        &#125;\n        return res;\n    &#125;\n\n    int superPow(int a, vector&lt;int&gt;&amp; b) &#123;&#x2F;&#x2F;b数组\n        if (b.empty()) return 1;\n        int k &#x3D; b.back();&#x2F;&#x2F;last_digit\n        b.pop_back();\n        return qmi(superPow(a, b), 10) * qmi(a, k) % p;&#x2F;&#x2F;\n    &#125;\n&#125;;\n\n\n\n373.查找和最小的K对数字 多路归并 类似丑数\ntypedef vector&lt;int&gt; VI;\n\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b, int k) &#123;&#x2F;&#x2F;多路归并\n        if (a.empty() || b.empty()) return &#123;&#125;;\n        int n &#x3D; a.size(), m &#x3D; b.size();\n        priority_queue&lt;VI, vector&lt;VI&gt;, greater&lt;VI&gt;&gt; heap;&#x2F;&#x2F;小根堆\n        for (int i &#x3D; 0; i &lt; m; i ++ ) heap.push(&#123;b[i] + a[0], 0, i&#125;);&#x2F;&#x2F;第一列入堆\n        vector&lt;VI&gt; res;\n        while (k -- &amp;&amp; heap.size()) &#123;\n            auto t &#x3D; heap.top();\n            heap.pop();\n            res.push_back(&#123;a[t[1]], b[t[2]]&#125;);\n            if (t[1] + 1 &lt; n)\n                heap.push(&#123;a[t[1] + 1] + b[t[2]], t[1] + 1, t[2]&#125;);&#x2F;&#x2F;-&gt;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n374.猜数字大小 二分模板&#x2F;&#x2F;374.猜数字大小 二分模板\nclass Solution &#123;\npublic:\n    int guessNumber(int n) &#123;\n        int l &#x3D; 1, r &#x3D; n;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (long long)l + r &gt;&gt; 1;\n            if (guess(mid) &lt;&#x3D; 0) r &#x3D; mid;&#x2F;&#x2F;-1 0 1 &lt;&#x3D;num的max &#x3D;&#x3D;\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n\n\n！375.猜数字大小II 代价guess 至少需要拥有多少现金才能确保你能猜到 【区间DP】 min&lt;—f[i,j]:所有可能的目标值在[i,j]及所有可能猜法 worst的min\nclass Solution &#123;\npublic:\n    int getMoneyAmount(int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2));&#x2F;&#x2F;0~n+1\n        for (int len &#x3D; 2; len &lt;&#x3D; n; len ++ )\n            for (int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i ++ ) &#123;\n                int j &#x3D; i + len - 1;\n                f[i][j] &#x3D; INT_MAX;\n                for (int k &#x3D; i; k &lt;&#x3D; j; k ++ )\n                    f[i][j] &#x3D; min(f[i][j], max(f[i][k - 1], f[k + 1][j]) + k);\n            &#125;\n        return f[1][n];\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;区间DP模板写法\nfor (int len &#x3D; 2; len &lt;&#x3D; n; len ++ )\n    for (int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i ++ ) &#123;\n        int j &#x3D; i + len - 1;\n        \n    &#125;\n\n\n\n【贪心 DP O(n)极值点】376.摆动序列 最长子序列的长度 贪心O(n)只取极值点、DPO(n) dp_up[i] dp_down[i]&#x2F;&#x2F;376.摆动序列 最长子序列的长度 贪心O(n)只取波峰波谷极值点\n&#x2F;&#x2F; 中间有多少波峰波谷就有多少局部极值 max! 端点必选！\nclass Solution &#123;\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\n        if (nums.size() &lt;&#x3D; 2) return nums.size();\n        int res &#x3D; 2;&#x2F;&#x2F;\n        for (int i &#x3D; 1; i + 1 &lt; nums.size(); i ++ ) &#123;\n            int a &#x3D; nums[i - 1], b &#x3D; nums[i], c &#x3D; nums[i + 1];\n            if (b &gt; a &amp;&amp; b &gt; c || b &lt; a &amp;&amp; b &lt; c) res ++ ;&#x2F;&#x2F;极值点\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;DP O(n) dp_up[i] dp_down[i]\nclass Solution &#123;\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n        if (nums.empty())   return 0;\n        int n &#x3D; nums.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (2, 1));\n\n        dp[0][1] &#x3D; dp[0][0] &#x3D; 1;\n        for (int i &#x3D; 1; i&lt;n; i++)&#123;\n            dp[i][0] &#x3D; dp[i-1][0];&#x2F;&#x2F;&#x3D;&#x3D;\n            dp[i][1] &#x3D; dp[i-1][1];&#x2F;&#x2F;\n            if (nums[i] &gt; nums[i-1])\n                dp[i][1] &#x3D; max(dp[i][1], dp[i-1][0] + 1);\n            else if (nums[i] &lt; nums[i-1])\n                dp[i][0] &#x3D; max(dp[i][0], dp[i-1][1] + 1);\n        &#125;\n        return max(dp[n-1][0], dp[n-1][1]);\n    &#125;\n&#125;;\n\n作者：T-SHLoRk\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;4912&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n377.组合总和Ⅳ DP i≥nums[j]: f(i)+&#x3D;f(i−nums[j])\n&#x2F;&#x2F;377.组合总和Ⅳ\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;5005&#x2F;\n&#x2F;&#x2F; DP O(mn):状态数为 m 个，每次转移需要 n 次循环\n&#x2F;&#x2F; 枚举最后一个j 不重不漏 带顺序\n&#x2F;&#x2F; 设 f(i) 表示组成和为 i 的方案数。\n&#x2F;&#x2F; 初始时，f(0)&#x3D;1 其余为 0。\n&#x2F;&#x2F; 转移时，先枚举 i 然后枚举每个数字 nums[j]，如果 i≥nums[j]，令 f(i)+&#x3D;f(i−nums[j])。\n&#x2F;&#x2F; 最终答案为f(target)。\n\n&#x2F;&#x2F; 注意：\n&#x2F;&#x2F; bag:有限制的组合最优化问题 求M m 数量\n&#x2F;&#x2F; 此题和完全背包的区别，背包问题的状态表示是f(i,j)表示前i个物体，组成的重量为j，经过优化变成了一维。\n&#x2F;&#x2F; 【如果此题用完全背包解答，则会将顺序不同的序列算作相同的组合。】\n&#x2F;&#x2F; 此题在求解过程中整数会出现溢出，但由于答案在 32 位整数范围内，所以我们只需要在计算过程中模 INT_MAX 即可避免溢出）\n&#x2F;&#x2F; 进阶：\n&#x2F;&#x2F; 如果数组中存在负数，则有可能有无穷多个答案。\n&#x2F;&#x2F; 可以添加负数个数的限制。\nclass Solution &#123;\npublic:\n    int combinationSum4(vector&lt;int&gt;&amp; nums, int m) &#123;\n        vector&lt;unsigned&gt; f(m + 1);&#x2F;&#x2F;\n        f[0] &#x3D; 1;&#x2F;&#x2F;1种：空集\n        for(int i &#x3D; 1; i &lt;&#x3D; m; i++)\n            for(auto j: nums)\n                if(i &gt;&#x3D; j)\n                    f[i] +&#x3D; f[i - j];&#x2F;&#x2F;枚举最后一个j不重不漏 带顺序\n        return f[m];\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; dfs:可以按顺序从小到大枚举，如果无法满足 target 可以提前剪枝。但这样需要注意最后答案统计的是无序的情况，变为有序需要使用组合数学，对每种情况乘上各数字出现次数的阶乘\n\tint res;\n    vector&lt;int&gt; cur;      &#x2F;&#x2F; 当前组合\n    int curSum;             &#x2F;&#x2F; 当前组合的求和\n    map&lt;int, int&gt; dict;   &#x2F;&#x2F; 记忆化结构\n    void dfs(vector&lt;int&gt; nums, int tar) &#123;\n        if (curSum &#x3D;&#x3D; tar) &#123;\n            res ++;\n            return;\n        &#125;\n        if (curSum &gt; tar) &#123;\n            return;\n        &#125;\n        if (dict.find(tar - curSum) !&#x3D; dict.end()) &#123;\n            res +&#x3D; dict[tar - curSum] ;\n            return;\n        &#125;\n        int a &#x3D; res;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++) &#123;\n            cur.push_back(nums[i]);\n            curSum +&#x3D; nums[i];\n            dfs(nums, tar);\n            curSum -&#x3D; nums[i];\n            cur.pop_back();\n        &#125;\n        dict[tar - curSum] &#x3D; res - a;\n    &#125;\n\n&#x2F;&#x2F; 记忆化搜索就是DP: 思想是一样的，只是两种不同的实现方式。\n&#x2F;&#x2F; 在不确定转移顺序（保证转移没有环）的情况下，可以采用记忆化搜索\n&#x2F;&#x2F; 在确定转移顺序且需要注重效率的情况下，可以采用递推DP\n\n&#x2F;&#x2F; 这个题dp递推式与完全背包相同，但完全背包问题可以交换两层循环的顺序，这个题中两层循环的顺序却不能交换\n&#x2F;&#x2F; （交换后就是LC518的答案了）\n\n\n\n\n378.有序矩阵中第K小的元素 值域二分：向下向左 O(nlogL) L为值域 &lt;&#x3D;mid的个数&gt;&#x3D;k 的min\n\n&#x2F;&#x2F;378.有序矩阵中第K小的元素 &lt;&#x3D;mid的个数&gt;&#x3D;k 的min\n&#x2F;&#x2F;多路归并:维护一个K个元素的大顶堆，那么堆顶元素就是第K小的数 没有利用行有序和列有序的性质O(klogn)&lt;&#x3D;O(n*n*logK)\n&#x2F;&#x2F;二分搜索的题型分为两种，一种是索引二分(在有序数组中二分查找)，一种是值域二分（可行解在一个区间内查找，判断这个解是否成立）。这题就是经典的值域二分问题可以解的问题\n&#x2F;&#x2F;向下向左 O(nlogL) L为值域\nclass Solution &#123;\npublic:\n    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;\n        int l&#x3D; INT_MIN, r &#x3D; INT_MAX;\n        while(l &lt; r) &#123;\n            int mid &#x3D; (long long) l + r &gt;&gt; 1;\n            int j &#x3D; matrix[0].size() - 1, cnt &#x3D; 0;&#x2F;&#x2F;&lt;&#x3D;mid的个数\n            for(int i &#x3D; 0; i &lt; matrix.size(); i++) &#123;&#x2F;&#x2F;O(n)\n                while(j &gt;&#x3D; 0 &amp;&amp; matrix[i][j] &gt; mid) j--;\n                cnt +&#x3D; j + 1;&#x2F;&#x2F;0~j\n            &#125;\n            if(cnt &gt;&#x3D; k) r &#x3D; mid;&#x2F;&#x2F;\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n\n379.\n\n\n\n380.常数时间插入、删除和获取随机元素 随机索引:数组 hash[val]&#x3D;idx O(1)-:swap到最后 pop_back\n&#x2F;&#x2F;380.常数时间插入、删除和获取随机元素\n&#x2F;&#x2F;O(1)+-hash表map&#123;val,idx&#125; 随机索引：数组 swap到最后 pop_back\nclass RandomizedSet &#123;\npublic:\n    unordered_map&lt;int, int&gt; hash;\n    vector&lt;int&gt; nums;\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    RandomizedSet() &#123;\n\n    &#125;\n    \n    &#x2F;** Inserts a value to the set. Returns true if the set did not already contain the specified element. *&#x2F;\n    bool insert(int x) &#123;\n        if(hash.count(x) &#x3D;&#x3D; 0) &#123;\n            nums.push_back(x);\n            hash[x] &#x3D; nums.size() - 1;&#x2F;&#x2F;\n            return true;\n        &#125;\n        return false;\n    &#125;\n    \n    &#x2F;** Removes a value from the set. Returns true if the set contained the specified element. *&#x2F;\n    bool remove(int x) &#123;\n        if(hash.count(x)) &#123;\n            int y &#x3D; nums.back();\n            int px &#x3D; hash[x], py &#x3D; hash[y];\n            swap(nums[px], nums[py]);\n            swap(hash[x], hash[y]);\n            nums.pop_back();\n            hash.erase(x);\n            return true;\n        &#125;\n        return false;\n    &#125;\n    \n    &#x2F;** Get a random element from the set. *&#x2F;\n    int getRandom() &#123;\n        return nums[rand() % nums.size()];&#x2F;&#x2F;rand()\n    &#125;\n&#125;;\n\n\n\n381.O(1) 时间插入、删除和获取随机元素 - 允许重复 嵌套map(set)\nclass RandomizedCollection &#123;\npublic:\n    unordered_map&lt;int, unordered_set&lt;int&gt;&gt; hash;\n    vector&lt;int&gt; nums;\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    RandomizedCollection() &#123;\n\n    &#125;\n\n    &#x2F;** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. *&#x2F;\n    bool insert(int x) &#123;\n        bool res &#x3D; hash[x].empty();\n        nums.push_back(x);\n        hash[x].insert(nums.size() - 1);\n        return res;\n    &#125;\n\n    &#x2F;** Removes a value from the collection. Returns true if the collection contained the specified element. *&#x2F;\n    bool remove(int x) &#123;\n        if (hash[x].size()) &#123;\n            int px &#x3D; *hash[x].begin(), py &#x3D; nums.size() - 1;\n            int y &#x3D; nums.back();\n            swap(nums[px], nums[py]);\n            hash[x].erase(px), hash[x].insert(py);\n            hash[y].erase(py), hash[y].insert(px);\n            nums.pop_back();\n            hash[x].erase(py);\n            return true;\n        &#125;\n        return false;\n    &#125;\n\n    &#x2F;** Get a random element from the collection. *&#x2F;\n    int getRandom() &#123;\n        return nums[rand() % nums.size()];\n    &#125;\n&#125;;\n\n\n\n382.链表随机节点 S&#x3D;O(1) n大且未知 抽奖场景 蓄水池抽样algo!!!调和数列\n\nk最终被选上且没被换下来的概率&#x3D;1&#x2F;n\n&#x2F;&#x2F;382.链表随机节点 S&#x3D;O(1) n大且未知 抽奖场景 蓄水池抽样algo\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;14526&#x2F;\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;7a9ea6ece2af\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;shilinnpu&#x2F;p&#x2F;7810662.html\nclass Solution &#123;\npublic:\n    ListNode* h;\n\n    &#x2F;** @param head The linked list&#39;s head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. *&#x2F;\n    Solution(ListNode* head) &#123;\n        h &#x3D; head;\n    &#125;\n    \n    &#x2F;** Returns a random node&#39;s value. *&#x2F;\n    int getRandom() &#123;\n        int c &#x3D; -1, n &#x3D; 0;\n        for(auto p &#x3D; h; p; p &#x3D; p-&gt;next) &#123;\n            n++;\n            if(rand() % n &#x3D;&#x3D; 0) c &#x3D; p-&gt;val;&#x2F;&#x2F; 1&#x2F;n\n        &#125;\n        return c;\n    &#125;\n&#125;;\n\n\n\n383.赎金信 char_cntA&lt;&#x3D;B b++ a– 爽题class Solution &#123;\npublic:\n    bool canConstruct(string a, string b) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        for(auto c: b) hash[c]++;\n        for(auto c: a) &#123;\n            if(!hash[c]) return false;\n            else hash[c]--;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n\n\n384.打乱数组 1&#x2F;n! 乘法原理 swap(cur,之后) 洗牌算法(382)\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; a;\n    \n    Solution(vector&lt;int&gt;&amp; nums) &#123;\n        a &#x3D; nums;\n    &#125;\n    \n    &#x2F;** Resets the array to its original configuration and return it. *&#x2F;\n    vector&lt;int&gt; reset() &#123;\n        return a;\n    &#125;\n    \n    &#x2F;** Returns a random shuffling of the array. *&#x2F;\n    vector&lt;int&gt; shuffle() &#123;\n        auto b &#x3D; a;\n        int n &#x3D; a.size();\n        for(int i &#x3D; 0; i &lt; n; i++)\n            swap(b[i], b[i + rand() % (n - i)]);&#x2F;&#x2F;\n        return b;\n    &#125;\n&#125;;\n\n\n\n385.迷你语法分析器 dfs LC341的逆op:arr-&gt;NestedInteger [num,] ,\n&#x2F;&#x2F;385.迷你语法分析器 dfs LC341的逆op:arr-&gt;NestedInteger [num,] ,\nclass Solution &#123;\npublic:\n    NestedInteger deserialize(string s) &#123;\n        int u &#x3D; 0;\n        return dfs(s, u);\n    &#125;\n\n    NestedInteger dfs(string&amp; s, int&amp; u) &#123;\n        NestedInteger res;\n        if (s[u] &#x3D;&#x3D; &#39;[&#39;) &#123;\n            u ++ ;  &#x2F;&#x2F; 跳过左括号\n            while (s[u] !&#x3D; &#39;]&#39;) res.add(dfs(s, u));&#x2F;&#x2F;!!!\n            u ++ ;  &#x2F;&#x2F; 跳过右括号\n            if (u &lt; s.size() &amp;&amp; s[u] &#x3D;&#x3D; &#39;,&#39;) u ++ ;  &#x2F;&#x2F; 跳过逗号!!!\n        &#125; else &#123;\n            int k &#x3D; u;\n            while (k &lt; s.size() &amp;&amp; s[k] !&#x3D; &#39;,&#39; &amp;&amp; s[k] !&#x3D; &#39;]&#39;) k ++ ;\n            res.setInteger(stoi(s.substr(u, k - u)));\n            if (k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; &#39;,&#39;) k ++ ;  &#x2F;&#x2F; 跳过逗号\n            u &#x3D; k;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n386.字典序排数 1n的字典序 Trie 枚举首位+递归子树09&#x2F;&#x2F;386.字典序排数 1~n的字典序 Trie 枚举首位+递归子树0~9\n&#x2F;&#x2F; toStr sort O(logn*nlogn)\n&#x2F;&#x2F; Trie类似桶排序 O(nlogn)\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; res;\n\n    vector&lt;int&gt; lexicalOrder(int n) &#123;\n        for (int i &#x3D; 1 ; i &lt;&#x3D; 9 ; i ++) dfs(i, n);&#x2F;&#x2F;枚举首位\n        return res;\n    &#125;\n\n    void dfs(int now, int n) &#123;\n        if (now &gt; n) return;&#x2F;&#x2F;剪枝\n        res.push_back(now);\n        for (int i &#x3D; 0; i &lt;&#x3D; 9; i++)&#x2F;&#x2F;递归子树0~9\n            dfs(now * 10 + i, n);\n    &#125;\n&#125;;\n\n\n\n\n387.字符串中的第一个唯一字符 hashclass Solution &#123;\npublic:\n    int firstUniqChar(string s) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        for(auto c: s) hash[c]++;\n        for(int i &#x3D; 0; i&lt; s.size(); i++)\n            if(hash[s[i]] &#x3D;&#x3D; 1)\n                return i;\n        return -1;\n    &#125;\n&#125;;\n\n\n\n388.文件的最长绝对路径 str处理细节 stk维护最长路径每层串长\n&#x2F;&#x2F;388.文件的最长绝对路径 str处理细节 stk维护最长路径每层串长\nclass Solution &#123;\npublic:\n    int lengthLongestPath(string input) &#123;\n        stack&lt;int&gt; stk;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0, sum &#x3D; 0; i &lt; input.size(); i ++ ) &#123;&#x2F;&#x2F;跳过&#39;\\n&#39;\n            int k &#x3D; 0;\n            while (i &lt; input.size() &amp;&amp; input[i] &#x3D;&#x3D; &#39;\\t&#39;) i ++ , k ++ ;&#x2F;&#x2F;层数\n            while (stk.size() &gt; k) sum -&#x3D; stk.top(), stk.pop();&#x2F;&#x2F;回溯了\n            int j &#x3D; i;\n            while (j &lt; input.size() &amp;&amp; input[j] !&#x3D; &#39;\\n&#39;) j ++ ;&#x2F;&#x2F;\n            int len &#x3D; j - i;\n            stk.push(len), sum +&#x3D; len;\n            if (input.substr(i, len).find(&#39;.&#39;) !&#x3D; -1)\n                res &#x3D; max(res, sum + (int)stk.size() - 1);&#x2F;&#x2F;补stk.size()-1个&#39;&#x2F;&#39;\n            i &#x3D; j;&#x2F;&#x2F;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n389.找不同 打乱找多一个:【better】全^ 找2中的1 S&#x3D;O(1)  或者cnt++–余下的那个 [a,b]:cnt&#x2F;&#x2F;389.找不同 打乱找多一个：【better】全^ 找2中的1 S&#x3D;O(1)  或者cnt++--余下的那个 [a,b]:cnt\nclass Solution &#123;\npublic:\n    char findTheDifference(string s, string t) &#123;\n        int x &#x3D; 0;\n        for(auto c: s) x ^&#x3D; c;\n        for(auto c: t) x ^&#x3D; c;\n        return x;&#x2F;&#x2F;找2中的1\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;cnt++--余下的那个 [a,b]:cnt\nclass Solution &#123;\npublic:\n    char findTheDifference(string s, string t) &#123;\n        unordered_map&lt;char, int&gt; cnt;\n        for(auto c: t) cnt[c]++;\n        for(auto c: s) cnt[c]--;\n        for(auto [a, b]: cnt)\n            if(b) return a;\n        return -1;\n    &#125;\n&#125;;\n\n\n\n\n\n390.消除游戏 S型约瑟夫 f[n]&#x3D;2*g[n&#x2F;2] g[n]&#x3D;n+1-f[n]\n\n&#x2F;&#x2F;390.消除游戏 S型约瑟夫 DP Acwing1455.招聘\n&#x2F;&#x2F; 假设初始数组是[1,2,3,4,5,6]，最终剩下来的数字是f(6)，经过第一轮从左到右遍历后剩下来的是[2,4,6]，恰好是2 * [1,2,3]，\n&#x2F;&#x2F; 这时我们从[1,2,3]右侧开始遍历，最终剩下来的是b(3)，我们可以发现f(6)&#x3D;2∗b(3)。如果初始数组长度为奇数也可以得到一样的结果。【转化！】\nclass Solution &#123;\npublic:\n    int lastRemaining(int n) &#123;&#x2F;&#x2F;计算方法中向更小的n推迭代式 不动点定理~\n        return n &#x3D;&#x3D; 1 ? 1 : 2 * (n &#x2F; 2 + 1 - lastRemaining(n &#x2F; 2));\n    &#125;\n&#125;;\n\n\n\n\n391.完美矩形 1次4个 3次0个 总面积&#x3D;&#x3D; 没意义\n&#x2F;&#x2F;391.完美矩形\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;731117&#x2F;\nclass Solution &#123;\npublic:\n    bool isRectangleCover(vector&lt;vector&lt;int&gt;&gt;&amp; r) &#123;\n        map&lt;pair&lt;int, int&gt;, int&gt; cnt;\n        typedef long long LL;\n        LL sum &#x3D; 0;\n        for (auto x: r) &#123;\n            LL a &#x3D; x[0], b &#x3D; x[1], c &#x3D; x[2], d &#x3D; x[3];\n            ++ cnt[&#123;a, b&#125;], ++ cnt[&#123;a, d&#125;];\n            ++ cnt[&#123;c, b&#125;], ++ cnt[&#123;c, d&#125;];\n            sum +&#x3D; (c - a) * (d - b);\n        &#125;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (auto&amp; [x, y]: cnt)\n            if (y &#x3D;&#x3D; 1) res.push_back(&#123;x.first, x.second&#125;);\n            else if (y &#x3D;&#x3D; 3) return false;\n            else if (y &gt; 4) return false;\n        if (res.size() !&#x3D; 4) return false;\n        sort(res.begin(), res.end());\n        return sum &#x3D;&#x3D; (LL)(res[3][0] - res[0][0]) * (res[3][1] - res[0][1]);\n    &#125;\n&#125;;\n\n\n\n392.判断子序列 双指针&#x2F;&#x2F;392.判断子序列 双指针\nclass Solution &#123;\npublic:\n    bool isSubsequence(string s, string t) &#123;\n        int k &#x3D; 0;\n        for(auto c: t)\n            if(k &lt; s.size() &amp;&amp; c &#x3D;&#x3D; s[k])\n                k++;\n        return k &#x3D;&#x3D; s.size();\n    &#125;\n&#125;;\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;1772&#x2F;\n\n\n\n393.UTF-8编码验证 str&#x2F;&#x2F;393.UTF-8编码验证\nclass Solution &#123;\npublic:\n    int get(int x, int k) &#123;\n        return x &gt;&gt; k &amp; 1;\n    &#125;\n\n    bool validUtf8(vector&lt;int&gt;&amp; data) &#123;\n        for (int i &#x3D; 0; i &lt; data.size(); i ++ ) &#123;&#x2F;&#x2F;处理每一段\n            if (!get(data[i], 7)) continue;&#x2F;&#x2F;0xxxxxxx\n            int k &#x3D; 0;\n            while (k &lt;&#x3D; 4 &amp;&amp; get(data[i], 7 - k)) k ++ ;&#x2F;&#x2F;1110xxxx\n            if (k &#x3D;&#x3D; 1 || k &gt; 4) return false;&#x2F;&#x2F;k&#x3D;2 3 4个1\n            for (int j &#x3D; 1; j &lt;&#x3D; k - 1; j ++ ) &#123;\n                int t &#x3D; i + j;\n                if (t &gt;&#x3D; data.size()) return false;\n                if (!(get(data[t], 7) &amp;&amp; !get(data[t], 6))) return false;&#x2F;&#x2F;!10xxxxxx\n            &#125;\n            i +&#x3D; k - 1;&#x2F;&#x2F;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n\n\n\n394.字符串解码 递归游程解码&#x2F;&#x2F;394.字符串解码 递归游程解码\nclass Solution &#123;\npublic:\n    string decodeString(string s) &#123;\n        int u &#x3D; 0;\n        return dfs(s, u);\n    &#125;\n\n    string dfs(string&amp; s, int&amp; u) &#123;\n        string res;\n        while (u &lt; s.size() &amp;&amp; s[u] !&#x3D; &#39;]&#39;) &#123;\n            if (s[u] &gt;&#x3D; &#39;a&#39; &amp;&amp; s[u] &lt;&#x3D; &#39;z&#39; || s[u] &gt;&#x3D; &#39;A&#39; &amp;&amp; s[u] &lt;&#x3D; &#39;Z&#39;) res +&#x3D; s[u ++ ];&#x2F;&#x2F;u++\n            else if (s[u] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[u] &lt;&#x3D; &#39;9&#39;) &#123;\n                int k &#x3D; u;\n                while (s[k] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[k] &lt;&#x3D; &#39;9&#39;) k ++ ;\n                int x &#x3D; stoi(s.substr(u, k - u));&#x2F;&#x2F;x次\n                u &#x3D; k + 1;&#x2F;&#x2F;u跳过[\n                string y &#x3D; dfs(s, u);\n                u ++ ; &#x2F;&#x2F; u过滤掉右括号]\n                while (x -- ) res +&#x3D; y;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n395.至少有K个重复字符的最长子串 构造单调性 难！\n&#x2F;&#x2F;构造单调性 难！\nclass Solution &#123;\npublic:\n    int K;\n    unordered_map&lt;char, int&gt; cnt;\n    &#x2F;&#x2F;[j,i]区间内 x:不同字符数 y:满足&gt;&#x3D;K要求的不同字符数 O(1)维护\n    void add(char c, int&amp; x, int&amp; y) &#123;\n        if (!cnt[c]) x ++ ;\n        cnt[c] ++ ;\n        if (cnt[c] &#x3D;&#x3D; K) y ++ ;\n    &#125;\n\n    void del(char c, int&amp; x, int&amp; y) &#123;\n        if (cnt[c] &#x3D;&#x3D; K) y -- ;\n        cnt[c] -- ;\n        if (!cnt[c]) x -- ;\n    &#125;\n\n    int longestSubstring(string s, int _K) &#123;\n        K &#x3D; _K;\n        int res &#x3D; 0;\n        for (int k &#x3D; 1; k &lt;&#x3D; 26; k ++ ) &#123;&#x2F;&#x2F;枚举区间中最多包含的不同字符数k x&lt;&#x3D;k O(26*n)\n            cnt.clear();&#x2F;&#x2F;\n            for (int i &#x3D; 0, j &#x3D; 0, x &#x3D; 0, y &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n                add(s[i], x, y);\n                while (x &gt; k) del(s[j ++ ], x, y);&#x2F;&#x2F;x&lt;&#x3D;k\n                if (x &#x3D;&#x3D; y) res &#x3D; max(res, i - j + 1);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n396.旋转函数 错位相减 找规律 O(n)+O(1)s\n\nclass Solution &#123;\npublic:\n    int maxRotateFunction(vector&lt;int&gt;&amp; A) &#123;\n        typedef long long LL;\n        LL sum &#x3D; 0, cur &#x3D; 0;\n        for (auto c: A) sum +&#x3D; c;\n        int n &#x3D; A.size();\n        for (int i &#x3D; 0; i &lt; n; i ++ ) cur +&#x3D; i * A[i];\n        LL res &#x3D; cur;\n        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- ) &#123;\n            cur +&#x3D; sum - (LL)n * A[i];\n            res &#x3D; max(res, cur);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n397.整数替换 直接模拟+记忆化搜索(无效状态多) LL O(sqrt(n))分支多，但搜到的不同数字种数少 为保证不重复搜索，加入备忘录memo dp： O(sqrt(n))\n\n&#x2F;&#x2F; 类似LC周赛：吃橘子 实际没那么大！\n&#x2F;&#x2F;397.整数替换 直接模拟+记忆化搜索 LL O(sqrt(n))\n&#x2F;&#x2F; 分支多，但搜到的不同数字种数少 为保证不重复搜索，加入备忘录memo dp： O(sqrt(n))\ntypedef long long LL;\n\nclass Solution &#123;\npublic:\n    unordered_map&lt;LL, int&gt; dp;&#x2F;&#x2F;记忆化搜索\n\n    int integerReplacement(int n) &#123;\n        return f(n);\n    &#125;\n\n    int f(LL n) &#123;\n        if (dp.count(n)) return dp[n];&#x2F;&#x2F;\n        if (n &#x3D;&#x3D; 1) return 0;\n        if (n % 2 &#x3D;&#x3D; 0) return dp[n] &#x3D; f(n &#x2F; 2) + 1;\n        return dp[n] &#x3D; min(f(n + 1), f(n - 1)) + 1;\n    &#125;\n&#125;;\n\n\n\n\n398.随机数索引 map&lt;int,vector&gt;class Solution &#123;\npublic:\n    unordered_map&lt;int, vector&lt;int&gt;&gt; hash;\n\n    Solution(vector&lt;int&gt;&amp; nums) &#123;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)\n            hash[nums[i]].push_back(i);\n    &#125;\n    \n    int pick(int target) &#123;\n        return hash[target][rand() % hash[target].size()];\n    &#125;\n&#125;;\n\n\n\n399.除法求值 多源最短路Floyd ij&#x3D;ik*kj 路径唯一不求min&#x2F;&#x2F;蓝书P358 多源最短路 Floyd min(不经过k，经过k) DP\nclass Solution &#123;\npublic:\n    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123;\n        unordered_set&lt;string&gt; vers;\n        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; d;\n        for(int i &#x3D; 0; i &lt; equations.size(); i++) &#123;\n            auto a &#x3D; equations[i][0], b &#x3D; equations[i][1];\n            auto c &#x3D; values[i];\n            d[a][b] &#x3D; c, d[b][a] &#x3D; 1 &#x2F; c;\n            vers.insert(a), vers.insert(b);\n        &#125;\n\n        for(auto k: vers)\n            for(auto i: vers)\n                for(auto j: vers)\n                    if(d[i][k] &amp;&amp; d[k][j])\n                        d[i][j] &#x3D; d[i][k] * d[k][j];\n        \n        vector&lt;double&gt; res;\n        for(auto q: queries) &#123;\n            auto a &#x3D; q[0], b &#x3D; q[1];\n            if(d[a][b]) res.push_back(d[a][b]);\n            else res.push_back(-1);\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;3989&#x2F;\n\n\n\n400.第N位数字 1~串中nth ceil(n&#x2F;k)&#x3D;floor((n+k-1)&#x2F;k)\nclass Solution &#123;\npublic:\n    int findNthDigit(int n) &#123;\n        long long k &#x3D; 1, t &#x3D; 9, s &#x3D; 1;&#x2F;&#x2F;k位数 cnt first\n        while (n &gt; k * t) &#123;\n            n -&#x3D; k * t;&#x2F;&#x2F;!\n            k ++, t *&#x3D; 10, s *&#x3D; 10;&#x2F;&#x2F;len：1*9 2*90 3*900\n        &#125;\n        s +&#x3D; (n + k - 1) &#x2F; k - 1;&#x2F;&#x2F;k位数的第几个数\n        n &#x3D; n % k ? n % k : k;&#x2F;&#x2F;该数中的第几位!\n        return to_string(s)[n - 1] - &#39;0&#39;;&#x2F;&#x2F;itos\n    &#125;\n&#125;;\n\n\n\n\n\n\n401.二进制手表 n个亮的所有可能时间 bin_cnt_n个1 sprintf(str, “%d:%02d”, a, b);&#x2F;&#x2F;401.二进制手表 n个亮的所有可能时间 bin_cnt_n个1\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; readBinaryWatch(int num) &#123;\n        vector&lt;string&gt; res;\n        char str[10];\n        for(int i &#x3D; 0; i &lt; 1 &lt;&lt; 10; i++) &#123;&#x2F;&#x2F;2^10\n            int cnt &#x3D; 0;\n            for(int j &#x3D; 0; j &lt; 10; j++)\n                if(i &gt;&gt; j &amp; 1)\n                    cnt++;\n            if(cnt &#x3D;&#x3D; num) &#123;\n                int a &#x3D; i &gt;&gt; 6, b &#x3D; i &amp; 63;&#x2F;&#x2F;高4 低6\n                if(a &lt; 12 &amp;&amp; b &lt; 60) &#123;\n                    sprintf(str, &quot;%d:%02d&quot;, a, b);&#x2F;&#x2F;\n                    res.push_back(str);\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n!!!402.移掉K位数字 余下min 0,去前导0 经典贪心O(n):&#x3D;不删 单调栈res.back()&gt;x删pop\n&#x2F;&#x2F;402.移掉K位数字 余下min 去前导0 贪心O(n) &#x3D;不删\n&#x2F;&#x2F;&#x3D;，不删：把选择机会留给后面 if(提前)删，之后不能选择不删，且后面删是递归往前不断地删! 不够K位去尾得min\n&#x2F;&#x2F; DP：不能确定不同集合哪种更优，故搜M m n。 贪心：总有局部最优（需证明全局最优）。\nstring removeKdigits(string num, int k) &#123;\n\tk &#x3D; min(k, (int)num.size());\n    string res;\n    for(auto x : num) &#123;&#x2F;&#x2F;单调栈\n        while(res.size() &gt; 0 &amp;&amp; res.back() &gt; x &amp;&amp; k &gt; 0) &#123;&#x2F;&#x2F;&gt;删\n            res.pop_back();\n            k --;\n        &#125;\n        res.push_back(x);\n    &#125;\n    while(k -- ) res.pop_back();&#x2F;&#x2F;去尾\n    int n &#x3D; res.size(),i &#x3D; 0;\n    while(i &lt; n &amp;&amp; res[i] &#x3D;&#x3D; &#39;0&#39;) \n        i ++;\n    return n - i &#x3D;&#x3D; 0 ? &quot;0&quot; : res.substr(i, n - i);&#x2F;&#x2F;特判0 去前导0\n&#125;\n\n\n\n\n!!!403.青蛙过河O(n*n) 记忆化搜索 seq_DP dp(从x走y步) f hash(stone,idx)&#x2F;&#x2F; https://www.acwing.com/activity/content/problem/content/2802/\n&#x2F;&#x2F;403.青蛙过河 [y-1,y+1]步-&gt;x-&gt;y步\n&#x2F;&#x2F;O(n*n) 记忆化搜索 seq_DP dp() f[][] hash(stone,idx)\n&#x2F;&#x2F; if状态定义很多但很少被用到(无效状态很多)，记忆化搜索(func_call)就很快：只搜用到的。状态都被用到了就直接循环。\n\nconst int N &#x3D; 2010;\n\nint f[N][N];\n\nclass Solution &#123;\npublic:\n    unordered_map&lt;int, int&gt; hash;\n    vector&lt;int&gt; stones;\n\n    int dp(int x, int y) &#123;&#x2F;&#x2F;从x走y步：1 0  dp是函数 f是2D数组\n        if (f[x][y] !&#x3D; -1) return f[x][y];&#x2F;&#x2F;记忆化\n        f[x][y] &#x3D; 0;\n        for (int l &#x3D; max(1, y - 1); l &lt;&#x3D; y + 1; l ++ ) &#123;&#x2F;&#x2F;枚举l步到x\n            int z &#x3D; stones[x] - l;\n            if (hash.count(z)) &#123;\n                int p &#x3D; hash[z];\n                if (dp(p, l)) &#123;\n                    f[x][y] &#x3D; 1;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return f[x][y];\n    &#125;\n\n    bool canCross(vector&lt;int&gt;&amp; _stones) &#123;\n        stones &#x3D; _stones;\n        int n &#x3D; stones.size();\n        for (int i &#x3D; 0; i &lt; n; i ++ ) hash[stones[i]] &#x3D; i;&#x2F;&#x2F;(stones, idx)\n        memset(f, -1, sizeof f);\n        f[0][1] &#x3D; 1;&#x2F;&#x2F;T\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            if (dp(n - 1, i)) return true;&#x2F;&#x2F; ||\n        return false;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;迭代版本 Java\nclass Solution &#123;\n    public boolean canCross(int[] stones) &#123;\n        int n &#x3D; stones.length;\n        &#x2F;&#x2F;f[i,j]表示 i 这个下标的石头跳 j 步是否合法；\n        &#x2F;&#x2F;由于第一次跳 1 步，第二次最多跳 2 步，那么第 n - 1最多跳 n - 1步\n        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;\n            if (stones[i + 1] - stones[i] &gt; i + 1) return false;\n        &#125;\n        boolean[][] f &#x3D; new boolean[n][n + 1];\n        f[0][1] &#x3D; true;\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            for (int j &#x3D; 0; j &lt; i; j++) &#123;\n                int k &#x3D; stones[i] - stones[j];\n                if (k &gt; i) continue;\n                f[i][k] &#x3D; f[j][k - 1] || f[j][k] || f[j][k + 1];\n                if (i &#x3D;&#x3D; n - 1 &amp;&amp; f[i][k]) return true;\n            &#125;\n        &#125;\n        return false;\n\n    &#125;\n&#125;\n\n\n\n\n404.左叶子之和 dfsclass Solution &#123;\npublic:\n    int res &#x3D; 0;\n\n    int sumOfLeftLeaves(TreeNode* root) &#123;\n        dfs(root);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* root) &#123;\n        if(!root) return;\n        if(root-&gt;left)\n            if(!root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)\n                res +&#x3D; root-&gt;left-&gt;val;\n        dfs(root-&gt;left);\n        dfs(root-&gt;right);\n    &#125;\n&#125;;\n\n\n\n\n405.数字转换为十六进制数 有符号整数int&gt;&gt;&#x3D;会报错 &amp;0xf&#x2F;&#x2F;405.数字转换为十六进制数\nclass Solution &#123;\npublic:\n    string toHex(unsigned int num) &#123;&#x2F;&#x2F;有符号整数int&gt;&gt;&#x3D;会报错\n        if(!num) return &quot;0&quot;;\n        string res, nums &#x3D; &quot;0123456789abcdef&quot;;\n        while(num) &#123;\n            res +&#x3D; nums[num &amp; 0xf];\n            num &gt;&gt;&#x3D; 4;\n        &#125;\n        reverse(res.begin(), res.end());\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n!!!406.据身高重建队列 贪心 h,k:left&gt;&#x3D;h_cnt (二分+树状数组) O(n∗logn∗logn)\n&#x2F;&#x2F;406.根据身高重建队列 贪心 h,k:left&gt;&#x3D;h_cnt\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;9970&#x2F; 分支少 法3也可！\n&#x2F;&#x2F; (二分+树状数组) O(n∗logn∗logn)\nclass Solution &#123;\npublic:\n    int n;\n    vector&lt;int&gt; tr;\n\n    int lowbit(int x) &#123;\n        return x &amp; -x;\n    &#125;\n\n    void add(int x, int v) &#123;\n        for (int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) tr[i] +&#x3D; v;\n    &#125;\n\n    int query(int x) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; x; i; i -&#x3D; lowbit(i)) res +&#x3D; tr[i];\n        return res;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;\n        n &#x3D; people.size();\n        tr.resize(n + 1);&#x2F;&#x2F;tr:1~\n\n        sort(people.begin(), people.end(), [](vector&lt;int&gt;a, vector&lt;int&gt;b) &#123;\n            if (a[0] !&#x3D; b[0]) return a[0] &lt; b[0];\n            return a[1] &gt; b[1];\n        &#125;);&#x2F;&#x2F;\n\n        vector&lt;vector&lt;int&gt;&gt; res(n);\n        for (auto p: people) &#123;\n            int h &#x3D; p[0], k &#x3D; p[1];\n            int l &#x3D; 1, r &#x3D; n;\n            while (l &lt; r) &#123;\n                int mid &#x3D; l + r &gt;&gt; 1;\n                if (mid - query(mid) &gt;&#x3D; k + 1) r &#x3D; mid;&#x2F;&#x2F;k+1个空位]\n                else l &#x3D; mid + 1;\n            &#125;\n            res[r - 1] &#x3D; p;&#x2F;&#x2F;res:0~\n            add(r, 1);&#x2F;&#x2F;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;2610&#x2F; 反过来sort O(n*n)\n&#x2F;&#x2F; 先按身高从大到小排序，身高一样则按照k排序：身高大或k小意味着限制条件少，应该被优先考虑。\n&#x2F;&#x2F; 依次插入元素：由上一点，先进入res的元素不会被后进入的元素影响，因此每一次插入只需要考虑自己。它应该插到res的第b位，从而实现0到b-1的数字都比它大。\nclass Solution &#123;\npublic:\n\n  vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;\n    auto cmp &#x3D; [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123;\n            return a[0] &gt; b[0] || (a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1]);\n        &#125;;\n    sort(people.begin(), people.end(), cmp);\n    vector&lt;vector&lt;int&gt;&gt; res;\n    for(auto p:people) res.insert(res.begin()+p[1],p);&#x2F;&#x2F;\n    return res;\n  &#125;\n&#125;;\n\n\n\n\n【】算法思路是目的，ds is 步骤实现&#x2F;优化tools，切忌本末倒置！【】思路到代码：清楚定义每个状态的含义、怎么求值、求的顺序、why按此顺序算是对的 环环相扣！!!!407.接雨水II LC42的2D版 init边界f&#x3D;h入小跟堆 cur最终f&#x3D;max(cur真实h,t_min最终f) &gt;&#x3D; 决定了递增的搜索顺序\n&#x2F;&#x2F;407.接雨水II LC42的2D版\n&#x2F;&#x2F; 算法思路是目的，ds is 步骤实现&#x2F;优化tools，切忌本末倒置！\n&#x2F;&#x2F; 思路到代码：清楚定义每个状态的含义、怎么求值、求的顺序、why按此顺序算是对的 环环相扣！\n&#x2F;&#x2F; 堆：acw592.雨\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;737240&#x2F;\n&#x2F;&#x2F; 状态转移有环，非拓扑图：init边界f&#x3D;h入堆 从min开始搜...\n&#x2F;&#x2F; Dijkstra:第一次出堆是真实值 本题入堆时就是真实值了 证明思路类似\nclass Solution &#123;\npublic:\n    struct Cell &#123;\n        int h, x, y;\n        bool operator &lt; (const Cell&amp; t) const &#123;\n            return h &gt; t.h;&#x2F;&#x2F;小根堆\n        &#125;\n    &#125;;\n\n    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; h) &#123; \n        if (h.empty() || h[0].empty()) return 0;\n        int n &#x3D; h.size(), m &#x3D; h[0].size();\n        priority_queue&lt;Cell&gt; heap;&#x2F;&#x2F;\n        vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m));&#x2F;&#x2F;vis\n        &#x2F;&#x2F;边界入堆f&#x3D;h st\n        for (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n            st[i][0] &#x3D; st[i][m - 1] &#x3D; true;\n            heap.push(&#123;h[i][0], i, 0&#125;);\n            heap.push(&#123;h[i][m - 1], i, m - 1&#125;);\n        &#125;\n        for (int i &#x3D; 1; i + 1 &lt; m; i ++ ) &#123;\n            st[0][i] &#x3D; st[n - 1][i] &#x3D; true;\n            heap.push(&#123;h[0][i], 0, i&#125;);\n            heap.push(&#123;h[n - 1][i], n - 1, i&#125;);\n        &#125;\n\n        int res &#x3D; 0;\n        int dx[] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[] &#x3D; &#123;0, 1, 0, -1&#125;;\n        while (heap.size()) &#123;\n            auto t &#x3D; heap.top();&#x2F;&#x2F;接完水高度最小的一个\n            heap.pop();\n            res +&#x3D; t.h - h[t.x][t.y];&#x2F;&#x2F;t_min 最终-真实&#x3D;高度差\n\n            for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n                int x &#x3D; t.x + dx[i], y &#x3D; t.y + dy[i];\n                if (x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; !st[x][y]) &#123;&#x2F;&#x2F;!st\n                    heap.push(&#123;max(h[x][y], t.h), x, y&#125;);&#x2F;&#x2F;cur最终f&#x3D;max(cur真实h,t_min最终f) &gt;&#x3D; 决定了递增的搜索顺序\n                    st[x][y] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n408.\n\n\n\n409.最长回文串 能构造的~ k&#x2F;2*2&#x2F;&#x2F;409.最长回文串 能构造的~ k&#x2F;2*2\nclass Solution &#123;\npublic:\n    int longestPalindrome(string s) &#123;\n        unordered_map&lt;char, int&gt; hash;\n        for (auto c: s) hash[c] ++ ;\n        int res &#x3D; 0;\n        for (auto [a, k]: hash) res +&#x3D; k &#x2F; 2 * 2;&#x2F;&#x2F;\n        if (res &lt; s.size()) res ++ ;&#x2F;&#x2F;1个的 取一个放中间\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n!!!410.分割数组的最大值 最小化m段和的max_out 经典二分[&lt;-]+贪心[尽量放check:cnt&lt;&#x3D;m]贪心解：每段&gt;&#x3D;mid能放则放\n\n&#x2F;&#x2F;410.分割数组的最大值 最小化m段和的max_out 经典二分+贪心\n&#x2F;&#x2F; 证明贪心解正确的方法：贪心解&gt;&#x3D;(显然) 且 &lt;&#x3D;(调整法&lt;-转化)best解\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;最少分cnt段-&gt;贪心解：每段&gt;&#x3D;mid能放则放\n    bool check(vector&lt;int&gt;&amp; nums, int m, int mid) &#123;\n        int sum &#x3D; 0, cnt &#x3D; 0;&#x2F;&#x2F;该段和sum 段数cnt\n        for (auto x: nums) &#123;\n            if (x &gt; mid) return false;&#x2F;&#x2F;!!!\n            if (sum + x &gt; mid) &#123;&#x2F;&#x2F;入新段\n                cnt ++ ;\n                sum &#x3D; x;\n            &#125; else &#123;\n                sum +&#x3D; x;&#x2F;&#x2F;\n            &#125;\n        &#125;\n        if (sum) cnt ++ ;&#x2F;&#x2F;\n        return cnt &lt;&#x3D; m;&#x2F;&#x2F;就一定能再分割成m段\n    &#125;\n\n    int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123;\n        int l &#x3D; 0, r &#x3D; INT_MAX;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (long long)l + r &gt;&gt; 1;\n            if (check(nums, m, mid)) r &#x3D; mid;&#x2F;&#x2F;check&#x3D;&#x3D;T:每段都&lt;&#x3D;mid[max段长min化 &lt;-]时,(段数增加)最少能分成m段\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n\n411.\n\n\n\n\n\n412.Fizz Buzz 小模拟&#x2F;&#x2F;412.Fizz Buzz 小模拟\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; fizzBuzz(int n) &#123;\n        vector&lt;string&gt; res;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n            if(i % 3 &#x3D;&#x3D; 0 &amp;&amp; i % 5 &#x3D;&#x3D; 0) res.push_back(&quot;FizzBuzz&quot;);\n            else if(i % 3 &#x3D;&#x3D; 0) res.push_back(&quot;Fizz&quot;);\n            else if(i % 5 &#x3D;&#x3D; 0) res.push_back(&quot;Buzz&quot;);\n            else res.push_back(to_string(i));\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n413.等差数列划分 &lt;-求差分 值相等的[L+1~R]len&gt;&#x3D;2的子区间数 k*(k-1)&#x2F;2\n&#x2F;&#x2F;413.等差数列划分 &lt;-求差分 值相等的[L+1~R]len&gt;&#x3D;2的子区间数 k*(k-1)&#x2F;2\nclass Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        for (int i &#x3D; A.size() - 1; i &gt; 0; i -- ) A[i] -&#x3D; A[i - 1];&#x2F;&#x2F;\n        int res &#x3D; 0;\n        for (int i &#x3D; 1; i &lt; A.size(); i ++ ) &#123;\n            int j &#x3D; i;\n            while (j &lt; A.size() &amp;&amp; A[j] &#x3D;&#x3D; A[i]) j ++ ;\n            int k &#x3D; j - i;\n            res +&#x3D; k * (k - 1) &#x2F; 2;&#x2F;&#x2F;k&#x3D;1 0个;k&#x3D;2(len&#x3D;3) 1个\n            i &#x3D; j - 1;&#x2F;&#x2F;i++\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n414.第三大的数 讲过 分类讨论 s:abc中不同的数&#x2F;&#x2F;414.第三大的数\nclass Solution &#123;\npublic:\n    int thirdMax(vector&lt;int&gt;&amp; nums) &#123;\n        long long INF &#x3D; 1e10, a &#x3D; -INF, b &#x3D; -INF, c &#x3D; -INF, s &#x3D; 0;\n        for (auto x: nums) &#123;\n            if (x &gt; a) s ++, c &#x3D; b, b &#x3D; a, a &#x3D; x;\n            else if (x &lt; a &amp;&amp; x &gt; b) s ++, c &#x3D; b, b &#x3D; x;\n            else if (x &lt; b &amp;&amp; x &gt; c) s ++, c &#x3D; x;\n        &#125;\n        if (s &lt; 3) return a;&#x2F;&#x2F;s:abc中不同的数\n        return c;\n    &#125;\n&#125;;\n\n\n\n\n415.字符串相加 高精度加法模板 i&lt;A.size()||i&lt;B.size()||t 进位class Solution &#123;\npublic:\n    vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;&#x2F;&#x2F;高精度加法模板\n        vector&lt;int&gt; C;\n        for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size() || i &lt; B.size() || t; i ++ ) &#123;\n            if (i &lt; A.size()) t +&#x3D; A[i];&#x2F;&#x2F;t:进位\n            if (i &lt; B.size()) t +&#x3D; B[i];\n            C.push_back(t % 10);\n            t &#x2F;&#x3D; 10;\n        &#125;\n        return C;\n    &#125;\n\n    string addStrings(string a, string b) &#123;\n        vector&lt;int&gt; A, B;\n        for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i -- ) A.push_back(a[i] - &#39;0&#39;);\n        for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i -- ) B.push_back(b[i] - &#39;0&#39;);\n        auto C &#x3D; add(A, B);\n        string c;\n        for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i -- ) c +&#x3D; to_string(C[i]);\n        return c;\n    &#125;\n&#125;;\n\n\n\n\n416.分割等和子集 01bag模板 逆序 f[j] |&#x3D; f[j - x];&#x2F;&#x2F;bool\n&#x2F;&#x2F;416.分割等和子集 01bag模板 逆序\n&#x2F;&#x2F; 正常数组写法：dp[i][j]表示考虑前i个数字，是否存在子数组和为j。转移方程为\n&#x2F;&#x2F; dp[i][j] &#x3D; dp[i-1][j] | dp[i-1][j-nums[i]]（即不选第i个数字或者选第i个数字）\nclass Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size(), m &#x3D; 0;\n        for (auto x: nums) m +&#x3D; x;\n        if (m % 2) return false;\n        m &#x2F;&#x3D; 2;&#x2F;&#x2F;2分子集和\n        vector&lt;int&gt; f(m + 1);\n        f[0] &#x3D; 1;\n        for (auto x: nums)\n            for (int j &#x3D; m; j &gt;&#x3D; x; j -- )\n                f[j] |&#x3D; f[j - x];&#x2F;&#x2F;bool\n        return f[m];\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; bitset写法：代码的等价变形 O(nm&#x2F;64)\nclass Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        bitset&lt;10001&gt; f;&#x2F;&#x2F; sum&#x2F;2 &lt;&#x3D; 1w\n        f[0] &#x3D; 1;\n        int sum &#x3D; 0;\n        for (auto x: nums) &#123;\n            f |&#x3D; f &lt;&lt; x;\n            sum +&#x3D; x;\n        &#125;\n        if (sum % 2) return false;\n        return f[sum &#x2F; 2];\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;6416&#x2F;\n&#x2F;&#x2F; 在DP中由于每次都需要遍历1到target(target &#x3D; sum(nums) &#x2F; 2)，当数组元素很大的时候dp的速度就会很慢。\n&#x2F;&#x2F; 有些时候在dp数组里，大部分dp[i][j]都是0，dp数组很稀疏。\n\n&#x2F;&#x2F; dp[i][j]实际上是为了记录考虑前i个数字时，j是否能够通过子数组求和得到，\n&#x2F;&#x2F; 因此可以考虑用sum_set记录能够通过子数组求和得到的数字，每次扩充sum_set\n&#x2F;&#x2F; （即把原来sum_set里的每个元素都加上nums[i]，类似于dp里选取nums[i]这个元素的过程)，最后判断target是否在sum_set里即可。\n&#x2F;&#x2F;python3代码：\nclass Solution:\n    def canPartition(self, nums: List[int]) -&gt; bool:\n        s &#x3D; sum(nums) \n        if s % 2 !&#x3D; 0:\n            return False\n        target &#x3D; s &#x2F; 2\n        sum_set &#x3D; set([0]) # 初始的sum_set\n        for i in range(0, len(nums)):\n            to_add &#x3D; set() # 加上nums[i]，新增的子数组和\n            for ele in sum_set:\n                to_add.add(ele + nums[i])\n            sum_set |&#x3D; to_add # 扩充sum_set\n            if target in sum_set:\n                return True\n        return False\n\n        \n\n\n\n417.太平洋大西洋水流问题 floodfill b&#x2F;dfs if(st&amp;t)return; 1|2&#x3D;3&#x2F;&#x2F;太平洋大西洋水流问题 floodfill b&#x2F;dfs if(st[x][y]&amp;t)return;\nclass Solution &#123;\npublic:\n    int n, m;\n    vector&lt;vector&lt;int&gt;&gt; w;\n    vector&lt;vector&lt;int&gt;&gt; st;\n\n    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n\n    void dfs(int x, int y, int t) &#123;\n        if (st[x][y] &amp; t) return; &#x2F;&#x2F;1&amp;1&#x3D;2&amp;2&#x3D;1返回visited 1&amp;2&#x3D;2&amp;1&#x3D;0继续|&#x3D;3 !!!\n        st[x][y] |&#x3D; t; &#x2F;&#x2F;01 10 11\n        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#123;\n            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];\n            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; w[a][b] &gt;&#x3D; w[x][y])&#x2F;&#x2F;&gt;&#x3D;\n                dfs(a, b, t);\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        w &#x3D; matrix;\n        if (w.empty() || w[0].empty()) return &#123;&#125;;\n        n &#x3D; w.size(), m &#x3D; w[0].size();\n        st &#x3D; vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m));\n\n        for (int i &#x3D; 0; i &lt; n; i ++ ) dfs(i, 0, 1); &#x2F;&#x2F;4边界从低到高搜 1 2 3\n        for (int i &#x3D; 0; i &lt; m; i ++ ) dfs(0, i, 1);\n        for (int i &#x3D; 0; i &lt; n; i ++ ) dfs(i, m - 1, 2);\n        for (int i &#x3D; 0; i &lt; m; i ++ ) dfs(n - 1, i, 2);\n\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            for (int j &#x3D; 0; j &lt; m; j ++ )\n                if (st[i][j] &#x3D;&#x3D; 3) &#x2F;&#x2F;\n                    res.push_back(&#123;i, j&#125;);\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n418.\n\n\n\n419.甲板上的战舰 不相邻长条数 cnt左上角&#x2F;&#x2F;419.甲板上的战舰 可扩展为：求连通块数 并查集\nclass Solution &#123;\npublic:\n    int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        int res &#x3D; 0;&#x2F;&#x2F;不相邻长条数 cnt左上角\n        for (int i &#x3D; 0; i &lt; board.size(); i ++ )\n            for (int j &#x3D; 0; j &lt; board[i].size(); j ++ ) &#123;\n                if (i &gt; 0 &amp;&amp; board[i - 1][j] &#x3D;&#x3D; &#39;X&#39;) continue;\n                if (j &gt; 0 &amp;&amp; board[i][j - 1] &#x3D;&#x3D; &#39;X&#39;) continue;\n                if (board[i][j] &#x3D;&#x3D; &#39;X&#39;) res ++ ;\n            &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n420.强密码检验器 str to强min_step:+-改 分类讨论 dirty没意思 超繁琐…\n&#x2F;&#x2F;420.强密码检验器 str to强min_step:+-改 分类讨论 dirty没意思\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;738243&#x2F;\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;25738&#x2F;\nclass Solution &#123;\npublic:\n    int strongPasswordChecker(string s) &#123;\n        int a &#x3D; 0, b &#x3D; 0, c &#x3D; 0, n &#x3D; s.size(), k &#x3D; 0;&#x2F;&#x2F;0 a A数 k种字符\n        for (auto x: s) &#123;\n            if (x &gt;&#x3D; &#39;0&#39; &amp;&amp; x &lt;&#x3D; &#39;9&#39;) a &#x3D; 1;\n            else if (x &gt;&#x3D; &#39;a&#39; &amp;&amp; x &lt;&#x3D; &#39;z&#39;) b &#x3D; 1;\n            else if (x &gt;&#x3D; &#39;A&#39; &amp;&amp; x &lt;&#x3D; &#39;Z&#39;) c &#x3D; 1;\n        &#125;\n        k &#x3D; a + b + c; &#x2F;&#x2F;包含3类字符中的k类\n        if (n &lt; 6) return max(6 - n, 3 - k);&#x2F;&#x2F;【1】+ 分类讨论总结...\n        else &#123;\n            int p &#x3D; 0, del &#x3D; n - 20, res &#x3D; del;&#x2F;&#x2F;del&#x3D;n-20 需要删到&lt;&#x3D;20\n            int d[3] &#x3D; &#123;0&#125;;\n            for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;&#x2F;&#x2F;[&#x3D;&#x3D;]段长s\n                int j &#x3D; i;\n                while (j &lt; s.size() &amp;&amp; s[j] &#x3D;&#x3D; s[i]) j ++ ;\n                int s &#x3D; j - i;\n                i &#x3D; j - 1;\n                p +&#x3D; s &#x2F; 3; &#x2F;&#x2F;修改S&#x2F;3次\n                if (s &gt;&#x3D; 3) d[s % 3] ++ ;\n            &#125;\n            if (n &lt;&#x3D; 20) return max(p, 3 - k);&#x2F;&#x2F;【2】改+同时 有重叠\n            if (d[0] &amp;&amp; del &gt; 0) &#123; &#x2F;&#x2F;3*x -1 转化到第三类:最赚\n                int t &#x3D; min(d[0], del);\n                del -&#x3D; t;&#x2F;&#x2F;-\n                p -&#x3D; t;&#x2F;&#x2F;改\n            &#125;\n            if (d[1] &amp;&amp; del &gt; 0) &#123; &#x2F;&#x2F;3*x+1 -2\n                int t &#x3D; min(d[1] * 2, del);\n                del -&#x3D; t;\n                p -&#x3D; t &#x2F; 2;\n            &#125;\n            if (p &amp;&amp; del &gt; 0) &#123;\n                int t &#x3D; min(p * 3, del);\n                p -&#x3D; t &#x2F; 3; &#x2F;&#x2F;第三类-3个,p-&#x3D;1\n            &#125;\n            return res + max(p, 3 - k);&#x2F;&#x2F;【3】- 边改边+同时做\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;25738&#x2F;\n&#x2F;&#x2F; 贪心 堆 O(nlogn)\n\n\n\n421.数组中两个数的最大异或值 Trie例题&#x2F;&#x2F;421.数组中两个数的最大异或值\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; s;\n\n    void insert(int x) &#123;\n        int p &#x3D; 0;\n        for (int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;\n            int u &#x3D; x &gt;&gt; i &amp; 1;\n            if (!s[p][u]) s[p][u] &#x3D; s.size(), s.push_back(&#123;0, 0&#125;);&#x2F;&#x2F;++tot\n            p &#x3D; s[p][u];\n        &#125;\n    &#125;\n\n    int query(int x) &#123;\n        int p &#x3D; 0, res &#x3D; 0;\n        for (int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;\n            int u &#x3D; x &gt;&gt; i &amp; 1;\n            if (s[p][!u]) p &#x3D; s[p][!u], res |&#x3D; 1 &lt;&lt; i;&#x2F;&#x2F;不同：该位为1\n            else p &#x3D; s[p][u]; &#x2F;&#x2F;没!u再选u &#x3D;&#x3D; 0\n        &#125;\n        return res;&#x2F;&#x2F;就是^结果！\n    &#125;\n&#x2F;*\n    int query(int x) &#123;\n        int p &#x3D; 0, res &#x3D; 0;\n        for (int i &#x3D; 30; i &gt;&#x3D; 0; i -- ) &#123;\n            int u &#x3D; x &gt;&gt; i &amp; 1;\n            if (s[p][!u]) p &#x3D; s[p][!u], res &#x3D; (res &lt;&lt; 1) + !u;\n            else p &#x3D; s[p][u], res &#x3D; (res &lt;&lt; 1) + u; &#x2F;&#x2F;没!u再选u\n        &#125;\n        return res ^ x;\n    &#125;\n*&#x2F;\n    \n    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;\n        s.push_back(&#123;0, 0&#125;);\n        int res &#x3D; 0;\n        for (auto x: nums) &#123;\n            res &#x3D; max(res, query(x));\n            insert(x);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;549&#x2F;\n&#x2F;*\n假设当前节点是 p，我们用一个long long变量来存储当前边的哈希值。\n哈希函数可以随意发挥，只要保证冲突的概率很小即可。这里我使用了一种[完全不会冲突的哈希函数：?????]\nlong long变量的低32位存储p点到根节点的路径所表示的二进制数，第32位存储当前边是0还是1, 从第33位开始，表示节点p的高度。\n例如，假设p点到根节点的前缀是(101)2&#x3D;5，当前边是1，p在Trie树中的高度是27，则当前边的哈希值是：\n5+1∗2^32+27∗2^33\n*&#x2F;\nclass Solution &#123;\npublic:\n    typedef long long LL;\n\n    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;LL&gt; edge;\n        int res &#x3D; 0;\n        for (auto &amp;x : nums)\n        &#123;\n            LL pre &#x3D; 0, pre_op &#x3D; 0;\n            int xorr &#x3D; 0;\n            for (int i &#x3D; 30; i &gt;&#x3D; 0; i--)\n            &#123;\n                int next &#x3D; x &gt;&gt; i &amp; 1;\n                edge.insert(pre + next * (1LL &lt;&lt; 32) + i * (1LL &lt;&lt; 33));\n                if (edge.count(pre_op + !next * (1LL &lt;&lt; 32) + i * (1LL &lt;&lt; 33)))\n                &#123;\n                    xorr &#x3D; xorr * 2 + 1;&#x2F;&#x2F;走1\n                    pre_op &#x3D; pre_op * 2 + !next;\n                &#125;\n                else\n                &#123;\n                    xorr &lt;&lt;&#x3D; 1;&#x2F;&#x2F;走0\n                    pre_op &#x3D; pre_op * 2 + next;\n                &#125;\n                pre &#x3D; pre * 2 + next;&#x2F;&#x2F;更新前缀\n            &#125;\n            res &#x3D; max(res, xorr);&#x2F;&#x2F;xorr\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n\n422.\n\n\n\n423.从英文中重建数字&#x2F;&#x2F;423.从英文中重建数字\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;22477&#x2F;\nclass Solution &#123;\npublic:\n    string originalDigits(string s) &#123;\n        string name[] &#x3D; &#123;\n            &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;,\n            &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;\n        &#125;;\n        int ord[] &#x3D; &#123;0, 8, 3, 2, 6, 4, 5, 1, 7, 9&#125;;\n        unordered_map&lt;char, int&gt; cnt;\n        for (auto c: s) cnt[c] ++ ;\n        string res;\n        for (int x: ord) &#123;\n            while (true) &#123;&#x2F;&#x2F;处理多(未知)个相同 while true break;\n                bool flag &#x3D; true;\n                for (auto c: name[x])\n                    if (!cnt[c]) &#123;\n                        flag &#x3D; false;\n                        break;\n                    &#125;\n                if (flag) &#123;\n                    res +&#x3D; to_string(x);\n                    for (auto c: name[x]) cnt[c] -- ;&#x2F;&#x2F;zerozero 00\n                &#125;\n                else break;&#x2F;&#x2F;\n            &#125;\n        &#125;\n        sort(res.begin(), res.end());\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n424.替换后的最长重复字符&#x2F;&#x2F;424.替换后的最长重复字符\nclass Solution &#123;\npublic:\n\tint characterReplacement(string s, int k) &#123;\n\t\tint res &#x3D; 0;\n\t\tfor (char c &#x3D; &#39;A&#39;; c &lt;&#x3D; &#39;Z&#39;; c ++ ) &#123;\n\t\t\tfor (int i &#x3D; 0, j &#x3D; 0, cnt &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n\t\t\t\tif (s[i] &#x3D;&#x3D; c) cnt ++ ;&#x2F;&#x2F;A~Z搜一遍O(26n)，而不选择[j,i]中MaxCnt字母(会变)的cnt(会变) 无法证明单调性，不严谨！\n\t\t\t\twhile (i - j + 1 - cnt &gt; k) &#123;&#x2F;&#x2F;可最多替换k次\n\t\t\t\t\tif (s[j] &#x3D;&#x3D; c) cnt -- ;\n\t\t\t\t\tj ++ ;\n\t\t\t\t&#125;\n\t\t\t\tres &#x3D; max(res, i - j + 1);\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n425.\n\n\n\n426.\n\n427.建立四叉树\n&#x2F;&#x2F;427.建立四叉树\n&#x2F;&#x2F; Node(bool _val, bool _isLeaf)\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; s;\n    \n    Node* construct(vector&lt;vector&lt;int&gt;&gt;&amp; w) &#123;\n        int n &#x3D; w.size();\n        s &#x3D; vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(n + 1));\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n                s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1];\n        return dfs(1, 1, n, n);\n    &#125;\n\n    Node* dfs(int x1, int y1, int x2, int y2) &#123;\n        int n &#x3D; x2 - x1 + 1;\n        int sum &#x3D; s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1];&#x2F;&#x2F;2D子矩阵和\n        if (sum &#x3D;&#x3D; 0 || sum &#x3D;&#x3D; n * n) return new Node(!!sum, true);&#x2F;&#x2F;1 0\n        auto node &#x3D; new Node(0, false);&#x2F;&#x2F;内部节点val随意\n        int m &#x3D; n &#x2F; 2;&#x2F;&#x2F;4分\n        node-&gt;topLeft &#x3D; dfs(x1, y1, x1 + m - 1, y1 + m - 1);\n        node-&gt;topRight &#x3D; dfs(x1, y1 + m, x1 + m - 1, y2);\n        node-&gt;bottomLeft &#x3D; dfs(x1 + m, y1, x2, y1 + m - 1);\n        node-&gt;bottomRight &#x3D; dfs(x1 + m, y1 + m, x2, y2);\n        return node;\n    &#125;\n&#125;;\n\n\n\n\n428.\n\n\n\n429.N叉树的层序遍历 bfs&#x2F;&#x2F;429.N叉树的层序遍历 bfs\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        if (!root) return res;\n        queue&lt;Node*&gt; q;\n        q.push(root);\n        while (q.size()) &#123;\n            int len &#x3D; q.size();&#x2F;&#x2F;\n            vector&lt;int&gt; line;\n            while (len -- ) &#123;\n                auto t &#x3D; q.front();\n                q.pop();\n                line.push_back(t-&gt;val);\n                for (auto c: t-&gt;children) q.push(c);&#x2F;&#x2F;\n            &#125;\n            res.push_back(line);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n430.扁平化多级双向链表 递归插入子节点\n&#x2F;&#x2F;430.扁平化多级双向链表 递归插入子节点\n&#x2F;*\n&#x2F;&#x2F; Definition for a Node.\nclass Node &#123;\npublic:\n    int val;\n    Node* prev;\n    Node* next;\n    Node* child;\n&#125;;\n*&#x2F;\n\nclass Solution &#123;\npublic:\n    Node* flatten(Node* head) &#123;\n        auto res &#x3D; dfs(head);&#x2F;&#x2F;&#123;head,tail&#125;\n        return res[0];\n    &#125;\n\n    vector&lt;Node*&gt; dfs(Node* head) &#123;\n        if(!head) return &#123;NULL, NULL&#125;;\n        auto cur &#x3D; head, tail &#x3D; head;\n        while(cur) &#123;\n            tail &#x3D; cur;&#x2F;&#x2F;last非空\n            if(cur-&gt;child) &#123;\n                auto t &#x3D; dfs(cur-&gt;child);\n                cur-&gt;child &#x3D; NULL;&#x2F;&#x2F;!\n                t[1]-&gt;next &#x3D; cur-&gt;next;&#x2F;&#x2F;NULL\n                if(cur-&gt;next) cur-&gt;next-&gt;prev &#x3D; t[1];\n                cur-&gt;next &#x3D; t[0];\n                t[0]-&gt;prev &#x3D; cur;\n                cur &#x3D; t[1]-&gt;next;\n                tail &#x3D; t[1];&#x2F;&#x2F;last非空：cur-&gt;next &#x3D;&#x3D; NULL\n            &#125; else &#123;\n                cur &#x3D; cur-&gt;next;\n            &#125;\n        &#125;\n        return &#123;head, tail&#125;;\n    &#125;\n&#125;;\n\n\n\n\n\n431.\n\n\n\n432.全O(1)的数据结构 (+-mM)unordered_map+双向有序链表h t 细节超多！\n&#x2F;&#x2F;432.全O(1)的数据结构 (+-mM)unordered_map+双向有序链表h t\nclass AllOne &#123;\npublic:\n    struct Node &#123;\n        Node *left, *right;\n        int val;&#x2F;&#x2F;cnt\n        unordered_set&lt;string&gt; S;\n\n        Node (int _val) &#123;\n            val &#x3D; _val;\n            left &#x3D; right &#x3D; NULL;\n        &#125;\n    &#125;*left, *right;\n    unordered_map&lt;string, Node*&gt; hash;&#x2F;&#x2F;关联Node\n\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    AllOne() &#123;\n        left &#x3D; new Node(INT_MIN), right &#x3D; new Node(INT_MAX);&#x2F;&#x2F;边界+-INF\n        left-&gt;right &#x3D; right, right-&gt;left &#x3D; left;\n    &#125;\n\n    Node* add_to_right(Node* node, string key, int val) &#123;\n        if (node-&gt;right-&gt;val &#x3D;&#x3D; val) node-&gt;right-&gt;S.insert(key);&#x2F;&#x2F;val节点存在\n        else &#123;\n            auto t &#x3D; new Node(val);\n            t-&gt;S.insert(key);\n            t-&gt;right &#x3D; node-&gt;right, node-&gt;right-&gt;left &#x3D; t;\n            node-&gt;right &#x3D; t, t-&gt;left &#x3D; node;\n        &#125;\n        return node-&gt;right;\n    &#125;\n\n    Node* add_to_left(Node* node, string key, int val) &#123;\n        if (node-&gt;left-&gt;val &#x3D;&#x3D; val) node-&gt;left-&gt;S.insert(key);\n        else &#123;\n            auto t &#x3D; new Node(val);\n            t-&gt;S.insert(key);\n            t-&gt;left &#x3D; node-&gt;left, node-&gt;left-&gt;right &#x3D; t;\n            node-&gt;left &#x3D; t, t-&gt;right &#x3D; node;\n        &#125;\n        return node-&gt;left;\n    &#125;\n\n    void remove(Node* node) &#123;\n        node-&gt;left-&gt;right &#x3D; node-&gt;right;\n        node-&gt;right-&gt;left &#x3D; node-&gt;left;\n        delete node;&#x2F;&#x2F;双链表-\n    &#125;\n\n    &#x2F;** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. *&#x2F;\n    void inc(string key) &#123;\n        if (hash.count(key) &#x3D;&#x3D; 0) hash[key] &#x3D; add_to_right(left, key, 1);&#x2F;&#x2F;左边界\n        else &#123;\n            auto t &#x3D; hash[key];\n            t-&gt;S.erase(key);&#x2F;&#x2F;-+空删\n            hash[key] &#x3D; add_to_right(t, key, t-&gt;val + 1);\n            if (t-&gt;S.empty()) remove(t);\n        &#125;\n    &#125;\n\n    &#x2F;** Decrements an existing key by 1. If Key&#39;s value is 1, remove it from the data structure. *&#x2F;\n    void dec(string key) &#123;\n        if (hash.count(key) &#x3D;&#x3D; 0) return;\n        auto t &#x3D; hash[key];\n        t-&gt;S.erase(key);\n        if (t-&gt;val &gt; 1) &#123;\n            hash[key] &#x3D; add_to_left(t, key, t-&gt;val - 1);\n        &#125; else &#123;\n            hash.erase(key);&#x2F;&#x2F;cnt&#x3D;0 !!!!!\n        &#125;\n        if (t-&gt;S.empty()) remove(t);\n    &#125;\n\n    &#x2F;** Returns one of the keys with maximal value. *&#x2F;\n    string getMaxKey() &#123;\n        if (right-&gt;left !&#x3D; left) return *right-&gt;left-&gt;S.begin();\n        return &quot;&quot;;\n    &#125;\n\n    &#x2F;** Returns one of the keys with Minimal value. *&#x2F;\n    string getMinKey() &#123;\n        if (left-&gt;right !&#x3D; right) return *left-&gt;right-&gt;S.begin();\n        return &quot;&quot;;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your AllOne object will be instantiated and called as such:\n * AllOne* obj &#x3D; new AllOne();\n * obj-&gt;inc(key);\n * obj-&gt;dec(key);\n * string param_3 &#x3D; obj-&gt;getMaxKey();\n * string param_4 &#x3D; obj-&gt;getMinKey();\n *&#x2F;\n\n\n\n433.最小基因变化 最短路 宽搜bfs&#x2F;&#x2F;433.最小基因变化\nclass Solution &#123;\npublic:\n    int minMutation(string start, string end, vector&lt;string&gt;&amp; bank) &#123;\n        unordered_set&lt;string&gt; S;\n        for (auto&amp; s: bank) S.insert(s);\n        unordered_map&lt;string, int&gt; dist;&#x2F;&#x2F;最短路 宽搜bfs\n        queue&lt;string&gt; q;\n        q.push(start);\n        dist[start] &#x3D; 0;&#x2F;&#x2F;\n        char chrs[4] &#x3D; &#123;&#39;A&#39;, &#39;T&#39;, &#39;C&#39;, &#39;G&#39;&#125;;\n\n        while (q.size()) &#123;\n            auto t &#x3D; q.front();\n            q.pop();\n            for (int i &#x3D; 0; i &lt; t.size(); i ++ ) &#123;\n                auto s &#x3D; t;\n                for (char c: chrs) &#123;\n                    s[i] &#x3D; c;\n                    if (S.count(s) &amp;&amp; dist.count(s) &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;合法且unvisited\n                        dist[s] &#x3D; dist[t] + 1;\n                        if (s &#x3D;&#x3D; end) return dist[s];\n                        q.push(s);&#x2F;&#x2F;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n\n\n\n434.字符串中的单词数 爽题&#x2F;&#x2F;434.字符串中的单词数 爽题\nclass Solution &#123;\npublic:\n    int countSegments(string s) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            if (s[i] &#x3D;&#x3D; &#39; &#39;) continue;\n            int j &#x3D; i + 1;\n            while (j &lt; s.size() &amp;&amp; s[j] !&#x3D; &#39; &#39;) j ++ ;\n            res ++ ;\n\t\t\ti &#x3D; j - 1; &#x2F;&#x2F;或i &#x3D; j; s[j]&#x3D;&#x3D;&#39; &#39;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n435.无重叠区间 MaxCnt 经典贪心 按Rsort 能选就选\n&#x2F;&#x2F;435.无重叠区间 MaxCnt 经典贪心 按Rsort 能选就选\n&#x2F;&#x2F; 去min_cnt使不重叠&#x3D;&#x3D;不重叠max_cnt(对偶问题):贪心\nclass Solution &#123;\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; q) &#123;\n        if(q.size() &lt; 2) return 0;\n        sort(q.begin(), q.end(), [](const vector&lt;int&gt;&amp;a,const vector&lt;int&gt;&amp;b) &#123;&#x2F;&#x2F;\n            return a[1] &#x3D;&#x3D; b[1] ? a[0] &gt; b[0] : a[1] &lt; b[1];\n        &#125;);\n        if (q.empty()) return 0;\n        int res &#x3D; 1, r &#x3D; q[0][1], n &#x3D; q.size();\n        for (int i &#x3D; 1; i &lt; n; i ++ )\n            if (q[i][0] &gt;&#x3D; r) &#123;\n                res ++;\n                r &#x3D; q[i][1];\n            &#125;\n        return q.size() - res;&#x2F;&#x2F;min_del\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;acw908 &#x3D;&#x3D;&gt; acw905.区间选点:min_vers_cover_substr【&#x3D;LC453】按Rsort 遇不覆盖段选cur_best:R(cover之后段可能最大)\n&#x2F;&#x2F;贪心适用于单峰函数\n\n\n\n436.寻找右区间[lr数值最lower_bound]sort二分O(nlogn) acw830.单调栈[左max idx最近]!不同! {l,r,i}&#x2F;&#x2F;对于每个区间 i，二分查找区间 j，满足 start_j &gt;&#x3D; end_i 且 start_j 最小。\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findRightInterval(vector&lt;vector&lt;int&gt;&gt;&amp; q) &#123;\n        int n &#x3D; q.size();\n        for (int i &#x3D; 0; i &lt; n; i ++ ) q[i].push_back(i);&#x2F;&#x2F;&#123;l,r,i&#125;\n        sort(q.begin(), q.end());\n        vector&lt;int&gt; res(n, -1);&#x2F;&#x2F;无:-1\n        for (auto&amp; x: q) &#123;\n            int l &#x3D; 0, r &#x3D; n - 1;\n            while (l &lt; r) &#123;\n                int mid &#x3D; l + r &gt;&gt; 1;\n                if (q[mid][0] &gt;&#x3D; x[1]) r &#x3D; mid;&#x2F;&#x2F;\n                else l &#x3D; mid + 1;\n            &#125;\n            if (q[r][0] &gt;&#x3D; x[1]) res[x[2]] &#x3D; q[r][2];&#x2F;&#x2F;存区间idx\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;find-right-interval&#x2F;solution&#x2F;yong-mapyou-xian-cheng-de-er-fen-lower_b-jq7q&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findRightInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;\n        map&lt;int,int&gt;left2index;&#x2F;&#x2F;sorted\n        for(int i&#x3D;0;i&lt;intervals.size();i++)&#123;\n            left2index[intervals[i][0]]&#x3D;i;\n        &#125;\n        vector&lt;int&gt;ans;\n        for(auto vec:intervals)&#123;\n            auto it&#x3D;left2index.lower_bound(vec[1]);&#x2F;&#x2F;&gt;&#x3D;r\n            if(it&#x3D;&#x3D;left2index.end())ans.push_back(-1);\n            else ans.push_back((*it).second);&#x2F;&#x2F;idx\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n\n\n\n？437.路径总和III O(n)晕~：why只回溯cnt？？？区间和&#x3D;sum cnt[Si-T]\nclass Solution &#123;\npublic:\n    unordered_map&lt;int, int&gt; cnt;&#x2F;&#x2F;&#123;前缀和, cnt&#125;\n    int res &#x3D; 0;\n\n    int pathSum(TreeNode* root, int sum) &#123;&#x2F;&#x2F;区间和sum\n        cnt[0] ++ ;&#x2F;&#x2F;S0&#x3D;0 哨兵\n        dfs(root, sum, 0);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* root, int sum, int cur) &#123;&#x2F;&#x2F;cur:不包括root-&gt;val\n        if (!root) return;\n        cur +&#x3D; root-&gt;val;&#x2F;&#x2F;更新cur&#x3D;前缀和Si\n        res +&#x3D; cnt[cur - sum];&#x2F;&#x2F;cnt[Si-T]\n        cnt[cur] ++ ;&#x2F;&#x2F;更新cnt\n        dfs(root-&gt;left, sum, cur), dfs(root-&gt;right, sum, cur);&#x2F;&#x2F;起点不root了\n        cnt[cur] -- ;&#x2F;&#x2F;回溯\n    &#125;\n&#125;;\n\n\n\nclass Solution &#123;\npublic:\n    int res;\n    int s;\n    int pathSum(TreeNode* root, int sum) &#123;\n        if (!root) return 0;\n        s &#x3D; sum;\n        dfs(root, 0)&#x2F;&#x2F;\n        if (root -&gt; left) pathSum(root -&gt; left, sum); &#x2F;&#x2F;不一定是从根节点开始\n        if (root -&gt; right) pathSum(root -&gt; right, sum);\n        return res;\n    &#125;\n\n    void dfs(TreeNode* u, int sum)\n    &#123;\n        sum +&#x3D; u -&gt; val;\n        if (s &#x3D;&#x3D; sum) res ++; &#x2F;&#x2F;路径不一定是叶节点结束\n        if (!u -&gt; left &amp;&amp; !u -&gt; right) return;\n        if (u -&gt; left) dfs(u -&gt; left, sum);\n        if (u -&gt; right) dfs(u -&gt; right, sum);\n    &#125;\n&#125;;\n\n作者：Roger_3\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;14333&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n438.找到字符串中所有字母异位词 O(n)双指针:m长滑动窗口cnt[c]&#x3D;&#x3D;的c达satisfy种即可(合二为一:+-&#x3D;0即可) cnt[s[j++]]++;&#x2F;&#x2F;cnt少一个s-&#x2F;&#x2F;438.找到字符串中所有字母异位词 O(n)双指针:m长滑动窗口cnt[c]&#x3D;&#x3D;的c达satisfy种即可(合二为一:+-&#x3D;0即可)\n&#x2F;&#x2F; [类似LC3:不重最长子串]\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findAnagrams(string s, string p) &#123;\n        unordered_map&lt;char, int&gt; cnt;\n        for (auto c: p) cnt[c] ++ ;&#x2F;&#x2F;p+\n        vector&lt;int&gt; res;\n        int tot &#x3D; cnt.size();\n        for (int i &#x3D; 0, j &#x3D; 0, satisfy &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            if ( -- cnt[s[i]] &#x3D;&#x3D; 0) satisfy ++ ;\n            while (i - j + 1 &gt; p.size()) &#123; &#x2F;&#x2F;j++\n                if (cnt[s[j]] &#x3D;&#x3D; 0) satisfy -- ;\n                cnt[s[j ++ ]] ++ ;&#x2F;&#x2F;cnt少一个s-\n            &#125;\n            if (satisfy &#x3D;&#x3D; tot) res.push_back(j);&#x2F;&#x2F;idx_j\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n439.\n\n\n\n440.字典序的第K小数字 数位统计 数奥:难，需要很仔细 分类讨论 f(prefix, n):1~n中前缀为prefix的个数\n&#x2F;&#x2F;440.字典序的第K小数字 数位统计 数奥\nclass Solution &#123;\npublic:\n    int f(int prefix, int n) &#123;\n        long long p &#x3D; 1;\n        auto A &#x3D; to_string(n), B &#x3D; to_string(prefix);\n        int dt &#x3D; A.size() - B.size();\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; dt; i ++ ) &#123; &#x2F;&#x2F;dt&gt;0 B比A短\n            res +&#x3D; p;\n            p *&#x3D; 10; &#x2F;&#x2F;最后一次p&#x3D;&#x3D;10^(a-b)\n        &#125;\n        A &#x3D; A.substr(0, B.size());\n        if (A &#x3D;&#x3D; B) res +&#x3D; n - prefix * p + 1; &#x2F;&#x2F;&lt;\n        else if (A &gt; B) res +&#x3D; p; &#x2F;&#x2F;随意\n        return res; &#x2F;&#x2F;BA等长,A&lt;B: res&#x3D;0\n    &#125;\n\n    int findKthNumber(int n, int k) &#123;\n        int prefix &#x3D; 1;\n        while (k &gt; 1) &#123;\n            int cnt &#x3D; f(prefix, n); &#x2F;&#x2F;f:1~n中前缀为prefix的个数\n            if (k &gt; cnt) &#123;\n                k -&#x3D; cnt;\n                prefix ++ ; &#x2F;&#x2F;换前缀\n            &#125; else &#123;\n                k -- ; &#x2F;&#x2F;当前前缀下的第k个 当前占一位\n                prefix *&#x3D; 10; &#x2F;&#x2F;定该前缀的下一位\n            &#125;\n        &#125;\n        return prefix;\n    &#125;\n&#125;;\n\n\n\n\n\n441.排列硬币 一元二次方程&#x2F;&#x2F;441.排列硬币 一元二次方程\nclass Solution &#123;\npublic:\n    int arrangeCoins(int n) &#123;\n        return (-1 + sqrt(1 + 8.0 * n)) &#x2F; 2;&#x2F;&#x2F; k(k+1)&#x2F;2 &lt;&#x3D; n 求k_max k&gt;0\n    &#125;\n&#125;;\n\n\n\n\n442.数组中重复的数据 T&#x3D;O(n) 1中原地找2次的数s:【奇技淫巧】把idx当做cnt *(-1)&#x3D;+就记录[LC448]\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; res;\n        for (auto x: nums) &#123;\n            int p &#x3D; abs(x) - 1;&#x2F;&#x2F;0~n-1\n            nums[p] *&#x3D; -1;\n            if (nums[p] &gt; 0) res.push_back(abs(x));&#x2F;&#x2F;原地 奇技淫巧\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n443.压缩字符串 游程 直接覆盖 len无1 按位拿出k~t：O(1)&#x2F;&#x2F;443.压缩字符串 游程 直接覆盖\nclass Solution &#123;\npublic:\n    int compress(vector&lt;char&gt;&amp; s) &#123;\n        int k &#x3D; 0;&#x2F;&#x2F;ans_idx\n        for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n            int j &#x3D; i + 1;\n            while (j &lt; s.size() &amp;&amp; s[j] &#x3D;&#x3D; s[i]) j ++ ;\n            int len &#x3D; j - i;\n            s[k ++ ] &#x3D; s[i];&#x2F;&#x2F;ch\n            &#x2F;&#x2F;无1 按位拿出k~t：O(1)  to_string(len):S&#x3D;O(logn)&#x3D;3 也可以~\n            if (len &gt; 1) &#123;\n                int t &#x3D; k;\n                while (len) &#123;\n                    s[t ++ ] &#x3D; &#39;0&#39; + len % 10;\n                    len &#x2F;&#x3D; 10;\n                &#125;\n                reverse(s.begin() + k, s.begin() + t);\n                k &#x3D; t;\n            &#125;\n            i &#x3D; j - 1;\n        &#125;\n        return k;\n    &#125;\n&#125;;\n\n\n\n\n444.\n\n\n\n445.两数相加II 反转链表+高精度加法 头插&#x2F;&#x2F;445.两数相加II\nclass Solution &#123;\npublic:\n\t&#x2F;&#x2F; 翻转链表\n    ListNode* reverse(ListNode* head) &#123;\n        auto a &#x3D; head, b &#x3D; head-&gt;next;\n        while (b) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n        head-&gt;next &#x3D; NULL;&#x2F;&#x2F;\n        return a;\n    &#125;\n\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n        l1 &#x3D; reverse(l1), l2 &#x3D; reverse(l2);\n        auto head &#x3D; new ListNode(-1);&#x2F;&#x2F;答案链表头插\n        &#x2F;&#x2F; 高精度加法\n        int t &#x3D; 0;&#x2F;&#x2F;进位\n        while (l1 || l2 || t) &#123;\n            if (l1) t +&#x3D; l1-&gt;val, l1 &#x3D; l1-&gt;next;\n            if (l2) t +&#x3D; l2-&gt;val, l2 &#x3D; l2-&gt;next;\n            auto cur &#x3D; new ListNode(t % 10);\n            t &#x2F;&#x3D; 10;\n            cur-&gt;next &#x3D; head-&gt;next;&#x2F;&#x2F;\n            head-&gt;next &#x3D; cur;\n        &#125;\n        return head-&gt;next;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;reverse*3\nclass Solution &#123;\npublic:\n\t&#x2F;&#x2F; 翻转链表\n    ListNode* reverse(ListNode* head) &#123;\n        auto a &#x3D; head, b &#x3D; head-&gt;next;\n        while (b) &#123;\n            auto c &#x3D; b-&gt;next;\n            b-&gt;next &#x3D; a;\n            a &#x3D; b, b &#x3D; c;\n        &#125;\n        head-&gt;next &#x3D; NULL;&#x2F;&#x2F;\n        return a;\n    &#125;\n\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n        l1 &#x3D; reverse(l1), l2 &#x3D; reverse(l2);\n        auto dummy &#x3D; new ListNode(-1), cur &#x3D; dummy;\n        &#x2F;&#x2F; 高精度加法\n        int t &#x3D; 0;\n        while (l1 || l2 || t) &#123;\n            if (l1) t +&#x3D; l1-&gt;val, l1 &#x3D; l1-&gt;next;\n            if (l2) t +&#x3D; l2-&gt;val, l2 &#x3D; l2-&gt;next;\n            cur &#x3D; cur-&gt;next &#x3D; new ListNode(t % 10);&#x2F;&#x2F;\n            t &#x2F;&#x3D; 10;\n        &#125;\n        return reverse(dummy-&gt;next);\n    &#125;\n&#125;;\n\n\n\n\n446.等差数列划分II-子序列 cnt DP O(n*n)\n&#x2F;&#x2F;446.等差数列划分II-子序列 cnt DP O(n*n)\n&#x2F;*\n设 f(i,d) 表示以 i 为结尾的差值为 d 的子序列的个数（包括长度为 2 的）。\n初始时 f(i,d) 都是 0。转移时，枚举 0≤j&lt;i，令 d&#x3D;A[i]−A[j]，则 f(i,d)+&#x3D;f(j,d)+1\n[(&gt;&#x3D;2) +&#x3D; (&gt;&#x3D;3) + (aj,ai)]，这个的意思是以 j 结尾的子序列都可以接到 A[i] 上，A[i], A[j] 也算 1 个。\n最终答案为 ∑i∑df(i,d)\n数值大，但个数不多：hash表\n*&#x2F;\nclass Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; a) &#123;\n        typedef long long LL;\n        int n &#x3D; a.size();\n        vector&lt;unordered_map&lt;LL, int&gt;&gt; f(n);&#x2F;&#x2F;常数大\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            for (int k &#x3D; 0; k &lt; i; k ++ ) &#123;\n                LL j &#x3D; (LL)a[i] - a[k];\n                &#x2F;&#x2F; res +&#x3D; f[k][j];&#x2F;&#x2F;查找两次~\n                &#x2F;&#x2F; f[i][j] +&#x3D; f[k][j] + 1\n                auto it &#x3D; f[k].find(j);&#x2F;&#x2F;f[k][j]存在 只找一次！\n                int t &#x3D; 0;\n                if (it !&#x3D; f[k].end()) &#123;\n                    t &#x3D; it-&gt;second;\n                    res +&#x3D; t;&#x2F;&#x2F;(&gt;&#x3D;3)\n                &#125;\n                f[i][j] +&#x3D; t + 1;&#x2F;&#x2F;f[i][j]+&#x3D;f[k][j]+1\n            &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n447.回旋镖的数量 ijk ij&#x3D;ik cnt:与i距离dist的点数 sigma_P(C,2) 不同jk总数\n&#x2F;&#x2F;447.回旋镖的数量 ijk ij&#x3D;ik cnt\nclass Solution &#123;\npublic:\n    int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; p) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; p.size(); i ++ ) &#123;\n            unordered_map&lt;int, int&gt; cnt;&#x2F;&#x2F;&#123;dist,cnt&#125;：与i距离dist的点数\n            for (int j &#x3D; 0; j &lt; p.size(); j ++ )\n                if (i !&#x3D; j) &#123;&#x2F;&#x2F;\n                    int dx &#x3D; p[i][0] - p[j][0];\n                    int dy &#x3D; p[i][1] - p[j][1];\n                    int dist &#x3D; dx * dx + dy * dy;&#x2F;&#x2F;sqrt有精度问题\n                    cnt[dist] ++ ;\n                &#125;\n            for (auto [d, c]: cnt) res +&#x3D; c * (c - 1);&#x2F;&#x2F;sigma_P(C,2) 不同jk总数\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n448.找到所有数组中消失的数字 nums[0~n-1] +to- -不管！原地vis 思想同LC442class Solution &#123;\npublic:\n    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;\n        for (auto x: nums) &#123;\n            x &#x3D; abs(x);&#x2F;&#x2F;-:abs\n            if (nums[x - 1] &gt; 0) nums[x - 1] *&#x3D; -1;&#x2F;&#x2F;nums[0~n-1] +to- -不管！vis\n        &#125;\n        vector&lt;int&gt; res;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ )\n            if (nums[i] &gt; 0)\n                res.push_back(i + 1);&#x2F;&#x2F;1~n\n        return res;\n    &#125;\n&#125;;\n\n\n\n449.序列化和反序列化二叉[搜索]树  d:vec ssin 子树范围 &lt; &gt;&#x3D;也能过：说明v唯一&#x2F;&#x2F;449.序列化和反序列化二叉[搜索]树 \n&#x2F;&#x2F; 不要使用类成员&#x2F;全局&#x2F;静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。\n&#x2F;&#x2F; d:vec ssin 子树范围 &lt; &gt;&#x3D;也能过：说明v唯一\nclass Codec &#123;\npublic:\n\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    string serialize(TreeNode* root) &#123;\n        string res;\n        dfs_s(root, res);\n        return res;\n    &#125;\n\n    void dfs_s(TreeNode* root, string&amp; res) &#123;\n        if (!root) return;\n        res +&#x3D; to_string(root-&gt;val) + &#39; &#39;;\n        dfs_s(root-&gt;left, res), dfs_s(root-&gt;right, res);\n    &#125;\n\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    TreeNode* deserialize(string str) &#123;\n        vector&lt;int&gt; data;&#x2F;&#x2F;\n        stringstream ssin(str);&#x2F;&#x2F;\n        int x, u &#x3D; 0;\n        while (ssin &gt;&gt; x) data.push_back(x);\n        return dfs_d(data, u, INT_MIN, INT_MAX);&#x2F;&#x2F;子树范围\n    &#125;\n\n    TreeNode* dfs_d(vector&lt;int&gt;&amp; data, int&amp; u, int minv, int maxv) &#123;\n        if (u &#x3D;&#x3D; data.size() || data[u] &lt; minv || data[u] &gt; maxv) return NULL;\n        auto root &#x3D; new TreeNode(data[u ++ ]);\n        root-&gt;left &#x3D; dfs_d(data, u, minv, root-&gt;val);&#x2F;&#x2F;&lt;&#x3D;\n        root-&gt;right &#x3D; dfs_d(data, u, root-&gt;val + 1, maxv);&#x2F;&#x2F;&gt;\n        return root;\n    &#125;\n&#125;;\n\n\n\n450.删除二叉搜索树中的节点 经典ds O(h&#x3D;logn) &amp;root 后继p覆盖root，删p\n&#x2F;&#x2F;450.删除二叉搜索树中的节点 经典ds O(h&#x3D;logn) &amp;root 后继p覆盖root，删p\nclass Solution &#123;\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) &#123;\n        del(root, key);\n        return root;&#x2F;&#x2F;&amp;root\n    &#125;\n\n    void del(TreeNode* &amp;root, int key) &#123;\n        if (!root) return;\n        if (key &#x3D;&#x3D; root-&gt;val) &#123;\n            if (!root-&gt;left &amp;&amp; !root-&gt;right) root &#x3D; NULL;  &#x2F;&#x2F; 叶节点 &amp;更灵活：不分父的lr auto\n            else if (!root-&gt;left) root &#x3D; root-&gt;right;  &#x2F;&#x2F; 只有右儿子\n            else if (!root-&gt;right) root &#x3D; root-&gt;left;  &#x2F;&#x2F; 只有左儿子\n            else &#123;  &#x2F;&#x2F; 左右儿子都有\n                auto p &#x3D; root-&gt;right;\n                while (p-&gt;left) p &#x3D; p-&gt;left;  &#x2F;&#x2F; 找后继\n                root-&gt;val &#x3D; p-&gt;val;&#x2F;&#x2F;p覆盖root，删p\n                del(root-&gt;right, p-&gt;val);\n            &#125;\n        &#125;\n        else if (key &lt; root-&gt;val) del(root-&gt;left, key);\n        else del(root-&gt;right, key);\n    &#125;\n&#125;;\n\n\n\n\n\n\n451.根据字符出现频率排序 双关键字排序：cnt&gt;,ASCII字典序&lt;  [&amp;]class Solution &#123;\npublic:\n    string frequencySort(string s) &#123;\n        unordered_map&lt;char, int&gt; cnt;\n        for (auto c: s) cnt[c] ++ ;\n        &#x2F;&#x2F;双关键字排序：cnt&gt;,ASCII字典序&lt;  [&amp;](char a, char b)\n        sort(s.begin(), s.end(), [&amp;](char a, char b) &#123;\n            if (cnt[a] !&#x3D; cnt[b]) return cnt[a] &gt; cnt[b];\n            return a &lt; b;\n        &#125;);\n        return s;\n    &#125;\n&#125;;\n\n\n\n\n\n452.用最少数量的箭引爆气球 acw905区间选点 R排,不覆盖段选R(覆盖最多)  &lt;-&gt;LC435 区间贪心\nclass Solution &#123;\npublic:\n    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        if (points.empty()) return 0;\n        sort(points.begin(), points.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;\n            return a[1] &lt; b[1];&#x2F;&#x2F;R sort\n        &#125;);\n        int res &#x3D; 1, r &#x3D; points[0][1];\n        for (int i &#x3D; 1; i &lt; points.size(); i ++ )\n            if (points[i][0] &gt; r) &#123;\n                res ++ ;\n                r &#x3D; points[i][1];&#x2F;&#x2F;不覆盖段选R\n            &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n453.最小移动次数使数组元素相等 n-1个+1&#x3D;&#x3D;1个-1 cnt&#x3D;tot-n*min_x accumulate min_element&#x2F;&#x2F;453.最小移动次数使数组元素相等 n-1个+1&#x3D;&#x3D;1个-1 cnt&#x3D;tot-n*min_x\n&#x2F;&#x2F; STL:accumulate min_element\nclass Solution &#123;\npublic:\n    int minMoves(vector&lt;int&gt;&amp; nums) &#123;\n        return accumulate(nums.begin(), nums.end(), 0) \n            - nums.size() * *min_element(nums.begin(), nums.end());\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;yxc\nclass Solution &#123;\npublic:\n    int minMoves(vector&lt;int&gt;&amp; nums) &#123;\n        int minv &#x3D; INT_MAX;\n        for (auto x: nums) minv &#x3D; min(minv, x);\n        int res &#x3D; 0;\n        for (auto x: nums) res +&#x3D; x - minv;\n        return res;\n    &#125;\n&#125;;\n\n\n\n454.四数相加II O(n*n) 空间换时间cnt[c+d]++; res+&#x3D;cnt[-(a+b)];\n&#x2F;&#x2F;454.四数相加II O(n*n) 空间换时间cnt[c+d]++ res+&#x3D;cnt[-(a+b)];\nclass Solution &#123;\npublic:\n    int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;\n        unordered_map&lt;int, int&gt; cnt;\n        for (auto c: C)\n            for (auto d: D)\n                cnt[c + d] ++ ;\n        int res &#x3D; 0;\n        for (auto a: A)\n            for (auto b: B)\n                res +&#x3D; cnt[-(a + b)];\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n455.分发饼干 贪心 O(nlogn) sort+Greedy解：min_gi、Si单调、Si为&gt;&#x3D;gi的first\n1&lt;2&lt;3 2&lt;3&lt;4 可以swap为单调\n\nGreedy解：Si为&gt;&#x3D;gi的first \n第一个与G解不同的Best解B1可前移为G1，不影响后面的解！以此类推~  G&#x3D;B！！！\n逐步缩小解集范围！\n&#x2F;&#x2F;455.分发饼干 贪心 O(nlogn) sort+Greedy解：min_gi、Si单调、Si为&gt;&#x3D;gi的first\n&#x2F;&#x2F; 二分图最大匹配：匈牙利算法模板O(nm) \nclass Solution &#123;\npublic:\n    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int res &#x3D; 0;\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; g.size(); i ++ ) &#123;\n            while (j &lt; s.size() &amp;&amp; s[j] &lt; g[i]) j ++ ;&#x2F;&#x2F;\n            if (j &lt; s.size()) &#123;\n                res ++ ;\n                j ++ ;\n            &#125;\n            else break;&#x2F;&#x2F;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int ans &#x3D; 0;\n\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; g.size() &amp;&amp; j &lt; s.size(); j++)\n            if (s[j] &gt;&#x3D; g[i]) &#123;\n                ans++;\n                i++;\n            &#125;\n\n        return ans;\n    &#125;\n&#125;;\n作者：wzc1995\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;375&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n？？？456.132模式 单调栈O(n) 难 单调栈顶维护的是3，max_k(right)维护的是2，枚举的是nums[i] “1”【Knuth所提出来的 stack-sortable permutation】\n\n&#x2F;&#x2F;???？？？456.132模式 单调栈O(n)\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;132-pattern&#x2F;solution&#x2F;132mo-shi-by-leetcode-solution-ye89&#x2F;\n&#x2F;*\n单调栈维护的是3，max_k(right)维护的是2，枚举的是nums[i] &quot;1&quot;，\nmax_k来源于单调栈，所以其索引一定大于栈顶的元素，但其值一定小于栈顶元素，故栈顶元素就是3，\n即找到了对“32”。 \n于是当出现nums[i] &lt; max_k时，即找到了&quot;12&quot;，这个时候一定会有3个元素的，\n而栈顶3必定大于2，故也大于1，即满足“132”\n*&#x2F;\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;6595&#x2F;\n&#x2F;*\n这个问题与Knuth所提出来的 stack-sortable permutation 类似，\n即判断一个数组是否可以只用一个栈来进行排序，当且仅当它不包含231模式。\n而将本问题中的数组逆序，寻找132模式就变成了寻找231模式，也即判断数组是否可以仅用一个栈来进行排序。\n*&#x2F;\n&#x2F;&#x2F; https:&#x2F;&#x2F;en.jinzhao.wiki&#x2F;wiki&#x2F;Stack-sortable_permutation\nclass Solution &#123;\npublic:\n    bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;\n        stack&lt;int&gt; stk;\n        int right &#x3D; INT_MIN;&#x2F;&#x2F;max_Ak\n        for (int i &#x3D; nums.size() - 1; i &gt;&#x3D; 0; i -- ) &#123;\n            if (nums[i] &lt; right) return true;&#x2F;&#x2F;枚举到了1：满足要求\n            while (stk.size() &amp;&amp; nums[i] &gt; stk.top()) &#123;&#x2F;&#x2F;栈顶&lt;Ai\n                right &#x3D; max(right, stk.top());&#x2F;&#x2F;更新right 2\n                stk.pop();&#x2F;&#x2F;删栈顶 (top 3刚好&gt;2 &#x3D;&#x3D; 2是max_Ak)\n            &#125;\n            stk.push(nums[i]);&#x2F;&#x2F;Ai入栈\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n\n\n\n457.环形数组循环 (路径标记寻环) O(n) (快慢指针寻环)\n&#x2F;&#x2F;457.环形数组循环 (路径标记寻环) O(n) (快慢指针寻环)\nclass Solution &#123;\npublic:\n    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size(), Base &#x3D; 10000;\n        for (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n            if (nums[i] &gt;&#x3D; Base) continue;&#x2F;&#x2F;vis\n            int k &#x3D; i, S &#x3D; Base + i, t &#x3D; nums[k] &gt; 0;&#x2F;&#x2F;mark:S 符号:t\n            int last &#x3D; -1;\n            do &#123;\n                int p &#x3D; ((k + nums[k]) % n + n) % n;&#x2F;&#x2F;k-&gt;跳到p\n                last &#x3D; nums[k], nums[k] &#x3D; S;\n                k &#x3D; p;\n            &#125; while (k !&#x3D; i &amp;&amp; nums[k] &lt; Base &amp;&amp; (t ^ (nums[k] &gt; 0)) &#x3D;&#x3D; 0);&#x2F;&#x2F;unvis 符号&#x3D;&#x3D;\n            if (last % n &amp;&amp; nums[k] &#x3D;&#x3D; S) return true;&#x2F;&#x2F;last%n!&#x3D;0：len&gt;1的环\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n\n\n\n458.可怜的小猪 m_min后有毒死一轮 P_min内check n中哪桶毒所需min_x头猪&#x3D;? 数学O(logn)&#x2F;&#x2F; 状态数(k+1)^x&gt;&#x3D;n x&gt;&#x3D;ceil(log(n)&#x2F;log(k+1))\n条件：\n\n方案：\n\n&#x2F;&#x2F;458.可怜的小猪 m_min后有毒死一轮 P_min内check n中哪桶毒所需min_x头猪&#x3D;?\n&#x2F;&#x2F; 状态数(k+1)^x&gt;&#x3D;n x&gt;&#x3D;ceil(log(n)&#x2F;log(k+1))  方案：x位的k+1进制数-&gt;10进制数&#x3D;哪桶毒\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;131&#x2F;\nclass Solution &#123;\npublic:\n    int poorPigs(int n, int minutesToDie, int minutesToTest) &#123;\n        int k &#x3D; minutesToTest &#x2F; minutesToDie;&#x2F;&#x2F;轮数k&#x3D;P&#x2F;m\n        return ceil(log(n) &#x2F; log(k + 1));&#x2F;&#x2F;x&gt;&#x3D;\n    &#125;\n&#125;;\n\n\n\n459.重复的子字符串 蓝书P73~74 min_t&#x3D;n-KMP_next[n] min_t|n\n\n&#x2F;&#x2F;459.重复的子字符串 蓝书P73~74 min_t&#x3D;n-KMP_next[n] min_t|n\n&#x2F;&#x2F; 结论1：min周期：n-KMP_next[n](min_t可以不|n)\n&#x2F;&#x2F; 结论2：min_t是所有周期的公约数(故min_t|n，否则无周期)\n&#x2F;&#x2F; 证明见：https:&#x2F;&#x2F;www.acwing.com&#x2F;video&#x2F;1861&#x2F;\nclass Solution &#123;\npublic:\n    bool repeatedSubstringPattern(string s) &#123;\n        int n &#x3D; s.size();\n        s &#x3D; &#39; &#39; + s;&#x2F;&#x2F;next 背！\n        vector&lt;int&gt; next(n + 1);\n        for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#123;\n            while (j &amp;&amp; s[i] !&#x3D; s[j + 1]) j &#x3D; next[j];\n            if (s[i] &#x3D;&#x3D; s[j + 1]) j ++ ;\n            next[i] &#x3D; j;\n        &#125;\n        int t &#x3D; n - next[n];\n        return t &lt; n &amp;&amp; n % t &#x3D;&#x3D; 0; &#x2F;&#x2F; min_t&lt;n &amp;&amp; min_t|n\n    &#125;\n&#125;;\n\n\n\n460.LFU缓存 设计 难 扩146.LRU 双链表嵌套:list RW_O(1):hash_block&#x2F;node:cnt [key] erase size\n&#x2F;&#x2F;460.LFU缓存 扩146.LRU 双链表嵌套:list RW_O(1):hash_block&#x2F;node:cnt [key] erase size\nclass LFUCache &#123;\npublic:\n    struct Node &#123;\n        Node *left, *right;\n        int key, val;\n        Node(int _key, int _val) &#123;\n            key &#x3D; _key, val &#x3D; _val;\n            left &#x3D; right &#x3D; NULL;\n        &#125;\n    &#125;;\n    struct Block &#123;\n        Block *left, *right;\n        Node *head, *tail;&#x2F;&#x2F;哨兵\n        int cnt;\n        Block(int _cnt) &#123;\n            cnt &#x3D; _cnt;\n            left &#x3D; right &#x3D; NULL;\n            head &#x3D; new Node(-1, -1), tail &#x3D; new Node(-1, -1);\n            head-&gt;right &#x3D; tail, tail-&gt;left &#x3D; head;\n        &#125;\n        ~Block() &#123;&#x2F;&#x2F;~块内双链表\n            delete head;\n            delete tail;\n        &#125;\n        void insert(Node* p) &#123;\n            p-&gt;right &#x3D; head-&gt;right;\n            head-&gt;right-&gt;left &#x3D; p;\n            p-&gt;left &#x3D; head;\n            head-&gt;right &#x3D; p;\n        &#125;\n        void remove(Node* p) &#123;\n            p-&gt;left-&gt;right &#x3D; p-&gt;right;\n            p-&gt;right-&gt;left &#x3D; p-&gt;left;\n        &#125;\n        bool empty() &#123;\n            return head-&gt;right &#x3D;&#x3D; tail;\n        &#125;\n    &#125;*head, *tail;\n    int n;\n    unordered_map&lt;int, Block*&gt; hash_block;\n    unordered_map&lt;int, Node*&gt; hash_node;\n\n    void insert(Block* p) &#123;  &#x2F;&#x2F; 在p的右侧插入新块，cnt是p-&gt;cnt + 1\n        auto cur &#x3D; new Block(p-&gt;cnt + 1);\n        cur-&gt;right &#x3D; p-&gt;right;\n        p-&gt;right-&gt;left &#x3D; cur;\n        p-&gt;right &#x3D; cur;\n        cur-&gt;left &#x3D; p;\n    &#125;\n\n    void remove(Block* p) &#123;\n        p-&gt;left-&gt;right &#x3D; p-&gt;right;\n        p-&gt;right-&gt;left &#x3D; p-&gt;left;\n        delete p;&#x2F;&#x2F;~Block\n    &#125;\n\n    LFUCache(int capacity) &#123;\n        n &#x3D; capacity;\n        head &#x3D; new Block(0), tail &#x3D; new Block(INT_MAX);&#x2F;&#x2F;\n        head-&gt;right &#x3D; tail, tail-&gt;left &#x3D; head;\n    &#125;\n\n    int get(int key) &#123;\n        if (hash_block.count(key) &#x3D;&#x3D; 0) return -1;\n        auto block &#x3D; hash_block[key];\n        auto node &#x3D; hash_node[key];\n        &#x2F;&#x2F;cnt+1: -++(更新block)-\n        block-&gt;remove(node);\n        if (block-&gt;right-&gt;cnt !&#x3D; block-&gt;cnt + 1) insert(block);\n        block-&gt;right-&gt;insert(node);\n        hash_block[key] &#x3D; block-&gt;right;\n        if (block-&gt;empty()) remove(block);\n        return node-&gt;val;\n    &#125;\n\n    void put(int key, int value) &#123;\n        if (!n) return;&#x2F;&#x2F;边界\n        if (hash_block.count(key)) &#123;&#x2F;&#x2F;有\n            hash_node[key]-&gt;val &#x3D; value;&#x2F;&#x2F;put_value\n            get(key);&#x2F;&#x2F;cnt+1\n        &#125; else &#123;\n            if (hash_block.size() &#x3D;&#x3D; n) &#123;&#x2F;&#x2F;满了，要先删头block尾node\n                auto p &#x3D; head-&gt;right-&gt;tail-&gt;left;\n                head-&gt;right-&gt;remove(p);\n                if (head-&gt;right-&gt;empty()) remove(head-&gt;right);&#x2F;&#x2F;块空 删\n                hash_block.erase(p-&gt;key);\n                hash_node.erase(p-&gt;key);\n                delete p;\n            &#125;\n            &#x2F;&#x2F;无 cnt1头块insert\n            auto p &#x3D; new Node(key, value);\n            if (head-&gt;right-&gt;cnt &gt; 1) insert(head);\n            head-&gt;right-&gt;insert(p);\n            hash_block[key] &#x3D; head-&gt;right;\n            hash_node[key] &#x3D; p;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;Java: https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;8960&#x2F;\n\n\n\n\n461.汉明距离 bin不同的位数：^&#x2F;&#x2F;461.汉明距离 bin不同的位数：^\nclass Solution &#123;\npublic:\n    int hammingDistance(int x, int y) &#123;\n        int res &#x3D; 0;\n        while (x || y) &#123;\n            res +&#x3D; (x &amp; 1) ^ (y &amp; 1);&#x2F;&#x2F;bin不同的位数\n            x &gt;&gt;&#x3D; 1, y &gt;&gt;&#x3D; 1;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n\n462.最少移动次数使数组元素相等II 选1+1或-1[LC453] &#x3D;&#x3D;acw104.货仓选址：求sigma中位数dist！\nsort 预处理前缀和 min(L+R)\n\nacw104.货仓选址 绝对值不等式： 证明是中位数！\n证明见：\nhttps://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/solution/czhong-wei-shu-jian-dan-zheng-ming-by-ke-a2v9/\n&#x2F;&#x2F;462.最少移动次数使数组元素相等II 选1+1或-1[LC453] &#x3D;&#x3D;acw104.货仓选址：求sigma中位数dist！\n&#x2F;&#x2F;绝对值不等式||a|-|b||≤|a±b|≤|a|+|b|  sort、res +&#x3D; abs(x - nums[n &#x2F; 2]);\n&#x2F;&#x2F; 证明见：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;minimum-moves-to-equal-array-elements-ii&#x2F;solution&#x2F;czhong-wei-shu-jian-dan-zheng-ming-by-ke-a2v9&#x2F;\nclass Solution &#123;\npublic:\n    int minMoves2(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        sort(nums.begin(), nums.end());&#x2F;&#x2F;\n        int res &#x3D; 0;\n        for (auto x: nums)\n            res +&#x3D; abs(x - nums[n &#x2F; 2]);&#x2F;&#x2F;\n        &#x2F;&#x2F; for (int i &#x3D; 0; i &lt; n; i ++ )\n        &#x2F;&#x2F;     res +&#x3D; abs(nums[i] - nums[i &#x2F; 2]);&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n&#x2F;&#x2F;快选：选一半递归 LC215 O(n)找K大\n\n\n\n\n463.岛屿的周长 不用floodfill &#x3D;&#x3D;1循环judge即可：出界 10交界&#x2F;&#x2F;463.岛屿的周长 不用floodfill &#x3D;&#x3D;1循环judge即可：出界 10交界\nclass Solution &#123;\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; grid.size(); i ++ )\n            for (int j &#x3D; 0; j &lt; grid[i].size(); j ++ )\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;\n                    for (int k &#x3D; 0; k &lt; 4; k ++ ) &#123;\n                        int x &#x3D; i + dx[k], y &#x3D; j + dy[k];\n                        if (x &lt; 0 || x &gt;&#x3D; grid.size() || y &lt; 0 || y &gt;&#x3D; grid[0].size())\n                            res ++ ;&#x2F;&#x2F;出界\n                        else if (grid[x][y] &#x3D;&#x3D; 0) res ++ ;&#x2F;&#x2F;10交界\n                    &#125;\n                &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n464.我能赢吗 博弈论 1~n不重选 first&gt;&#x3D;m_win sum + i + 1 &gt;&#x3D; m&#x2F;&#x2F;当前局wo先胜\t!dp(x + (1 &lt;&lt; i))&#x2F;&#x2F;下一局面必败,wo胜 记忆化搜索&#x2F;&#x2F;464.我能赢吗 博弈论 1~n不重选 first&gt;&#x3D;m_win\n&#x2F;&#x2F; [存在某种行动，使得行动后对面面临必败局面]，则优先采取该行动。同时，这样的局面被称为[必胜]。\n&#x2F;&#x2F; sum + i + 1 &gt;&#x3D; m&#x2F;&#x2F;当前局wo先胜\t!dp(x + (1 &lt;&lt; i))&#x2F;&#x2F;下一局面必败,wo胜\nclass Solution &#123;\npublic:\n\tvector&lt;int&gt; f;\n\tint n, m;\n\n\tint dp(int x) &#123;\n\t\tif (f[x] !&#x3D; -1) return f[x];&#x2F;&#x2F;记忆化搜索\n\t\tint sum &#x3D; 0;\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ )\n\t\t\tif (x &gt;&gt; i &amp; 1)\n\t\t\t\tsum +&#x3D; i + 1;&#x2F;&#x2F;sum&#x3D;state 第0位表示1是否被选过\n\t\tfor (int i &#x3D; 0; i &lt; n; i ++ ) &#123;\n\t\t\tif (x &gt;&gt; i &amp; 1) continue;&#x2F;&#x2F;\n\t\t\tif (sum + i + 1 &gt;&#x3D; m) return f[x] &#x3D; 1;&#x2F;&#x2F;当前局wo先胜\n\t\t\tif (!dp(x + (1 &lt;&lt; i))) return f[x] &#x3D; 1;&#x2F;&#x2F;下一局面必败,wo胜\n\t\t&#125;\n\t\treturn f[x] &#x3D; 0;\n\t&#125;\n\n\tbool canIWin(int _n, int _m) &#123;\n\t\tn &#x3D; _n, m &#x3D; _m;\n\t\tif (n * (n + 1) &#x2F; 2 &lt; m) return false;&#x2F;&#x2F;\n\t\tf.resize(1 &lt;&lt; n, -1);&#x2F;&#x2F;n&lt;20\n\t\treturn dp(0);\n\t&#125;\n&#125;;\n\n\n\n465.\n\n\n\n466.统计重复个数 码力值难！\n&#x2F;&#x2F;466.统计重复个数 码力值难！\nclass Solution &#123;\npublic:\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) &#123;\n        &#x2F;&#x2F; 存一下匹配完每个s1之后是匹配了s2的第几个字符\n        &#x2F;&#x2F; 这里不对s2.size()取模，是为了能计算一共匹配到了s2的哪个位置\n        vector&lt;int&gt; cnt;&#x2F;&#x2F;s2 cnt[i]&#x3D;k\n        &#x2F;&#x2F; 哈希表快速判断余数有没有出现过\n        unordered_map&lt;int, int&gt; hash;&#x2F;&#x2F;s1 hash[k]&#x3D;i\n        &#x2F;&#x2F; i枚举匹配每个s1，k是在s2里转的指针\n        for (int i &#x3D; 0, k &#x3D; 0; i &lt; n1; i ++ ) &#123;\n            &#x2F;&#x2F; j枚举s1的每个字符\n            for (int j &#x3D; 0; j &lt; s1.size(); j ++ )\n                if (s1[j] &#x3D;&#x3D; s2[k % s2.size()]) &#x2F;&#x2F; 如果匹配上了\n                     k ++ ; &#x2F;&#x2F; 在s2里匹配的指针就往后走!!!\n            cnt.push_back(k); &#x2F;&#x2F; 每次匹配完一个s1，就把s2的指针位置k存下来!!!\n            &#x2F;&#x2F; 如果余数k对应的指针位置之前已经出现过了，就说明出现循环节了\n            if (hash.count(k % s2.size())) &#123;\n                &#x2F;&#x2F; 计算一下循环节里一共有多少个s1，也就是当前和上次是第几个s1之间的差\n                int a &#x3D; i - hash[k % s2.size()];\n                &#x2F;&#x2F; 计算一下循环节里能匹配多少个s2中的字符\n                int b &#x3D; k - cnt[hash[k % s2.size()]];\n                &#x2F;&#x2F; 还剩多少个循环节&#x3D;后面剩下的s1的个数&#x2F;循环节里的s1的个数\n                &#x2F;&#x2F; 剩下的循环节个数还要乘以每个循环节能匹配的s2中的字符数，就是剩下的循环节能匹配s2中的字符数\n                int res &#x3D; (n1 - i - 1) &#x2F; a * b;&#x2F;&#x2F;-1：单独处理最后不完整的循环节\n                &#x2F;&#x2F; 还要把最后不完整的循环节模拟一遍，找出它能匹配多少字符\n                &#x2F;&#x2F; 先遍历不完整循环节的s1个数\n                for (int u &#x3D; 0; u &lt; (n1 - i - 1) % a; u ++ )\n                    &#x2F;&#x2F; 再遍历每个s1\n                    for (int j &#x3D; 0; j &lt; s1.size(); j ++ )\n                        &#x2F;&#x2F; 如果能和s2当前位置匹配\n                        if (s1[j] &#x3D;&#x3D; s2[k % s2.size()])\n                            k ++ ;\n                res +&#x3D; k; &#x2F;&#x2F; 答案加上k，这里k既包含循环节出现之前匹配的字符，也包含最后的不完整的循环节\n                &#x2F;&#x2F; 返回的是匹配的字符数 除以 s2长度 除以n2，也就是能匹配的大S2的数量\n                return res &#x2F; s2.size() &#x2F; n2;\n            &#125;\n            &#x2F;&#x2F; 如果没有出现循环节，标记s2的余数位置k对应的是循环节的第几个s1!!!\n            &#x2F;&#x2F; 这里也是要取余，不然没法判断出现循环节（判断是s2的同一位置）\n            hash[k % s2.size()] &#x3D; i;\n        &#125;\n        &#x2F;&#x2F; 没有出现循环节\n        &#x2F;&#x2F; 如果一个字符都匹配不了，那么cnt是空的，直接返回0\n        if (cnt.empty()) return 0;\n        &#x2F;&#x2F; 返回最后匹配了s2多少个字符，除以s2的长度就是匹配了多少个s2\n        &#x2F;&#x2F; 再除以n2就是匹配了多少个大S2\n        return cnt.back() &#x2F; s2.size() &#x2F; n2;\n    &#125;\n&#125;;\n\n作者：LauZyHou\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;745466&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n467.环绕字符串中唯一的子字符串 双指针 相连[i,j) 以p[i]为起点的连续子串maxLen求和\n&#x2F;&#x2F;467.环绕字符串中唯一的子字符串 双指针 相连[i,j) 以p[i]为起点的连续子串maxLen求和\n&#x2F;*\n题目要求去重，观察到子串可以根据开头字母进行分类，最多有 26 个字母，所以最多有 26 类。\n如果我们能得到每个字母开头所能得到子串的最大长度，那么该字母开头贡献的答案子串个数就是这个最大长度。\n所以在第一步拆分的过程中，每拆分出一段 pi，就对 pi 子串中，统计每个字母开头到 pi 末尾的长度，和之前记录的长度取最大值。\n*&#x2F;\n&#x2F;&#x2F;不判重：每段长k 子串数k*(k+1)&#x2F;2\n&#x2F;&#x2F;判重“连续子串”：看 起点、maxlen&#x3D;个数\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;651359&#x2F;\nclass Solution &#123;\npublic:\n    int findSubstringInWraproundString(string p) &#123;\n        unordered_map&lt;char, int&gt; cnt;\n        for (int i &#x3D; 0; i &lt; p.size();) &#123;\n            int j &#x3D; i + 1;\n            while (j &lt; p.size() &amp;&amp; (p[j] - p[j - 1] &#x3D;&#x3D; 1 || p[j] &#x3D;&#x3D; &#39;a&#39; &amp;&amp; p[j - 1] &#x3D;&#x3D; &#39;z&#39;)) j ++ ;&#x2F;&#x2F;相连[i,j)\n            while (i &lt; j) cnt[p[i]] &#x3D; max(cnt[p[i]], j - i), i ++ ;&#x2F;&#x2F;cnt：以p[i]为起点的连续子串maxLen\n        &#125;\n        int res &#x3D; 0;\n        for (auto [a, b]: cnt) res +&#x3D; b;&#x2F;&#x2F;cnt求和\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n468.验证IP地址 模拟 对称简洁函数编码 .4:6 split 4 6 check&#x2F;&#x2F;468.验证IP地址 模拟 对称简洁函数编码 .4:6\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; split(string ip, char t) &#123;\n        vector&lt;string&gt; items;\n        for (int i &#x3D; 0; i &lt; ip.size(); i ++ ) &#123;\n            int j &#x3D; i;\n            string item;\n            while (ip[j] !&#x3D; t) item +&#x3D; ip[j ++ ];\n            i &#x3D; j;\n            items.push_back(item);\n        &#125;\n        return items;\n    &#125;\n\n    string check_ipv4(string ip) &#123;\n        auto items &#x3D; split(ip + &#39;.&#39;, &#39;.&#39;);&#x2F;&#x2F;+ &#39;.&#39;\n        if (items.size() !&#x3D; 4) return &quot;Neither&quot;;&#x2F;&#x2F;4个\n        for (auto item: items) &#123;&#x2F;&#x2F;str\n            if (item.empty() || item.size() &gt; 3) return &quot;Neither&quot;;&#x2F;&#x2F;0~&quot;255&quot;\n            if (item.size() &gt; 1 &amp;&amp; item[0] &#x3D;&#x3D; &#39;0&#39;) return &quot;Neither&quot;;&#x2F;&#x2F;不可有前导0\n            for (auto c: item)\n                if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) return &quot;Neither&quot;;&#x2F;&#x2F;非数字\n            int t &#x3D; stoi(item);&#x2F;&#x2F;int\n            if (t &gt; 255) return &quot;Neither&quot;;&#x2F;&#x2F;0~&lt;&#x3D;255\n        &#125;\n        return &quot;IPv4&quot;;\n    &#125;\n\n    bool check(char c) &#123;&#x2F;&#x2F;16进制\n        if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) return true;\n        if (c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;f&#39;) return true;\n        if (c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;F&#39;) return true;\n        return false;\n    &#125;\n\n    string check_ipv6(string ip) &#123;\n        auto items &#x3D; split(ip + &#39;:&#39;, &#39;:&#39;);\n        if (items.size() !&#x3D; 8) return &quot;Neither&quot;;&#x2F;&#x2F;8个\n        for (auto item: items) &#123;\n            if (item.empty() || item.size() &gt; 4) return &quot;Neither&quot;;&#x2F;&#x2F;0db8\n            for (auto c: item)\n                if (!check(c)) return &quot;Neither&quot;;\n        &#125;\n        return &quot;IPv6&quot;;\n    &#125;\n\n    string validIPAddress(string ip) &#123;\n        if (ip.find(&#39;.&#39;) !&#x3D; -1 &amp;&amp; ip.find(&#39;:&#39;) !&#x3D; -1) return &quot;Neither&quot;;\n        if (ip.find(&#39;.&#39;) !&#x3D; -1) return check_ipv4(ip);\n        if (ip.find(&#39;:&#39;) !&#x3D; -1) return check_ipv6(ip);\n        return &quot;Neither&quot;;\n    &#125;\n&#125;;\n\n\n\n469.\n\n\n\n470.用Rand7()实现Rand10() (0~6)*7+(1~7) &gt;40回炉 %10保留概率40&#x2F;49  期望轮数49&#x2F;40  期望次数49*2&#x2F;40&#x3D;49&#x2F;20\n进阶：rand7() 调用次数的 期望值 是多少 ? 49&#x2F;20\n\n&#x2F;&#x2F;470.用Rand7()实现Rand10() (0~6)*7+(1~7) &gt;40回炉 %10\n&#x2F;&#x2F; 两次7就是49，就超过10了，然后把10的整数40以内的数保留下来，按模就知道随机到了哪个数。\n&#x2F;&#x2F; 保留概率40&#x2F;49  期望轮数49&#x2F;40  期望次数49*2&#x2F;40&#x3D;49&#x2F;20\n&#x2F;&#x2F; 进阶：rand7() 调用次数的 [期望值](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Expected_value) 是多少 ? 49&#x2F;20\nclass Solution &#123;\npublic:\n    int rand10() &#123;\n        &#x2F;&#x2F; 调用两次rand7生成1-49之间的数\n        int t &#x3D; (rand7() - 1) * 7 + rand7(); &#x2F;&#x2F; 1到49 随机区间里的随机 (0~6)*7+(1~7)\n        &#x2F;&#x2F; 只有1到40保留下来\n        if (t &gt; 40) return rand10();&#x2F;&#x2F;回炉重造~\n        int m &#x3D; t % 10;&#x2F;&#x2F;%10等概率\n        return m &#x3D;&#x3D; 0 ? 10 : m;\n    &#125;\n&#125;;\n\n\n\n\n\n\n471.\n\n\n\n\n\nTLE？472.连接词 hash+DP:O(n^3*m) 向后转移 f[i]&lt;0 continue; f[n]&gt;1 return true;  acw841.str_hash可优化至O(n*n*m)\n&#x2F;&#x2F;TLE...\nclass Solution &#123;\npublic:\n    unordered_set&lt;string&gt; hash;&#x2F;&#x2F;O(1)判断存在\n\n    bool check(string&amp; word) &#123;&#x2F;&#x2F;是连接词\n        int n &#x3D; word.size();\n        vector&lt;int&gt; f(n + 1, INT_MIN);&#x2F;&#x2F;f[i]:前i个字符最多可拆words\n        f[0] &#x3D; 0;&#x2F;&#x2F;空串由0个字符串组成\n        for (int i &#x3D; 0; i &lt;&#x3D; n; i ++ ) &#123;\n            if (f[i] &lt; 0) continue;&#x2F;&#x2F;剪枝1\n            for (int j &#x3D; n - i; j; j -- ) &#123;&#x2F;&#x2F;j逆序：让2尽早剪枝掉\n                if (hash.count(word.substr(i, j))) &#123;\n                    f[i + j] &#x3D; max(f[i + j], f[i] + 1);&#x2F;&#x2F;\n                    if (f[n] &gt; 1) return true;&#x2F;&#x2F;剪枝2：前n个字符最多可拆&gt;1words\n                &#125;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n\n    vector&lt;string&gt; findAllConcatenatedWordsInADict(vector&lt;string&gt;&amp; words) &#123;\n        for (auto&amp; word: words) hash.insert(word);\n        vector&lt;string&gt; res;\n        for (auto&amp; word: words)\n            if (check(word))\n                res.push_back(word);\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n473.火柴拼正方形[LC698] 经典dfs剪枝：拼4根等长 扩展：提高课_搜索_acw167.木棒：拼m根等长 蓝书P104！！！ 从大到小sort 3根true 失败：回溯st  某条边上的第一根&#x2F;最后一根 false nums_sorted跳过等长\n&#x2F;&#x2F;473.火柴拼正方形 经典dfs剪枝：拼4根等长 扩展：提高课_搜索_acw167.木棒：拼m根等长 蓝书P104！！！\n&#x2F;*\n非常经典的dfs剪枝例题\n\n1.从大到小枚举\n2.每条边内部，要求火柴编号递增，也就是按照给定的顺序去枚举\n3.如果当前放某根火柴失败了（也就是在某条边上加了某个火柴之后，剩余的火柴没法凑出目标情况）\n3.1 要跳过相等长度的火柴，因为继续使用相等长度的火柴代替这个火柴的效果也是一模一样的\n3.2 如果失败的时候，是放的某条边上的第一根火柴就失败了，则直接剪掉当前分支\n3.3 如果失败的时候，是放的某条边上的最后一根火柴失败的，也直接剪掉当前分支\n*&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; nums;\n    vector&lt;bool&gt; st;\n    int sum;\n\n    bool dfs(int start, int cur, int cnt) &#123;&#x2F;&#x2F;起点:控制边内部火柴编号递增 cur已拼长 已拼好几根\n        if (cnt &#x3D;&#x3D; 3) return true;&#x2F;&#x2F;3根即可！\n        if (cur &#x3D;&#x3D; sum) return dfs(0, 0, cnt + 1);\n        for (int i &#x3D; start; i &lt; nums.size(); i ++ ) &#123;\n            if (st[i]) continue;&#x2F;&#x2F;\n            if (cur + nums[i] &lt;&#x3D; sum) &#123;\n                st[i] &#x3D; true;\n                if (dfs(i + 1, cur + nums[i], cnt)) return true;&#x2F;&#x2F;枚举+i后\n                st[i] &#x3D; false;&#x2F;&#x2F;回溯\n            &#125;\n            if (!cur || cur + nums[i] &#x3D;&#x3D; sum) return false;&#x2F;&#x2F;3.2 3.3\n            while (i + 1 &lt; nums.size() &amp;&amp; nums[i + 1] &#x3D;&#x3D; nums[i])&#x2F;&#x2F;3.1 nums_sorted 跳过等长\n                i ++ ;\n        &#125;\n        return false;\n    &#125;\n\n    bool makesquare(vector&lt;int&gt;&amp; _nums) &#123;\n        nums &#x3D; _nums;\n        if (nums.empty()) return false;\n        st.resize(nums.size());\n        sum &#x3D; 0;\n        for (auto x: nums) sum +&#x3D; x;\n        if (sum % 4) return false;\n        sum &#x2F;&#x3D; 4;&#x2F;&#x2F;4根等长&#x3D;sum\n        sort(nums.begin(), nums.end(), greater&lt;int&gt;());&#x2F;&#x2F;从大到小\n        return dfs(0, 0, 0);\n    &#125;\n&#125;;\n\n\n\n\n474.一和零 最多m0n1的最大子集size [选择问题本质上&#x3D;背包] acw8.二维费用的背包问题 01背包:物品只能用一次 逆序  f[i-1,j-vi,k-mi]+wi maxCnt:wi&#x3D;1\n&#x2F;&#x2F;474.一和零 最多m0n1的最大子集size [选择问题本质上&#x3D;背包] acw8.二维费用的背包问题\nclass Solution &#123;\npublic:\n    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1));\n        for (auto&amp; str: strs) &#123;\n            int a &#x3D; 0, b &#x3D; 0;\n            for (auto c: str)\n                if (c &#x3D;&#x3D; &#39;0&#39;) a ++ ;\n                else b ++ ;\n            for (int i &#x3D; m; i &gt;&#x3D; a; i -- )&#x2F;&#x2F;01背包:物品只能用一次 逆序\n                for (int j &#x3D; n; j &gt;&#x3D; b; j -- )\n                    f[i][j] &#x3D; max(f[i][j], f[i - a][j - b] + 1);&#x2F;&#x2F;f[i-1,j-vi,k-mi]+wi maxCnt:wi&#x3D;1\n        &#125;\n        return f[m][n];\n    &#125;\n&#125;;\n\n\n\n\n475.供暖器 都能供上的min供暖半径(&#x3D;) O(nlogn)二分+双指针：单调性[房子右移区间右移] j:能覆盖当前房子的最左侧区间 check:都能覆盖到\n&#x2F;&#x2F;475.供暖器 都能供上的min供暖半径(&#x3D;) O(nlogn)二分+双指针：单调性[房子右移区间右移] j:能覆盖当前房子的最左侧区间\nclass Solution &#123;\npublic:\n    bool check(int mid, vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;\n        for (int i &#x3D; 0, j &#x3D; 0; i &lt; houses.size(); i ++ ) &#123;\n            while (j &lt; heaters.size() &amp;&amp; abs(heaters[j] - houses[i]) &gt; mid)\n                j ++ ;&#x2F;&#x2F;j:能覆盖当前房子的最左侧区间\n            if (j &gt;&#x3D; heaters.size()) return false;&#x2F;&#x2F;house[i]覆盖不到\n        &#125;\n        return true;&#x2F;&#x2F;都能覆盖到\n    &#125;\n\n    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n        int l &#x3D; 0, r &#x3D; INT_MAX;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (long long)l + r &gt;&gt; 1;\n            if (check(mid, houses, heaters)) r &#x3D; mid;&#x2F;&#x2F;min_r\n            else l &#x3D; mid + 1;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n\n\n476.数字的补数 低cnt位[&amp;cnt个全1]取反 cnt&#x3D;31会溢出int&#x2F;&#x2F;476.数字的补数\nclass Solution &#123;\npublic:\n    int findComplement(int num) &#123;\n        if (!num) return 1;\n        int cnt &#x3D; 0;\n        for (int x &#x3D; num; x; x &gt;&gt;&#x3D; 1) cnt ++ ;&#x2F;&#x2F;位数\n        return ~num &amp; ((1ll &lt;&lt; cnt) - 1);&#x2F;&#x2F;低cnt位[&amp;cnt个全1]取反 cnt&#x3D;31会溢出int\n    &#125;\n&#125;;\n\n\n\n477.汉明距离总和 按位统计 乘法原理：bin第i位&#x3D;0cnt * 第i位&#x3D;1cnt O(31n)\nclass Solution &#123;\npublic:\n    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt;&#x3D; 30; i ++ ) &#123;\n            int x &#x3D; 0, y &#x3D; 0;\n            for (auto c: nums)\n                if (c &gt;&gt; i &amp; 1) y ++ ;\n                else x ++ ;\n            res +&#x3D; x * y;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n478.在圆内随机生成点 框内采(-1,1)圆外回炉、极坐标直接采sqrt(r^2 * (0,1)) M_PI  1.0*、(double)&#x2F;&#x2F;478.在圆内随机生成点 等概率\n&#x2F;&#x2F; 外切框内圆外:回炉重采样 期望次数：4&#x2F;pi rand()&#x2F;RAND_MAX&#x3D;(0,1) 标准位移(-1,1)\nclass Solution &#123;\npublic:\n    double r, x, y;\n\n    Solution(double radius, double x_center, double y_center) &#123;\n        r &#x3D; radius, x &#x3D; x_center, y &#x3D; y_center;\n    &#125;\n\n    vector&lt;double&gt; randPoint() &#123;\n        double a &#x3D; (double)rand() &#x2F; RAND_MAX * 2 - 1;&#x2F;&#x2F;(-1,1) 或 1.0 *\n        double b &#x3D; (double)rand() &#x2F; RAND_MAX * 2 - 1;\n        if (a * a + b * b &gt; 1) return randPoint();&#x2F;&#x2F;圆外回炉\n        return &#123;x + r * a, y + r * b&#125;;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;solution&#x2F;content&#x2F;23141&#x2F;\n&#x2F;&#x2F;法二：极坐标圆内直接采样\n&#x2F;&#x2F; r&#x3D;1&#x2F;2 面积&#x3D;pi&#x2F;4 与圆心的距离是二维的，需要在 [0, r^2] 内采样然后开方，才能保证是均匀分布。\n&#x2F;&#x2F; 角度直接在 [0, 2 * pi] 内采样就可以。 M_PI！！！\nclass Solution &#123;\nprivate:\n    double r, x, y;\n\npublic:\n    Solution(double radius, double x_center, double y_center) &#123;\n        r &#x3D; radius, x &#x3D; x_center, y &#x3D; y_center;\n    &#125;\n\n    vector&lt;double&gt; randPoint() &#123;\n        double cr &#x3D; r * sqrt(1.0 * rand() &#x2F; RAND_MAX);&#x2F;&#x2F;sqrt(r^2 * (0,1))\n        double angle &#x3D; 2 * M_PI * rand() &#x2F; RAND_MAX;\n        double cx &#x3D; x + cr * cos(angle), cy &#x3D; y + cr * sin(angle);\n        return &#123;cx, cy&#125;;\n    &#125;\n&#125;;\n\n\n\n479.最大回文数乘积(n位数的) 3*3&#x3D;9 从大到小枚举回文结果”i+reverse_i” stoll 枚举较大n位数a&gt;&#x3D;b a*a&gt;&#x3D;[ab&#x3D;num] for(j*j &gt;&#x3D; num)num%j &#x3D;&#x3D; 0&#x2F;&#x2F;479.最大回文数乘积\n&#x2F;&#x2F; 如果都不大于回文数，除完之后的另一个数一定是比自己大的，那种情况要么已经枚举过了，要么就是另一个数已经不是n位数了。\n&#x2F;&#x2F; n&#x3D;1时候，只有3∗3&#x3D;9。n&#x3D;2到n&#x3D;8的时候，2n位数里一定是有答案的。\nclass Solution &#123;\npublic:\n    int largestPalindrome(int n) &#123;\n        typedef long long LL;\n        if (n &#x3D;&#x3D; 1) return 9;&#x2F;&#x2F;9~&gt;4平方都不是回文数 3*3&#x3D;9 1*9&#x3D;9 i*11&#x3D;&quot;ii&quot;错\n        int maxv &#x3D; pow(10, n) - 1;&#x2F;&#x2F;n个9\n        for (int i &#x3D; maxv; ;i -- ) &#123;&#x2F;&#x2F;从大到小枚举回文结果&quot;i+reverse_i&quot;\n            auto a &#x3D; to_string(i);\n            auto b &#x3D; a;\n            reverse(b.begin(), b.end());\n            auto num &#x3D; stoll(a + b);&#x2F;&#x2F;str-&gt;ll 回文结果num\n            for (LL j &#x3D; maxv; j * j &gt;&#x3D; num; j -- )&#x2F;&#x2F;枚举较大n位数a&gt;&#x3D;b a*a&gt;&#x3D;[ab&#x3D;num] 99*99&lt;9999 &lt;9889 &lt;9779...&gt;&#x3D;9009进loop\n                if (num % j &#x3D;&#x3D; 0)&#x2F;&#x2F; 9009&#x2F;99&#x3D;91\n                    return num % 1337;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n\n\n\n480.滑动窗口中位数 +-动态中位数 O(nlogn)对顶堆 multiset:-任意(rbTree) init get 滑动:+x-y调整为r多1-&gt;&lt;- get_median&#x2F;&#x2F;480.滑动窗口中位数 +-动态中位数 O(nlogn)对顶堆 multiset:-任意(rbTree)\nclass Solution &#123;\npublic:\n\tint k;\n\tmultiset&lt;int&gt; left, right;\n\n\tdouble get_medium() &#123;\n\t\tif (k % 2) return *right.begin();\n\t\treturn ((double)*left.rbegin() + *right.begin()) &#x2F; 2;\n\t&#125;\n\n\tvector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int _k) &#123;\n\t\tk &#x3D; _k;\n\t\t&#x2F;&#x2F;init\n\t\tfor (int i &#x3D; 0; i &lt; k; i ++ ) right.insert(nums[i]);\n\t\tfor (int i &#x3D; 0; i &lt; k &#x2F; 2; i ++ ) &#123;&#x2F;&#x2F;r多一\n\t\t\tleft.insert(*right.begin());\n\t\t\tright.erase(right.begin());\n\t\t&#125;\n\t\tvector&lt;double&gt; res;\n\t\tres.push_back(get_medium());&#x2F;&#x2F;get\n\t\tfor (int i &#x3D; k; i &lt; nums.size(); i ++ ) &#123;\n\t\t\tint x &#x3D; nums[i], y &#x3D; nums[i - k];&#x2F;&#x2F;+x-y\n\t\t\tif (x &gt;&#x3D; *right.begin()) right.insert(x);&#x2F;&#x2F;+\n\t\t\telse left.insert(x);\n\t\t\tif (y &gt;&#x3D; *right.begin()) right.erase(right.find(y));&#x2F;&#x2F;- find(y)只删一个y\n\t\t\telse left.erase(left.find(y));\n\t\t\t&#x2F;&#x2F;调整为r多1\n\t\t\twhile (left.size() &gt; right.size()) &#123;&#x2F;&#x2F;l&gt;r:l-&gt;r\n\t\t\t\tright.insert(*left.rbegin());\n\t\t\t\tleft.erase(left.find(*left.rbegin()));&#x2F;&#x2F;\n\t\t\t&#125;\n\t\t\twhile (right.size() &gt; left.size() + 1) &#123;&#x2F;&#x2F;r&gt;l+1:l&lt;-r\n\t\t\t\tleft.insert(*right.begin());\n\t\t\t\tright.erase(right.begin());\n\t\t\t&#125;\n\t\t\tres.push_back(get_medium());&#x2F;&#x2F;get\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n&#125;;\n\n\n\n\n\n481.神奇的字符串 cnt串&#x3D;原串 求前n位cnt1 模拟: k&#x3D;3-k&#x3D;1、2交替 s+&#x3D;s[i]个kclass Solution &#123;\npublic:\n    int magicalString(int n) &#123;\n        string s &#x3D; &quot;122&quot;;\n        for(int i &#x3D; 2, k &#x3D; 1;s.size() &lt; n; i++, k &#x3D; 3 - k) &#123;&#x2F;&#x2F;k&#x3D;3-k 1、2交替\n            for(int j &#x3D; 0; j &lt; s[i] - &#39;0&#39;; j++)&#x2F;&#x2F;s[i]个k\n                s +&#x3D; to_string(k);\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++) res +&#x3D; s[i] &#x3D;&#x3D; &#39;1&#39;;&#x2F;&#x2F;\n        return res;\n    &#125;\n&#125;;\n\n\n\n482.密钥格式化 ‘-‘K个一隔 余数在前[if有！] toupper 模拟:先去’-‘ if(res.size())res+&#x3D;’-‘;&#x2F;&#x2F;没余数 res空 不加前导’-‘!class Solution &#123;\npublic:\n    string licenseKeyFormatting(string S, int K) &#123;\n        string s;\n        for (auto c: S)\n            if (c !&#x3D; &#39;-&#39;)\n                s +&#x3D; c;\n        string res;\n        for (int i &#x3D; 0; i &lt; s.size() % K; i ++ ) res +&#x3D; toupper(s[i]);&#x2F;&#x2F;if %K&gt;0:有余数\n        for (int i &#x3D; s.size() % K; i &lt; s.size();) &#123;\n            if (res.size()) res +&#x3D; &#39;-&#39;;&#x2F;&#x2F;8%4&#x3D;&#x3D;0没余数 res空 不加前导&#39;-&#39;!!!\n            for (int j &#x3D; 0; j &lt; K; j ++ )\n                res +&#x3D; toupper(s[i ++ ]);&#x2F;&#x2F;res才不空 才加前导&#39;-&#39;!!!\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n483.最小好进制 k&gt;&#x3D;2 全1 二分-&gt;数学夹逼 stoll pow 1.0&#x2F; 枚举k进制数位数t:t&#x3D;log2(n)+1;t &gt;&#x3D; 3   0t次*k+1&#x3D;k进制t位全1&#x3D;r&#x3D;&#x3D;n 特判：t&#x3D;2时k&#x3D;n-1 因为(n-1)+1&#x3D;n原数n、进制k&lt;&#x3D;10^18    位数t&lt;&#x3D;60\n\npow 取整数部分k 回代验证\n\n&#x2F;&#x2F;483.最小好进制 k&gt;&#x3D;2 全1 数学夹逼 枚举k进制数位数t\n&#x2F;&#x2F; 原数n、进制k&lt;&#x3D;10^18    位数t&lt;&#x3D;60\n&#x2F;&#x2F; pow 取整数部分 k回代验证\nclass Solution &#123;\npublic:\n    string smallestGoodBase(string number) &#123;\n        typedef long long LL;\n        LL n &#x3D; stoll(number);\n        for (int t &#x3D; log2(n) + 1; t &gt;&#x3D; 3; t -- ) &#123;&#x2F;&#x2F;t &gt;&#x3D; 3\n            LL k &#x3D; pow(n, 1.0 &#x2F; (t - 1));\n            LL r &#x3D; 0;\n            for (int i &#x3D; 0; i &lt; t; i ++ ) r &#x3D; r * k + 1;&#x2F;&#x2F;秦九韶算法：0t次*k+1&#x3D;k进制t位全1\n            if (r &#x3D;&#x3D; n) return to_string(k);\n        &#125;\n        return to_string(n - 1);&#x2F;&#x2F;特判：t&#x3D;2时k&#x3D;n-1 因为(n-1)+1&#x3D;n\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; 同acw628.美丽的数 二分做法\n&#x2F;&#x2F; https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;problem&#x2F;content&#x2F;2283&#x2F;\n#include &lt;iostream&gt;\nusing namespace std;\ntypedef long long LL;\n\nint check(LL n, LL b, int i)\n&#123;\n    LL res &#x3D; 0;\n    for (int k &#x3D; 0; k &lt; i; k++)\n    &#123;\n        if (res &gt; (n - 1) &#x2F; b) return 1; &#x2F;&#x2F;使用除法，防止数据溢出, res * b + 1会溢出\n        res &#x3D; res * b + 1;\n    &#125;\n    if (res &#x3D;&#x3D; n) return 0;\n\n    return -1;\n&#125;\n\nint main()\n&#123;\n   int T;\n   cin &gt;&gt; T;\n\n   &#x2F;&#x2F;整数n能不能用某一个进制b表示成连续i个1的形式\n   &#x2F;&#x2F;从大到小枚举i\n   &#x2F;&#x2F;二分出进制b，满足进制数大于b的进制表示下，n小于连续i个1，小于b的进制n大于连续i个1表示的数\n   &#x2F;&#x2F;最终答案就是n等于连续i个1表示的数\n   for (int t &#x3D; 1; t &lt;&#x3D; T; t++)\n   &#123;\n        LL n;\n        cin &gt;&gt; n;\n\n        for (int i &#x3D; 63; i &gt; 0; i--) &#x2F;&#x2F;二分枚举\n        &#123;\n            LL l &#x3D; 2, r &#x3D; n;\n            while (l &lt; r)\n            &#123;\n                LL mid &#x3D; (l + r) &#x2F; 2;\n                if (check(n, mid, i) &gt;&#x3D; 0) r &#x3D; mid;\n                else l &#x3D; mid + 1;\n            &#125;\n            if (check(n, l, i) &#x3D;&#x3D; 0) &#x2F;&#x2F;整数n可以在l进制下表示i位1.\n            &#123;\n                printf(&quot;Case #%d: %lld\\n&quot;, t, l);\n                break;\n            &#125;\n        &#125;\n   &#125;\n\n    return 0;\n&#125;\n\n\n\n\n484.\n\n\n\n485.最大连续1的个数 easy双指针&#x2F;&#x2F;485.最大连续1的个数 easy双指针\nclass Solution &#123;\npublic:\n    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; nums.size(); i ++ ) &#123;\n            if (nums[i] &#x3D;&#x3D; 0) continue;&#x2F;&#x2F;\n            int j &#x3D; i + 1;\n            while (j &lt; nums.size() &amp;&amp; nums[j] &#x3D;&#x3D; 1) j ++ ;\n            res &#x3D; max(res, j - i);\n            i &#x3D; j;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n486.预测赢家 博弈论[区间DP：循环注意枚举顺序len i(j&#x3D;i+len-1)、记忆化搜索] 首尾取 wo先手胜否 f(i,j):余(i,j) wo-ta分数的max差值 f(i,j)&#x3D;max(-f(i+1,j)+ai,-f(i,j-1)+aj)  len&#x3D;&#x3D;1:f[ij]&#x3D;nums[i]  return f[0,n-1]&gt;&#x3D;0;\n状态数O(n*n) 转移O(1)\n&#x2F;&#x2F;486.预测赢家 博弈论[区间DP：循环注意枚举顺序！、记忆化搜索] 首尾取 wo先手胜否\n&#x2F;&#x2F; f(i,j):余(i,j)时wo-ta分数的max差值 f(i,j)&#x3D;max(-f(i+1,j)+ai,-f(i,j-1)+aj)\nclass Solution &#123;\npublic:\n    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(n));\n        for (int len &#x3D; 1; len &lt;&#x3D; n; len ++ ) &#123;&#x2F;&#x2F;len i(j&#x3D;i+len-1)\n            for (int i &#x3D; 0; i + len - 1 &lt; n; i ++ ) &#123;\n                int j &#x3D; i + len - 1;\n                if (len &#x3D;&#x3D; 1) f[i][j] &#x3D; nums[i];&#x2F;&#x2F;\n                else &#123;\n                    f[i][j] &#x3D; max(nums[i] - f[i + 1][j], nums[j] - f[i][j - 1]);\n                &#125;\n            &#125;\n        &#125;\n        return f[0][n - 1] &gt;&#x3D; 0;&#x2F;&#x2F;从小到大递推：分数max差值&gt;&#x3D;0 先手胜\n    &#125;\n&#125;;\n\n\n\n\n487.\n\n\n\n—488.祖玛游戏 爆搜+剪枝 难 code2…ing&#x2F;&#x2F;488.祖玛游戏\n&#x2F;&#x2F;yxc保证对+优化版：dfs(,get()) f[+&#39; &#39;+hand] ans&#x3D;min &gt;&#x3D;ans 启发式估价函数\nclass Solution &#123;\npublic:\n    unordered_map&lt;string, int&gt; f;&#x2F;&#x2F;到某状态的min_step\n    unordered_map&lt;char, int&gt; cnt;&#x2F;&#x2F;手里的每种球数\n    int ans &#x3D; 6;\n\n    int findMinStep(string board, string hand) &#123;\n        for (auto c: hand) cnt[c] ++ ;\n        f[board] &#x3D; 0;\n        dfs(board, get());\n        if (ans &#x3D;&#x3D; 6) ans &#x3D; -1;&#x2F;&#x2F;ans&lt;&#x3D;5\n        return ans;\n    &#125;\n\n    string clean_up(string s) &#123;&#x2F;&#x2F;不停消连续段\n        bool is_changed &#x3D; true;\n        while (is_changed) &#123;\n            is_changed &#x3D; false;\n            for (int i &#x3D; 0; i &lt; s.size(); i ++ ) &#123;\n                int j &#x3D; i + 1;\n                while (j &lt; s.size() &amp;&amp; s[j] &#x3D;&#x3D; s[i]) j ++ ;\n                if (j - i &gt;&#x3D; 3) &#123;&#x2F;&#x2F;\n                    s &#x3D; s.substr(0, i) + s.substr(j);\n                    is_changed &#x3D; true;&#x2F;&#x2F;消了才true继续,否则false结束[不停消]\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return s;\n    &#125;\n\n    string get() &#123;\n        string res;\n        for (auto [x, c]: cnt) res +&#x3D; to_string(c);\n        return res;\n    &#125;\n\n    int h(string board) &#123;  &#x2F;&#x2F; +IDA*启发式搜索：至少还需要多少次操作[估价函数]\n        sort(board.begin(), board.end());\n        int res &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; board.size();) &#123;\n            int j &#x3D; i + 1;\n            while (j &lt; board.size() &amp;&amp; board[j] &#x3D;&#x3D; board[i]) j ++ ;\n            if (j - i + cnt[board[i]] &lt; 3) return 6;&#x2F;&#x2F;无连续 6无解\n            if (j - i &lt;&#x3D; 2) res +&#x3D; 3 - (j - i);&#x2F;&#x2F;必须从手里拿球:至少还需要3-(j-i)步\n            i &#x3D; j;\n        &#125;\n        return res;\n    &#125;\n\n    void dfs(string board, string hand) &#123;\n        if (f[board + &#39; &#39; + hand] + h(board) &gt;&#x3D; ans) return;&#x2F;&#x2F;不能更新min_ans\n        for (auto [x, c]: cnt) &#123;\n            if (c) &#123;\n                -- cnt[x];&#x2F;&#x2F;\n                for (int i &#x3D; 0; i &lt;&#x3D; board.size(); i ++ ) &#123;\n                    auto r &#x3D; clean_up(board.substr(0, i) + x + board.substr(i));&#x2F;&#x2F;插入pos i\n                    auto s &#x3D; r + &#39; &#39; + get();&#x2F;&#x2F;+inhand球数集合\n                    if (f.count(s) &#x3D;&#x3D; 0 || f[s] &gt; f[board + &#39; &#39; + hand] + 1) &#123;\n                        f[s] &#x3D; f[board + &#39; &#39; + hand] + 1;\n                        if (r.empty()) ans &#x3D; min(ans, f[s]);&#x2F;&#x2F;\n                        dfs(r, get());\n                    &#125;\n                &#125;\n                ++ cnt[x];\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;快！\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zuma-game&#x2F;solution&#x2F;zu-ma-you-xi-by-617076674&#x2F;\nclass Solution &#123;\npublic:\n    int res &#x3D; INT_MAX;\n    int findMinStep(string board, string hand) &#123;\n        int cnt[26] &#x3D; &#123;0&#125;;\n        for (char color : hand) &#123;\n            cnt[color - &#39;A&#39;]++;\n        &#125;\n        backTracking(board, cnt, 0);\n        return res &#x3D;&#x3D; INT_MAX ? -1 : res; \n    &#125;\n\n    void backTracking(string &amp;board, int *cnt, int step) &#123;\n        if (step &gt;&#x3D; res) &#123;\n            return;\n        &#125;\n        if (board.empty()) &#123;\n            res &#x3D; min(res, step);\n            return;\n        &#125;\n        &#x2F;&#x2F; 效仿下面的函数removeBalls\n        for (int slow &#x3D; 0, fast &#x3D; 0; fast &lt;&#x3D; board.size(); fast++) &#123;\n            if (fast &lt; board.size() &amp;&amp; board[slow] &#x3D;&#x3D; board[fast]) &#123;\n                continue;\n            &#125;\n            int need &#x3D; 3 - (fast - slow); &#x2F;&#x2F; 在两个连续相同球之后(或者单个球)需要插入的球数\n            if (cnt[board[slow] - &#39;A&#39;] &gt;&#x3D; need) &#123; \n                &#x2F;&#x2F; 删除[slow, fast)段的字符串（str.substr(str.size()) 返回的是空串）\n                string newBoard &#x3D; board.substr(0, slow) + board.substr(fast);\n                removeBalls(newBoard);\n                cnt[board[slow] - &#39;A&#39;] -&#x3D; need;\n                backTracking(newBoard, cnt, step + need);\n                cnt[board[slow] - &#39;A&#39;] +&#x3D; need;\n            &#125;\n            &#x2F;&#x2F; 在两个连续相同球之间插入不同的球\n            if (need &#x3D;&#x3D; 1) &#123;\n                for (char color : &#123;&#39;R&#39;, &#39;Y&#39;, &#39;B&#39;, &#39;G&#39;, &#39;W&#39;&#125;) &#123;\n                    if (color &#x3D;&#x3D; board[slow] || cnt[color - &#39;A&#39;] &#x3D;&#x3D; 0) continue;\n                    string newBoard &#x3D; board;\n                    newBoard.insert(newBoard.begin() + slow + 1, color);\n                    cnt[color - &#39;A&#39;]--;\n                    backTracking(newBoard, cnt, step + 1);\n                    cnt[color - &#39;A&#39;]++;\n                &#125;\n            &#125;\n            slow &#x3D; fast;\n        &#125;\n    &#125;\n\n    void removeBalls(string &amp;board) &#123; \n        for (int slow &#x3D; 0, fast &#x3D; 0; fast &lt;&#x3D; board.size(); fast++) &#123;\n            if (fast &lt; board.size() &amp;&amp; board[slow] &#x3D;&#x3D; board[fast]) &#123;\n                continue;\n            &#125; \n            if (fast - slow &gt;&#x3D; 3) &#123; &#x2F;&#x2F; 删除[slow, fast)段的字符串\n                board.erase(slow, fast - slow);\n                fast &#x3D; 0; &#x2F;&#x2F; 回到字符串开头\n            &#125; \n            slow &#x3D; fast;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n489.\n\n\n\n490.\n\n\n\n491.递增子序列 所有方案：爆搜 判重：枚举当前序列下一个数从哪一个位置开始选 unordered_set count insert&#x2F;&#x2F; 题目要求返回所有方案，那只能直接爆搜。\n&#x2F;&#x2F; 因为这道题目要判重，所以如果直接判断每个数选不选的情况是比较难做的。这里的做法是枚举当前序列下一个数从哪一个位置开始选。\nclass Solution &#123;\npublic:\n\tvector&lt;vector&lt;int&gt;&gt; ans;\n\tvector&lt;int&gt; path;\n\n\tvector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;\n\t\tdfs(nums, 0);\n\t\treturn ans;\n\t&#125;\n\n\tvoid dfs(vector&lt;int&gt;&amp; nums, int start) &#123; &#x2F;&#x2F; start表示当前序列下一个数从哪一个位置开始选\n\t\t&#x2F;&#x2F; 这种方式在每个位置都要加答案一下\n\t\tif (path.size() &gt;&#x3D; 2) ans.push_back(path);\n\t\t&#x2F;&#x2F; 如果已经到头了就直接返回\n\t\tif (start &#x3D;&#x3D; nums.size()) return;\n\t\t&#x2F;&#x2F; 枚举一下下一个数是哪个数\n\t\t&#x2F;&#x2F; 判重，在每一层里面开一个哈希表，记录这一层已经尝试过的数字，后面就不用再尝试了\n\t\tunordered_set&lt;int&gt; S;\n\t\tfor (int i &#x3D; start; i &lt; nums.size(); i ++ ) &#123;\n\t\t\tif (path.empty() || path.back() &lt;&#x3D; nums[i]) &#123;\n\t\t\t\tif (S.count(nums[i])) continue;&#x2F;&#x2F;判重:后4可换为前4 已遍历过\n\t\t\t\tS.insert(nums[i]);&#x2F;&#x2F;\n\t\t\t\tpath.push_back(nums[i]);\n\t\t\t\tdfs(nums, i + 1);\n\t\t\t\tpath.pop_back();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n&#x2F;*\n\tvoid dfs(vector&lt;int&gt;&amp; nums, int u) &#123; &#x2F;&#x2F; u:当前位 枚举每一位选不选(不判重！)\n\t\tif(u &#x3D;&#x3D; nums.size()) &#123;\n\t\t\tif (path.size() &gt;&#x3D; 2) ans.push_back(path);\n\t\t\treturn;\n\t\t&#125;\n\t\tdfs(nums, u + 1);&#x2F;&#x2F;cur不选\n\t\tif (path.empty() || path.back() &lt;&#x3D; nums[u]) &#123;&#x2F;&#x2F;能选:单增\n\t\t\tpath.push_back(nums[u]);\n\t\t\tdfs(nums, u + 1);\n\t\t\tpath.pop_back();&#x2F;&#x2F;\n\t\t&#125;\n\t&#125;\n*&#x2F;\n\n&#125;;\n\n\n\n\n\n492.构造矩形 L&gt;&#x3D;W 暴力枚举 O(√n)&#x2F;&#x2F;492.构造矩形 暴力枚举 O(√n)\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; constructRectangle(int area) &#123;\n        for (int w &#x3D; sqrt(area); w &gt;&#x3D; 1; w--)&#x2F;&#x2F;w*w&lt;&#x3D;w*L&#x3D;&#x3D;n w&lt;&#x3D;√n\n            if (area % w &#x3D;&#x3D; 0)\n                return &#123;area &#x2F; w, w&#125;;&#x2F;&#x2F;L&gt;&#x3D;W\n\n        return &#123;area, 1&#125;;&#x2F;&#x2F;area是质数\n    &#125;\n&#125;;\n\n\n\n493.翻转对 ai&gt;2*aj逆序对cnt 离散化+树状数组 !!!归并排序[分治]: 递归 ij跨lr j-(mid+1) 选小的归并 w[0…覆盖原数组n[l…class Solution &#123;\npublic:\n    vector&lt;int&gt; w;\n\n    int reversePairs(vector&lt;int&gt;&amp; nums) &#123;\n        return merge_sort(nums, 0, nums.size() - 1);\n    &#125;\n\n    int merge_sort(vector&lt;int&gt;&amp; nums, int l, int r) &#123;\n        if (l &gt;&#x3D; r) return 0;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        int res &#x3D; merge_sort(nums, l, mid) + merge_sort(nums, mid + 1, r);&#x2F;&#x2F;递归\n        for (int i &#x3D; l, j &#x3D; mid + 1; i &lt;&#x3D; mid; i ++ ) &#123;&#x2F;&#x2F;ij跨lr\n            while (j &lt;&#x3D; r &amp;&amp; nums[j] * 2ll &lt; nums[i]) j ++ ;\n            res +&#x3D; j - (mid + 1);&#x2F;&#x2F;“逆序对”数\n        &#125;\n        &#x2F;&#x2F;归并排序 选小的归并\n        w.clear();\n        int i &#x3D; l, j &#x3D; mid + 1;\n        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n            if (nums[i] &lt;&#x3D; nums[j]) w.push_back(nums[i ++ ]);\n            else w.push_back(nums[j ++ ]);\n        while (i &lt;&#x3D; mid) w.push_back(nums[i ++ ]);\n        while (j &lt;&#x3D; r) w.push_back(nums[j ++ ]);\n        &#x2F;&#x2F;w[0...覆盖原数组n[l...\n        for (i &#x3D; l, j &#x3D; 0; j &lt; w.size(); i ++, j ++ ) nums[i] &#x3D; w[j];\n        return res;\n    &#125;\n&#125;;\n\n\n\n\n494.目标和 +-号case数 标准DP：f&#x3D;前i个总和j的case数 S&#x3D;[-1k,1k] offset&#x3D;1k a[i-1]\n&#x2F;&#x2F;494.目标和 +-号case数 标准DP：S&#x3D;[-1k,1k] offset&#x3D;1k a[i-1]\nclass Solution &#123;\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; a, int S) &#123;\n        if (S &lt; -1000 || S &gt; 1000) return 0;\n        int n &#x3D; a.size(), Offset &#x3D; 1000;&#x2F;&#x2F;\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2001));\n        f[0][Offset] &#x3D; 1;&#x2F;&#x2F;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; -1000; j &lt;&#x3D; 1000; j ++ ) &#123;\n                if (j - a[i - 1] &gt;&#x3D; -1000)&#x2F;&#x2F;正\n                    f[i][j + Offset] +&#x3D; f[i - 1][j - a[i - 1] + Offset];\n                if (j + a[i - 1] &lt;&#x3D; 1000)&#x2F;&#x2F;负\n                    f[i][j + Offset] +&#x3D; f[i - 1][j + a[i - 1] + Offset];\n            &#125;\n        return f[n][S + Offset];\n    &#125;\n&#125;;\n\n\n\n495.提莫攻击 小模拟 总中毒时间+&#x3D;min(攻击间隔，中毒持续时间)+最后一次持续class Solution &#123;\npublic:\n    int findPoisonedDuration(vector&lt;int&gt;&amp; w, int d) &#123;\n        int res &#x3D; 0;\n        for (int i &#x3D; 1; i &lt; w.size(); i ++ ) res +&#x3D; min(w[i] - w[i - 1], d);&#x2F;&#x2F;min(攻击间隔，持续时间)\n        if (w.size()) res +&#x3D; d;&#x2F;&#x2F;最后一次持续\n        return res;\n    &#125;\n&#125;;\n\n\n\n496.下一个更大元素I 1中num在2中pos 右边first&gt;[] &lt;-q[升 模板acw830.单调栈&#x2F;&#x2F;496.下一个更大元素I 1中num在2中pos 右边first&gt;[] &lt;-q[升 模板acw830.单调栈\n&#x2F;*\n单调栈：\n左边区间第一个比它小的数，第一个比它大的数\n确定这个元素是否是区间最值\n右边区间第一个大于它的值\n到 右边区间第一个大于它的值 的距离\n确定以该元素为最值的最长区间\n*&#x2F;\n&#x2F;&#x2F; 单调队列队首维护区间最值\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        stack&lt;int&gt; stk;\n        vector&lt;int&gt; q(nums2.size());\n        for (int i &#x3D; nums2.size() - 1; i &gt;&#x3D; 0; i -- ) &#123;&#x2F;&#x2F;&lt;- q[升\n            int x &#x3D; nums2[i];\n            while (stk.size() &amp;&amp; x &gt;&#x3D; stk.top()) stk.pop();\n            if (stk.empty()) q[i] &#x3D; -1;&#x2F;&#x2F;\n            else q[i] &#x3D; stk.top();&#x2F;&#x2F;q[i]&#x3D;右first&gt;nums2[i]的x值\n            stk.push(x);\n        &#125;\n\n        unordered_map&lt;int, int&gt; hash;&#x2F;&#x2F;num,pos\n        for (int i &#x3D; 0; i &lt; nums2.size(); i ++ )\n            hash[nums2[i]] &#x3D; i;\n        vector&lt;int&gt; res;\n        for (auto x: nums1)\n            res.push_back(q[hash[x]]);&#x2F;&#x2F;1中num在2中pos 右边first&gt;[]\n        return res;\n    &#125;\n&#125;;\n\n\n\n497.非重叠矩形中的随机点 [包括v,e] 概率与面积成正比: 线段长&#x3D;S 前缀和预处理O(n) 随机[1~back]k二分O(logn)到矩形&lt;&#x3D;r-1] 随机x y x&#x3D;t0+[0,dx-1]&#x2F;&#x2F;497.非重叠矩形中的随机点 [包括v,e] 概率与面积成正比\n&#x2F;&#x2F; 线段长&#x3D;S 前缀和预处理O(n) 随机[1~back]k二分O(logn)到矩形&lt;&#x3D;r-1] 随机x y\nclass Solution &#123;\npublic:\n    int n;\n    vector&lt;vector&lt;int&gt;&gt; rects;\n    vector&lt;int&gt; s;\n\n    Solution(vector&lt;vector&lt;int&gt;&gt;&amp; _rects) &#123;&#x2F;&#x2F;init\n        rects &#x3D; _rects;\n        n &#x3D; rects.size();\n        s.push_back(0);&#x2F;&#x2F;前缀和1~\n        for (auto&amp; r: rects) &#123;\n            int dx &#x3D; r[2] - r[0] + 1;\n            int dy &#x3D; r[3] - r[1] + 1;\n            s.push_back(s.back() + dx * dy);&#x2F;&#x2F;线段尾idx：S前缀和\n        &#125;\n    &#125;\n\n    vector&lt;int&gt; pick() &#123;\n        int k &#x3D; rand() % s.back() + 1;&#x2F;&#x2F;[1~back]k\n        int l &#x3D; 1, r &#x3D; n;\n        while (l &lt; r) &#123;\n            int mid &#x3D; l + r &gt;&gt; 1;\n            if (s[mid] &gt;&#x3D; k) r &#x3D; mid;&#x2F;&#x2F;前mid个矩形S 二分到k所在矩形 &lt;&#x3D;r-1]&lt;-\n            else l &#x3D; mid + 1;\n        &#125;\n        auto&amp; t &#x3D; rects[r - 1];&#x2F;&#x2F;\n        int dx &#x3D; t[2] - t[0] + 1;\n        int dy &#x3D; t[3] - t[1] + 1;\n        return &#123;rand() % dx + t[0], rand() % dy + t[1]&#125;;&#x2F;&#x2F;x&#x3D;t0+[0,dx-1]\n    &#125;\n&#125;;\n\n\n\n498.对角线遍历 Z字模拟O(nm) 按照每个对角线坐标的和枚举 “上+右边”条斜线i&#x3D;行j+列 上 行– n-1-(n+m-2-i)&#x3D;1-m+i&#x2F;&#x2F;498.对角线遍历 Z字模拟O(nm) 按照每个对角线坐标的和i&#x3D;行+列枚举\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; w) &#123;\n        vector&lt;int&gt; res;\n        if (w.empty() || w[0].empty()) return res;\n        int n &#x3D; w.size(), m &#x3D; w[0].size();\n        for (int i &#x3D; 0; i &lt; n + m - 1; i ++ ) &#123;&#x2F;&#x2F;上+右边 条斜线i&#x3D;行+列\n            if (i % 2 &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;上 行--\n                for (int j &#x3D; min(i, n - 1); j &gt;&#x3D; max(0, 1 - m + i); j -- )&#x2F;&#x2F;n-1-(n+m-2-i)&#x3D;1-m+i\n                    res.push_back(w[j][i - j]);&#x2F;&#x2F;行j+列&#x3D;i\n            &#125; else &#123;&#x2F;&#x2F;下 行++\n                for (int j &#x3D; max(0, 1 - m + i); j &lt;&#x3D; min(i, n - 1); j ++ )\n                    res.push_back(w[j][i - j]);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n\n\n499.\n\n\n\n500.键盘行 同行打出words[] 模拟 ch,line S.insert(hash[tolower(c)]) sz&#x3D;&#x3D;1&#x2F;&#x2F;500.键盘行 同行打出words[] 模拟 ch,line S.insert(hash[tolower(c)]) sz&#x3D;&#x3D;1\nclass Solution &#123;\npublic:\n    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123;\n        string line[3] &#x3D; &#123;\n            &quot;qwertyuiop&quot;,\n            &quot;asdfghjkl&quot;,\n            &quot;zxcvbnm&quot;\n        &#125;;\n        unordered_map&lt;char, int&gt; hash;&#x2F;&#x2F; ch,line\n        for (int i &#x3D; 0; i &lt; 3; i ++ )\n            for (auto&amp; c: line[i])\n                hash[c] &#x3D; i;\n\n        vector&lt;string&gt; res;\n        for (auto&amp; word: words) &#123;\n            set&lt;int&gt; S;&#x2F;&#x2F;word lines集合\n            for (auto c: word) S.insert(hash[tolower(c)]);&#x2F;&#x2F;tolower\n            if (S.size() &#x3D;&#x3D; 1) res.push_back(word);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n","slug":"Leetcode1-500","date":"2021-08-16T13:41:20.000Z","categories_index":"算法","tags_index":"算法","author_index":"CodingSeed"},{"id":"4f5f8b1adeea7120197c416f19615115","title":"SpringBoot2[atguigu-sb2-bxl]","content":"[TOC]\nidea：ctrl+alt+v  快速引进变量，自动补全函数返回值\n&#x3D;&#x3D;win+shift+s&#x3D;&#x3D;：windows截屏工具快捷键！！！\n第一季：SpringBoot2核心技术-基础入门01、背景Faas：函数式服务 Serverless\n\n基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。\n1.之前： 实现时要写A所有空方法，适配器模式\nAdapter将A的5方法全默认实现为空方法，BC继承Adapter并重写各自方法。\n\n微服务是一种架构风格\n\n一个应用拆分为一组小型服务\n\n每个服务运行在自己的进程内，也就是可独立部署和升级\n\n服务之间使用轻量级HTTP交互\n\n服务围绕业务功能拆分\n\n可以由全自动部署机制独立部署\n\n去中心化，服务自治。服务可以使用不同的语言、不同的存储技术\n\n\n分布式的困难\n远程调用\n\n服务发现\n\n负载均衡\n\n服务容错\n\n配置管理\n\n服务监控\n\n链路追踪\n\n日志管理：微服务架构默认将应用日志分散保存在每一个微服务节点上，当系统进行用户行为分析、数据统计时必须收集所有节点日志数据，非常不方便。这时候我们需要一个独立的日志平台，收集所有节点的日志数据并可方便对其进行汇总分析，然后进行可视化展示，常见的解决方案有ELK（Elasticsearch+Logstash+Kibana），EFK（Elasticsearch+Fluentd+Kibana）。\n\n任务调度\n\n……\n\n\n云原生 运维\n上云的困难\n服务自愈\n\n弹性伸缩\n\n服务隔离\n\n自动化部署\n\n灰度发布：新旧版本共存，gradually替换【同样的服务有多台服务器运行，先把服务部署在其中一两台上看运行效果，没有问题了再慢慢全部升级】\n\n流量治理\n\n……\n\n\n\n02、入门【官网文档】https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/index.html\n依赖管理\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.3.12.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n统一配置\nhttps://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/appendix-application-properties.html#common-application-properties\napplication.properties:\nserver.port&#x3D;8888\nhttp:&#x2F;&#x2F;localhost:8888&#x2F;hello\n\n\n\nhttps://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/getting-started.html#getting-started-first-application-executable-jar\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n\n打Jar包启动：java -jar boot-01-helloworld-1.0-SNAPSHOT.jar\n03、了解自动配置原理！！！https://www.yuque.com/atguigu/springboot/qb7hy2\n1、SpringBoot特点1.1、依赖管理父项目依赖管理    \n&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n他的父项目\n &lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n  &lt;&#x2F;parent&gt;\n\n几乎声明了所有开发中常用的依赖的版本号,【自动版本仲裁机制】\n\n\n\n\n开发导入【starter场景启动器】\n\n3、SpringBoot所有支持的场景 https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-boot&#x2F;docs&#x2F;current&#x2F;reference&#x2F;html&#x2F;using-spring-boot.html#using-boot-starter \n4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。\n5、所有场景启动器最底层的依赖\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n  &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n引入非版本仲裁的jar，要写版本号。\n1.2、自动配置@SpringBootApplication\npublic class MainApplication &#123;\n    &#x2F;&#x2F; idea：ctrl+alt+v  快速引进变量，自动补全函数返回值\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1.返回IOC容器\n        ConfigurableApplicationContext run &#x3D; SpringApplication.run(MainApplication.class, args);\n\n        &#x2F;&#x2F; 2.查看容器里的组件\n        String[] names &#x3D; run.getBeanDefinitionNames();\n        for (String name: names) &#123;\n            System.out.println(name);\n        &#125;\n\n    &#125;\n&#125;\n\n\n自动配好Web常见功能，如：字符编码问题 characterEncodingFilter；dispatcherServlet；viewResolver；文件上传功能 multipartResolver\n\n\nSpringBoot帮我们配置好了所有web开发的常见场景\n\n\n默认的包结构\n\n\n主程序所在包【MainApplication 所在的层级】及其下面的所有子包里面的组件都会被默认扫描进来\n无需以前的包扫描配置\n\n\n\n想要改变扫描路径，@SpringBootApplication(&#x3D;&#x3D;scanBasePackages&#x3D;&#x3D;&#x3D;“com.atguigu”)\n\n\n\n\n或者@ComponentScan 指定扫描路径\n\n\n\n\n\n@SpringBootApplication\n等同于\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(&quot;com.atguigu.boot&quot;)\n\n&#x2F;&#x2F;com.bxl.WorldController\n@RestController\npublic class WorldController &#123;\n\n    @RequestMapping(&quot;&#x2F;w&quot;)\n    public String world66() &#123;\n        return &quot;世界&quot;;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;主程序\n@SpringBootApplication(scanBasePackages &#x3D; &quot;com.bxl&quot;)\n\n&#x2F;&#x2F;@SpringBootConfiguration\n&#x2F;&#x2F;@EnableAutoConfiguration\n&#x2F;&#x2F;@ComponentScan(&quot;com.bxl&quot;)\npublic class MainApplication &#123;\n\n\n\n\n各种配置拥有默认值\n\n\n默认配置最终都是映射到某个类上，如：MultipartProperties【&lt;-spring.servlet.multipart.max-file-size&#x3D;10MB】\n配置文件的值最终会绑定每个类上，这个类会在容器中创建对象\n\n\n按需加载所有自动配置项\n\n\n非常多的starter\n引入了哪些场景这个场景的自动配置才会开启\n\n\n\nSpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面\n\n+spring-boot-starter-batch 场景后 就不发红了，生效了。\n\n\n……\n\n\n\n2、容器功能2.1、组件添加Spring xml配置方式：\n+boot-bean- User Pet类\nres-new xml:SpringConfig—— beans.xml\n&lt;bean id&#x3D;&quot;user01&quot; class&#x3D;&quot;com.bxl.boot.bean.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zhangsan&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;com.bxl.boot.bean.Pet&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;tomcat&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n1、@Configuration\n基本使用\n\nFull模式与Lite模式\n\n\n示例\n最佳实战\n\n\n\n\n配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断\n配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式\n\n\n\n\n\n#############################Configuration使用示例######################################################\n&#x2F;**\n * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的\n * 2、配置类本身也是组件\n * 3、proxyBeanMethods：代理bean的方法\n *      Full(proxyBeanMethods &#x3D; true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】\n *      Lite(proxyBeanMethods &#x3D; false)【每个@Bean方法被调用多少次返回的组件都是新创建的】\n *      组件依赖必须使用Full模式默认。其他默认是Lite模式【容器中添加的组件只注册不使用、不依赖】\n *\n *\n *&#x2F;\n@Configuration(proxyBeanMethods &#x3D; true) &#x2F;&#x2F;告诉SpringBoot这是一个配置类 &#x3D;&#x3D; 配置文件\npublic class MyConfig &#123;\n\n    &#x2F;**\n     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象\n     * @return\n     *&#x2F;\n    @Bean &#x2F;&#x2F;给容器中添加bean组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例\n    public User user01()&#123;\n        User zhangsan &#x3D; new User(&quot;zhangsan&quot;, 18);\n        &#x2F;&#x2F;true: user组件依赖了Pet组件\n        zhangsan.setPet(tomcatPet());\n        return zhangsan;\n    &#125;\n\n    @Bean(&quot;tom&quot;) &#x2F;&#x2F;自定义组件名\n    public Pet tomcatPet()&#123;\n        return new Pet(&quot;tomcat&quot;);\n    &#125;\n&#125;\n\n\n################################@Configuration测试代码如下########################################\n&#x2F;**\n * 主程序类：主配置类\n *&#x2F;\n@SpringBootApplication(scanBasePackages &#x3D; &quot;com.bxl&quot;)\n\n&#x2F;&#x2F;@SpringBootConfiguration\n&#x2F;&#x2F;@EnableAutoConfiguration\n&#x2F;&#x2F;@ComponentScan(&quot;com.bxl&quot;)\npublic class MainApplication &#123;\n    &#x2F;&#x2F; idea：ctrl+alt+v  快速引进变量，自动补全函数返回值\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1.返回IOC容器\n        ConfigurableApplicationContext run &#x3D; SpringApplication.run(MainApplication.class, args);\n\n        &#x2F;&#x2F; 2.查看容器里的组件\n        String[] names &#x3D; run.getBeanDefinitionNames();\n        for (String name: names) &#123;\n            System.out.println(name);\n        &#125;\n\n        &#x2F;&#x2F;3、从容器中获取组件【1默认单实例】\n        Pet tom01 &#x3D; run.getBean(&quot;tom&quot;, Pet.class);\n        Pet tom02 &#x3D; run.getBean(&quot;tom&quot;, Pet.class);\n\n        System.out.println(&quot;2个Pet组件&#x3D;&#x3D;否:&quot;+(tom01 &#x3D;&#x3D; tom02));\n\n        &#x2F;&#x2F;4、代理对象：com.bxl.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892\n        &#x2F;&#x2F;@Configuration(proxyBeanMethods &#x3D; true):  com.bxl.boot.config.MyConfig@71154f21\n        MyConfig bean &#x3D; run.getBean(MyConfig.class);\n        System.out.println(bean);\n\n        &#x2F;&#x2F;如果@Configuration(proxyBeanMethods &#x3D; true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。\n        &#x2F;&#x2F;保持组件单实例,false就!&#x3D;\n        User user &#x3D; bean.user01();\n        User user1 &#x3D; bean.user01();\n        System.out.println(user &#x3D;&#x3D; user1);\n\n\n        User user01 &#x3D; run.getBean(&quot;user01&quot;, User.class);\n        Pet tom &#x3D; run.getBean(&quot;tom&quot;, Pet.class);\n\n        System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() &#x3D;&#x3D; tom));\n\n\n    &#125;\n&#125;\n\n\n2、@Bean、@Component、@Controller、@Service、@Repository在Stereotype（旧规矩）模式下，Spring为Controller-Service-Dao的分层模型分别提供了@Controller、@Service、@Repository注解，除此之外的组件使用@Component注解。\n根据它们的源码可以看到，Controller、Service、Repository其本质就是Component。\n它存在的本质只是给开发者看的，对Spring而言它们就都是Component。\n@Controller 控制层类，@Service 业务层类，@Repository 持久层类，@Component 无法归类到前3种时就称为组件。\n使用@Component注解在一个类上，表示将此类标记为Spring容器中的一个Bean。\n3、@ComponentScan、@Import@ComponentScan：扫描包\n@Import的好处是可以引入第三方外部类，可以标注在主配置类MainApplication或者组件上\n@Import：自动从类中的无参构造函数创建一个实例注册到 IOC 容器中\n【注意】@Import所创建的bean实例在 IOC 容器中默认的id名为类的全限定名，如 User 类就是：com.atguigu.bean.User\n@Import(&#123;User.class, DBHelper.class&#125;)\n\n@Import 高级用法： https://www.bilibili.com/video/BV1gW411W7wy?p=8\n4、@Conditional条件装配：满足Conditional指定的条件，则进行组件注入\n搜 下载源码 ctrl+h：继承树\n\n容器中有无bean Class ,项目类路径中有无resource 配置property，指定Java版本，是否web应用 … 才注入bean\nConditionalOnSingleCandidate：指定组件只有一个【@Priority主】实例\n2.2、原生配置文件引入1、@ImportResource&#x2F;**\n * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的\n * 2、配置类本身也是组件\n * 3、proxyBeanMethods：代理bean的方法\n *      Full(proxyBeanMethods &#x3D; true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】\n *      Lite(proxyBeanMethods &#x3D; false)【每个@Bean方法被调用多少次返回的组件都是新创建的】\n *      组件依赖必须使用Full模式默认。其他默认是Lite模式【容器中添加的组件只注册不使用、不依赖】\n * 4、@Import(&#123;User.class, DBHelper.class&#125;)\n *      给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名\n *&#x2F;\n\n@Import(&#123;User.class, DBHelper.class&#125;)\n@Configuration(proxyBeanMethods &#x3D; true) &#x2F;&#x2F;告诉SpringBoot这是一个配置类 &#x3D;&#x3D; 配置文件\n&#x2F;&#x2F;@ConditionalOnBean(name &#x3D; &quot;tom&quot;) &#x2F;&#x2F;依赖tom而存在，容器有tom，才有user01，tom22\n@ConditionalOnMissingBean(name &#x3D; &quot;tom&quot;)\n@ImportResource(&quot;classpath:beans.xml&quot;) &#x2F;&#x2F;spring xml配置生效\npublic class MyConfig &#123;\n\n&#x2F;&#x2F;    @Bean(&quot;tom22&quot;) &#x2F;&#x2F;自定义组件名\n&#x2F;&#x2F;    public Pet tomcatPet()&#123;\n&#x2F;&#x2F;        return new Pet(&quot;tomcat&quot;);\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;**\n     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象\n     * @return\n     *&#x2F;\n    &#x2F;&#x2F;依赖tom22而存在\n    &#x2F;&#x2F; !!!组件按顺序加入容器：如果tom22在user01后面加载，就是user01&#x3D;false[此时还没载入tom22,条件不满足] tom22&#x3D;true\n    @ConditionalOnBean(name &#x3D; &quot;tom22&quot;)\n    @Bean &#x2F;&#x2F;给容器中添加bean组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例\n    public User user01()&#123;\n        User zhangsan &#x3D; new User(&quot;zhangsan&quot;, 18);\n        &#x2F;&#x2F;true: user组件依赖了Pet组件\n        zhangsan.setPet(tomcatPet());\n        return zhangsan;\n    &#125;\n\n    @Bean(&quot;tom22&quot;) &#x2F;&#x2F;自定义组件名\n    public Pet tomcatPet()&#123;\n        return new Pet(&quot;tomcat&quot;);\n    &#125;\n&#125;\n\n\n\nMain测试：\n        boolean tom &#x3D; run.containsBean(&quot;tom&quot;);\n        System.out.println(&quot;容器中tom组件：&quot;+ tom);\n\n        boolean user01 &#x3D; run.containsBean(&quot;user01&quot;);\n        System.out.println(&quot;容器中user01组件：&quot;+ user01);\n\n        boolean tom22 &#x3D; run.containsBean(&quot;tom22&quot;);\n        System.out.println(&quot;容器中tom22组件：&quot;+ tom22);\n\n        &#x2F;&#x2F;@ImportResource(&quot;classpath:beans.xml&quot;) &#x2F;&#x2F;spring xml配置\n        boolean haha &#x3D; run.containsBean(&quot;haha&quot;);\n        boolean hehe &#x3D; run.containsBean(&quot;hehe&quot;);\n        System.out.println(&quot;haha：&quot;+haha);\n        System.out.println(&quot;hehe：&quot;+hehe);\n\n\n\n\n2.3、配置绑定如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用；\n以前：\npublic class getProperties &#123;\n     public static void main(String[] args) throws FileNotFoundException, IOException &#123;\n         Properties pps &#x3D; new Properties();\n         pps.load(new FileInputStream(&quot;a.properties&quot;));\n         Enumeration enum1 &#x3D; pps.propertyNames();&#x2F;&#x2F;得到配置文件的名字\n         while(enum1.hasMoreElements()) &#123;\n             String strKey &#x3D; (String) enum1.nextElement();\n             String strValue &#x3D; pps.getProperty(strKey);\n             System.out.println(strKey + &quot;&#x3D;&quot; + strValue);\n             &#x2F;&#x2F;封装到JavaBean。\n         &#125;\n     &#125;\n &#125;\n\nSpringboot2 注解2种方式：\n法一：\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;mycar&quot;)\npublic class Car &#123;\n\n法二：\n@ConfigurationProperties(prefix &#x3D; &quot;mycar&quot;)\npublic class Car &#123;\n+\n@EnableConfigurationProperties(Car.class)\n&#x2F;&#x2F;1、开启Car配置绑定功能\n&#x2F;&#x2F;2、把这个Car这个组件自动注册到容器中\npublic class MyConfig &#123;\n    \n    \n将JavaBean与spring核心配置文件application.properties中mycar前缀配置绑定：    \nmycar.brand&#x3D;BYD\nmycar.price&#x3D;100000\n\n\n\n3、自动配置原理入门3.1、引导加载自动配置类@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters &#x3D; &#123; @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),\n\t\t@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)\npublic @interface SpringBootApplication&#123;&#125;\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    \n\n1、@SpringBootConfiguration@Configuration。代表当前是一个配置类   类似“MyConfig”\n2、@ComponentScan指定扫描哪些，Spring注解；\n3、@EnableAutoConfiguration@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration &#123;&#125;\n\n1、@AutoConfigurationPackage自动配置包？指定了默认的包规则\n@Import(AutoConfigurationPackages.Registrar.class)  &#x2F;&#x2F;给容器中导入一个组件\npublic @interface AutoConfigurationPackage &#123;&#125;\n\n&#x2F;&#x2F;利用Registrar给容器中导入一系列组件\n&#x2F;&#x2F;将【指定的一个包】下的所有组件导入进来？-&gt;MainApplication 所在包下。\n\n\n&#x3D;&#x3D;win+shift+s&#x3D;&#x3D;：windows截屏工具快捷键！！！\n\n2、@Import(AutoConfigurationImportSelector.class)1、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件\n2、调用List&lt;String&gt; configurations &#x3D; getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类\n3、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件\n4、从META-INF&#x2F;spring.factories位置来加载一个文件。\n\t默认扫描我们当前系统里面所有META-INF&#x2F;spring.factories位置的文件\n    spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF&#x2F;spring.factories\n    \n\n\n文件里面写死了spring-boot一启动就要给容器中加载的所有配置类\nspring-boot-autoconfigure-2.3.4.RELEASE.jar&#x2F;META-INF&#x2F;spring.factories\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\\norg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\n\n3.2、按需开启自动配置项虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration\n按照条件装配规则（@Conditional），最终会按需配置。\n\n\n\n\n\n\n\nprivate static class DefaultDispatcherServletCondition extends SpringBootCondition &#123;\n    看注解。。。ing\n\n3.3、修改默认配置        @Bean\n\t\t@ConditionalOnBean(MultipartResolver.class)  &#x2F;&#x2F;容器中有这个类型组件\n\t\t@ConditionalOnMissingBean(name &#x3D; DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) &#x2F;&#x2F;容器中没有这个名字为 multipartResolver 的组件\n\t\tpublic MultipartResolver multipartResolver(MultipartResolver resolver) &#123;\n            &#x2F;&#x2F;给【@Bean标注的方法传入了对象参数】，这个【参数的值就会从容器中找】。\n            &#x2F;&#x2F;SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范【命名规范化！】\n\t\t\t&#x2F;&#x2F; Detect if the user has created a MultipartResolver but named it incorrectly\n\t\t\treturn resolver;\n\t\t&#125;\n给容器中加入了文件上传解析器；\n\n\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String handle01(@RequestParam(&quot;name&quot;) String name) &#123;\n        return &quot;Hello, Spring boot 2!&quot; + &quot;你好：&quot; + name;\n    &#125;\n\nhttp:&#x2F;&#x2F;localhost:8888&#x2F;hello?name&#x3D;张三\n\n\nProperties绑定配置\napplication.properties:\n#server.servlet.encoding.charset&#x3D;GBK\n\n\n\nSpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了【以用户的优先】\n@Bean\n\t@ConditionalOnMissingBean\n\tpublic CharacterEncodingFilter characterEncodingFilter() &#123;\n    &#125;\n\nMyConfig:\n&#x2F;&#x2F;    @Bean\n&#x2F;&#x2F;    public CharacterEncodingFilter filter()&#123;\n&#x2F;&#x2F;        return null;\n&#x2F;&#x2F;    &#125;\n\n&#x3D;&#x3D;总结&#x3D;&#x3D;：\n\nSpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration\n\n每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定\n\n生效的配置类就会给容器中装配很多组件\n\n只要容器中有这些组件，相当于这些功能就有了\n\n定制化配置\n\n\n用户直接【自己@Bean替换底层的组件】\n用户去看这个【组件是获取的配置文件什么值就去修改】。\n\n\n\nxxxxxAutoConfiguration —&gt; 组件  —&gt; xxxxProperties里面拿值  —-&gt; application.properties\n\n改配置方法：\n查配置文档\n查AutoConfiguration源码\n3.4、最佳实践\n引入场景依赖\n\n\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter\n\n\n查看自动配置了哪些（选做）\n\n\n自己分析，引入场景对应的自动配置一般都生效了\n&#x3D;&#x3D;配置文件中debug&#x3D;true&#x3D;&#x3D;开启自动配置报告。Negative（不生效）\\Positive matches（生效）\n\n\n是否需要修改\n\n\n参照文档修改配置项\n\n\n\n\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties\n自己分析。xxxxProperties绑定了配置文件的哪些前缀prefix。\n\n\n\n\n\n自定义加入或者替换组件\n\n\n\n\n@Bean、@Component。。。\n\n\n\n\n\n自定义器  XXXXXCustomizer；\n……\n\n\n\n\n4、开发小技巧4.1、Lombok简化JavaBean开发\n@NoArgsConstructor  &#x2F;&#x2F;无参构造器&#x2F;&#x2F;@AllArgsConstructor  &#x2F;&#x2F;全参构造器@Data@ToString@EqualsAndHashCode\n@Slf4j\nparent-dependency-搜lombok.version:\n\t\t&lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\n\nsettings-plugin- idea中搜索安装lombok插件\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;简化JavaBean开发&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n@NoArgsConstructor  &#x2F;&#x2F;无参构造器\n&#x2F;&#x2F;@AllArgsConstructor  &#x2F;&#x2F;全参构造器\n@Data\n@ToString\n@EqualsAndHashCode\npublic class User &#123;\n\n    private String name;\n    private Integer age;\n\n    private Pet pet;\n\n    public User(String name,Integer age)&#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n\n&#125;\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;简化日志开发&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n@Slf4j\n@RestController\npublic class HelloController &#123;\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String handle01(@RequestParam(&quot;name&quot;) String name)&#123;\n        \n        log.info(&quot;请求进来了....&quot;);\n        \n        return &quot;Hello, Spring Boot 2!&quot;+&quot;你好：&quot;+name;\n    &#125;\n&#125;\n\n\n\n\n4.2、dev-tools 【ctrl(+shift)+F9 autorestart】    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n        &lt;optional&gt;true&lt;&#x2F;optional&gt; \n    &lt;&#x2F;dependency&gt; &lt;!--必须--&gt;\n\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;configuration&gt;\n                &lt;fork&gt;true&lt;&#x2F;fork&gt;&lt;!-- 如果没有该配置，热部署的devtools不生效 --&gt;\n            &lt;&#x2F;configuration&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n&#x2F;&#x2F;ctrl+F9：devtools autorestart(shift+F10)  付费JRebel：reload\n@RequestMapping(&quot;&#x2F;hello257&quot;)\n\n项目或者页面修改以后：Ctrl+F9；\n似乎不太管用。。。\nctrl+shift+F9\ntrue \n \n                    true\n                \n\n\n\n\n\n4.3、Spring Initailizr（项目初始化向导）0、选择我们需要的开发场景\n1、自动依赖引入\n2、自动创建项目结构\n3、自动编写好主配置类\nSpring Boot 2 学习笔记（上）：https://blog.csdn.net/u011863024/article/details/113667634\nSpring Boot 2 学习笔记（下）：https://blog.csdn.net/u011863024/article/details/113667946\nweb模块默认规则的原理研究笔记：主要包括：1、配置文件加载位置2、静态资源映射规则3、templates文件夹4、错误页面处理5、WebMvcConfigurer配置\nhttps://blog.csdn.net/qq_43240702/article/details/111032361\nSpringBoot 自动装配源码：https://www.cnblogs.com/seazean/p/15109440.html\nMVC 源码笔记，根据 doDispatch 函数一步一步的源码解析：https://www.cnblogs.com/seazean/p/15095819.htm\n第一季：SpringBoot2核心技术-核心功能boot-05-web-01项目\n04、配置文件1、文件类型1.1、properties同以前的properties用法\n1.2、yaml1.2.1、简介YAML 是 “YAML Ain’t Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。 \n非常适合用来做以数据为中心的配置文件\n1.2.2、基本语法\nkey: value；kv之间有空格\n\n大小写敏感\n\n使用缩进表示层级关系\n\n缩进不允许使用tab，只允许空格\n\n缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n‘#’表示注释\n\n字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义&#x2F;不转义\n\n\n1.2.3、数据类型\n字面量：单个的、不可再分的值。date、boolean、string、number、null\n\nk: v\n\n\n对象：键值对的集合。map、hash、set、object\n\n行内写法：  k: &#123;k1:v1,k2:v2,k3:v3&#125;\n#或\nk: \n\tk1: v1\n  k2: v2\n  k3: v3\n\n\n数组：一组按次序排列的值。array、list、queue\n\n行内写法：  k: [v1,v2,v3]\n#或者\nk:\n - v1\n - v2\n - v3\n\n1.2.4、示例@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\n@Component\n@ToString\n@Data\npublic class Person &#123;\n\t\n\tprivate String userName;\n\tprivate Boolean boss;\n\tprivate Date birth;\n\tprivate Integer age;\n\tprivate Pet pet;\n\tprivate String[] interests;\n\tprivate List&lt;String&gt; animal;\n\tprivate Map&lt;String, Object&gt; score;\n\tprivate Set&lt;Double&gt; salarys;\n\tprivate Map&lt;String, List&lt;Pet&gt;&gt; allPets;\n&#125;\n\n@Data\npublic class Pet &#123;\n\tprivate String name;\n\tprivate Double weight;\n&#125;\n\n\n\nperson:\n#  单引号会将 \\n作为字符串输出   双引号会将\\n 作为换行输出\n#  双引号不会转义，单引号会转义\n  boss: true\n  birth: 2019&#x2F;12&#x2F;9\n  age: 18\n#  interests: [篮球,足球]\n  interests:\n    - 篮球\n    - 足球\n    - 18\n  animal: [阿猫,阿狗]\n#  score:\n#    english: 80\n#    math: 90\n  score: &#123;english:80,math:90&#125;\n  salarys:\n    - 9999.98\n    - 9999.99\n  pet:\n    name: 阿狗\n    weight: 99.99\n  allPets:\n    sick:\n      - &#123;name: 阿狗,weight: 99.99&#125;\n      - name: 阿猫\n        weight: 88.88\n      - name: 阿虫\n        weight: 77.77\n    health:\n      - &#123;name: 阿花,weight: 199.99&#125;\n      - &#123;name: 阿明,weight: 199.99&#125;\n  user-name: &#39;zhangsan \\n 李四&#39;\n\n\n\n\n#spring:\n#  banner:\n#    image:\n#      bitdepth: 4\n#  cache:\n#    type: redis\n#    redis:\n#      time-to-live: 11000\n\n\n\n\n2、配置提示自定义的类和配置文件绑定一般没有提示。user-name: ‘zhangsan \\n 李四’\n&lt;!--https:&#x2F;&#x2F;docs.spring.io&#x2F;spring-boot&#x2F;docs&#x2F;2.3.12.RELEASE&#x2F;reference&#x2F;html&#x2F;appendix-configuration-metadata.html#configuration-metadata-annotation-processor--&gt;\n\n\t&lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n           &lt;optional&gt;true&lt;&#x2F;optional&gt;\n       &lt;&#x2F;dependency&gt;\n\n\n&lt;build&gt;\n       &lt;plugins&gt;\n           &lt;plugin&gt;\n               &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n               &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n               &lt;configuration&gt;\n                   &lt;excludes&gt;\n                       &lt;exclude&gt;\n                           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                           &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n                       &lt;&#x2F;exclude&gt;\n                   &lt;&#x2F;excludes&gt;\n               &lt;&#x2F;configuration&gt;\n           &lt;&#x2F;plugin&gt;\n       &lt;&#x2F;plugins&gt;\n   &lt;&#x2F;build&gt;\n\nbuild-exclude：打包时不打包这些无用提示类\n05、Web开发\nhttps://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-auto-configuration\n1、SpringMVC自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置)\nThe auto-configuration adds the following features on top of Spring’s defaults:\n\nInclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.\n\n\n内容协商视图解析器和BeanName视图解析器\n\n\nSupport for serving static resources, including support for WebJars (covered later in this document)).\n\n\n静态资源（包括webjars）\n\n\nAutomatic registration of Converter, GenericConverter, and Formatter beans.\n\n\n自动注册 Converter，GenericConverter，Formatter \n\n\nSupport for HttpMessageConverters (covered later in this document).\n\n\n支持 HttpMessageConverters （后来我们配合内容协商理解原理）\n\n\nAutomatic registration of MessageCodesResolver (covered later in this document).\n\n\n自动注册 MessageCodesResolver （国际化用）\n\n\nStatic index.html support.\n\n\n静态index.html 页支持\n\n\nCustom Favicon support (covered later in this document).\n\n\n自定义 Favicon\n\n\nAutomatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).\n\n\n自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上）\n\n\n\nIf you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.\n不用@EnableWebMvc注解。使用 **@Configuration** + **WebMvcConfigurer** 自定义规则\nIf you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components.\n声明 **WebMvcRegistrations** 改变默认底层组件\nIf you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc.\n使用 **@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC**\nboot-05-web-01项目\n2、简单功能分析2.1、静态资源访问1、静态资源目录只要静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources\n访问 ： 当前项目根路径&#x2F; + 静态资源名 \n原理： 静态映射&#x2F;**。\n请求进来，先去找Controller看能不能处理。【不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面】\n&#x3D;&#x3D;改变【默认】的静态资源【路径】static-locations–&gt;放资源的地方！访问不用+ta！&#x3D;&#x3D;\nspring:\n  mvc:\n    static-path-pattern: &#x2F;res&#x2F;**\n\n  resources:\n    static-locations: [classpath:&#x2F;haha&#x2F;]\n\n点源码\n方便【拦截器拦截&#x2F;放行指定目录】下的资源或页面进行处理！！！\n\n2、静态【资源访问前缀】默认无前缀\nspring:\n  mvc:\n    static-path-pattern: &#x2F;res&#x2F;**\n\n当前项目 + static-path-pattern + 静态资源名 &#x3D; 静态资源文件夹下找\n&#x3D;&#x3D;访问+前缀 static-path-pattern&#x3D;&#x3D;: http://localhost:8081/res/zhifubao.png\n3、webjars自动映射 &#x2F;webjars&#x2F;**\nhttps://www.webjars.org/\n&lt;dependency&gt;\n    &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.5.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n访问地址：http://localhost:8080/webjars/jquery&#x2F;3.5.1&#x2F;jquery.js   后面地址要按照依赖里面的包路径\n2.2、欢迎页支持\n静态资源路径下  index.html\n\n\n可以配置静态资源路径\n但是&#x3D;&#x3D;不可以配置静态资源的访问前缀。否则导致 index.html不能被【默认 (不写)】访问&#x3D;&#x3D;\n\n\n\nspring:\n#  mvc:\n#    static-path-pattern: &#x2F;res&#x2F;**   这个会导致welcome page功能失效\n\n  resources:\n    static-locations: [classpath:&#x2F;haha&#x2F;]\n\n\ncontroller能处理&#x2F;index\n\n2.3、自定义 Favicon【F12-network-favicon.ico requestURL-图片另存为】\nfavicon.ico放在静态资源目录下即可。【不要+访问前缀】 \nspring:\n#  mvc:\n#    static-path-pattern: &#x2F;res&#x2F;**   这个会导致 Favicon 功能失效\n\n\n\n&#x3D;&#x3D;以后都默认放到static，而+访问前缀（方便拦截放行）&#x3D;&#x3D;\n浏览器不关，就是同一会话session，&#x3D;&#x3D;favicon在session期间共享&#x3D;&#x3D;【换浏览器打开】\n2.4、静态资源配置原理\nSpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）\nSpringMVC功能的自动配置类(boot.autoconfigure.web.servlet) WebMvcAutoConfiguration，生效\n\n@Configuration(proxyBeanMethods &#x3D; false)\n@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)\n@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) &#x2F;&#x2F;!!!全面接管！！！\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\n\t\tValidationAutoConfiguration.class &#125;)\npublic class WebMvcAutoConfiguration &#123;&#125;\n\n\n给容器中配了什么。\n\nspringmvc用来兼容rest风格：表单提交put delete请求\n\n\n\n@Configuration(proxyBeanMethods &#x3D; false)\n@Import(EnableWebMvcConfiguration.class)\n@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)\n@Order(0)\npublic static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;&#125;\n\n\n配置文件的相关属性和xxx配置前缀进行了绑定。WebMvcProperties–&gt;spring.mvc、ResourceProperties–&gt;spring.resources\n\n【注意！拓展：】\n1、配置类只有一个有参构造器：所有参数的值都会从容器中确定\t&#x2F;&#x2F;有参构造器所有参数的值都会从容器中确定\n&#x2F;&#x2F;ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象\n&#x2F;&#x2F;WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象\n&#x2F;&#x2F;ListableBeanFactory beanFactory Spring的beanFactory\n&#x2F;&#x2F;HttpMessageConverters 找到所有的HttpMessageConverters\n&#x2F;&#x2F;ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;DispatcherServletPath  \n&#x2F;&#x2F;ServletRegistrationBean   给应用注册Servlet、Filter....\n\tpublic WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties,\n\t\t\t\tListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,\n\t\t\t\tObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,\n\t\t\t\tObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,\n\t\t\t\tObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123;\n\t\t\tthis.resourceProperties &#x3D; resourceProperties;\n\t\t\tthis.mvcProperties &#x3D; mvcProperties;\n\t\t\tthis.beanFactory &#x3D; beanFactory;\n\t\t\tthis.messageConvertersProvider &#x3D; messageConvertersProvider;\n\t\t\tthis.resourceHandlerRegistrationCustomizer &#x3D; resourceHandlerRegistrationCustomizerProvider.getIfAvailable();\n\t\t\tthis.dispatcherServletPath &#x3D; dispatcherServletPath;\n\t\t\tthis.servletRegistrations &#x3D; servletRegistrations;\n\t\t&#125;\n\n\n\n\n\n2、资源处理的默认规则spring:\n#  mvc:\n#    static-path-pattern: &#x2F;res&#x2F;**        #默认&#x2F;**\n\n  resources:\n    add-mappings: false   禁用所有静态资源(的路径映射)规则\n\n\n\n@Override\n\t\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n\t\t\tif (!this.resourceProperties.isAddMappings()) &#123;\n\t\t\t\tlogger.debug(&quot;Default resource handling disabled&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t\tDuration cachePeriod &#x3D; this.resourceProperties.getCache().getPeriod();\n\t\t\tCacheControl cacheControl &#x3D; this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n\t\t\t&#x2F;&#x2F;webjars的规则\n            if (!registry.hasMappingForPattern(&quot;&#x2F;webjars&#x2F;**&quot;)) &#123;\n                &#x2F;&#x2F;访问前缀 存放目录 缓存时间\n                customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;)\n\t\t\t\t\t\t.addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;)\n\t\t\t\t\t\t.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n\t\t\t&#125;\n            \n            &#x2F;&#x2F;静态资源路径的配置规则\n\t\t\tString staticPathPattern &#x3D; this.mvcProperties.getStaticPathPattern();\n\t\t\tif (!registry.hasMappingForPattern(staticPathPattern)) &#123;\n\t\t\t\tcustomizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\n\t\t\t\t\t\t.addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n\t\t\t\t\t\t.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n\t\t\t&#125;\n\t\t&#125;\n\ngetStaticLocations-&gt;\n@ConfigurationProperties(prefix &#x3D; &quot;spring.resources&quot;, ignoreUnknownFields &#x3D; false)\npublic class ResourceProperties &#123;\n\n\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123; &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,\n\t\t\t&quot;classpath:&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &#125;;\n\n\t&#x2F;**\n\t * Locations of static resources. Defaults to classpath:[&#x2F;META-INF&#x2F;resources&#x2F;,\n\t * &#x2F;resources&#x2F;, &#x2F;static&#x2F;, &#x2F;public&#x2F;].\n\t *&#x2F;\n\tprivate String[] staticLocations &#x3D; CLASSPATH_RESOURCE_LOCATIONS;\n\n\n\n3、欢迎页的处理规则\tHandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。\t\n\n\t\t@Bean\n\t\tpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,\n\t\t\t\tFormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123;\n\t\t\tWelcomePageHandlerMapping welcomePageHandlerMapping &#x3D; new WelcomePageHandlerMapping(\n\t\t\t\t\tnew TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),\n\t\t\t\t\tthis.mvcProperties.getStaticPathPattern());\n\t\t\twelcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n\t\t\twelcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());\n\t\t\treturn welcomePageHandlerMapping;\n\t\t&#125;\n\n进入new ：\n\tWelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,\n\t\t\tApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;\n\t\tif (welcomePage.isPresent() &amp;&amp; &quot;&#x2F;**&quot;.equals(staticPathPattern)) &#123;\n            &#x2F;&#x2F;要用欢迎页功能，必须是&#x2F;**\n\t\t\tlogger.info(&quot;Adding welcome page: &quot; + welcomePage.get());\n\t\t\tsetRootViewName(&quot;forward:index.html&quot;);\n\t\t&#125;\n\t\telse if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;\n            &#x2F;&#x2F; 调用Controller  &#x2F;index\n\t\t\tlogger.info(&quot;Adding welcome page template: index&quot;);\n\t\t\tsetRootViewName(&quot;index&quot;);\n\t\t&#125;\n\t&#125;\n\n4、favicon3、请求参数处理【&#x3D;&#x3D;！重要！&#x3D;&#x3D;】0、请求映射  @RequestMapping1、rest使用与原理\n@xxxMapping；\n\nRest风格支持（使用HTTP请求方式动词来表示对资源的操作）\n\n\n以前：&#x2F;getUser  获取用户    &#x2F;deleteUser 删除用户   &#x2F;editUser  修改用户      &#x2F;saveUser 保存用户\n现在： &#x2F;user    *GET-*获取用户    *DELETE-*删除用户     *PUT-*修改用户      *POST-*保存用户\n\n\n\n核心Filter；HiddenHttpMethodFilter\n\n\n\n\n用法： 表单method&#x3D;post，隐藏域 _method&#x3D;put\n\n&#96;&#96;&#96;html\n\n    \n    \n\n\n    \n    \n\n\n- SpringBoot中手动开启 +配置\n\n- &#96;&#96;&#96;yaml\n  spring:\n    mvc:\n      hiddenmethod:\n        filter:\n          enabled: true\n\n\n\n\n\n扩展：如何把_method 这个名字换成我们自己喜欢的。\n\n\n\n&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.GET)\n    @GetMapping(&quot;&#x2F;user&quot;)\n    public String getUser()&#123;\n\n        return &quot;GET-张三&quot;;\n    &#125;\n\n&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.POST)\n    @PostMapping(&quot;&#x2F;user&quot;)\n    public String saveUser()&#123;\n        return &quot;POST-张三&quot;;\n    &#125;\n\n\n&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.PUT)\n    @PutMapping(&quot;&#x2F;user&quot;)\n    public String putUser()&#123;\n\n        return &quot;PUT-张三&quot;;\n    &#125;\n\n\n&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.DELETE)\n    @DeleteMapping(&quot;&#x2F;user&quot;)\n    public String deleteUser()&#123;\n        return &quot;DELETE-张三&quot;;\n    &#125;\n\n\n\n\t@Bean\n\t@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)&#x2F;&#x2F;没有Hidden再new OrderedHidden: 默认“_method”\n\t@ConditionalOnProperty(prefix &#x3D; &quot;spring.mvc.hiddenmethod.filter&quot;, name &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; false) &#x2F;&#x2F;默认false +配置！！！\n\tpublic OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;\n\t\treturn new OrderedHiddenHttpMethodFilter();\n\t&#125;\n\n\n\n    &#x2F;&#x2F;扩展点：如何把 _method 这个名字换成我们自己喜欢的\n&#x2F;&#x2F;自定义filter\n    @Bean\n    public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;\n        HiddenHttpMethodFilter methodFilter &#x3D; new HiddenHttpMethodFilter();\n        methodFilter.setMethodParam(&quot;_m&quot;);\n        return methodFilter;\n    &#125;\n\n没有Hidden再new OrderedHidden: 默认“_method”\n\n那就config类自定义HiddenFilter：\n\nboot.config:\n    \n@Configuration(proxyBeanMethods &#x3D; false)\npublic class WebConfig &#x2F;*implements WebMvcConfigurer*&#x2F; &#123;\n\n    @Bean\n    public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;\n        HiddenHttpMethodFilter methodFilter &#x3D; new HiddenHttpMethodFilter();\n        methodFilter.setMethodParam(&quot;_m&quot;);&#x2F;&#x2F;\n        return methodFilter;\n    &#125;\n    \n    \n_m起作用：DELETE   \n&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input name&#x3D;&quot;_m&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;delete&quot;&#x2F;&gt;\n    &lt;input value&#x3D;&quot;REST-DELETE 提交&quot; type&#x3D;&quot;submit&quot;&#x2F;&gt;\n&lt;&#x2F;form&gt;\n    \n_method不起作用：还是POST\n&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input name&#x3D;&quot;_method&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;PUT&quot;&#x2F;&gt;\n    &lt;input value&#x3D;&quot;REST-PUT 提交&quot; type&#x3D;&quot;submit&quot;&#x2F;&gt;\n&lt;&#x2F;form&gt;\n\n\n\n\n\nRest原理（表单提交要使用REST的时候）(&#x3D;&#x3D;表单提交只有GET POST两种&#x3D;&#x3D;，所以要包装到POST。)\n\n表单提交会带上**_method&#x3D;PUT**\n\n请求过来被HiddenHttpMethodFilter拦截\n\n\n请求是否正常，并且是POST\n\n\n\n\n获取到**_method**的值。\n兼容以下请求；(Allowed methods)   PUT.DELETE.PATCH\n\n\n\n\n\n\n原生HttpServletRequest（post），&#x3D;&#x3D;包装模式&#x3D;&#x3D;requestWrapper重写了getMethod方法，返回的是传入的值。\n过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requestWrapper的。\n\n\n\n\n\n\n\nRest使用客户端工具，\n\n如PostMan直接发送Put、delete等方式请求，无需Filter。\n\nspring:\n  mvc:\n    hiddenmethod:\n      filter:\n        enabled: true   #开启页面表单的Rest功能 （选择性开启）\n\n\n\n2、请求映射原理ctrl+H继承树\n\nctrl+F12打开3个父类整个结构\nSpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet-》doDispatch（）开始\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n\t\tHttpServletRequest processedRequest &#x3D; request;\n\t\tHandlerExecutionChain mappedHandler &#x3D; null;\n\t\tboolean multipartRequestParsed &#x3D; false;\n\n\t\tWebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry &#123;\n\t\t\tModelAndView mv &#x3D; null;\n\t\t\tException dispatchException &#x3D; null;\n\n\t\t\ttry &#123;\n\t\t\t\tprocessedRequest &#x3D; checkMultipart(request);\n\t\t\t\tmultipartRequestParsed &#x3D; (processedRequest !&#x3D; request);\n\n\t\t\t\t&#x2F;&#x2F; 找到当前请求使用哪个Handler（Controller的方法）处理\n\t\t\t\tmappedHandler &#x3D; getHandler(processedRequest);\n                \n                &#x2F;&#x2F;HandlerMapping：处理器映射。&#x2F;xxx-&gt;&gt;xxxx\n\n\n\nRequestMappingHandlerMapping：保存了所有@RequestMapping 和handler的映射规则。\n\n所有的请求映射都在HandlerMapping中。\n\n\n4–&gt;1GET\n\n&#x2F;user 多GET，比对都行：二义性报错\n\n\nSpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问&#x2F; 能访问到index.html；\n\nSpringBoot自动配置了默认 的 RequestMappingHandlerMapping【WebMvcAutoConfiguration中搜】\n\n请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。\n\n\n如果有就找到这个请求对应的handler\n如果没有就是下一个 HandlerMapping\n\n\n我们需要一些自定义的映射处理，我们也可以自己给容器中放HandlerMapping【定义请求谁来处理】。\n\n\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;\n\tif (this.handlerMappings !&#x3D; null) &#123;\n\t\tfor (HandlerMapping mapping : this.handlerMappings) &#123;&#x2F;&#x2F;\n\t\t\tHandlerExecutionChain handler &#x3D; mapping.getHandler(request);&#x2F;&#x2F;\n\t\t\tif (handler !&#x3D; null) &#123;\n\t\t\t\treturn handler;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn null;\n&#125;\n\n！！！待填坑ing~~[自定义 HandlerMapping]自定义 HandlerMapping场景举例：\n&#x2F;api&#x2F;v1&#x2F;user—&gt;xxx包处理\n&#x2F;api&#x2F;v2&#x2F;user—&gt;xxx包处理\n1、普通参数与基本注解【&#x3D;&#x3D;！重要！&#x3D;&#x3D;】1.1、注解：&#x3D;&#x3D;@PathVariable、@RequestHeader、@ModelAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody&#x3D;&#x3D;\n@RestController\npublic class ParameterTestController &#123;\n\n\n    &#x2F;&#x2F;  car&#x2F;2&#x2F;owner&#x2F;zhangsan\n    @GetMapping(&quot;&#x2F;car&#x2F;&#123;id&#125;&#x2F;owner&#x2F;&#123;username&#125;&quot;)\n    public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id,\n                                     @PathVariable(&quot;username&quot;) String name,\n                                     @PathVariable Map&lt;String,String&gt; pv,\n                                     @RequestHeader(&quot;User-Agent&quot;) String userAgent,\n                                     @RequestHeader Map&lt;String,String&gt; header,\n                                     @RequestParam(&quot;age&quot;) Integer age,\n                                     @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters,\n                                     @RequestParam Map&lt;String,String&gt; params,\n                                     @CookieValue(&quot;_ga&quot;) String _ga,\n                                     @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123;\n\n\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n\n&#x2F;&#x2F;        map.put(&quot;id&quot;,id);\n&#x2F;&#x2F;        map.put(&quot;name&quot;,name);\n&#x2F;&#x2F;        map.put(&quot;pv&quot;,pv);\n&#x2F;&#x2F;        map.put(&quot;userAgent&quot;,userAgent);\n&#x2F;&#x2F;        map.put(&quot;headers&quot;,header);\n        map.put(&quot;age&quot;,age);\n        map.put(&quot;inters&quot;,inters);\n        map.put(&quot;params&quot;,params);\n        map.put(&quot;_ga&quot;,_ga);\n        System.out.println(cookie.getName()+&quot;&#x3D;&#x3D;&#x3D;&gt;&quot;+cookie.getValue());\n        return map;\n    &#125;\n\n\n    @PostMapping(&quot;&#x2F;save&quot;)\n    public Map postMethod(@RequestBody String content)&#123;\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;content&quot;,content);\n        return map;\n    &#125;\n\n\n    &#x2F;&#x2F;1、语法： 请求路径：&#x2F;cars&#x2F;sell;low&#x3D;34;brand&#x3D;byd,audi,yd\n    &#x2F;&#x2F;2、SpringBoot默认是禁用了矩阵变量的功能\n    &#x2F;&#x2F;      手动开启：原理。对于路径的处理。UrlPathHelper进行解析。\n    &#x2F;&#x2F;              removeSemicolonContent（移除分号内容）支持矩阵变量的\n    &#x2F;&#x2F;3、矩阵变量同名必须有url路径变量才能被解析：pathVar！！！\n    @GetMapping(&quot;&#x2F;cars&#x2F;&#123;path&#125;&quot;)\n    public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low,\n                        @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand,\n                        @PathVariable(&quot;path&quot;) String path)&#123;\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n\n        map.put(&quot;low&quot;,low);\n        map.put(&quot;brand&quot;,brand);\n        map.put(&quot;path&quot;,path);\n        return map;\n    &#125;\n\n    &#x2F;&#x2F; &#x2F;boss&#x2F;1;age&#x3D;20&#x2F;2;age&#x3D;10\n\n    @GetMapping(&quot;&#x2F;boss&#x2F;&#123;bossId&#125;&#x2F;&#123;empId&#125;&quot;)\n    public Map boss(@MatrixVariable(value &#x3D; &quot;age&quot;,pathVar &#x3D; &quot;bossId&quot;) Integer bossAge,\n                    @MatrixVariable(value &#x3D; &quot;age&quot;,pathVar &#x3D; &quot;empId&quot;) Integer empAge)&#123;\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n\n        map.put(&quot;bossAge&quot;,bossAge);\n        map.put(&quot;empAge&quot;,empAge);\n        return map;\n\n    &#125;\n\n&#125;\n\n\n\n\n\n\n\n\n\nWebConfig：\n要么implements WebMvcConfigurer 接口，重写configurePathMatch方法\n要么 直接@Bean一个WebMvcConfigurer组件\n\n\n\n\n\n\n@RequestAttribute（获取request域属性：页面转发时获取请求数据）\n不进行页面功能开发，不返回JSON数据\nRequestController 默认方法返回只做页面跳转：\n\n@Controller\npublic class RequestController &#123;\n\n    @GetMapping(&quot;&#x2F;goto&quot;)\n    public String goToPage(HttpServletRequest request)&#123;\n\n        request.setAttribute(&quot;msg&quot;,&quot;成功了...&quot;);\n        request.setAttribute(&quot;code&quot;,200);\n        return &quot;forward:&#x2F;success&quot;;  &#x2F;&#x2F;转发到  &#x2F;success请求 (或者跳转到页面，用EL表达式写出~)\n    &#125;\n\n\n    @GetMapping(&quot;&#x2F;params&quot;)\n    public String testParam(Map&lt;String,Object&gt; map,\n                            Model model,\n                            HttpServletRequest request,\n                            HttpServletResponse response)&#123;\n        map.put(&quot;hello&quot;,&quot;world666&quot;);\n        model.addAttribute(&quot;world&quot;,&quot;hello666&quot;);\n        request.setAttribute(&quot;message&quot;,&quot;HelloWorld&quot;);\n\n        Cookie cookie &#x3D; new Cookie(&quot;c1&quot;,&quot;v1&quot;);\n        response.addCookie(cookie);\n        return &quot;forward:&#x2F;success&quot;;\n    &#125;\n\n\n    &#x2F;&#x2F;没引入thymeleaf，无template页面，模拟下\n    @ResponseBody\n    @GetMapping(&quot;&#x2F;success&quot;)\n    public Map success(@RequestAttribute(value &#x3D; &quot;msg&quot;,required &#x3D; false) String msg,\n                       @RequestAttribute(value &#x3D; &quot;code&quot;,required &#x3D; false)Integer code,\n                       HttpServletRequest request)&#123;\n        Object msg1 &#x3D; request.getAttribute(&quot;msg&quot;);&#x2F;&#x2F;\n\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n        Object hello &#x3D; request.getAttribute(&quot;hello&quot;);\n        Object world &#x3D; request.getAttribute(&quot;world&quot;);\n        Object message &#x3D; request.getAttribute(&quot;message&quot;);\n\n        map.put(&quot;reqMethod_msg&quot;,msg1);&#x2F;&#x2F;\n        map.put(&quot;annotation_msg&quot;,msg);\n        map.put(&quot;hello&quot;,hello);\n        map.put(&quot;world&quot;,world);\n        map.put(&quot;message&quot;,message);\n\n        return map;\n\n    &#125;\n&#125;\n\n\n\n\n\n1.2、Servlet API：&#x3D;&#x3D;WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId&#x3D;&#x3D;\npublic class RequestController &#123;\n\n\n    @GetMapping(&quot;&#x2F;goto&quot;)\n    public String goToPage(HttpServletRequest request)&#123;\n\n        request.setAttribute(&quot;msg&quot;,&quot;成功了...&quot;);\n        request.setAttribute(&quot;code&quot;,200);\n        return &quot;forward:&#x2F;success&quot;;  &#x2F;&#x2F;转发到  &#x2F;success请求 (或者跳转到页面，用EL表达式写出~)\n    &#125;\n    \n    debug:\n    @Value(SpringEL表达式动态获取值)\n        \n\n\ninto\nServletRequestMethodArgumentResolver  可以解析以上的部分参数\nHttpServletRequest\n@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) &#123;\n\t\tClass&lt;?&gt; paramType &#x3D; parameter.getParameterType();\n\t\treturn (WebRequest.class.isAssignableFrom(paramType) ||\n\t\t\t\tServletRequest.class.isAssignableFrom(paramType) ||\n\t\t\t\tMultipartRequest.class.isAssignableFrom(paramType) ||\n\t\t\t\tHttpSession.class.isAssignableFrom(paramType) ||\n\t\t\t\t(pushBuilder !&#x3D; null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||\n\t\t\t\tPrincipal.class.isAssignableFrom(paramType) ||\n\t\t\t\tInputStream.class.isAssignableFrom(paramType) ||\n\t\t\t\tReader.class.isAssignableFrom(paramType) ||\n\t\t\t\tHttpMethod.class &#x3D;&#x3D; paramType ||\n\t\t\t\tLocale.class &#x3D;&#x3D; paramType ||\n\t\t\t\tTimeZone.class &#x3D;&#x3D; paramType ||\n\t\t\t\tZoneId.class &#x3D;&#x3D; paramType);\n\t&#125;\n\nresolveArgument\n\n\n1.3、复杂参数：&#x3D;&#x3D;Map、Model（map、model里面的数据会被放在request的请求域  &#x3D;&#x3D;request.setAttribute）、Errors&#x2F;BindingResult、RedirectAttributes（ 重定向携带数据   页面开始时用）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder&#x3D;&#x3D;\nMap&lt;String,Object&gt; map,  Model model, HttpServletRequest request 都是可以给request域中放数据，\nrequest.getAttribute();\n\n\n@Controller\npublic class RequestController &#123;\n    @GetMapping(&quot;&#x2F;goto&quot;)\n    public String goToPage(HttpServletRequest request)&#123;\n\n        request.setAttribute(&quot;msg&quot;,&quot;成功了...&quot;);\n        request.setAttribute(&quot;code&quot;,200);\n        return &quot;forward:&#x2F;success&quot;;  &#x2F;&#x2F;转发到  &#x2F;success请求 (或者跳转到页面，用EL表达式写出~)\n    &#125;\n    \n    @GetMapping(&quot;&#x2F;params&quot;)\n    public String testParam(Map&lt;String,Object&gt; map,\n                            Model model,\n                            HttpServletRequest request,\n                            HttpServletResponse response)&#123;\n        map.put(&quot;hello&quot;,&quot;world666&quot;);\n        model.addAttribute(&quot;world&quot;,&quot;hello666&quot;);\n        request.setAttribute(&quot;message&quot;,&quot;HelloWorld&quot;);&#x2F;&#x2F;&#x3D;&#x3D;\n\n        Cookie cookie &#x3D; new Cookie(&quot;c1&quot;,&quot;v1&quot;);\n        cookie.setDomain(&quot;localhost&quot;);\n        response.addCookie(cookie);&#x2F;&#x2F;让浏览器加一个Cookie\n        return &quot;forward:&#x2F;success&quot;;\n    &#125;\n\n    &#x2F;&#x2F;没引入thymeleaf，无template页面，模拟下\n    @ResponseBody\n    @GetMapping(&quot;&#x2F;success&quot;)\n    public Map success(@RequestAttribute(value &#x3D; &quot;msg&quot;,required &#x3D; false) String msg,&#x2F;&#x2F;goToPage  required &#x3D; false\n                       @RequestAttribute(value &#x3D; &quot;code&quot;,required &#x3D; false)Integer code,\n                       HttpServletRequest request)&#123;\n        Object msg1 &#x3D; request.getAttribute(&quot;msg&quot;);&#x2F;&#x2F;\n\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n        Object hello &#x3D; request.getAttribute(&quot;hello&quot;);&#x2F;&#x2F;testParam 中放入request域的3个属性\n        Object world &#x3D; request.getAttribute(&quot;world&quot;);\n        Object message &#x3D; request.getAttribute(&quot;message&quot;);\n\n        map.put(&quot;reqMethod_msg&quot;,msg1);&#x2F;&#x2F;\n        map.put(&quot;annotation_msg&quot;,msg);\n        map.put(&quot;hello&quot;,hello);\n        map.put(&quot;world&quot;,world);\n        map.put(&quot;message&quot;,message);\n\n        return map;\n\n    &#125;\n\n\n\n\n\n\nctrl+F12搜ModelAndViewContainer.getModel()\nMap、Model类型的参数，会返回 mavContainer.getModel();—&gt; BindingAwareModelMap 是Model 也是Map\nmavContainer.getModel(); 获取到值的\n\n\n\n-&gt; 3 原理6\n\n\n1.4、自定义对象参数：表单post–&gt;json对象可以自动类型转换与格式化，可以级联封装。\n&#x2F;**\n * &lt;form action&#x3D;&quot;&#x2F;saveuser&quot; method&#x3D;&quot;post&quot;&gt;\n *     姓名： &lt;input name&#x3D;&quot;userName&quot;&#x2F;&gt; &lt;br&#x2F;&gt;\n *     年龄： &lt;input name&#x3D;&quot;age&quot;&#x2F;&gt; &lt;br&#x2F;&gt;\n *     生日： &lt;input name&#x3D;&quot;birth&quot;&#x2F;&gt; &lt;br&#x2F;&gt;\n *     宠物姓名：&lt;input name&#x3D;&quot;pet.name&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n *     宠物年龄：&lt;input name&#x3D;&quot;pet.age&quot;&#x2F;&gt;\n *     &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;保存&quot;&#x2F;&gt;\n * &lt;&#x2F;form&gt;\n *&#x2F;\n@Data\npublic class Person &#123;\n    \n    private String userName;\n    private Integer age;\n    private Date birth;\n    private Pet pet;\n    \n&#125;\n\n@Data\npublic class Pet &#123;\n\n    private String name;\n    private String age;\n\n&#125;\n\nresult\n    \n    \n测试封装POJO；\n&lt;form action&#x3D;&quot;&#x2F;saveuser&quot; method&#x3D;&quot;post&quot;&gt;\n    姓名： &lt;input name&#x3D;&quot;userName&quot; value&#x3D;&quot;zhangsan&quot;&#x2F;&gt; &lt;br&#x2F;&gt;\n    年龄： &lt;input name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&#x2F;&gt; &lt;br&#x2F;&gt;\n    生日： &lt;input name&#x3D;&quot;birth&quot; value&#x3D;&quot;2019&#x2F;12&#x2F;10&quot;&#x2F;&gt; &lt;br&#x2F;&gt;\n&lt;!--    宠物姓名：&lt;input name&#x3D;&quot;pet.name&quot; value&#x3D;&quot;阿猫&quot;&#x2F;&gt;&lt;br&#x2F;&gt;--&gt;\n&lt;!--    宠物年龄：&lt;input name&#x3D;&quot;pet.age&quot; value&#x3D;&quot;5&quot;&#x2F;&gt;--&gt;\n    宠物： &lt;input name&#x3D;&quot;pet&quot; value&#x3D;&quot;啊猫,3&quot;&#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;保存&quot;&#x2F;&gt;\n&lt;&#x2F;form&gt;\n    \n@RestController\npublic class ParameterTestController &#123;\n\n    &#x2F;**\n     * 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定\n     * @param person\n     * @return\n     *&#x2F;\n    @PostMapping(&quot;&#x2F;saveuser&quot;)\n    public Person saveuser(Person person)&#123;\n\n        return person;\n    &#125;\n\n\n\n2、POJO封装过程\nrun保存 debug带参数&#x2F;saveuser ： support-最后一个ServletModelAttributeMethodProcessor\n原理见5.3\n\n\n\n3、参数处理【原理】DispatcherServlet-doDispatch:\n\nHandlerMapping中找到能处理请求的Handler（Controller.method()）\n\n为当前Handler 找一个适配器 HandlerAdapter； RequestMappingHandlerAdapter\n\n\n\n\n\n适配器执行目标方法并确定方法参数的每一个值\n\n\n\n1、HandlerAdapter\n0 - 支持方法上标注@RequestMapping \n1 - 支持函数式编程的\nxxxxxx\n2、执行目标方法&#x2F;&#x2F; Actually invoke the handler.\n&#x2F;&#x2F;DispatcherServlet -- doDispatch:\nmv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());\n【step into-&gt;*4到RequestMappingHandlerAdapter里的handleInternal  往下】\nmav &#x3D; invokeHandlerMethod(request, response, handlerMethod); &#x2F;&#x2F;执行目标方法\ninto\n真正执行！\n\n&#x2F;&#x2F;ServletInvocableHandlerMethod\nObject returnValue &#x3D; invokeForRequest(webRequest, mavContainer, providedArgs);\n&#x2F;&#x2F;获取方法的参数值\nObject[] args &#x3D; getMethodArgumentValues(request, mavContainer, providedArgs);\n\n\n封装好后，真正开始执行：\n\ninto\n\n\ninto\n\ninto doInvoke：反射工具类 调用目标方法\nto 5、getMethodArgumentValues        into…\n3、参数解析器-HandlerMethodArgumentResolver确定将要执行的目标方法的每一个参数的值是什么;\nSpringMVC目标方法能写多少种参数类型。取决于参数解析器。\nHierarchy:\n\n\n\n当前解析器【是否支持解析这种】参数\n支持就调用 resolveArgument进行解析\n\n4、返回值处理器\n调试：\nhttp://localhost:8081/car/2/owner/zhangsan \n5、如何确定目标方法每一个参数的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;InvocableHandlerMethod&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception &#123;\n\n\t\tMethodParameter[] parameters &#x3D; getMethodParameters();&#x2F;&#x2F;\n\t\tif (ObjectUtils.isEmpty(parameters)) &#123;\n\t\t\treturn EMPTY_ARGS;\n\t\t&#125;\n\n\t\tObject[] args &#x3D; new Object[parameters.length];\n\t\tfor (int i &#x3D; 0; i &lt; parameters.length; i++) &#123;\n\t\t\tMethodParameter parameter &#x3D; parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] &#x3D; findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] !&#x3D; null) &#123;\n\t\t\t\tcontinue;\n\t\t\t&#125;\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) &#123;&#x2F;&#x2F;\n\t\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));\n\t\t\t&#125;\n\t\t\ttry &#123;\n\t\t\t\targs[i] &#x3D; this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);&#x2F;&#x2F;\n\t\t\t&#125;\n\t\t\tcatch (Exception ex) &#123;\n\t\t\t\t&#x2F;&#x2F; Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\t\t\tString exMsg &#x3D; ex.getMessage();\n\t\t\t\t\tif (exMsg !&#x3D; null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tthrow ex;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn args;\n\t&#125;\n\ngetMethodParameters();\nthis.resolvers.supportsParameter(parameter):  into…\n5.1、挨个判断所有参数解析器那个支持解析这个参数@Nullable\nprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;\n\tHandlerMethodArgumentResolver result &#x3D; this.argumentResolverCache.get(parameter);&#x2F;&#x2F;\n\tif (result &#x3D;&#x3D; null) &#123;\n\t\tfor (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123;\n\t\t\tif (resolver.supportsParameter(parameter)) &#123;&#x2F;&#x2F;\n\t\t\t\tresult &#x3D; resolver;\n\t\t\t\tthis.argumentResolverCache.put(parameter, result);&#x2F;&#x2F;缓存组件，越来越快！\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn result;\n&#125;\n\n\n\nsupportsParameter             into:\n\n5.2、解析这个参数的值调用各自 HandlerMethodArgumentResolver 的 resolveArgument 方法即可\n\n\nurlPathHelper解析路径变量保存到request域中\n\nRequestHeader：\n\n5.3、自定义类型参数 封装POJOServletModelAttributeMethodProcessor  这个参数处理器支持\n 是否为简单类型。\npublic static boolean isSimpleValueType(Class&lt;?&gt; type) &#123;\n\t\treturn (Void.class !&#x3D; type &amp;&amp; void.class !&#x3D; type &amp;&amp;\n\t\t\t\t(ClassUtils.isPrimitiveOrWrapper(type) ||\n\t\t\t\tEnum.class.isAssignableFrom(type) ||\n\t\t\t\tCharSequence.class.isAssignableFrom(type) ||\n\t\t\t\tNumber.class.isAssignableFrom(type) ||\n\t\t\t\tDate.class.isAssignableFrom(type) ||\n\t\t\t\tTemporal.class.isAssignableFrom(type) ||\n\t\t\t\tURI.class &#x3D;&#x3D; type ||\n\t\t\t\tURL.class &#x3D;&#x3D; type ||\n\t\t\t\tLocale.class &#x3D;&#x3D; type ||\n\t\t\t\tClass.class &#x3D;&#x3D; type));\n\t&#125;\n\n\n\n@Override\n\t@Nullable\n\tpublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;\n\n\t\tAssert.state(mavContainer !&#x3D; null, &quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;);\n\t\tAssert.state(binderFactory !&#x3D; null, &quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;);\n\n\t\tString name &#x3D; ModelFactory.getNameForParameter(parameter);\n\t\tModelAttribute ann &#x3D; parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tif (ann !&#x3D; null) &#123;\n\t\t\tmavContainer.setBinding(name, ann.binding());\n\t\t&#125;\n\n\t\tObject attribute &#x3D; null;\n\t\tBindingResult bindingResult &#x3D; null;\n\n\t\tif (mavContainer.containsAttribute(name)) &#123;\n\t\t\tattribute &#x3D; mavContainer.getModel().get(name);\n\t\t&#125;\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F; Create attribute instance\n\t\t\ttry &#123;\n\t\t\t\tattribute &#x3D; createAttribute(name, parameter, binderFactory, webRequest);\n\t\t\t&#125;\n\t\t\tcatch (BindException ex) &#123;\n\t\t\t\tif (isBindExceptionRequired(parameter)) &#123;\n\t\t\t\t\t&#x2F;&#x2F; No BindingResult parameter -&gt; fail with BindException\n\t\t\t\t\tthrow ex;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; Otherwise, expose null&#x2F;empty value and associated BindingResult\n\t\t\t\tif (parameter.getParameterType() &#x3D;&#x3D; Optional.class) &#123;\n\t\t\t\t\tattribute &#x3D; Optional.empty();\n\t\t\t\t&#125;\n\t\t\t\tbindingResult &#x3D; ex.getBindingResult();\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (bindingResult &#x3D;&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; Bean property binding and validation;\n\t\t\t&#x2F;&#x2F; skipped in case of binding failure on construction.\n\t\t\tWebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, attribute, name);&#x2F;&#x2F;!!!!!!!!!!!!!!!\n\t\t\tif (binder.getTarget() !&#x3D; null) &#123;\n\t\t\t\tif (!mavContainer.isBindingDisabled(name)) &#123;\n\t\t\t\t\tbindRequestParameters(binder, webRequest);\n\t\t\t\t&#125;\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;\n\t\t\t\t\tthrow new BindException(binder.getBindingResult());\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F; Value type adaptation, also covering java.util.Optional\n\t\t\tif (!parameter.getParameterType().isInstance(attribute)) &#123;\n\t\t\t\tattribute &#x3D; binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n\t\t\t&#125;\n\t\t\tbindingResult &#x3D; binder.getBindingResult();\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Add resolved attribute and BindingResult at the end of the model\n\t\tMap&lt;String, Object&gt; bindingResultModel &#x3D; bindingResult.getModel();\n\t\tmavContainer.removeAttributes(bindingResultModel);\n\t\tmavContainer.addAllAttributes(bindingResultModel);\n\n\t\treturn attribute;\n\t&#125;\n\n将请求数据封装入Person对象里\n\nWebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, attribute, name);\nWebDataBinder :web数据绑定器，将请求参数的值绑定到指定的JavaBean里面\nWebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次(反射)封装到JavaBean中：\nbindRequestParameters(binder, webRequest);\n\n\n\nGenericConversionService.find：在设置每一个值的时候，找它里面的所有converter哪个可以将这个数据类型（request带来参数的字符串）转换到指定的类型（JavaBean – Integer）\n文件上传： byte流 – &gt; file \n见1、SpringMVC自动配置概览：\n\n@FunctionalInterfacepublic interface Converter&lt;S, T&gt;\n\n\n未来我们可以给WebDataBinder里面放自己的Converter；\nprivate static final class StringToNumber&lt;T **extends** Number&gt; implements Converter&lt;String, T&gt;\n自定义 Converter！！！！！\n\n货币、时间等\n类型转换器 格式化\n\n&#x2F;&#x2F;1、WebMvcConfigurer定制化SpringMVC的功能\n@Bean\npublic WebMvcConfigurer webMvcConfigurer()&#123;\n    return new WebMvcConfigurer() &#123;\n        @Override\n        public void configurePathMatch(PathMatchConfigurer configurer) &#123;\n            UrlPathHelper urlPathHelper &#x3D; new UrlPathHelper();\n            &#x2F;&#x2F; 不移除；后面的内容。矩阵变量功能就可以生效\n            urlPathHelper.setRemoveSemicolonContent(false);\n            configurer.setUrlPathHelper(urlPathHelper);\n        &#125;\n\n        @Override\n        public void addFormatters(FormatterRegistry registry) &#123;\n            registry.addConverter(new Converter&lt;String, Pet&gt;() &#123;\n\n                @Override\n                public Pet convert(String source) &#123;\n                    &#x2F;&#x2F; 啊猫,3\n                    if(!StringUtils.isEmpty(source))&#123;\n                        Pet pet &#x3D; new Pet();\n                        String[] split &#x3D; source.split(&quot;,&quot;);\n                        pet.setName(split[0]);\n                        pet.setAge(Integer.parseInt(split[1]));\n                        return pet;\n                    &#125;\n                    return null;\n                &#125;\n            &#125;);\n        &#125;\n    &#125;;\n&#125;\n\n\n\nhttp://localhost:8081/params debug：\n6、目标方法执行完成将所有的数据都放在 ModelAndViewContainer；包含【要去的页面地址View。还包含Model数据。】\n\n跳出到\n\n7、处理派发结果return &quot;forward:&#x2F;success&quot;;\n\n一路into\n\ninto into F8\ngetModelAndView里：\nmodelFactory.updateModel(webRequest, mavContainer);\n\n\n\nDisPatcherServlet里：\nha.handle()\napplyPostHandle() 拦截器…\nprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\nrenderMergedOutputModel(mergedModel, getRequestToExpose(request), response);\ninto*2:   exposeModelAsRequestAttributes！！！！！！！！！！！！！\nInternalResourceView：\n@Override\n\tprotected void renderMergedOutputModel(\n\t\t\tMap&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n\n\t\t&#x2F;&#x2F; Expose the model object as request attributes.\n\t\texposeModelAsRequestAttributes(model, request);\n\n\t\t&#x2F;&#x2F; Expose helpers as request attributes, if any.\n\t\texposeHelpers(request);\n\n\t\t&#x2F;&#x2F; Determine the path for the request dispatcher.\n\t\tString dispatcherPath &#x3D; prepareForRendering(request, response);\n\n\t\t&#x2F;&#x2F; Obtain a RequestDispatcher for the target resource (typically a JSP).\n\t\tRequestDispatcher rd &#x3D; getRequestDispatcher(request, dispatcherPath);\n\t\tif (rd &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +\n\t\t\t\t\t&quot;]: Check that the corresponding file exists within your web application archive!&quot;);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; If already included or response already committed, perform include, else forward.\n\t\tif (useInclude(request, response)) &#123;\n\t\t\tresponse.setContentType(getContentType());\n\t\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\t\tlogger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;);\n\t\t\t&#125;\n\t\t\trd.include(request, response);\n\t\t&#125;\n\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F; Note: The forwarded resource is supposed to determine the content type itself.\n\t\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\t\tlogger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;);\n\t\t\t&#125;\n\t\t\trd.forward(request, response);\n\t\t&#125;\n\t&#125;\n\n\n\n暴露模型作为请求域属性\n&#x2F;&#x2F; Expose the model object as request attributes.\n\t\texposeModelAsRequestAttributes(model, request);\n\nmodel.forEach：request.setAttribute！！！！！！！！！！\nprotected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model,\n\t\t\tHttpServletRequest request) throws Exception &#123;\n\n    &#x2F;&#x2F;model中的所有数据遍历挨个放在请求域中\n\t\tmodel.forEach((name, value) -&gt; &#123;\n\t\t\tif (value !&#x3D; null) &#123;\n\t\t\t\trequest.setAttribute(name, value);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\trequest.removeAttribute(name);\n\t\t\t&#125;\n\t\t&#125;);\n\t&#125;\n\nmap、model–&gt;request域 在渲染视图view.render时放，即SpringMVC决定要跳转到哪个页面了，跳转之前request.setAttribute的。\n4、数据响应与内容协商响应page:单体   响应data:前后端分离\n\n1、响应JSON1.1、jackson.jar+@ResponseBody        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\nweb场景自动引入了json场景\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-json&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n      &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n\n\n给前端自动返回json数据；\n1、返回值解析器\n&#x3D;&#x3D;invokeForRequest、F8断点调试：&#x2F;test&#x2F;person&#x3D;&#x3D;\ntry &#123;\n\t\t\tthis.returnValueHandlers.handleReturnValue(\n\t\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\t\t&#125;\n\n\n\n\t@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123;\n\n\t\tHandlerMethodReturnValueHandler handler &#x3D; selectHandler(returnValue, returnType);&#x2F;&#x2F;\n\t\tif (handler &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());\n\t\t&#125;\n\t\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#x2F;&#x2F;\n\t&#125;\n\n\n\nRequestResponseBodyMethodProcessor!!!!\n@Override\n\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;\n\n\t\tmavContainer.setRequestHandled(true);\n\t\tServletServerHttpRequest inputMessage &#x3D; createInputMessage(webRequest);\n\t\tServletServerHttpResponse outputMessage &#x3D; createOutputMessage(webRequest);\n\n\t\t&#x2F;&#x2F; Try even with null return value. ResponseBodyAdvice could get involved.\n        &#x2F;&#x2F; 使用消息转换器进行写出操作\n\t\twriteWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n\t&#125;\n\n\n\n2、返回值解析器原理\n&#x3D;&#x3D;invokeForRequest、F8断点调试：&#x2F;test&#x2F;person&#x3D;&#x3D;\n\n1、返回值处理器判断是否支持这种类型返回值 supportsReturnType\n\n2、返回值处理器调用 handleReturnValue 进行处理\n\n3、RequestResponseBodyMethodProcessor 可以处理返回值标了@ResponseBody 注解的。\n\n\n\\1.  利用 MessageConverters 进行处理 将数据写为json\n\n\n\n\n1、【MediaType】内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）\nq&#x3D;权重！&#x3D;&#x3D;xml_q&#x3D;0.9     &gt;     *&#x2F;*&#x3D;json_q&#x3D;0.8，所以浏览器默认优先响应xml数据！！！！！！！！！！&#x3D;&#x3D;\n\n\n\n2、服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，\n\n\n\n\n\n\n3、SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理？\n\n\n\n\n\n\n\n1、得到MappingJackson2HttpMessageConverter可以将对象写为json\n2、利用MappingJackson2HttpMessageConverter将对象转为json再写出去。\n\n\n\n\n\n\n\n@Controller\npublic class ResponseTestController &#123;\n\n\n    @ResponseBody &#x2F;&#x2F;--RequestResponseBodyMethodProcessor ---&gt; messageConverter\n    @GetMapping(&quot;&#x2F;he11&quot;)\n    public FileSystemResource file()&#123;&#x2F;&#x2F;implement Resource~\n\n\n        &#x2F;&#x2F;作业：文件以这样的方式返回看是谁处理的（messageConverter）。?？\n        return null;\n    &#125;\n\n\n    &#x2F;**\n     * 1、浏览器发请求直接返回 xml    [application&#x2F;xml]        jacksonXmlConverter\n     * 2、如果是ajax(JS)请求 返回 json   [application&#x2F;json]      jacksonJsonConverter\n     * 3、如果硅谷app发请求，返回自定义协议数据  [appliaction&#x2F;x-guigu]   xxxxConverter\n     *          属性值1;属性值2;\n     *\n     * 步骤：\n     * 1、添加自定义的MessageConverter进系统底层\n     * 2、系统底层就会统计出所有MessageConverter能操作哪些类型\n     * 3、客户端内容协商 [guigu---&gt;guigu]\n     *\n     * 作业：如何以参数的方式进行内容协商?？\n     * @return\n     *&#x2F;\n    @ResponseBody  &#x2F;&#x2F;利用返回值处理器里面的消息转换器进行处理\n    @GetMapping(value &#x3D; &quot;&#x2F;test&#x2F;person&quot;)\n    public Person getPerson()&#123;\n        Person person &#x3D; new Person();\n        person.setAge(28);\n        person.setBirth(new Date());\n        person.setUserName(&quot;zhangsan&quot;);\n        return person;\n    &#125;\n\n&#125;\n\n\n1.2、SpringMVC到底支持哪些返回值ModelAndView\nModel\nView\nResponseEntity \nResponseBodyEmitter\nStreamingResponseBody\nHttpEntity\nHttpHeaders\nCallable     异步的\nDeferredResult\nListenableFuture\nCompletionStage   MVC包装了的async\nWebAsyncTask\n有 @ModelAttribute 且为对象类型的:!simpleType\n@ResponseBody 注解 ---&gt; RequestResponseBodyMethodProcessor；&#x2F;&#x2F;!!!\n\n1.3、HTTPMessageConverter原理1、MessageConverter规范\nHttpMessageConverter: 看是否支持将 此 Class类型的对象，转为MediaType类型的数据。\n例子：Person对象转W为JSON response。或者 JSON转R为Person req\n2、默认的MessageConverter\n0 - 只支持Byte类型的ret\n1 - String\n2 - String\n3 - Resource\n4 - ResourceRegion\n5 - DOMSource.class \\SAXSource.class \\ StAXSource.class \\StreamSource.class \\Source.class   【HashSet   xml解析相关~】\n6 - MultiValueMap\n&#x3D;&#x3D;7 - true  MappingJackson2     任意类型可转换~&#x3D;&#x3D;\n8 - true\n9 - 支持注解方式xml处理的。  XmlRootElement\n最终 MappingJackson2HttpMessageConverter  把(任意类型)对象转为JSON（利用底层的jackson的objectMapper转换的）\n\n2、内容协商根据客户端接收能力不同，返回不同媒体类型的数据。json xml….\n1、引入xml依赖 &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;jackson-dataformat-xml&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2、postman分别测试返回json和xml只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型。\n\n\n3、开启浏览器参数方式内容协商功能postman发xml头req debug：handleReturnValue-in-F8:           MediaType\n&#x3D;&#x3D;浏览器不好改req头Accept字段为json，除非ajax数据setRequestAttribute(“ContentType”)&#x3D;&#x3D;\n&#x3D;&#x3D;为了方便内容协商，开启基于请求参数的内容协商功能。&#x3D;&#x3D;\nspring:\n    contentnegotiation:\n      favor-parameter: true  #开启请求参数内容协商模式\n\n\n浏览器发请求【带参?format&#x3D;】： http://localhost:8080/test/person?format=json \nhttp://localhost:8080/test/person?format=xml \n\n确定客户端接收什么样的内容类型；\n1、Parameter策略优先确定是要返回json数据（获取请求头中的format的值）\n\n2、最终进行内容协商返回给客户端json即可。\n\n4、内容协商原理\n1、判断当前响应头中是否已经有确定的媒体类型。MediaType\n\nMediaType contentType = outputMessage.getHeaders().getContentType();\n\n- **2、getAcceptableMediaTypes 获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段）【application&#x2F;xml】**\n\n- - **contentNegotiationManager 内容协商管理器 默认使用基于请求头的策略**\n  - ![img](https:&#x2F;&#x2F;cdn.nlark.com&#x2F;yuque&#x2F;0&#x2F;2020&#x2F;png&#x2F;1354552&#x2F;1605230462280-ef98de47-6717-4e27-b4ec-3eb0690b55d0.png?x-oss-process&#x3D;image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n- - **HeaderContentNegotiationStrategy  确定客户端可以接收的内容类型** \n  - ![img](https:&#x2F;&#x2F;cdn.nlark.com&#x2F;yuque&#x2F;0&#x2F;2020&#x2F;png&#x2F;1354552&#x2F;1605230546376-65dcf657-7653-4a58-837a-f5657778201a.png?x-oss-process&#x3D;image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n- 3、**getProducibleMediaTypes**  遍历循环所有当前系统的 **MessageConverter**，看谁支持操作这个对象（Person）: canWrite\n\n- 4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。  result.**addAll**(converter.getSupportedMediaTypes());\n\n- 5、客户端需要【application&#x2F;xml】。服务端能力【10种、json、xml】&#x3D;&#x3D;优化点：这里可以把server端处理能力producibleType(已固定)全部提前缓存起来，会快一点！&#x3D;&#x3D;\n\n- ![img](https:&#x2F;&#x2F;cdn.nlark.com&#x2F;yuque&#x2F;0&#x2F;2020&#x2F;png&#x2F;1354552&#x2F;1605173876646-f63575e2-50c8-44d5-9603-c2d11a78adae.png?x-oss-process&#x3D;image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n- &#96;&#96;&#96;\n  isCompatibleWith\n\n\n6、进行内容协商的最佳匹配媒体类型 isConcrete():\n\n\n\n7、用 支持 [将对象转为 最佳匹配媒体类型(xml)] 的converter。调用它进行转化 。\n\n\n\n导入了jackson处理xml的包，xml的converter就会自动进来\nWebMvcConfigurationSupport:\njackson2XmlPresent &#x3D; ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);\n\nif (jackson2XmlPresent) &#123;\n\t\t\tJackson2ObjectMapperBuilder builder &#x3D; Jackson2ObjectMapperBuilder.xml();\n\t\t\tif (this.applicationContext !&#x3D; null) &#123;\n\t\t\t\tbuilder.applicationContext(this.applicationContext);\n\t\t\t&#125;\n\t\t\tmessageConverters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));\n\t\t&#125;\n\n\n5、自定义 MessageConverter！！！！！！实现多协议数据兼容。json、xml、x-guigu\n0、@ResponseBody 响应数据出去 调用 RequestResponseBodyMethodProcessor 处理\n1、Processor 处理方法返回值。通过 MessageConverter 处理\n2、所有 MessageConverter 合起来可以支持各种媒体类型数据的操作（读、写）：CanR R CanW WtoT\n3、内容协商找到最终的 messageConverter；\n系统默认Converter： WebMvcAutoConfiguration\n\nthis\naddDefaultConverters               getDefaultConverters              super.getMessageConverters();\naddDefaultHttpMessageConverters    jackson2XmlPresent：\njackson2XmlPresent &#x3D; ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);\n见上节4、内容协商原理\n\n导入了jackson处理xml的包，xml的converter就会自动进来\n    &#x2F;**\n     * 1、浏览器发请求直接返回 xml    [application&#x2F;xml]        jacksonXmlConverter\n     * 2、如果是ajax(JS)请求 返回 json   [application&#x2F;json]      jacksonJsonConverter\n     * 3、如果硅谷app发请求，返回自定义协议数据  [appliaction&#x2F;x-guigu]   xxxxConverter\n     *          属性值1;属性值2;\n     *\n     * 步骤：\n     * 1、添加自定义的MessageConverter进系统底层\n     * 2、系统底层就会统计出所有MessageConverter能操作哪些类型\n     * 3、客户端内容协商 [guigu---&gt;guigu]\n     *\n     * 作业：如何以参数的方式进行【自定义】内容协商?？\n     * @return\n     *&#x2F;\n    @ResponseBody  &#x2F;&#x2F;利用返回值处理器里面的消息转换器进行处理\n    @GetMapping(value &#x3D; &quot;&#x2F;test&#x2F;person&quot;)\n    public Person getPerson()&#123;\n        Person person &#x3D; new Person();\n        person.setAge(28);\n        person.setBirth(new Date());\n        person.setUserName(&quot;zhangsan&quot;);\n        return person;\n    &#125;\n\n&#125;\n\nSpringMVC的什么功能。一个入口给容器中添加一个  WebMvcConfigurer\nWebConfig中编写：\n@Configuration(proxyBeanMethods &#x3D; false)\npublic class WebConfig &#x2F;*implements WebMvcConfigurer*&#x2F; &#123;\n    \n    &#x2F;&#x2F;1、WebMvcConfigurer定制化SpringMVC的功能\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer()&#123;\n        return new WebMvcConfigurer() &#123;\n\n            &#x2F;**\n             * 自定义内容协商策略\n             * @param configurer\n             *&#x2F;\n            @Override &#x2F;&#x2F;覆盖默认\n            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;\n                &#x2F;&#x2F;Map&lt;String, MediaType&gt; mediaTypes\n                Map&lt;String, MediaType&gt; mediaTypes &#x3D; new HashMap&lt;&gt;();\n                mediaTypes.put(&quot;json&quot;,MediaType.APPLICATION_JSON);\n                mediaTypes.put(&quot;xml&quot;,MediaType.APPLICATION_XML);\n                mediaTypes.put(&quot;gg&quot;,MediaType.parseMediaType(&quot;application&#x2F;x-guigu&quot;));&#x2F;&#x2F;acceptable 绑定producible\n                &#x2F;&#x2F;指定支持解析哪些参数对应的哪些媒体类型\n                ParameterContentNegotiationStrategy parameterStrategy &#x3D; new ParameterContentNegotiationStrategy(mediaTypes);&#x2F;&#x2F;参数类型!!!\n&#x2F;&#x2F;                parameterStrategy.setParameterName(&quot;ff&quot;); &#x2F;&#x2F;?format&#x3D;---&gt;?ff&#x3D;\n\n                HeaderContentNegotiationStrategy headStrategy &#x3D; new HeaderContentNegotiationStrategy();&#x2F;&#x2F;否则不能用postman改头Accept字段生效！！！\n\n                configurer.strategies(Arrays.asList(parameterStrategy,headStrategy));&#x2F;&#x2F;!!!\n            &#125;\n\n            @Override &#x2F;&#x2F;默认+扩展:自定义的Converter\n            public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n                converters.add(new GuiguMessageConverter());&#x2F;&#x2F;\n            &#125;\n        &#125;\n        \n        \n        \n        \n        \n        \n    &#125;\n\nconverter.GuiguMessageConverter:\n&#x2F;**\n * 自定义的Converter：implements HttpMessageConverter&lt;Person&gt;\n *&#x2F;\npublic class GuiguMessageConverter implements HttpMessageConverter&lt;Person&gt; &#123;\n\n    @Override\n    public boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType) &#123;&#x2F;&#x2F;@RequestBody 略\n        return false;\n    &#125;\n\n    @Override\n    public boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType) &#123;\n        return clazz.isAssignableFrom(Person.class);&#x2F;&#x2F;处理Person-&gt;...\n    &#125;\n\n    &#x2F;**\n     * 服务器要统计所有MessageConverter都能写出哪些内容类型\n     *\n     * application&#x2F;x-guigu\n     * @return\n     *&#x2F;\n    @Override\n    public List&lt;MediaType&gt; getSupportedMediaTypes() &#123;\n        return MediaType.parseMediaTypes(&quot;application&#x2F;x-guigu&quot;);&#x2F;&#x2F;producible\n    &#125;\n\n    @Override\n    public Person read(Class&lt;? extends Person&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123;\n        &#x2F;&#x2F;自定义协议数据的写出\n        String data &#x3D; person.getUserName()+&quot;;&quot;+person.getAge()+&quot;;&quot;+person.getBirth();&#x2F;&#x2F;属性值1;属性值2;\n\n\n        &#x2F;&#x2F;写出去\n        OutputStream body &#x3D; outputMessage.getBody();\n        body.write(data.getBytes());\n    &#125;\n&#125;\n\n\n\n\n\n只自定义param后，只能解析参数的，没有Header的策略\naccept *&#x2F;* 都行，就第一个优先：一律返回json！！！\n所以必须new一个空new HeaderContentNegotiationStrategy(); 入strategies的List{里}。 头、参都行了！！！\n【浏览器：参数?format&#x3D;gg   postman：头accept  application&#x2F;x-guigu】\n还可以+Path。。。\npublic class HeaderContentNegotiationStrategy implements ContentNegotiationStrategy &#123;\n\npublic interface ContentNegotiationStrategy &#123;\n\n\n\n\n有可能我们添加的自定义的功能会覆盖默认很多功能，导致一些默认的功能失效。【看源码，缺啥添啥   HeaderStrategy】\n作业：大家考虑，上述功能除了我们完全自定义外？SpringBoot有没有为我们提供基于配置文件的快速修改媒体类型功能？怎么配置呢？【提示：参照SpringBoot官方文档web开发内容协商章节】\n5、视图解析与模板引擎视图解析（页面跳转）：SpringBoot默认不支持 JSP[不支持在Jar压缩包中编译]，需要引入第三方模板引擎技术实现页面渲染。\n1、视图解析\n1、视图解析原理流程1、目标方法处理的过程中，所有数据都会被放在 ModelAndViewContainer 里面。包括数据和视图地址\n2、方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在 ModelAndViewContainer \n3、任何目标方法执行完成以后都会返回 ModelAndView（数据和视图地址）。\n4、****processDispatchResult  处理派发结果（页面改如何响应）\n\n1、render(mv, request, response); 进行页面渲染逻辑\n\n\n1、根据方法的String返回值得到 View 对象【定义了页面的渲染逻辑】\n\n\n\n\n1、所有的视图解析器尝试是否能根据当前返回值得到View对象\n2、得到了  redirect:&#x2F;main.html –&gt; Thymeleaf new RedirectView()\n\n\n\n\n\n\n3、ContentNegotiationViewResolver 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。\n4、view.render(mv.getModelInternal(), request, response);   视图对象调用自定义的render进行页面渲染工作\n\n\n\n\n\n\n\nRedirectView 如何渲染【重定向到一个页面】\n1、获取目标url地址\n\n\n\n\n\n\n\n\n\n2、&#x3D;&#x3D;response.sendRedirect(encodedURL);&#x3D;&#x3D;【servlet中最原生的重定向语法】\n\n\n\n\n\n\n\n\nHTTP状态码——302 理解 302 表示临时性重定向。 访问一个Url时,被重定向到另一个url上。 常用于页面跳转。\n视图解析：\n\n\n返回值以 forward: 开始： new InternalResourceView(forwardUrl); –&gt;  &#x3D;&#x3D;原生servlet转发：request.getRequestDispatcher(path 比如”&#x2F;“).forward(request, response);&#x3D;&#x3D;\n返回值以 redirect: 开始： new RedirectView() –》 render就是重定向\n\n\n\n返回值是普通字符串： new ThymeleafView（）—&gt;  process()\n\n\n\n作业：。。。\n自定义视图解析器+自定义视图； 大厂学院。\n比如：data–&gt;Excel表\n\n\n\n\n\n\n重定向 参数\n\n2、模板引擎-Thymeleaf（性能不高 不能高并发）1、thymeleaf简介Thymeleaf is a modern server-side Java template engine for both web and standalone environments, capable of processing HTML, XML, JavaScript, CSS and even plain text.\n现代化、服务端Java模板引擎\nhttps://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax\n2、基本语法1、表达式\n\n\n表达式名字\n语法\n用途\n\n\n\n变量取值\n${…}\n获取请求域、session域、对象等值\n\n\n选择变量\n*{…}\n获取上下文对象值\n\n\n消息\n#{…}\n获取国际化等值\n\n\n链接\n@{…}\n生成链接\n\n\n片段表达式\n~{…}\njsp:include 作用，【引入】【(已有的)公共页面片段】\n\n\n2、字面量文本值: ‘one text’ , ‘Another one!’ ,…数字: 0 , 34 , 3.0 , 12.3 ,…布尔值: true , false\n空值: null\n变量： one，two，…. 变量不能有空格\n3、文本操作字符串拼接: +\n变量替换: |The name is ${name}| \n4、数学运算运算符: + , - , * , &#x2F; , %\n5、布尔运算运算符:  and , or\n一元运算: ! , not \n6、比较运算比较: &gt; , &lt;** **,** **&gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le **)**等式: &#x3D;&#x3D; , !&#x3D; ( eq , ne ) \n7、条件运算If-then: (if) ? (then)\nIf-then-else: (if) ? (then) : (else)\nDefault: (value) ?: (defaultvalue) \n8、特殊操作无操作： _\n3、设置属性值-th:attr设置单个值\n&lt;form action&#x3D;&quot;subscribe.html&quot; th:attr&#x3D;&quot;action&#x3D;@&#123;&#x2F;subscribe&#125;&quot;&gt;\n  &lt;fieldset&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; &#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Subscribe!&quot; th:attr&#x3D;&quot;value&#x3D;#&#123;subscribe.submit&#125;&quot;&#x2F;&gt;\n  &lt;&#x2F;fieldset&gt;\n&lt;&#x2F;form&gt;\n\n设置多个值\n&lt;img src&#x3D;&quot;..&#x2F;..&#x2F;images&#x2F;gtvglogo.png&quot;  th:attr&#x3D;&quot;src&#x3D;@&#123;&#x2F;images&#x2F;gtvglogo.png&#125;,title&#x3D;#&#123;logo&#125;,alt&#x3D;#&#123;logo&#125;&quot; &#x2F;&gt;\n\n\n\n以上两个的&#x3D;&#x3D;代替写法 th:xxxx&#x3D;“#@…{}”    动态取值覆盖默认&#x3D;&#x3D;\n&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Subscribe!&quot; th:value&#x3D;&quot;#&#123;subscribe.submit&#125;&quot;&#x2F;&gt;\n&lt;form action&#x3D;&quot;subscribe.html&quot; th:action&#x3D;&quot;@&#123;&#x2F;subscribe&#125;&quot;&gt;\n\n\n\n所有h5兼容的标签写法\nhttps://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-value-to-specific-attributes\n4、迭代&lt;tr th:each&#x3D;&quot;prod : $&#123;prods&#125;&quot;&gt;\n        &lt;td th:text&#x3D;&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;&#x2F;td&gt;\n        &lt;td th:text&#x3D;&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;&#x2F;td&gt;\n        &lt;td th:text&#x3D;&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n\n\n\n&lt;tr th:each&#x3D;&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class&#x3D;&quot;$&#123;iterStat.odd&#125;? &#39;odd&#39;&quot;&gt;\n  &lt;td th:text&#x3D;&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;&#x2F;td&gt;\n  &lt;td th:text&#x3D;&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;&#x2F;td&gt;\n  &lt;td th:text&#x3D;&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n\n\n\n5、条件运算&lt;a href&#x3D;&quot;comments.html&quot;\nth:href&#x3D;&quot;@&#123;&#x2F;product&#x2F;comments(prodId&#x3D;$&#123;prod.id&#125;)&#125;&quot;\nth:if&#x3D;&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;&gt;view&lt;&#x2F;a&gt;\n\n\n\n&lt;div th:switch&#x3D;&quot;$&#123;user.role&#125;&quot;&gt;\n  &lt;p th:case&#x3D;&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;&#x2F;p&gt;\n  &lt;p th:case&#x3D;&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;&#x2F;p&gt;\n  &lt;p th:case&#x3D;&quot;*&quot;&gt;User is some other thing&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n\n\n6、属性优先级\n3、thymeleaf使用1、引入Starter&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2、自动配置好了thymeleaf@Configuration(proxyBeanMethods &#x3D; false)\n@EnableConfigurationProperties(ThymeleafProperties.class)\n@ConditionalOnClass(&#123; TemplateMode.class, SpringTemplateEngine.class &#125;)\n@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class &#125;)\npublic class ThymeleafAutoConfiguration &#123; &#125;&#x2F;&#x2F;\n\n\n\n自动配好的策略\n\n1、所有thymeleaf的配置值都在 ThymeleafProperties\n\n2、配置好了 SpringTemplateEngine \n\n3、配好了 ThymeleafViewResolver \n\n4、我们只需要直接开发页面\n\n\nThymeleafProperties:\n\tpublic static final String DEFAULT_PREFIX &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;\n\n\tpublic static final String DEFAULT_SUFFIX &#x3D; &quot;.html&quot;;  &#x2F;&#x2F;xxx.html\n\n\n\n3、页面开发【初体验 小试牛刀~】                域中$  th:要修改的属性&#x3D;””templates&#x2F;success.html:\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1 th:text&#x3D;&quot;$&#123;msg&#125;&quot;&gt;哈哈&lt;&#x2F;h1&gt;\n&lt;h2&gt;\n    &lt;a href&#x3D;&quot;www.atguigu.com&quot; th:href&#x3D;&quot;$&#123;link&#125;&quot;&gt;去百度&lt;&#x2F;a&gt;  &lt;br&#x2F;&gt;\n    &lt;a href&#x3D;&quot;www.atguigu.com&quot; th:href&#x3D;&quot;@&#123;&#x2F;link&#125;&quot;&gt;去百度[无效]&lt;&#x2F;a&gt; &lt;!--绝对路径   可动态+&#x2F;world...--&gt;\n    &lt;a href&#x3D;&quot;www.atguigu.com&quot; th:href&#x3D;&quot;@&#123;http:&#x2F;&#x2F;www.baidu.com&#125;&quot;&gt;去百度2&lt;&#x2F;a&gt;\n&lt;&#x2F;h2&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n        \n        \n        \n        \n@Controller&#x2F;&#x2F;!!!不是RestController!!!!\npublic class ViewTestController &#123;\n\n    @GetMapping(&quot;&#x2F;atguigu&quot;)\n    public String atguigu(Model model)&#123;\n\n        &#x2F;&#x2F;model中的数据会被放在请求域中 request.setAttribute(&quot;a&quot;,aa)\n        model.addAttribute(&quot;msg&quot;,&quot;你好 guigu&quot;);\n        model.addAttribute(&quot;link&quot;,&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);\n        return &quot;success&quot;;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n4、构建后台管理系统   boot-05-web-admin1、项目创建thymeleaf、web-starter、devtools、lombok\n2、静态资源处理自动配置好，我们只需要把所有静态资源放到 static 文件夹下\n3、路径构建html都要+：！！！！！！\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n\nth:action&#x3D;”@{&#x2F;login}”\nth:修改标签属性&#x3D;”${}”\n行内写法(修改纯文本)：&lt;&gt; [[${}]] &lt;&#x2F;&gt;\n\n抽取公共样式组件 common.html : css&#x2F; js &#x2F;left side&#x2F; header section\nth: @{} 动态化标签后，改了项目名也自动OK！！！\n4、模板抽取（8、 Template Layout）th:insert放整体 &#x2F;replace放内容+换标签 &#x2F;include只放内容\n    &lt;div th:include&#x3D;&quot;common :: commonheader&quot;&gt; &lt;&#x2F;div&gt;\n    \n\n    &lt;!-- left side start--&gt;\n    &lt;div th:replace&#x3D;&quot;common :: #leftmenu&quot;&gt; &lt;&#x2F;div&gt;\n    &lt;!-- left side end--&gt;\n    \n    &lt;!-- main content start--&gt;\n    &lt;div class&#x3D;&quot;main-content&quot; &gt;\n\n        &lt;!-- header section start--&gt;\n        &lt;div th:replace&#x3D;&quot;common :: headermenu&quot;&gt; &lt;&#x2F;div&gt;\n        &lt;!-- header section end--&gt;\n        ......\n      \n      \n&lt;!-- Placed js at the end of the document so the pages load faster --&gt;\n&lt;div th:replace&#x3D;&quot;common :: #commonscript&quot;&gt; &lt;&#x2F;div&gt;\n\n\n5、页面跳转&#x2F;&#x2F;+模板引擎thymeleaf后，如果需要跳转到指定的【页面】，需要使用@Controller注解和视图解析器InternalResourceViewResolver配合使用。   自动渲染String为页面\n&#x2F;&#x2F;如果我们在Controller方法中，需要返回JSON、XML，或者我们自己定义的类型到页面中，那么就需要使用【@ResponseBody注解该方法】。\n@Controller &#x2F;&#x2F;不能用@RestController!!!\npublic class IndexController &#123;\n\n    &#x2F;**\n     * 来登录页\n     * @return\n     *&#x2F;\n    @GetMapping(value &#x3D; &#123;&quot;&#x2F;&quot;, &quot;&#x2F;login&quot;&#125;)\n    public String loginPage() &#123;\n        return &quot;login&quot;;\n    &#125;\n\n    @PostMapping(&quot;&#x2F;login&quot;)\n    public String main(User user, HttpSession session, Model model)&#123;\n\n        if(StringUtils.hasLength(user.getUserName()) &amp;&amp; &quot;123456&quot;.equals(user.getPassWord()))&#123;\n            &#x2F;&#x2F;把登陆成功的用户保存起来\n            session.setAttribute(&quot;loginUser&quot;,user);\n            &#x2F;&#x2F;登录成功重定向到main.html;  重定向防止表单重复提交！！！\n            return &quot;redirect:&#x2F;main.html&quot;;\n        &#125;else &#123;\n            model.addAttribute(&quot;msg&quot;,&quot;账号密码错误&quot;);&#x2F;&#x2F;转发回login页\n            &#x2F;&#x2F;回到登录页面\n            return &quot;login&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 去main页面\n     * @return\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;main.html&quot;)\n    public String mainPage(HttpSession session, Model model)&#123;\n\n        &#x2F;&#x2F;是否登录，  拦截器，过滤器\n        Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;);\n        if(loginUser !&#x3D; null)&#123;\n            return &quot;main&quot;;\n        &#125; else &#123;\n            model.addAttribute(&quot;msg&quot;,&quot;请重新登录&quot;);&#x2F;&#x2F;转发回login页\n            &#x2F;&#x2F;回到登录页面\n            return &quot;login&quot;;\n        &#125;\n\n    &#125;\n\n\n&#125;\n\n\n\n\n\n6、数据渲染[表格内容]@Controller\npublic class TableController &#123;    \n\t@GetMapping(&quot;&#x2F;dynamic_table&quot;)\n    public String dynamic_table(Model model)&#123;\n        &#x2F;&#x2F;表格内容的遍历\n        List&lt;User&gt; users &#x3D; Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;),\n                new User(&quot;lisi&quot;, &quot;123444&quot;),\n                new User(&quot;haha&quot;, &quot;aaaaa&quot;),\n                new User(&quot;hehe &quot;, &quot;aaddd&quot;));\n        model.addAttribute(&quot;users&quot;,users);\n\n        return &quot;table&#x2F;dynamic_table&quot;;\n    &#125;\n...\n&#125;\n\n\n        &lt;table class&#x3D;&quot;display table table-bordered&quot; id&#x3D;&quot;hidden-table-info&quot;&gt;\n        &lt;thead&gt;\n        &lt;tr&gt;\n            &lt;th&gt;#&lt;&#x2F;th&gt;\n            &lt;th&gt;用户名&lt;&#x2F;th&gt;\n            &lt;th&gt;密码&lt;&#x2F;th&gt;\n        &lt;&#x2F;tr&gt;\n        &lt;&#x2F;thead&gt;\n        &lt;tbody&gt;\n        &lt;tr class&#x3D;&quot;gradeX&quot; th:each&#x3D;&quot;user,stats:$&#123;users&#125;&quot;&gt;\n            &lt;td th:text&#x3D;&quot;$&#123;stats.count&#125;&quot;&gt;Trident&lt;&#x2F;td&gt;\n            &lt;td th:text&#x3D;&quot;$&#123;user.userName&#125;&quot;&gt;Internet&lt;&#x2F;td&gt;\n            &lt;td &gt;[[$&#123;user.password&#125;]]&lt;&#x2F;td&gt;\n        &lt;&#x2F;tr&gt;\n        &lt;&#x2F;tbody&gt;\n        &lt;&#x2F;table&gt;\n\n\n\n[!]跨域CORS……ing6、拦截器1、HandlerInterceptor 接口 (Ctrl+F12) &#x3D;&#x3D;原生servlet转发：request.getRequestDispatcher(path 比如”&#x2F;“).forward(request, response);&#x3D;&#x3D;\n&#x2F;**\n * 登录检查\n * 1、配置好拦截器要拦截哪些请求\n * 2、把这些配置放在容器中\n *&#x2F;\n@Slf4j\npublic class LoginInterceptor implements HandlerInterceptor &#123;\n\n    &#x2F;**\n     * 目标方法执行之前\n     * @param request\n     * @param response\n     * @param handler\n     * @return\n     * @throws Exception\n     *&#x2F;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n\n        String requestURI &#x3D; request.getRequestURI();&#x2F;&#x2F;\n        log.info(&quot;preHandle拦截的请求路径是&#123;&#125;&quot;,requestURI);\n\n        &#x2F;&#x2F;登录检查逻辑\n        HttpSession session &#x3D; request.getSession();\n\n        Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;);\n\n        if(loginUser !&#x3D; null)&#123;\n            &#x2F;&#x2F;放行\n            return true;\n        &#125;\n\n        &#x2F;&#x2F;拦截住。未登录。跳转到登录页\n&#x2F;&#x2F;        session.setAttribute(&quot;msg&quot;,&quot;请先登录&quot;);\n&#x2F;&#x2F;        response.sendRedirect(&quot;&#x2F;&quot;);\n\n        &#x2F;&#x2F;请求域转发属性 可展示出来\n        request.setAttribute(&quot;msg&quot;,&quot;请先登录&quot;);\n&#x2F;&#x2F;        原生servlet请求域转发：request.getRequestDispatcher(path 比如&quot;&#x2F;&quot;).forward(request, response);\n        request.getRequestDispatcher(&quot;&#x2F;&quot;).forward(request,response);\n        return false;\n    &#125;\n\n    &#x2F;**\n     * 目标方法执行完成以后\n     * @param request\n     * @param response\n     * @param handler\n     * @param modelAndView\n     * @throws Exception\n     *&#x2F;\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        log.info(&quot;postHandle执行&#123;&#125;&quot;,modelAndView);&#x2F;&#x2F;\n    &#125;\n\n    &#x2F;**\n     * 页面渲染以后\n     * @param request\n     * @param response\n     * @param handler\n     * @param ex\n     * @throws Exception\n     *&#x2F;\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;,ex);&#x2F;&#x2F;\n    &#125;\n&#125;\n\n\n\n2、配置拦截器&#x2F;**\n * 1、编写一个拦截器实现HandlerInterceptor接口\n * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）\n * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】\n *&#x2F;\n@Configuration\npublic class AdminWebConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(&quot;&#x2F;**&quot;)  &#x2F;&#x2F;所有请求都被拦截包括静态资源\n                .excludePathPatterns(&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;,&quot;&#x2F;css&#x2F;**&quot;,&quot;&#x2F;fonts&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;,&quot;&#x2F;js&#x2F;**&quot;); &#x2F;&#x2F;放行的请求\n    &#125;\n&#125;\n\nIndexController：\n    &#x2F;**\n     * 去main页面\n     * @return\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;main.html&quot;)\n    public String mainPage(HttpSession session, Model model)&#123;\n\n        log.info(&quot;当前方法是：&#123;&#125;&quot;, &quot;mainPage&quot;);\n        &#x2F;&#x2F;是否登录，  拦截器，过滤器\n&#x2F;&#x2F;        Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;);\n&#x2F;&#x2F;        if(loginUser !&#x3D; null)&#123;\n&#x2F;&#x2F;            return &quot;main&quot;;\n&#x2F;&#x2F;        &#125; else &#123;\n&#x2F;&#x2F;            model.addAttribute(&quot;msg&quot;,&quot;请重新登录&quot;);&#x2F;&#x2F;转发回login页\n&#x2F;&#x2F;            &#x2F;&#x2F;回到登录页面\n&#x2F;&#x2F;            return &quot;login&quot;;\n&#x2F;&#x2F;        &#125;\n\n        return &quot;main&quot;;\n\n    &#125;\n\n\n\n登录后，main：\n\n3、拦截器原理1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有 拦截器】\n2、先来顺序执行 所有拦截器的 preHandle方法\n\n1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle\n2、如果当前拦截器返回为false。直接    倒序执行所有已经执行了的拦截器的  afterCompletion；\n\n\n3、如果任何一个拦截器返回false。直接return跳出不执行目标方法\n4、所有拦截器都返回True。执行目标方法\n5、倒序执行所有拦截器的postHandle方法。\n6、前面的步骤有任何异常都会直接倒序触发 afterCompletion\n7、页面成功渲染完成以后，也会倒序触发 afterCompletion\n\n\n7、文件上传1、页面表单&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;&#x2F;upload&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n\n\n2、文件上传代码@RequestPart(&quot;photos&quot;) MultipartFile[] photos\n\n    \n&lt;form role&#x3D;&quot;form&quot; th:action&#x3D;&quot;@&#123;&#x2F;upload&#125;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n                            &lt;div class&#x3D;&quot;form-group&quot;&gt;\n                                &lt;label for&#x3D;&quot;exampleInputEmail1&quot;&gt;邮箱&lt;&#x2F;label&gt;\n                                &lt;input type&#x3D;&quot;email&quot; name&#x3D;&quot;email&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;exampleInputEmail1&quot; placeholder&#x3D;&quot;Enter email&quot;&gt;\n                            &lt;&#x2F;div&gt;\n                            &lt;div class&#x3D;&quot;form-group&quot;&gt;\n                                &lt;label for&#x3D;&quot;exampleInputPassword1&quot;&gt;名字&lt;&#x2F;label&gt;\n                                &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;exampleInputPassword1&quot; placeholder&#x3D;&quot;Password&quot;&gt;\n                            &lt;&#x2F;div&gt;\n                            &lt;div class&#x3D;&quot;form-group&quot;&gt;\n                                &lt;label for&#x3D;&quot;exampleInputFile&quot;&gt;头像&lt;&#x2F;label&gt;\n                                &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;headerImg&quot; id&#x3D;&quot;exampleInputFile&quot;&gt;\n                                &lt;p class&#x3D;&quot;help-block&quot;&gt;Example block-level help text here.&lt;&#x2F;p&gt;\n                            &lt;&#x2F;div&gt;\n                            &lt;div class&#x3D;&quot;form-group&quot;&gt;\n                                &lt;label for&#x3D;&quot;exampleInputFile&quot;&gt;生活照&lt;&#x2F;label&gt;\n                                &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photos&quot; multiple&gt;\n                                &lt;p class&#x3D;&quot;help-block&quot;&gt;Example block-level help text here.&lt;&#x2F;p&gt;\n                            &lt;&#x2F;div&gt;\n                            &lt;div class&#x3D;&quot;checkbox&quot;&gt;\n                                &lt;label&gt;\n                                    &lt;input type&#x3D;&quot;checkbox&quot;&gt; Check me out\n                                &lt;&#x2F;label&gt;\n                            &lt;&#x2F;div&gt;\n                            &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-primary&quot;&gt;提交&lt;&#x2F;button&gt;\n                        &lt;&#x2F;form&gt;\n\n\n\n\n\n\n\n\n&#x2F;**\n * 文件上传测试\n *&#x2F;\n@Slf4j\n@Controller\npublic class FormTestController &#123;\n\n    @GetMapping(&quot;&#x2F;form_layouts&quot;)\n    public String form_layouts()&#123;\n        return &quot;form&#x2F;form_layouts&quot;;\n    &#125;\n\n    &#x2F;**\n     * MultipartFile 自动封装上传过来的文件\n     * @param email\n     * @param username\n     * @param headerImg\n     * @param photos\n     * @return\n     *&#x2F;\n    @PostMapping(&quot;&#x2F;upload&quot;)\n    public String upload(@RequestParam(&quot;email&quot;) String email,\n                         @RequestParam(&quot;username&quot;) String username,\n                         @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg,\n                         @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123;\n\n        log.info(&quot;上传的信息：email&#x3D;&#123;&#125;，username&#x3D;&#123;&#125;，headerImg&#x3D;&#123;&#125;，photos&#x3D;&#123;&#125;&quot;,\n                email,username,headerImg.getSize(),photos.length);\n\n        if(!headerImg.isEmpty())&#123;\n            &#x2F;&#x2F;保存到文件服务器，OSS服务器\n            String originalFilename &#x3D; headerImg.getOriginalFilename();\n            headerImg.transferTo(new File(&quot;F:\\\\cache\\\\&quot;+originalFilename));\n        &#125;\n\n        if(photos.length &gt; 0)&#123;\n            for (MultipartFile photo : photos) &#123;\n                if(!photo.isEmpty())&#123;\n                    String originalFilename &#x3D; photo.getOriginalFilename();\n                    photo.transferTo(new File(&quot;F:\\\\cache\\\\&quot;+originalFilename));\n                &#125;\n            &#125;\n        &#125;\n\n\n        return &quot;main&quot;;\n    &#125;\n&#125;\n\n\n\nspring.servlet.multipart.max-file-size&#x3D;10MB\nspring.servlet.multipart.max-request-size&#x3D;100MB\n\n\n\ndebug…doDispatcher打断点 点:提交\n3、自动配置原理**文件上传自动配置类-MultipartAutoConfiguration-**MultipartProperties\n\n自动配置好了 StandardServletMultipartResolver   【文件上传解析器】\n\n原理步骤\n\n\n1、checkMultipart: 请求进来使用文件上传解析器判断（isMultipart）并封装（resolveMultipart，返回MultipartHttpServletRequest）文件上传请求\n\n\n\n2、参数解析器来解析请求中的文件内容封装成MultipartFile\n\n\n\n\n3、将request中文件信息封装为一个Map；MultiValueMap&lt;String, MultipartFile&gt;\n\n\n\n\n\n\ntransferTo: FileCopyUtils.copy。实现文件流的拷贝\n@PostMapping(&quot;&#x2F;upload&quot;)\npublic String upload(@RequestParam(&quot;email&quot;) String email,\n                     @RequestParam(&quot;username&quot;) String username,\n                     @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg,\n                     @RequestPart(&quot;photos&quot;) MultipartFile[] photos)\n\n\n8、异常处理(7.1.11.Error Handling)https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-template-engines\n1、错误处理1、默认规则\n默认情况下，Spring Boot提供/error处理所有错误的映射\n\n对于机器客户端postman，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据\n\npostman模拟已登录：\n\n\n\n\n\n要对其进行自定义，添加**View**解析为**error**``** **\n\n要完全替换默认行为，可以实现 ErrorController 并注册该类型的Bean定义，或添加ErrorAttributes类型的组件以使用现有机制但替换其内容。\n\nerror&#x2F;下的4xx，5xx页面会被自动解析；\n\n\n\n\n\n\n&#96;&#96;&#96;@GetMapping(“&#x2F;basic_table”)public String basic_table() {\nint i = 10/0;// / by zero error\nreturn &quot;table/basic_table&quot;;\n\n}\n\n#### 2、定制错误处理逻辑\n\n- 自定义错误页\n\n- - error&#x2F;404.html   error&#x2F;5xx.html；有精确的错误状态码页面就&#x3D;&#x3D;匹配精确，没有就找 4xx.html；如果都没有就触发白页&#x3D;&#x3D;\n\n  - ![image-20211020173659945](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020173659945.png)\n\n  - ![image-20211020173723605](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020173723605.png)\n\n  - ![image-20211020173913613](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020173913613.png)\n\n  - &#96;&#96;&#96;java\n    &#x2F;**\n     *\n     * @param a  不带请求参数或者参数类型不对  400；Bad Request  一般都是浏览器的参数没有传递正确\n     * @return\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;basic_table&quot;)\n    public String basic_table(@RequestParam(&quot;a&quot;) int a)&#123;\n    \n        int i &#x3D; 10&#x2F;0;\n        return &quot;table&#x2F;basic_table&quot;;\n    &#125;\n\n\n\n\n\n@ControllerAdvice+@ExceptionHandler处理全局异常；底层是 ExceptionHandlerExceptionResolver 支持的\n\n/**\n * 处理整个web controller的异常\n */\n@Slf4j\n@ControllerAdvice\npublic class GlobalExceptionHandler &#123;\n\n    @ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;)  //处理异常\n    public String handleArithException(Exception e)&#123;\n\n        log.error(&quot;异常是：&#123;&#125;&quot;,e);\n        return &quot;login&quot;; //视图地址 or ModelAndView\n    &#125;\n&#125;\n\n- ![image-20211020184108688](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020184108688.png)\n\n- @ResponseStatus+自定义异常 ；底层是 **ResponseStatusExceptionResolver ，把responsestatus注解的信息底层调用** **response.sendError(statusCode, resolvedReason)；请求就结束了，mav&#x3D;null，tomcat发送的&#x2F;error**\n\n- &#96;&#96;&#96;java\n  @ResponseStatus(value&#x3D; HttpStatus.FORBIDDEN,reason &#x3D; &quot;用户数量太多&quot;)\n  public class UserTooManyException extends RuntimeException &#123;\n  \n      public  UserTooManyException()&#123;\n  \n      &#125;\n      public  UserTooManyException(String message)&#123;\n          super(message);\n      &#125;\n  &#125;\n  \n  \n      @GetMapping(&quot;&#x2F;dynamic_table&quot;)\n      public String dynamic_table(@RequestParam(value&#x3D;&quot;pn&quot;,defaultValue &#x3D; &quot;1&quot;) Integer pn,Model model)&#123;\n          &#x2F;&#x2F;表格内容的遍历\n  &#x2F;&#x2F;        response.sendError\n       List&lt;User&gt; users &#x3D; Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;),\n                  new User(&quot;lisi&quot;, &quot;123444&quot;),\n                  new User(&quot;haha&quot;, &quot;aaaaa&quot;),\n                  new User(&quot;hehe &quot;, &quot;aaddd&quot;));\n          model.addAttribute(&quot;users&quot;,users);\n  \n          if(users.size()&gt;3)&#123;\n              throw new UserTooManyException();\n          &#125;\n\n![image-20211020190326375](http://cache.itzy8.top/springboot2/image-20211020190326375.png)\n\n\n\n![image-20211020190400683](http://cache.itzy8.top/springboot2/image-20211020190400683.png)\n\n\nSpring底层的异常，如 参数类型转换异常；DefaultHandlerExceptionResolver 处理框架底层的异常。\n\n\n\n\n\n\nresponse.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage()); \ntomcat原生错误页：\n\n\n\n\n\n\n\n自定义实现 HandlerExceptionResolver 处理异常；可以作为默认的全局异常处理规则（Ordered.HIGHEST_PRECEDENCE）\n\n\n\n\n\n\n&#x2F;&#x2F;优先级，数字越小优先级越高 (否则，就被DefaultHandlerExceptionResolver处理了！) 最高，所有错误都成了他！\n@Order(value&#x3D; Ordered.HIGHEST_PRECEDENCE)    \n@Component\npublic class CustomerHandlerExceptionResolver implements HandlerExceptionResolver &#123;\n    @Override\n    public ModelAndView resolveException(HttpServletRequest request,\n                                         HttpServletResponse response,\n                                         Object handler, Exception ex) &#123;\n\n        try &#123;\n            response.sendError(511,&quot;我喜欢的错误&quot;);&#x2F;&#x2F;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return new ModelAndView();\n    &#125;\n&#125;\n\n\nErrorViewResolver  实现自定义处理异常；\n\nresponse.sendError 。error请求就会转给controller\n你的异常没有任何人能处理。tomcat底层 response.sendError。error请求就会转给controller\n\n\n\nbasicErrorController 要去的页面地址是 ErrorViewResolver 解析出的视图地址 ；\n\n\n\n3、异常处理自动配置原理\nautoconfig-servlet-error-ErrorMvcAutoConfiguration  自动配置异常处理规则\n\n\n容器中的组件1：类型：DefaultErrorAttributes -&gt; id：errorAttributes\n\n\n\n\npublic class &#x3D;&#x3D;DefaultErrorAttributes&#x3D;&#x3D; implements &#x3D;&#x3D;ErrorAttributes, HandlerExceptionResolver&#x3D;&#x3D;\nDefaultErrorAttributes：定义错误页面中可以&#x3D;&#x3D;包含哪些数据&#x3D;&#x3D;。\n\n\n\n\n\n\n\n\n\n\n\n\n\n容器中的组件2：&#x3D;&#x3D;类型：BasicErrorController –&gt; id：basicErrorController（json+白页 适配响应）&#x3D;&#x3D;\n\n\n\n\n处理默认 &#x2F;error 路径的请求；页面响应 new ModelAndView(“error”, model)；\n\n\n\n\n&#96;&#96;&#96;#server.error.path&#x3D;&#x2F;error\n    - ![image-20211020163434801](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020163434801.png)\n\n    - **容器中有组件 View**-&gt;**id是error**；&#x3D;&#x3D;（响应默认错误页）&#x3D;&#x3D;\n\n- - - 容器中放组件 **BeanNameViewResolver（视图解析器）；按照返回的视图名作为组件的id去容器中找View对象。**\n\n    - ![image-20211020163913132](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020163913132.png)\n\n      \n\n- - **容器中的组件3：**类型：**DefaultErrorViewResolver -&gt; id：**conventionErrorViewResolver\n\n- - - 如果发生错误，会以HTTP的状态码 作为&#x3D;&#x3D;视图页地址&#x3D;&#x3D;（viewName），找到真正的页面\n    - &#x3D;&#x3D;error&#x2F;404、5xx.html&#x3D;&#x3D;\n\n![image-20211020165114658](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020165114658.png)\n\n如果想要返回页面；就会找error视图【**StaticView**.render()】。(默认是一个白页)\n\n\n\nBasicErrorController :\n\n![img](https:&#x2F;&#x2F;cdn.nlark.com&#x2F;yuque&#x2F;0&#x2F;2020&#x2F;png&#x2F;1354552&#x2F;1606043870164-3770e116-344f-448e-8bff-8f32438edc9a.png?x-oss-process&#x3D;image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)写出去json\n\n![img](https:&#x2F;&#x2F;cdn.nlark.com&#x2F;yuque&#x2F;0&#x2F;2020&#x2F;png&#x2F;1354552&#x2F;1606043904074-50b7f088-2d2b-4da5-85e2-0a756da74dca.png?x-oss-process&#x3D;image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_35%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10) 错误页\n\n\n\n\n\n#### 4、异常处理步骤流程\n\n1、执行目标方法ha.handle()，目标方法运行期间有任何异常都会被catch、而且标志当前请求结束finally：webRequest.requestCompleted()  reqActive&#x3D;false；并且用 **dispatchException封装** \n\n2、进入视图解析流程（页面渲染？） \n\nprocessDispatchResult(processedRequest, response, mappedHandler, **mv**(null), **dispatchException**);\n\ninto\n\n3、**mv** &#x3D; **processHandlerException**；处理handler发生的异常，处理完成返回ModelAndView；\n\n- 1、遍历所有的 **handlerExceptionResolvers，看谁能处理当前异常【****HandlerExceptionResolver处理器异常解析器****】**\n- ![img](https:&#x2F;&#x2F;cdn.nlark.com&#x2F;yuque&#x2F;0&#x2F;2020&#x2F;png&#x2F;1354552&#x2F;1606047252166-ce71c3a1-0e0e-4499-90f4-6d80014ca19f.png?x-oss-process&#x3D;image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n- **2、系统默认的  异常解析器；**\n- ![img](https:&#x2F;&#x2F;cdn.nlark.com&#x2F;yuque&#x2F;0&#x2F;2020&#x2F;png&#x2F;1354552&#x2F;1606047109161-c68a46c1-202a-4db1-bbeb-23fcae49bbe9.png?x-oss-process&#x3D;image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n- @ExceptionHandler @ResponseStatus ...\n- - **1、DefaultErrorAttributes先来处理异常。把异常信息保存到request域，并且返回null；**\n  - ![image-20211020171418458](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020171418458.png)\n- **2、默认没有任何人能处理异常，所以异常会被抛出**\n- - **1、如果没有任何人能处理，最终底层就会&#x3D;&#x3D;发送 &#x2F;error 请求。会被底层的BasicErrorController处理&#x3D;&#x3D;【servlet规范】**\n  - ![image-20211020172349858](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020172349858.png)\n  - ![image-20211020172413003](http:&#x2F;&#x2F;cache.itzy8.top&#x2F;springboot2&#x2F;image-20211020172413003.png)\n    - **2、解析错误视图；遍历所有的**  **ErrorViewResolver  看谁能解析。**\n- - - ![img](https:&#x2F;&#x2F;cdn.nlark.com&#x2F;yuque&#x2F;0&#x2F;2020&#x2F;png&#x2F;1354552&#x2F;1606047900473-e31c1dc3-7a5f-4f70-97de-5203429781fa.png?x-oss-process&#x3D;image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n    - **3、默认的** **DefaultErrorViewResolver ,作用是把响应状态码作为错误页的地址，error&#x2F;500.html** \n- - - **4、模板引擎最终响应这个页面** **error&#x2F;500.html** \n\n\n\n\n\n# 9、Web原生组件注入（Servlet、Filter、Listener）7.4.1\n\n## 1、使用Servlet API\n\nboot入口主程序：@ServletComponentScan(basePackages &#x3D; **&quot;com.atguigu.admin&quot;**) :指定原生Servlet组件都放在哪个包里\n\n\n\n@WebServlet(urlPatterns &#x3D; **&quot;&#x2F;my&quot;**)：效果：直接响应，**没有经过Spring的拦截器？**\n\n@WebFilter(urlPatterns&#x3D;&#123;**&quot;&#x2F;css&#x2F;\\*&quot;**,**&quot;&#x2F;images&#x2F;\\*&quot;**&#125;)                    &#x2F;*:servlet   &#x2F;**:Spring\n\n@WebListener\n\n\n\n\n\n\n\n扩展：DispatchServlet 如何注册进来\n\n- 容器中自动配置了  DispatcherServlet  属性绑定到 WebMvcProperties；对应的配置文件配置项是 **spring.mvc。**\n\n- **通过** **ServletRegistrationBean**&lt;DispatcherServlet&gt; 把 DispatcherServlet  配置进来。\n\n- 默认映射的是 &#x2F; 路径。\n\n- &#96;&#96;&#96;\n  #spring.mvc.servlet.path&#x3D;&#x2F;mvc&#x2F;\n\n\n\n\n\n\nTomcat-Servlet；\n多个Servlet都能处理到同一层路径，精确优选原则\nA： &#x2F;my&#x2F;\nB： &#x2F;my&#x2F;1\n2、使用RegistrationBean(推荐)ServletRegistrationBean, FilterRegistrationBean, and ServletListenerRegistrationBean\n&#x2F;**\n * 1、MyServlet --&gt; &#x2F;my\n * 2、DispatcherServlet --&gt; &#x2F;\n *&#x2F;\n@Configuration(proxyBeanMethods &#x3D; true)&#x2F;&#x2F;保证依赖的组件始终是单实例的!!!\npublic class MyRegistConfig &#123;\n\n    @Bean\n    public ServletRegistrationBean myServlet()&#123;\n        MyServlet myServlet &#x3D; new MyServlet();\n\n        return new ServletRegistrationBean(myServlet,&quot;&#x2F;my&quot;,&quot;&#x2F;my02&quot;);\n    &#125;\n\n\n    @Bean\n    public FilterRegistrationBean myFilter()&#123;\n\n        MyFilter myFilter &#x3D; new MyFilter();\n&#x2F;&#x2F;        return new FilterRegistrationBean(myFilter,myServlet()); &#x2F;&#x2F; 拦截&quot;&#x2F;my&quot;,&quot;&#x2F;my02&quot;     myServlet单实例！！！\n        FilterRegistrationBean filterRegistrationBean &#x3D; new FilterRegistrationBean(myFilter);\n        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;&#x2F;my&quot;,&quot;&#x2F;css&#x2F;*&quot;));\n        return filterRegistrationBean;\n    &#125;\n\n    @Bean\n    public ServletListenerRegistrationBean myListener()&#123;\n        MyServletContextListener myServletContextListener &#x3D; new MyServletContextListener();\n        return new ServletListenerRegistrationBean(myServletContextListener);\n    &#125;\n&#125;\n\n\n\n10、嵌入式Servlet容器(7.4.3)1、切换嵌入式Servlet容器\n默认支持的webServer\n\n\nTomcat, Jetty, or Undertow\nServletWebServerApplicationContext Ioc容器启动寻找ServletWebServerFactory 并引导创建服务器\n\n\n切换服务器\n\n\n\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n\n\n原理\n\n\nSpringBoot应用启动发现当前是Web应用。web场景包-导入tomcat\nweb应用会创建一个web版的ioc容器 ServletWebServerApplicationContext\n\n\n\nServletWebServerApplicationContext 启动的时候寻找 ServletWebServerFactory``（Servlet 的web服务器工厂---&gt; Servlet 的web服务器） \nSpringBoot底层默认有很多的WebServer工厂；TomcatServletWebServerFactory, JettyServletWebServerFactory, or UndertowServletWebServerFactory\n\n\n\n底层直接会有一个自动配置类。ServletWebServerFactoryAutoConfiguration\nServletWebServerFactoryAutoConfiguration导入了ServletWebServerFactoryConfiguration（配置类）\n\n\n\nServletWebServerFactoryConfiguration 配置类 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有 TomcatServletWebServerFactory\nTomcatServletWebServerFactory 创建出Tomcat服务器并启动；TomcatWebServer 的构造器拥有初始化方法initialize---this.tomcat.start();\n\n\n\n内嵌服务器，就是手动把启动服务器的代码调用（tomcat核心jar包存在）\n\n\n&#96;&#96;\n\n\n2、定制Servlet容器 7.4.4\n实现  WebServerFactoryCustomizer \n\n\n把配置文件的值和ServletWebServerFactory 进行绑定\n\n\n\n&#x3D;&#x3D;修改配置文件 server.xxx&#x3D;&#x3D;\n#server.servlet.session.timeout&#x3D;60m\n#server.undertow.accesslog.dir&#x3D;&#x2F;tmp\n\n直接自定义 ConfigurableServletWebServerFactory\n\n\nxxxxxCustomize：定制化器，可以改变xxxx的默认规则\nimport org.springframework.boot.web.server.WebServerFactoryCustomizer;\nimport org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123;\n\n    @Override\n    public void customize(ConfigurableServletWebServerFactory server) &#123;\n        server.setPort(9000);\n    &#125;\n\n&#125;\n\n\n\n11、定制化原理【&#x3D;&#x3D;Boot精髓！&#x3D;&#x3D;】1、定制化的常见方式\n修&#x3D;&#x3D;改配置文件&#x3D;&#x3D;；\n\nxxxxxCustomizer；\n\n编&#x3D;&#x3D;写自定义的配置类   xxxConfiguration；+ @Bean&#x3D;&#x3D;替换、增加(视图解析器) 容器中默认组件； \n\n&#x3D;&#x3D;Web应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能；+ @Bean给容器中再扩展一些组件&#x3D;&#x3D;\n\n\n&#x2F;**\n * 1、编写一个拦截器实现HandlerInterceptor接口\n * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）\n * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】\n *\n * @EnableWebMvc:全面接管\n *      1、静态资源？视图解析器？欢迎页.....全部失效!\n *&#x2F;\n&#x2F;&#x2F;@EnableWebMvc\n@Configuration\npublic class AdminWebConfig implements WebMvcConfigurer&#123;\n\n\n    &#x2F;**\n     * Filter、Interceptor 几乎拥有相同的功能？\n     * 1、Filter是Servlet定义的原生组件。好处，脱离Spring应用也能使用\n     * 2、Interceptor是Spring定义的接口。可以使用Spring的自动装配等功能\n     *\n     *&#x2F;\n&#x2F;&#x2F;    @Autowired\n&#x2F;&#x2F;    RedisUrlCountInterceptor redisUrlCountInterceptor;\n\n    &#x2F;**\n     * 定义静态资源行为\n     * @param registry\n     *&#x2F;\n&#x2F;&#x2F;    @Override\n&#x2F;&#x2F;    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n&#x2F;&#x2F;        &#x2F;**\n&#x2F;&#x2F;         * 访问  &#x2F;aa&#x2F;** 所有请求都去 classpath:&#x2F;static&#x2F; 下面进行匹配\n&#x2F;&#x2F;         *&#x2F;\n&#x2F;&#x2F;        registry.addResourceHandler(&quot;&#x2F;aa&#x2F;**&quot;)\n&#x2F;&#x2F;                .addResourceLocations(&quot;classpath:&#x2F;static&#x2F;&quot;); &#x2F;&#x2F;前缀 与 路径目录\n&#x2F;&#x2F;    &#125;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(&quot;&#x2F;**&quot;)  &#x2F;&#x2F;所有请求都被拦截包括静态资源\n                .excludePathPatterns(&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;,&quot;&#x2F;css&#x2F;**&quot;,&quot;&#x2F;fonts&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;,\n                        &quot;&#x2F;js&#x2F;**&quot;,&quot;&#x2F;aa&#x2F;**&quot;); &#x2F;&#x2F;放行的请求\n\n&#x2F;&#x2F;        registry.addInterceptor(redisUrlCountInterceptor)\n&#x2F;&#x2F;                .addPathPatterns(&quot;&#x2F;**&quot;)\n&#x2F;&#x2F;                .excludePathPatterns(&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;,&quot;&#x2F;css&#x2F;**&quot;,&quot;&#x2F;fonts&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;,\n&#x2F;&#x2F;                        &quot;&#x2F;js&#x2F;**&quot;,&quot;&#x2F;aa&#x2F;**&quot;);\n    &#125;\n\n&#x2F;&#x2F;    @Bean\n&#x2F;&#x2F;    public WebMvcRegistrations webMvcRegistrations()&#123;\n&#x2F;&#x2F;        return new WebMvcRegistrations()&#123;\n&#x2F;&#x2F;            @Override\n&#x2F;&#x2F;            public RequestMappingHandlerMapping getRequestMappingHandlerMapping() &#123;\n&#x2F;&#x2F;                return null;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;        &#125;;\n&#x2F;&#x2F;    &#125;\n\n    &#x2F;&#x2F;\n&#125;\n\n\n过于底层……:\n\n@EnableWebMvc + WebMvcConfigurer —— @Bean  可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能\n\n原理\n1、WebMvcAutoConfiguration  默认的SpringMVC的自动配置功能类。静态资源、欢迎页…..\n\n\n\n2、一旦使用 @EnableWebMvc，会 @Import(DelegatingWebMvcConfiguration.class)\n3、DelegatingWebMvcConfiguration 的 作用，只保证SpringMVC最基本的使用\n\n\n\n\n把所有系统中的 WebMvcConfigurer s 拿过来。所有功能的定制都是这些 WebMvcConfigurer s 合起来一起生效\n自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取\n\n\n\n\n\n\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport【有】\n\n\n\n\n\n4、WebMvcAutoConfiguration 里面的配置要能生效 必须：  【无】@ConditionalOn&#x3D;&#x3D;Missing&#x3D;&#x3D;Bean(WebMvcConfigurationSupport.class)\n5、@EnableWebMvc  导致了 WebMvcAutoConfiguration  没有生效。【全面接管】\n\n\n… …\n\n2、原理分析&#x3D;&#x3D;套路&#x3D;&#x3D;&#x3D;&#x3D;场景starter&#x3D;&#x3D; - xxxxAutoConfiguration - @Bean…导入xxx组件 - 绑定xxxProperties – &#x3D;&#x3D;绑定配置文件项&#x3D;&#x3D; \n06、数据访问1、SQL1、数据源的自动配置-HikariDataSource1、导入JDBC场景&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n数据库驱动？\n为什么导入JDBC场景，官方不导入驱动？官方不知道我们接下要操作什么数据库。\n数据库版本和驱动版本对应\n默认版本：&lt;mysql.version&gt;8.0.22&lt;&#x2F;mysql.version&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n&lt;!--            &lt;version&gt;5.1.49&lt;&#x2F;version&gt;--&gt;\n        &lt;&#x2F;dependency&gt;\n想要修改版本\n1、直接依赖引入具体版本（maven的就近依赖原则）\n2、重新声明版本（maven的属性的就近优先原则）\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n        &lt;mysql.version&gt;5.1.49&lt;&#x2F;mysql.version&gt;\n    &lt;&#x2F;properties&gt;\n\nMysql5.5命令行修改密码 5.5初始无密码，直接Entermysql -uroot -p\nuse mysql;\nupdate user set password&#x3D;password(“123456”) where user&#x3D;”root”;\nflush privileges;\nquit\n5.7后随机默认密码在&#x2F;data .err 里\nsqlyog\n2、分析自动配置1、自动配置的类\nDataSourceAutoConfiguration ： 数据源的自动配置\n\n\n修改数据源相关的配置：spring.datasource\n数据库连接池的配置，是自己容器中没有DataSource才自动配置的\n\n\n\n底层配置好的连接池是：HikariDataSource\n\n\n\n@Configuration(proxyBeanMethods &#x3D; false)\n@Conditional(PooledDataSourceCondition.class)\n@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)\n@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,\n\t\tDataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,\n\t\tDataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;)\nprotected static class PooledDataSourceConfiguration\n\n\n\n\nDataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置\n\nJdbcTemplateAutoConfiguration： JdbcTemplate的自动配置，可以来对数据库进行crud\n\n\n可以修改这个配置项@ConfigurationProperties(prefix &#x3D; “spring.jdbc”) 来修改JdbcTemplate\n@Bean@Primary    JdbcTemplate；容器中有这个组件\n\n\nJndiDataSourceAutoConfiguration： jndi的自动配置\n\nXADataSourceAutoConfiguration： 分布式事务相关的\n\n\n3、修改配置项spring:\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_account\n    username: root\n    password: 123456\n    driver-class-name: com.mysql.jdbc.Driver\n\n\n\n\n\n4、测试@Slf4j\n@SpringBootTest\nclass Boot05WebAdminApplicationTests &#123;\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n\n    @Test\n    void contextLoads() &#123;\n\n&#x2F;&#x2F;        jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)\n&#x2F;&#x2F;        jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,)\n        Long aLong &#x3D; jdbcTemplate.queryForObject(&quot;select count(*) from account_tbl&quot;, Long.class);\n        log.info(&quot;记录总数：&#123;&#125;&quot;,aLong);\n    &#125;\n\n&#125;\n\n2、使用Druid数据源1、druid官方github地址https://github.com/alibaba/druid\n整合第三方技术的两种方式\n\n自定义\n找starter\n\n2、自定义方式1、创建数据源        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.1.17&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;\n\t\tdestroy-method&#x3D;&quot;close&quot;&gt;\n\t\t&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;20&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;initialSize&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;maxWait&quot; value&#x3D;&quot;60000&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;minIdle&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;timeBetweenEvictionRunsMillis&quot; value&#x3D;&quot;60000&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;minEvictableIdleTimeMillis&quot; value&#x3D;&quot;300000&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;testWhileIdle&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;testOnBorrow&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;testOnReturn&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;poolPreparedStatements&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;maxOpenPreparedStatements&quot; value&#x3D;&quot;20&quot; &#x2F;&gt;\n\n\n\n2、StatViewServletStatViewServlet的用途包括：\n\n提供监控信息展示的html页面\n提供监控信息的JSON API\n\n&lt;servlet&gt;\n\t&lt;servlet-name&gt;DruidStatView&lt;&#x2F;servlet-name&gt;\n\t&lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n&lt;servlet-mapping&gt;\n\t&lt;servlet-name&gt;DruidStatView&lt;&#x2F;servlet-name&gt;\n\t&lt;url-pattern&gt;&#x2F;druid&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\n\n\n3、StatFilter用于统计监控信息；如SQL监控、URI监控\n需要给数据源中配置如下属性；可以允许多个filter，多个用，分割；如：\n\n&lt;property name&#x3D;&quot;filters&quot; value&#x3D;&quot;stat,slf4j&quot; &#x2F;&gt;\n\n系统中所有filter：\n\n\n\n别名\nFilter类名\n\n\n\ndefault\ncom.alibaba.druid.filter.stat.StatFilter\n\n\nstat\ncom.alibaba.druid.filter.stat.StatFilter\n\n\nmergeStat\ncom.alibaba.druid.filter.stat.MergeStatFilter\n\n\nencoding\ncom.alibaba.druid.filter.encoding.EncodingConvertFilter\n\n\nlog4j\ncom.alibaba.druid.filter.logging.Log4jFilter\n\n\nlog4j2\ncom.alibaba.druid.filter.logging.Log4j2Filter\n\n\nslf4j\ncom.alibaba.druid.filter.logging.Slf4jLogFilter\n\n\ncommonlogging\ncom.alibaba.druid.filter.logging.CommonsLogFilter\n\n\n慢SQL记录配置\n&lt;bean id&#x3D;&quot;stat-filter&quot; class&#x3D;&quot;com.alibaba.druid.filter.stat.StatFilter&quot;&gt;\n    &lt;property name&#x3D;&quot;slowSqlMillis&quot; value&#x3D;&quot;10000&quot; &#x2F;&gt;\n    &lt;property name&#x3D;&quot;logSlowSql&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n使用 slowSqlMillis 定义慢SQL的时长\n\n3、使用官方starter方式1、引入druid-starter&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.1.17&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n2、分析自动配置\n扩展配置项 spring.datasource.druid\n\nDruidSpringAopConfiguration.class,   监控SpringBean的；配置项：spring.datasource.druid.aop-patterns\n\nDruidStatViewServletConfiguration.class, 监控页的配置：spring.datasource.druid.stat-view-servlet；默认开启\n\nDruidWebStatFilterConfiguration.class, web监控配置；spring.datasource.druid.web-stat-filter；默认开启\n\nDruidFilterConfiguration.class}) 所有Druid自己filter的配置\n\n\nprivate static final String FILTER_STAT_PREFIX &#x3D; &quot;spring.datasource.druid.filter.stat&quot;;\nprivate static final String FILTER_CONFIG_PREFIX &#x3D; &quot;spring.datasource.druid.filter.config&quot;;\nprivate static final String FILTER_ENCODING_PREFIX &#x3D; &quot;spring.datasource.druid.filter.encoding&quot;;\nprivate static final String FILTER_SLF4J_PREFIX &#x3D; &quot;spring.datasource.druid.filter.slf4j&quot;;\nprivate static final String FILTER_LOG4J_PREFIX &#x3D; &quot;spring.datasource.druid.filter.log4j&quot;;\nprivate static final String FILTER_LOG4J2_PREFIX &#x3D; &quot;spring.datasource.druid.filter.log4j2&quot;;\nprivate static final String FILTER_COMMONS_LOG_PREFIX &#x3D; &quot;spring.datasource.druid.filter.commons-log&quot;;\nprivate static final String FILTER_WALL_PREFIX &#x3D; &quot;spring.datasource.druid.filter.wall&quot;;\n\n\n\n3、配置示例spring:\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db_account\n    username: root\n    password: 123456\n    driver-class-name: com.mysql.jdbc.Driver\n\n    druid:\n      aop-patterns: com.atguigu.admin.*  #监控SpringBean\n      filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）\n\n      stat-view-servlet:   # 配置监控页功能\n        enabled: true\n        login-username: admin\n        login-password: admin\n        resetEnable: false\n\n      web-stat-filter:  # 监控web\n        enabled: true\n        urlPattern: &#x2F;*\n        exclusions: &#39;*.js,*.gif,*.jpg,*.png,*.css,*.ico,&#x2F;druid&#x2F;*&#39;\n\n\n      filter:\n        stat:    # 对上面filters里面的stat的详细配置\n          slow-sql-millis: 1000\n          logSlowSql: true\n          enabled: true\n        wall:\n          enabled: true\n          config:\n            drop-table-allow: false\n\nSpringBoot配置示例\nhttps://github.com/alibaba/druid/tree/master/druid-spring-boot-starter\n配置项列表https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8\n3、整合MyBatis操作https://github.com/mybatis\nstarter\nSpringBoot官方的Starter：spring-boot-starter-*\n第三方的： *-spring-boot-starter\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.1.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n1、配置模式\n全局配置文件\n\nSqlSessionFactory: 自动配置好了\n\nSqlSession：自动配置了 SqlSessionTemplate 组合了SqlSession\n\n@Import(AutoConfiguredMapperScannerRegistrar.class）；\n\nMapper： 只要我们写的操作MyBatis的接口标准了 @Mapper 就会被自动扫描进来\n\n\n@EnableConfigurationProperties(MybatisProperties.class) ： MyBatis配置项绑定类。\n@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)\npublic class MybatisAutoConfiguration&#123;&#125;\n\n@ConfigurationProperties(prefix &#x3D; &quot;mybatis&quot;)\npublic class MybatisProperties\n\n可以修改配置文件中 mybatis 开始的所有；\n# 配置mybatis规则\nmybatis:\n  config-location: classpath:mybatis&#x2F;mybatis-config.xml  #全局配置文件位置\n  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml  #sql映射文件位置\n  \nMapper接口---&gt;绑定Xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;com.atguigu.admin.mapper.AccountMapper&quot;&gt;\n&lt;!--    public Account getAcct(Long id); --&gt;\n    &lt;select id&#x3D;&quot;getAcct&quot; resultType&#x3D;&quot;com.atguigu.admin.bean.Account&quot;&gt;\n        select * from  account_tbl where  id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n\n\n\n配置 private Configuration configuration; mybatis.configuration下面的所有，就是相当于改mybatis全局配置文件中的值\n\n# 配置mybatis规则\nmybatis:\n#  config-location: classpath:mybatis&#x2F;mybatis-config.xml\n  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml\n  configuration:\n    map-underscore-to-camel-case: true\n    \n 可以不写xml全局配置文件，所有全局配置文件的配置都放在configuration配置项中即可\n\n\n\n\n\n\n导入mybatis官方starter\n\n编写mapper接口。标准@Mapper注解\n\n编写sql映射文件并绑定mapper接口\n\n在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息 （建议；配置在mybatis.configuration）\n\n\n2、注解模式@Mapper\npublic interface CityMapper &#123;\n\n    @Select(&quot;select * from city where id&#x3D;#&#123;id&#125;&quot;)\n    public City getById(Long id);\n\n    public void insert(City city);\n\n&#125;\n\n\n3、混合模式@Mapper\npublic interface CityMapper &#123;\n\n    @Select(&quot;select * from city where id&#x3D;#&#123;id&#125;&quot;)\n    public City getById(Long id);\n\n    public void insert(City city);\n\n&#125;\n\ncityMapper.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;com.alex.admin.mapper.CityMapper&quot;&gt;\n\n&lt;!--    public void insert(City city);--&gt;\n    &lt;insert id&#x3D;&quot;insert&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;\n        insert into  city(&#96;name&#96;,&#96;state&#96;,&#96;country&#96;) values(#&#123;name&#125;,#&#123;state&#125;,#&#123;country&#125;)\n    &lt;&#x2F;insert&gt;\n\n&lt;&#x2F;mapper&gt;\n\n改为写Mapper：\n@Mapper\npublic interface CityMapper &#123;\n\n    @Select(&quot;select * from city where id&#x3D;#&#123;id&#125;&quot;)\n    public City getById(Long id);\n\n\n    @Insert(&quot;insert into  city(&#96;name&#96;,&#96;state&#96;,&#96;country&#96;) values(#&#123;name&#125;,#&#123;state&#125;,#&#123;country&#125;)&quot;)\n    @Options(useGeneratedKeys &#x3D; true,keyProperty &#x3D; &quot;id&quot;)\n    public void insert(City city);\n\n&#125;\n\n\n\n登录,copy  JSESSIONID    或放行&#x2F;city\n\n最佳实战：\n\n引入mybatis-starter\n\n配置application.yaml中，指定mapper-location位置即可\n\n编写Mapper接口并标注@Mapper注解\n\n简单方法直接注解方式\n\n复杂方法编写mapper.xml进行绑定映射\n\n主程序@MapperScan(“com.atguigu.admin.mapper”) 简化，其他的接口就可以不用标注@Mapper注解\n\n\n4、整合 MyBatis-Plus 完成CRUD1、什么是MyBatis-PlusMyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\nmybatis plus 官网\n建议安装 MybatisX 插件 \n2、整合MyBatis-Plus&lt;dependency&gt;\n    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n自动配置\n\nMybatisPlusAutoConfiguration 配置类，MybatisPlusProperties 配置项绑定。**&#x3D;&#x3D;mybatis-plus：&#x3D;&#x3D;xxx 就是对**mybatis-plus的定制\n\nSqlSessionFactory 自动配置好。底层是容器中默认的数据源\n\n*mapperLocations 自动配置好的。有默认值。classpath*:&#x2F;mapper&#x2F;*&#x2F;*.xml；任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。  &#x3D;&#x3D;建议以后sql映射文件，放在 mapper下&#x3D;&#x3D;\n\n容器中也自动配置好了 SqlSessionTemplate\n\n@Mapper 标注的接口也会被自动扫描；建议直接 &#x3D;&#x3D;@MapperScan(“com.atguigu.admin.mapper”)&#x3D;&#x3D;批量扫描就行\n\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@TableName(&quot;user_tbl&quot;)\npublic class User &#123;\n\n    &#x2F;**\n     * 所有属性都应该在数据库中\n     *&#x2F;\n    @TableField(exist &#x3D; false)  &#x2F;&#x2F;当前属性表中不存在\n    private String userName;\n    @TableField(exist &#x3D; false)\n    private String password;\n\n\n    &#x2F;&#x2F;以下是数据库字段\n    private Long id;\n    private String name;\n    private Integer age;\n    private String email;\n\n\n&#125;\n\n优点：\n\n只需要我们的Mapper继承 BaseMapper 就可以拥有crud能力\n\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;\n\n\n\n\n\n3、CRUD功能dynamic_table.html        ctrl+alt+L:格式化\n    @GetMapping(&quot;&#x2F;user&#x2F;delete&#x2F;&#123;id&#125;&quot;)\n    public String deleteUser(@PathVariable(&quot;id&quot;) Long id,\n                             @RequestParam(value &#x3D; &quot;pn&quot;,defaultValue &#x3D; &quot;1&quot;)Integer pn,\n                             RedirectAttributes ra)&#123;\n\n        userService.removeById(id);\n\n        ra.addAttribute(&quot;pn&quot;,pn);\n        return &quot;redirect:&#x2F;dynamic_table&quot;;\n    &#125;\n\n\n    @GetMapping(&quot;&#x2F;dynamic_table&quot;)\n    public String dynamic_table(@RequestParam(value&#x3D;&quot;pn&quot;,defaultValue &#x3D; &quot;1&quot;) Integer pn,Model model)&#123;\n        &#x2F;&#x2F;表格内容的遍历\n&#x2F;&#x2F;        response.sendError\n&#x2F;&#x2F;     List&lt;User&gt; users &#x3D; Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;),\n&#x2F;&#x2F;                new User(&quot;lisi&quot;, &quot;123444&quot;),\n&#x2F;&#x2F;                new User(&quot;haha&quot;, &quot;aaaaa&quot;),\n&#x2F;&#x2F;                new User(&quot;hehe &quot;, &quot;aaddd&quot;));\n&#x2F;&#x2F;        model.addAttribute(&quot;users&quot;,users);\n&#x2F;&#x2F;\n&#x2F;&#x2F;        if(users.size()&gt;3)&#123;\n&#x2F;&#x2F;            throw new UserTooManyException();\n&#x2F;&#x2F;        &#125;\n        &#x2F;&#x2F;从数据库中查出user表中的用户进行展示\n\n        &#x2F;&#x2F;构造分页参数\n        Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(pn, 2);\n        &#x2F;&#x2F;调用page进行分页\n        Page&lt;User&gt; userPage &#x3D; userService.page(page, null);\n\n\n&#x2F;&#x2F;        userPage.getRecords()\n&#x2F;&#x2F;        userPage.getCurrent()\n&#x2F;&#x2F;        userPage.getPages()\n\n\n        model.addAttribute(&quot;users&quot;,userPage);\n\n        return &quot;table&#x2F;dynamic_table&quot;;\n    &#125;\n\n\n\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;\n\n\n&#125;\n\npublic interface UserService extends IService&lt;User&gt; &#123;\n\n&#125;\n\n分页插件\n@Configuration\npublic class MyBatisConfig &#123;\n\n\n    &#x2F;**\n     * MybatisPlusInterceptor\n     * @return\n     *&#x2F;\n    @Bean\n    public MybatisPlusInterceptor paginationInterceptor() &#123;\n        MybatisPlusInterceptor mybatisPlusInterceptor &#x3D; new MybatisPlusInterceptor();\n        &#x2F;&#x2F; 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false\n        &#x2F;&#x2F; paginationInterceptor.setOverflow(false);\n        &#x2F;&#x2F; 设置最大单页限制数量，默认 500 条，-1 不受限制\n        &#x2F;&#x2F; paginationInterceptor.setLimit(500);\n        &#x2F;&#x2F; 开启 count 的 join 优化,只针对部分 left join\n\n        &#x2F;&#x2F;这是分页拦截器\n        PaginationInnerInterceptor paginationInnerInterceptor &#x3D; new PaginationInnerInterceptor();\n        paginationInnerInterceptor.setOverflow(true);\n        paginationInnerInterceptor.setMaxLimit(500L);\n        mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor);\n\n        return mybatisPlusInterceptor;\n    &#125;\n&#125;\n\n\n\n\n\ndynamic_table.html 动态分页实现：\n&lt;table class&#x3D;&quot;display table table-bordered table-striped&quot; id&#x3D;&quot;dynamic-table&quot;&gt;\n                                    &lt;thead&gt;\n                                    &lt;tr&gt;\n                                        &lt;th&gt;#&lt;&#x2F;th&gt;\n                                        &lt;th&gt;name&lt;&#x2F;th&gt;\n                                        &lt;th&gt;age&lt;&#x2F;th&gt;\n                                        &lt;th&gt;email&lt;&#x2F;th&gt;\n                                        &lt;th&gt;操作&lt;&#x2F;th&gt;\n                                    &lt;&#x2F;tr&gt;\n                                    &lt;&#x2F;thead&gt;\n                                    &lt;tbody&gt;\n                                    &lt;tr class&#x3D;&quot;gradeX&quot; th:each&#x3D;&quot;user,stat: $&#123;users.records&#125;&quot;&gt;\n                                        &lt;td th:text&#x3D;&quot;$&#123;stat.count&#125;&quot;&gt;&lt;&#x2F;td&gt;\n\n                                        &lt;td th:text&#x3D;&quot;$&#123;user.id&#125;&quot;&gt;&lt;&#x2F;td&gt;\n                                        &lt;td&gt;[[$&#123;user.name&#125;]]&lt;&#x2F;td&gt;\n                                        &lt;td th:text&#x3D;&quot;$&#123;user.age&#125;&quot;&gt;Win 95+&lt;&#x2F;td&gt;\n                                        &lt;td th:text&#x3D;&quot;$&#123;user.email&#125;&quot;&gt;4&lt;&#x2F;td&gt;\n                                        &lt;td&gt;\n                                            &lt;a th:href&#x3D;&quot;@&#123;&#x2F;user&#x2F;delete&#x2F;&#123;id&#125;(id&#x3D;$&#123;user.id&#125;,pn&#x3D;$&#123;users.current&#125;)&#125;&quot;\n                                               class&#x3D;&quot;btn btn-danger btn-sm&quot; type&#x3D;&quot;button&quot;&gt;删除&lt;&#x2F;a&gt;\n                                        &lt;&#x2F;td&gt;\n                                    &lt;&#x2F;tr&gt;\n                                    &lt;&#x2F;tfoot&gt;\n                                &lt;&#x2F;table&gt;\n\n\n\n\n\n&lt;div class&#x3D;&quot;row-fluid&quot;&gt;\n    &lt;div class&#x3D;&quot;span6&quot;&gt;\n        &lt;div class&#x3D;&quot;dataTables_info&quot; id&#x3D;&quot;hidden-table-info_info&quot;&gt;\n            当前第[[$&#123;users.current&#125;]]页  总计 [[$&#123;users.pages&#125;]]页  共[[$&#123;users.total&#125;]]条记录\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;span6&quot;&gt;\n        &lt;div class&#x3D;&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt;\n            &lt;ul&gt;\n                &lt;li class&#x3D;&quot;prev disabled&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;← 前一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n                &lt;li th:class&#x3D;&quot;$&#123;num &#x3D;&#x3D; users.current?&#39;active&#39;:&#39;&#39;&#125;&quot; th:each&#x3D;&quot;num:$&#123;#numbers.sequence(1,users.pages)&#125;&quot; &gt;\n                    &lt;a th:href&#x3D;&quot;@&#123;&#x2F;dynamic_table(pn&#x3D;$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;&#x2F;a&gt;\n                &lt;&#x2F;li&gt;\n                &lt;li class&#x3D;&quot;next disabled&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;下一页 → &lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n            &lt;&#x2F;ul&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n&lt;!--common scripts for all pages--&gt;\n&lt;!--&lt;script src&#x3D;&quot;js&#x2F;scripts.js&quot;&gt;&lt;&#x2F;script&gt;--&gt;\n\n\n\n&#x3D;&#x3D;作业：”修改 添加“按钮 及功能实现~&#x3D;&#x3D;\n2、NoSQLRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。\n1、Redis自动配置&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n自动配置：\n\nRedisAutoConfiguration 自动配置类。RedisProperties 属性类 –&gt; spring.redis.xxx是对redis的配置\n\n连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration\n\n自动注入了RedisTemplate&lt;**Object**, **Object**&gt; ： xxxTemplate；\n\n自动注入了StringRedisTemplate；k：v都是String\n\nkey：value\n\n底层只要我们使用 StringRedisTemplate、****RedisTemplate就可以操作redis\n\n\nredis环境搭建\n1、阿里云按量付费redis。经典网络\n2、申请redis的公网连接地址\n3、修改白名单  允许0.0.0.0&#x2F;0 访问\n\n\n\n\n用完释放！！！！\nhttps://www.cnblogs.com/yunqing/p/10605934.html\nredis-server redis.windows.conf\nredis-server –service-install redis.windows-service.conf –loglevel verbose\n开启服务：redis-server –service-start\n停止服务：redis-server –service-stop\nredis-cli.exe -h 127.0.0.1 -p 6379\nget set del auth \nrequirepass\nhttps://www.cnblogs.com/liyan492/p/9858548.html\n概念：\n　　Jedis：是Redis的Java实现客户端，提供了比较全面的Redis命令的支持，\n　　Redisson：实现了分布式和可扩展的Java数据结构。\n　　Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。\n优点：\n　　Jedis：比较全面的提供了Redis的操作特性\n　　Redisson：促使使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列\n　　Lettuce：主要在一些分布式缓存框架上使用比较多\n可伸缩：\nJedis：使用阻塞的I&#x2F;O，且其方法调用都是同步的，程序流需要等到sockets处理完I&#x2F;O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。\nRedisson：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Redisson的API是线程安全的，所以可以操作单个Redisson连接来完成各种操作\nLettuce：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作\n结论：\n建议使用：Jedis + Redisson\n2、RedisTemplate与Lettuce@Test\nvoid testRedis()&#123;\n    ValueOperations&lt;String, String&gt; operations &#x3D; redisTemplate.opsForValue();\n\n    operations.set(&quot;hello&quot;,&quot;world&quot;);\n\n    String hello &#x3D; operations.get(&quot;hello&quot;);\n    System.out.println(hello);\n&#125;\n\n\n\n\n\n\n\n3、切换至jedis        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\n&lt;!--        导入jedis--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\nspring:\n  redis:\n      host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com\n      port: 6379\n      password: lfy:Lfy123456\n      client-type: jedis\n      jedis:\n        pool:\n          max-active: 10\n\n\n\n@Configuration\npublic class AdminWebConfig implements WebMvcConfigurer&#123;\n\n\n    &#x2F;**\n     * Filter、Interceptor 几乎拥有相同的功能？\n     * 1、Filter是【Servlet定义的原生组件】。好处，脱离Spring应用也能使用\n     * 2、Interceptor是【Spring定义的接口。可以使用Spring的自动装配等功能】\n     *\n     *&#x2F;\n    @Autowired\n    RedisUrlCountInterceptor redisUrlCountInterceptor;\n\n    &#x2F;**\n     * 定义静态资源行为\n     * @param registry\n     *&#x2F;\n&#x2F;&#x2F;    @Override\n&#x2F;&#x2F;    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n&#x2F;&#x2F;        &#x2F;**\n&#x2F;&#x2F;         * 访问  &#x2F;aa&#x2F;** 所有请求都去 classpath:&#x2F;static&#x2F; 下面进行匹配\n&#x2F;&#x2F;         *&#x2F;\n&#x2F;&#x2F;        registry.addResourceHandler(&quot;&#x2F;aa&#x2F;**&quot;)\n&#x2F;&#x2F;                .addResourceLocations(&quot;classpath:&#x2F;static&#x2F;&quot;); &#x2F;&#x2F;前缀 与 路径目录\n&#x2F;&#x2F;    &#125;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n&#x2F;&#x2F;        registry.addInterceptor(new LoginInterceptor())\n&#x2F;&#x2F;                .addPathPatterns(&quot;&#x2F;**&quot;)  &#x2F;&#x2F;所有请求都被拦截包括静态资源\n&#x2F;&#x2F;                .excludePathPatterns(&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;,&quot;&#x2F;css&#x2F;**&quot;,&quot;&#x2F;fonts&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;,\n&#x2F;&#x2F;                        &quot;&#x2F;js&#x2F;**&quot;,&quot;&#x2F;aa&#x2F;**&quot;,&quot;&#x2F;sql&quot;); &#x2F;&#x2F;放行的请求\n\n        registry.addInterceptor(redisUrlCountInterceptor)\n                .addPathPatterns(&quot;&#x2F;**&quot;)\n                .excludePathPatterns(&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;,&quot;&#x2F;css&#x2F;**&quot;,&quot;&#x2F;fonts&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;,\n                        &quot;&#x2F;js&#x2F;**&quot;,&quot;&#x2F;aa&#x2F;**&quot;);\n    &#125;\n\n\n\n\n\n\n\n\n\t&#x2F;**\n     * 去main页面\n     * @return\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;main.html&quot;)\n    public String mainPage(HttpSession session, Model model)&#123;\n\n        log.info(&quot;当前方法是：&#123;&#125;&quot;, &quot;mainPage&quot;);\n        &#x2F;&#x2F;是否登录，  拦截器，过滤器\n&#x2F;&#x2F;        Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;);\n&#x2F;&#x2F;        if(loginUser !&#x3D; null)&#123;\n&#x2F;&#x2F;            return &quot;main&quot;;\n&#x2F;&#x2F;        &#125; else &#123;\n&#x2F;&#x2F;            model.addAttribute(&quot;msg&quot;,&quot;请重新登录&quot;);&#x2F;&#x2F;转发回login页\n&#x2F;&#x2F;            &#x2F;&#x2F;回到登录页面\n&#x2F;&#x2F;            return &quot;login&quot;;\n&#x2F;&#x2F;        &#125;\n\n\n        ValueOperations&lt;String, String&gt; opsForValue &#x3D;\n                redisTemplate.opsForValue();\n\n        String s &#x3D; opsForValue.get(&quot;&#x2F;main.html&quot;);\n        String s1 &#x3D; opsForValue.get(&quot;&#x2F;sql&quot;);\n\n\n        model.addAttribute(&quot;mainCount&quot;,s);\n        model.addAttribute(&quot;sqlCount&quot;,s1);\n\n        return &quot;main&quot;;\n\n    &#125;\n    \n    \n\n\n\n\n@Component\npublic class RedisUrlCountInterceptor implements HandlerInterceptor &#123;\n\n    @Autowired\n    StringRedisTemplate redisTemplate;\n\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        String uri &#x3D; request.getRequestURI();\n\n        &#x2F;&#x2F;默认每次访问当前uri就会计数+1\n        redisTemplate.opsForValue().increment(uri);\n\n        return true;\n    &#125;\n&#125;\n\n\n\n&lt;!--statistics start--&gt;\n&lt;div class&#x3D;&quot;row state-overview&quot;&gt;\n    &lt;div class&#x3D;&quot;col-md-6 col-xs-12 col-sm-6&quot;&gt;\n        &lt;div class&#x3D;&quot;panel purple&quot;&gt;\n            &lt;div class&#x3D;&quot;symbol&quot;&gt;\n                &lt;i class&#x3D;&quot;fa fa-gavel&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;&#x2F;div&gt;\n            &lt;div class&#x3D;&quot;state-value&quot;&gt;\n                &lt;div class&#x3D;&quot;value&quot; th:text&#x3D;&quot;$&#123;mainCount&#125;&quot;&gt;230&lt;&#x2F;div&gt;\n                &lt;div class&#x3D;&quot;title&quot;&gt;&#x2F;main.html&lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;col-md-6 col-xs-12 col-sm-6&quot;&gt;\n        &lt;div class&#x3D;&quot;panel red&quot;&gt;\n            &lt;div class&#x3D;&quot;symbol&quot;&gt;\n                &lt;i class&#x3D;&quot;fa fa-tags&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;&#x2F;div&gt;\n            &lt;div class&#x3D;&quot;state-value&quot;&gt;\n                &lt;div class&#x3D;&quot;value&quot; th:text&#x3D;&quot;$&#123;sqlCount&#125;&quot;&gt;3490&lt;&#x2F;div&gt;\n                &lt;div class&#x3D;&quot;title&quot;&gt;&#x2F;sql&lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n\n\n\n\n\n07、单元测试1、JUnit5 的变化Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库\n作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。\nJUnit 5 &#x3D; JUnit Platform + JUnit Jupiter + JUnit Vintage\nJUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。\nJUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个测试引擎，用于在Junit Platform上运行。\nJUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。\n\n注意：\nSpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test****）\nJUnit 5’s Vintage Engine Removed from **spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage**\n&lt;dependency&gt;\n    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;\n    &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.hamcrest&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;hamcrest-core&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n  &lt;scope&gt;test&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n现在版本：\n@SpringBootTest\nclass Boot05WebAdminApplicationTests &#123;\n\n\n    @Test\n    void contextLoads() &#123;\n\n    &#125;\n&#125;\n\n\n\n\n\n以前：\n@SpringBootTest + @RunWith(SpringTest.class)\nSpringBoot整合Junit以后。\n\n编写测试方法：@Test标注（注意需要使用junit5版本的注解）\nJunit类具有Spring的功能，@Autowired、比如&#x3D;&#x3D;@Transactional 标注测试insert方法，测试完成后自动回滚&#x3D;&#x3D;\n\n2、JUnit5常用注解[&#x3D;&#x3D;P72…待看~&#x3D;&#x3D;]P72:https://www.bilibili.com/video/BV19K4y1L7MT?p=72&amp;spm_id_from=pageDriver\nJUnit5的注解与JUnit4的注解有所变化\nhttps://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations\n\n**@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试\n\n**@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍\n\n**@RepeatedTest :**表示方法可重复执行，下方会有详细介绍\n\n**@DisplayName :**为测试类或者测试方法设置展示名称\n\n**@BeforeEach :**表示在每个单元测试之前执行\n\n**@AfterEach :**表示在每个单元测试之后执行\n\n**@BeforeAll :**表示在所有单元测试之前执行\n\n**@AfterAll :**表示在所有单元测试之后执行\n\n**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories\n\n**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore\n\n**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误\n\n**@ExtendWith :**为测试类或测试方法提供扩展类引用\n\n\nimport org.junit.jupiter.api.Test; &#x2F;&#x2F;注意这里使用的是jupiter的Test注解！！\n\n\npublic class TestDemo &#123;\n\n  @Test\n  @DisplayName(&quot;第一次测试&quot;)\n  public void firstTest() &#123;\n      System.out.println(&quot;hello world&quot;);\n  &#125;\n\n\n\n3、断言（assertions）断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别：\n检查业务逻辑返回的数据是否合理。\n所有的测试运行结束以后，会有一个详细的测试报告；\n1、简单断言用来对单个值进行简单的验证。如：\n\n\n\n方法\n说明\n\n\n\nassertEquals\n判断两个对象或两个原始类型是否相等\n\n\nassertNotEquals\n判断两个对象或两个原始类型是否不相等\n\n\nassertSame\n判断两个对象引用是否指向同一个对象\n\n\nassertNotSame\n判断两个对象引用是否指向不同的对象\n\n\nassertTrue\n判断给定的布尔值是否为 true\n\n\nassertFalse\n判断给定的布尔值是否为 false\n\n\nassertNull\n判断给定的对象引用是否为 null\n\n\nassertNotNull\n判断给定的对象引用是否不为 null\n\n\n@Test\n@DisplayName(&quot;simple assertion&quot;)\npublic void simple() &#123;\n     assertEquals(3, 1 + 2, &quot;simple math&quot;);\n     assertNotEquals(3, 1 + 1);\n\n     assertNotSame(new Object(), new Object());\n     Object obj &#x3D; new Object();\n     assertSame(obj, obj);\n\n     assertFalse(1 &gt; 2);\n     assertTrue(1 &lt; 2);\n\n     assertNull(null);\n     assertNotNull(new Object());\n&#125;\n\n\n\n2、数组断言通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等\n@Test\n@DisplayName(&quot;array assertion&quot;)\npublic void array() &#123;\n assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);\n&#125;\n\n\n\n3、组合断言assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言\n@Test\n@DisplayName(&quot;assert all&quot;)\npublic void all() &#123;\n assertAll(&quot;Math&quot;,\n    () -&gt; assertEquals(2, 1 + 1),\n    () -&gt; assertTrue(1 &gt; 0)\n );\n&#125;\n\n\n\n4、异常断言在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows()** ,配合函数式编程就可以进行使用。\n@Test\n@DisplayName(&quot;异常测试&quot;)\npublic void exceptionTest() &#123;\n    ArithmeticException exception &#x3D; Assertions.assertThrows(\n           &#x2F;&#x2F;扔出断言异常\n            ArithmeticException.class, () -&gt; System.out.println(1 % 0));\n\n&#125;\n\n\n\n5、超时断言Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间\n@Test\n@DisplayName(&quot;超时测试&quot;)\npublic void timeoutTest() &#123;\n    &#x2F;&#x2F;如果测试方法时间超过1s将会异常\n    Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));\n&#125;\n\n\n\n6、快速失败通过 fail 方法直接使得测试失败\n@Test\n@DisplayName(&quot;fail&quot;)\npublic void shouldFail() &#123;\n fail(&quot;This should fail&quot;);\n&#125;\n\n\n\n4、前置条件（assumptions）JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。\n@DisplayName(&quot;前置条件&quot;)\npublic class AssumptionsTest &#123;\n private final String environment &#x3D; &quot;DEV&quot;;\n \n @Test\n @DisplayName(&quot;simple&quot;)\n public void simpleAssume() &#123;\n    assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;));\n    assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;));\n &#125;\n \n @Test\n @DisplayName(&quot;assume then do&quot;)\n public void assumeThenDo() &#123;\n    assumingThat(\n       Objects.equals(this.environment, &quot;DEV&quot;),\n       () -&gt; System.out.println(&quot;In DEV&quot;)\n    );\n &#125;\n&#125;\n\nassumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。\n5、嵌套测试JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。\n@DisplayName(&quot;A stack&quot;)\nclass TestingAStackDemo &#123;\n\n    Stack&lt;Object&gt; stack;\n\n    @Test\n    @DisplayName(&quot;is instantiated with new Stack()&quot;)\n    void isInstantiatedWithNew() &#123;\n        new Stack&lt;&gt;();\n    &#125;\n\n    @Nested\n    @DisplayName(&quot;when new&quot;)\n    class WhenNew &#123;\n\n        @BeforeEach\n        void createNewStack() &#123;\n            stack &#x3D; new Stack&lt;&gt;();\n        &#125;\n\n        @Test\n        @DisplayName(&quot;is empty&quot;)\n        void isEmpty() &#123;\n            assertTrue(stack.isEmpty());\n        &#125;\n\n        @Test\n        @DisplayName(&quot;throws EmptyStackException when popped&quot;)\n        void throwsExceptionWhenPopped() &#123;\n            assertThrows(EmptyStackException.class, stack::pop);\n        &#125;\n\n        @Test\n        @DisplayName(&quot;throws EmptyStackException when peeked&quot;)\n        void throwsExceptionWhenPeeked() &#123;\n            assertThrows(EmptyStackException.class, stack::peek);\n        &#125;\n\n        @Nested\n        @DisplayName(&quot;after pushing an element&quot;)\n        class AfterPushing &#123;\n\n            String anElement &#x3D; &quot;an element&quot;;\n\n            @BeforeEach\n            void pushAnElement() &#123;\n                stack.push(anElement);\n            &#125;\n\n            @Test\n            @DisplayName(&quot;it is no longer empty&quot;)\n            void isNotEmpty() &#123;\n                assertFalse(stack.isEmpty());\n            &#125;\n\n            @Test\n            @DisplayName(&quot;returns the element when popped and is empty&quot;)\n            void returnElementWhenPopped() &#123;\n                assertEquals(anElement, stack.pop());\n                assertTrue(stack.isEmpty());\n            &#125;\n\n            @Test\n            @DisplayName(&quot;returns the element when peeked but remains not empty&quot;)\n            void returnElementWhenPeeked() &#123;\n                assertEquals(anElement, stack.peek());\n                assertFalse(stack.isEmpty());\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n6、参数化测试参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。\n利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。\n@ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型\n@NullSource: 表示为参数化测试提供一个null的入参\n@EnumSource: 表示为参数化测试提供一个枚举入参\n@CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参\n@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)\n当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。\n@ParameterizedTest\n@ValueSource(strings &#x3D; &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)\n@DisplayName(&quot;参数化测试1&quot;)\npublic void parameterizedTest1(String string) &#123;\n    System.out.println(string);\n    Assertions.assertTrue(StringUtils.isNotBlank(string));\n&#125;\n\n\n@ParameterizedTest\n@MethodSource(&quot;method&quot;)    &#x2F;&#x2F;指定方法名\n@DisplayName(&quot;方法来源参数&quot;)\npublic void testWithExplicitLocalMethodSource(String name) &#123;\n    System.out.println(name);\n    Assertions.assertNotNull(name);\n&#125;\n\nstatic Stream&lt;String&gt; method() &#123;\n    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);\n&#125;\n\n\n\n7、迁移指南在进行迁移的时候需要注意如下的变化：\n\n注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。\n\n把@Before 和@After 替换成@BeforeEach 和@AfterEach。\n\n把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。\n\n把@Ignore 替换成@Disabled。\n\n把@Category 替换成@Tag。\n\n把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。\n\n\n08、指标监控1、SpringBoot Actuator1、简介未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n2、1.x与2.x的不同\n3、如何使用\n引入场景\n\n访问 http://localhost:8080/actuator/**\n\n暴露所有监控信息为HTTP\n\n\nmanagement:\n  endpoints:\n    enabled-by-default: true #暴露所有端点信息\n    web:\n      exposure:\n        include: &#39;*&#39;  #以web方式暴露\n\n\n测试\n\nhttp://localhost:8080/actuator/beans\nhttp://localhost:8080/actuator/configprops\nhttp://localhost:8080/actuator/metrics\nhttp://localhost:8080/actuator/metrics/jvm.gc.pause\nhttp://localhost:8080/actuator/endpointName&#x2F;detailPath。。。。。。\n4、可视化https://github.com/codecentric/spring-boot-admin\n2、Actuator Endpoint1、最常使用的端点\n\n\nID\n描述\n\n\n\nauditevents\n暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。\n\n\nbeans\n显示应用程序中所有Spring Bean的完整列表。\n\n\ncaches\n暴露可用的缓存。\n\n\nconditions\n显示自动配置的所有条件信息，包括匹配或不匹配的原因。\n\n\nconfigprops\n显示所有@ConfigurationProperties。\n\n\nenv\n暴露Spring的属性ConfigurableEnvironment\n\n\nflyway\n显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。\n\n\nhealth\n显示应用程序运行状况信息。\n\n\nhttptrace\n显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。\n\n\ninfo\n显示应用程序信息。\n\n\nintegrationgraph\n显示Spring integrationgraph 。需要依赖spring-integration-core。\n\n\nloggers\n显示和修改应用程序中日志的配置。\n\n\nliquibase\n显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。\n\n\nmetrics\n显示当前应用程序的“指标”信息。\n\n\nmappings\n显示所有@RequestMapping路径列表。\n\n\nscheduledtasks\n显示应用程序中的计划任务。\n\n\nsessions\n允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。\n\n\nshutdown\n使应用程序正常关闭。默认禁用。\n\n\nstartup\n显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。\n\n\nthreaddump\n执行线程转储。\n\n\n如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：\n\n\n\nID\n描述\n\n\n\nheapdump\n返回hprof堆转储文件。\n\n\njolokia\n通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。\n\n\nlogfile\n返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。\n\n\nprometheus\n以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。\n\n\n最常用的Endpoint\n\nHealth：监控状况\n\nMetrics：运行时指标\n\nLoggers：日志记录\n\n\n2、Health Endpoint健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。\n重要的几点：\n\nhealth endpoint返回的结果，应该是一系列健康检查后的一个汇总报告\n\n很多的健康检查默认已经自动配置好了，比如：数据库、redis等\n\n可以很容易的添加自定义的健康检查机制\n\n\n\n3、Metrics Endpoint提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到；\n\n通过Metrics对接多种监控系统\n\n简化核心Metrics开发\n\n添加自定义Metrics或者扩展已有Metrics\n\n\n\n4、管理Endpoints1、开启与禁用Endpoints\n默认所有的Endpoint除过shutdown都是开启的。\n需要开启或者禁用某个Endpoint。配置模式为  management.endpoint..enabled &#x3D; true\n\nmanagement:\n  endpoint:\n    beans:\n      enabled: true\n\n\n或者禁用所有的Endpoint然后手动开启指定的Endpoint\n\nmanagement:\n  endpoints:\n    enabled-by-default: false\n  endpoint:\n    beans:\n      enabled: true\n    health:\n      enabled: true\n\n\n\n\n\n2、暴露Endpoints支持的暴露方式\n\nHTTP：默认只暴露health和info Endpoint\nJMX：默认&#x3D;&#x3D;暴露所有Endpoint&#x3D;&#x3D;\ncmd  jconsole  都能看！\n\n除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则\n\n\n\n\nID\nJMX\nWeb\n\n\n\nauditevents\nYes\nNo\n\n\nbeans\nYes\nNo\n\n\ncaches\nYes\nNo\n\n\nconditions\nYes\nNo\n\n\nconfigprops\nYes\nNo\n\n\nenv\nYes\nNo\n\n\nflyway\nYes\nNo\n\n\nhealth\nYes\nYes\n\n\nheapdump\nN&#x2F;A\nNo\n\n\nhttptrace\nYes\nNo\n\n\ninfo\nYes\nYes\n\n\nintegrationgraph\nYes\nNo\n\n\njolokia\nN&#x2F;A\nNo\n\n\nlogfile\nN&#x2F;A\nNo\n\n\nloggers\nYes\nNo\n\n\nliquibase\nYes\nNo\n\n\nmetrics\nYes\nNo\n\n\nmappings\nYes\nNo\n\n\nprometheus\nN&#x2F;A\nNo\n\n\nscheduledtasks\nYes\nNo\n\n\nsessions\nYes\nNo\n\n\nshutdown\nYes\nNo\n\n\nstartup\nYes\nNo\n\n\nthreaddump\nYes\nNo\n\n\n3、定制 Endpoint1、定制 Health 信息import org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MyHealthIndicator implements HealthIndicator &#123;\n\n    @Override\n    public Health health() &#123;\n        int errorCode &#x3D; check(); &#x2F;&#x2F; perform some specific health check\n        if (errorCode !&#x3D; 0) &#123;\n            return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();\n        &#125;\n        return Health.up().build();\n    &#125;\n\n&#125;\n\n构建Health\nHealth build &#x3D; Health.down()\n                .withDetail(&quot;msg&quot;, &quot;error service&quot;)\n                .withDetail(&quot;code&quot;, &quot;500&quot;)\n                .withException(new RuntimeException())\n                .build();\nmanagement:\n    health:\n      enabled: true\n      show-details: always #总是显示详细信息。可显示每个模块的状态信息\n\n\n\n@Component\npublic class MyComHealthIndicator extends AbstractHealthIndicator &#123;\n\n    &#x2F;**\n     * 真实的检查方法\n     * @param builder\n     * @throws Exception\n     *&#x2F;\n    @Override\n    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;\n        &#x2F;&#x2F;mongodb。  获取连接进行测试\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n        &#x2F;&#x2F; 检查完成\n        if(1 &#x3D;&#x3D; 2)&#123;\n&#x2F;&#x2F;            builder.up(); &#x2F;&#x2F;健康\n            builder.status(Status.UP);\n            map.put(&quot;count&quot;,1);\n            map.put(&quot;ms&quot;,100);\n        &#125;else &#123;\n&#x2F;&#x2F;            builder.down();\n            builder.status(Status.OUT_OF_SERVICE);\n            map.put(&quot;err&quot;,&quot;连接超时&quot;);\n            map.put(&quot;ms&quot;,3000);\n        &#125;\n\n\n        builder.withDetail(&quot;code&quot;,100)\n                .withDetails(map);\n\n    &#125;\n&#125;\n\n\n\n2、定制info信息常用两种方式\n1、编写配置文件info:\n  appName: boot-admin\n  version: 2.0.1\n  mavenProjectName: @project.artifactId@  #使用@@可以获取maven的pom文件值\n  mavenProjectVersion: @project.version@\n\n2、编写InfoContributorimport java.util.Collections;\n\nimport org.springframework.boot.actuate.info.Info;\nimport org.springframework.boot.actuate.info.InfoContributor;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ExampleInfoContributor implements InfoContributor &#123;\n\n    @Override\n    public void contribute(Info.Builder builder) &#123;\n        builder.withDetail(&quot;example&quot;,\n                Collections.singletonMap(&quot;key&quot;, &quot;value&quot;));\n    &#125;\n\n&#125;\n\n\n\n\n\nhttp://localhost:8080/actuator/info 会输出以上方式返回的所有info信息\n3、定制Metrics信息1、SpringBoot支持自动适配的Metrics\nJVM metrics, report utilization of:\n\n\nVarious memory and buffer pools\nStatistics related to garbage collection\n\n\n\nThreads utilization\nNumber of classes loaded&#x2F;unloaded\n\n\nCPU metrics\n\nFile descriptor metrics\n\nKafka consumer and producer metrics\n\nLog4j2 metrics: record the number of events logged to Log4j2 at each level\n\nLogback metrics: record the number of events logged to Logback at each level\n\nUptime metrics: report a gauge for uptime and a fixed gauge representing the application’s absolute start time\n\nTomcat metrics (server.tomcat.mbeanregistry.enabled must be set to true for all Tomcat metrics to be registered)\n\nSpring Integration metrics\n\n\n2、增加定制Metricsclass MyService&#123;\n    Counter counter;\n    public MyService(MeterRegistry meterRegistry)&#123;\n         counter &#x3D; meterRegistry.counter(&quot;myservice.method.running.counter&quot;);\n    &#125;\n\n    public void hello() &#123;\n        counter.increment();\n    &#125;\n&#125;\n\n\n&#x2F;&#x2F;也可以使用下面的方式\n@Bean\nMeterBinder queueSize(Queue queue) &#123;\n    return (registry) -&gt; Gauge.builder(&quot;queueSize&quot;, queue::size).register(registry);\n&#125;\n\n\n\n\n\n4、定制Endpoint@Component\n@Endpoint(id &#x3D; &quot;container&quot;)\npublic class DockerEndpoint &#123;\n\n\n    @ReadOperation\n    public Map getDockerInfo()&#123;\n        return Collections.singletonMap(&quot;info&quot;,&quot;docker started...&quot;);\n    &#125;\n\n    @WriteOperation\n    private void restartDocker()&#123;\n        System.out.println(&quot;docker restarted....&quot;);\n    &#125;\n\n&#125;\n\n场景：开发ReadinessEndpoint来管理程序是否就绪，或者Liveness****Endpoint来管理程序是否存活；\n当然，这个也可以直接使用 https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes\n09、原理解析1、Profile功能为了方便多环境适配，springboot简化了profile功能。\n1、application-profile功能\n默认配置文件  application.yaml；任何时候都会加载\n\n指定环境配置文件  application-{env}.yaml\n\n激活指定环境\n\n\n配置文件激活\n命令行激活：java -jar xxx.jar –spring.profiles.active&#x3D;prod  –person.name&#x3D;haha\n\n\n\n\n修改配置文件的任意值，命令行优先\n\n\n\n\n默认配置与环境配置同时生效\n\n同名配置项，profile配置优先\n\n\n2、@Profile条件装配功能@Configuration(proxyBeanMethods &#x3D; false)\n@Profile(&quot;production&quot;)\npublic class ProductionConfiguration &#123;\n\n    &#x2F;&#x2F; ...\n\n&#125;\n\n3、profile分组spring.profiles.group.production[0]&#x3D;proddb\nspring.profiles.group.production[1]&#x3D;prodmq\n\n使用：--spring.profiles.active&#x3D;production  激活\n\n\n\n\n\n2、外部化配置https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\n\nDefault properties (specified by setting SpringApplication.setDefaultProperties).\n\n@PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.\n\nConfig data (such as **application.properties** files)\n\nA RandomValuePropertySource that has properties only in random.*.\n\nOS environment variables.\n\nJava System properties (System.getProperties()).\n\nJNDI attributes from java:comp/env.\n\nServletContext init parameters.\n\nServletConfig init parameters.\n\nProperties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).\n\nCommand line arguments.\n\nproperties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.\n\n@TestPropertySource annotations on your tests.\n\nDevtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active.\n\n\n1、外部配置源常用：Java属性文件、YAML文件、环境变量、命令行参数；\n2、配置文件查找位置(1) classpath 根路径\n(2) classpath 根路径下config目录\n(3) jar包当前目录\n(4) jar包当前目录的config目录\n(5) &#x2F;config子目录的直接子目录\n3、配置文件加载顺序：\n　当前jar包内部的application.properties和application.yml\n\n　当前jar包内部的application-{profile}.properties 和 application-{profile}.yml\n\n　引用的外部jar包的application.properties和application.yml\n\n　引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml\n\n\n4、指定环境优先，外部优先，后面的可以覆盖前面的同名配置项3、自定义starter1、starter启动原理\nstarter-pom引入 autoconfigurer 包\n\n\n\nautoconfigure包中配置使用 META-INF&#x2F;spring.factories 中 EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类\n\n编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties\n\n\n@Configuration\n@Conditional\n\n\n\n@EnableConfigurationProperties\n@Bean\n\n\n\n……\n\n\n\n引入starter — xxxAutoConfiguration — 容器中放入组件 —- 绑定xxxProperties —- 配置项\n2、自定义starteratguigu-hello-spring-boot-starter（启动器）\natguigu-hello-spring-boot-starter-autoconfigure（自动配置包）\n4、SpringBoot原理Spring原理【Spring注解】、SpringMVC原理、自动配置原理、SpringBoot原理\n1、SpringBoot启动过程\n创建 SpringApplication\n\n\n保存一些信息。\n判定当前应用的类型。ClassUtils。Servlet\n\n\n\nbootstrappers****：初始启动引导器（List）：去spring.factories文件中找 org.springframework.boot.Bootstrapper\n找 ApplicationContextInitializer；去spring.factories****找 ApplicationContextInitializer\n\n\n\n\nList&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers\n\n\n\n\n\n找 ApplicationListener  ；应用监听器。去spring.factories****找 ApplicationListener\n\n\n\n\nList&lt;ApplicationListener&lt;?&gt;&gt; listeners\n\n\n\n\n运行 SpringApplication\n\n\nStopWatch\n记录应用的启动时间\n\n\n\n创建引导上下文（Context环境）****createBootstrapContext()\n\n\n\n\n获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置\n\n\n\n\n\n让当前应用进入headless模式。java.awt.headless\n获取所有 RunListener****（运行监听器）【为了方便所有Listener进行事件感知】\n\n\n\n\ngetSpringFactoriesInstances 去spring.factories****找 SpringApplicationRunListener.\n\n\n\n\n\n遍历 SpringApplicationRunListener 调用 starting 方法；\n\n\n\n\n相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。\n\n\n\n\n\n保存命令行参数；ApplicationArguments\n准备环境 prepareEnvironment（）;\n\n\n\n\n返回或者创建基础环境信息对象。StandardServletEnvironment\n配置环境信息对象。\n\n\n\n\n\n\n\n读取所有的配置源的配置属性值。\n\n\n\n\n\n\n\n\n绑定环境信息\n监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成\n\n\n\n\n\n创建IOC容器（createApplicationContext（））\n\n\n\n\n根据项目类型（Servlet）创建容器，\n当前会创建 AnnotationConfigServletWebServerApplicationContext\n\n\n\n\n\n准备ApplicationContext IOC容器的基本信息  prepareContext()\n\n\n\n\n保存环境信息\nIOC容器的后置处理流程。\n\n\n\n\n\n\n应用初始化器；applyInitializers；\n\n\n\n\n\n\n\n遍历所有的 ApplicationContextInitializer 。调用 initialize.。来对ioc容器进行初始化扩展功能\n遍历所有的 listener 调用 contextPrepared。EventPublishRunListenr；通知所有的监听器contextPrepared\n\n\n\n\n\n\n\n\n所有的监听器 调用 contextLoaded。通知所有的监听器 contextLoaded；\n\n\n\n\n\n刷新IOC容器。refreshContext\n\n\n\n\n创建容器中的所有组件（Spring注解）\n\n\n\n\n\n容器刷新完成后工作？afterRefresh\n所有监听 器 调用 listeners.started(context); 通知所有的监听器 started\n\n\n\n调用所有runners；callRunners()\n\n\n\n\n获取容器中的 ApplicationRunner \n获取容器中的  CommandLineRunner\n\n\n\n\n\n\n合并所有runner并且按照@Order进行排序\n遍历所有的runner。调用 run 方法\n\n\n\n\n\n如果以上有异常，\n\n\n\n\n调用Listener 的 failed\n\n\n\n\n\n调用所有监听器的 running 方法  listeners.running(context); 通知所有的监听器 running \nrunning如果有问题。继续通知 failed 。调用所有 Listener 的 failed；通知所有的监听器 failed\n\n\n\npublic interface Bootstrapper &#123;\n\n\t&#x2F;**\n\t * Initialize the given &#123;@link BootstrapRegistry&#125; with any required registrations.\n\t * @param registry the registry to initialize\n\t *&#x2F;\n\tvoid intitialize(BootstrapRegistry registry);\n\n&#125;\n\n\n\n\n@FunctionalInterface\npublic interface ApplicationRunner &#123;\n\n\t&#x2F;**\n\t * Callback used to run the bean.\n\t * @param args incoming application arguments\n\t * @throws Exception on error\n\t *&#x2F;\n\tvoid run(ApplicationArguments args) throws Exception;\n\n&#125;\n@FunctionalInterface\npublic interface CommandLineRunner &#123;\n\n\t&#x2F;**\n\t * Callback used to run the bean.\n\t * @param args incoming main method arguments\n\t * @throws Exception on error\n\t *&#x2F;\n\tvoid run(String... args) throws Exception;\n\n&#125;\n\n2、Application Events and Listenershttps://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners\nApplicationContextInitializer\nApplicationListener\nSpringApplicationRunListener\n3、ApplicationRunner 与 CommandLineRunner第一季：SpringBoot2核心技术-场景整合","slug":"SpringBoot2","date":"2021-06-16T14:11:41.000Z","categories_index":"SpringBoot2","tags_index":"SpringBoot2","author_index":"CodingSeed"},{"id":"6f87183d1eab90b4f00ad401576c1de7","title":"kof97逆向","content":"1Hack rom\n教程https://cloud.tencent.com/developer/article/1176843kof97http://www.winkawaks.org/roms/neogeo/index.htm\n\n\nF5存档F7读档\nneogeo:debug dipswitches\nTool：\nshot factory： 截图\ntile viewer:ctrl T   图片基元\n68000 debugger–&gt;…\nmamemame使用教学\nhttp://www.962.net/gl/6245_all.html\ntab\n其他控制 coin：5678     \n存档读档：shift+F7,Z &#x2F; F7,Z                   &#x2F;sta\nP暂停\nhttps://wiki.neogeodev.org/index.php?title=Main_Page\nBase &#x2F;video sys\nNGH numbers: 232\nMVS  arcade\nAES  console\n模拟器开源代码：FBAlpha\nd_neogeo.cpp\n232-p1 主程序逻辑代码code！！！！！！！汇编\np2 贴图index 血量 …DB     新手改！\n图像资源文件：\ns1 Text layer tiles 8*8\n\nc1-6 Sprite data  16*16\nM1：Z80协处理器 音频\nv1-3:wav文件\n换贴图：裸体版。。。\n\n\n\n\n\n\n\n\n\n\nsave test97.bin 0, 100000\n小端了\n给IDA pro\n\n; :\nn x\nd t\ng 9c54\n\n2 M68000汇编基础Tab:  universe bios 2.2\n\n\n–&gt;\nBRA: short jmp\nJMP\nBSR: short call\nJSR\nIDA 看\nDebug中：\nbp 9ede\njsr改为bsr(等效)【ROM write word】: ow@9ede&#x3D;6100\ndisassembly窗口：bsr！！！\n重新断\n还原：ow@9ede&#x3D;4eba\n《68000汇编语言程序设计》\n68K指令集 临时速查https://wenku.baidu.com/view/ec0325ea4afe04a1b071de53.html\nF11单步\n\ndbf: bp 611c\n​         dbra(loop): D1-1,jmp to $6106\nsr： flags S&#x3D;1 特权级 \nccr：flags 后8bit 非特权级\n​        bp 9eb0 \n​         ori：or imm\n\n关中断  IntVBlank垂直同步Interrupt 、 timer…  、重启….\n\nrte 自动回复flags\nsp\nbp 9eb4\nA7:sys堆栈  sp 压栈push\n\n用reg传参，静态global var传参\n堆栈小（win console：4k  gui：64k）\n\nmame调试技巧硬补丁：bne–&gt;nop  4e71\n\n不会执行 中间…\nHard reset:改坏了，硬重启  恢复bne\n！！！软补丁：F7不影响了！！！\n条件断点，g 让程序继续跑\n\n\nbpclear\n等价：\n\n\n\n脚本语言，类似C语言，并不短路！！！\n3.kof97内存地址映射\n通常“内存”：RAM\nmemory: CPU寻址空间\nhttps://wiki.neogeodev.org/index.php?title=68k_memory_map\nROM\nRAM 可写\n\n\n镜像：指向同一块内存\n\n硬件 空间小 64k\n108200-&gt;只看8200\n p2-rom: 4M-&gt;1M  用bankswitch内存切页！\n\nsys rom：bios    coin~\n1 RAM\n2 P2ROM\n3 IO\n4~7 palette\nC BIOS\n\nbios ： 与IDA kof97p1 无关\n3: IO reg\n\n\n主板出错报告，正常到不了\n直接PC改为AEC0：\na7:sys堆栈  （改PC 0AEC0）\n\n3c0000: 还是0，没变\n\n操作显存，类似操作硬盘  addr 、content 、 step自增1\n\nvideo sys-vram显存\n\n实验120实际是10，改为1234\n\n显存的W与R出的不同，一般只关注W\n\n实验2move.l: long 4B\n3c0000端口 word类型2B   reg不够大\n16bit CPU，转换为2 steps\n同上等效！ 向显存10处写1234\n设地址+写内容 一步实现\n\nBankswitchF7 z\nP2ROM 4M ：winhex打开\nida 搜switch\n\n\n\nP2ROM 不能W，没写1\n切页了！！！\n\n\nwinhex：切页index 00 01 02 03\n不同硬件做切页：CPU不停读切页index，不等就切页失败，spining自旋忙等\n4. 主循环帧动画  显卡扫描60frames&#x2F;s   CRT显像管主循环地址：入口 9C38  ,  start 9C44\n\nCPU计算慢，重绘：卡顿 \n如今：CPU-&gt;GPU,掉帧\nF10  死循环\n\n\nstep4 等待VBlank中断信号\nbp 9EA2\nF5\nshift F11\nF10…\n9C5C: step 1    读keyboard\n\n9CDC: step2\n…\n9D88 end\nROM文件头格式https://wiki.neogeodev.org/index.php?title=68k_program_header\nPE ELF\n0:中断向量表 （实模式 加电 0-0x100）\n查68k vector table:\nC…:BIOS\n\n5  除0   RTE：不处理，直接返回\nA7 initialSP: 10F300\n\n68k interrupt：\nIntTimer\n\nIO reg设置中断频率\n通知reg已处理，acknowledgement，防止不停中断\n\nIntVBlankRoutine:  bp 9EA2\n\nhttps://wiki.neogeodev.org/index.php?title=68k_program_header\n\n\n100000调试开关\n\n\nF2界面字符串：欧美日\n\n\nOEP：BIOS交控制权\ncoin后选人\n过场动画\n声音处理\n\n122–&gt;9868\n查BIOS_RAM_Locations  10FD80\n\n\nRAM布局\n10F300：initialSP\nstk增长不快\n100000：debugdip\n100098：帧数计数器\nPool：堆 动态内存  data表示意义在变化（发2个波 addr不同）生命周期结束就销毁了\nstatic RAM：1P横坐标[常用]\n地址访问不直接用立即数\n\nA5+offset\nhttps://wiki.neogeodev.org/index.php?title=68k_instructions_timings\n\n因为imm慢，timing长\nA5&#x3D;108000不变，RAM Base基址\nA4指向Object\n5.图像显示（上）https://wiki.neogeodev.org/index.php?title=Category:Video_system\nctrl F\n\n\n8*8 tile：血条，时间，文字     \nkof97.zip图像资源文件：\ns1 Text layer tiles 8*8\nfix layer： 图层置顶 fixed position\nCtrl T：tile viewer\n\n用kawaks\n\n\n留黑边防止露馅\n按列遍历“K”在70A5\n\n改为6A 6B，变！！！\n\n\n0x2 36B–&gt;10进制：875\n\n2-&gt;3有偏差\n\n741B\n\nc1-6 Sprite data  16*16\n\n\nSprites 一条\n上下两层移动速度不同，造成景深效果\n近景：\n\n2P影子： 压扁 ，palette变黑，垂直翻转\n\n\nCtrl D\n\nMVSVRAM.dmp\n\n用CE！！！\n\n\n\n\nSCB1\n\nSCB2: 0x8000*2-&gt;0x10000\n\n\n\nsave\n\n\n\nSCB2:收缩因子 FF0F  0FFF  横纵 全1 不收缩\n草雉0C7 *2&#x3D;18E  word\n\n影子可改0B4*2&#x3D;168   VH\n\n\nSCB4：H Pos\n草雉0C7 *2&#x3D;18E  word\n2P：0B4*2\nSCB3：V\nsprite size\n\nsticky bit(group)&lt;–&gt;   1P&#x3D;&#x3D;多个sprite竖条\n\n\nSCB3:V\n\nSCB4:H\n\naddr靠后的tile会压住addr靠前的tile：2P压1P\n\n\n远 中 近bg 人物\n6.图像显示（下）\n64-&gt;0x40 *2&#x3D;0x80 bytes\nidx:12\nhex 12*80&#x3D;900\nV012: 63c9 d100\n\nLSB: 63c9&#x3D;10进制 25545\npalette: d1&#x3D;10进制 209 ，实际210\n\npalette: d8&#x3D;10进制 232\nHflip\n\nVflip（倒影！！！）\n\n1P Hflip了\nidx0A9*80\noffset…\n\n5e48 b508\n-&gt;24136 181\ntile viewer, paletteB5*2&#x3D;181\n\n步进step frame\n\n切换速度: 8frames 切换一次画面\ngif 自动动画(bg: 省CPU)\n3bit: 8 tiles循环\n2bit：4 tiles循环\n\n\n\n1word : sprite size置0，影子隐藏\n影跳\n\n1P2P交替    sprite隔帧替换\n双帧隐藏\nVBlankRoutine中断处理例程  时间有限，追求效率！！！\n9F20: UpdateSCB3\n\n64个\n9F24: UpdateSCB2           看a0\n\n\n32个\n高效：dbf loop 每次判0，慢\n4次就直接跳到箭头处\n\n\n\n\nSCB1在外面更新，写入的区域看不到，size&#x3D;0,改好再显示\n人物SCB1：bp 6022 （写入不显示的SCB1）\n\nd7：b4…-&gt;113   1p2p idx\na6: tile num [lsb msb] 需要解析！\n11types压缩算法\n\n\n10 palette\n08 idx\n05W 07H\ntile num 连续； 透明就忽略掉，稀疏压缩\n7.动态内存管理\n0x200&#x3D;512B 为单位分配addr &#x2F; 释放，对齐\n发波，贴图（依赖人物，生命周期短）\n\n双链表\n\n按prio插入\n释放：\n\n\n改r h仍正常，不重要\nnext：0500  prev：-1\n\n\n\nmem上:可用，下:不可用(垃圾data)\n\nlevel越大，prio越弱，靠后\n前两字节304C：（飞行道具obj…）自带处理程序addr\na4:obj\nP1ROM 30B2：分配0x200B动态内存\na0:自带处理程序  d0:level\n\n\n\n分配、释放obj处bp，打印链表指针\n连招卡顿，挨个执行处理程序\n经典实验1：指针上提！！！，造成内存分配失败“task over!!”\n\n\n分配失败：\n\npalette, tile vram addr\n\n\n\n\n1P2P放在static RAM: 108100【200B】~108300【200B】\n处理例程：\n\n\n动作一变，处理例程就变了\n8层bg：\n10b0b2[100B]：bg\n\n\n。。。\n\nbg obj 处理：\n\n人物影子10e4d6\n\n3层影跳 0x40&#x3D;64B\n\n备份队列，H V tile_idx palette\n类的继承：400 、200 、64\n\n\n\nCH：70 ACT：72 查人物&#x2F;贴图\n\nobj（offset70）人物CH code：1B   （72）动作ACT code：9B\ndebug模式:\n\n家用机：按住(按两次？)coin &#x2F; pause，移动    攻击：调整CH 、ACT code\n\n8.ACT封装BIOS:unibios\nkeyboard:  qwer  coin:5–&gt;CH  ACT\nF7 z\n【图片待修复。。。】\n![image-20210507163044497](C:\\Users\\bxl\\Desktop\\image-20210507163044497.png)\n\n\n\n108170\n落地 声效\nP2rom：4个bank 的    bank12里\n\n\nGraph Info Entry：\nH V  人物静态图idx\n100000处 改为0200: anchor 十字\n\nFF负值-&gt;W为0\n只是右闪了一下：因为站立本身就是一套ACT，现只右移了一张贴图\n一个人物：menu-&gt;submenu1-&gt;entry1\n​                   250000-2536c6-250092\nGraph Data Entry：\n10种压缩方法&#x2F;解析方法\n\ntype2：\n\n10：16  10000：65536\n\n1才写入rom\n比8高就16bit位图。。。\n人物设计  美工tile  压缩—&gt;P2rom\nBank2：ACT\n\n\n站立ACT：21191a\ncode addr：P1rom  584C\n6bit一组\nFF：ACT循环\nFE：ACT中断\nFD：站立\n4 frames &#x2F; tile\n判定框：type | box idx 绿黄蓝。。。\n\n\n04A4：W为0000    头判定框相对十字偏移  “头的判定落到了脚的位置~”\n\nWH：框的大小  控制(被)打击范围\nnext：黄框    FD 0A：000010 10\n\n\n\n04D4142C\n\n04是否硬直…flag\n06哪些判定框有效\ngraph idx: bank1…拿到tile\nFB：鬼烧2段 1段\n200002:  20011a\n\n\n\nFB：\n\n水平负偏移FFF8–&gt;ff80\n\n鬼烧偏移加大，直接冲到右边！！！\n鬼烧起势：【tile H偏移  判定框s 。。。】*n\n\n（72）动作ACT code：\n\n发动作：显示9c\n\nFC：音效  02C5(idx)–&gt;02c6\n\n\nFA:附加特效 45：idx  W Hoffset\n\n256个常用的特效在出招ACT里\n其它在[出招判定]流程里\n鬼烧起势81实验：\n\n持续2frames  tile_idx:E1\n\nbp  到Bank1：？？？\n\n250000-&gt;2536c6 [+ e1*4]: 25100c\npalette  解析type  Width、H  idx：11139  8bit位图\n\n11139&#x3D;&#x3D;10进制69945\n\n位图10…\nIDA逆向 6022处: UpdateSCB1。。。\n​               584C: ACT 6bit组 GetNextMov。。。\n\n9.指令输入系统+出招表https://wiki.neogeodev.org/index.php?title=Memory_mapped_registers\n\n\n松开是1，   按跳FF变FE\n\n下 FD, L   FB, R  F7, 轻拳EF, DF  BF 7F\n主循环里：\n\n封装为按下&#x2F;松开事件\n公司开发多个游戏：keyboard处理做成通用接口\n\nP1: 108000+5A48:静态地址10da44\n把300000处取反：上下左右01020408   攻击10204080\n2帧取与：TAS逐帧操作\n1P控制：\n\n\n1^0&#x3D;1\n为稳定性考虑！  1&#x2F;30s\n小键盘 升龙626 424 2626 2624 \n输入缓冲区60B  60帧&#x2F;s\n\n移动内存：复制平移【不一定合理，其实可以用指针】\n连跳两下&#x3D;高跳pause_step over： 101在缓冲区中向前滚动\n\nIDA 12914  UpdateACTInputQueue\n\nbp 12914\n\n方向键持续时间：用于蓄力的招！\na0:输入检查表 [ 所有出招 ] ,一个指针数组 \n\nL: 66跑 44后跳 28影跳 626X升龙… 424 624 236 214 2426X大蛇薙 26236X\n\nW1run W4后跳\n系统检查是否出招，出招否\n\nA8改AC：升龙626\nX方向键  记录之前动作\n\n\n更新后检查招式时改成040004：bp 129ac\n\nmax span frames:8帧内有4….0…**4[保证在队列尾！最新！]**即可\n\n\n0 0蓄力时间, 改小更容易\nF5 升龙\n比较方式：严格404，压了其他键 就发不出招来了 ：有轻拳无后跳\n蓄力 复合指令：  允许与X复合\n$14     \n$28\n$F0\n\n11种判定方法。。。\n分析出招表：可比较 2人谁出招快，距离远…\n10.碰撞检测搜：KOF97判定框查看方法及判定框颜色定义全解析！！\n\n\n判定框size&#x3D;0的结果。。。\n\n10000  不是0…\n\nP2rom\nIDA 3698:\n\nx\n主循环…9E04  软补丁nop跳过 6B\n\n\n不会碰撞检测了\n\n成ACT动画播放器了\n\n都nop，就能穿人了\nenter:\n\n\n\n\n97：1P面向不转向原则\n\n\n98：2P强制转身\n3698 (被)攻击\n\n\n\n64种box type\n被攻击判定：\n\n\n\n05红框\n\n爆气 counter  56：\n\nc~17不磨血攻击判定：\n18~… 必杀技\n\n\n\n\n玛丽38   龙二3839\n飞行道具：\n\n\n\n3112\n\n\nCH：1B  ACT：9B\n\n19紫 3A橙：飞行道具抵消判定框\n\n3d\n\n3C\n\n3b  互穿\n\n3f\n\n不靠判定框判定受0E攻击：\n\n07禁止对空追打：改？？？ 可无限连招\n8：倒地追打\n\n11.碰撞处理和连招蹲防不能防跳起的ABCD。。。跳防不能防必杀技。。。\n\n\nnop掉3794：每一帧后重复攻击判定\n\n\n\n\n碰撞检测返回处38be：\n\n同人互相counter（同受）攻击：  4B\n\n\n\n\n\n\n连续技\n目押需要C时机，cancel只要够快就行（输入缓冲队列里有）\n mark位接受cancel\n\n挥空cancel\n\n\n\n\n\n\n\n\n\n\n\n\nbp 1e5f4   断cancel\n葵花三段：108172 ：008D 末尾做按键test【半主动状态】\nACT：6B\n\n200002 CH table\n八神CH：108170\n\nACT menu：20d91a\nIDA 584C  5A3E:GetMovOffset\nACT 经解析：\n\n\n\n\nACT：2876f8\n\n\nIDA58E0\n\n0500-&gt;W为0520：持续5帧  火焰特效     高4位特效\n\n\n0700-&gt;W为070c:       改cancel可连招！！！！！！！！\n\n[超]必杀（最高级）没有cancel位\n硬直：打中人停3帧\n\n70硬直：屏幕震动效果    打击感！！！\n\nIDA 1633E。。。\n\ntask over\n软固定\n鬼步bug？？？\nhack rom 需要游戏设计idea，需要可玩性~\n","slug":"kof97逆向","date":"2021-02-17T12:24:13.000Z","categories_index":"逆向","tags_index":"游戏逆向","author_index":"CodingSeed"},{"id":"ff3b385e81d2e459aa67c54453b93307","title":"《恶意代码分析实战》实验","content":"1https://down.52pojie.cn/Tools/\n1-1：\nhttps://www.virustotal.com/gui/\nhttps://www.virscan.org/\npe.jpg\nPEiD\nPEtools\n1-2:\n脱壳机FUPX—改源文件\nsysinternal&#x2F;strings.exe\nlab1-3:\n3\nlinxerunpacker–&gt;unpacked.exe\n\nstrings unpacked.exe\n\n1-4：\nPEtools：编译时间被伪造\n\nadvapi32.dll\n提权\n\n网址 文件\n\n功能\n\nresource hacker–&gt;action-&gt;save as *.bin  \npetools：01-04是exe\nPEiD：子系统 输入表 DLL API\n\n33-1【静态分析】peid加壳\nstrings注册表位置  网址\n\n【动态分析】\n开启wireshark： 版本要求vista以上，可用win7测，或用fiddler~\n运行3-1.exe【慎！！！VM里运行】  , procexp: \nhandles: mutant互斥量_WinVMX32   【对res在同一时刻只有一个对象能对其访问】\nDLLs：联网\n\nprocmon: filter\n\n\n\n\nseed 随机数生成\nregedit注册表      加入自启动项\n比较大小和md5值：说明3-1.exe将self拷贝到了system32下vmx32to64.exe\nwireshark：双击：协议 内容\n\nDNS域名解析\n连外网 SSL：每次随机字符     定期发送不断广播256B数据包【随机数据】\n3-2.dll输出表：服务 安装self\n\n输入表：服务sc 注册表reg  Inet  http\ndll的某个宿主程序svchost.exe\n\nregshot注册表快照：\n\n1.运行该dll\n\nproexp中rundll32.exe不存在了，运行完毕。\n\n\nkey  创建服务\n\nval   5.as识别其的指纹特征\n\nwireshark：start\npromon\nprocexp\n\n\n\n4\n\nwireshark: dns\n\nhttp\n\n3-3procexp: run后消失，留下孤儿进程svchost.exe\n\n\n键盘记录，保存进该log文件中！！！\nmem有而image磁盘里没有按键相关API出现，是可移的内存修改操作！\nexp：PID 1640\nmon：\n\n\n\n\n桌面创建文件，记录输入内容+打开的程序：\n\n目的：svchost启动keyboard记录器\n3-4 自删除peid\n\n\n获取系统目录，copy到指定目录，隐藏自身\nservice reg\n\n联网\n命令行参数-in (install)\n\nhttp后门程序\n\n双击点完消失：自删除    exp没有特殊行为\n\n\nprocmon只看进程监控：\n\ncmd 删除self\n\n\n还是消失，无法有效安装，until第9章RE逆向分析原因！\n5 IDA Pro5-1 \n\nspace\n\n1.DllMain地址\n\n\n\n\n\n\n\n\n\nctrl+X: xref\np:call  r:read\n\n9个p，5个函数调用\n\n\n\n\nctrl+G:0x10001757\n\n\n\n”[This is RDO]“ 字符串长0Dh~\nesc返回\n\n\n\n23个局部变量\n\n6.+的是参数，1个参\n\n\n\n\n\n\n\n\n\n\n引用处：向上\n\n\nesc\n向下\n\nstr_cmp\n\n开启了远程shell会话\n\n\nglobal var：sys版本信息\n\n\n\n\n\n\n10\n\n\n\n\nmalloc\nsend\n\n\n\n\nview-exports：\n\n\n\nmsdn\n\nesc\n左分支call：入\n\nget进程&#x2F;线程&#x2F;模块列表\n\n\nesc\n右分支call：入  same\nPSLIST：发送走所有进程 &#x2F; 匹配某特定进程名并发送走\n\n\n！！！12.\n函数图模式：\n\n\n改名：\n\n13\n\n\n\n\n\n\nG\n\n\nascii to int,30*[3e8h&#x3D;&#x3D;1000dec]&#x3D;3w (ms) \nsleep30s\n15\n\n16\n\n\n\n\n\n\n17\n\n\n\n\n\nspace  找头部\n\n交叉引用\n\n\n18 随机数据字节，无可读性\n\n【IDA python插件相关】\n19 20 21\n获取光标位置\n\n配置python脚本较麻烦，用IDC脚本（类似C语言）！\n\nLab05-01.idc\nfile-script file: open\n\n解密出字符串~\n\n6 识别汇编中的C代码结构6-1\n\nmsdn\n\n\n\n\nif\n\n\n过于复杂，不要陷入细节\nesc返回\n\npush info str： 改名printf\n\n目的：检测当前网络连接状态\n6-2\n输入解析，网络状态回应\n\n\n\nwireshark start, 运行6-2.exe\n\n\nIDA：\n\n\n\n\n\n\n2.rename：printf\n\n\n3.4.\n\n5.网络特征\n从wininet.dll 导入的API：\n\nuser agent\nurl\nhFile句柄，用它访问url\n读取内容：\n\n快捷键r  转换含义\n\n\n首4B是不是’&lt;!–’ ： html注释开始处\n200h&#x3D;512B\nctrl+K\n\n\n\nesc\n\nesc\n\n\nsleep 60s ， retn\n\n\n6-3\nautorun自启动\n\n\n\n\n\n401130\n\n\n\n\n\n程序名\n\n上一个lab中’&lt;!–‘后的第5B字符：\n\n\nswitch结构\n\n上一个lab中’&lt;!–‘后的第5B字符\n\n\n*4：32位sys里每个内存地址长4B        抵达相应内存地址执行\n\n\n\n5+1default(&gt;4)\n\n\n\n\n\n5.本地特征：reg自启动项\n\n\ndeault ：printf  error_str\n\n\n\n\n\n\n\n\n6-4\n动态生成user agent\n\n\nadd  for循环结构\n\n头counter&#x3D;0  &lt;1440: loop\n\n尾 cnt自增1\n\n\n解析html：cnt做参\n\n\n5.动态user agent，  攻击者可得知恶意程序运行了多久：%d min\n\n\n\n\n总运行时长1min*1440cnt&#x3D;1440min&#x3D;24h\n\n\n7 分析恶意windows程序7-1\n\n服务 联网\n\n\n\n2.互斥量：单例运行\n3.主机特征：“HGL345”  “Malservice”\nGetCurrentProcess：获取当前进程的伪句柄： 可以被复制，但不能被继承， 不用close handle！！！！！！！！！！！！！！！！！！！\n\nGetModuleFileNameA:获取完整路径\n1.被用来创建服务\n\ntype 2：service auto start\n10h:srv win32 own process 该服务运行于独立进程中\n服务名：“Malservice”\n\n00:00  1.1.2100年\n\n等待时间DueTime\n等到00:00  1.1.2100年 才继续执行loop20次\n\n创建20个线程不断访问url（dead loop无限循环）：DDos分布式拒绝服务攻击\n\n4.网络特征：“IE8.0”  “http…”\n\n7-2\n\nDependency Walker 输入表分析\nDLE32.dll：COM（component obj model）相关API\n创建COM对象  init close COM库\n\n\nrun\n\nIDA\n\n接口&#x2F;类 标志符\n\n\n\niwebbrowser2\n\nedx: COM对象ppv的基址\n\nview-structure：按insert\n\n\n\n\n启动IE，访问web地址ad.html 一次性广告\n\n\n7-3 感染型\n\n没有LoadLibrary, getProcAddr  没用dll？\ndll:\n\n\n\nDLL无导出函数？\n\nIDA：dll\n结构复杂，只看call\n收发数据：从远程接受命令\n\nport：80\n\n\n\n\n\nexe：\nmain要有2个参argc\nargv：1参exe，2参“。。。”\n\njudge 2参&#x3D;&#x3D;“。。。。。”\n\nkernel32.dll 和 7-3.dll映射入内存\n\n\n\n跳过。。。\n\n\nmalloc\n_stricmp\n\n搜索，找到C盘下的exe，调用4010A0\n\n\nIsBadReadPtr：进程是否有权限访问内存块\nrepne&#x3D;&#x3D;strlen\nrep&#x3D;&#x3D;memcpy\nesi–w覆盖–&gt;edi\n\n403010 A键转换：\n\n是1不是L\n\n总结：查找C盘所有exe，将导入表中的kernel32.dll改为kerne132.dll ！！！！！\n\n只留文件操作\n\n双击，无有用信息\ncmd 带参\n\nC:\\strings.exe—&gt;Dependency walker: 发现已被感染\n\n\n假的dll多了很多导出函数：将真的dll函数重定向，实现相同功能，再add自己的后门功能\n\n\n逆程序，将所有exe导入表中kerne132- 改回-&gt;kernel32\n9 OD 动态分析9-2      ？？？逆向shell技术？？？\n导入函数\ncmd执行…\n\nproexp监控  , run 9-2.exe：没什么。。。\nOD\nIDA\n\n401128  main\nOD bp 401128\n\nr:转换\n\n\n\n\n\n\nPathBuffer\n\n\n\nOD缺乏符号支持–&gt;IDA\n\n获取当前file name\nstep over\n\n\n_strcmp:     !&#x3D;  eax&#x3D;1\n\n\n所以双击end\n\n重命名为ocl.exe!!!!!!!!!!!!!!\n\n\n\n40124c！！！\n\n\n\n\nF4， data窗口跟随\n\ninto 401089\nF5：汇编to C\n\n解密过程！401089\n\n\n\ngetIP失败：\n\ngetIP成功：\nhost to net字节序\n\n\n6.域名就是：\n\n\n\n\n\n混淆域名的编码函数：这些str 与 IP xor\n\n\n\n\ninto 401000\n\n功能：反向shell：向远程发送shell命令\nIO Err-&gt;socket\n绑定了套接字和cmd.exe的标准流: socket data&lt;—to—&gt;cmd.exe\n\n？？？？？逆向shell技术？？？？？？？\n9-3\n\n\n\n\n运行时动态加载dll：需要LoadLibrary\n\nctrl+X\n\n\n\n4+2&#x3D;6个DLL\n2.基地址\nPEiD：DLL1 子系统\n\n23同上\n\nOD\n\n\nDLL3:\n\n\nM窗口：\n\n\n​          7.（1）DLL1的神秘数据：PID\n\n\n\nnew IDA：DLL1.dll\nprintf\n\n\n2参：cur进程PID\n\nDLL2Print\nxref\n\n\n1000B078保存了“temp.txt”的句柄\n7.（2）DLL2的神秘数据：“temp.txt”的文件句柄\n\n\n\n\nnew IDA：DLL2.dll\nDLL2ReturnJ：“temp.txt”的文件句柄\n\n\nWriteFile写入的是“temp.txt”\n\n6.\nmsdn\n\n\n\nIDA:DLL3.dll\n\nxref\n\n\n7.(3) DLL3神秘数据：“ping www.malwareanalysisbook.com”的内存地址\n6.NetScheduleJobAdd 2参数据：\n9-3.exe\n\n局部变量Buffer\n\nDLL3GetStructure(局部变量Buffer的地址)\n\n\nAT_INFO：\n\n\n\ninsert   search OK\n\n\n\n\n\n\n\n\n\nOD查基址\n\n\n代码段：391000\n\n11 恶意代码行为11-1 gina\n\n\n\n\n\n\n\n\n百度：windows gina\nwindows定制登录(xp&#x2F;2000&#x2F;2003等,vista&#x2F;win7&#x2F;2008已经使用了另外一种叫做凭证提供程序的方式了）\nGINA英文全名叫做 Graphical Identification and Authentication，是一个图形化的登录认证模块.\n首先让我们看一下windows的登录过程,了解一下GINA在登录环节中的位置\n打开任务管理器,会看到一个叫做winlogon的进程,这个进程在windows做好一些初始化工作后会被启动,并且将一直存在直到系统关闭.\nwinlogon是windows负责用户登录、认证之类操作的进程,winlogon启动时回查看注册表中 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WInlogon的GinaDll项,\n如果发现设置了这一项,则winlogon将使用GinaDll指定的动态模块,否则的话加载msgina.dll(在系统目录下)。\n当有用户登录、锁屏、关机等SAS事件时,winlogon会探测到,winlogon通过调用GINA模块中导出的函数来完成这些SAS事件的处理。\n\n拦截Gina来窃取用户的登录凭证\n\n\n\n1.从TGAD资源节中提取msgina32.dll，释放到磁盘:\n\n\n\n\n2.驻留方式：多了msgina32.dll\n\n手动提取&#x3D;&#x3D;自动释放 MD5&#x3D;：\n\n3.如何窃取用户登录凭证 4.对证书的处理\ngina拦截器：将凭证info给真实msgina.dll，必须包含gina要求的所有导出函数，至少15个\n\nstr：记录凭证info   .sys值得注意\n\n调用原因，判断dll是否被加载时调用\n\n获取真实MSGina句柄\n\n\nExports窗口-WlxLoggedOnSAS:\n\n获取真实dll的”…”函数地址\n\nLogout有额外操作\n\n\n\n\n\n\n11-2 inline hook , 邮件addr邮件客户端\n联网\nreg\nini配置文件\n\n对邮件做了处理：SMTP指令RCPT 用来创建email收件人\n\nini被加密了\n\n\n\n\n\n导出函数\n\n给cur进线程拍快照\n\nadv-reg\n\n\n\n监视宿主\n\n\n文件：\n\n\n\n\n\n\n\n\n\nreg：\n\n\n驻留：使该dll加载到所有加载user32.dll的exe中\nregedit\n\n\n\nini拷贝到C:\\WINDOWS\\system32\n\n\nrename   reg\n\nDllMain:\n1000105B\n\n\n8.ini意义：加密的恶意代码作者邮箱\n打开ini：\nini读入buffer，&gt;0B,rename解码:\n\nsys32:ini, spoolvxx32.dll 存入\\system32:\n\ndll入OD：\nbp 100016CA  (F2)  解码函数\n\n单步,\n\nrename邮箱：\n\n安装inline hook\n\n\ninline hook原理\n\ninto 100014B6：\n加载dll的getCurProc\n\nproc绝对路径\n\n返回arg4：路径名\nesc\n10001104:获取路径中进程名\n\n1000102D\n\n\nesc\n挨个比较\n\n所针对的3个攻击目标进程：\n\n\ncur PID\n\ninto\n\nThread32First&#x2F;Next 遍历cur thread\n不是curThreadId获取的线程,就挂起\n\nrename挂起线程！\n\n\n1499: curPID,curTID,快照，遍历Th，不是cur 就ResumeThread\n挂起、恢复\n目的：修改内核，安装inline hook\n\ninto 12A3\n获取wsock32.dll的句柄，得到send函数地址lpaddr\n\n\ninto 1203\n\n[lpaddr]send函数头：0E9h+4Boffset(arg4-lpaddr)\n\n在构造jmp指令\n\n5Bjmp：E9 offset(4B)\n7Bjmp：mov eax,offset      \n​                jmp eax\njmp to—&gt;\n3参 func:113D    rename为hook func\n\nesc\n1203：钩子安装处\n\n\nVirtualProtect改mem权限：改send函数执行权            ， 恢复权限\n\n备份send开头处（要改）5B\n\nrun恶意代码后jmp回send函数处继续执行\n\narg8: 3484的数据空间（4参）\n\n\n\ninto 156B:hook func\n\n查找“RCPT TO:”\n\nadd 向外发送的恶意邮件账户\n\n\n\nOD文件 附加msimn\nM窗口\n\nspoolvxx已载入内存！！！\nctrl+G:  send\nsend已被hook：跳到spoolvxx执行恶意动作\n\n\n\n\n\n邮件属于TCP\n\nstart监控\noutlook\n\nSMTP右键follow TCP stream\n\n多了个接收地址\n\n\n\n11-3\n1.2.\n\n索引服务，检测mem state, 防止mem过低\ndll:\n\ndependency walker\ndll导出函数奇怪\n\n键盘记录器\n\n\n运行\n\n\n\n3.4.\n\n\n401070\n\n\n对cisvc任何修改都W入磁盘\n不用writefile来改写exe了\n40127C【F5】:memcpy\n\nshellcode\n【C】转为代码\n\n\nUltra Compare比较cisvc感染前后变化：shellcode!!!!!\n\n\n\n\n\nOEP变为shellcode处\n\n感染后IDA：\n\n\nOD感染后\nG:1001B0A  F2(bp)\n\n1001B1B：\n\n调用导出函数\n跳到真实OEP\n\n\n5.6.\nIDA dll：\n建MZ互斥量\n\n\n\n\n\n\n\n\n12 隐蔽的恶意代码启动12-1 DLL注入IE 弹窗进程注入\n\n\n\n\n\nrun exe(+dll)\nprocexp,没什么。。。\n\n\n\n\n【N】：rename\n\n获取每个进程对象的PID\n\n\n\n是explorer.exe: ret 1\n\n\n拿句柄，操纵进程\n\n向上找：\ndll路径写入explorer.exe\nLoadLibraryA函数（参数lab12-01.dll）地址给CreateRemoteThread\nDLL注入：让远程进程explorer.exe创建线程，调用LoadLibraryA强制加载lab12-01.dll\n\n\n\n\n每分钟弹窗一次\n\n法一：重启系统，失效\n法二：procexp重启进程\n\n\n\n\n\ndll  iDA:\n\n\n\n运行时间：\n\n作为标题。。。2min\n\n12-2 进程替换前：3-3\nIDA exe：import窗口\nCreateProcess\nget&#x2F;setThreadContext\nR&#x2F;WProcessMemory\nLockResource\nSizeofResource\n\nCREATE_SUSPEND，等主进程resume thread\n\n\n添加context结构体：\nstructure窗口【insert】\n\n\n引用该进程的ebx寄存器–&gt;指向PEB\nmsdn &#x2F; windbg：PEB+8B&#x3D;被挂起进程的imgBaseAddr–[4B]-&gt;入Buffer\n释放新创建的进程内存空间，之后就可填充恶意代码了\n\n开始处：比对“MZ”“PE”\n\n\n“PE”+0x34&#x3D;imagebase\n40h:page_exec_RW\n\n\n循环 cnt\n‘PE’+6B：区段数\n\n\n\nvar4：’MZ‘      +3C&#x3D;’PE‘\n\n\n’PE‘+0xF8  [40B&#x3D;28h*【0x6区段数】]\n\n在遍历区段头\n加struct\n\n\n\nrename：\n\n\n\n\n\n\n复制节表\n\n\n判断来源\n\nctrl+X:\n\n\n\n\nres…—[4010EA]copy to—-&gt;svchost.exe\ninto 40132C：\nfind&#x2F;load&#x2F;lock&#x2F;sizeof Resource\nreshacker: res保存为bin\n\ncode被加密了(^41h)\n40132C函数中：\n\ninto 401000:\n\n\n\n\n\n\n\n12-3 keylogger  HookIDA:imports\n\nHook类型：\n\nmsdn  0Dh&#x3D;13\n\nlpfn：hook函数地址       keylogger\n\ninto fn:\n401086【Y】：L参-&gt;\n\n\n\n判定按键类型：\n\n\n\n\n\n\nvar_C&#x3D;Buffer&#x3D;参&#x3D;vkCode\n\n[shift]vkCode&#x3D;10h  -8h&#x3D;8h\n\n\ndd: data dw  4B\n\n401249:\n\n\nSetWindowsHookExA\n12-4 sfc_os32.dll  木马化wupd\nres hacker提取资源  4D5A 5045\n\nprocmon filter-file：\n\n\nwireshark\n运行\n\n下载updater.exe\n\nIDA    rename:\n\n\n\n\n\n\ninto 401000:\n\n【r】转换：\n\nwinlogon.exe\n\n\n\nget加载到进程的所有模块句柄数组\n\ncur模块名 是否&#x3D;&#x3D;winlogon.exe    ret 1&#x2F;0\nesc\nrename: 确定PID是否表示winlogon.exe\n\n\n\n\nret 0false:循环再找\nret 1:\n\n\n提权\n\nesc\nsfc_os.dll中编号2的函数指针\n\ndwDesiredAccess&#x3D;1F0FFFh:  PROCESS_ALL_ACCESS\n打开winlogon，get winlogon句柄\n向winlogon远程线程注入sfc_os.dll中编号2的函数:\n\n不用writeProcessMem了\n\nsfc_os.dll：windows文件保护\n\n\n\n\n\n\n\n\nhttps://www.aldeid.com/wiki/WFP-Windows-File-Protection\n\n4参：SfcTerminateWatcherThread() 函数\n\n\n\nesc\nwupdmgr用于系统更新\n\nwupdmgr.exe改名为winup.exe, 复制到&#x2F;temp\ninto 4011FC:\n\n正在提取资源节到硬盘上\n\n\n\n\n\n恶意res 12-4.exe  IDA：\n\n\n\n下载，重命名，自动更新\n\n\n\n13 数据加密13-1\nwireshark\n运行\n\n\nIDA str：没有网址 和 加密str！！！\n\n\n\n\n\n\n排除清零 和 库代码：只剩4011B8\n\narg4：BufferLen&#x3D;0Ch\n\nrename\n\n^3Bh\n\n\n\nctrl+X\n\n10进制索引值：101\n\n\n\n7060-编辑-修改数据\n\n\n\n域名网址ok！\n4.那加密str呢？\nPEiD插件Kanal：\n\n\n\n\n\n\n\n\nrename\n\n‘&#x3D;’做填充字符\n\n用标准Base64编码创建get请求的字符串\n\n\n\n\n\n\n\n\n【F5】\n\n\n对【hostname 前12B】 进行Base64编码\n\nInternetOpenUrlA\n\n\n\n\n\n\n通信信号beacon？？？？\n\n13-2\nprocmon filter\n运行\n\n\npeid-kanal 空！！！\n插件findcrypt.plw放入ida\\plugins中：\n\n\nsearch-text: xor ,find all occur\n\n\n\n4参 loop  shl shr\n\n\n\n\n\n加密函数~temp文件\n回溯\nimports-WriteFIle-xref：\n\n\n\n\ncreateFile  WFile\n\nxref\n\n获取想要加密的内容\n40181F：加密函数\n\n\n\n\n\n401070：获取想要加密的内容\n\nBitBlt\nGetDIBits\n获取位图信息，复制到buffer\n\n\n6.7.\n手动解密\n非标准 不好识别\n\n加密文件-&gt;加密函数：逆运行解密\n\n\n\n加密函数处: bp 401880 \n生成temp。。。后: bp 40190A\n[F2]\n\nrun\n单步，生成一个temp\nrun\n\n\n选中到底\n\nbin粘贴\n\nrun\n\n\n原始temp[.bmp] 被加密了。。。\n编程解密\n\n拷贝temp，改”\\…”内容\n\n\n0xC&#x3D;12\npy脚本放入\\PyCommands:\nb space删除断点\n重新载入exe\n！脚本名\n\n\n\n13-3\n\n\n\nwireshark\n DNS www…..\nIDA:\n自定义Base64加密算法\n\n\n\n\nsearch-text:  6个xor\nrename：\n\n\n\n\n插件findcrypt.plw放入ida\\plugins中：\n\n\n\n\n40cb08: xref   e:encode\n\n40DB08: xref       d:decode\n\n\nxor6:\n\n\nxor1:密钥初始化代码\n\n\nxref\n\n\nxor1：\n\n\narg0：密钥\nRFile\n-&gt;-&gt;-&gt;-&gt;\nWFile\n\n\nvarBE0+4&#x3D;var54&#x3D;arg10&#x3D;4015B7参\n&#x3D;ebp+S:网络套接字\n\n\npy27\n\n\n解密AES\nneed：VS &#x2F; VCForPython27     pycrypto-2.6.1\n\n\n\n\n\n14 恶意代码的网络特征14-1\n\nimport\nxref*2:\nURLDownloadToCacheFileA\nCreateProcessA\nrename:\n\n\n\n\n\nxref:\n\n\n\n\n\n\n\n改为标准填充字符’&#x3D;’\n\n\n\n\n\n\n\n\n\n\n14-2\n\n\n\n\nIDA:\n\n\n\n\n\n\n\n\n\n\ncreateThread*2\n\nLoadStringA：从资源节里读取字符串\n\n\n\n\n\n\n\n\n401000 内部函数\n403010 串\n\n\n\n\n\n\n\n\n\n\n\n\nesc\n\n自删除：\n\n\n\n\nSnort规则编写简述。。。\n14-3wireshark\n.pcapng 捕获的数据包文件\nIDA：\n\n\n\n\n\n401280 InternetOpenUrlA\n\n\n\n\n4011F3\n参：source\n​        arg4\n\nxref: winmain\n\nsource–401457:\n\ncreateFile失败，反馈给信令网址\n\nT:\n\n&#x3D;&#x3D;\n\nC:\\autobat.exe是存储URL明文的配置文件\n\n\n\n4012C7后 strstr &lt;no   00401000:\n拆分 乱序  隐藏！\n\n\n\n\n从web页面noscript标签中的某些特定组件 获得命令\n类似例子：注释域？？？？？？？？？？？？？？\n更难区分恶意流量与合法流量\n\n\n\n4017D1:call 401684\n1分为2\n\ncase0: d URLDownloadtoCacheFile  CreateProcA\n\n10 n end\n15 s sleep\n14 r  1651 1372 \n\n\n\n\n\n\n\n1565&#x2F;1651–1147：strlen    str idx:byte_4070D8\n\nURL 只需小写      2Fh  00–&gt;’&#x2F;‘\n非标准算法，需逆向\n太简单， 输出中   http:&#x2F;&#x2F; 对应编码参数 ‘&#x2F;08202016370000’ 易被识别\n\n\n\n\n\n\n\n\n\n\n\n\n15 对抗反汇编 F5 space Data、Code、P:func15-1\n\n\n1.固定条件的跳转指令 永假条件分支技术\n\njmp到call指令中间不正常，地址标红不可用\n401010【D】变data\n\n401011【C】变code\n\n没对齐\n\n【C】\n\n【C】直到指令紧挨\n\n\n5次   添加E8，以欺骗它反汇编为call+不可达地址！！！！\n\n\n\n【D】\nnext【C】。。。\n\n\n\nmain：\n\n\n\n\n\n\n\n\n\n选中。。。retn\n【P】强制变为函数\n【SPACE】\n\narg_4： 命令行2参数\n\n\n【F5】 to C:\n\n\n15-2\nesp永远非零\nD C\n\n\nD C CC\n\n\nDC\n\nDC\n\nEE【D】\nEF【C】\nE6【D】\nE8【C】\n\n\n\n\n–\n全nop\n–\n选中 P\nspace\n\n\n\n\n\n\ncall 401386\n【r】转换str\n\n\n\n上\n\nuser-agent用本地PC名称\n\nF5\n\n\n\n\nopenUrl readFile （Buffer） strstr “Bamboo::”\n\n\n\n\n\nreadFile  \n\n\n\n\n15-3进程快照  proc32first&#x2F;next  printf\n\nOD\n\nIDA\n\n\n\n\n1.将main的返回地址 覆盖为40148C，继续执行恶意代码\n\n\n\n【G】40148C\n‘E9’【D】\n【C】\n自造除零异常处理，跳过printf(只是诱饵)\n\n4014C0: data【C】code\n？？？？？？？？？？？？\n\nD C\n\n参数非ASCII文本，都做过401534函参\n猜ta解密函数：\n\n\n原理：按位取反\n第5章idc脚本改写：\n\n\n\n\n\n\n\n\n\n62个字符&#x3D;0x3E  i &lt;&#x3D; 0x3E\nb^0xFF\n\n光标 file script  .idc\n\nDCDC\n\nexec spoolsrv.exe\n16 反调试16-1 调试状态3标志一系列验证，失败401000  自删除end\n\n401000：\nbp 4010de\n\nxref 79次\n403554处\nfs：0 保存TEB\nwindbg kernel local本地内核调试：\n\n\n\n\n\n\n\n\n\ndt _teb\n\nfs：30h 保存PEB\n\n\n0没被调试\n【反调试！！！】\n去bp 重新载入\n\n法一：手动1改0\n\n法二：OD插件PhantOm：   hide from PEB\n\n\nPEB+18h: ProcessHeap\nopcode bytes: 5  无硬编码 错误指令：忽略ta！！！\n\nProcessHeap+10h：ForceFlags&#x3D;&#x3D;beingDebugged 0没被调试\n已auto解决,先移除phantOm\n\n\nPEB+68h&#x3D;NtGlobalFlag\n\n自动屏蔽，插件已移除\n\n\n\n16-2 TLS回调\n\n\n4.40123A\n5.反反调试太强，改用英文原版OD：\n\n\n\n\n\n\n\ntls回调在OEP前执行retn\n\n\n\n【ctrl+E】\n\n\n\n\ntls作为启动过程的结果被调用\n\n\nSpy++ search -find window 拖到OD：\n\n新版OD：\n\n对抗FindWindow反调试！\n避免：原版+plugin\\ 拷贝phantom\n改ini：更新plugin path路径\n\n\n载入exe：\n\n\n\n\n\n\n\nbp 40123A\n【F4】size&#x3D;4\n\nbzqr\n\n\n\n\n\n\n\n入str2\n\n右键Array\n\nrename：\n\nesc\n\n过于复杂，只看要点\n\n让beingdebugged恒&#x3D;&#x3D;0：\nOD   phantom-hide from PEB\n重载\nG 40123A   F4\n\nbzrr还是提示 错！\n\nxref\n\n设置错误码&#x3D;3039h\n调试器打印bcmp（3039h, cur错误码）\n\n\n命令行中run，OutputDebugStringA失败，全新错误码，不++：\n\nspace、nop：永远不++\n\n\nsave file: Lab16-02_patched.exe\n载入patched.exe 1234：\n\nbp 40123A  F4\n\n\ntls：\n\ncmp arg4,1 进程启动时call tls\ncmp arg4,2 线程启动时call tls         CreateThread , call OutputDebugString时\n猜：cmp arg4,3 进程终止时call tls\n\n3.byrr, 不同方法，得到的命令行密码不同\n\n16-3 时间差 类似9-2\n\n\n\n\n\n\n\n发DNS请求\napateDNS监控：\n\nrun，nothing。。。\n\n\n\n【r】\n\n\nOD： G 401518 F4\n\n重启apateDNS\n改名 run\n监控nothing。。。\n向上找\n4014C3  【F4】\n\ninto 4011E0:\n获取精确的时间差&gt;1200ms,var118 1置2\n\nless\n\nOD中：401286 F4 单步\n&lt;&#x3D; ，var118依旧是1\n 猜：OD外run，&gt; 置2了崩了               直接NOP掉！！！\n\n\n全部内容-保存文件：\n\n删、替换原文件、rename qgr.exe\nG(strncmp) 401518      F4\n\n改名为peo.exe\nrun\n监控到了！！！\n\n\n\n\n\ninto 4011E0:\n\n$：当前指令地址\n401228入栈，跳到EIP新地址去执行\n\nget EIP值–&gt;给EAX\n\n401254处：用于删除异常处理的例程\nOD会花大量时间进行异常处理，通过此时间差判定run在OD中\n\nOD\n\n4015B4 出现无法处理的异常:   below\n\n非法操作：Write [0]\nnop掉左分支： \n\ncopy到exe-所有修改-全部复制-保存文件_\n覆盖原peo.exe：异常不存在了\nrdtsc*2 系统启动以来的时钟数\ndiv 0\n\nOD已自动更正：\n\n\n\n自删除+exit，OD中call     nop掉！！！\n\n\n修改字符串\n\n触发非法写入异常\n\n自删除+exit\n\n\n17 反VM17-1&lt;—-7-1\n\npython-2.6.6.msi\n\n\n同时拷贝2个plugins\n\nfile-script:\nfindAntiVM.py\nfrom idautils import *\nfrom idc import *\n\nheads &#x3D; Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))\nantiVM &#x3D; []\nfor i in heads:\n\tif (GetMnem(i) &#x3D;&#x3D; &quot;sidt&quot; or GetMnem(i) &#x3D;&#x3D; &quot;sgdt&quot; or GetMnem(i) &#x3D;&#x3D; &quot;sldt&quot; or GetMnem(i) &#x3D;&#x3D; &quot;smsw&quot; or GetMnem(i) &#x3D;&#x3D; &quot;str&quot; or GetMnem(i) &#x3D;&#x3D; &quot;in&quot; or GetMnem(i) &#x3D;&#x3D; &quot;cpuid&quot;):\n\t\tantiVM.append(i)\n\nprint &quot;Number of potential Anti-VM instructions: %d&quot; % (len(antiVM))\n\nfor i in antiVM:\n\tSetColor(i, CIC_ITEM, 0x0000ff)\n\tMessage(&quot;Anti-VM: %08x\\n&quot; % i)\n\nGetMnem(i) &#x3D;&#x3D; “sidt”  sldt  str    sgdt     smsw   in     cpuid    ??????????????????????\n\n\n红色高亮 sldt sidt str指令\n\n\n3.4.5.6.\nsldt\n\n\nsidt\n\n自删除：\nVM多核形式: ECX&#x3D;F7   VMware特征：FF\n\n检查会失败\n\nor改为F7，or改为单核VM\nstr\n\n\n\n\n17-2 尝试禁用\nPEiD\nrundll32.exe dll,ExportFunc\n\n\n\n\n\n\n\n\n\n\n\n5567 xref: InstallRT\n打开log 写入log\n10006196：反VM\n\n\n\n\n\n\n\n\n\n\n\n\n改串为”[…]0”\n\n或者OD改检查指令，保存\n\n\n\nInstallRT的1000D3D0、1000D10D\n\n\nInstallSA:\n\n\n\n\nInstallSB:\n\n5A0A禁用文件保护 (12-4)\n\n\n\n留待分析。。。17-3&lt;—-12-2\n\n\n\n\n\n\n\nfindAntiVM.py\n\n\nstring:\n\nxref\nview-graphs-User xrefs chart\n\n\n判断自己是否在虚拟机中\n\n\n\nxor xor\n\nrename   xref\nvar_38右键array 27，rename为Byte_Array\n\n\n\n分配空间lpMem[dwBytes]，第2次调AdaptersInfo\n\n\n\n\n\n\n\n\njmp资源节，跳过适配器检查！！！！\n\n\n\nnop掉40145D处 1130函数调用\n\n\n18 加壳脱壳  easy18-1 尾部跳转OEPpeid-&gt;Hard core scan: UPX压缩壳\n\n\nnext F2bp F9run：执行过loop\n\n尾部跳转\n\n\nF2bp F9run F8over\n\nOEP！！！\n\n\nunpacked\nImpREC:修复导入表\n\n\nunpacked.exe\n\n脱壳成功：unpacked_.exe\n\nrun 没报错\n同14-1\n18-2 OllyDump: find OEP by section hop\n\n分析-分析代码\ndump debugged process\n去rebuild import\nModify：1090\ndump：unpacked\nImpREC：18-02.exe\nOEP：1090\nIAT autoSearch\nget Imported\nfix dump: unpacked\n同7-2\n18-3 ESP定律脱壳法\nOD：pushad\ntrace into 不对\ntrace over\n\n\n找连续0000 尾部跳转:jmp &#x2F; retn\n\n\n没找到\n删调试信息\n\n\n\nrun：\npopfd  retn尾部跳转【F8】\n\n分析代码：OEP！！！\n依据堆栈平衡原理：ESP定律脱壳法\n\ndump debugged process\n去rebuild import\nModify：\ndump：unpacked\nImpREC：18-03.exe\nOEP：\nIAT autoSearch\nget Imported\nfix dump: unpacked\nunpacked_  PEiD：VC++6.0\n同9-2\n18-4 同3\n\n栈上设置硬件访问断点，找popad\n【F8】 esp变化 ：数据窗口中跟随\n\n\n\nOEP\ndump debugged process\n去rebuild import\nModify：\ndump：unpacked\nImpREC：18-04.exe\nOEP：\nIAT autoSearch\nget Imported\nfix dump: unpacked\nunpacked_  PEiD：VC++6.0\n同9-1\n18-5 同\n\n【F8】到ESP变红 数据窗口跟随\n断电 硬件访问 DWORD\n分析代码\ndump debugged process\n去rebuild import\nModify：1190\ndump：unpacked\nImpREC：18-04.exe\nOEP：1190\nIAT autoSearch\nget Imported\nfix dump: unpacked\nunpacked_  PEiD：VC++6.0\n同7-1\n19 Shellcode分析。。。19-1 idc解密 scdbgbin IDA\n【C】\n200处：ecx cnter\n\ncall sub_208作用: push 224(next addr)\npop esi&#x3D;224\nlodsb: esi-&gt;eax 依据DF(direction标志位)esi++&#x2F;–\n224处【D】\n49h存入eax\nesi自增为225【D】4Ah\nstosb:eax-&gt;[edi&#x3D;224]  依据DF(direction标志位)edi++&#x2F;–\n解码！！！\nidc   i&lt;&#x3D;0x18D？？？？\n\n光标224处 file-script idc\n【C】\nIDA没识别shellcode\n将实验数据保存到19-1.exe ，源代码lab19-01.cpp：借用缓冲区溢出分析程序 strcpy\n\n\nOD 19-1.exe：\n4016B4：main\nF7 into\nretn处F2 F9run\n\n【enter】响应\n【F8】单步\n解密函数：\n\nretn处F2 F9run\n解密完成\nshellcode开始工作。。。\n\n详见P654-655。。。\nOD动态调试 \nscdbg\n\n19-2\nIDA：各个call \n提权\nreg里获取默认浏览器路径\n\n启动【不可见】浏览器进程\n\nunk_407030: shellcode注入浏览器\n\n2.【C】\n\n3.解密idc\n\n4.5.\n\n\n\n\nshellcode为了通用性：动态获取API addr，再调用func\nkernel32.dll\n\n“loadlibraryA” hash运算，使短小精悍！\n\nstr代码放在4071BB\nfunc name &#x2F; 4B\n\n4071BB add入栈 ，再call\n\nebx操控funcName hash值\n\ncall CreateProcess\n\nshellcode功能：建立远程shell\n详见P657-660。。。19-3 PDFStreamDumper 堆喷射\nAdobeReader8.1.2及之前版本中\n\nJS percent encoding 编码方式：\n%u：ASCII 16进制 2B\n89e581ec\n%：ASCII 16进制 1B\n\n\n\n\nShellExec: 用默认pdf阅读器打开bar.pdf\n_sc.bin IDA:\n【C】hashed func name\ncall 17B - call CA:FindKernel32base\n195 call：hash值计算\nloadlibrary函参shell32.dll\ngetTempPath\n\n\n\nshellcode解析详见P665-669。。。\n\n20 C++代码分析20-1  ECX传递对象索引：this指针\nnew obj\nthis指针\n\n\n\n\n20-2虚函数 FTP\n\n\n\n\nfindfirst&#x2F;nextFile\nstrncmp\n_strlen\nstrcat\n\nnew doc_obj\n虚函数表4060DC 写入该new doc_obj\n\n401440\n\n同理判pdf\n\n\n\n其他\n\n40132F：\npdf、doc 与 other 操作不同\n看pdf虚函数\n\n\ndoc虚函数“%s-%d.doc”\nother：nothing。。。\n\nC盘新建\n\n创建虚拟网络环境\n\n向ftp.blabla.com发请求，ApateDNS将请求重定向到本地PC上 DNS reply IP: 127.0.0.1\n\nrun\n\n\n\n20-3 异常 http get post\nIDA Strings window\n\n\n为获取执行命令轮询远程服务器\n\n后门程序\nImports：W32    CreateProcess\n\n\n\n401EE0是new obj所属类的成员函数\n\ninto+ into\n4036F0：异常对象的成员函数\n初始化异常\n\n\n\n\n\nesc \n\nesc\n\n\n401F80：发送信号，读响应\n1 into\n\n\n2 into\n不断获取计算机信息\n\nfunc 404ED0 \n\n404B10\n\n\n402410：获取指令\nsocket connection\nhttp get\npolling\n\n\n\nswitch 6 cases:\n0x6166: af\n\n\ndelete\natoi sleep\ninto CreateProcess\n253B -2A20: CreateFile  将服务器获取的http响应写到本地disk\n用http post指令来uploadFIle\n受害主机信息发送到服务器\n\n\n\n\n\n10 WinDbg调试内核10-1 创建服务来加载驱动：创建内核态Reg键值-禁用防火墙\nIDA exe：\nimports  服务\n\nStr\n\nIDA sys：\nimport  注册表\n\nStrings sys：\n内核态Reg\n禁用防火墙\n\n【猜测：创建服务来加载驱动：创建注册表键值-禁用防火墙】\nprocmon filter exe: run 【检测不到内核态Reg变化】\n写了一个随机数 没意义。。。\n\nIDA再分析exe：\nOpenSCManagerA\n\n1 SERVICE_KERNEL_DRIVER\n\nSERVICE_CONTROL_STOP 卸载驱动\nIDA sys:\nDriverEntry\ncall 10906:\n偏移量–&gt;内存位置\n\n\n\n\n\nVM内\nWinDbg-Open executable: lab10-01.exe\nbp 00401080【ControlService地址】\ng\n\nwindbg指令，API文档。。。想要~~\n\n宿主机\n双机调试 windbg VM\n!drvobj Lab10-01\n\n该drv没有供用户空间中app使用的Device\n!object \\Driver    内核中所有驱动列表\n\ndt解析为该数据结构\n\ng\ng\nVM内g  又卡死\n宿主机单步\n\n结合IDA：\n\n偏移0x486\nIDA默认sys addr：0x00010000\n+486&#x3D;10486：函数卸载处\n\nor：\n\n\n\nIDA addr与windbg addr保持一致了\n\n10-2 SSDT(R3-0通信)hook NtQueryDirectoryFile+FILE_BOTH_DIR_INFORMATION“脱链”文件隐藏\n\n\n\n\n\n\n宿主机windbg 双机调试：\ndd KeServiceDescriptorTable\n80502b8c函数指针数组：保存所有原生API函数的地址\n11c 数组大小\n80503000 参数个数 数组\nu\n\ndd dwo(KeServiceDescriptorTable) L100 \ng\ng\nprocmon filter 10-2.exe\n\nC盘 搜不到Mlwx486.sys\n\n\n\nIDA exe\n\nPE res写入.sys文件\n\n\nsc query “service name”\n\nwindbg     lm:系统读取的模块信息  \n\n没文件，用了Rootkit技术！！！\n根据nt范围，比较前后两次 dd dwo(KeServiceDescriptorTable) L100 变化\n–&gt;\n以b开头地址，是被PROCMON32修改的，忽略\n改了80570074这个地址\n\nNtQueryDirectoryFile：\n提取文件和目录信息的通用函数，findfirst&#x2F;nextfile,资源管理器用它显示管理目录\nrootkit钩取该函数，可实现文件隐藏\n被改后的地址下断点+g\n\np单步\n\n提取资源Mlwx486.sys\n\nIDA 该Mlwx486.sys：\n将基址改为内存中被改后的实际地址：f8cd8000\n\n\n3 FILE_BOTH_DIR_INFORMATION\n\n是3 是0\n\nsource2：”Mlwx”\n\nesi+5Eh:\n\n匹配文件名，执行文件隐藏：\n\n\n该buffer当前ds就是FILE_BOTH_DIR_INFORMATION\n原理：链表删节点 “脱链”\n\n\n\n10-3 _eprocess的ActiveProcessLinks脱链改当前进程，获取信息\n\nC:&#x2F;system32&#x2F;.sys\nrun 任务管理器没该进程，删不了\n2.只能快照源OS，或重启\n\n\nIDA exe:\nservice~~DeviceIoControl  加载和发送请求到内核驱动的函数\nOleInit… 使用COM对象\n\n打开一个由ProcHelper驱动创建的内核设备句柄\n\n向指定的设备驱动发送控制代码\n没IO信息，少见\n\n下同7-2 COM\nIDA sys：\n创建设备对象\n\n更容易被用户态app访问设备句柄\n\n\nwindbg双机调试：\n!devobj ProcHelper\ndt _DRIVER_OBJECT  820df7e0\n\n\nIDA[G] DriverInit 的地址\n\nIDA[G] DriverUnload 的地址\n\nxp允许28&#x3D;&#x3D;0x1Ch种可能的MajorFunction\ndd 820df7e0+0x038 L1c\n804f454a:驱动不能处理的非法请求类型的处理程序\n\n\n606\n\nnothing。。。\n666 DeviceIoControl：操纵PEB\n\n返回调用DeviceIoControl的_EPROCESS结构 (未公开，只有wdk说明，无定义)\ndt _eprocess\n\n双向链表\n\n\n脱链原理\n\n\n21 64位恶意代码21-1\n\n1.64VM run nothing。。。\n\n\n\nidaq64 exe:\nEntryPoint\n\n3参 int ptr ptr\n\n\n\nASCII   2E&#x3D;&#x3D;’.’\n\n改名ocl.exe运行 nothing\n\n\n\n\n获取目录路径中的文件名r11 [&lt;-]\n\n抽象的编码操作。。。跳过\n编码后str rcx &#x3D;&#x3D; jzm.exe\n\nnop掉jmp！！！\n\n\n\n\nVM内\nOD不支持64位调试，同windbg-amd64：\nfile-open executable-ocl.exe:\n\n\n\n\n\n参数：套接字。。。rbx\n\n\n\nmsdn\n\ninto 140001000\n\n\n\n\n21-2API IsWow64Process：是否是在64位OS上运行的32位程序\n\n\n\n\n\n\n\n\n\n\n\n\n\n同12-1 动态获取IsWow64Process函数地址\n\nrename\n\n\nvar_10 &#x3D; is64sys ? 1 : 0 \n\n\n\nx86\n\nrename\n\ninto\n将x86资源节中的文件提取到disk sysDIr里\n2参\n\n\nesc\ncall 401130 提权\ncall dw_40A7B0 EnumProcess\ncall 4011E0 找IE\nDLL注入\nx64：【 x.dll   x.exe 】\n提取dll、资源节\n\n\nrun\n64位OS上的32位程序：对应的系统目录是SysWow64\n\n\n\nIDA Lab21-02x.exe\n\ndll写入内存，注入\n\nstring-explorer.exe   xref:  func1090  xref：  main      循环调用\ninto 1090：1368： strcmp\n\n\n\n","slug":"《恶意代码分析实战》实验","date":"2020-11-26T16:25:37.000Z","categories_index":"逆向","tags_index":"逆向,反汇编","author_index":"CodingSeed"},{"id":"353cf78a0c7522820ab388e96d2cdefc","title":"core","content":"一、【保护模式】\n\n段寄存器有96位，但我们只能看见16位，那如果证明Attribute、Base、Limit的存在呢？\n\n2、探测Attribute\n\nint var &#x3D; 0;\n__asm\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tmov ax,ss\t&#x2F;&#x2F;cs不行 cs是可读 可执行 但不可写\n\tmov ds,ax\t&#x2F;&#x2F; 将 ss 段选择子代入 ds 段寄存器\n\tmov dword ptr ds:[var],eax\n&#125;\n\n3、探测Base\n[0]不可读不可写\n\nint var &#x3D; 1;\t\t\t\t\t\n__asm\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tmov ax,fs\t\t&#x2F;&#x2F;不要用DS 否则编译不过去\n\tmov gs,ax\t\t\t\t\n\tmov eax,gs:[0]\t&#x2F;&#x2F;&#x3D;&#x3D; fs.base+0\n\tmov dword ptr ds:[var],eax\t\n\t\n\t&#x2F;&#x2F;相当于mov edx,dword ptr ds:[0x7FFDF000]\n&#125;\n\n\n3、探测Limit\n\nint var &#x3D; 1;\t\t\t\t\t\n__asm\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tmov ax,fs\t\t\t&#x2F;&#x2F;不要用DS 否则编译不过去\n\tmov gs,ax\t\t\t\t\n\t\n\t&#x2F;&#x2F;mov eax,gs:[0x1000]\t&#x2F;&#x2F;FS limit&#x3D;0xFFF 0x1000越界了！\n\tmov edx,dword ptr ds:[0x7FFDF000+0x1000]&#x2F;&#x2F;等价，ds limit大 没越界\n\t\n\tmov dword ptr ds:[var],eax\n&#125;\n\n\n\n\n写段寄存器时，只给了16位[2B]，剩下的80位填什么？数据从哪里来？\n\nchar buffer[6] &#x3D; &#39;00001B&#39;;&#x2F;&#x2F;?????????\n__asm\n&#123;\n\tles ecx,fword ptr ds:[buffer] &#x2F;&#x2F;高2个字节给es，低四个字节给ecx\t\n&#125;&#x2F;&#x2F;dw:4 fw:6 qw:8 \n把另一个段寄存器中的数据读入到寄存器 ax(16bit)，然后把 ax 代入到了 ds，可是 ax 明明只有 16 位啊，而 ds 有 96 位。\nCPU必然在背后帮我们做了一些事情，它从 GDT 表中取出对应的段描述符，经过分析后自动的填写的了段寄存器中。\n\n段描述符共有64位，但需要填充的是80位，怎么填？\n\n当用Selector找到我们需要的描述符（GDT或LDT中的某一表项）后，\n我们把这个描述符拆解成3个部分，分别是 attribute, base 和 limit。\n\n段描述符 gdt[Selector]&#x3D;...;\n-&gt;\n段寄存器一共有 96 位，其中 16 可见部分来源于段选择子的索引部分。剩下 80 位来源于 GDT 表。\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;q1007729991&#x2F;article&#x2F;details&#x2F;52538080\n分析段选择子为0x1B、0x23对应的段描述符，并将内容填写到段寄存器结构体中.\n段描述符结构\n|   7    |     6       |     5     |   4    |   3    |   2    |   1    |   0    |  字节\n|76543210|7 6 5 4 3210 |7 65 4 3210|76543210|76543210|76543210|76543210|76543210|  比特\n|--------|-|-|-|-|---- |-|--|-|----|--------|--------|--------|--------|--------|  占位\n|  BASE  |G|D|0|A|LIMIT|P|D |S|TYPE|&lt;------- BASE 23-0 ------&gt;|&lt;-- LIMIT 15-0 -&gt;|  含义\n|  31-24 | |&#x2F;| |V|19-16| |P |\n\t\t   |B| |L|     | |L |\n\n0x1B &#x3D; 0000 0000 0001 1011\n索引号：0000 0000 0001 1&#x3D; 3 (查找gdt[3])\nRPL: 11b &#x3D; 3\nTI: 0 (查找 GDT 表)\n查找到的 GDT 描述符为：gdt[3] &#x3D; 00[cffb]00&#96;0000ffff\n00000000 |[ 1 1 0 0 1111 | 1 11 1 1011 ]|0000 0000 0000 0000 0000 0000 | 1111 1111 1111 1111\n段寄存器结构：\nselector  &#x3D; 0x001B\n[attribute &#x3D; 0xcffb] (G &#x3D; 1 DB &#x3D; 1 P &#x3D; 1 DPL &#x3D; 3 S &#x3D; 1 TYPE &#x3D; 1011(非一致代码段，可读已访问过))\nbase      &#x3D; 0x00000000\nlimit     &#x3D; 0xffffffff\n\n\n0x23 &#x3D; 0000 0000 0010 0011b\n索引号：0000 0000 0010 0 &#x3D; 4\nTI: 0 (查找 GDT 表)\nRPL: 11b &#x3D; 3\n查找到的 GDT 描述符为：gdt[4] &#x3D; 00[cff3]00&#96;0000ffff\n段寄存器结构：\nselector  &#x3D; 0x23\nattribute &#x3D; 0xcff3 (G &#x3D; 1 DB &#x3D; 1 P &#x3D; 1 DPL &#x3D; 3 S &#x3D; 1 TYPE &#x3D; 0011(可读可写向上扩展的数据段))\nbase      &#x3D; 0x00000000\nlimit     &#x3D; 0xffffffff\n\nchar buffer[6];\n__asm\n&#123;\n\tmov fword ptr ds:[buffer],0x1B0000\n\tles ecx,fword ptr ds:[buffer] &#x2F;&#x2F;高2个字节给es，低四个字节给ecx\t\n&#125;\n\nMOV DS,AX\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;102592866\n调用门（无参）\n实验：构造一个无参调用门\n#include &quot;stdafx.h&quot;\n#include &lt;windows.h&gt;\n\nvoid __declspec(naked) GetRegister()\n&#123;\n\t__asm\n\t&#123;\n\t\tint 3\n\n\t\tretf\t\t&#x2F;&#x2F; 注意返回，不能是ret\n\t&#125;\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\tchar buff[6];\n\t*(DWORD*)&amp;buff[0] &#x3D; 0x12345678;\t\t\t&#x2F;&#x2F; 在这行设置断点\n\t*(WORD*)&amp;buff[4] &#x3D; 0x48;\t\t\t\t&#x2F;&#x2F; 段选择子所在偏移\n\t__asm\n\t&#123;\n\t\tcall fword ptr[buff]\t\t\t\t&#x2F;&#x2F; 长调用\n\t&#125;\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n修改代码：R3读取高2G内存\n#include &lt;windows.h&gt;\n\nBYTE GDT[6] &#x3D; &#123;0&#125;;\nDWORD dwH2GValue;\n\nvoid __declspec(naked) GetRegister()\n&#123;\n\t__asm\n\t&#123;\n\t\tpushad\n\t\tpushfd\n\n\t\tmov eax,0x8003f00c\t&#x2F;&#x2F; 读取高2G内存\n\t\tmov ebx,[eax]\n\t\tmov dwH2GValue,ebx\n\t\tsgdt GDT;\t\t\t&#x2F;&#x2F; 读取GDT\n\n\t\tpopfd\n\t\tpopad\n\n\t\tretf\n\t&#125;\n&#125;\n\nvoid PrintRegister()\n&#123;\n\tDWORD GDT_ADDR &#x3D; *(PDWORD)(&amp;GDT[2]);\n\tWORD GDT_LIMIT &#x3D; *(PWORD)(&amp;GDT[0]);\n\n\tprintf(&quot;%x %x %x \\n&quot;, dwH2GValue, GDT_ADDR, GDT_LIMIT);\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\t__asm\n\t&#123;\n\t\tmov ebx,ebx\n\t\tmov ebx,ebx\n\t&#125;\n\n\tchar buff[6];\n\t*(DWORD*)&amp;buff[0] &#x3D; 0x12345678;\n\t*(WORD*)&amp;buff[4] &#x3D; 0x48;\t&#x2F;&#x2F; segment select\n\n\t__asm\n\t&#123;\n\t\tcall fword ptr[buff]\n\t&#125;\n\tPrintRegister();\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;无参\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;q1007729991&#x2F;article&#x2F;details&#x2F;52537782\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\nWORD g_cs0, g_ss0, g_ds0, g_es0, g_fs0, g_gs0;\nDWORD r0_data_lowdword, r0_data_hidword;\n\n__declspec(naked) void getData() &#123;\n\t__asm &#123;\n\t\tpushfd\n\t\tpushad\n\t\tmov g_cs0, cs\n\t\tmov g_ss0, ss\n\t\tmov g_ds0, ds\n\t\tmov g_es0, es\n\t\tmov g_fs0, fs\n\t\tmov g_gs0, gs\n\t\tmov eax, 0x8003f048\n\t\tmov eax, [eax]\n\t\tmov r0_data_lowdword, eax\n\t\tmov eax, 0x8003f04c\n\t\tmov eax, [eax]\n\t\tmov r0_data_hidword, eax\n\t\tpopad\n\t\tpopfd\n\t\tretf\n\t&#125;\n&#125;\n\nvoid printData() &#123;\n\tprintf(&quot;g_cs0&#x3D;%02x\\ng_ss0&#x3D;%02x\\ng_ds0&#x3D;%02x\\ng_es0&#x3D;%02x\\ng_fs0&#x3D;%02x\\ng_gs0&#x3D;%02x\\nr0_data(0x8003f048)&#x3D;%08x %08x\\n&quot;, \n\t\tg_cs0, g_ss0, g_ds0, g_es0, g_fs0, g_gs0, r0_data_hidword, r0_data_lowdword);\n&#125;&#x2F;&#x2F;r0_data(0x8003f048)&#x3D;0040ec00 00081030\n\nint main(int argc, char* argv[]) &#123;\n\tchar cs_eip[6] &#x3D; &#123;0, 0, 0, 0, 0x48, 0&#125;;&#x2F;&#x2F; 这里的 eip 被废弃\n\t__asm &#123;\n\t\tcall fword ptr [cs_eip]\n\t&#125;\n\tprintData();\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F;有参\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;q1007729991&#x2F;article&#x2F;details&#x2F;52542296\nint g_a, g_b, g_c;\n__declspec(naked) void getParam(int a, int b, int c) &#123;\n\t__asm &#123;\n\t\t&#x2F;&#x2F; int 3 &#x2F;&#x2F; 取消注释可以在WinDbg中看R0栈数据\n\t\tpushad &#x2F;&#x2F; 0x20 B\n\t\tpushfd &#x2F;&#x2F; 0x04 B\n\t\t&#x2F;&#x2F;             .- 8 个通用寄存器和标志寄存器占用大小\n\t\t&#x2F;&#x2F;             |     .- cs 和 eip 占用大小\n\t\t&#x2F;&#x2F;             |     |\n\t\tmov eax, [esp+0x24+0x08+0x08] &#x2F;&#x2F; 参数 a\n\t\tmov g_a, eax\n\t\tmov eax, [esp+0x24+0x08+0x04] &#x2F;&#x2F; 参数 b\n\t\tmov g_b, eax\n\t\tmov eax, [esp+0x24+0x08+0x00] &#x2F;&#x2F; 参数 c\n\t\tmov g_c, eax\n\t\tpopfd\n\t\tpopad\n\t\tretf 0x0c\n\t&#125;\n&#125;\nint main(int argc, char* argv[])\n&#123;\n\t&#x2F;&#x2F; 构造cs:eip\n\tchar cs_eip[6] &#x3D; &#123;0, 0, 0, 0, 0x48, 0&#125;;\n\t__asm &#123;\n\t\tpush 1\n\t\tpush 2\n\t\tpush 3\n\t\tcall fword ptr [cs_eip];\n\t&#125;\n\tprintf(&quot;g_a &#x3D; %d\\ng_b &#x3D; %d\\ng_c &#x3D; %d\\n&quot;, g_a, g_b, g_c);\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;08.阶段测试.xls???????????????????????????????????????????？？？？？？？？？？？？\n2.在第一题的基础上进行修改,实现通过翻墙的方式返回到其他地址【修改压入堆栈的值esp】\n#include &lt;windows.h&gt;\n\nBYTE GDT[6] &#x3D; &#123;0&#125;;\nDWORD dwH2GValue;\n\nvoid __declspec(naked) GetRegister()\n&#123;\n\t__asm\n\t&#123;\n\n\t\tmov eax,0x8003f00c\t&#x2F;&#x2F; 读取高2G内存\n\t\tmov ebx,[eax]\n\t\tmov dwH2GValue,ebx\n\t\tsgdt GDT;\t\t\t&#x2F;&#x2F; 读取GDT\n\n\t\tmov eax,0x1140118B\n\t\tmov [esp],eax \t\t&#x2F;&#x2F;\n\n\t\tretf\n\t&#125;\n&#125;\n\nvoid PrintRegister()\n&#123;\n\tDWORD GDT_ADDR &#x3D; *(PDWORD)(&amp;GDT[2]);\n\tWORD GDT_LIMIT &#x3D; *(PWORD)(&amp;GDT[0]);\n\n\tprintf(&quot;%x %x %x \\n&quot;, dwH2GValue, GDT_ADDR, GDT_LIMIT);\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\t__asm\n\t&#123;\n\t\tmov ebx,ebx\n\t\tmov ebx,ebx\n\t&#125;\n\n\tchar buff[6];\n\t*(DWORD*)&amp;buff[0] &#x3D; 0x12345678;\n\t*(WORD*)&amp;buff[4] &#x3D; 0x48;\t&#x2F;&#x2F; segment select\n\n\t__asm\n\t&#123;\n\t\tcall fword ptr[buff]\n\t&#125;\n\tprintf(&quot;%X\\n&quot;, temp);\n\tprintf(&quot;成功！\\n&quot;);\n\tscanf(&quot;%d&quot;, &amp;GDT);\n\n\tPrintRegister();\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n3.在第一题的基础上进行修改,在门中再建一个门跳转到其他地址\n&#x2F;&#x2F; Test_For_Call_Gate.cpp : Defines the entry point for the console application.\t\t\t\n&#x2F;&#x2F;\t\t\t\n\t\t\t\n#include &quot;stdafx.h&quot;\t\t\t\n#include &quot;stdio.h&quot;\t\t\t\n#include &quot;windows.h&quot;\t\t\t\n\t\t\t\nint temp;\t\t\t\nBYTE GDT[6] &#x3D; &#123;0&#125;;\t\t\t\nint x,y,z;\t\t\t\nvoid WuCanTiQuan();\t\t\t\n\t\t\t\nchar buff[6] &#x3D; &#123;0,0,0,0,0x48,0&#125;;\t\t\t\n\t\t\t\nvoid __declspec(naked) Test ()\t\t\t\n&#123;\t\t\t\n\t&#x2F;&#x2F;就是这个printf\t\t\n\t&#x2F;&#x2F;printf(&quot;chenggong\\n&quot;);\t\t\n\t_asm\t\t\n\t&#123;\t\t\n\t\tretf\t\n\t&#125;\t\t\n&#125;\t\t\t\n\t\t\t\n&#x2F;&#x2F;Address:00401005\t\t\t\nvoid __declspec(naked) WuCanTiQuan_naked()\t\t\t\n&#123;\t\t\t\n\t_asm\t\t\n\t&#123;\t\t\n\t\t&#x2F;&#x2F;int 3\t\n\t\t\tmov eax,0x8003f008\n\t\t\tmov ebx,[eax]\n\t\t\tmov ds:[temp],ebx\n\t\t\t\n\t\t\t\n\t&#125;\t\t\n\t*(DWORD*)0x8003f048 &#x3D; (DWORD)0x0040ec0000081030;\t\t\n\t_asm\t\t\n\t&#123;\t\t\n\t\tcall fword ptr[buff]\t\n\t\tretf\t\n\t&#125;\t\t\n&#125;\t\t\t\n\t\t\t\nint main(int argc, char* argv[])\t\t\t\n&#123;\t\t\t\n\t\t\t\n\tWuCanTiQuan();\t\t\n\t\t\t\n\treturn 0;\t\t\n&#125;\t\t\t\n\t\t\t\nvoid WuCanTiQuan()\t\t\t\n&#123;\t\t\t\n\tchar buffer[6];\t\t\n\t*(DWORD*)&amp;buffer[0] &#x3D; 0x12345678;\t\t\n\t*(WORD*)&amp;buffer[4] &#x3D; 0x48;\t\t\n\t_asm\t\t\n\t&#123;\t\t\n\t\tcall fword ptr[buffer]\t\n\t&#125;\t\t\n\t\t\t\n\tprintf(&quot;%X\\n&quot;,temp);\t\t\n\tprintf(&quot;成功!\\n&quot;);\t\t\n\tscanf(&quot;%d&quot;,&amp;GDT);\t\t\n&#125;\t\t\t\n&#x2F;&#x2F;Address:\t\t\t\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n&#x2F;&#x2F;中断门\n#include &lt;stdio.h&gt;\n\nint g_high2G; &#x2F;&#x2F; 在中断门中读取高2G内存保存进来。\nint g_eflagsBefore; &#x2F;&#x2F; 保存进入中断门前的 EFLAGS 寄存器。\nint g_eflagsAfter; &#x2F;&#x2F; 保存进入中断门里的 EFLAGS 寄存器。\nint g_eax; &#x2F;&#x2F; 待会在中断门里要用到 eax ，先把旧的保存到这里。\n\n__declspec(naked) void func() &#123;\n\t__asm &#123;\n\t\t&#x2F;*\n\t\t  此时栈结构：\n\t\t\t| eip3 | &lt;- esp0\n\t\t\t| cs3  |\n\t\t\t|eflags|\n\t\t\t| esp3 |\n\t\t\t| ss3  |\n\t\t *&#x2F;\n\t\tmov g_eax, eax\n\t\t&#x2F;&#x2F; 保存当前 eflags\n\t\tpushfd\n\t\tpop g_eflagsAfter\t&#x2F;&#x2F;???\n\t\t&#x2F;&#x2F; 保存原始 eflags\n\t\tmov eax, [esp+0x08]\n\t\tmov g_eflagsBefore, eax\n\t\t&#x2F;&#x2F; 读取 8003f500 处的值\n\t\tmov eax, ds:[0x8003f500]\n\t\tmov g_high2G, eax\n\t\t&#x2F;&#x2F; 恢复 eax\n\t\tmov eax, g_eax\n\n\t\t&#x2F;&#x2F; 中断门返回\n\t\tiretd\n\t&#125;\n&#125;\nint main(int argc, char* argv[])\n&#123;\n\t__asm &#123;\n\t\t&#x2F;&#x2F; 构造的中断门描述符安装在 IDT[20] 这个位置。\n\t\tint 0x20;\n\t&#125;\n\tprintf(&quot;0x8003f500: %08x\\n&quot;, g_high2G);\n\tprintf(&quot;进入中断门前的 EFLAGS &#x3D; %08x\\n&quot;, g_eflagsBefore);\n\tprintf(&quot;进入中断门后的 EFLAGS &#x3D; %08x\\n&quot;, g_eflagsAfter);&#x2F;&#x2F;IF&#x3D;1-&gt;0\n\treturn 0;\n&#125;\n\n\n\n\n\n\n&#x2F;&#x2F;TSS切换实验\n&#x2F;&#x2F; 文件：tss.h\n#pragma once\n\ntypedef struct TSS &#123;\n\tDWORD link; &#x2F;&#x2F; 保存前一个 TSS 段选择子，使用 call 指令切换寄存器的时候由CPU填写。\n\t&#x2F;&#x2F; 这 6 个值是固定不变的，用于提权，CPU 切换栈的时候用\n\tDWORD esp0; &#x2F;&#x2F; 保存 0 环栈指针\n\tDWORD ss0;  &#x2F;&#x2F; 保存 0 环栈段选择子\n\tDWORD esp1; &#x2F;&#x2F; 保存 1 环栈指针\n\tDWORD ss1;  &#x2F;&#x2F; 保存 1 环栈段选择子\n\tDWORD esp2; &#x2F;&#x2F; 保存 2 环栈指针\n\tDWORD ss2;  &#x2F;&#x2F; 保存 2 环栈段选择子\n\t&#x2F;&#x2F; 下面这些都是用来做切换寄存器值用的，切换寄存器的时候由CPU自动填写。\n\tDWORD cr3; \n\tDWORD eip;  \n\tDWORD eflags;\n\tDWORD eax;\n\tDWORD ecx;\n\tDWORD edx;\n\tDWORD ebx;\n\tDWORD esp;\n\tDWORD ebp;\n\tDWORD esi;\n\tDWORD edi;\n\tDWORD es;\n\tDWORD cs;\n\tDWORD ss;\n\tDWORD ds;\n\tDWORD fs;\n\tDWORD gs;\n\tDWORD ldt;\n\t&#x2F;&#x2F; 这个暂时忽略\n\tDWORD io_map;\n&#125; TSS;\n\n\n\n\n&#x2F;&#x2F; 文件：SwitchTSS.cpp\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &quot;tss.h&quot;\n\nchar st[10] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 0042b034\n\nDWORD g_esp;\nDWORD g_cs;\n\nTSS tss &#x3D; &#123;&#x2F;&#x2F; 0x00427b40\n\t\t0x00000000,&#x2F;&#x2F;link\n\t\t(DWORD)st,&#x2F;&#x2F;esp0\n\t\t0x00000010,&#x2F;&#x2F;ss0\n\t\t0x00000000,&#x2F;&#x2F;esp1\n\t\t0x00000000,&#x2F;&#x2F;ss1\n\t\t0x00000000,&#x2F;&#x2F;esp2\n\t\t0x00000000,&#x2F;&#x2F;ss2\n\t\t0x00000000,&#x2F;&#x2F;cr3\n\t\t0x0040fad0,&#x2F;&#x2F;eip\n\t\t0x00000000,&#x2F;&#x2F;eflags\n\t\t0x00000000,&#x2F;&#x2F;eax\n\t\t0x00000000,&#x2F;&#x2F;ecx\n\t\t0x00000000,&#x2F;&#x2F;edx\n\t\t0x00000000,&#x2F;&#x2F;ebx\n\t\t(DWORD)st,&#x2F;&#x2F;esp\n\t\t0x00000000,&#x2F;&#x2F;ebp\n\t\t0x00000000,&#x2F;&#x2F;esi\n\t\t0x00000000,&#x2F;&#x2F;edi\n\t\t0x00000023,&#x2F;&#x2F;es  \n\t\t0x00000008,&#x2F;&#x2F;cs  \n\t\t0x00000010,&#x2F;&#x2F;ss\n\t\t0x00000023,&#x2F;&#x2F;ds\n\t\t0x00000030,&#x2F;&#x2F;fs\n\t\t0x00000000,&#x2F;&#x2F;gs\n\t\t0x00000000,&#x2F;&#x2F;ldt\n\t\t0x20ac0000\n&#125;;\n\n__declspec(naked) func() &#123;&#x2F;&#x2F;0040FAD0\n\t__asm &#123;\n\t\tmov g_esp, esp\n\t\tmov eax, 0\n\t\tmov ax, cs\n\t\tmov g_cs, eax\n\n\t\tiret\n\t&#125;\n&#125;\nint main(int argc, char* argv[])\n&#123;\n\tprintf(&quot;please input cr3:\\n&quot;);\n\tscanf(&quot;%x&quot;, &amp;(tss.cr3));\n\n\tchar buffer[6] &#x3D; &#123;0, 0, 0, 0, 0x48, 0&#125;;\n\t__asm &#123;\n\t\tcall fword ptr [buffer]\n\t&#125;\n\n\t&#x2F;&#x2F; 不出意外，这里打印的值分别是 00000008, 0042b034\n\tprintf(&quot;g_cs &#x3D; %08x\\ng_esp &#x3D; %08x\\n&quot;, g_cs, g_esp);\n\treturn 0;\n&#125;\n\n&#x2F;*\n1.\neq 8003f048 0000e942&#96;7b400068\t【mem窗口看 427b40:tss.base】\n最后一个字节0x68如何得来的呢?\n这是 io_map 字段，固定大小 104，二进制 0x68. 固定值即可。\n2.\nCR3 需要在 WinDbg 中查看。在 WinDbg 中使用命令 !process 0 0来查看程序SwitchTSS.exe 的 DirBase\n3.\n怎么看全局变量tss的首地址，在调试时打开memory子窗口，然后在address一栏输入tss，回车，第一行左边的地址就是tss在内存中的地址了\n4.\n#如果运行到iret蓝屏解决方法# vc用ctrl+f5直接跑。 不要使用f5调试模式。（这会设置tf位而导致试验失败！）\n不止单步会出问题 ，如果函数里有int3的话也会出问题。去掉就可以返回来的。\n5.\ncall 执行执行任务切换（记住，是切换一堆寄存器）。本实验并没有使用 jmp，\n 如果使用 jmp 的话，唯一的区别就是在测试函数那里返回不要使用 iret 指令，否则一定会蓝屏的。\n call的话会保存上一个tss，所以直接iret就成。 如果用jmp，需要自己在内存构造一块tss内存，自己填写值。\n\n在分别使用 call 和 jmp 的时候，有两个地方需要观察一下：1. EFLAGS寄存器 2. TSS 的 link 域。\n\nJMP FAR和CALL FAR访问任务段的区别:\n当使用JMP FAR来实现任务切换时，TSS结构体中的Previous Task Link的值在任务切换完成之后为0，CPU不会为其赋值；\n如果使用CALL FAR来实现任务切换，Previous Task Link的值在任务切换完成之后会CPU会将其填充为原来的TSS段选择子 \n\n当使用JMP FAR来实现任务切换时，EFLAGS寄存器中的NT位不变；\n当使用CALL FAR来实现任务切换时，EFLAGS寄存器中的NT位就会被置1\n(NT位会对iret指令产生影响 NT位如果为0，iret的值从堆栈中取(中断返回)；如果NT位为1，会找TSS中的Previous Task Link进行返回)\n\n*&#x2F;\n\n\n\n&#x2F;&#x2F; 文件：TaskGate.cpp\n#include &lt;windows.h&gt;\n#include &quot;tss.h&quot; &#x2F;&#x2F; tss.h 文件请移步至第11篇《TSS切换实验》中查看。\n\nchar st[10] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 0042ace4\n\nDWORD g_esp;\nDWORD g_cs;\n\nTSS tss &#x3D; &#123;&#x2F;&#x2F; 0x00427a30\n\t\t0x00000000,&#x2F;&#x2F;link\n\t\t(DWORD)st,&#x2F;&#x2F;esp0\n\t\t0x00000010,&#x2F;&#x2F;ss0\n\t\t0x00000000,&#x2F;&#x2F;esp1\n\t\t0x00000000,&#x2F;&#x2F;ss1\n\t\t0x00000000,&#x2F;&#x2F;esp2\n\t\t0x00000000,&#x2F;&#x2F;ss2\n\t\t0x00000000,&#x2F;&#x2F;cr3\n\t\t0x00401020,&#x2F;&#x2F;eip\n\t\t0x00000000,&#x2F;&#x2F;eflags\n\t\t0x00000000,&#x2F;&#x2F;eax\n\t\t0x00000000,&#x2F;&#x2F;ecx\n\t\t0x00000000,&#x2F;&#x2F;edx\n\t\t0x00000000,&#x2F;&#x2F;ebx\n\t\t(DWORD)st,&#x2F;&#x2F;esp\n\t\t0x00000000,&#x2F;&#x2F;ebp\n\t\t0x00000000,&#x2F;&#x2F;esi\n\t\t0x00000000,&#x2F;&#x2F;edi\n\t\t0x00000023,&#x2F;&#x2F;es  \n\t\t0x00000008,&#x2F;&#x2F;cs  \n\t\t0x00000010,&#x2F;&#x2F;ss\n\t\t0x00000023,&#x2F;&#x2F;ds\n\t\t0x00000030,&#x2F;&#x2F;fs\n\t\t0x00000000,&#x2F;&#x2F;gs\n\t\t0x00000000,&#x2F;&#x2F;ldt\n\t\t0x20ac0000\n&#125;;\n\n__declspec(naked) func() &#123;&#x2F;&#x2F;00401020\n\t__asm &#123;\n\t\tmov g_esp, esp\n\t\tmov eax, 0\n\t\tmov ax, cs\n\t\tmov g_cs, eax\n\n\t\tiretd\n\t&#125;\n&#125;\nint main(int argc, char* argv[])\n&#123;\n\tprintf(&quot;please input cr3:\\n&quot;); \n\tscanf(&quot;%x&quot;, &amp;(tss.cr3)); &#x2F;&#x2F; 使用 !process 0 0 查看\n\n\t__asm &#123;\n\t\tint 0x20\n\t&#125;\n\n\t&#x2F;&#x2F; 不出意外，这里打印的值分别是 00000008, 0042ace4\n\tprintf(&quot;g_cs &#x3D; %08x\\ng_esp &#x3D; %08x\\n&quot;, g_cs, g_esp);\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;页的机制\n\n&#x2F;&#x2F;PDE PTE\n&#x2F;&#x2F;0地址读写\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nint main(int argc, char *argv[])\n&#123;\n\tint x &#x3D; 1;\n\n\tprintf(&quot;x的地址：%x\\n&quot;, &amp;x);\n\n\tgetchar();\n\n\t&#x2F;&#x2F; 向0地址写入数据\n\t*(int*)0 &#x3D; 123;\n\t&#x2F;&#x2F; 从0地址读出数据\n\tprintf(&quot;0地址的数据：&quot;, *(int*)0);\n\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;不提权读取高2G内存\nint main(int argc, char* argv[])\n&#123;\n\tint *p &#x3D; (int*)0x8003f00c;\n\tgetchar();\n\tprintf(&quot;%08x\\n&quot;, *p);\n\treturn 0;\n&#125;\n\n\n\n\n\n-------------------------------------------------------------\n\n&#x2F;&#x2F;实验3：通过修改物理页属性使字符串常量可修改\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nint main(int argc, char *argv[])\n&#123;\n\tchar *str &#x3D; &quot;Hello World&quot;;\n\n\tprintf(&quot;线性地址：%x&quot;, str);\n\n\tgetchar();\t\t\t\t\t\t&#x2F;&#x2F; 让程序执行到这里\n\n\t&#x2F;&#x2F;修改只读变量\n\tstr[0] &#x3D; &#39;M&#39;;\n\n\tprintf(&quot;修改后的值：%s\\n&quot;,str);\n\n\treturn 0;\n&#125;\n\n\n\n&#x2F;&#x2F;实验4：通过修改物理页属性使普通用户读取高2G内存\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nint main(int argc, char *argv[])\n&#123;\n\tPDWORD p &#x3D; (PDWORD)0x8003F00C;\n\n\tgetchar();\t\t\t&#x2F;&#x2F; 让程序运行到这里\n\n\tprintf(&quot;读取高2G内存：%x \\n&quot;, *p);\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;TLB实验\n&#x2F;&#x2F;PAE分页模式\n#include &lt;windows.h&gt;\n\nDWORD zero, one, two;\n\n__declspec(naked) \nvoid MountPageOnNull() &#123;\n\t__asm &#123;\n\t\tpush ebp\n\t\tmov ebp, esp\n\t\tsub esp, 0x100\n\t\tpush ebx\n\t\tpush esi\n\t\tpush edi\n\t&#125;\n\n\tDWORD* pPTE;\t&#x2F;&#x2F; 保存目标线性地址的 PTE 线性地址\n\tDWORD* pNullPTE; &#x2F;&#x2F; 0 地址的 PTE 线性地址\n\tpNullPTE &#x3D; (DWORD*)0xc0000000;\n\n\t&#x2F;&#x2F; 挂上 0x50000000 所在位置\n\tpPTE &#x3D; (DWORD*)(0xc0000000 + ((0x50000000 &gt;&gt; 9) &amp; 0x7ffff8));\t\n\t*pNullPTE &#x3D; *pPTE;\n\n\tzero &#x3D; *(DWORD*)0;\n\n\t&#x2F;&#x2F; 挂上 0x60000000 所在位置\n\tpPTE &#x3D; (DWORD*)(0xc0000000 + ((0x60000000 &gt;&gt; 9) &amp; 0x7ffff8));\t\n\t*pNullPTE &#x3D; *pPTE;\n\n\tone &#x3D; *(DWORD*)0;\n\n\t&#x2F;&#x2F; 刷新 TLB \n\t__asm &#123;\n\t\tmov eax, cr3\n\t\tmov cr3, eax\n\t&#125;\n\t\n\t&#x2F;&#x2F; 再次读取 0 地址位置的数据\n\ttwo &#x3D; *(DWORD*)0;\n\n\n\n\t__asm &#123;\n\t\tpop edi\n\t\tpop esi\n\t\tpop ebx\n\t\tmov esp, ebp\n\t\tpop ebp\n\t\tiretd\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 外壳包裹函数\n__declspec(naked)\nvoid MyMountPageOnNull() &#123;\n\t__asm &#123;\n\t\tint 0x20\n\t\tret\n\t&#125;\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\tDWORD* x &#x3D; (DWORD*)VirtualAlloc((LPVOID)0x50000000, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\tDWORD* y &#x3D; (DWORD*)VirtualAlloc((LPVOID)0x60000000, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\n\t*x &#x3D; 0x12345678;\n\t*y &#x3D; 0x87654321;\n\n\tif (x !&#x3D; (DWORD*)0x50000000 || y !&#x3D; (DWORD*)0x60000000) &#123;\n\t\tprintf(&quot;Error alloc!\\n&quot;);\n\t\treturn -1;\n\t&#125;\n\n\tMyMountPageOnNull();\n\n\tprintf(&quot;1. 读 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%08x\\n\\n&quot;, zero);\n\n\tprintf(&quot;2. 给 0 地址重新挂上物理页\\n\\n&quot;);\n\n\n\tprintf(&quot;3. 重新读取 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%08x\\n\\n&quot;, one);\n\n\tprintf(&quot;4. 刷新 TLB \\n\\n&quot;);\n\n\tprintf(&quot;5. 再次读取 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%08x\\n&quot;, two);\n\n\t\n\treturn 0;\n&#125;\n\n\n\n\n\n&#x2F;&#x2F;TLB    10-10-12分页模式\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nDWORD x, y, z;\n\nvoid __declspec(naked) PageOnNull() &#123;\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;保存现场\n\t\tpush ebp\n\t\tmov ebp, esp\n\t\tsub esp, 0x100\n\t\tpush ebx\n\t\tpush esi\n\t\tpush edi\n\t&#125;\n\n\tDWORD* pPTE;\t\t\t&#x2F;&#x2F; 保存目标线性地址的 PTE 线性地址\n\tDWORD* pNullPTE;\t\t&#x2F;&#x2F; 0 地址的 PTE 线性地址\n\tpNullPTE &#x3D; (DWORD*)0xC0000000;\n\n\t&#x2F;&#x2F; 挂上 0x50000000 所在位置\n\tpPTE &#x3D; (DWORD*)(0xC0000000 + (0x50000000 &gt;&gt; 10));\n\t*pNullPTE &#x3D; *pPTE;\n\n\tx &#x3D; *(DWORD*)0;\n\n\t&#x2F;&#x2F; 挂上 0x60000000 所在位置\n\tpPTE &#x3D; (DWORD*)(0xC0000000 + (0x60000000 &gt;&gt; 10));\n\t*pNullPTE &#x3D; *pPTE;\n\n\ty &#x3D; *(DWORD*)0;\n\n\t&#x2F;&#x2F; 刷新 TLB\n\t__asm &#123;\n\t\tmov eax, cr3\n\t\tmov cr3, eax\n\t&#125;\n\t\n\t&#x2F;&#x2F; 再次读取 0 地址位置的数据\n\tz &#x3D; *(DWORD*)0;\n\n\n\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;恢复现场\n\t\tpop edi\n\t\tpop esi\n\t\tpop ebx\n\t\tmov esp, ebp\n\t\tpop ebp\n\t\tiretd\n\t&#125;\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\tDWORD* p5 &#x3D; (DWORD*)VirtualAlloc((LPVOID)0x50000000, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\tDWORD* p6 &#x3D; (DWORD*)VirtualAlloc((LPVOID)0x60000000, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\n\tif (p5 !&#x3D; (DWORD*)0x50000000 || p6 !&#x3D; (DWORD*)0x60000000)\n\t&#123;\n\t\tprintf(&quot;Error alloc!\\n&quot;);\n\t\treturn -1;\n\t&#125;\n\n\t*p5 &#x3D; 0x1234;\n\t*p6 &#x3D; 0x5678;\n\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F; 通过中断门提权\n\t\tint 0x20\n\t&#125;\n\n\tprintf(&quot;1. 读 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%x \\n\\n&quot;, x);\n\n\tprintf(&quot;2. 给 0 地址重新挂上物理页\\n\\n&quot;);\n\n\tprintf(&quot;3. 重新读取 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%x \\n\\n&quot;, y);\n\n\tprintf(&quot;4. 刷新 TLB \\n\\n&quot;);\n\n\tprintf(&quot;5. 再次读取 0 地址数据:\\n&quot;);\n\tprintf(&quot;*NULL &#x3D; 0x%x \\n&quot;, z);\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41490873&#x2F;article&#x2F;details&#x2F;89847738\n&#x2F;*\n1. 给定一个线性地址，和长度，读取内容；\nint ReadMemory(OUT BYTE* buffer,IN DWORD dwAddr,IN DWORD dwLeght)\n要求：\n1) 可以自己指定分页方式。\n2) 页不存在，要提示，不能报错。\n3) 可以正确读取数据。\n\n说说思路吧，如果给出的线性地址+读取的长度没有超过0x1000。那么这种情况很好处理，判断PDE和PTE的p都为1就行了\n如果超过了1页，把线性地址加上0x1000那么这个值肯定就对应下一个物理页了。再次判断一下PDE和PTE的p位，注意下细节就好了。\n*&#x2F;\n\n&#x2F;&#x2F; readPageAttr.cpp : 定义控制台应用程序的入口点。\n&#x2F;&#x2F;调用门描述符 eq 8003f048 0041ec00&#96;00081087\n\n#include &quot;stdafx.h&quot;\n#include &lt;Windows.h&gt;\nDWORD dwPDT_Index&#x3D;0;\nDWORD dwPTT_Index&#x3D;0;\nDWORD dwPageIndex&#x3D;0;\nDWORD result&#x3D;0;\nbool bRead&#x3D;false;  &#x2F;&#x2F;地址是否可读标志 true为可正常读\nvoid CallGate();\nvoid _declspec(naked) test()\n&#123;\n\n\n\t_asm\n\t&#123;\n\t\t\n\t\tpush 0x30&#x2F;&#x2F;???\n\t\tpop fs&#x2F;&#x2F;\n\n\t\tpushad\n\t\tpushfd\n\n\t\txor eax,eax\n\t\tmov bRead,al\n\n\t\t&#x2F;&#x2F;PDE&#x3D;0xc0300000+PDI*4\n\t\tmov eax,0xc0300000 \n\t\t&#x2F;&#x2F;dwPDT_Index&#x3D;PDI\n\t\tmov ecx,dwPDT_Index\n\t\tshl ecx,2\n\t\t&#x2F;&#x2F;eax&#x3D;PDE的指针\n\t\tadd eax,ecx\n\t\t&#x2F;&#x2F;读出pde的值\n\t\tmov ebx,[eax]\n\t\t&#x2F;&#x2F;保存在全局变量PDE\n\t\t&#x2F;&#x2F;判断PDE的p位是否为1\n\t\ttest ebx,0x1\n\t\tjz end\n\n\t\t&#x2F;&#x2F;解析PTE 0xc0000000+PDI*4096+PTI*4\n\t\t&#x2F;&#x2F;在上面已经移了2位  再左移10位就是4096\n\t\tshl ecx,10\n\t\t&#x2F;&#x2F;eax&#x3D;PTI\n\t\tmov eax,dwPTT_Index\n\t\tshl eax,2\n\t\t&#x2F;&#x2F;ebx&#x3D;PTE的指针\n\t\tmov ebx,0xc0000000\n\t\tadd ebx,eax\n\t\tadd ebx,ecx\n\t\tmov ebx,[ebx]\n\t\t&#x2F;&#x2F;判断PTE的p位\n\t\ttest ebx,0x1\n\t\tjz end\n\t\t\n\t\t&#x2F;&#x2F;设置bRead为1\n\t\txor eax,eax\n\t\tmov al,0x1\n\t\tmov bRead,al\n\nend:\tpopfd\n\t\tpopad\n\t\tretf\n\t&#125;\n\n&#125;\n\n\n\nvoid ParsePage(DWORD dwAddr)\n&#123;\n\t&#x2F;&#x2F;10  10  12分页模式\n\t&#x2F;&#x2F;获取PDT索引\n\tdwPDT_Index&#x3D;(dwAddr&gt;&gt;22);\n\t&#x2F;&#x2F;获取PTT的索引\n\tdwPTT_Index&#x3D;((dwAddr&lt;&lt;10)&gt;&gt;22);\n\n\tdwPageIndex&#x3D;(dwAddr&amp;0xfff);\n\tprintf(&quot;dwPTT_Index&#x3D;%x&quot;,dwPTT_Index);\n\tCallGate();&#x2F;&#x2F;长调用跨段提权\n\t\n\n&#125;\n\nvoid CallGate()\n&#123;\n\tchar buffer[6]&#x3D;&#123;0&#125;;\n\t*(DWORD*)&amp;buffer[0]&#x3D;0;\n\t*(WORD*)&amp;buffer[4]&#x3D;0x4b;&#x2F;&#x2F;段选择子  01001[idx&#x3D;9] 0[GDT] 11[R3]\n\t_asm\n\t&#123;\n\t\tcall fword ptr [buffer]\n\t\tpush 0x3b\t&#x2F;&#x2F;？ 0011 1011   12、调用门（无参）？？？？？？\n\t\tpop fs \t\t&#x2F;&#x2F;?\n\t&#125;\n\n&#125;\n\n\nbool ReadMemory(OUT void*buffer,IN DWORD dwAddr,IN DWORD\n\t\t\t\tdwlength)\n&#123; \n\t&#x2F;&#x2F;自己制定分页方式 10 10 12\n\t&#x2F;&#x2F;页不存在，要提示不能报错\n\t&#x2F;&#x2F;如果dwAddr+dwLength&gt;0x1000则发生跨页，需要检查两个页\n\tprintf(&quot;dwAddr&#x3D;%x&quot;,dwAddr);\n\tif((dwAddr&amp;0xfff+dwlength)&gt;0x1000)\n\t&#123;\n\t\t&#x2F;&#x2F;判断是否可读\n\t\tParsePage(dwAddr);\n\t\tif (bRead)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;如果该物理页可读，则判断下一个物理页  该线性地址+0x1000\n\t\t\t&#x2F;&#x2F;就肯定是下一个物理页了\n\t\t\tParsePage((dwAddr+0x1000));\n\t\t\tif (bRead)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;到这里说明是两个物理页都是可读的，读取值\n\t\t\t\tmemcpy_s(buffer,dwlength,(DWORD*)dwAddr,dwlength);\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t\t\n\t\t&#125; \n\t\t\t\n\t\n\n\t&#125;\n\telse\n\t&#123;\n\t\tParsePage(dwAddr);\n\t\tif (bRead)\n\t\t&#123;\n\t\t\n\t\t\t&#x2F;&#x2F;到这里说明该物理页是可读的，读取值\n\t\t\tmemcpy_s(buffer,dwlength,(DWORD*)dwAddr,dwlength);\n\t\t\treturn true;\n\t\t&#125; \n\t\t\n\t&#125;\n\n\treturn false;\n\t\t\n&#125;\n\nint _tmain(int argc, _TCHAR* argv[])\n&#123;\n\n\tDWORD buf[100]&#x3D;&#123;0&#125;;\n\tprintf(&quot;调用门地址：%x\\n&quot;,test);&#x2F;&#x2F;test()函数首地址\n\tint *p&#x3D;(int *)0x11ffc;\n\t*p&#x3D;0x12345678;\n\tBOOL bRet&#x3D;ReadMemory(buf,0x11ffc,4);&#x2F;&#x2F;ffc+4&#x3D;0x1000 没跨页\n\t\t\n\t\n\tif (bRet)\n\t&#123;\n\t\tfor(int i&#x3D;0;i&lt;1;i++)&#123;\n\t\t\tprintf(&quot;\\n 内存读取成功\\n buf[%d]&#x3D;%x&quot;,i,buf[i]);&#x2F;&#x2F; 1 2 3 4 5 6 7 8\n\t\t&#125;\n\t&#125; \n\telse\n\t&#123;\n\t\tprintf(&quot;内存读取失败&quot;);\n\t&#125;\n\tgetchar();\n\treturn 0;\n\t\n&#125;\n\n\n\n\n\n&#x2F;*\n2.申请长度为100的DWORD的数组,且每项用该项的地址初始化；\n把[这个数组所在的物理页挂到0x1000的地址上];\n定义一个指针，指向0x1000这个页里的数组所在的地址,用0x1000这个页的线性地址打印出这数组的值；\n\n要求：\n数组所在的物理页，是同一个页；\n*&#x2F;\n\n&#x2F;&#x2F; protect2.cpp : 定义控制台应用程序的入口点。\n&#x2F;&#x2F;调用门描述符 eq 8003f048 0041【ec00&#96;0008】1087\n&#x2F;&#x2F;00411087:段偏移[看函数首址]\t  R3-&gt;R0段base\n#include &quot;stdafx.h&quot;\n#include&lt;windows.h&gt;\nDWORD dwPDT_Index&#x3D;0;\nDWORD dwPTT_Index&#x3D;0;\nDWORD dwPageIndex&#x3D;0;\nDWORD dwPDE;\nDWORD dwPTE;\n\n\nvoid CallGate()\n&#123;\n\tchar buffer[6]&#x3D;&#123;0&#125;;\n\t*(DWORD*)&amp;buffer[0]&#x3D;0;\n\t*(WORD*)&amp;buffer[4]&#x3D;0x4b;\n\t_asm\n\t&#123;\n\t\tcall fword ptr [buffer]\n\t\tpush 0x3b&#x2F;&#x2F;\n\t\tpop fs&#x2F;&#x2F;\n\t&#125;\n\n&#125;\n\nvoid _declspec(naked) test()\n&#123;\n\n\n\t_asm\n\t&#123;\n\n\t\t\tpush 0x30\n\t\t\tpop fs\n\t\t\tpushad\n\t\t\tpushfd\n\n\t\t\t&#x2F;&#x2F;PDE&#x3D;0xc0300000+PDI*4 参见23-24、PDT&#x2F;PTT基址\n\t\t\tmov eax,0xc0300000 \n\t\t\t&#x2F;&#x2F;dwPDT_Index&#x3D;PDI\n\t\t\tmov ecx,dwPDT_Index\n\t\t\tshl ecx,2\n\t\t\t&#x2F;&#x2F;eax&#x3D;PDE的指针\n\t\t\tadd eax,ecx\n\t\t\t&#x2F;&#x2F;读出pde的值\n\t\t\tmov eax,[eax]\n\t\t\tmov dwPDE,eax\n\n\t\t\t&#x2F;&#x2F;解析PTE 0xc0000000+PDI*4096+PTI*4\n\t\t\t&#x2F;&#x2F;在上面已经移了2位  再左移10位就是4096\n\t\t\tshl ecx,10\n\t\t\t&#x2F;&#x2F;eax&#x3D;PTI\n\t\t\tmov eax,dwPTT_Index\n\t\t\tshl eax,2\n\t\t\t&#x2F;&#x2F;ebx&#x3D;PTE的指针\n\t\t\tmov ebx,0xc0000000\n\t\t\tadd ebx,eax\n\t\t\tadd ebx,ecx\n\t\t\tmov ebx,[ebx]\n\t\t\tand ebx,0xfffff000\n\t\t\tor ebx,0x067\t&#x2F;&#x2F;线性地址后3位:067\n\t\t\tmov dwPTE,ebx\t&#x2F;&#x2F;dwPTE存物理页首址\n\t\t\t\n\n\t\t\t&#x2F;&#x2F;找出0x1000的PDE\n\t\t\tmov eax,0x1000\n\t\t\tshr eax,20\t &#x2F;&#x2F;??\n\t\t\tand eax,0xffc&#x2F;&#x2F;??\n\t\t\tmov ecx,eax  &#x2F;&#x2F;用ecx来保存PDI？？？？？？\n\t\t\tadd eax,0xc0300000\n\t\t\tint 3\n\t\t\t&#x2F;&#x2F;找到PDE&#x3D;0xc0300000+PDI(*4???)\n\t\t\tmov ebx,[eax]\n\t\t\t\n\t\t\t&#x2F;&#x2F;判断 如果无效 则挂一个dwPDE\n\t\t\ttest ebx,0\n\t\t\tjnz s\n\t\t\tmov ebx,dwPDE\n\t\t\tmov [eax],ebx\n\ns:\t\t\tmov eax,0x1000\n\t\t\tshl eax,10\n\t\t\tshr eax,20\n\t\t\t&#x2F;&#x2F;计算 PTI*4 ?????\n\t\t\tand eax,0xffc\n\t\t\t&#x2F;&#x2F;计算PDI*4096\n\t\t\tshl ecx,12\n\t\t\t&#x2F;&#x2F;解析PTE 0xc0000000+PDI*4096+PTI*4\n\t\t\tmov ebx,0xc0000000\n\t\t\tadd ebx,eax\n\t\t\tadd ebx,ecx\n\t\t\tmov eax,dwPTE\n\t\t\tmov [ebx],g_eax&#x2F;&#x2F;挂dwPTE：数组所在的物理页首址\n\n\t\t\tpopfd\n\t\t\tpopad\n\t\t\tretf\n\t&#125;\n\n&#125;\n\nvoid ParsePage(DWORD dwAddr)\n&#123;\n\t&#x2F;&#x2F;10  10  12分页模式\n\t&#x2F;&#x2F;获取PDT索引\n\tdwPDT_Index&#x3D;(dwAddr&gt;&gt;22);\n\t&#x2F;&#x2F;获取PTT的索引\n\tdwPTT_Index&#x3D;((dwAddr&lt;&lt;10)&gt;&gt;22);\n\n\tdwPageIndex&#x3D;(dwAddr&amp;0xfff);\n\tprintf(&quot;dwPTT_Index&#x3D;%x\\n&quot;,dwPTT_Index);\n\tCallGate();\n\n&#125;\n\n\n\nint _tmain(int argc, _TCHAR* argv[])\n&#123;\n\t&#x2F;&#x2F; 1.这个函数可以用来对虚拟地址空间进行分配(保留操作MEM_RESERVE) \n\t&#x2F;&#x2F; 2.这个函数可以把已经保留的虚拟地址提交到物理存储器(MEM_COMMIT) \n\tDWORD* dwAddr&#x3D;(DWORD*)VirtualAlloc(0,0x1000,MEM_COMMIT,PAGE_READWRITE);&#x2F;&#x2F;地址0开始的一页\n\tDWORD *p&#x3D;dwAddr;\n\tprintf(&quot;test&#x3D;%x   dwAddr&#x3D;%x\\n&quot;,test,(DWORD)dwAddr);\n\tfor (int i&#x3D;0;i&lt;100;i++)\n\t&#123;\n\t\t*p&#x3D;(DWORD)p;\n\t\tp++;\n\t&#125;\n\tParsePage((DWORD)dwAddr);\n\n\t&#x2F;&#x2F;3：定义一个指针，指向0x1000  使用指针打印出数组的值。\n\tdwAddr&#x3D;(DWORD*)0x1000;\n\tfor (int i&#x3D;0;i&lt;100;i++)\n\t&#123;\n\t\tprintf(&quot;test&#x3D;%x\\n&quot;,*dwAddr);\n\t\tdwAddr++;\n\t&#125;\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;API函数 系统调用\n\n\n&#x2F;*\n编写一个ReadProcessMemory函数\n要求：不使用任何DLL，直接调用0环函数\n意义：自己实现的API，可以避免3环程序被恶意挂钩\n*&#x2F;\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;102786700\n&#x2F;&#x2F;进程1\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n\tint num &#x3D; 0x12345678;\n\n\tprintf(&quot;&amp;num &#x3D; %x \\n&quot;, &amp;num);\n\n\tgetchar();\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;进程2 ?????????\nvoid MyReadProcessMemory(\n\tHANDLE hProcess, \n\tLPCVOID lpBaseAddress, \n\tLPVOID lpBuffer, \n\tDWORD nSize, \n\tLPDWORD lpNumberOfBytesRead)\n&#123;\n\t__asm\n\t&#123;\n\t\tlea  eax, [ebp+0x14]\n\t\tpush eax\t\t\t\t; ReturnLength\n\t\tpush [ebp+0x14]\t\t\t; BufferLength\n\t\tpush [ebp+0x10]\t\t\t; Buffer\n\t\tpush [ebp+0x0C]\t\t\t; BaseAddress\n\t\tpush [ebp+0x08]\t\t\t; ProcessHandle\n\n\t\tmov  eax, 0BAh\n\t\tmov  edx, esp\n\t\tint  02eh\t\t\t\t; Windows操作系统提供IDT[0x2e]给用户进行内核调用\n\t\t\n\t\tadd  esp, 20\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tDWORD pBuffer;\t\t\t\t\t\t\t&#x2F;&#x2F; 接收数据的缓冲区\n\tHANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, 0, PID);\t\t\t&#x2F;&#x2F; 获得进程句柄，PID修改为进程1的PID\n\tMyReadProcessMemory(hProcess, (PVOID)0x12ff7c, &amp;pBuffer, 4, 0);\t\t&#x2F;&#x2F; 调用自定义的ReadProcessMemory\n\n\tprintf(&quot;pBuffer &#x3D; %x \\n&quot;, pBuffer);\t\t&#x2F;&#x2F; 打印从其他进程中读取的数据\n\n\tgetchar();\n\treturn 0;\n&#125;\n&#x2F;&#x2F;成功从进程1中读取了变量num的值！\n\n\n&#x2F;&#x2F;R\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;onetrainee&#x2F;p&#x2F;11704626.html\n\n&#x2F;&#x2F;W？？？？？？？？？\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;dubh3&#x2F;p&#x2F;13322156.html\n&#x2F;*\n分析过程如下：\n\n1.先正常的调用WriteProcessMemory函数，然后在OllyDbg中跟踪它，\n看他执行到 NtWriteProcessMemory 时的堆栈是什么样的，观察我们传进去的每一个参数在栈中此时的位置\n2.进入 NtWriteProcessMemory ，看下此时我们的栈又发生了什么变化\n3.根据参数在栈中的变化，以及分析执行完后栈要怎么平衡回去才能让我们的函数正常返回\n*&#x2F;\n#include &quot;stdio.h&quot;\n#include &quot;windows.h&quot;\n\nvoid MyWriteProcessMemory(HANDLE hProcess,LPVOID lpBaseAddress,LPVOID lpBuffer,DWORD nSize,LPDWORD lpNumberOfBytesWritten)\n&#123;\n\t_asm\n\t&#123;\n\t\tlea eax,[ebp+0x18]\n\t\tpush eax 　　　　　　　　&#x2F;&#x2F;lpNumberOfBytesWritten10         push [ebp+0x14]　　　　　&#x2F;&#x2F;nSize\n\t\tpush [ebp+0x10]　　　　&#x2F;&#x2F;lpBuffer\n\t\tpush [ebp+0xc]　　　　&#x2F;&#x2F;lpBaseAddress\n\t\tpush [ebp+8]　　　　　　&#x2F;&#x2F;hProcess\n\t\tsub esp,4　　　　　　　　&#x2F;&#x2F;平衡堆栈，因为在call NtWriteProcessMemory后，栈中会压入一个4字节数据（我们不用管这4字节数据干嘛的）\n\t\tmov eax,0x115　　　　　　&#x2F;&#x2F;把服务号保存在eax中\n\t\tmov edx,0x7FFE0300　　　　&#x2F;&#x2F;获取SystemCall中的地址\n\t\tcall dword ptr [edx]   &#x2F;&#x2F;调用SystemCall　　18         add esp,0x18　　　　　　&#x2F;&#x2F;本来这个call后面是跟retn 0x14的，我们是自己写的程序，不能返回到它那里去，我们只需要平衡到这段代码执行之前的esp就行了\n\t&#125;\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\tchar inBuffer[10] &#x3D; &quot;abcdefg&quot;;　　&#x2F;&#x2F;要写入的数据\n\tchar strA[10] &#x3D; &#123;0&#125;;　　&#x2F;&#x2F;要写入数据的缓冲区　　\n\tSIZE_T size &#x3D; 0;　　　　&#x2F;&#x2F;接收实际的数据长度\n\tMyWriteProcessMemory((HANDLE)-1,strA,inBuffer,9,&amp;size);　　&#x2F;&#x2F;其实和WriteProcessMemory的参数一样，我们采用这种方式来调用自己的函数，开头的-1表示操作的进程是自己\n\tprintf(&quot;%s\\n&quot;,strA);　　　　&#x2F;&#x2F;打印strA，如果写入成功，会打印出上面的 abcdefg\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;&#x2F;【进程线程】\n练习 ：通过进程结构体遍历所有的进程\n\tULONG ProcessListHead&#x3D;0;\n\tPLIST_ENTRY pListHead;\n\tPLIST_ENTRY pListNext;\n\t__asm&#123;\n\t\n\t\tmov eax,fs:124h\n\t\tmov ebx,[eax+220h]  &#x2F;&#x2F;得到线程结构体\n\t\tmov ProcessListHead,ebx\n\t&#125;\n\n\tpListHead&#x3D;(PLIST_ENTRY)(ProcessListHead+0x88);\n\tpListNext&#x3D;pListHead;\n\t\n\tdo\n\t&#123;\n\t\n\t\tDbgPrint(&quot;ImageFileName&#x3D;%s\\n&quot;,(PULONG)pListNext-0x88&#x2F;4+0x174&#x2F;4);\n\t\t\n\t\tpListNext&#x3D;pListNext-&gt;Flink;\n\t&#125;while(pListHead!&#x3D;pListNext);\n\n\n\n\n\n\n\n\n\n（五）—— 模拟线程切换\n&#x2F;&#x2F; ThreadSwitch.cpp : Defines the entry point for the console application.\n&#x2F;&#x2F;\n\n#include &quot;stdafx.h&quot;\n#include &quot;ThreadCore.h&quot;\n\nint main(int argc, char* argv[])\n&#123;\n\t&#x2F;&#x2F;初始化线程环境\n\tRegisterGMThread(&quot;Thread1&quot;,Thread1,NULL);\n\tRegisterGMThread(&quot;Thread2&quot;,Thread2,NULL);\n\tRegisterGMThread(&quot;Thread3&quot;,Thread3,NULL);\n\tRegisterGMThread(&quot;Thread4&quot;,Thread4,NULL);\n\n    &#x2F;&#x2F;仿Windows线程切换\n\tfor (;;)\n\t&#123;\n\t\tSleep(20);\n\t\tThreadPolling();\n\t&#125;\n\t\n\treturn 0;\n&#125;\n\n\n&#x2F;&#x2F; ThreadCore.h: interface for the ThreadCore class.\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n#if !defined(AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_)\n#define AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_\n\n#if _MSC_VER &gt; 1000\n#pragma once\n#endif &#x2F;&#x2F; _MSC_VER &gt; 1000\n\n\n\n#define MAXGMTHREAD\t0x100\n\n\n#define GMTHREAD_CREATE\t\t0x01\n#define GMTHREAD_READY\t\t0x02\n#define GMTHREAD_RUNING\t\t0x04\n#define GMTHREAD_SLEEP\t\t0x08\n#define GMTHREAD_SUSPEND\t0x10\n#define GMTHREAD_EXIT\t0x100\n\ntypedef struct\n&#123;\n\tchar *name;\t\t\t\t\t&#x2F;&#x2F; 线程名 相当于线程TID\n\tint Flags;\t\t\t\t\t&#x2F;&#x2F; 线程状态\n\tint SleepMillisecondDot;\t&#x2F;&#x2F; 休眠时间\n\t\n\tvoid *InitialStack;\t\t\t&#x2F;&#x2F; 线程堆栈起始位置，也就是EBP\n\tvoid *StackLimit;\t\t\t&#x2F;&#x2F; 线程堆栈界限\n\tvoid *KernelStack;\t\t\t&#x2F;&#x2F; 线程堆栈当前位置，也就是ESP\n\t\n\tvoid *lpParameter;\t\t\t&#x2F;&#x2F; 线程函数的参数\n\tvoid (*func)(void *lpParameter);\t&#x2F;&#x2F; 线程函数\n\t\n&#125; GMThread_t;\t\n\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\n&#x2F;* 线程结构体数组\n * 线程在不同状态的存储位置不同\n * 正在运行的线程位于KPCR\n * 等待中的线程位于等待链表\n * 就绪的线程位于调度链表中\n * 这里对于以上三种情况使用一个数组进行包含\n * main函数也是一个线程，信息存在第一个数组成员里，也就是下标为0的位置\n * 创建线程时，是从下标为1的位置开始分配的\n *&#x2F;\nextern GMThread_t GMThreadList[MAXGMTHREAD];\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\nvoid IdleGMThread(void *lpParameter);\n\nvoid GMThreadStartup(GMThread_t *GMThreadp);\nvoid initGMThread(GMThread_t *GMThreadp,char *name,void (*func)(void *lpParameter),void *lpParameter);\nint RegisterGMThread(char *name,void (*func)(void *lpParameter),void *lpParameter);\nvoid Scheduling(void);\n\nvoid GMSleep(int Milliseconds);\n\nvoid ThreadPolling();\n\nvoid Thread1(void *lpParameter);\nvoid Thread2(void *lpParameter);\nvoid Thread3(void *lpParameter);\nvoid Thread4(void *lpParameter);\n\n#endif &#x2F;&#x2F; !defined(AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_)\n\n\n\n\n\n&#x2F;&#x2F;ThreadCore.cpp\n#include &quot;stdafx.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;windows.h&quot;\n\n#include &quot;ThreadCore.h&quot;\n\n#define _SELF\t\t&quot;滴水_仿Windows线程切换&quot;\n\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\nint CurrentThreadindex &#x3D; 0;\nGMThread_t GMThreadList[MAXGMTHREAD] &#x3D; &#123; NULL,0 &#125;;\n\n#define GMTHREADSTACKSIZE 0x80000\n\nvoid *WindowsStackLimit &#x3D; NULL;\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\n__declspec(naked) void SwitchContext(GMThread_t *SrcGMThreadp,GMThread_t *DstGMThreadp)\n&#123;\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;保存现场\n\t\tpush ebp\n\t\tmov  ebp,esp\n\t\t&#x2F;&#x2F;sub esp,__LOCAL_SIZE\n\t\tpush edi\n\t\tpush esi\n\t\tpush ebx\n\t\tpush ecx\n\t\tpush edx\n\t\tpush eax\n\t\t\n\t\tmov esi,SrcGMThreadp\t&#x2F;&#x2F;当前线程结构体指针\n\t\tmov edi,DstGMThreadp\t&#x2F;&#x2F;目标线程结构体指针\n\n\t\t&#x2F;&#x2F; esi + GMThread_t.KernelStack &#x3D;&#x3D; SrcGMThreadp.KernelStack\n\t\tmov [esi+GMThread_t.KernelStack], esp\n\t\t&#x2F;&#x2F;---------------经典堆栈切换 另一个线程复活----------------------------------\n\t\t&#x2F;&#x2F; edi + GMThread_t.KernelStack &#x3D;&#x3D; DstGMThreadp.KernelStack\n\t\tmov esp, [edi+GMThread_t.KernelStack]\n\n\t\t&#x2F;&#x2F;此时，ESP为目标线程堆栈栈顶\n\t\tpop eax\n\t\tpop edx\n\t\tpop ecx\n\t\tpop ebx\n\t\tpop esi\n\t\tpop edi\n\t\t&#x2F;&#x2F;add esp,__LOCAL_SIZE\n\t\tpop ebp\n\t\tret\t\t&#x2F;&#x2F;ebp之后是GMThreadStartup函数地址\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;用来执行线程函数\nvoid GMThreadStartup(GMThread_t *GMThreadp)\n&#123;\n\t&#x2F;&#x2F;执行线程函数\n\tGMThreadp-&gt;func(GMThreadp-&gt;lpParameter);\n\t&#x2F;&#x2F;线程函数执行结束，设置线程状态为EXIT\n\tGMThreadp-&gt;Flags &#x3D; GMTHREAD_EXIT;\n\t&#x2F;&#x2F;线程切换\n\tScheduling();\n\n\treturn ;\n&#125;\n\nvoid IdleGMThread(void *lpParameter)\n&#123;\n\tScheduling();\n\treturn ;\n&#125;\n\nvoid PushStack(unsigned int **Stackpp,unsigned int v)\n&#123;\n\t&#x2F;&#x2F; ESP 减去一个单位（4个字节）\n\t*Stackpp -&#x3D; 1;\n\n\t&#x2F;&#x2F;[ESP] &#x3D; 参数v\n\t**Stackpp &#x3D; v;\n\n\treturn ;\n&#125;\n\nvoid initGMThread(GMThread_t *GMThreadp,char *name,void (*func)(void *lpParameter),void *lpParameter)\n&#123;\n\tunsigned char *StackPages;\n\tunsigned int *StackDWORDParam;\n\t\n    &#x2F;&#x2F;结构初始化赋值\n\tGMThreadp-&gt;Flags &#x3D; GMTHREAD_CREATE;\t\t&#x2F;&#x2F;初始化线程为创建状态\n\tGMThreadp-&gt;name &#x3D; name;\t\t\t\t\t&#x2F;&#x2F;线程名\n\tGMThreadp-&gt;func &#x3D; func;\t\t\t\t\t&#x2F;&#x2F;线程函数，已经定义好\n\tGMThreadp-&gt;lpParameter &#x3D; lpParameter;\t&#x2F;&#x2F;参数\n\t\n    &#x2F;&#x2F;申请堆栈空间\n\tStackPages &#x3D; (unsigned char*)VirtualAlloc(NULL,GMTHREADSTACKSIZE,MEM_COMMIT,PAGE_READWRITE);\n\t\n\t&#x2F;&#x2F;堆栈清零\n\tmemset(StackPages,0,GMTHREADSTACKSIZE);\n\t\n\t&#x2F;&#x2F;堆栈栈底（EBP）\n\tGMThreadp-&gt;InitialStack &#x3D; (StackPages+GMTHREADSTACKSIZE-0x10);\n\t\n\t&#x2F;&#x2F;堆栈边界地址\n\tGMThreadp-&gt;StackLimit &#x3D; StackPages;\n\t\n\tStackDWORDParam &#x3D; (unsigned int*)GMThreadp-&gt;InitialStack;\n\t\n\t&#x2F;&#x2F;入栈\n\tPushStack(&amp;StackDWORDParam,(unsigned int)GMThreadp);\t\t&#x2F;&#x2F;线程结构体自身指针，用来寻找 线程函数|函数参数\n\tPushStack(&amp;StackDWORDParam,(unsigned int)9);\t\t\t\t&#x2F;&#x2F;平衡堆栈\n\tPushStack(&amp;StackDWORDParam,(unsigned int)GMThreadStartup);\t&#x2F;&#x2F;函数地址，执行线程函数的入口函数\n\t&#x2F;&#x2F;下面的值可以随便写\n\tPushStack(&amp;StackDWORDParam,5); &#x2F;&#x2F;push ebp\n\tPushStack(&amp;StackDWORDParam,7); &#x2F;&#x2F;push edi\n\tPushStack(&amp;StackDWORDParam,6); &#x2F;&#x2F;push esi\n\tPushStack(&amp;StackDWORDParam,3); &#x2F;&#x2F;push ebx\n\tPushStack(&amp;StackDWORDParam,2); &#x2F;&#x2F;push ecx\n\tPushStack(&amp;StackDWORDParam,1); &#x2F;&#x2F;push edx\n\tPushStack(&amp;StackDWORDParam,0); &#x2F;&#x2F;push eax\n\t&#x2F;&#x2F;执行后，堆栈变化如下\n\n\tGMThreadp-&gt;KernelStack &#x3D; StackDWORDParam;\t&#x2F;&#x2F;指向当前线程的栈顶（ESP）\n\tGMThreadp-&gt;Flags &#x3D; GMTHREAD_READY;\t\t\t&#x2F;&#x2F;线程状态设置为就绪\n\n\treturn ;\n&#125;\n\nint RegisterGMThread(char *name,void (*func)(void *lpParameter),void *lpParameter)\n&#123;\n\tint i;\n\n\t&#x2F;&#x2F;为数组下标为0的成员赋值，IDLE GM Thread，相当于main函数线程\n\tif (GMThreadList[0].name&#x3D;&#x3D;NULL)\n\t&#123;\n\t\t&#x2F;&#x2F;申请堆栈初始化操作  线程数组 ，线程名字 ，函数地址 ，参数\n\t\tinitGMThread(&amp;GMThreadList[0], &quot;IDLE GM Thread&quot;, IdleGMThread, NULL);\n\t&#125;\n\n\t&#x2F;&#x2F;新增的线程从下标为1开始写入\n\tfor (i&#x3D;1;GMThreadList[i].name;i++)\n\t&#123;\n\t\t&#x2F;&#x2F;判断数组中尚未初始化的成员\n\t\tif (0&#x3D;&#x3D;stricmp(GMThreadList[i].name,name))\n\t\t&#123;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;初始化线程结构体\n\tinitGMThread(&amp;GMThreadList[i],name,func,lpParameter);\n\n\treturn (i|0x55AA0000);&#x2F;&#x2F;??????????\n&#125;\n\nvoid Scheduling(void)\n&#123;\n\tint i;\n\tint TickCount;\n\tGMThread_t *SrcGMThreadp;\n\tGMThread_t *DstGMThreadp;\n\n\tTickCount &#x3D; GetTickCount();\n\n\tSrcGMThreadp &#x3D; &amp;GMThreadList[CurrentThreadindex];\t\t&#x2F;&#x2F;当前线程结构体指针\n\tDstGMThreadp &#x3D; &amp;GMThreadList[0];\t\t\t\t\t\t&#x2F;&#x2F;目标线程结构体指针\n\n\t&#x2F;&#x2F;遍历线程数组，找到状态为就绪的线程\n\tfor (i&#x3D;1;GMThreadList[i].name;i++)\n\t&#123;\n\t\tif (GMThreadList[i].Flags&amp;GMTHREAD_SLEEP)\n\t\t&#123;\n\t\t\tif (TickCount&gt;GMThreadList[i].SleepMillisecondDot)\n\t\t\t&#123;\n\t\t\t\tGMThreadList[i].Flags &#x3D; GMTHREAD_READY;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif ((GMThreadList[i].Flags&amp;GMTHREAD_READY))\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;检测到有线程的状态为就绪，将其作为目标线程\n\t\t\tDstGMThreadp &#x3D; &amp;GMThreadList[i];\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\t\n\tCurrentThreadindex &#x3D; DstGMThreadp-GMThreadList;\t\t&#x2F;&#x2F;得到即将执行的线程下标\n\tSwitchContext(SrcGMThreadp,DstGMThreadp);\t\t\t&#x2F;&#x2F;线程切换\n\t\n\treturn ;\n&#125;\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n\nvoid GMSleep(int Milliseconds)\n&#123;\n\tGMThread_t *GMThreadp;\n\tGMThreadp &#x3D; &amp;GMThreadList[CurrentThreadindex];\n\n\tif ((GMThreadp-&gt;Flags&amp;GMTHREAD_SUSPEND)&#x3D;&#x3D;0)\n\t&#123;\n\t\tGMThreadp-&gt;SleepMillisecondDot &#x3D; GetTickCount()+Milliseconds;\n\t\tGMThreadp-&gt;Flags &#x3D; GMTHREAD_SLEEP;\n\t&#125;\n\n\t&#x2F;&#x2F;线程切换\n\tScheduling();\n\treturn ;\n&#125;\n\nvoid ThreadPolling()\n&#123;\n\tunsigned char StackPage[GMTHREADSTACKSIZE];\n\tmemset(StackPage,0,GMTHREADSTACKSIZE);\n\t&#x2F;&#x2F;模拟线程切换\n\tIdleGMThread(StackPage);\n\n\treturn ;\n&#125;\n\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\n&#x2F;&#x2F;---------------------------------------------------------------------------------------\nvoid vmmprint(char *f,int l,char *fmt, ...)\n&#123;\n\tint ret;\n\tchar buffer[0x100];\n\tva_list args;\n\t\n\t&#x2F;&#x2F;----------------------------------\n\tva_start(args, fmt);\n\t_snprintf(buffer,0x80,&quot;[%s]:&quot;,f,l);\n\tret &#x3D; _vsnprintf(buffer+strlen(buffer), 0x100-strlen(buffer), fmt, args);\n\tif (ret &#x3D;&#x3D; -1)\n\t&#123;\n\t\tstrcpy(buffer, &quot;vmmprint: error.&quot;);\n\t&#125;\n\t&#x2F;&#x2F;----------------------------------\n\tprintf(&quot;%s&quot;,buffer);\n\t&#x2F;&#x2F;OutputDebugString(buffer);\n\t\n\treturn ;\n&#125;\n\nvoid Thread1(void *lpParameter)\n&#123;\n\tint i;\n\tfor (i&#x3D;0;i&lt;3;i++)\n\t&#123;\n\t\tvmmprint(_SELF,__LINE__,&quot;Thread1 \\n&quot;);\n\t\tGMSleep(1000);\n\t&#125;\n\n\treturn ;\n&#125;\n\nvoid Thread2(void *lpParameter)\n&#123;\n\tfor (;;)\n\t&#123;\n\t\tvmmprint(_SELF,__LINE__,&quot;Thread2 \\n&quot;);\n\t\tGMSleep(500);\n\t&#125;\n\t\n\treturn ;\n&#125;\n\nvoid Thread3(void *lpParameter)\n&#123;\n\tfor (;;)\n\t&#123;\n\t\tvmmprint(_SELF,__LINE__,&quot;Thread3 \\n&quot;);\n\t\tGMSleep(800);\n\t&#125;\n\t\n\treturn ;\n&#125;\n\nvoid Thread4(void *lpParameter)\n&#123;\n\tfor (;;)\n\t&#123;\n\t\tvmmprint(_SELF,__LINE__,&quot;Thread4 \\n&quot;);\n\t\tGMSleep(200);\n\t&#125;\n\t\n\treturn ;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;二、驱动开发\n\n\n#include &quot;ntddk.h&quot;\n\n&#x2F;&#x2F;卸载函数\nVOID DriverUnload(PDRIVER_OBJECT driver)\n&#123;\n\tDbgPrint(&quot;驱动程序已停止.\\r\\n&quot;);\n&#125;\n\n&#x2F;&#x2F;驱动程序入口函数，相当于控制台的main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)\n&#123;\n\tDbgPrint(&quot;驱动程序已运行.\\r\\n&quot;);\n\tDbgPrint(&quot;%x . \\r\\n&quot;, DriverObject);\n\n\t&#x2F;&#x2F;设置一个卸载函数  便于退出\n\tDriverObject-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;103519478\nWindows驱动开发学习笔记（四）—— 3环与0环通信（常规方式）\n\n&#x2F;&#x2F;R0代码\n#include &lt;ntddk.h&gt;\n#include &lt;ntstatus.h&gt;\n\n#define DEVICE_NAME L&quot;\\\\Device\\\\MyDevice&quot;\n&#x2F;&#x2F; Ring3用CreateFile打开设备时，用&quot;\\\\\\\\.\\\\MyTestDriver&quot;\n#define SYMBOLICLINK_NAME L&quot;\\\\??\\\\MyTestDriver&quot;\n\n&#x2F;&#x2F; 0-2047是保留的  2048~4095\n#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\n&#x2F;&#x2F; 卸载函数\nVOID DriverUnload(PDRIVER_OBJECT pDriver)\n&#123;\n\tUNICODE_STRING SymbolicLinkName &#x3D; &#123;0&#125;;\n\n\tDbgPrint(&quot;驱动程序停止运行了 . \\r\\n&quot;);\n\n\t&#x2F;&#x2F; 删除符号链接 删除设备\n\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME);\n\tIoDeleteSymbolicLink(&amp;SymbolicLinkName);\n\tIoDeleteDevice(pDriver-&gt;DeviceObject);\n&#125;\n\n&#x2F;&#x2F; IRP_MJ_CREATE处理函数\nNTSTATUS IrpCreateProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)\n&#123;\n\tDbgPrint(&quot;DispatchCreate ... \\n&quot;);\n\n\t&#x2F;&#x2F; 返回状态如果不设置 Ring3返回的是失败\n\tpIrp-&gt;IoStatus.Status &#x3D; STATUS_SUCCESS;\n\tpIrp-&gt;IoStatus.Information &#x3D; 0;\n\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\n\treturn STATUS_SUCCESS;\n&#125;\n\n&#x2F;&#x2F; IRP_MJ_CLOSE处理函数\nNTSTATUS IrpCloseProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)\n&#123;\n\tDbgPrint(&quot;DispatchClose ... \\n&quot;);\n\tpIrp-&gt;IoStatus.Status &#x3D; STATUS_SUCCESS;\n\tpIrp-&gt;IoStatus.Information &#x3D; 0;\n\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\n\treturn STATUS_SUCCESS;\n&#125;\n\n&#x2F;&#x2F; IRP_MJ_DEVICE_CONTROL处理函数 用来处理与Ring3交互\nNTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)\n&#123;\n\tNTSTATUS status &#x3D; STATUS_INVALID_DEVICE_REQUEST;\n\tPIO_STACK_LOCATION pIrpStack;\n\tULONG uIoControlCode;\n\tPVOID pIoBuffer;\n\tULONG uInLength;\n\tULONG uOutLength;\n\tULONG uRead;\n\tULONG uWrite;\n\n\t&#x2F;&#x2F; 设置临时变量的值\n\tpIrpStack &#x3D; IoGetCurrentIrpStackLocation(pIrp);\n\t&#x2F;&#x2F; 获取控制码\n\tuIoControlCode &#x3D; pIrpStack-&gt;Parameters.DeviceIoControl.IoControlCode;\n\t&#x2F;&#x2F; 获取缓冲区地址(输入和输出的缓冲区都是一个)\n\tpIoBuffer &#x3D; pIrp-&gt;AssociatedIrp.SystemBuffer;\n\t&#x2F;&#x2F; Ring3 发送数据的长度\n\tuInLength &#x3D; pIrpStack-&gt;Parameters.DeviceIoControl.InputBufferLength;\n\t&#x2F;&#x2F; Ring0 发送数据的长度\n\tuOutLength &#x3D; pIrpStack-&gt;Parameters.DeviceIoControl.OutputBufferLength;\n\n\tswitch(uIoControlCode)\n\t&#123;\n\tcase OPER1:\n\t\t&#123;\n\t\t\tDbgPrint(&quot;IrpDeviceControlProc -&gt; OPER1 ... \\n&quot;);\n\n\t\t\tpIrp-&gt;IoStatus.Information &#x3D; 0;\n\t\t\tstatus &#x3D; STATUS_SUCCESS;\n\t\t\tbreak;\n\t\t&#125;\n\tcase OPER2:\n\t\t&#123;\n\t\t\tDbgPrint(&quot;IrpDeviceControlProc -&gt; OPER2 接收字节数：%d \\n&quot;, uInLength);\n\t\t\tDbgPrint(&quot;IrpDeviceControlProc -&gt; OPER2 输出字节数：%d \\n&quot;, uOutLength);\n\t\t\t&#x2F;&#x2F; Read From Buffer\n\t\t\tmemcpy(&amp;uRead, pIoBuffer, 4);\n\t\t\tDbgPrint(&quot;IrpDeviceControlProc -&gt; OPER2 ... %x \\n&quot;, uRead);\n\t\t\t&#x2F;&#x2F; Write To Buffer\n\t\t\tmemcpy(&amp;pIoBuffer, &amp;uWrite, 4);\n\t\t\t&#x2F;&#x2F; Set Status\n\t\t\tpIrp-&gt;IoStatus.Information &#x3D; 2;\n\t\t\tstatus &#x3D; STATUS_SUCCESS;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 设置返回状态\n\tpIrp-&gt;IoStatus.Status &#x3D; status;\n\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\n\treturn status;\n&#125;\n\n&#x2F;&#x2F; 入口函数 相当于Main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)\n&#123;\n\tNTSTATUS status &#x3D; 0;\n\tULONG    uIndex &#x3D; 0;\n\tPDEVICE_OBJECT pDeviceObj &#x3D; NULL;\n\tUNICODE_STRING Devicename;\n\tUNICODE_STRING SymbolicLinkName;\n\n\tDbgPrint(&quot;驱动程序开始运行了 . \\r\\n&quot;);\n\n\t&#x2F;&#x2F; 创建设备名称\n\tRtlInitUnicodeString(&amp;Devicename, DEVICE_NAME);\n\t\n\t&#x2F;&#x2F; 创建设备\n\tstatus &#x3D; IoCreateDevice(pDriver, 0, &amp;Devicename,\n\t\tFILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDeviceObj);\n\tif(status !&#x3D; STATUS_SUCCESS)\n\t&#123;\n\t\tDbgPrint(&quot;创建设备失败! \\r\\n&quot;);\n\t\treturn status;\n\t&#125;\n\t&#x2F;&#x2F;设置交互数据的方式\n\tpDeviceObj-&gt;Flags |&#x3D; DO_BUFFERED_IO;\n\n\t&#x2F;&#x2F; 创建符号链接名称\n\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME);\n\n\t&#x2F;&#x2F; 创建符号链接\n\tstatus &#x3D; IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);\n\tif(status !&#x3D; STATUS_SUCCESS)\n\t&#123;\n\t\tDbgPrint(&quot;创建符号链接失败! \\r\\n&quot;);\n\t\tIoDeleteDevice(pDeviceObj);\n\t\treturn status;\n\t&#125;\n\n\t&#x2F;&#x2F; 设置分发函数和卸载函数\n\tpDriver-&gt;MajorFunction[IRP_MJ_CREATE] &#x3D; IrpCreateProc;\n\tpDriver-&gt;MajorFunction[IRP_MJ_CLOSE]   &#x3D; IrpCloseProc;\n\tpDriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] &#x3D; IrpDeviceControlProc;\n\tpDriver-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n\n\n&#x2F;&#x2F;R3代码\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;winioctl.h&gt;\n\n#define IN_BUFFER_MAXLENGTH  0x10\t&#x2F;&#x2F;输入缓存最大长度\n#define OUT_BUFFER_MAXLENGTH 0x10\t&#x2F;&#x2F;输出缓存最大长度\n#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)\n#define SYMBOLICLINK_NAME &quot;\\\\\\\\.\\\\MyTestDriver&quot;\n\nHANDLE g_hDevice;\t&#x2F;&#x2F;驱动句柄\n\n&#x2F;***************************************************************************&#x2F;\n&#x2F;&#x2F;打开驱动服务句柄\n&#x2F;&#x2F;打开三环链接名：\\\\\\\\.\\\\Driver\n&#x2F;***************************************************************************&#x2F;\nBOOL Open(PCHAR pLinkName)\n&#123;\n\tTCHAR szBuffer[10] &#x3D; &#123;0&#125;;\n\t&#x2F;&#x2F;在3环获取驱动程序\n\tg_hDevice &#x3D; CreateFile(pLinkName, GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tDWORD err &#x3D; GetLastError();\n\tsprintf(szBuffer, &quot;%d\\n&quot;, err);\n\tif(g_hDevice !&#x3D; INVALID_HANDLE_VALUE)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n&#125;\n\n&#x2F;***************************************************************************&#x2F;\n&#x2F;&#x2F;与驱动通信的函数\n&#x2F;***************************************************************************&#x2F;\nBOOL IoControl(DWORD dwIoCode, PVOID InBuff, DWORD InBuffLen, PVOID OutBuff, DWORD OutBuffLen)\n&#123;\n\tDWORD dw;\n\t&#x2F;&#x2F;驱动句柄&#x2F;操作码&#x2F;输入缓冲区地址&#x2F;输入缓冲区长度&#x2F;输出缓冲区地址&#x2F;输出缓冲区长度&#x2F;返回长度&#x2F;指向OVERLAPPED 此处为NULL\n\tDeviceIoControl(g_hDevice, dwIoCode, InBuff, InBuffLen, OutBuff, OutBuffLen, &amp;dw, NULL);\n\treturn TRUE;\n&#125;\n\n\nint main()\n&#123;\n\tDWORD dwInBuffer &#x3D; 0x11223344;\n\tTCHAR szOutBuffer[OUT_BUFFER_MAXLENGTH] &#x3D; &#123;0&#125;;\n\n\t&#x2F;&#x2F;1. 通过符号链接，打开设备\n\tOpen(SYMBOLICLINK_NAME);\n\t&#x2F;&#x2F;2. 测试通信\n\tIoControl(OPER2, &amp;dwInBuffer, IN_BUFFER_MAXLENGTH, szOutBuffer, OUT_BUFFER_MAXLENGTH);\n\n\tprintf(&quot;%s&quot;, szOutBuffer);\n\t&#x2F;&#x2F;3. 关闭设备\n\tCloseHandle(g_hDevice);\n\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;103527830\nWindows驱动开发学习笔记（五）—— SSDT HOOK\n实验一：通过代码获取SSDT表地址\n#include &lt;ntddk.h&gt;\n#include &lt;ntstatus.h&gt;\n\ntypedef struct _KSYSTEM_SERVICE_TABLE  \n&#123;  \n\tPULONG  ServiceTableBase;\t\t\t\t\t\t\t\t&#x2F;&#x2F; 服务函数地址表基址  \n\tPULONG  ServiceCounterTableBase;\t\t\t\t\t\t&#x2F;&#x2F; SSDT函数被调用的次数\n\tULONG   NumberOfService;\t\t\t\t\t\t\t\t&#x2F;&#x2F; 服务函数的个数  \n\tPULONG   ParamTableBase;\t\t\t\t\t\t\t\t&#x2F;&#x2F; 服务函数参数表基址   \n&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;  \n\ntypedef struct _KSERVICE_TABLE_DESCRIPTOR  \n&#123;  \n\tKSYSTEM_SERVICE_TABLE   ntoskrnl;                       &#x2F;&#x2F; ntoskrnl.exe 的服务函数  \n\tKSYSTEM_SERVICE_TABLE   win32k;                         &#x2F;&#x2F; win32k.sys 的服务函数(GDI32.dll&#x2F;User32.dll 的内核支持)  \n\tKSYSTEM_SERVICE_TABLE   notUsed1;  \n\tKSYSTEM_SERVICE_TABLE   notUsed2;  \n&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\n&#x2F;&#x2F; KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了\nextern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;\n\n&#x2F;&#x2F;卸载函数\nVOID DriverUnload(PDRIVER_OBJECT driver)\n&#123;\n\tDbgPrint(&quot;驱动程序已停止.\\r\\n&quot;);\n&#125;\n\n&#x2F;&#x2F;驱动程序入口函数，相当于控制台的main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)\n&#123;\n\tDbgPrint(&quot;驱动程序已运行.\\r\\n&quot;);\n\t\n\tKdPrint((&quot;--&gt; %x \\n&quot;, KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase));\n\n\t&#x2F;&#x2F;设置一个卸载函数  便于退出\n\tDriverObject-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n\n\n\n\n通过页表基址修改页属性\n描述：SSDT所在的物理页是只读的，如果要修改，要先修改页属性为可写\n\n方法1：修改页属性\nif(RCR4 &amp; 0x00000020)\n&#123;&#x2F;&#x2F;说明是2-9-9-12分页\n\tKdPrint((&quot;2-9-9-12分页 %p\\n&quot;,RCR4));\n\tKdPrint((&quot;PTE1 %p\\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));\n\t*(DWORD64*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8)) |&#x3D; 0x02; \n\tKdPrint((&quot;PTE1 %p\\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8))));\n&#125;\nelse\n&#123;&#x2F;&#x2F;说明是10-10-12分页\n\tKdPrint((&quot;10-10-12分页\\n&quot;));\n\tKdPrint((&quot;PTE1 %p\\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));\n\t*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC)) |&#x3D; 0x02;\n\tKdPrint((&quot;PTE2 %p\\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));\n&#125;\n\n\n方法2：修改CR0寄存器\n描述：CR0寄存器的第16位叫做保护属性位，控制着页的读&#x2F;写属性\nVOID PageProtectOn()\n&#123;\n\t__asm&#123;\n\t\t\tmov  eax,cr0\n\t\t\tor   eax,10000h\t\t\t&#x2F;&#x2F;\n\t\t\tmov  cr0,eax\n\t\t\tsti\n\t&#125;\n&#125;\n\nVOID PageProtectOff()\n&#123;\n\t__asm&#123;\n\t\t\tcli\n\t\t\tmov  eax,cr0\n\t\t\tand  eax,not 10000h\t\t&#x2F;&#x2F;\n\t\t\tmov  cr0,eax\n\t&#125;\n&#125;\n\n\n\n\n\n实验二：SSDT HOOK\n第一步：编译如下代码\n#include &lt;ntddk.h&gt;\n#include &lt;ntstatus.h&gt;\n\nULONG uOldNtOpenProcess;\t\t\t&#x2F;&#x2F;存储原来的NtOpenProcess地址\n\ntypedef NTSTATUS (*NTOPENPROCESS)(\n\tPHANDLE ProcessHandle,\n\tACCESS_MASK DesiredAccess,\n\tPOBJECT_ATTRIBUTES ObjectAttributes,\n\tPCLIENT_ID ClientId);\n\nVOID PageProtectOn()\n&#123;\n\t__asm&#123;&#x2F;&#x2F;开启内存保护\n\t\tmov  eax,cr0\n\t\tor   eax,10000h\n\t\tmov  cr0,eax\n\t\tsti\n\t&#125;\n&#125;\n\nVOID PageProtectOff()\n&#123;\n\t__asm&#123;&#x2F;&#x2F;关闭内存保护\n\t\tcli\n\t\tmov  eax,cr0\n\t\tand  eax,not 10000h\n\t\tmov  cr0,eax\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;1. 找到系统服务表：函数地址表\ntypedef struct _KSYSTEM_SERVICE_TABLE  \n&#123;  \n\tPULONG  ServiceTableBase;\t\t\t&#x2F;&#x2F; 服务函数地址表基址  \n\tPULONG  ServiceCounterTableBase;\t\t&#x2F;&#x2F; SSDT函数被调用的次数\n\tULONG   NumberOfService;\t\t\t&#x2F;&#x2F; 服务函数的个数  \n\tPULONG   ParamTableBase;\t\t\t&#x2F;&#x2F; 服务函数参数表基址   \n&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;  \n\ntypedef struct _KSERVICE_TABLE_DESCRIPTOR  \n&#123;  \n\tKSYSTEM_SERVICE_TABLE   ntoskrnl;\t\t&#x2F;&#x2F; ntoskrnl.exe 的服务函数  \n\tKSYSTEM_SERVICE_TABLE   win32k;\t\t\t&#x2F;&#x2F; win32k.sys 的服务函数(GDI32.dll&#x2F;User32.dll 的内核支持)  \n\tKSYSTEM_SERVICE_TABLE   notUsed1;  \n\tKSYSTEM_SERVICE_TABLE   notUsed2;  \n&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\n&#x2F;&#x2F; KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了\nextern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;\n\n&#x2F;&#x2F;2. 准备用于替换的函数\nNTSTATUS MyNtOpenProcess(\n\tPHANDLE ProcessHandle,\n\tACCESS_MASK DesiredAccess,\n\tPOBJECT_ATTRIBUTES ObjectAttributes,\n\tPCLIENT_ID ClientId\n)&#123;\n\t&#x2F;&#x2F;自己的业务..各种过滤，或者修改返回结构\n\n\tNTSTATUS status;\n\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tKdPrint((&quot;%x %x %x %x \\n&quot;, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId));\n\n\treturn ((NTOPENPROCESS)uOldNtOpenProcess)(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);\n&#125;\n\n&#x2F;&#x2F;3. Hook\nNTSTATUS HookNtOpenPRocess()\n&#123;\n\tNTSTATUS status;\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tPageProtectOff();\n\n\tuOldNtOpenProcess &#x3D; KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7A];\n\n\tKeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7A] &#x3D; (ULONG)MyNtOpenProcess;\n\n\tPageProtectOn();\n\n\treturn status;\n&#125;\n\n&#x2F;&#x2F;4. 恢复\nNTSTATUS UnHookNtOpenPRocess()\n&#123;\n\tNTSTATUS status;\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tPageProtectOff();\n\n\tKeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7A] &#x3D; (ULONG)uOldNtOpenProcess;\n\n\tPageProtectOn();\n\n\treturn status;\n&#125;\n\n&#x2F;&#x2F;卸载函数\nVOID DriverUnload(PDRIVER_OBJECT driver)\n&#123;\n\tUnHookNtOpenPRocess();\n\n\tDbgPrint(&quot;驱动程序已停止.\\r\\n&quot;);\n&#125;\n\n&#x2F;&#x2F;驱动程序入口函数，相当于控制台的main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)\n&#123;\n\tDbgPrint(&quot;驱动程序已运行.\\r\\n&quot;);\n\n\tHookNtOpenPRocess();\n\n\t&#x2F;&#x2F;设置一个卸载函数  便于退出\n\tDriverObject-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n\n\n\n\n\nWindows驱动开发学习笔记（六）—— Inline HOOK\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41988448&#x2F;article&#x2F;details&#x2F;103557383\nSSDT HOOK 缺点：\n容易发现，容易绕过\n只能HOOK系统服务表里的函数\n\nInline Hook：\nJMP的偏移 &#x3D; 跳转地址 - 补丁地址&amp;[0xE9] - 5\n\n实验一：3环 Inline Hook\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nBYTE* ProcAddr &#x3D; 0;\t\t\t&#x2F;&#x2F;原函数地址\nDWORD OldProtect &#x3D; 0;\t\t&#x2F;&#x2F;保存旧的内存保护\nBYTE  OldCmd[20] &#x3D; &#123;0&#125;;\t\t&#x2F;&#x2F;存储原函数头部原始指令 在最后面构造返回到原函数的指令\n\nBYTE* HookProcAddr  &#x3D; 0;\t&#x2F;&#x2F;钩子函数的地址\n\n&#x2F;&#x2F;函数指针 将数据作为指令执行\ntypedef void (*POLDCMD)();\nPOLDCMD pOldCmd &#x3D; (POLDCMD)(char*)OldCmd;\n&#x2F;&#x2F;printf的格式\nchar *format &#x3D; &quot;%x&quot;;\n\n\nDWORD add(DWORD a, DWORD b)\n&#123;\n\treturn a + b;\n&#125;\n\nvoid __declspec(naked) HookProc()\n&#123;\n\t&#x2F;&#x2F;保存现场\n\t__asm\n\t&#123;\n\t\tpushad\n\t\tpushfd\n\t&#125;\n\n\t&#x2F;&#x2F;获得参数1\n\tprintf(&quot;a &#x3D; &quot;);\n\n\t__asm\n\t&#123;\n\t\tmov eax, esp\n\t\tadd eax, 40\n\n\t\tpush [eax]\n\t\tpush format\n\t\tcall printf\n\t\tadd esp, 8\n\t&#125;\n\n\t&#x2F;&#x2F;获得参数2\n\tprintf(&quot;\\nb &#x3D; &quot;);\n\n\t__asm\n\t&#123;\n\t\tmov eax, esp\n\t\tadd eax, 44\n\n\t\tpush [eax]\n\t\tpush format\n\t\tcall printf\n\t\tadd esp, 8\n\t&#125;\n\n\tprintf(&quot;\\n&quot;);\n\n\t&#x2F;&#x2F;还原现场\n\t__asm\n\t&#123;\n\n\t\tpopfd\n\t\tpopad\n\t\t\n\t\t&#x2F;&#x2F;执行原函数头部指令 并返回到原函数下一行继续执行\n\t\tjmp pOldCmd\n\t&#125;\n&#125;\n\nvoid InlineHook()\n&#123;\n\t&#x2F;&#x2F;获得需要挂钩的函数地址???????????????\n\tProcAddr  &#x3D;   (BYTE*)add + 1;\n\tProcAddr +&#x3D; *(DWORD*)ProcAddr + 4;\n\t&#x2F;&#x2F;修改内存保护\n\tVirtualProtect(ProcAddr, 6, PAGE_EXECUTE_READWRITE, &amp;OldProtect);\n\t&#x2F;&#x2F;将被覆盖的指令复制到数组中\n\tstrncpy((char*)OldCmd, (char*)ProcAddr, 6);\n\t&#x2F;&#x2F;数组末尾添上跳转指令 用于返回到被挂钩的函数\n\tOldCmd[6] &#x3D; 0xE9;\n\t*(DWORD*)&amp;OldCmd[7] &#x3D; (DWORD)(ProcAddr+6) - (DWORD)&amp;OldCmd[6] - 5;\n\n\t&#x2F;&#x2F;获得钩子函数的地址???????????\n\tHookProcAddr &#x3D; (BYTE*)HookProc + 1;\n\tHookProcAddr +&#x3D; *(DWORD*)HookProcAddr + 4;\n\t&#x2F;&#x2F;修改原函数的头部 跳转到钩子函数\n\tProcAddr[0] &#x3D; 0xE9;\n\t*(DWORD*)&amp;ProcAddr[1] &#x3D; HookProcAddr - ProcAddr - 5;\n\t&#x2F;&#x2F;跳转指令只占五个字节 原函数头部三行指令占六个字节 因此将多余字节填充为nop: 0x90\n\tProcAddr[5] &#x3D; 0x90;\n\n&#125;\n\nvoid UnInlineHook()\n&#123;\n\t&#x2F;&#x2F;判断函数是否被挂钩\n\tif(ProcAddr[0] &#x3D;&#x3D; 0xE9)\n\t&#123;\n\t\tstrncpy((char*)ProcAddr, (char*)OldCmd, 6);\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tDWORD sum;\n\n\t&#x2F;&#x2F;挂钩：打印1 2\n\tInlineHook();\n\n\tsum &#x3D; add(1, 2);\n\tprintf(&quot;sum &#x3D; %x\\n&quot;, sum);&#x2F;&#x2F;3\n\n\t&#x2F;&#x2F;脱钩：不打印\n\tUnInlineHook();\n\n\tsum &#x3D; add(3, 4);\n\tprintf(&quot;sum &#x3D; %x\\n&quot;, sum);&#x2F;&#x2F;7\n\n\treturn 0;\n&#125;\n\n\n\n\n\n实验二：0环 Inline Hook\n#include &lt;ntddk.h&gt;\n#include &lt;ntstatus.h&gt;\n\nPUCHAR pNtOpenProcess;\nUCHAR  OldCmd[20] &#x3D; &#123;0&#125;;\n&#x2F;&#x2F;函数指针 用于将数据作为指令执行\ntypedef VOID (*POLDCMD)();\nPOLDCMD pOldCmd &#x3D; (POLDCMD)(PUCHAR)OldCmd;\n\nPCHAR format &#x3D; &quot;%x %x %x %x \\r\\n&quot;;\n\ntypedef NTSTATUS (*NTOPENPROCESS)(\n\tPHANDLE ProcessHandle,\n\tACCESS_MASK DesiredAccess,\n\tPOBJECT_ATTRIBUTES ObjectAttributes,\n\tPCLIENT_ID ClientId);\n\ntypedef struct _KSYSTEM_SERVICE_TABLE  \n&#123;  \n\tPULONG  ServiceTableBase;\t\t\t&#x2F;&#x2F; 服务函数地址表基址  \n\tPULONG  ServiceCounterTableBase;\t&#x2F;&#x2F; SSDT函数被调用的次数\n\tULONG   NumberOfService;\t\t\t&#x2F;&#x2F; 服务函数的个数  \n\tPULONG   ParamTableBase;\t\t\t&#x2F;&#x2F; 服务函数参数表基址   \n&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;  \n\ntypedef struct _KSERVICE_TABLE_DESCRIPTOR  \n&#123;  \n\tKSYSTEM_SERVICE_TABLE   ntoskrnl;\t\t&#x2F;&#x2F; ntoskrnl.exe 的服务函数  \n\tKSYSTEM_SERVICE_TABLE   win32k;\t\t\t&#x2F;&#x2F; win32k.sys 的服务函数(GDI32.dll&#x2F;User32.dll 的内核支持)  \n\tKSYSTEM_SERVICE_TABLE   notUsed1;  \n\tKSYSTEM_SERVICE_TABLE   notUsed2;  \n&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\n&#x2F;&#x2F; KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了\nextern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;\n\nVOID PageProtectOn()\n&#123;\n\t__asm&#123;&#x2F;&#x2F;开启内存保护\n\t\tmov  eax,cr0\n\t\tor   eax,10000h\n\t\tmov  cr0,eax\n\t\tsti\n\t&#125;\n&#125;\n\nVOID PageProtectOff()\t\t\t\t\n&#123;\n\t__asm&#123;&#x2F;&#x2F;关闭内存保护\n\t\tcli\t\t\t\t\t\n\t\tmov  eax,cr0\n\t\tand  eax,not 10000h\n\t\tmov  cr0,eax\n\t&#125;\n&#125;\n\nVOID __declspec(naked) HookProc()&#123;\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;保存现场\n\t\tpushad\n\t\tpushfd\n\t\n\t\tmov eax, esp\n\t\tadd eax, 40\t\t&#x2F;&#x2F;eflags + 8个通用寄存器 + 返回地址 4B*10\n\t\tadd eax, 12\t\t&#x2F;&#x2F;定位到最后一个参数\n\t\tpush [eax]\t\t&#x2F;&#x2F;ClientId\n\t\tpush [eax-0x4]\t&#x2F;&#x2F;ObjectAttributes\n\t\tpush [eax-0x8]\t&#x2F;&#x2F;DesiredAccess\n\t\tpush [eax-0xC]\t&#x2F;&#x2F;ProcessHandle\n\t\tpush format\n\t\tcall DbgPrint\n\t\tadd esp, 20\n\n\t\t&#x2F;&#x2F;还原现场\n\t\tpopfd\n\t\tpopad\n\n\t\t&#x2F;&#x2F;[HookProc-&gt;OldCmd]调用原本的指令，然后返回到原函数\n\t\tjmp pOldCmd\n\t&#125;\n&#125;\n\nNTSTATUS InlineHook()\n&#123;\n\tNTSTATUS status;\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tPageProtectOff();\n\n\t&#x2F;&#x2F;保存原来的指令[OldCmd]\t\n\tpNtOpenProcess &#x3D; (PUCHAR)KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7A];\n\tRtlMoveMemory(OldCmd, pNtOpenProcess, 5);\n\n\t&#x2F;&#x2F;[后面续上]构造回去的指令，用于返回到原函数\n\tOldCmd[5] &#x3D; 0xE9;\n\t*(PULONG)&amp;OldCmd[6] &#x3D; ((ULONG)pNtOpenProcess+5) - (ULONG)&amp;OldCmd[5] - 5;\n\n\t&#x2F;&#x2F;[NT-&gt;HookProc]内核函数不存在中间人（call后通过jmp跳转），函数地址为实际地址\n\tpNtOpenProcess[0] &#x3D; 0xE9;\n\t*(PULONG)&amp;pNtOpenProcess[1] &#x3D; (ULONG)HookProc - (ULONG)pNtOpenProcess - 5;\n\n\tPageProtectOn();\n\n\treturn status;\n&#125;\n\nNTSTATUS UnInlineHook()\n&#123;\n\tNTSTATUS status;\n\tstatus &#x3D; STATUS_SUCCESS;\n\n\tif(pNtOpenProcess[0] &#x3D;&#x3D; 0xE9)\n\t&#123;\n\t\tPageProtectOff();\n\t\tRtlMoveMemory(pNtOpenProcess, OldCmd, 5);&#x2F;&#x2F;内核中的memcpy！\n\t\tPageProtectOn();\n\t&#125;\n\n\treturn status;\n&#125;\n\n&#x2F;&#x2F;卸载函数\nVOID DriverUnload(PDRIVER_OBJECT driver)\n&#123;\n\t&#x2F;&#x2F;卸载驱动时脱钩\n\tUnInlineHook();\n\n\tDbgPrint(&quot;驱动程序已停止.\\r\\n&quot;);\n&#125;\n\n&#x2F;&#x2F;驱动程序入口函数，相当于控制台的main函数\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)\n&#123;\n\tDbgPrint(&quot;驱动程序已运行.\\r\\n&quot;);\n\t&#x2F;&#x2F;运行驱动时挂钩\n\tInlineHook();\n\n\t&#x2F;&#x2F;设置一个卸载函数  便于退出\n\tDriverObject-&gt;DriverUnload &#x3D; DriverUnload;\n\n\treturn STATUS_SUCCESS;\n&#125;\n\n\n【正确的临界区】\n全局变量：\nFlag &#x3D; 0;\n\n进入临界区：\nLab：\n\tmov eax,1\n\t&#x2F;&#x2F;多核情况下必须加lock\n\tlock xadd [Flag],eax\n\tcmp eax,0\n\tjz endLab\n\tdec [Flag]\n\t&#x2F;&#x2F;线程等待Sleep..\n\tjmp Lab\nendLab:\n\tret\n\n离开临界区：\nlock dec [Flag]\n\n通过代码实现内核重载。。。\n步骤：\n\n申请内存，按内存对齐展开\n根据重定位表修复全局变量\n修复IAT表(修复导入表的说法不准确)\n山寨系统服务表\n狸猫换太子（Hook KiFastCallEntry）\n\n\n\n笔记-进程监控项目分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n【APC】\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"core","date":"2020-09-17T02:21:18.000Z","categories_index":"逆向","tags_index":"逆向","author_index":"CodingSeed"},{"id":"02fb78d957647a82a5e9777a15428562","title":"Win32","content":"Win32&#x2F;*\n对于字符串，ASCII 中使用 char 来定义，而 Unicode 中使用 wchar_t 来定义，并且需要添加前缀L。\n那么在 windows.h 头文件中（或者是它包含的其他头文件）就这样来处理：\n#ifdef UNICODE\ntypedef wchar_t TCHAR;\n#define TEXT(quote) L##quote\n#else\ntypedef char TCHAR\n#define TEXT(quote) quote\n#endif\n我们在源码中可以这样来使用：\nTCHAR str[] &#x3D; TEXT(&quot;C语言中文网&quot;);\n如果是Unicode版，也就是定义了UNICODE宏，那么上面的语句等价于：\nwchar_t str[] &#x3D; L&quot;C语言中文网&quot;;\n如果是ASCII，也就是没有定义UNICODE宏，那么等价于：\nchar str[] &#x3D; &quot;C语言中文网&quot;;\n\n\n用UTF-8就有复杂点.因为此时程序是把一个字节一个字节的来读取,\n然后再根据字节中开头的bit标志来识别是该把1个还是两个或三个字节做为一个单元来处理.\n\n0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元.\n\n这是约定的规则.你用UTF-8来表示时必须遵守这样的规则.\n我们知道UTF-16不需要用啥字符来做标志,所以两字节也就是2的16次能表示65536个字符.\n\n而UTF-8由于里面有额外的标志信息,\n一个字节只能表示2的7次方128个字符,两个字节只能表示2的11次方2048个字符.而三个字节能表示2的16次方,65536个字符.\n\n由于&quot;汉&quot;的编码27721大于2048了所有两个字节还不够,只能用三个字节来表示.\n所有要用1110xxxx 10xxxxxx 10xxxxxx这种格式.把27721对应的二进制从左到右填充XXX符号\n(实际上不一定从左到右,也可以从右到左,Big-Endian就是从左到右,Little-Endian是从右到左.)\n\n由上面我们可以看出UTF-8在局部的字节错误（丢失、增加、改变）不会导致连锁性的错误，\n因为 UTF-8 的字符边界很容易检测出来，所以容错性较高。\n\nUnicode版本2\n所有编码对应的开头标志\nEF BB BF　　　 UTF-8\nFE FF　　　　　UTF-16&#x2F;UCS-2, little endian\nFF FE　　　　　UTF-16&#x2F;UCS-2, big endian\nFF FE 00 00　　UTF-32&#x2F;UCS-4, little endian.\n00 00 FE FF　　UTF-32&#x2F;UCS-4, big-endian.\n\nTCHAR cht[] &#x3D; TEXT(&quot;中国&quot;);\nPTSTR pszTChar &#x3D; TEXT(&quot;china&quot;);\nMessageBox(0,TEXT(&quot;根据项目字符集决定&quot;),TEXT(&quot;标题&quot;),MB_OK);\n\nint _tmain(int argc, TCHAR *argv[])\n\nmain(),wmain是WINDOWS的控制台程序（32BIT）或DOS程序（16BIT）.\nWinMain(),wWinMain()是WINDOWS的GUI程序.\n*&#x2F;\n\n\n\n\n#include &quot;Tools.h&quot;\n\nHINSTANCE hAppInstance;\n\nvoid CreateButton(HWND hwnd)\t\t\n&#123;\t\t\n\tHWND hwndPushButton;\t\n\tHWND hwndCheckBox;\t\n\tHWND hwndRadio;\t\n\n\thwndPushButton &#x3D; CreateWindow ( \t\n\t\tTEXT(&quot;button&quot;),\t\t&#x2F;&#x2F;1\n\t\tTEXT(&quot;普通按钮&quot;),\n\t\t&#x2F;&#x2F;WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,\n\t\tWS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,\n\t\t10, 10,\n\t\t80, 20,\n\t\thwnd, \n\t\t(HMENU)1001,\t\t&#x2F;&#x2F;2 子窗口编号\n\t\thAppInstance, \n\t\tNULL);\n\n\t&#x2F;&#x2F;获取button的WNDCLASS\n\tTCHAR szBuffer[0x20];\n\tGetClassName(hwndPushButton,szBuffer,0x20);&#x2F;&#x2F;in out bufferSize\n\n\tWNDCLASS wc;\n\tGetClassInfo(hAppInstance,szBuffer,&amp;wc);&#x2F;&#x2F;ImageBase in out\n\tOutputDebugStringF(&quot;--&gt;%s\\n&quot;,wc.lpszClassName);\n\tOutputDebugStringF(&quot;--&gt;%x\\n&quot;,wc.lpfnWndProc);\n\n\n\n\thwndCheckBox &#x3D; CreateWindow ( \t\n\t\tTEXT(&quot;button&quot;), \n\t\tTEXT(&quot;复选框&quot;),\n\t\t&#x2F;&#x2F;WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX,\n\t\tWS_CHILD | WS_VISIBLE | BS_CHECKBOX |BS_AUTOCHECKBOX ,\n\t\t10, 40,\n\t\t80, 20,\n\t\thwnd, \n\t\t(HMENU)1002,\n\t\thAppInstance, \n\t\tNULL);\n\n\thwndRadio &#x3D; CreateWindow ( \t\n\t\tTEXT(&quot;button&quot;), \n\t\tTEXT(&quot;单选按钮&quot;),\n\t\t&#x2F;&#x2F;WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON | BS_AUTORADIOBUTTON,\n\t\tWS_CHILD | WS_VISIBLE | BS_RADIOBUTTON  ,\n\t\t10, 70,\n\t\t80, 20,\n\t\thwnd, \n\t\t(HMENU)1003,\n\t\thAppInstance, \n\t\tNULL);\n&#125; \t\t\n\n\n\n\n\n\nLRESULT CALLBACK WindowProc(  \t\t\t\t\t\t\t\n\tIN  HWND hwnd,  \n\tIN  UINT uMsg,  \n\tIN  WPARAM wParam,  \n\tIN  LPARAM lParam  \n\t);\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\thAppInstance &#x3D; hInstance;\n\t&#x2F;&#x2F;窗口的类名\t\t\t\t\t\t\n\tTCHAR className[] &#x3D; &quot;My First Window&quot;; \t\t\t\t\t\t\n\t\n\t&#x2F;&#x2F;OutputDebugStringF(&quot;%s\\n&quot;, lpCmdLine);\n\t\n\t&#x2F;&#x2F; 创建窗口类的对象 \t\t\t\t\t\t\n\tWNDCLASS wndclass &#x3D; &#123;0&#125;;\t\t\t\t\t\t&#x2F;&#x2F;一定要先将所有值赋值!!!!!!!  &#x3D;&#123;0&#125;\n\twndclass.hbrBackground &#x3D; (HBRUSH)COLOR_MENU;\t&#x2F;&#x2F;窗口的背景色\n\twndclass.lpfnWndProc &#x3D; WindowProc;\t\t\t\t&#x2F;&#x2F;窗口过程函数\n\twndclass.lpszClassName &#x3D; className;\t\t\t\t&#x2F;&#x2F;窗口类的名字\n\twndclass.hInstance &#x3D; hInstance;\t\t\t\t\t&#x2F;&#x2F;定义窗口类的应用程序的实例句柄\n\t\n\t&#x2F;&#x2F;步骤5：注册窗口类\t\t\t\t\t\t\t\t\t\t\t\n\tRegisterClass(&amp;wndclass);  \t\t\t\t\t\n\n\t&#x2F;&#x2F;步骤6：创建窗口\t\t\t\t\t\n\n\t&#x2F;&#x2F; 创建窗口  \t\t\t\t\t\n\tHWND hwnd &#x3D; CreateWindow(  \t\t\t\t\t\n\t\tclassName,\t\t\t\t\t\t\t&#x2F;&#x2F;类名\n\t\tTEXT(&quot;我的第一个窗口&quot;),\t\t\t\t&#x2F;&#x2F;窗口标题\n\t\tWS_OVERLAPPEDWINDOW,\t\t\t\t&#x2F;&#x2F;窗口外观样式 \n\t\t10,\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;相对于父窗口的X坐标\n\t\t10,\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;相对于父窗口的Y坐标\n\t\t600,\t\t\t\t\t\t\t\t&#x2F;&#x2F;窗口的宽度  \n\t\t300,\t\t\t\t\t\t\t\t&#x2F;&#x2F;窗口的高度  \n\t\tNULL,\t\t\t\t\t\t\t\t&#x2F;&#x2F;父窗口句柄，为NULL  \n\t\tNULL,\t\t\t\t\t\t\t\t&#x2F;&#x2F;菜单句柄，为NULL  \n\t\thInstance,\t\t\t\t\t\t\t&#x2F;&#x2F;当前应用程序的句柄  \n\t\tNULL);\t\t\t\t\t\t\t\t&#x2F;&#x2F;附加数据一般为NULL\n\n\tif(hwnd &#x3D;&#x3D; NULL)\t\t\t\t\t\t&#x2F;&#x2F;是否创建成功  \n\t\treturn 0;  \t\t\t\t\n\n\tCreateButton(hwnd);\t&#x2F;&#x2F;!!!!\n\n\t&#x2F;&#x2F;步骤7：显示窗口\t\t\t\t\t\n\n\t&#x2F;&#x2F; 显示窗口  \t\t\t\t\t\n\tShowWindow(hwnd, SW_SHOW);  \t\t\t\t\t\n\n\t&#x2F;&#x2F;步骤8：消息循环\t\t\t\t\t\n\n\tMSG msg;  \t\t\t\t\t\n\twhile(GetMessage(&amp;msg, NULL, 0, 0))  \t\t\t\t\t\n\t&#123;  \t\t\t\t\t\n\t\tTranslateMessage(&amp;msg);  \t\t\t\t\n\t\tDispatchMessage(&amp;msg);  \t\t\t\t\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;步骤9：回调函数\t\t\t\t\t\n\n&#x2F;*\t\t\t\t\t\n窗口消息处理程序 窗口回调函数：\t\t\t\t\t\n\t\t\t\t\t\n1、窗口回调函数处理过的消息，必须传回0.\t\t\t\t\t\n\t\t\t\t\t\n2、窗口回调不处理的消息，由DefWindowProc来处理.\t\t\t\t\t\n*&#x2F;\t\t\t\t\t\n\nLRESULT CALLBACK WindowProc(  \t\t\t\t\t\t\t\n\tIN  HWND hwnd,  \n\tIN  UINT uMsg,  \n\tIN  WPARAM wParam,  \n\tIN  LPARAM lParam  \n\t)\t\t\t\n&#123;  \t\t\n\t&#x2F;&#x2F;DbgPrintf(&quot;%x\\n&quot;,uMsg);\n\tswitch(uMsg)\t\t\t\t\n\t&#123;\t\t\t\t\n\t\t\n\t\t&#x2F;&#x2F;窗口消息\t\t\t\n\t\tcase WM_CREATE: \t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tCREATESTRUCT* createst &#x3D; (CREATESTRUCT*)lParam;\t\t\n\t\t\tDbgPrintf(&quot;WM_CREATE: %s\\n&quot;,createst-&gt;lpszClass);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_MOVE:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_MOVE %d %d\\n&quot;,wParam,lParam);\t\t\n\t\t\tPOINTS points &#x3D; MAKEPOINTS(lParam);\t\t\n\t\t\tDbgPrintf(&quot;X Y %d %d\\n&quot;,points.x,points.y);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_SIZE:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_SIZE %d %d\\n&quot;,wParam,lParam);\t\t\n\t\t\tint newWidth  &#x3D; (int)(short) LOWORD(lParam);    \t\t\n\t\t\tint newHeight  &#x3D; (int)(short) HIWORD(lParam);   \t\t\n\t\t\tDbgPrintf(&quot;WM_SIZE %d %d\\n&quot;,newWidth,newHeight);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_DESTROY:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_DESTROY %d %d\\n&quot;,wParam,lParam);\t\t\n\t\t\tPostQuitMessage(0);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\t&#x2F;&#x2F;键盘消息\t\t\t\n\t\tcase WM_KEYUP:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_KEYUP %d %d\\n&quot;,wParam,lParam);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_KEYDOWN:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_KEYDOWN %d %d\\n&quot;,wParam,lParam);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t\t&#x2F;&#x2F;鼠标消息\t\t\t\n\t\tcase WM_LBUTTONDOWN:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tDbgPrintf(&quot;WM_LBUTTONDOWN %d %d\\n&quot;,wParam,lParam);\t\t\n\t\t\tPOINTS points &#x3D; MAKEPOINTS(lParam);\t\t\n\t\t\tDbgPrintf(&quot;WM_LBUTTONDOWN %d %d\\n&quot;,points.x,points.y);\t\t\n\n\t\t\treturn 0;\t\t\n\t\t&#125;\t\t\t\n\t&#125;\t\t\t\t\n\treturn DefWindowProc(hwnd,uMsg,wParam,lParam);\t\t&#x2F;&#x2F;default 判断消息的类型是不是我关心的:是就处理,不是 让Windows去处理\n\n&#125;  \t\t\t\t\t\n\n\n\n\n\n\n&#x2F;&#x2F;win32_res\n\n#include &quot;stdafx.h&quot;\n#include &quot;resource.h&quot;\n\n\nBOOL CALLBACK DialogProc(\t\t\t\t\t\t\n\t\t\t\t\t\t HWND hwndDlg,  &#x2F;&#x2F; handle to dialog box\n\t\t\t\t\t\t UINT uMsg,     &#x2F;&#x2F; message\n\t\t\t\t\t\t WPARAM wParam, &#x2F;&#x2F; first message parameter\n\t\t\t\t\t\t LPARAM lParam  &#x2F;&#x2F; second message parameter\n\t\t\t\t\t\t )\n&#123;\t\t\t\t\t\t\n\n\tHWND hEditUser &#x3D; NULL;\n\tHWND hEditPass &#x3D; NULL;\n\n\tswitch(uMsg)\t\t\t\t\t\n\t&#123;\t\t\t\t\t\n\t\tcase  WM_INITDIALOG :\t\t\t\t\t\n\n\t&#x2F;&#x2F;\tMessageBox(NULL,TEXT(&quot;WM_INITDIALOG&quot;),TEXT(&quot;INIT&quot;),MB_OK);\t\t\t\t\n\n\t\treturn TRUE ;\t\t\t\t\n\n\t\tcase  WM_COMMAND :\t\t\t\t\t\n\n\t\tswitch (LOWORD (wParam))\t\t\t\t\n\t\t&#123;\t\t\t\t\n\t\t\tcase   IDC_BUTTON_OK :\t\t\t\t\n\t\t\t&#x2F;&#x2F;MessageBox(NULL,TEXT(&quot;IDC_BUTTON_OK&quot;),TEXT(&quot;OK&quot;),MB_OK);\t\t\t\t\t\n\t\t\t\n\t\t\t&#x2F;&#x2F;hHandle\n\t\t\thEditUser &#x3D; GetDlgItem(hwndDlg,IDC_EDIT_USERNAME);\n\t\t\thEditPass &#x3D; GetDlgItem(hwndDlg,IDC_EDIT_PASSWORD);\n\t\t\t&#x2F;&#x2F;content\n\t\t\tTCHAR szUserBuff[128];\n\t\t\tTCHAR szPassBuff[128];\n\n\t\t\tGetWindowText(hEditUser,szUserBuff,128);\n\t\t\tGetWindowText(hEditPass,szPassBuff,128);\n\n\t\t\tif (strcmp(szUserBuff, TEXT(&quot;admin&quot;)) &#x3D;&#x3D; 0 &amp;&amp; strcmp(szPassBuff, TEXT(&quot;123&quot;)) &#x3D;&#x3D; 0)\n\t\t\t&#123;\n\t\t\t\tMessageBox(NULL, TEXT(&quot;密码正确&quot;), TEXT(&quot;密码正确&quot;), MB_OK);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tMessageBox(NULL, TEXT(&quot;密码错误&quot;), TEXT(&quot;密码错误&quot;), MB_OK);\n\t\t\t&#125;\n\t\t\t\n\t\t\treturn TRUE;\n\n\t\t\tcase   IDC_BUTTON_ERROR:\n\n\t\t\tMessageBox(NULL,TEXT(&quot;IDC_BUTTON_ERROR&quot;),TEXT(&quot;ERROR&quot;),MB_OK);\t\t\t\n\n\t\t\tEndDialog(hwndDlg, 0);\t\t\t\n\n\t\t\treturn TRUE;\t\t\t\n\t\t&#125;\t\t\n\n\t\tbreak ;\t\t\t\t\n\t&#125;\t\t\t\t\t\t\n\n\treturn FALSE ;\t\t\t\t\t\n&#125;\t\t\t\t\t\t\n\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\n\t\n\tDialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, DialogProc);\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;IconDemo\n\n#include &quot;stdafx.h&quot;\n#include &quot;resource.h&quot;\nHINSTANCE hAppInstance;\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tBOOL bRet &#x3D; TRUE;\n\tHICON hIconSmall;\n\tHICON hIconBig;\n\tswitch(uMsg)\n\t&#123;\n\t\tcase WM_INITDIALOG :\n\t\thIconSmall &#x3D; LoadIcon (hAppInstance, MAKEINTRESOURCE (IDI_ICON_SMALL));\n\t\thIconBig &#x3D; LoadIcon (hAppInstance, MAKEINTRESOURCE (IDI_ICON_BIG));\n\t\t  &#x2F;&#x2F;设置图标\n\t\tSendMessage(hDlg,WM_SETICON,ICON_BIG,(DWORD)hIconBig);\n\t\tSendMessage(hDlg,WM_SETICON,ICON_SMALL,(DWORD)hIconSmall);\n\t\t\n\t\treturn 0 ;\n\t\tcase WM_COMMAND:\n\t\tswitch(LOWORD(wParam))\n\t\t&#123;\n\t\t\tcase IDC_BUTTON_OUT:\n\t\t\tEndDialog(hDlg,0);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tbRet &#x3D; FALSE;\n\t\t\tbreak;\n\t\t&#125;\n\t\tbreak;\n\n\t\tdefault:\n\t\tbRet &#x3D; FALSE;\n\t\tbreak;\n\t&#125;\n\t\n\treturn bRet;\n&#125;\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\thAppInstance &#x3D; hInstance;\n\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n&#x2F;&#x2F;项目：LordPE\tWin32\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;thread Timer\nfor (int i &#x3D; 0; i &lt; 10; i++)\n&#123;\n\tprintf(&quot;+++++++++\\n&quot;);\n&#125;\n\n\n\n\n&#x2F;&#x2F;threadd_ctrl\t\twin32\n#include &quot;resource.h&quot;\n\nHWND hEdit;\nHANDLE hThread;\n&#x2F;&#x2F;DWORD isEnd;\t\t\t\t\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\t\n\tDWORD dwIndex &#x3D; 0;\t\t\t\t\n\tDWORD dwCount;\t\t\t\t\n\n\twhile(dwIndex&lt;1000)\t\t\t\t\n\t&#123;\t\t\t\n\t&#x2F;*\tif(dwIndex &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tbreak;\n\t\t\t&#x2F;&#x2F;::ExitThread(2);&#x2F;&#x2F;退出码 清理堆栈 不管new 直接返回!\n\t\t&#125;*&#x2F;\n\t\tGetWindowText(hEdit,szBuffer,10);\t\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwCount );\t\t\t\n\t\tdwCount++;\t\n\t\tSleep(200);\n\t\tmemset(szBuffer,0,10);\t\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwCount);\t\t\t\n\t\tSetWindowText(hEdit,szBuffer);\t\t\t\n\t\tdwIndex++;\t\t\t\n\t&#125;\t\n\t&#x2F;&#x2F;free delete\n\n\treturn 0;\t\t\t\t\n&#125;\t\t\t\t\t\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\t\n\tDWORD dwIndex &#x3D; 0;\t\t\t\t\n\tDWORD dwCount;\t\t\t\t\n\n\n\twhile(dwIndex&lt;10)\t\t\t\t\n\t&#123;\t\t\t\t\n\t\tGetWindowText(hEdit,szBuffer,10);\t\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwCount );\t\t\t\n\t\tdwCount++;\t\t\t\n\t\tmemset(szBuffer,0,10);\t\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwCount);\t\t\t\n\t\tSetWindowText(hEdit,szBuffer);\t\t\t\n\t\tdwIndex++;\t\t\t\n\t&#125;\t\t\t\t\n\n\treturn 0;\t\t\t\t\n&#125;\t\t\t\t\t\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tBOOL bRet &#x3D; FALSE;\t\t\t\t\n\n\tswitch(uMsg)\t\t\t\t\n\t&#123;\t\t\t\t\n\t\tcase WM_CLOSE:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tEndDialog(hDlg,0);\t\t\n\t\t\tbreak;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_INITDIALOG:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\thEdit &#x3D; GetDlgItem(hDlg,IDC_EDIT);\t\t\n\t\t\tSetWindowText(hEdit,&quot;0&quot;);\t\t\n\n\t\t\tbreak;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_COMMAND:\t\t\t\t\n\n\t\tswitch (LOWORD (wParam))\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tcase IDC_BUTTON1:\t\t\t\n\t\t\t&#123;\t\t\n\t\t\t\thThread &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\t\t\t\tNULL, 0, NULL);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t\tcase IDC_BUTTON2:\t\t\t\n\t\t\t&#123;\t\t\n\n\t\t\t\t::SuspendThread(hThread);\n\t\t\t\tCONTEXT context;\n\n\t\t\t\t&#x2F;&#x2F;设置要获取的类型\n\t\t\t\tcontext.ContextFlags &#x3D; CONTEXT_CONTROL;\n\n\t\t\t\t&#x2F;&#x2F;获取\n\t\t\t\tBOOL ok &#x3D; ::GetThreadContext(hThread,&amp;context);\n\n\t\t\t\t&#x2F;&#x2F;设置\n\t\t\t\tcontext.Eip &#x3D; 0x401000;&#x2F;&#x2F;\n\n\t\t\t\tSetThreadContext(hThread,&amp;context);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t\tcase IDC_BUTTON3:\t\t\t\n\t\t\t&#123;\t\t\n\t\t\t\t::ResumeThread(hThread);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\t\n\t\t\tcase IDC_BUTTON4:\t\t\t\n\t\t\t&#123;\n\t\t\t\t::TerminateThread(hThread,3);&#x2F;&#x2F;异步 只通知OS终止，不等  不清理堆栈（local_var有引用）\n\n\t\t\t\t::WaitForSingleObject(hThread,INFINITE);&#x2F;&#x2F;阻塞self\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t&#125;\t\n\t\tbreak ;\t\t\t\n\t&#125;\t\t\t\t\n\n\treturn bRet;\t\t\t\t\n&#125;\t\t\t\t\t\n\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\n\n\tDialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, MainDlgProc);\n\treturn 0;\n&#125;\n\n\n\n\n在g_num&#x3D;0时，t1取得g_num&#x3D;0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num&#x3D;0\n然后t2对得到的值进行加1并赋给g_num，使得g_num&#x3D;1\n然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。\n这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num&#x3D;1\n\n&#x2F;&#x2F;加临界区 &#x3D;&#x3D;20000了\n#include &quot;stdafx.h&quot;\n#include &quot;resource.h&quot;\n\nHWND hEdit;\nHANDLE hThread1;\nHANDLE hThread2;\nCRITICAL_SECTION cs;\n\n\n&#x2F;&#x2F;DWORD isEnd;\t\t\t\t\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\t\n\tDWORD dwIndex &#x3D; 0;\t\t\t\t\n\tDWORD dwCount;\t\t\t\t\n\n\twhile(dwIndex&lt;10000)\t\t\t\t\n\t&#123;\t\t\t\n\t&#x2F;*\tif(dwIndex &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tbreak;\n\t\t\t&#x2F;&#x2F;::ExitThread(2);&#x2F;&#x2F;退出码 清理堆栈 不管new 直接返回!\n\t\t&#125;*&#x2F;\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit,szBuffer,10);\t\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwCount );\t\t\t\n\t\tdwCount++;\t\n\n\t\tmemset(szBuffer,0,10);\t\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwCount);\t\t\t\n\t\tSetWindowText(hEdit,szBuffer);\t\t\t\n\t\tdwIndex++;\t\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t&#125;\t\n\t&#x2F;&#x2F;free delete\n\n\treturn 0;\t\t\t\t\n&#125;\t\t\t\t\t\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\t\n\tDWORD dwIndex &#x3D; 0;\t\t\t\t\n\tDWORD dwCount;\t\t\t\t\n\n\n\twhile(dwIndex&lt;10000)\t\t\t\t\n\t&#123;\t\t\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit,szBuffer,10);\t\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwCount );\t\t\t\n\t\tdwCount++;\t\t\t\n\t\tmemset(szBuffer,0,10);\t\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwCount);\t\t\t\n\t\tSetWindowText(hEdit,szBuffer);\t\t\t\n\t\tdwIndex++;\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t&#125;\t\t\t\t\n\n\treturn 0;\t\t\t\t\n&#125;\t\t\t\t\t\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\t\t\t\t\t\n&#123;\t\t\t\t\t\n\tBOOL bRet &#x3D; FALSE;\t\t\t\t\n\n\tswitch(uMsg)\t\t\t\t\n\t&#123;\t\t\t\t\n\t\tcase WM_CLOSE:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tEndDialog(hDlg,0);\t\t\n\t\t\tbreak;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_INITDIALOG:\t\t\t\t\n\t\t&#123;\t\t\t\n\t\t\thEdit &#x3D; GetDlgItem(hDlg,IDC_EDIT);\t\t\n\t\t\tSetWindowText(hEdit,&quot;0&quot;);\t\t\n\n\t\t\tbreak;\t\t\n\t\t&#125;\t\t\t\n\t\tcase WM_COMMAND:\t\t\t\t\n\n\t\tswitch (LOWORD (wParam))\t\t\t\n\t\t&#123;\t\t\t\n\t\t\tcase IDC_BUTTON1:\t\t\t\n\t\t\t&#123;\t\t\n\t\t\t\thThread1 &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\t\t\t\tNULL, 0, NULL);\n\n\t\t\t\t::CloseHandle(hThread1);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t\tcase IDC_BUTTON2:\t\t\t\n\t\t\t&#123;\t\t\n\n\t\t\t\thThread2 &#x3D; ::CreateThread(NULL, 0, ThreadProc2, \t\n\t\t\t\t\tNULL, 0, NULL);\n\n\t\t\t\t::CloseHandle(hThread2);\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t\tcase IDC_BUTTON3:\t\t\t\n\t\t\t&#123;\t\t\n\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\t\n\t\t\tcase IDC_BUTTON4:\t\t\t\n\t\t\t&#123;\n\n\t\t\t\treturn TRUE;\t\n\t\t\t&#125;\t\t\n\t\t&#125;\t\n\t\tbreak ;\t\t\t\n\t&#125;\t\t\t\t\n\n\treturn bRet;\t\t\t\t\n&#125;\t\t\t\t\t\n\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR     lpCmdLine,\n\tint       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\n\tInitializeCriticalSection(&amp;cs);\t\n\tDialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, MainDlgProc);\n\tDeleteCriticalSection(&amp;cs);\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n&#x2F;&#x2F;临界区\t\tthread_ctl\twin32 console\n#include &quot;stdafx.h&quot;\t\t\n#include &lt;windows.h&gt;\t\t\nCRITICAL_SECTION cs;\t\t\n\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int x&#x3D;0;x&lt;1000;x++)\t\n\t&#123;\t\n\t\tEnterCriticalSection(&amp;cs);\n\n\t\tSleep(1000);\n\t\t\n\t\tprintf(&quot;11111:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\n\n\t\tLeaveCriticalSection(&amp;cs);\n\t\t\n\t&#125;\t\n\treturn 0;\t\n&#125;\t\t\n\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int x&#x3D;0;x&lt;1000;x++)\t\n\t&#123;\t\n\t\tEnterCriticalSection(&amp;cs);\n\t\t\n\t\tSleep(1000);\n\t\t\n\t\tprintf(&quot;22222:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\n\t\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t\t\n\t&#125;\t\n\n\treturn 0;\t\n&#125;\t\t\n\nDWORD WINAPI ThreadProc3(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int x&#x3D;0;x&lt;1000;x++)\t\n\t&#123;\t\n\t\tEnterCriticalSection(&amp;cs);\n\t\t\n\t\tSleep(1000);\n\t\t\n\t\tprintf(&quot;33333:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\n\t\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t\t\n\t&#125;\t\n\n\treturn 0;\t\n&#125;\t\t\n\nDWORD WINAPI ThreadProc4(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int x&#x3D;0;x&lt;1000;x++)\t\n\t&#123;\t\n\t\tEnterCriticalSection(&amp;cs);\n\t\t\n\t\tSleep(1000);\n\t\t\n\t\tprintf(&quot;44444:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\n\t\t\n\t\tLeaveCriticalSection(&amp;cs);\n\t\t\n\t&#125;\t\n\n\treturn 0;\t\n&#125;\t\t\n\n\nint main(int argc, char* argv[])\t\t\n&#123;\t\t\n\tInitializeCriticalSection(&amp;cs);\t\n\n\t&#x2F;&#x2F;printf(&quot;主线程:%x %x %x\\n&quot;,cs.LockCount,cs.RecursionCount,cs.OwningThread);\t\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread1 &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread2 &#x3D; ::CreateThread(NULL, 0, ThreadProc2, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread3 &#x3D; ::CreateThread(NULL, 0, ThreadProc3, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread4 &#x3D; ::CreateThread(NULL, 0, ThreadProc4, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;如果不在其他的地方引用它 关闭句柄\t\n\t::CloseHandle(hThread1);\t\n\t::CloseHandle(hThread2);\t\n\t::CloseHandle(hThread3);\t\n\t::CloseHandle(hThread4);\t\n\n\tSleep(1000*60*60);\t\n\n\tDeleteCriticalSection(&amp;cs);\n\n\treturn 0;\t\n&#125;\t\t\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;互斥体 mutex\n&#x2F;*\nWIN32 使用 MUTEX 实现禁止多开\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;Kwansy&#x2F;article&#x2F;details&#x2F;106485735\n*&#x2F;\n&#x2F;&#x2F; MutexLimitMultiOpen2.cpp : Defines the entry point for the application.\n&#x2F;&#x2F;\n\n#include &quot;stdafx.h&quot;\n\nBOOL CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)\n&#123;\n\tswitch(uMsg)\n\t&#123;\n\tcase WM_CLOSE:\n\t\t&#123;\n\t\t\tEndDialog(hDlg, 0);\n\t\t\treturn TRUE;\n\t\t&#125;\n\t&#125;\n\treturn FALSE;\n&#125;\n\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n                     HINSTANCE hPrevInstance,\n                     LPSTR     lpCmdLine,\n                     int       nCmdShow)\n&#123;\n\tHANDLE hMutex;\n\t&#x2F;&#x2F; 尝试获取\n\thMutex &#x3D; OpenMutex(MUTEX_ALL_ACCESS, FALSE, &quot;MYMUTEXTAG&quot;);\n\tif (NULL &#x3D;&#x3D; hMutex)\n\t&#123;\n\t\t&#x2F;&#x2F; 如果没有，说明咱是第一个，那就创建一个MUTEX\n\t\thMutex &#x3D; CreateMutex(0, FALSE, &quot;MYMUTEXTAG&quot;);\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F; 如果有，说明已经有了，不准多开\n\t\tMessageBox(0, &quot;请不要多开&quot;, &quot;Error&quot;, MB_OK);\n\t\treturn -1;\n\t&#125;\n \tDialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), 0, DlgProc);\n\tReleaseMutex(hMutex);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n&#x2F;&#x2F;WaitForSingleObject\n#include &lt;windows.h&gt;\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int i&#x3D;0;i&lt;5;i++)\t\n\t&#123;\t\n\t\tprintf(&quot;+++++++++\\n&quot;);\n\t\tSleep(1000);\n\t&#125;\t\n\treturn 0;\t\n&#125;\t\t\n\nint main(int argc, char* argv[])\t\t\n&#123;\t\t\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread1 &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\tNULL, 0, NULL);\n\t&#x2F;&#x2F;WaitForSingleObject处理的是进程&#x2F;线程句柄(para1),不会恢复回“未通知”状态，保持“已通知”\n\t&#x2F;&#x2F;[其他内核对象的话不一定，有可能恢复回“未通知”状态，会一直等，一直阻塞！！！！]\n\t\n\t&#x2F;&#x2F;DWORD dwCode &#x3D; ::WaitForSingleObject(hThread1, INFINITE);&#x2F;&#x2F;3000 监视0环内存\n\t\n\t::WaitForSingleObject(hThread1, 3000);\n\tMessageBox(0,0,0,0);\n\t::WaitForSingleObject(hThread1, 3000);\n\tMessageBox(0,0,0,0);\n\t::WaitForSingleObject(hThread1, 3000);\n\tMessageBox(0,0,0,0);\n\n\t&#x2F;&#x2F;CloseHandle(hThread1);&#x2F;&#x2F;否则[程序运行时]：内核对象泄露\n\n\treturn 0;\t\n&#125;\t\t\n\n\n\n&#x2F;&#x2F;WaitForMultipleObjects\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int i&#x3D;0;i&lt;5;i++)\t\n\t&#123;\t\n\t\tprintf(&quot;+++++++++\\n&quot;);\n\t\tSleep(1000);\n\t&#125;\t\n\treturn 0;\t\n&#125;\t\t\n\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\t\n&#123;\t\t\n\tfor(int i&#x3D;0;i&lt;3;i++)\t\n\t&#123;\t\n\t\tprintf(&quot;---------\\n&quot;);\n\t\tSleep(1000);\n\t&#125;\t\n\n\treturn 0;\t\n&#125;\t\t\n\n\nint main(int argc, char* argv[])\t\t\n&#123;\t\t\n\n\tHANDLE hArray[2];\t\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread1 &#x3D; ::CreateThread(NULL, 0, ThreadProc1, \t\n\t\tNULL, 0, NULL);\n\n\t&#x2F;&#x2F;创建一个新的线程\t\n\tHANDLE hThread2 &#x3D; ::CreateThread(NULL, 0, ThreadProc2, \t\n\t\tNULL, 0, NULL);\n\n\thArray[0] &#x3D; hThread1;\t\n\thArray[1] &#x3D; hThread2;\t\n\n\tDWORD dwCode &#x3D; ::WaitForMultipleObjects(2, hArray,FALSE,INFINITE);\t\n\tCloseHandle(hArray[0]);\n\tCloseHandle(hArray[1]);\n\t\n\tMessageBox(0,0,0,0);\t\n\n\treturn 0;\t\n&#125;\t\t\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_41020820&#x2F;article&#x2F;details&#x2F;108029582\n&#x2F;&#x2F;抢红包-临界区\n#include &quot;stdafx.h&quot;\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &quot;resource.h&quot;\n\nHWND hEdit1,hEdit2,hEdit3,hEdit4;\nCRITICAL_SECTION cs;\n\nDWORD WINAPI GetMoney1(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0; &#x2F;&#x2F;从EDIT1当中通过GetWindowText()获取到的红包金额\n\tDWORD dwMoney&#x3D;0; &#x2F;&#x2F;当前线程金额\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit2,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money) &#x2F;&#x2F;红包金额\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,–-Money);\n\t\t\tSetWindowText(hEdit2,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tflag&#x3D;FALSE;\n\t\t&#125;\n\t\tLeaveCriticalSection(&amp;cs);\n\t\tSleep(50);\n\t&#125;\n\treturn 0;\n&#125;\n\nDWORD WINAPI GetMoney2(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit3,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,–-Money);\n\t\t\tSetWindowText(hEdit3,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;else\n\t\t&#123;\n\t\t\tflag&#x3D;FALSE;\n\t\t&#125;\n\t\tLeaveCriticalSection(&amp;cs);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n\n&#125;\nDWORD WINAPI GetMoney3(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\tEnterCriticalSection(&amp;cs);\n\t\tGetWindowText(hEdit4,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,–-Money);\n\t\t\tSetWindowText(hEdit4,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tflag &#x3D;FALSE;\n\t\t&#125;\n\t\tLeaveCriticalSection(&amp;cs);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n\n&#125;\n\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\n&#123;\n\tHANDLE hThreads[3];\n\thThreads[0]&#x3D; CreateThread(NULL,0,GetMoney1,NULL,NULL,NULL);\n\thThreads[1]&#x3D;CreateThread(NULL,0,GetMoney2,NULL,NULL,NULL);\n\thThreads[2]&#x3D;CreateThread(NULL,0,GetMoney3,NULL,NULL,NULL);\n\n\tWaitForMultipleObjects(3,hThreads,TRUE,INFINITE);\n\t&#x2F;&#x2F;自己用来释放资源的代码\n\tCloseHandle(hThreads[0]);\n\tCloseHandle(hThreads[1]);\n\tCloseHandle(hThreads[2]);\n\treturn 0;\n&#125;\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tswitch(uMsg)\n\t&#123;\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hDlg,0);\n\t\t\treturn TRUE;\n\t\tcase WM_INITDIALOG:\n\t\t&#123;\n\t\t\thEdit1 &#x3D; GetDlgItem(hDlg,IDC_EDIT1);\n\t\t\thEdit2 &#x3D; GetDlgItem(hDlg,IDC_EDIT2);\n\t\t\thEdit3 &#x3D; GetDlgItem(hDlg,IDC_EDIT3);\n\t\t\thEdit4 &#x3D; GetDlgItem(hDlg,IDC_EDIT4);\n\t\t\tSetWindowText(hEdit1,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\n\t\t\treturn TRUE;\n\t\t&#125;\n\t\tcase WM_COMMAND:\n\t\t\tswitch(LOWORD(wParam))\n\t\t\t&#123;\n\t\t\t\tcase IDC_BUTTON1:\n\t\t\t\t&#123;\n\t\t\t\t\tTCHAR szBuff[10];\n\t\t\t\t\tmemset(szBuff,0,10);\n\t\t\t\t\tGetWindowText(hEdit1,szBuff,10);\n\t\t\t\t\tSetWindowText(hEdit1,szBuff);\n\t\t\t\t\tSetWindowText(hEdit2,“0”);\n\t\t\t\t\tSetWindowText(hEdit3,“0”);\n\t\t\t\t\tSetWindowText(hEdit4,“0”);\n\t\t\t\t\tCreateThread(NULL,0,ThreadProc1,NULL,NULL,NULL);\n\t\t\t\t\t&#x2F;&#x2F;WaitForSingleObject(hThread,INFINITE);\n\t\t\t\t\treturn TRUE;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tbreak;\n\t&#125;\n\treturn 0;\n&#125;\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR lpCmdLine,\n\tint nCmdShow)\n&#123;\n&#x2F;&#x2F; TODO: Place code here.\n\tInitializeCriticalSection(&amp;cs);\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\treturn 0;\n&#125;\n\n\n\n\n\n\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_41020820&#x2F;article&#x2F;details&#x2F;108029837\n&#x2F;&#x2F;抢红包-mutex (hongbao)\n#include &quot;stdafx.h&quot;\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &quot;resource.h&quot;\n\nHWND hEdit1,hEdit2,hEdit3,hEdit4;\n\nHANDLE hMutex;\n\n&#x2F;&#x2F;CRITICAL_SECTION cs;\n\nDWORD WINAPI GetMoney1(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\n\t\t&#x2F;&#x2F;EnterCriticalSection(&amp;cs);\n\t\tWaitForSingleObject(hMutex,INFINITE);\n\t\tGetWindowText(hEdit2,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,--Money);\n\t\t\tSetWindowText(hEdit2,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tflag&#x3D;FALSE;\n\t\t&#125;\n\t\t&#x2F;&#x2F;LeaveCriticalSection(&amp;cs);\n\t\tReleaseMutex(hMutex);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n&#125;\nDWORD WINAPI GetMoney2(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\t&#x2F;&#x2F;EnterCriticalSection(&amp;cs);\n\t\tWaitForSingleObject(hMutex,INFINITE);\n\t\tGetWindowText(hEdit3,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,-–Money);\n\t\t\tSetWindowText(hEdit3,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;else\n\t\t&#123;\n\t\t\tflag&#x3D;FALSE;\n\t\t&#125;\n\t\t&#x2F;&#x2F;LeaveCriticalSection(&amp;cs);\n\t\tReleaseMutex(hMutex);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n\n&#125;\nDWORD WINAPI GetMoney3(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[10];\n\tTCHAR szBuffer2[10];\n\tDWORD Money&#x3D;0;\n\tDWORD dwMoney&#x3D;0;\n\tBOOL flag&#x3D;TRUE;\n\twhile(flag)\n\t&#123;\n\t\t&#x2F;&#x2F;EnterCriticalSection(&amp;cs);\n\t\tWaitForSingleObject(hMutex,INFINITE);\n\t\tGetWindowText(hEdit4,szBuffer,10);\n\t\tGetWindowText(hEdit1,szBuffer2,10);\n\t\tsscanf(szBuffer,&quot;%d&quot;,&amp;dwMoney);\n\t\tsscanf(szBuffer2,&quot;%d&quot;,&amp;Money);\n\t\tif(Money!&#x3D;0)\n\t\t&#123;\n\t\t\tmemset(szBuffer,0,10);\n\t\t\tmemset(szBuffer2,0,10);\n\t\t\tsprintf(szBuffer,&quot;%d&quot;,++dwMoney);\n\t\t\tsprintf(szBuffer2,&quot;%d&quot;,-–Money);\n\t\t\tSetWindowText(hEdit4,szBuffer);\n\t\t\tSetWindowText(hEdit1,szBuffer2);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tflag &#x3D;FALSE;\n\t\t&#125;\n\t\t&#x2F;&#x2F;LeaveCriticalSection(&amp;cs);\n\t\tReleaseMutex(hMutex);\n\t\tSleep(50);\n\n\t&#125;\n\treturn 0;\n\n&#125;\n\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\n&#123;\n\thMutex&#x3D; CreateMutex( NULL,FALSE, NULL);\n\tHANDLE hThreads[3];\n\thThreads[0]&#x3D; CreateThread(NULL,0,GetMoney1,NULL,NULL,NULL);\n\thThreads[1]&#x3D;CreateThread(NULL,0,GetMoney2,NULL,NULL,NULL);\n\thThreads[2]&#x3D;CreateThread(NULL,0,GetMoney3,NULL,NULL,NULL);\n\n\tWaitForMultipleObjects(3,hThreads,TRUE,INFINITE);\n\t&#x2F;&#x2F;自己用来释放资源的代码\n\tCloseHandle(hThreads[0]);\n\tCloseHandle(hThreads[1]);\n\tCloseHandle(hThreads[2]);\n\tCloseHandle(hMutex);\n\treturn 0;\n&#125;\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tswitch(uMsg)\n\t&#123;\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hDlg,0);\n\t\t\treturn TRUE;\n\t\tcase WM_INITDIALOG:\n\t\t&#123;\n\t\t\thEdit1 &#x3D; GetDlgItem(hDlg,IDC_EDIT1);\n\t\t\thEdit2 &#x3D; GetDlgItem(hDlg,IDC_EDIT2);\n\t\t\thEdit3 &#x3D; GetDlgItem(hDlg,IDC_EDIT3);\n\t\t\thEdit4 &#x3D; GetDlgItem(hDlg,IDC_EDIT4);\n\t\t\tSetWindowText(hEdit1,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\n\t\t\treturn TRUE;\n\t\t&#125;\n\t\tcase WM_COMMAND:\n\t\t\tswitch(LOWORD(wParam))\n\t\t\t&#123;\n\t\t\t\tcase IDC_BUTTON1:\n\t\t\t\t&#123;\n\t\t\t\t\tTCHAR szBuff[10];\n\t\t\t\t\tmemset(szBuff,0,10);\n\t\t\t\t\tGetWindowText(hEdit1,szBuff,10);\n\t\t\t\t\tSetWindowText(hEdit1,szBuff);\n\t\t\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\n\t\t\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\n\t\t\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\n\t\t\t\t\tCreateThread(NULL,0,ThreadProc1,NULL,NULL,NULL);\n\t\t\t\t\t&#x2F;&#x2F;WaitForSingleObject(hThread,INFINITE);\n\t\t\t\t\treturn TRUE;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tbreak;\n\t&#125;\n\treturn 0;\n&#125;\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\tHINSTANCE hPrevInstance,\n\tLPSTR lpCmdLine,\n\tint nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\t&#x2F;&#x2F;InitializeCriticalSection(&amp;cs);\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\treturn 0;\n&#125;\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F;线程同步\n\n&#x2F;&#x2F;event\n#include &quot;stdafx.h&quot;\n\nHANDLE g_hEvent;\t\n\t\nHWND hEdit1;\t\nHWND hEdit2;\t\nHWND hEdit3;\t\nHWND hEdit4;\t\nHANDLE hThread1;\t\nHANDLE hThread2;\t\nHANDLE hThread3;\t\nHANDLE hThread4;\t\n\t\n\nDWORD WINAPI ThreadProc2(LPVOID lpParameter)\t\n&#123;\t\n\tTCHAR szBuffer[10] &#x3D; &#123;0&#125;;\n\t\n\t&#x2F;&#x2F;当事件变成已通知时 \n\tWaitForSingleObject(g_hEvent, INFINITE);&#x2F;&#x2F;auto改成未通知\n\t\n\t&#x2F;&#x2F;读取内容\n\tGetWindowText(hEdit1,szBuffer,10);\n\tSleep(1000);\t\n\tSetWindowText(hEdit2,szBuffer);\n\n\tSetEvent(g_hEvent);\n\n\treturn 0;\n&#125;\t\nDWORD WINAPI ThreadProc3(LPVOID lpParameter)\t\n&#123;\t\n\tTCHAR szBuffer[10] &#x3D; &#123;0&#125;;\n\t\n\t&#x2F;&#x2F;当事件变成已通知时 \n\tWaitForSingleObject(g_hEvent, INFINITE);\n\t\n\t&#x2F;&#x2F;读取内容\n\tGetWindowText(hEdit1,szBuffer,10);\n\tSleep(1000);\t\n\tSetWindowText(hEdit3,szBuffer);\n\tSetEvent(g_hEvent);\n\n\treturn 0;\n&#125;\t\nDWORD WINAPI ThreadProc4(LPVOID lpParameter)\t\n&#123;\t\n\tTCHAR szBuffer[10] &#x3D; &#123;0&#125;;\n\t\n\t&#x2F;&#x2F;当事件变成已通知时 \n\tWaitForSingleObject(g_hEvent, INFINITE);\n\t\n\t&#x2F;&#x2F;读取内容\n\tGetWindowText(hEdit1,szBuffer,10);\n\tSleep(1000);\t\n\tSetWindowText(hEdit4,szBuffer);\n\tSetEvent(g_hEvent);\n\n\treturn 0;\n&#125;\t\n\n\nDWORD WINAPI ThreadMain(LPVOID lpParameter)\t\n&#123;\t\n\t&#x2F;&#x2F;创建事件\n\t&#x2F;&#x2F;默认安全属性  手动设置未通知状态(TRUE)  初始状态未通知 没有名字 \n\tg_hEvent &#x3D; CreateEvent(NULL, FALSE, FALSE, NULL);&#x2F;&#x2F;auto改成未通知\n\tHANDLE hThread[3];\n\t&#x2F;&#x2F;创建3个线程\n\thThread[0] &#x3D; ::CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL);\n\thThread[1] &#x3D; ::CreateThread(NULL, 0, ThreadProc3, NULL, 0, NULL);\n\thThread[2] &#x3D; ::CreateThread(NULL, 0, ThreadProc4, NULL, 0, NULL);\n\t\n\t&#x2F;&#x2F;设置文本框的值\n\tSetWindowText(hEdit1,&quot;1000&quot;);\n\t\n\t&#x2F;&#x2F;设置事件为已通知\n\tSetEvent(g_hEvent);\n\tSleep(50);\n\t&#x2F;&#x2F;等待线程结束 销毁内核对象\n\tWaitForMultipleObjects(3, hThread, TRUE, INFINITE);  \n\tCloseHandle(hThread[0]);  \n\tCloseHandle(hThread[1]);\n\tCloseHandle(hThread[2]);\n\tCloseHandle(g_hEvent);  \n\t\n\treturn 0;\n&#125;\t\n\t\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tswitch(uMsg)\n\t&#123;\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hDlg,0);\n\t\t\treturn TRUE;\n\t\tcase WM_INITDIALOG:\n\t\t&#123;\n\t\t\thEdit1 &#x3D; GetDlgItem(hDlg,IDC_EDIT1);\n\t\t\thEdit2 &#x3D; GetDlgItem(hDlg,IDC_EDIT2);\n\t\t\thEdit3 &#x3D; GetDlgItem(hDlg,IDC_EDIT3);\n\t\t\thEdit4 &#x3D; GetDlgItem(hDlg,IDC_EDIT4);\n\t\t\tSetWindowText(hEdit1,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\n\t\t\treturn TRUE;\n\t\t&#125;\n\t\tcase WM_COMMAND:\n\t\t\tswitch(LOWORD(wParam))\n\t\t\t&#123;\n\t\t\t\tcase IDC_BUTTON_BEGIN:\n\t\t\t\t&#123;\n\n\t\t\t\t\t::CreateThread(NULL,0,ThreadMain,NULL,NULL,NULL);\n\n\t\t\t\t\treturn TRUE;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tbreak;\n\t&#125;\n\treturn 0;\n&#125;\n\nint APIENTRY WinMain(HINSTANCE hInstance,\n\t\t\t\t\t HINSTANCE hPrevInstance,\n\t\t\t\t\t LPSTR     lpCmdLine,\n\t\t\t\t\t int       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;ProdConsum\n&#x2F;&#x2F;事件 实现线程同步[交替 轮流]\nHANDLE g_hSet, g_hClear;\t\t\nint g_Max &#x3D; 10;\t\t\nint g_Number &#x3D; 0;\t\t\n\t\t\t\t\t\t\n&#x2F;&#x2F;生产者线程函数  \t\t\nDWORD WINAPI ThreadProduct(LPVOID pM)  \t\t\n&#123;  \t\t\n\tfor (int i &#x3D; 0; i &lt; g_Max; i++)\t\t\n\t&#123;  \t\t\n\t\tWaitForSingleObject(g_hSet, INFINITE);\t\t&#x2F;&#x2F;\n\t\tg_Number &#x3D; 1; \n\t\tDWORD id &#x3D; GetCurrentThreadId();\n\t\tprintf(&quot;生产者%d将数据%d放入缓冲区\\n&quot;,id, g_Number); \n\t\tSetEvent(g_hClear);\t\t&#x2F;&#x2F;\n\t&#125;  \t\t\n\treturn 0;  \t\t\n&#125;  \t\t\n&#x2F;&#x2F;消费者线程函数\t\t\nDWORD WINAPI ThreadConsumer(LPVOID pM)  \t\t\n&#123;  \t\t\n\tfor (int i &#x3D; 0; i &lt; g_Max; i++)\t\t\n\t&#123;  \t\t\n\t\tWaitForSingleObject(g_hClear, INFINITE);\t&#x2F;&#x2F;\n\t\tg_Number &#x3D; 0; \n\t\tDWORD id &#x3D; GetCurrentThreadId();\n\t\tprintf(&quot;----消费者%d将数据%d放入缓冲区\\n&quot;,id, g_Number); \n\t\tSetEvent(g_hSet);\t\t&#x2F;&#x2F;\n\t&#125;  \t\t\n\treturn 0;  \t\t\n&#125;  \t\t\n\t\t\nint main(int argc, char* argv[])\t\t\n&#123;\t\t\n\t\t\n\tHANDLE hThread[2]; \t\t\n\t\t\n\tg_hSet &#x3D; CreateEvent(NULL, FALSE, TRUE, NULL); &#x2F;&#x2F;false:auto改 \ttrue:Producer先\n\tg_hClear &#x3D; CreateEvent(NULL, FALSE, FALSE, NULL); \t\t\t\t&#x2F;&#x2F;false\n\t\t\n\thThread[0] &#x3D; ::CreateThread(NULL, 0, ThreadProduct, NULL, 0, NULL); \t\t\n\thThread[1] &#x3D; ::CreateThread(NULL, 0, ThreadConsumer, NULL, 0, NULL);\t\n\t\t\n\tWaitForMultipleObjects(2, hThread, TRUE, INFINITE);  \t\t\n\tCloseHandle(hThread[0]);\t\t\n\tCloseHandle(hThread[1]);\t\t\n\t\t\n\t&#x2F;&#x2F;销毁 \t\n\tCloseHandle(g_hSet);  \t\n\tCloseHandle(g_hClear);  \t\t\n\t\t\n\tgetchar();\n\treturn 0;\t\n&#125;\t\t\n\n\n\n\n&#x2F;&#x2F;Semaphore:hongbao\n#include &quot;stdafx.h&quot;\t\t\t\t\n#include &quot;resource.h&quot;\t\t\t\t\nHANDLE hSemaphore;\t\t\t\t\nHWND hArray[3];\t\t\t\t\nHWND hEdit1;\nHWND hEdit2;\nHWND hEdit3;\nHWND hEdit4;\t\t\t\t\nHANDLE hThread[3];\n\t\t\t\nDWORD WINAPI ThreadProc1(LPVOID lpParameter)\t\t\t\t\n&#123;\t\t\t\t\n\tTCHAR szBuffer[10];\t\n\n\tDWORD dwTimmer&#x3D;0;\t\t\t\n\tWaitForSingleObject(hSemaphore, INFINITE);\n\t\n\tDWORD dwIndex &#x3D; (DWORD)lpParameter;\n\twhile(dwTimmer&lt;100)\t\t\t\n\t&#123;\t\t\t\n\t\tSleep(50);\t\t\n\t\tmemset(szBuffer,0,10);\t\t\n\t\tGetWindowText(hArray[dwIndex],szBuffer,10);\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwTimmer );\t\t\n\t\tdwTimmer++;\t\t\n\t\tmemset(szBuffer,0,10);\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwTimmer);\t\t\n\t\tSetWindowText(hArray[dwIndex],szBuffer);\t\t\n\t&#125;\t\t\t\n\tReleaseSemaphore(hSemaphore, 1, NULL);\t\t\t\n\treturn 0;\t\t\t\n&#125;\t\t\n\nDWORD WINAPI ThreadBegin(LPVOID lpParameter)\t\t\t\t\n&#123;\t\t\t\t\n\tTCHAR szBuffer[10];\t\t\t\n\tDWORD dwMoney&#x3D;0;\t\t\t\n\t\t\t\t\n\t\t\t\t\n\thSemaphore &#x3D; CreateSemaphore(NULL,0,3,NULL);\t\t\t\n\t\t\n\t\n\thThread[0] &#x3D; ::CreateThread(NULL, 0, ThreadProc1, (void*)0, 0, NULL);\t\t\t\n\thThread[1] &#x3D; ::CreateThread(NULL, 0, ThreadProc1, (void*)1, 0, NULL);\t\t\t\n\thThread[2] &#x3D; ::CreateThread(NULL, 0, ThreadProc1, (void*)2, 0, NULL);\t\t\t\n\t\t\t\t\n\t&#x2F;&#x2F;开始准备红包\t\t\t\n\twhile(dwMoney&lt;1000)\t\t\t\n\t&#123;\t\t\t\n\t\tmemset(szBuffer,0,10);\t\t\n\t\tGetWindowText(hEdit1,szBuffer,10);\t\t\n\t\tsscanf( szBuffer, &quot;%d&quot;, &amp;dwMoney );\t\t\n\t\tdwMoney++;\t\t\n\t\tmemset(szBuffer,0,10);\t\t\n\t\tsprintf(szBuffer,&quot;%d&quot;,dwMoney);\t\t\n\t\tSetWindowText(hEdit1,szBuffer);\t\t\n\t&#125;\t\t\t\n\tReleaseSemaphore(hSemaphore, 2, NULL);\t&#x2F;&#x2F;\t\t\n\t\t\t\t\n\t::WaitForMultipleObjects(3, hThread,TRUE,INFINITE);\t\t\t\n\t::CloseHandle(hSemaphore);\t\t\t\n\t\t\t\t\n\treturn 0;\t\t\t\n&#125;\t\t\t\t\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\t\t\t\t\n&#123;\t\t\t\t\n\tBOOL bRet &#x3D; FALSE;\t\t\t\n\t\t\t\t\n\tswitch(uMsg)\t\t\t\n\t&#123;\t\t\t\n\tcase WM_CLOSE:\t\t\t\n\t\t&#123;\t\t\n\t\t\tEndDialog(hDlg,0);\t\n\t\t\tbreak;\t\n\t\t&#125;\t\t\n\tcase WM_INITDIALOG:\t\t\t\n\t\t&#123;\t\t\n\t\t\thEdit1 &#x3D; GetDlgItem(hDlg,IDC_EDIT1);\t\n\t\t\thEdit2 &#x3D; GetDlgItem(hDlg,IDC_EDIT2);\t\n\t\t\thEdit3 &#x3D; GetDlgItem(hDlg,IDC_EDIT3);\t\n\t\t\thEdit4 &#x3D; GetDlgItem(hDlg,IDC_EDIT4);\t\n\t\t\t\t\n\t\t\tSetWindowText(hEdit1,&quot;0&quot;);\t\n\t\t\tSetWindowText(hEdit2,&quot;0&quot;);\t\n\t\t\tSetWindowText(hEdit3,&quot;0&quot;);\t\n\t\t\tSetWindowText(hEdit4,&quot;0&quot;);\t\n\n\t\t\thArray[0] &#x3D; hEdit2;\n\t\t\thArray[1] &#x3D; hEdit3;\n\t\t\thArray[2] &#x3D; hEdit4;\n\t\t\t\t\n\t\t\tbreak;\t\n\t\t&#125;\t\t\n\tcase WM_COMMAND:\t\t\t\n\t\t\t\t\n\t\tswitch (LOWORD (wParam))\t\t\n\t\t&#123;\t\t\n\t\tcase IDC_BUTTON1:\t\t\n\t\t\t&#123;\t\n\t\t\t\tCreateThread(NULL, 0, ThreadBegin,NULL, 0, NULL);\n\t\t\t\t\n\t\t\t\treturn TRUE;\n\t\t\t&#125;\t\n\t\t&#125;\t\t\n\t\tbreak ;\t\t\n\t&#125;\t\t\t\n\t\t\t\t\n\treturn bRet;\t\t\t\n&#125;\t\t\t\t\nint APIENTRY WinMain(HINSTANCE hInstance,\t\t\t\t\n\t\t\t\t\t HINSTANCE hPrevInstance,\t\t\t\t\n\t\t\t\t\t LPSTR     lpCmdLine,\t\t\t\t\n\t\t\t\t\t int       nCmdShow)\t\t\t\t\n&#123;\t\t\t\t\n\t&#x2F;&#x2F; TODO: Place code here.\t\t\t\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\t\t\t\n\treturn 0;\t\t\t\n&#125;\t\t\t\t\n\n\n\n\n\n\n\n\n\n&#x2F;*\n吃字母\n\n(1)ziyuan：输入ABCDEF\n(2)buffer*2\n(3)consumer*4\n\n(1)(3)资源间同步\n(2)资源与buffer之间R&#x2F;W互斥\n\nzzzzzz\n*&#x2F;\n\n#include &quot;stdafx.h&quot;\n#include &quot;resource.h&quot;\n&#x2F;&#x2F;文本框句柄\nHWND hEdit_RC;\nHWND hEdit_B1;\nHWND hEdit_B2;\nHWND hEdit_C1;\nHWND hEdit_C2;\nHWND hEdit_C3;\nHWND hEdit_C4;\n&#x2F;&#x2F;线程数组\nHANDLE hThread[5];\n&#x2F;&#x2F;互斥体[临界区]：缓冲区\nCRITICAL_SECTION g_Buffer_CS;\n&#x2F;&#x2F;信号量：缓冲区有空闲\nHANDLE hSemaphoreEmpty;\n&#x2F;&#x2F;信号量：缓冲区有资源\nHANDLE hSemaphoreFull;\n&#x2F;&#x2F;缓冲区文本框数组\nHWND hEditBuffer[3];\n&#x2F;&#x2F;消费者文本框数组\nHWND hEditCustomer[4];\n\nDWORD WINAPI ThreadProduct(LPVOID lpParameter)\n&#123;\n\tTCHAR szBuffer[256];\n\tTCHAR szTemp[2];\n\tDWORD dwLength;\n\tmemset(szBuffer,0,256);\n\n\tGetWindowText(hEdit_RC,szBuffer,256);\n\tdwLength &#x3D; strlen(szBuffer);\n\tif(dwLength &#x3D;&#x3D; 0)\n\t\treturn -1;\n\tfor(DWORD i&#x3D;0;i&lt;dwLength;i++)\n\t&#123;\n\t\t&#x2F;&#x2F;等待缓冲区可写资源的信息\n\t\tWaitForSingleObject(hSemaphoreEmpty, INFINITE);&#x2F;&#x2F;empty-1\n\t\t&#x2F;&#x2F;找到可写的缓冲区\n\t\tfor(DWORD k&#x3D;0;k&lt;2;k++)\n\t\t&#123;\n\t\t\tmemset(szTemp,0,2);\n\t\t\tEnterCriticalSection(&amp;g_Buffer_CS); \n\t\t\tGetWindowText(hEditBuffer[k],szTemp,2);\n\t\t\tif(!strcmp(szTemp,&quot;0&quot;))\n\t\t\t&#123;\n\t\t\t\tTCHAR szT[2] &#x3D; &#123;0&#125;;\n\t\t\t\tmemcpy(szT,&amp;szBuffer[i],1);\n\t\t\t\tSetWindowText(hEditBuffer[k],szT);\n\t\t\t\tLeaveCriticalSection(&amp;g_Buffer_CS); \n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\tLeaveCriticalSection(&amp;g_Buffer_CS); \n\t\t&#125;\n\t\t&#x2F;&#x2F;通知 缓冲区有资源\n\t\tSleep(1000);\n\t\tReleaseSemaphore(hSemaphoreFull, 1, NULL);&#x2F;&#x2F;full+1\n\t&#125;\n\treturn 0;\n&#125;\n\nDWORD WINAPI ThreadCustomer(LPVOID lpParameter)\n&#123;\n\tTCHAR szTemp[2];\n\tTCHAR szBuffer[256];\n\tTCHAR szNewBuffer[256];\n\tDWORD dwExitCode;\n\twhile(true)\n\t&#123;\n\t\t&#x2F;&#x2F;等待缓冲区有资源\n\t\tdwExitCode &#x3D; WaitForSingleObject(hSemaphoreFull, 10000);\n\t\tif(dwExitCode &#x3D;&#x3D; 0x102)\n\t\t\treturn -1;\n\t\t&#x2F;&#x2F;找到可写取资源的缓冲区\n\t\tEnterCriticalSection(&amp;g_Buffer_CS); \n\t\tfor(DWORD k&#x3D;0;k&lt;2;k++)\n\t\t&#123;\n\t\t\tmemset(szTemp,0,2);\n\t\t\tGetWindowText(hEditBuffer[k],szTemp,2);\n\t\t\tif(strcmp(szTemp,&quot;0&quot;))\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;存储到自己的文本框\n\t\t\t\tDWORD dwCusIndex &#x3D; (DWORD)lpParameter;\n\t\t\t\tmemset(szBuffer,0,256);\n\t\t\t\tGetWindowText(hEditCustomer[dwCusIndex],szBuffer,256);\n\t\t\t\tsprintf(szNewBuffer,&quot;%s-%s&quot;,szBuffer,szTemp);&#x2F;&#x2F;\n\t\t\t\tSetWindowText(hEditCustomer[dwCusIndex],szNewBuffer);\n\t\t\t\tSleep(500);\n\t\t\t\tSetWindowText(hEditBuffer[k],&quot;0&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tLeaveCriticalSection(&amp;g_Buffer_CS); \n\t\t&#x2F;&#x2F;通知 缓冲区可写\n\t\tSleep(1000);\n\t\tReleaseSemaphore(hSemaphoreEmpty, 1, NULL);\n\t&#125;\n\treturn 0;\n&#125;\n\nDWORD WINAPI ThreadMain(LPVOID lpParameter)\n&#123;\n\t&#x2F;&#x2F;创建信号量\n\thSemaphoreEmpty &#x3D; CreateSemaphore(NULL,2,2,NULL);\n\thSemaphoreFull &#x3D; CreateSemaphore(NULL,0,2,NULL);\n\t&#x2F;&#x2F;创建临界区\n\tInitializeCriticalSection(&amp;g_Buffer_CS);\n\t&#x2F;&#x2F;创建线程\n\thThread[0] &#x3D; ::CreateThread(NULL, 0, ThreadProduct,NULL, 0, NULL);\n\thThread[1] &#x3D; ::CreateThread(NULL, 0, ThreadCustomer,(void*)0, 0, NULL);\n\thThread[2] &#x3D; ::CreateThread(NULL, 0, ThreadCustomer,(void*)1, 0, NULL);\n\thThread[3] &#x3D; ::CreateThread(NULL, 0, ThreadCustomer,(void*)2, 0, NULL);\n\thThread[4] &#x3D; ::CreateThread(NULL, 0, ThreadCustomer,(void*)3, 0, NULL);\n\t&#x2F;&#x2F;等待线程结束\n\t::WaitForMultipleObjects(5, hThread,TRUE,INFINITE);\n\t::CloseHandle(hSemaphoreEmpty);\n\t::CloseHandle(hSemaphoreFull);\n\t::DeleteCriticalSection(&amp;g_Buffer_CS);  \n\n\treturn 0;\n&#125;\n\nBOOL CALLBACK MainDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)\n&#123;\n\tBOOL bRet &#x3D; FALSE;\n\t\n\tswitch(uMsg)\n\t&#123;\n\tcase WM_CLOSE:\n\t\t&#123;\n\t\t\tEndDialog(hDlg,0);\n\t\t\tbreak;\n\t\t&#125;\n\tcase WM_INITDIALOG:\n\t\t&#123;\n\t\t\thEdit_RC &#x3D; GetDlgItem(hDlg,IDC_EDIT_RC);\n\t\t\thEdit_B1 &#x3D; GetDlgItem(hDlg,IDC_EDIT_B1);\n\t\t\thEdit_B2 &#x3D; GetDlgItem(hDlg,IDC_EDIT_B2);\n\t\t\thEditBuffer[0] &#x3D; hEdit_B1;\n\t\t\thEditBuffer[1] &#x3D; hEdit_B2;\n\t\t\thEdit_C1 &#x3D; GetDlgItem(hDlg,IDC_EDIT_C1);\n\t\t\thEdit_C2 &#x3D; GetDlgItem(hDlg,IDC_EDIT_C2);\n\t\t\thEdit_C3 &#x3D; GetDlgItem(hDlg,IDC_EDIT_C3);\n\t\t\thEdit_C4 &#x3D; GetDlgItem(hDlg,IDC_EDIT_C4);\n\t\t\thEditCustomer[0] &#x3D; hEdit_C1;\n\t\t\thEditCustomer[1] &#x3D; hEdit_C2;\n\t\t\thEditCustomer[2] &#x3D; hEdit_C3;\n\t\t\thEditCustomer[3] &#x3D; hEdit_C4;\n\t\t\tSetWindowText(hEdit_RC,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit_B1,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit_B2,&quot;0&quot;);\n\t\t\tSetWindowText(hEdit_C1,&quot;&quot;);\n\t\t\tSetWindowText(hEdit_C2,&quot;&quot;);\n\t\t\tSetWindowText(hEdit_C3,&quot;&quot;);\n\t\t\tSetWindowText(hEdit_C4,&quot;&quot;);\n\t\t\t\n\t\t\tbreak;\n\t\t&#125;\n\tcase WM_COMMAND:\n\t\t\n\t\tswitch (LOWORD (wParam))\n\t\t&#123;\n\t\tcase IDC_BUTTON_BEGIN:\n\t\t\t&#123;\n\n\t\t\t\tCreateThread(NULL, 0, ThreadMain,NULL, 0, NULL);\n\t\t\t\t\n\t\t\t\treturn TRUE;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\tbreak ;\n\t&#125;\n\t\n\treturn bRet;\n&#125;\nint APIENTRY WinMain(HINSTANCE hInstance,\n\t\t\t\t\t HINSTANCE hPrevInstance,\n\t\t\t\t\t LPSTR     lpCmdLine,\n\t\t\t\t\t int       nCmdShow)\n&#123;\n\t&#x2F;&#x2F; TODO: Place code here.\n\n\tDialogBox(hInstance,MAKEINTRESOURCE(IDD_DIALOG_MAIN),NULL,MainDlgProc);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;&#x2F;进程\n&#x2F;&#x2F;process1\n#include &quot;windows.h&quot;\n\nVOID TestCreateProcess()\t\t\n&#123;\t\t\n\tSTARTUPINFO si &#x3D; &#123;0&#125;;   \t\n\t\tPROCESS_INFORMATION pi;\t\n\t\t\n\tsi.cb &#x3D; sizeof(si);\t\n\t\t\n\tTCHAR szCmdline[] &#x3D;TEXT(&quot; http:&#x2F;&#x2F;www.ifeng.com&quot;);&#x2F;&#x2F;space~\n\t\t\n\tBOOL res &#x3D; CreateProcess(\t\n\t\tTEXT(&quot;c:&#x2F;&#x2F;program files&#x2F;&#x2F;internet explorer&#x2F;&#x2F;iexplore.exe&quot;), \n\t\tszCmdline, \n\t\tNULL, \n\t\tNULL, \n\t\tFALSE, \n\t\tCREATE_NEW_CONSOLE, \n\t\tNULL, \n\t\tNULL, &amp;si, &amp;pi); \n\n\t&#x2F;&#x2F;printf(&quot;%x %x %x %x\\n&quot;,pi.dwProcessId,pi.dwThreadId,pi.hProcess,pi.hThread);\n&#125;\t\n\nint main(int argc, char* argv[])\n&#123;\n\tTestCreateProcess();\n\n&#x2F;&#x2F;\tprintf(&quot;%s\\n&quot;, argv[0]);\n&#x2F;&#x2F;\tprintf(&quot;%s\\n&quot;, argv[1]);\n\n\tgetchar();\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;[句柄的继承]\n&#x2F;&#x2F;父进程handle\n#include &quot;windows.h&quot;\n\nint main(int argc, char* argv[])\n&#123;\n\tchar szBuffer[256] &#x3D; &#123;0&#125;;\n\tchar szHandle[8] &#x3D; &#123;0&#125;;\n\n\tSECURITY_ATTRIBUTES sa;\n\tsa.nLength &#x3D; sizeof(sa);\n\tsa.lpSecurityDescriptor &#x3D; NULL;\n\tsa.bInheritHandle &#x3D; TRUE; \n\t&#x2F;&#x2F;创建一个可以被继承的内核对象\n\tHANDLE g_hEvent &#x3D; CreateEvent(&amp;sa, TRUE, FALSE, NULL);\n\n\t&#x2F;&#x2F;组织命令行参数\t\n\tsprintf(szHandle,&quot;%x&quot;,g_hEvent);\t\n\tsprintf(szBuffer,&quot;C:&#x2F;handle2.exe %s&quot;,szHandle);&#x2F;&#x2F;子进程 父句柄\n\t\t\n\t&#x2F;&#x2F;定义创建进程需要用的结构体\t\n\tSTARTUPINFO si &#x3D; &#123;0&#125;;   \t\n\tPROCESS_INFORMATION pi;\t\n\tsi.cb &#x3D; sizeof(si);\t\n\t\n\t&#x2F;&#x2F;创建子进程\t\n\tBOOL res &#x3D; CreateProcess(\t\n\t\tNULL, \n\t\tszBuffer, \n\t\tNULL, \n\t\tNULL, \n\t\tTRUE, &#x2F;&#x2F; 允许继承（&#x3D;1）的句柄，copy父进程句柄表\n\t\tCREATE_NEW_CONSOLE, \n\t\tNULL, \n\t\tNULL, &amp;si, &amp;pi); \n\n\t&#x2F;&#x2F;设置事件为已通知\n\tSetEvent(g_hEvent);&#x2F;&#x2F;下断点，单步~~~~~~~~~~~~~~~~~~~~~~\n\n\t&#x2F;&#x2F;关闭句柄 内核对象是否会被销毁？否\n\tCloseHandle(g_hEvent);\n\n\tgetchar();\n\n\treturn 0;\n&#125;\n\n\n\n\n&#x2F;&#x2F;子进程handle2\n#include &quot;windows.h&quot;\n\nint main(int argc, char* argv[])\n&#123;\n\tchar szBuffer[256] &#x3D; &#123;0&#125;;\n\n\tmemcpy(szBuffer,argv[1],8);\n\n\tDWORD dwHandle &#x3D; 0;\n\n\tsscanf(szBuffer,&quot;%x&quot;,&amp;dwHandle);\n\n\tprintf(&quot;%s\\n&quot;,argv[0]);&#x2F;&#x2F; 子进程\n\n\tprintf(&quot;%x\\n&quot;,dwHandle);&#x2F;&#x2F; 父句柄\n\n\tHANDLE g_hEvent &#x3D; (HANDLE)dwHandle;&#x2F;&#x2F;复制系统有效句柄表\n\n\n\tprintf(&quot;开始等待.....\\n&quot;);\n\t&#x2F;&#x2F;当事件变成已通知时 \n\tWaitForSingleObject(g_hEvent, INFINITE);\n\n\tDWORD dwCode &#x3D; GetLastError();\n\n\tprintf(&quot;等到消息.....%x\\n&quot;,dwCode);\n\n\tgetchar();\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n2、以挂起的方式创建进程，获取进程的ImageBase和AddressOfEntryPoint\n\nSTARTUPINFO ie_si &#x3D; &#123;0&#125;;   \t\nPROCESS_INFORMATION ie_pi;\t\nie_si.cb &#x3D; sizeof(ie_si);\t\n\t\n&#x2F;&#x2F;以挂起的方式创建进程\t\nTCHAR szBuffer[256] &#x3D; &quot;C:\\\\ipmsg.exe&quot;;\t\nCreateProcess(\t\n\tNULL,                    &#x2F;&#x2F; name of executable module\n\tszBuffer,                &#x2F;&#x2F; command line string\n\tNULL, \n\tNULL,  \n\tFALSE,                   &#x2F;&#x2F; handle inheritance option\n\tCREATE_SUSPENDED,     \n\tNULL,                    &#x2F;&#x2F; new environment block\n\tNULL,                    &#x2F;&#x2F; current directory name\n\t&amp;ie_si,                  &#x2F;&#x2F; startup information\n\t&amp;ie_pi                   &#x2F;&#x2F; process information\n\t);\n\t\n\t\nCONTEXT contx;  \t\ncontx.ContextFlags &#x3D; CONTEXT_FULL;  \t\n\t\n\t\nGetThreadContext(ie_pi.hThread, &amp;contx);\t\n\t\n&#x2F;&#x2F;获取入口点：ImageBase+AddressOfEntryPoint\t\nDWORD dwEntryPoint &#x3D; contx.Eax;\t\n\t\n&#x2F;&#x2F;获取ImageBase\t\nchar* baseAddress &#x3D; (CHAR *) contx.Ebx+8;\t\n\t\nmemset(szBuffer,0,256);\t\n\t\nReadProcessMemory(ie_pi.hProcess,baseAddress,szBuffer,4,NULL);\t\n\t\n&#x2F;&#x2F;将自己的壳子 拉伸 替换外壳程序。。。。\n\n\n&#x2F;&#x2F;恢复执行\nResumeThread(ie_pi.hThread);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\nhttps:&#x2F;&#x2F;download.csdn.net&#x2F;download&#x2F;xubiniq&#x2F;364282\n\n\n&#x2F;&#x2F;2015-5-21加密壳项目video:\t\thttps:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1yt41127Cd?p&#x3D;85\n&#x2F;&#x2F;part\nhttps:&#x2F;&#x2F;bbs.pediy.com&#x2F;thread-258555.htm\nhttps:&#x2F;&#x2F;bbs.pediy.com&#x2F;thread-258657.htm\nhttps:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1135335-1-1.html\nhttps:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-931981-1-1.html        shell.rar&#x2F;123.rar\n&#x2F;&#x2F;file\nhttps:&#x2F;&#x2F;www.haolizi.net&#x2F;example&#x2F;view_27057.html\nhttps:&#x2F;&#x2F;download.csdn.net&#x2F;download&#x2F;qq_41490873&#x2F;11255977?utm_medium&#x3D;distribute.pc_relevant_download.none-task-download-blogcommendfrombaidu-1.nonecase&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_download.none-task-download-blogcommendfrombaidu-1.nonecase\n&#x2F;&#x2F;blog\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;ABCDABCD321123&#x2F;article&#x2F;details&#x2F;106852327?utm_medium&#x3D;distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase\n\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;ILXYR&#x2F;p&#x2F;13436933.html\n&#x2F;&#x2F;PEStudy.h\n#pragma once\n#define _CRT_SECURE_NO_WARNINGS\n#include &lt;wtypes.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;Windows.h&gt;\n#include&lt;stdlib.h&gt;\n\nclass PEStudy\n&#123;\npublic:\n\tsize_t thisSize;&#x2F;&#x2F;This data is the size of opende file\n\tIN CHAR _lpszfFile[100] &#x3D; &quot;C:\\\\Users\\\\86182\\\\source\\\\repos\\\\Shell\\\\Release\\\\Shell.exe&quot;;\n\tOUT LPVOID* _pFileBuffer &#x3D; nullptr;\n\tPIMAGE_RESOURCE_DIRECTORY pImageResourceHeader &#x3D; nullptr;&#x2F;&#x2F;this ptr is init in the findresource() func\n\tPIMAGE_DOS_HEADER pImageDosHeader &#x3D; nullptr;\n\tPIMAGE_FILE_HEADER pImageFileHeader &#x3D; nullptr;\n\tPIMAGE_OPTIONAL_HEADER pImageOptionalPEHeader &#x3D; nullptr;\n\tPIMAGE_OPTIONAL_HEADER64 pImageOptionalHeader64 &#x3D; nullptr;\n\tPIMAGE_SECTION_HEADER pImageSectionHeads[99] &#x3D; &#123; nullptr &#125;;\n\tWORD SectionNumNow &#x3D; 0;&#x2F;&#x2F;The section number\n\n\tvoid initAllPoint();\n\tsize_t readFileBufferToTempBuffer(IN CHAR* lpszfFile, OUT LPVOID* pFileBuffer);&#x2F;&#x2F; lpszFile: The road of the desFile\n\tvoid printDosHeader();\n\tvoid printFilePEHeader();\n\tvoid printOptionalPEHeader();&#x2F;&#x2F;各种表的数据均未导出\n\tvoid getSectionHeaders();\n\tWORD maxNow(DWORD a, DWORD b) &#123; return a &gt; b ? a : b; &#125;\n\tDWORD RVAToFOA(DWORD RVA);\n\tDWORD FOAToRVA(DWORD RVA);\n\tDWORD querryAddress(DWORD beforeAddress, DWORD Size, DWORD align);\n\tvoid addASection(const char* chunkName,DWORD chunkSize);\n\tvoid SaveToTheSameCatalog(const char* fileName);\n\tvoid addSize(DWORD chunkSize);\n\t&#x2F;*********************************************************************************\n\t * the size of this added chunk is 0x1000 byte ,the same catalog is not doing now\n\t * fileName is the name of the file which saves your changeed data\n\t * chunkName is the name of the chunk you add\n\t *********************************************************************************&#x2F;\n\tvoid changeExportTable();&#x2F;&#x2F;DataDirectory[0]; 导出表\n\tvoid splayTheFile();\n\tvoid findResource();\n\tstatic PEStudy* getInstance();\nprivate:\n\tvoid DFSFindResource1(DWORD offset);\n\tvoid DFSFindResource2(DWORD offset);\n\tstatic PEStudy* _Instance;\n&#125;;\n\n\n\n&#x2F;&#x2F;PEStudy.cpp\n#include &quot;PEStudy.h&quot;\n#include&lt;Windows.h&gt;\n\nPEStudy* PEStudy::_Instance &#x3D; nullptr;\n\nPEStudy* PEStudy::getInstance()\n&#123;\n\tif (!_Instance)\n\t&#123;\n\t\t_Instance &#x3D; new PEStudy;\n\t&#125;\n\treturn _Instance;\n&#125;\n\nvoid PEStudy::addSize(DWORD chunkSize)\n&#123;\n\tchar* des &#x3D; (char*)((DWORD)(*_pFileBuffer) + thisSize);\n\tthisSize +&#x3D; chunkSize;\n\t\n\tvoid* tmp &#x3D; realloc(*_pFileBuffer, thisSize);\n\tif (!tmp);&#x2F;&#x2F;printf(&quot;realloc failed!!!\\n&quot;);\n\telse *_pFileBuffer &#x3D; tmp;\n\t\n\tmemset(des, 0, chunkSize);\n&#125;\n\nvoid PEStudy::changeExportTable()&#x2F;&#x2F;DataDirectory[0]; 导出表\n&#123;\n\tif (!pImageOptionalPEHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;Open file failed!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tgetSectionHeaders();\n\n\t_IMAGE_DATA_DIRECTORY now &#x3D; pImageOptionalPEHeader-&gt;DataDirectory[0];\n\n\tDWORD to &#x3D; RVAToFOA(now.VirtualAddress);\n\n\tPIMAGE_EXPORT_DIRECTORY ExportTable &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)(*_pFileBuffer) + to);\n\n\t&#x2F;*DWORD* to2 &#x3D; (DWORD*)((DWORD)(*_pFileBuffer) + (DWORD)RVAToFOA((DWORD)ExportTable-&gt;AddressOfNames));\n\t\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfNames + 7; i++)\n\t&#123;\n\t\tDWORD dress &#x3D; RVAToFOA(*to2);\n\t\tchar* name1 &#x3D; (char*)((DWORD)(*_pFileBuffer) + dress);\n\t\tto2++;\n\t&#125;*&#x2F;\n\n\tDWORD* addressOfFunctions, * addressOfNames, * addressOfOrdinals;\n\t&#x2F;&#x2F;这三个数组记录每个单元的是这些具体数据的虚拟地址\n\taddressOfFunctions &#x3D; (DWORD*)((DWORD)(*_pFileBuffer) + (DWORD)RVAToFOA((DWORD)ExportTable-&gt;AddressOfFunctions));\n\taddressOfNames &#x3D; (DWORD*)((DWORD)(*_pFileBuffer) + (DWORD)RVAToFOA((DWORD)ExportTable-&gt;AddressOfNames));\n\taddressOfOrdinals &#x3D; (DWORD*)((DWORD)(*_pFileBuffer) + (DWORD)RVAToFOA((DWORD)ExportTable-&gt;AddressOfNameOrdinals));\n\n\tchar* WriteTo &#x3D; (char*)pImageSectionHeads[pImageFileHeader-&gt;NumberOfSections - 1]-&gt;PointerToRawData;\n\n\tExportTable-&gt;AddressOfFunctions &#x3D; FOAToRVA((DWORD)WriteTo);\n\t\t\n\n\tWriteTo &#x3D; (char*)((DWORD)WriteTo + (DWORD)*_pFileBuffer);&#x2F;&#x2F;把修改内存的writeto指针指向要修改的区域\n\tDWORD* ali &#x3D; (DWORD*)WriteTo;\n\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfNames; i++)\n\t&#123;\n\t\tchar* see &#x3D; (char*)((DWORD)*_pFileBuffer + RVAToFOA((DWORD)addressOfNames[i]));\n\t&#125;\n\n\t&#x2F;&#x2F;memcpy(WriteTo, addressOfFunctions, ExportTable-&gt;NumberOfFunctions * 4);\n\n\tDWORD* RVAChange &#x3D; (DWORD*)ali, * RVADes &#x3D; NULL;\n\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfFunctions; i++)ali++;&#x2F;&#x2F;挪出导出函数RVA储存空间\n\tRVADes &#x3D; (DWORD*)ali;&#x2F;&#x2F;该地址开始转RVA\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfFunctions; i++)\n\t&#123;\n\t\tDWORD source &#x3D; (DWORD)((DWORD)(*_pFileBuffer) + RVAToFOA((DWORD)addressOfFunctions[i]));\n\t\tDWORD* tmp &#x3D; (DWORD*)source;\n\t\t*ali &#x3D; *tmp;\n\t\tali++;\n\t&#125;&#x2F;&#x2F;函数的具体数据，挪出的空间存储他们\n\n\tfor (int i &#x3D; 0; i &lt; ExportTable-&gt;NumberOfFunctions; i++)\n\t&#123;\n\t\tRVAChange[i] &#x3D; FOAToRVA((DWORD)(RVADes + i) - (DWORD)(*_pFileBuffer));\n\t&#125;\n\n\n\treturn;\n&#125;\n\nDWORD PEStudy::querryAddress(DWORD beforeAddress, DWORD Size, DWORD align)&#x2F;&#x2F; 原来的偏移地址   数据大小    对齐大小\n&#123;\n\twhile ((beforeAddress + Size) % align)Size++;\n\treturn beforeAddress + Size;\n&#125;\n\nvoid PEStudy::SaveToTheSameCatalog(const char* fileName)\n&#123;\n\tFILE* fp;\n\n\tif ((fp &#x3D; fopen(fileName, &quot;wb+&quot;)) &#x3D;&#x3D; NULL)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;Open failed!!!\\nThere is another .exe opened this file&quot;);\n\t\treturn;\n\t&#125;\n\n\n\tvoid* now &#x3D; (*_pFileBuffer);\n\n\tif (!fwrite(now, 1, thisSize, fp))\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;Push data wrong,the problem question is the data size is not same!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\n\tfflush(fp);\n\n\tfclose(fp);\n\n\t&#x2F;&#x2F;printf(&quot;Sucess!!!\\n&quot;);\n&#125;\n\nvoid PEStudy::addASection(const char* chunkName, DWORD chunkSize)\n&#123;\n\tif (!pImageFileHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;FIle open failed!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tif (!SectionNumNow)\n\t&#123;\n\t\tgetSectionHeaders();\n\t\tif (!SectionNumNow)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;FIle open failed!!!\\n&quot;);\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;pImageFileHeader\n\tpImageOptionalPEHeader-&gt;SizeOfImage +&#x3D; chunkSize;\n\t\n\tSectionNumNow &#x3D; ++pImageFileHeader-&gt;NumberOfSections;&#x2F;&#x2F;section加一（块）\n\n\tstrcpy((char*)pImageSectionHeads[SectionNumNow - 1]-&gt;Name, chunkName);\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;Misc.VirtualSize &#x3D; (DWORD)chunkSize;\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;Characteristics &#x3D; (DWORD)0x60000020;\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;SizeOfRawData &#x3D; (DWORD)chunkSize;\n\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;PointerToRawData &#x3D; querryAddress(pImageSectionHeads[SectionNumNow - 2]-&gt;PointerToRawData\n\t\t, pImageSectionHeads[SectionNumNow - 2]-&gt;SizeOfRawData, pImageOptionalPEHeader-&gt;FileAlignment);\n\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;VirtualAddress &#x3D; querryAddress(pImageSectionHeads[SectionNumNow - 2]-&gt;VirtualAddress,\n\t\tmaxNow(pImageSectionHeads[SectionNumNow - 2]-&gt;SizeOfRawData, pImageSectionHeads[SectionNumNow - 2]-&gt;Misc.VirtualSize),\n\t\tpImageOptionalPEHeader-&gt;SectionAlignment);\n\n\tpImageSectionHeads[SectionNumNow - 1]-&gt;NumberOfLinenumbers &#x3D; pImageSectionHeads[SectionNumNow - 1]-&gt;NumberOfRelocations &#x3D;\n\t\tpImageSectionHeads[SectionNumNow - 1]-&gt;PointerToLinenumbers &#x3D; pImageSectionHeads[SectionNumNow - 1]-&gt;PointerToRelocations &#x3D; 0;\n\n&#125;\n\nvoid PEStudy::getSectionHeaders()\n&#123;\n\tif (!pImageFileHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;pImageFileHeader is nullptr!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tSectionNumNow &#x3D; pImageFileHeader-&gt;NumberOfSections;\n\tauto filePoint &#x3D; *(_pFileBuffer);\n\n\tfor (int i &#x3D; 0; i &lt; SectionNumNow + 7; i++)&#x2F;&#x2F;加上7的原因是获得接下来空节表的地址，配合addSection函数使用的\n\t\tpImageSectionHeads[i] &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pImageOptionalPEHeader + pImageFileHeader-&gt;SizeOfOptionalHeader + i * 40);\n&#125;\n\nvoid PEStudy::printOptionalPEHeader()&#x2F;&#x2F;各种表的数据均未导出\n&#123;\n\tif (!pImageOptionalPEHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;pImageOptionalPEHeader is nullptr!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\treturn;\n&#125;\n\nvoid PEStudy::printFilePEHeader()\n&#123;\n\tif (!pImageFileHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;pImageFileHeader is null ptr&quot;);\n\t\treturn;\n\t&#125;\n\treturn;\n&#125;\n\nvoid PEStudy::initAllPoint()\n&#123;\n\t\n\n\tif (!thisSize)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;Open failed!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tauto filePoint &#x3D; *(_pFileBuffer);\n\n\tpImageDosHeader &#x3D; (PIMAGE_DOS_HEADER)(filePoint);\n\n\tpImageFileHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)filePoint + pImageDosHeader-&gt;e_lfanew + 0x4);\n\n\tpImageOptionalPEHeader &#x3D; (PIMAGE_OPTIONAL_HEADER)((DWORD)pImageFileHeader + 20);\n&#125;\n\nsize_t PEStudy::readFileBufferToTempBuffer(IN CHAR* lpszfFile, OUT LPVOID* pFileBuffer)&#x2F;&#x2F; lpszFile: The road of the desFile\n&#123;\n\tFILE* fp;\n\tDWORD fileSize &#x3D; 0;\n\tvoid* pTempFileBuffer &#x3D; NULL;\n\n\tif ((fp &#x3D; fopen(lpszfFile, &quot;rb&quot;)) &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;OpenFailed!!!&quot;), 0, 0);\n\t\treturn 0;\n\t&#125;\n\n\t&#x2F;&#x2F;find the teXt size\n\tfseek(fp, 0, SEEK_END);\n\tfileSize &#x3D; ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n\n\tpTempFileBuffer &#x3D; malloc(fileSize);\n\n\tif (!pTempFileBuffer)\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;The leaved space is not enough!!!!\\n&quot;), 0, 0);\n\t\tfclose(fp);\n\t\treturn 0;\n\t&#125;\n\n\tsize_t readSucess &#x3D; fread(pTempFileBuffer, fileSize, 1, fp);\n\n\tif (!readSucess)\n\t&#123;\n\t\tfclose(fp);\n\t\treturn 0;\n\t&#125;\n\n\tthisSize &#x3D; fileSize;\n\t*pFileBuffer &#x3D; pTempFileBuffer;\n\tpTempFileBuffer &#x3D; NULL;\n\tfclose(fp);\n\n\treturn fileSize;\n\n&#125;\n\nvoid PEStudy::printDosHeader()\n&#123;\n\tif (!pImageDosHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;&#x2F;&#x2F;printf(&quot;The pImageDOsHeader is nullptr!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\t\n&#125;\n\nDWORD PEStudy::RVAToFOA(DWORD RVA)\n&#123;\n\tif (!SectionNumNow)\n\t&#123;\n\t\tgetSectionHeaders();\n\t\tif (!SectionNumNow)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;The File opened failed!!!\\n&quot;);\n\t\t\tsystem(&quot;pause&quot;);\n\t\t\treturn -1;\n\t\t&#125;\n\t&#125;\n\tfor (int i &#x3D; 0; i &lt; SectionNumNow; i++)\n\t&#123;\n\t\tDWORD see &#x3D; pImageSectionHeads[i]-&gt;VirtualAddress + pImageSectionHeads[i]-&gt;SizeOfRawData;&#x2F;&#x2F;在数据里，就不用考虑内存对齐前的大小了\n\t\tif (see &gt;&#x3D; RVA &amp;&amp; pImageSectionHeads[i]-&gt;VirtualAddress &lt;&#x3D; RVA)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;&#x2F;&#x2F;printf(&quot;RVA is in the %dth Section!!!\\n&quot;, i);\n\t\t\t&#x2F;&#x2F;&#x2F;&#x2F;printf(&quot;FOA is 0x%X\\n&quot;, RVA - pImageSectionHeads[i]-&gt;VirtualAddress + pImageSectionHeads[i]-&gt;PointerToRawData);\n\t\t\treturn RVA - pImageSectionHeads[i]-&gt;VirtualAddress + pImageSectionHeads[i]-&gt;PointerToRawData;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;printf(&quot;Data is illegal!!!\\n&quot;);\n\treturn -1;\n&#125;\n\nDWORD PEStudy::FOAToRVA(DWORD FOA)\n&#123;\n\tif (!SectionNumNow)\n\t&#123;\n\t\tgetSectionHeaders();\n\t\tif (!SectionNumNow)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;The File opened failed!!!\\n&quot;);\n\t\t\tsystem(&quot;pause&quot;);\n\t\t\treturn -1;\n\t\t&#125;\n\t&#125;\n\n\tfor (int i &#x3D; 0; i &lt; SectionNumNow; i++)\n\t&#123;\n\t\t\n\t\tif (pImageSectionHeads[i]-&gt;PointerToRawData &lt;&#x3D; FOA &amp;&amp;\n\t\t\tpImageSectionHeads[i]-&gt;PointerToRawData + pImageSectionHeads[i]-&gt;SizeOfRawData &gt; FOA)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;FOA is in the %dth Section!!!\\n&quot;, i);\n\t\t\t&#x2F;&#x2F;printf(&quot;RVA is 0x%X\\n&quot;, FOA - pImageSectionHeads[i]-&gt;PointerToRawData + pImageSectionHeads[i]-&gt;VirtualAddress);\n\t\t\treturn FOA - pImageSectionHeads[i]-&gt;PointerToRawData + pImageSectionHeads[i]-&gt;VirtualAddress;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;printf(&quot;Data is illegal!!!\\n&quot;);\n\treturn -1;\n&#125;\n\nvoid PEStudy::DFSFindResource2(DWORD offset)\n&#123;\n\tint idx &#x3D; -1;\n\tfor (int i &#x3D; 0; i &lt;&#x3D; SectionNumNow; i++)\n\t\tif (!strcmp((const char*)pImageSectionHeads[i]-&gt;Name, &quot;.rsrc&quot;))idx &#x3D; i;\n\tauto now &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)offset +\n\t\t(DWORD)(*_pFileBuffer) + pImageSectionHeads[idx]-&gt;PointerToRawData);\n\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY DiaLogNow &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(\n\t\t(DWORD)now + (DWORD)16);\n\t\t\n\t&#x2F;&#x2F;printf(&quot;---------------该资源的语言内码为：%d\\n&quot;, DiaLogNow[0].Name);\n\n\tauto real &#x3D; (PIMAGE_RESOURCE_DATA_ENTRY)((DWORD)DiaLogNow[0].OffsetToData +\n\t\t(DWORD)(*_pFileBuffer) + pImageSectionHeads[idx]-&gt;PointerToRawData);\n\n\t&#x2F;&#x2F;printf(&quot;RVA:%X\\nFOA:%X\\nSIZE:%X\\n&quot;, real-&gt;OffsetToData, RVAToFOA(real-&gt;OffsetToData), real-&gt;Size);\n\n\treturn;\n\n\t\t\t&#x2F;&#x2F;DFSFindResource(DiaLogNow[i].OffsetToDirectory);\n\t\t\n\t\n&#125;\n\nvoid PEStudy::DFSFindResource1(DWORD offset)\n&#123;\n\tint idx &#x3D; -1;\n\tfor(int i&#x3D;0;i&lt;&#x3D;SectionNumNow;i++)\n\tif(!strcmp((const char *)pImageSectionHeads[i]-&gt;Name,&quot;.rsrc&quot;))idx&#x3D;i;\n\tauto now &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)offset + \n\t\t(DWORD)(*_pFileBuffer) + pImageSectionHeads[idx]-&gt;PointerToRawData);\n\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY DiaLogNow &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(\n\t\t(DWORD)now + (DWORD)16);\n\n\n\tfor (int i &#x3D; 0; i &lt; now-&gt;NumberOfIdEntries + now-&gt;NumberOfNamedEntries; i++)\n\t&#123;\n\t\tif (!DiaLogNow[i].NameIsString)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;该物品编号为：%d\\n该位置的下一项目录是否为具体资源：%s\\n&quot;,\n\t\t\t\t&#x2F;&#x2F;DiaLogNow[i].Id, DiaLogNow[i].DataIsDirectory ? &quot;NO&quot; : &quot;YES&quot;);\n\t\t\tDFSFindResource2(DiaLogNow[i].OffsetToDirectory);\n\t\t&#125;\n\t\telse; &#x2F;&#x2F;printf(&quot;---------------------------用户自制资源！！！------------------------------------\\n&quot;);\n\t&#125;\n\n\n\treturn;\n&#125;\n\nvoid PEStudy::findResource()\n&#123;\n\tif (!pImageOptionalPEHeader)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;open file failed!!!!\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\tauto ali &#x3D; pImageOptionalPEHeader-&gt;DataDirectory[2];\n\n\tpImageResourceHeader &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)RVAToFOA(ali.VirtualAddress) + (DWORD)(*_pFileBuffer));\n\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY firstDia &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pImageResourceHeader + (DWORD)16);\n\n\n\tfor (int i &#x3D; 0; i &lt; pImageResourceHeader-&gt;NumberOfIdEntries +\n\t\tpImageResourceHeader-&gt;NumberOfNamedEntries; i++)\n\t&#123;\n\t\tif (!firstDia[i].NameIsString)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;printf(&quot;该类型为：%d\\n该位置的下一项目录是否为具体资源：%s\\n&quot;,\n\t\t\t\t&#x2F;&#x2F;firstDia[i].Id, firstDia[i].DataIsDirectory ? &quot;NO&quot; : &quot;YES&quot;);\n\t\t\tDFSFindResource1(firstDia[i].OffsetToDirectory);\n\t\t&#125;\n\t\telse; &#x2F;&#x2F;printf(&quot;用户自制资源！！！\\n&quot;);\n\t&#125;\n\n\treturn;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;壳\n&#x2F;&#x2F; Shell.cpp : 定义应用程序的入口点。\n&#x2F;&#x2F;\n#define _CRT_SECURE_NO_WARNINGS\n#include &quot;framework.h&quot;\n#include &quot;Shell.h&quot;\n#include &quot;PEStudy.h&quot;\n#include&lt;wdmguid.h&gt;\n#include&lt;ntddkbd.h&gt;\n#include&lt;string.h&gt;\n\nPEStudy* PEInstance &#x3D; nullptr;\nTCHAR exeFullPath[MAX_PATH]; &#x2F;&#x2F; Full path   \n\ntypedef struct _ChildProcessInfo &#123;\n\n\tDWORD dwBaseAddress;\n\tDWORD dwReserve;\n&#125; CHILDPROCESS, * PCHILDPROCESS;\n\n&#x2F;&#x2F;getInstance就是单例模式，很好理解的一种设计模式，写游戏的时候学到的，\n&#x2F;&#x2F;它相当于一个全局对象，PEStudy有该函数\n\nBOOL CreateInjectProcess(\n\n\tPPROCESS_INFORMATION pi,\n\tPCONTEXT pThreadCxt,\n\tCHILDPROCESS* pChildProcess)\n&#123;\n\tSTARTUPINFO si;\n\tZeroMemory(&amp;si, sizeof(si));\n\tDWORD* PPEB;\n\tDWORD read;\n\n\t&#x2F;&#x2F;\n\tif (CreateProcess(\n\t\tNULL,   &#x2F;&#x2F;  指向一个NULL结尾的、用来指定可执行模块的宽字节字符串  \n\t\texeFullPath, &#x2F;&#x2F; 命令行字符串  \n\t\tNULL, &#x2F;&#x2F;    指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。  \n\t\tNULL, &#x2F;&#x2F;    如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。&lt;同上&gt;  \n\t\tfalse,&#x2F;&#x2F;    指示新进程是否从调用进程处继承了句柄。   \n\t\tCREATE_SUSPENDED,  &#x2F;&#x2F;  指定附加的、用来控制优先类和进程的创建的标  \n\t\t\t&#x2F;&#x2F;  CREATE_NEW_CONSOLE  新控制台打开子进程  \n\t\t\t&#x2F;&#x2F;  CREATE_SUSPENDED    子进程创建后挂起，直到调用ResumeThread函数  \n\t\tNULL, &#x2F;&#x2F;    指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境  \n\t\tNULL, &#x2F;&#x2F;    指定子进程的工作路径  \n\t\t&amp;si, &#x2F;&#x2F; 决定新进程的主窗体如何显示的STARTUPINFO结构体  \n\t\tpi  &#x2F;&#x2F; 接收新进程的识别信息的PROCESS_INFORMATION结构体  \n\t))\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;挂起创建程序成功！！！&quot;), 0, 0);\n\t\tpThreadCxt-&gt;ContextFlags &#x3D; CONTEXT_FULL;\n\t\tGetThreadContext(pi-&gt;hThread, pThreadCxt);\n\n\t\tPPEB &#x3D; (DWORD*)pThreadCxt-&gt;Ebx;\n\t\t&#x2F;&#x2F;\n\t\tReadProcessMemory(\n\t\t\tpi-&gt;hProcess,\n\t\t\t&amp;PPEB[2],\n\t\t\t(LPVOID) &amp; (pChildProcess-&gt;dwBaseAddress),\n\t\t\tsizeof(DWORD),\n\t\t\t&amp;read);\n\t\treturn TRUE;\n\t&#125;\n\telse MessageBox(0, TEXT(&quot;挂起创建程序失败！！！&quot;), 0, 0);\n\treturn FALSE;\n&#125;\n\nBOOL UnloadShell(HANDLE ProcHnd, unsigned long BaseAddr)\n&#123;\n\ttypedef unsigned long(__stdcall* pfZwUnmapViewOfSection)(unsigned long, unsigned long);\n\tpfZwUnmapViewOfSection ZwUnmapViewOfSection &#x3D; NULL;\n\n\tBOOL res &#x3D; FALSE;\n\tHMODULE m &#x3D; LoadLibrary(TEXT(&quot;ntdll.dll&quot;));\n\tif (m)\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;load exe sucess！！！&quot;), 0, 0);\n\t\tZwUnmapViewOfSection &#x3D; (pfZwUnmapViewOfSection)GetProcAddress(m, &quot;ZwUnmapViewOfSection&quot;);\n\t\tif (ZwUnmapViewOfSection)\n\t\t\tres &#x3D; (ZwUnmapViewOfSection((unsigned long)ProcHnd, BaseAddr) &#x3D;&#x3D; 0);\n\t\tFreeLibrary(m);\n\t&#125;\n\telse MessageBox(0, TEXT(&quot;load exe false！！！&quot;), 0, 0);\n\treturn res;\n&#125;\n\nDWORD GetSelfImageSize(HMODULE hModule)\n&#123;\n\tDWORD dwImageSize;\n\t_asm\n\t&#123;\n\t\tmov ecx, 0x30\n\t\tmov eax, fs: [ecx]\n\t\tmov eax, [eax + 0x0c]\n\t\tmov esi, [eax + 0x0c]\n\t\tadd esi, 0x20\n\t\tlodsd\n\t\tmov dwImageSize, eax\n\t&#125;\n\treturn dwImageSize;&#x2F;&#x2F;getSize\n&#125;\n\n&#x2F;&#x2F;本程序使用该函数卸载挂起进程\nBOOL  UnMapTargetProcess(HANDLE hProcess, CONTEXT&amp; stThreadContext)\n&#123;\n\ttypedef ULONG(WINAPI* PFNNtUnmapViewOfSection) (HANDLE ProcessHandle, PVOID BaseAddress);\n\tHMODULE hNtModule &#x3D; GetModuleHandle(_T(&quot;ntdll.dll&quot;));\n\n\tDWORD dwProcessBaseAddr &#x3D; 0x400000;\n\t\n\tif (hNtModule &#x3D;&#x3D; NULL)\n\t&#123;\n\t\thNtModule &#x3D; LoadLibrary(_T(&quot;ntdll.dll&quot;));\n\t\tif (hNtModule &#x3D;&#x3D; NULL)\n\t\t&#123;\n\t\t\tMessageBox(0, L&quot;ntdll find faied!!!&quot;, 0, 0);\n\t\t\treturn -1;\n\t\t&#125;\n\t&#125;\n\n\tPFNNtUnmapViewOfSection pfnNtUnmapViewOfSection &#x3D; (PFNNtUnmapViewOfSection)GetProcAddress(hNtModule, &quot;NtUnmapViewOfSection&quot;);\n\tif (pfnNtUnmapViewOfSection &#x3D;&#x3D; NULL)\n\t&#123;\n\t\treturn -1;\n\t&#125;\n\n\tpfnNtUnmapViewOfSection(hProcess, (PVOID)dwProcessBaseAddr);\n\n\treturn true;\n&#125;\n\nBOOL InjectProcess(void)\n&#123;\n\tchar szModulePath[MAX_PATH];\n\tDWORD dwImageSize &#x3D; 0;\n\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\tCONTEXT ThreadCxt;\n\tDWORD* PPEB;\n\tDWORD dwWrite &#x3D; 0;\n\tCHILDPROCESS stChildProcess;\n\tLPVOID lpVirtual &#x3D; NULL;\n\tPIMAGE_DOS_HEADER pDosheader &#x3D; NULL;\n\tPIMAGE_NT_HEADERS pVirPeHead &#x3D; NULL;\n\n\tHMODULE hModule &#x3D; NULL;\n\n\n\tGetModuleFileName(NULL, exeFullPath, MAX_PATH);\n\t&#x2F;&#x2F;获取当前进程的运行目录\n\t&#x2F;&#x2F;wsprintf(str, TEXT(&quot;%08X&quot;), num);&#x2F;&#x2F;wstr\n\tPEStudy::getInstance()-&gt;_pFileBuffer &#x3D; (OUT LPVOID*)malloc(sizeof(OUT LPVOID));\n\tsprintf(PEStudy::getInstance()-&gt;_lpszfFile, &quot;%ws&quot;, exeFullPath);\n\tPEStudy::getInstance()-&gt;readFileBufferToTempBuffer(PEStudy::getInstance()-&gt;_lpszfFile,\n\t\tPEStudy::getInstance()-&gt;_pFileBuffer);\n\n\tPEInstance &#x3D; PEStudy::getInstance();\n\n\tPEInstance-&gt;initAllPoint();\n\n\tPEInstance &#x3D; PEStudy::getInstance();\n\n\tPEInstance-&gt;getSectionHeaders();\n\n\tint whi &#x3D; -1;\n\n\tfor (int i &#x3D; 0; i &lt; PEInstance-&gt;pImageFileHeader-&gt;NumberOfSections; i++)\n\t\tif (!strcmp((const char*)PEInstance-&gt;pImageSectionHeads[i]-&gt;Name, &quot;.other&quot;))\n\t\t&#123;\n\t\t\twhi &#x3D; i;\n\t\t\tbreak;\n\t\t&#125;\n\n\tif (-1 &#x3D;&#x3D; whi)\n\t&#123;\n\t\tMessageBox(0, TEXT(&quot;该程序未被加壳，或仅含壳（空）&quot;), 0, 0);\n\t\treturn 0;\n\t&#125;\n\n\t&#x2F;&#x2F;unLock\n\n\tchar* now &#x3D; (char*)((DWORD)PEInstance-&gt;pImageSectionHeads[whi]-&gt;PointerToRawData +\n\t\t(DWORD)*PEInstance-&gt;_pFileBuffer);\n\n\tDWORD size &#x3D; PEInstance-&gt;pImageSectionHeads[whi]-&gt;SizeOfRawData;\n\n\t&#x2F;&#x2F;解密，若该节数据有加密的话\n\t&#x2F;*while (size--)\n\t&#123;\n\t\t(*now) ^&#x3D; 999;\n\t\tnow++;\n\t&#125;*&#x2F;\n\n\t&#x2F;&#x2F;sucess\n\n\tMessageBox(0, TEXT(&quot;程序解密已完成！！！&quot;), 0, 0);\n\n\t\n\tCONTEXT pThreadCxt;&#x2F;&#x2F;挂起上下文\n\t&#x2F;&#x2F;CHILDPROCESS stChildProcess;&#x2F;&#x2F;基址\n\n\tZeroMemory(szModulePath, MAX_PATH);\n\n\thModule &#x3D; GetModuleHandle(NULL);\n\tif (hModule &#x3D;&#x3D; NULL)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\n\tpDosheader &#x3D; (PIMAGE_DOS_HEADER)hModule;\n\tpVirPeHead &#x3D; (PIMAGE_NT_HEADERS)((DWORD)hModule + pDosheader-&gt;e_lfanew);\n\tLPVOID lpPuppetProcessBaseAddr &#x3D; NULL;&#x2F;&#x2F;分配内存成功与否\n\tdwImageSize &#x3D; GetSelfImageSize(hModule);\n\n\t&#x2F;&#x2F; 以挂起模式启动一个傀儡进程,传进去的是OUT类型的参数，便于获得这些数据\n\tif (CreateInjectProcess(&amp;pi, &amp;ThreadCxt, &amp;stChildProcess))\n\t&#123;\n\t\t&#x2F;&#x2F; 卸载需要注入进程中的代码 \n\t\tif (UnMapTargetProcess(pi.hProcess, ThreadCxt))\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 重新分配内存 \n\t\t\t&#x2F;&#x2F;loadNewPE，把PE的指针指向该节，把它当作新PE文件\n\t\t\t*PEInstance-&gt;_pFileBuffer &#x3D;\n\t\t\t\t(LPVOID)((DWORD)PEInstance-&gt;pImageSectionHeads[whi]-&gt;PointerToRawData +\n\t\t\t\t(DWORD)*PEInstance-&gt;_pFileBuffer);\n\n\t\t\tPEInstance-&gt;initAllPoint();&#x2F;&#x2F;重新初始化各个头DOS，PE，OPPE\n\t\t\t&#x2F;&#x2F;\n\t\t\tlpPuppetProcessBaseAddr &#x3D;\n\t\t\t\tVirtualAllocEx(pi.hProcess, (LPVOID)PEInstance-&gt;pImageOptionalPEHeader-&gt;ImageBase,\n\t\t\t\t\tPEInstance-&gt;pImageOptionalPEHeader-&gt;SizeOfImage,\n\t\t\t\t\tMEM_COMMIT | MEM_RESERVE,\n\t\t\t\t\tPAGE_EXECUTE_READWRITE);\n\n\n\t\t\tif (lpPuppetProcessBaseAddr)\n\t\t\t&#123;\n\t\t\t\tMessageBox(0, L&quot;sucess&quot;, 0, 0);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tMessageBox(0, L&quot;重新分配内存 failed&quot;, 0, 0);\n\t\t\t\treturn TRUE;\n\t\t\t&#125;\n\n\t\t\tif (lpPuppetProcessBaseAddr)\n\t\t\t&#123;\n\t\t\t\tBOOL bRet &#x3D; WriteProcessMemory(pi.hProcess,\n\t\t\t\t\tlpPuppetProcessBaseAddr,\n\t\t\t\t\t*PEInstance-&gt;_pFileBuffer,\n\t\t\t\t\tPEInstance-&gt;pImageOptionalPEHeader-&gt;SizeOfHeaders,\n\t\t\t\t\tNULL);\n\n\t\t\t\tif (!bRet)\n\t\t\t\t&#123;\n\t\t\t\t\treturn FALSE;\n\t\t\t\t&#125;\n\n\t\t\t\t&#x2F;&#x2F; 替换节\n\t\t\t\tLPVOID lpSectionBaseAddr &#x3D; (LPVOID)((DWORD)*PEInstance-&gt;_pFileBuffer\n\t\t\t\t\t+ PEInstance-&gt;pImageDosHeader-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS));\n\t\t\t\tPIMAGE_SECTION_HEADER pSectionHeader;\n\t\t\t\tDWORD dwIndex &#x3D; 0;\n\t\t\t\tTCHAR ans[100];\n\n\t\t\t\t&#x2F;&#x2F;一些调试信息\n\t\t\t\t&#x2F;*wsprintf(ans, L&quot;共有%d个节&quot;,\n\t\t\t\t\tPEInstance-&gt;pImageFileHeader-&gt;NumberOfSections);\n\t\t\t\tMessageBox(0, ans, 0, 0);*&#x2F;\n\n\t\t\t\tfor (; dwIndex &lt; PEInstance-&gt;pImageFileHeader-&gt;NumberOfSections;\n\t\t\t\t\t++dwIndex)\n\t\t\t\t&#123;\n\t\t\t\t\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)lpSectionBaseAddr;\n\t\t\t\t\tbRet &#x3D; WriteProcessMemory(pi.hProcess,\n\t\t\t\t\t\t(LPVOID)((DWORD)lpPuppetProcessBaseAddr +\n\t\t\t\t\t\t\tpSectionHeader-&gt;VirtualAddress),\n\t\t\t\t\t\t\t(LPCVOID)((DWORD)*PEInstance-&gt;_pFileBuffer +\n\t\t\t\t\t\t\t\tpSectionHeader-&gt;PointerToRawData),\n\t\t\t\t\t\tpSectionHeader-&gt;SizeOfRawData,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\t\tif (!bRet)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tMessageBox(0, L&quot;节区拓展失败！！！\\n&quot;, 0, 0);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t&#125;\n\n\t\t\t\t\tlpSectionBaseAddr &#x3D; (LPVOID)((DWORD)lpSectionBaseAddr + sizeof(IMAGE_SECTION_HEADER));\n\t\t\t\t&#125;\n\n\t\t\t\tMessageBox(0, L&quot;节区拓展成功！！！\\n&quot;, 0, 0);\n\n\t\t\t\tDWORD dwImageBase &#x3D; PEInstance-&gt;pImageOptionalPEHeader-&gt;ImageBase;\n\t\t\t\t&#x2F;&#x2F;ebx指向了一个结构，8个偏移之后指向了一个指针，指针指向了imageBase，（未确定）\n\t\t\t\tbRet &#x3D; WriteProcessMemory(pi.hProcess, \n\t\t\t\t\t(LPVOID)(ThreadCxt.Ebx + 8), (LPCVOID)&amp;dwImageBase, sizeof(PVOID), NULL);\n\n\t\t\t\tif (!bRet)\n\t\t\t\t&#123;\n\t\t\t\t\treturn FALSE;\n\t\t\t\t&#125;\n\n\t\t\t\t&#x2F;&#x2F; 替换入口点\n\t\t\t\tThreadCxt.Eax &#x3D; dwImageBase + PEInstance-&gt;pImageOptionalPEHeader\n\t\t\t\t\t-&gt;AddressOfEntryPoint;\n\t\t\t\tbRet &#x3D; SetThreadContext(pi.hThread, &amp;ThreadCxt);\n\n\t\t\t\tif (!bRet)\n\t\t\t\t&#123;\n\t\t\t\t\treturn FALSE;\n\t\t\t\t&#125;\n\n\t\t\t\tResumeThread(pi.hThread);\n\n\t\t\t\t&#x2F;&#x2F;该消息出来后若程序未远行，则加壳失败——原因可能是加壳程序逻辑错误，或者解壳程序逻辑错误，如开头所说\n\t\t\t\tMessageBox(0, L&quot;载入成功！！！&quot;, 0, 0);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\treturn TRUE;\n&#125;\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n\t_In_opt_ HINSTANCE hPrevInstance,\n\t_In_ LPWSTR    lpCmdLine,\n\t_In_ int       nCmdShow)\n&#123;\n\t&#x2F;&#x2F;调试\n\t&#x2F;&#x2F;MessageBox(0, L&quot;ReadFileFailed!!!\\n&quot;, 0, 0);\n\treturn InjectProcess();\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\nWin32_proj仓库https://github.com/Kwansy98?tab=repositories专栏https://blog.csdn.net/kwansy/category_9909961.html\n","slug":"Win32","date":"2020-08-20T05:41:47.000Z","categories_index":"逆向","tags_index":"逆向","author_index":"CodingSeed"},{"id":"a1e4caef696c9dadabec86ca767b0052","title":"PEToolKit","content":"&#x2F;&#x2F;PE课后作业参考代码（含测试代码）\n&#x2F;&#x2F;https:&#x2F;&#x2F;blog.csdn.net&#x2F;Kwansy&#x2F;article&#x2F;details&#x2F;106234264\n\n#include &quot;headers.h&quot;\n\n&#x2F;&#x2F; 读取PE文件到内存中，返回读取的字节数；读取失败返回0\nDWORD ReadPEFile(LPCSTR lpszFile, LPVOID *pFileBuffer)\n&#123;\n\tFILE *pFile &#x3D; NULL;\n\tDWORD dwFileSize &#x3D; 0;\n\tpFile &#x3D; fopen(lpszFile, &quot;rb&quot;);\n\tif (pFile &#x3D;&#x3D; NULL) \n\t&#123;\n\t\tprintf(&quot;打开文件失败\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\tfseek(pFile, 0, SEEK_END);\n\tdwFileSize &#x3D; ftell(pFile);\n\tfseek(pFile, 0, SEEK_SET);\n\t*pFileBuffer &#x3D; malloc(dwFileSize);\n\tif (*pFileBuffer &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\tfclose(pFile);\n\t\treturn 0;\n\t&#125;\t\n\tDWORD dwRead &#x3D; fread(*pFileBuffer, 1, dwFileSize, pFile);\n\tfclose(pFile);\n\tif (dwRead !&#x3D; dwFileSize)\n\t&#123;\n\t\tprintf(&quot;文件大小 &#x3D; %d\\t实际写入内存字节 &#x3D; %d\\t写入失败\\n&quot;, dwFileSize, dwRead);\n\t\treturn 0;\n\t&#125;\n\tif (!IsPEFile(*pFileBuffer, dwRead))\n\t&#123;\n\t\tprintf(&quot;不是有效的PE文件\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\treturn dwRead;\n&#125;\n\n&#x2F;&#x2F; 验证是否PE文件\nBOOL IsPEFile(LPVOID pFileBuffer, DWORD dwSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tif (*((PWORD)pDosHeader) !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\tprintf(&quot;不是有效的MZ标志\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\tif (pNTHeader-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\tprintf(&quot;不是有效的PE标记\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\n\treturn TRUE;\n&#125;\n\n&#x2F;&#x2F; 打印PE头信息\nVOID PrintNTHeaders(LPCSTR lpszFile)\n&#123;\n\tLPVOID pFileBuffer &#x3D; NULL;\n\tDWORD dwFileSize &#x3D; ReadPEFile(lpszFile, &amp;pFileBuffer);\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\t\n\tif (dwFileSize &#x3D;&#x3D; 0)\n\t&#123;\n\t\tprintf(&quot;读取文件失败\\n&quot;);\n\t\treturn;\n\t&#125;\n\n\t&#x2F;&#x2F;打印DOS头\n\tputs(&quot;----DOS HEADER----&quot;);\n\tprintf(&quot;e_magic &#x3D; %x\\n&quot;, pDosHeader-&gt;e_magic);\n\tprintf(&quot;e_lfanew &#x3D; %x\\n&quot;, pDosHeader-&gt;e_lfanew);\t\n\t&#x2F;&#x2F;打印NT头\t\n\tprintf(&quot;----标准PE头----\\n&quot;);\n\tprintf(&quot;Machine &#x3D; %x\\n&quot;, pPEHeader-&gt;Machine);\n\tprintf(&quot;NumberOfSections &#x3D; %x\\n&quot;, pPEHeader-&gt;NumberOfSections);\n\tprintf(&quot;TimeDateStamp &#x3D; %x\\n&quot;, pPEHeader-&gt;TimeDateStamp);\n\tprintf(&quot;PointerToSymbolTable &#x3D; %x\\n&quot;, pPEHeader-&gt;PointerToSymbolTable);\n\tprintf(&quot;NumberOfSymbols &#x3D; %x\\n&quot;, pPEHeader-&gt;NumberOfSymbols);\n\tprintf(&quot;SizeOfOptionalHeader &#x3D; %x\\n&quot;, pPEHeader-&gt;SizeOfOptionalHeader);\n\tprintf(&quot;Characteristics &#x3D; %x\\n&quot;, pPEHeader-&gt;Characteristics);\n\t&#x2F;&#x2F;可选PE头\t\n\tprintf(&quot;----可选PE头----\\n&quot;);\n\tprintf(&quot;Magic &#x3D; %x\\n&quot;, pOptionHeader-&gt;Magic);\n\tprintf(&quot;MajorLinkerVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MajorLinkerVersion);\n\tprintf(&quot;MinorLinkerVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MinorLinkerVersion);\n\tprintf(&quot;SizeOfCode &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfCode);\n\tprintf(&quot;SizeOfInitializedData &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfInitializedData);\n\tprintf(&quot;SizeOfUninitializedData &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfUninitializedData);\n\tprintf(&quot;AddressOfEntryPoint &#x3D; %x\\n&quot;, pOptionHeader-&gt;AddressOfEntryPoint);\n\tprintf(&quot;BaseOfCode &#x3D; %x\\n&quot;, pOptionHeader-&gt;BaseOfCode);\n\tprintf(&quot;BaseOfData &#x3D; %x\\n&quot;, pOptionHeader-&gt;BaseOfData);\n\tprintf(&quot;ImageBase &#x3D; %x\\n&quot;, pOptionHeader-&gt;ImageBase);\n\tprintf(&quot;SectionAlignment &#x3D; %x\\n&quot;, pOptionHeader-&gt;SectionAlignment);\n\tprintf(&quot;FileAlignment &#x3D; %x\\n&quot;, pOptionHeader-&gt;FileAlignment);\n\tprintf(&quot;MajorOperatingSystemVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MajorOperatingSystemVersion);\n\tprintf(&quot;MinorOperatingSystemVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MinorOperatingSystemVersion);\n\tprintf(&quot;MajorImageVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MajorImageVersion);\n\tprintf(&quot;MinorImageVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MinorImageVersion);\n\tprintf(&quot;MajorSubsystemVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MajorSubsystemVersion);\n\tprintf(&quot;MinorSubsystemVersion &#x3D; %x\\n&quot;, pOptionHeader-&gt;MinorSubsystemVersion);\n\tprintf(&quot;Win32VersionValue &#x3D; %x\\n&quot;, pOptionHeader-&gt;Win32VersionValue);\n\tprintf(&quot;SizeOfImage &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfImage);\n\tprintf(&quot;SizeOfHeaders &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfHeaders);\n\tprintf(&quot;CheckSum &#x3D; %x\\n&quot;, pOptionHeader-&gt;CheckSum);\n\tprintf(&quot;Subsystem &#x3D; %x\\n&quot;, pOptionHeader-&gt;Subsystem);\n\tprintf(&quot;DllCharacteristics &#x3D; %x\\n&quot;, pOptionHeader-&gt;DllCharacteristics);\n\tprintf(&quot;SizeOfStackReserve &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfStackReserve);\n\tprintf(&quot;SizeOfStackCommit &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfStackCommit);\n\tprintf(&quot;SizeOfHeapReserve &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfHeapReserve);\n\tprintf(&quot;SizeOfHeapCommit &#x3D; %x\\n&quot;, pOptionHeader-&gt;SizeOfHeapCommit);\n\tprintf(&quot;LoaderFlags &#x3D; %x\\n&quot;, pOptionHeader-&gt;LoaderFlags);\n\tprintf(&quot;NumberOfRvaAndSizes &#x3D; %x\\n&quot;, pOptionHeader-&gt;NumberOfRvaAndSizes);\n\t&#x2F;&#x2F;打印节表\t\n\tchar sectionName[9];\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tmemset(sectionName, 0, 9);\n\t\tmemcpy(sectionName, pSectionHeader-&gt;Name, 8);\n\t\tprintf(&quot;----节表: [%s]----\\n&quot;, sectionName);\n\t\tprintf(&quot;VirtualSize &#x3D; %x\\n&quot;, pSectionHeader-&gt;Misc.VirtualSize);\n\t\tprintf(&quot;VirtualAddress &#x3D; %x\\n&quot;, pSectionHeader-&gt;VirtualAddress);\n\t\tprintf(&quot;SizeOfRawData &#x3D; %x\\n&quot;, pSectionHeader-&gt;SizeOfRawData);\n\t\tprintf(&quot;PointerToRawData &#x3D; %x\\n&quot;, pSectionHeader-&gt;PointerToRawData);\n\t\tprintf(&quot;Characteristics &#x3D; %x\\n&quot;, pSectionHeader-&gt;Characteristics);\n\t\tpSectionHeader++;\n\t&#125;\n\t&#x2F;&#x2F;释放内存\n\tfree(pFileBuffer);\n&#125;\n\n&#x2F;&#x2F; 将 FileBuffer 拉伸成 ImageBuffer 并写入到新的缓冲区\n&#x2F;&#x2F; 返回 ImageBuffer 的大小；失败返回0\nDWORD CopyFileBufferToImageBuffer(LPVOID pFileBuffer, LPVOID *pImageBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t*pImageBuffer &#x3D; malloc(pOptionHeader-&gt;SizeOfImage);\n\tif (*pImageBuffer &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\tmemset(*pImageBuffer, 0, pOptionHeader-&gt;SizeOfImage);\n\t&#x2F;&#x2F; 复制DOS头+PE头+可选PE头+节表+文件对齐\n\tmemcpy(*pImageBuffer, pFileBuffer, pOptionHeader-&gt;SizeOfHeaders);\n\t&#x2F;&#x2F; 遍历节表，复制所有节\t\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tmemcpy((LPVOID)((DWORD)(*pImageBuffer) + pSectionHeader[i].VirtualAddress), \\\n\t\t\t(LPVOID)((DWORD)pFileBuffer + pSectionHeader[i].PointerToRawData), \\\n\t\t\tpSectionHeader[i].SizeOfRawData);\n\t&#125;\n\treturn pOptionHeader-&gt;SizeOfImage;\n&#125;\n\n&#x2F;&#x2F; 将 ImageBuffer 变成文件对齐的 FileBuffer 写入新的缓冲区\n&#x2F;&#x2F; 返回复制的大小，失败返回0\nDWORD CopyImageBufferToFileBuffer(LPVOID pImageBuffer, LPVOID *pNewBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pImageBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\t&#x2F;&#x2F; 最后一个节表\n\tPIMAGE_SECTION_HEADER pLastSectionHeader &#x3D; pSectionHeader + pPEHeader-&gt;NumberOfSections - 1;\n\t&#x2F;&#x2F; 计算要复制的字节\n\t&#x2F;&#x2F; 这一步有BUG，当最后一个节后面还有数据时（多见于控制台程序），丢失数据  ????????????？？？？？？？？???????????\n\tDWORD dwFileBufferSize &#x3D; pLastSectionHeader-&gt;PointerToRawData + pLastSectionHeader-&gt;SizeOfRawData;\n\t*pNewBuffer &#x3D; malloc(dwFileBufferSize);\t\n\tif (*pNewBuffer &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\tmemset(*pNewBuffer, 0, dwFileBufferSize);\n\t&#x2F;&#x2F; 复制DOS头+PE头+可选PE头+节表+文件对齐\n\tmemcpy(*pNewBuffer, pImageBuffer, pOptionHeader-&gt;SizeOfHeaders);\n\t&#x2F;&#x2F; 遍历节表，复制文件对齐后的节\t\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tmemcpy((LPVOID)((DWORD)(*pNewBuffer) + pSectionHeader[i].PointerToRawData), \\\n\t\t\t(LPVOID)((DWORD)pImageBuffer + pSectionHeader[i].VirtualAddress), \\\n\t\t\tpSectionHeader[i].SizeOfRawData);\n\t&#125;\n\treturn dwFileBufferSize;\n&#125;\n\n&#x2F;&#x2F; 内存数据写入文件\nBOOL MemoryToFile(LPVOID pMemBuffer, DWORD dwSize, LPCSTR lpszFile)\n&#123;\n\tFILE *fp &#x3D; NULL;\n\tfp &#x3D; fopen(lpszFile, &quot;wb+&quot;);\n\tif (fp &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;打开文件失败\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\tDWORD dwWritten &#x3D; fwrite(pMemBuffer, 1, dwSize, fp);\n\tif (dwWritten !&#x3D; dwSize)\n\t&#123;\n\t\tprintf(&quot;写入了 %d 字节，不等于 %d\\n&quot;, dwWritten, dwSize);\n\t\tfclose(fp);\n\t\treturn FALSE;\n\t&#125;\n\tfclose(fp);\n\treturn TRUE;\n&#125;\n\n&#x2F;&#x2F; 向代码节添加MessageBox代码\n&#x2F;&#x2F; 向代码节添加代码不需要担心内存对齐后大小发生变化\n&#x2F;&#x2F; 默认第一个节是代码节，但是这样判断不一定准确，应该遍历节表，根据属性找代码节\nBOOL AddCodeToCodeSec(LPCSTR lpszFile, LPCSTR lpszOutFile)\n&#123;\n\tBYTE shellcode[] &#x3D;\n\t&#123;\n\t\t0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, &#x2F;&#x2F; push 0 push 0 push 0 push 0\n\t\t0xE8, 0x00, 0x00, 0x00, 0x00,\t\t\t\t\t&#x2F;&#x2F; call MessageBoxA\n\t\t0xE9, 0x00, 0x00, 0x00, 0x00\t\t\t\t\t&#x2F;&#x2F; jmp OEP\n\t&#125;;\n\tDWORD dwShellCodeSize &#x3D; 18;\n\tDWORD dwCodeRva &#x3D; 0; &#x2F;&#x2F; 插入的位置RVA\n\tLPVOID pFileBuffer &#x3D; NULL;\n\tLPVOID pImageBuffer &#x3D; NULL;\n\tLPVOID pNewBuffer &#x3D; NULL;\n\t\n\tDWORD dwFileBufferSize &#x3D; 0;\n\tDWORD dwImageBufferSize &#x3D; 0;\n\tDWORD dwNewBufferSize &#x3D; 0;\n\t&#x2F;&#x2F; 读取PE到内存中\n\tif ((dwFileBufferSize &#x3D; ReadPEFile(lpszFile, &amp;pFileBuffer)) &#x3D;&#x3D; 0)\n\t&#123;\n\t\tprintf(&quot;读取失败\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\t&#x2F;&#x2F; 拉伸成内存映像\n\tdwImageBufferSize &#x3D; CopyFileBufferToImageBuffer(pFileBuffer, &amp;pImageBuffer);\n\tif (0 &#x3D;&#x3D; dwImageBufferSize)\n\t&#123;\n\t\tfree(pFileBuffer);\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pImageBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tDWORD dwCodeSecIndex &#x3D; -1;\n\t&#x2F;&#x2F; 遍历节表，找到代码节\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tif ((pSectionHeader[i].Characteristics &amp; 0x60000020) &#x3D;&#x3D; 0x60000020)\n\t\t&#123;\n\t\t\tdwCodeSecIndex &#x3D; i;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif (dwCodeSecIndex &#x3D;&#x3D; -1)\n\t&#123;\n\t\tprintf(&quot;找不到代码节\\n&quot;);\n\t\tfree(pFileBuffer);\n\t\tfree(pImageBuffer);\n\t\treturn FALSE;\n\t&#125;\n\n\t&#x2F;&#x2F; 计算插入点RVA\n\tdwCodeRva &#x3D; pSectionHeader[dwCodeSecIndex].VirtualAddress + pSectionHeader[dwCodeSecIndex].Misc.VirtualSize;\n\t&#x2F;&#x2F; 是否有足够的空间插入代码，要考虑到代码节是最后一个节的情况\n\tif (dwCodeSecIndex + 1 &#x3D;&#x3D; pPEHeader-&gt;NumberOfSections)\n\t&#123;\n\t\tif (dwCodeRva + dwShellCodeSize &gt; pOptionHeader-&gt;SizeOfImage)\n\t\t&#123;\n\t\t\tprintf(&quot;代码节没有足够的空间插入代码\\n&quot;);\n\t\t\tfree(pFileBuffer);\n\t\t\tfree(pImageBuffer);\n\t\t\treturn FALSE;\n\t\t&#125;\n\t&#125;\n\telse\n\t&#123;\n\t\tDWORD dwUnuseSize &#x3D; pSectionHeader[dwCodeSecIndex + 1].VirtualAddress - \\\n\t\t\tpSectionHeader[dwCodeSecIndex].VirtualAddress - pSectionHeader[dwCodeSecIndex].Misc.VirtualSize;\n\t\tif (dwUnuseSize &lt; dwShellCodeSize)\n\t\t&#123;\n\t\t\tprintf(&quot;代码节没有足够的空间插入代码\\n&quot;);\n\t\t\tfree(pFileBuffer);\n\t\t\tfree(pImageBuffer);\n\t\t\treturn FALSE;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 代码插入点偏移 &#x3D; VA + VSIZE\n\tdwCodeRva &#x3D; pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;Misc.VirtualSize;\n\t&#x2F;&#x2F; 代码插入\n\tmemcpy((LPVOID)((DWORD)pImageBuffer + dwCodeRva), shellcode, dwShellCodeSize);\n\t&#x2F;&#x2F; 修正地址\n\tDWORD MsgBoxAddr &#x3D; (DWORD)&amp;MessageBoxA; &#x2F;&#x2F; 获取MessageBox的地址\n\tDWORD hardCodeAddr &#x3D; MsgBoxAddr - (pOptionHeader-&gt;ImageBase + dwCodeRva + 13);\n\tmemcpy((LPVOID)((DWORD)pImageBuffer + dwCodeRva + 9), &amp;hardCodeAddr, 4);\n\thardCodeAddr &#x3D; pOptionHeader-&gt;ImageBase + pOptionHeader-&gt;AddressOfEntryPoint \\\n\t- (pOptionHeader-&gt;ImageBase + dwCodeRva + 18);\n\tmemcpy((LPVOID)((DWORD)pImageBuffer + dwCodeRva + 14), &amp;hardCodeAddr, 4);\n\t&#x2F;&#x2F; 修改入口点\n\tpOptionHeader-&gt;AddressOfEntryPoint &#x3D; dwCodeRva;\n\t&#x2F;&#x2F; 转成文件对齐\n\tdwNewBufferSize &#x3D; CopyImageBufferToFileBuffer(pImageBuffer, &amp;pNewBuffer);\n\tif (dwNewBufferSize !&#x3D; dwFileBufferSize)\n\t&#123;\n\t\tprintf(&quot;可能丢失数据\\n&quot;);\n\t&#125;\n\tMemoryToFile(pNewBuffer, dwNewBufferSize, lpszOutFile);\n\tfree(pFileBuffer);\n\tfree(pImageBuffer);\n\tfree(pNewBuffer);\n\tprintf(&quot;插入代码成功\\n&quot;);\n\treturn TRUE;\n&#125;\n\n&#x2F;&#x2F; 计算对齐的函数，如偏移为900，对齐为1000h，返回1000h\nDWORD Align(DWORD dwOffset, DWORD dwAlign)\n&#123;\n\t&#x2F;&#x2F; 如果偏移小于对齐，向上取整\n\tif (dwOffset &lt;&#x3D; dwAlign) return dwAlign;\n\t&#x2F;&#x2F; 如果偏移大于对齐且不能除尽，向上取整\n\tif (dwOffset % dwAlign)\n\t&#123;\n\t\treturn (dwOffset &#x2F; dwAlign + 1) * dwAlign;\n\t&#125;\n\t&#x2F;&#x2F; 如果能除尽，直接返回offset\n\treturn dwOffset;\n&#125;\n\n&#x2F;&#x2F; RVA 转 FOA\nDWORD RvaToFoa(LPVOID pFileBuffer, DWORD dwRva)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pFileBuffer + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t&#x2F;&#x2F; RVA在文件头中或者文件对齐&#x3D;&#x3D;内存对齐时，RVA&#x3D;&#x3D;FOA  错！第一句是对的，第二句是错的\n\tif (dwRva &lt; pOptionHeader-&gt;SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\n\t&#x2F;&#x2F; 遍历节表，确定偏移属于哪一个节\t\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tif (dwRva &gt;&#x3D; pSectionHeader[i].VirtualAddress &amp;&amp; \\\n\t\t\tdwRva &lt; pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize)\n\t\t&#123;\n\t\t\tint offset &#x3D; dwRva - pSectionHeader[i].VirtualAddress;\n\t\t\treturn pSectionHeader[i].PointerToRawData + offset;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;找不到RVA %x 对应的 FOA，转换失败\\n&quot;, dwRva);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; FOA 转 RVA\nDWORD FoaToRva(LPVOID pFileBuffer, DWORD dwFoa)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pFileBuffer + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\t&#x2F;&#x2F; RVA在文件头中或者文件对齐&#x3D;&#x3D;内存对齐时，RVA&#x3D;&#x3D;FOA  错！第一句是对的，第二句是错的\n\tif (dwFoa &lt; pOptionHeader-&gt;SizeOfHeaders)\n\t&#123;\n\t\treturn dwFoa;\n\t&#125;\n\t\n\t&#x2F;&#x2F; 遍历节表，确定偏移属于哪一个节\n\tfor (int i &#x3D; 0; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tif (dwFoa &gt;&#x3D; pSectionHeader[i].PointerToRawData &amp;&amp; \\\n\t\t\tdwFoa &lt; pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData)\n\t\t&#123;\n\t\t\tint offset &#x3D; dwFoa - pSectionHeader[i].PointerToRawData;\n\t\t\treturn pSectionHeader[i].VirtualAddress + offset;\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;找不到FOA %x 对应的 RVA，转换失败\\n&quot;, dwFoa);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 移动NT头和节表到DOS STUB，该函数在新增节时节表空间不足的情况下调用；返回地址减小值\nDWORD MoveNTHeaderAndSectionHeadersToDosStub(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tLPVOID pDst &#x3D; (LPVOID)((DWORD)pDosHeader + sizeof(IMAGE_DOS_HEADER)); &#x2F;&#x2F; NT头插入点\n\tDWORD dwRet &#x3D; (DWORD)pNTHeader - (DWORD)pDst; &#x2F;&#x2F; 返回地址减小的值\n\tDWORD dwSize &#x3D; 4 + sizeof(IMAGE_FILE_HEADER) + pPEHeader-&gt;SizeOfOptionalHeader +\\\n\t\tsizeof(IMAGE_SECTION_HEADER) * pPEHeader-&gt;NumberOfSections; &#x2F;&#x2F; 移动的字节数\n\tLPVOID pSrc &#x3D; malloc(dwSize);\n\tif (pSrc &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\tmemcpy(pSrc, (LPVOID)pNTHeader, dwSize); &#x2F;&#x2F; 保存要复制的数据\n\tmemset((LPVOID)pNTHeader, 0, dwSize); &#x2F;&#x2F; 清空原数据\n\tmemcpy(pDst, pSrc, dwSize); &#x2F;&#x2F; 移动数据\n\tfree(pSrc);\n\tpDosHeader-&gt;e_lfanew &#x3D; sizeof(IMAGE_DOS_HEADER); &#x2F;&#x2F; 更新 e_lfanew\n\n\treturn dwRet;\n&#125;\n\n&#x2F;&#x2F; 新增一个大小为 newSectionSize 的代码节\n&#x2F;&#x2F; dwFileBufferSize 是原来的文件大小\n&#x2F;&#x2F; 返回新缓冲区的大小，失败返回0\nDWORD AddCodeSection(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwFileBufferSize, DWORD dwNewSectionSize)\n&#123;\n\t&#x2F;&#x2F; 复制一份 pFileBuffer，不要修改原来的数据\n\tLPVOID pFileBuffer2 &#x3D; malloc(dwFileBufferSize);\n\tmemcpy(pFileBuffer2, pFileBuffer, dwFileBufferSize);\n\tpFileBuffer &#x3D; pFileBuffer2;\n\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPWORD pNumberOfSections &#x3D; &amp;(pPEHeader-&gt;NumberOfSections); &#x2F;&#x2F; 节的数量\n\tPIMAGE_SECTION_HEADER pLastSectionHeader &#x3D; pSectionHeader + *pNumberOfSections - 1; &#x2F;&#x2F; 最后一个节表\n\tPIMAGE_SECTION_HEADER pNewSectionHeader &#x3D; pSectionHeader + *pNumberOfSections; &#x2F;&#x2F; 新节表插入点\n\tDWORD newFileBufferSize &#x3D; 0; &#x2F;&#x2F; 新文件的大小\n\n\t&#x2F;&#x2F; 判断最后一个节表后面是否有空闲的80字节\n\tif (80 &gt; (DWORD)pFileBuffer + pOptionHeader-&gt;SizeOfHeaders - (DWORD)pNewSectionHeader)\n\t&#123;\n\t\tprintf(&quot;没有足够的80字节插入新节表\\n&quot;);\n\t\tfree(pFileBuffer2);\n\t\treturn 0;\n\t&#125;\n\n\t&#x2F;&#x2F; 判断空闲的80字节是否全为0，如果不是，则把整个NT头往上挪覆盖dos stub以空出空间插入节表\n\tfor (int i &#x3D; 0; i &lt; 80; i++)\n\t&#123;\n\t\tif (((PBYTE)pNewSectionHeader)[i] !&#x3D; 0)\n\t\t&#123;\t\t\t\n\t\t\tDWORD dwRet &#x3D; MoveNTHeaderAndSectionHeadersToDosStub(pFileBuffer);\n\t\t\tprintf(&quot;节表空间不足，NT头和节表向低地址移动了 %d 字节\\n&quot;, dwRet);\n\t\t\tif (dwRet &lt; 80)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;移动后仍没有足够的80字节空间插入新节表\\n&quot;);\n\t\t\t\tfree(pFileBuffer2);\n\t\t\t\treturn 0;\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F; 更新指针\n\t\t\tpNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\t\t\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\t\t\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\t\t\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\t\tpNumberOfSections &#x3D; &amp;(pPEHeader-&gt;NumberOfSections); &#x2F;&#x2F; 节的数量\n\t\t\tpLastSectionHeader &#x3D; pSectionHeader + *pNumberOfSections - 1; &#x2F;&#x2F; 最后一个节表\n\t\t\tpNewSectionHeader &#x3D; pSectionHeader + *pNumberOfSections; &#x2F;&#x2F; 新节表插入点\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 定义一个 IMAGE_SECTION_HEADER 结构，计算里面的属性\n\tIMAGE_SECTION_HEADER newSectionHeader;\n\tmemcpy(newSectionHeader.Name, &quot;.newsec&quot;, 8);\n\tnewSectionHeader.Misc.VirtualSize &#x3D; Align(dwNewSectionSize, pOptionHeader-&gt;SectionAlignment);\n\tnewSectionHeader.VirtualAddress &#x3D; pLastSectionHeader-&gt;VirtualAddress + \\\n\t\tAlign(pLastSectionHeader-&gt;Misc.VirtualSize, pOptionHeader-&gt;SectionAlignment);\t\n\tnewSectionHeader.SizeOfRawData &#x3D; Align(dwNewSectionSize, pOptionHeader-&gt;FileAlignment);\n\tnewSectionHeader.PointerToRawData &#x3D; pLastSectionHeader-&gt;PointerToRawData + pLastSectionHeader-&gt;SizeOfRawData;\n\tnewSectionHeader.PointerToRelocations &#x3D; 0;\n\tnewSectionHeader.PointerToLinenumbers &#x3D; 0;\n\tnewSectionHeader.NumberOfRelocations &#x3D; 0;\n\tnewSectionHeader.NumberOfLinenumbers &#x3D; 0;\n\tnewSectionHeader.Characteristics &#x3D; 0x60000020;\n\n\t&#x2F;&#x2F; pNewFileBuffer 分配内存，把 pFileBuffer 复制过去，后面的修改都在 pNewFileBuffer 进行\n\t*pNewFileBuffer &#x3D; malloc(dwFileBufferSize + newSectionHeader.SizeOfRawData);\n\tmemcpy(*pNewFileBuffer, pFileBuffer, dwFileBufferSize);\n\tmemset((LPVOID)((DWORD)*pNewFileBuffer + dwFileBufferSize), 0, newSectionHeader.SizeOfRawData); &#x2F;&#x2F; 新增节数据清0\n\n\t&#x2F;&#x2F; 更新指针，指向新内存\t\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\tpNumberOfSections &#x3D; &amp;(pPEHeader-&gt;NumberOfSections);\n\tpLastSectionHeader &#x3D; pSectionHeader + *pNumberOfSections - 1;\n\tpNewSectionHeader &#x3D; pSectionHeader + *pNumberOfSections;\n\n\t&#x2F;&#x2F; 节的数量+1，SizeOfImage是内存中拉伸后的大小\n\t*pNumberOfSections +&#x3D; 1;\t\n\tpOptionHeader-&gt;SizeOfImage +&#x3D; Align(newSectionHeader.Misc.VirtualSize, pOptionHeader-&gt;SectionAlignment);\n\n\t&#x2F;&#x2F; 拷贝 newSectionHeader\n\tmemcpy(pNewSectionHeader, &amp;newSectionHeader, sizeof(newSectionHeader));\n\n\t&#x2F;&#x2F;printf(&quot;插入成功\\n&quot;);\n\tfree(pFileBuffer2);\n\treturn dwFileBufferSize + newSectionHeader.SizeOfRawData;\n&#125;\n\n&#x2F;&#x2F; 扩大最后一个节\n&#x2F;&#x2F; 返回新文件的大小，失败返回0\nDWORD ExpandLastSection(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwOldSize, DWORD dwExpandSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tDWORD dwVirtualSizeExpand &#x3D; Align(dwExpandSize, pOptionHeader-&gt;SectionAlignment);\n\tDWORD dwRawDataExpand &#x3D; Align(dwExpandSize, pOptionHeader-&gt;FileAlignment);\n\t\n\t*pNewFileBuffer &#x3D; malloc(dwOldSize + dwRawDataExpand);\n\tmemcpy(*pNewFileBuffer, pFileBuffer, dwOldSize);\n\tmemset((LPVOID)((DWORD)(*pNewFileBuffer) + dwOldSize), 0, dwRawDataExpand);\n\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpNTHeader &#x3D; (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + (DWORD)*pNewFileBuffer);\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pNTHeader + 0x18);\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t&#x2F;&#x2F; 修改新内存的属性\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].Misc.VirtualSize +&#x3D; dwVirtualSizeExpand;\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].SizeOfRawData +&#x3D; dwRawDataExpand;\n\tpOptionHeader-&gt;SizeOfImage +&#x3D; dwVirtualSizeExpand;\n\n\treturn dwOldSize + dwRawDataExpand;\n&#125;\n\n&#x2F;&#x2F; 合并所有节\nBOOL MergeSection(LPVOID pImageBuffer, LPVOID *pNewImageBuffer, DWORD dwImageSize)\n&#123;\n\t*pNewImageBuffer &#x3D; malloc(dwImageSize);\n\tif (*pNewImageBuffer &#x3D;&#x3D; NULL)\n\t&#123;\n\t\tprintf(&quot;分配内存失败\\n&quot;);\n\t\treturn FALSE;\n\t&#125;\n\tmemcpy(*pNewImageBuffer, pImageBuffer, dwImageSize);\n\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewImageBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\tPIMAGE_SECTION_HEADER pLastSectionHeader &#x3D; pSectionHeader + pPEHeader-&gt;NumberOfSections - 1;\n\n\t&#x2F;&#x2F; 修改第一个节的范围以覆盖其他所有节\n\tpSectionHeader-&gt;SizeOfRawData &#x3D; pSectionHeader-&gt;Misc.VirtualSize &#x3D; \\\n\t\tpOptionHeader-&gt;SizeOfImage - pSectionHeader-&gt;VirtualAddress;\n\tpSectionHeader-&gt;SizeOfRawData &#x3D; Align(pSectionHeader-&gt;SizeOfRawData, pOptionHeader-&gt;FileAlignment);\n\n\t&#x2F;&#x2F; 属性包含所有节的属性\n\tfor (int i &#x3D; 1; i &lt; pPEHeader-&gt;NumberOfSections; i++)\n\t&#123;\n\t\tpSectionHeader[0].Characteristics |&#x3D; pSectionHeader[i].Characteristics;\n\t&#125;\n\t\n\t&#x2F;&#x2F; 清空其他节表的数据，这步是为了合并节后新增节方便\n\tmemset(pSectionHeader + 1, 0, sizeof(IMAGE_SECTION_HEADER) * (pPEHeader-&gt;NumberOfSections - 1));\n\n\t&#x2F;&#x2F; 节的数量 &#x3D; 1\n\tpPEHeader-&gt;NumberOfSections &#x3D; 1;\n\n\treturn TRUE;\n&#125;\n\n&#x2F;&#x2F; 打印数据目录\nDWORD TestPrintDataDirectory(LPCSTR lpszFile)\n&#123;\n\tLPVOID pFileBuffer &#x3D; NULL;\n\tReadPEFile(lpszFile, &amp;pFileBuffer);\n\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tLPCSTR data[16] &#x3D;\n\t&#123;\n\t\t&quot;导出表&quot;,\n\t\t&quot;导入表&quot;,\n\t\t&quot;资源表&quot;,\n\t\t&quot;异常信息表&quot;,\n\t\t&quot;安全证书表&quot;,\n\t\t&quot;重定位表&quot;,\n\t\t&quot;调试信息表&quot;,\n\t\t&quot;版权表&quot;,\n\t\t&quot;全局指针表&quot;,\n\t\t&quot;TLS表&quot;,\n\t\t&quot;加载配置表&quot;,\n\t\t&quot;绑定导入表&quot;,\n\t\t&quot;IAT表&quot;,\n\t\t&quot;延迟导入表&quot;,\n\t\t&quot;COM信息表&quot;,\n\t\t&quot;保留&quot;\n\t&#125;;\n\n\tfor (int i &#x3D; 0; i &lt; 16; i++)\n\t&#123;\n\t\tputs(data[i]);\n\t\tprintf(&quot;VirtualAddress &#x3D; %x\\n&quot;, (pOptionHeader-&gt;DataDirectory)[i].VirtualAddress);\n\t\tprintf(&quot;Size &#x3D; %x\\n&quot;, (pOptionHeader-&gt;DataDirectory)[i].Size);\n\t\tputs(&quot;-------------------------&quot;);\n\t&#125;\n\tfree(pFileBuffer);\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F; 打印导出表\nVOID PrintExportTable(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_EXPORT_DIRECTORY pExportDirectory &#x3D; \\\n\t\t(PIMAGE_EXPORT_DIRECTORY)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\tprintf(&quot;Base &#x3D; %x\\n&quot;, pExportDirectory-&gt;Base);\n\tprintf(&quot;NumberOfFunctions &#x3D; %x\\n&quot;, pExportDirectory-&gt;NumberOfFunctions);\n\tprintf(&quot;NumberOfNames &#x3D; %x\\n&quot;, pExportDirectory-&gt;NumberOfNames);\n\n\tprintf(&quot;----AddressOfFunctions----\\n&quot;);\n\tPDWORD AddressOfFunctions &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfFunctions));\n\tint i;\n\tfor (i &#x3D; 0; i &lt; (int)pExportDirectory-&gt;NumberOfFunctions; i++)\n\t&#123;\n\t\tprintf(&quot;AddressOfFunctions[%d] &#x3D; %x\\n&quot;, i, AddressOfFunctions[i]);\n\n\t\t&#x2F;&#x2F; 测试：调用导出序号为12的Plus函数，VC6可以这样调用，VS不行，要VirtualAlloc一块可执行内存\n\t\t&#x2F;&#x2F;if (i + pExportDirectory-&gt;Base &#x3D;&#x3D; 12)\n\t\t&#x2F;&#x2F;&#123;\n\t\t&#x2F;&#x2F;\tint (*Plus)(int x, int y) &#x3D; (int (*)(int x, int y))((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, AddressOfFunctions[i]));\n\t\t&#x2F;&#x2F;\tprintf(&quot;2+3&#x3D;%d\\n&quot;, Plus(2, 3));\n\t\t&#x2F;&#x2F;&#125;\n\t&#125;\n\n\tprintf(&quot;----AddressOfNames &amp; AddressOfNameOridinals----\\n&quot;);\n\tPDWORD AddressOfNames &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNames));\n\tPWORD AddressOfNameOridinals &#x3D; (PWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNameOrdinals));\n\t\n\tfor (i &#x3D; 0; i &lt; (int)pExportDirectory-&gt;NumberOfNames; i++)\n\t&#123;\n\t\tprintf(&quot;AddressOfNames[%d] &#x3D; %s, AddressOfOrdinals[%d] &#x3D; %d\\n&quot;,\n\t\t\ti, (char *)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, AddressOfNames[i])), i, AddressOfNameOridinals[i]);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 根据函数名返回函数入口点RVA\nDWORD GetFunctionAddrByName(LPVOID pFileBuffer, LPCSTR lpszFunc)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_EXPORT_DIRECTORY pExportDirectory &#x3D; \\\n\t\t(PIMAGE_EXPORT_DIRECTORY)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\n\tPDWORD AddressOfFunctions &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfFunctions));\n\tPDWORD AddressOfNames &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNames));\n\tPWORD AddressOfNameOridinals &#x3D; (PWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNameOrdinals));\n\tint i;\n\tfor (i &#x3D; 0; i &lt; (int)pExportDirectory-&gt;NumberOfNames; i++)\n\t&#123;\n\t\tif (!strcmp((char *)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, AddressOfNames[i])), lpszFunc))\n\t\t&#123;\n\t\t\treturn AddressOfFunctions[AddressOfNameOridinals[i]];\n\t\t&#125;\n\t&#125;\n\n\treturn NULL;\n&#125;\n\n&#x2F;&#x2F; 根据导出序号返回函数入口点RVA\nDWORD GetFunctionAddrByOrdinals(LPVOID pFileBuffer, DWORD dwOrdinal)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader &#x3D; (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_EXPORT_DIRECTORY pExportDirectory &#x3D; \\\n\t\t(PIMAGE_EXPORT_DIRECTORY)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\n\tPDWORD AddressOfFunctions &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfFunctions));\n\tPDWORD AddressOfNames &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNames));\n\tPWORD AddressOfNameOridinals &#x3D; (PWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-&gt;AddressOfNameOrdinals));\n\n\treturn AddressOfFunctions[dwOrdinal - pExportDirectory-&gt;Base];\n&#125;\n\n&#x2F;&#x2F; 打印重定位表\nVOID PrintRelocationTable(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_BASE_RELOCATION pBaseRelocation &#x3D; \\\n\t\t(PIMAGE_BASE_RELOCATION)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[5].VirtualAddress));\n\n\twhile (pBaseRelocation-&gt;VirtualAddress || pBaseRelocation-&gt;SizeOfBlock)\n\t&#123;\n\t\tputs(&quot;-------------------------------------&quot;);\n\t\tprintf(&quot;VirtualAddress &#x3D; %08x\\n&quot;, pBaseRelocation-&gt;VirtualAddress);\n\t\tprintf(&quot;SizeOfBlock &#x3D; %08x\\n&quot;, pBaseRelocation-&gt;SizeOfBlock);\n\t\tPWORD pwAddr &#x3D; (PWORD)((DWORD)pBaseRelocation + 8);&#x2F;&#x2F;ptr指向的地址作为DWORD +8B\n\t\tint n &#x3D; (pBaseRelocation-&gt;SizeOfBlock - 8) &#x2F; 2;\n\t\tprintf(&quot;要修改的地址个数 &#x3D; %d\\n&quot;, n);\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\n\t\t&#123; \n\t\t\tWORD wProp &#x3D; (0xF000 &amp; pwAddr[i]) &gt;&gt; 12;\n\t\t\tWORD wAddr &#x3D; 0x0FFF &amp; pwAddr[i];\n\t\t\tprintf(&quot;[%d]：RVA &#x3D; %08x\\t属性 &#x3D; %d\\n&quot;, i + 1, pBaseRelocation-&gt;VirtualAddress + wAddr, wProp);\n\t\t&#125;\n\t\tpBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pBaseRelocation + pBaseRelocation-&gt;SizeOfBlock);\t\t\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 移动导出表到新增节，返回新缓冲区的大小\nDWORD MoveExportTableToNewSection(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwFileBufferSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\tPIMAGE_EXPORT_DIRECTORY pExportTable &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\tPDWORD pAddressOfFunctions &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportTable-&gt;AddressOfFunctions));\n\tPWORD pAddressOfNameOrdinals &#x3D; (PWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportTable-&gt;AddressOfNameOrdinals));\n\tPDWORD pAddressOfNames &#x3D; (PDWORD)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pExportTable-&gt;AddressOfNames));\n\n\t&#x2F;&#x2F; 计算新增节的大小\n\t&#x2F;&#x2F; &#x3D; NumberOfFunctions * 4 + NumberOfNames * (2 + 4) + 所有函数名的字节 + sizeof(_IMAGE_EXPORT_DIRECTORY)\n\t&#x2F;&#x2F; 然后文件对齐\n\tDWORD dwNewSectionSize &#x3D; 0;\n\tdwNewSectionSize +&#x3D; pExportTable-&gt;NumberOfFunctions * 4; &#x2F;&#x2F; AddressOfFunctions 的空间\n\tdwNewSectionSize +&#x3D; pExportTable-&gt;NumberOfNames * (2 + 4); &#x2F;&#x2F; AddressOfNames + AddressOfNameOrdinals 的空间\n\tsize_t i &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; pExportTable-&gt;NumberOfNames; i++)\n\t&#123;\t\t\n\t\tLPCSTR lpszFuncName &#x3D; (LPCSTR)((DWORD)pFileBuffer + RvaToFoa(pFileBuffer, pAddressOfNames[i]));\n\t\tdwNewSectionSize +&#x3D; strlen(lpszFuncName) + 1;\n\t&#125;\n\tdwNewSectionSize +&#x3D; sizeof(_IMAGE_EXPORT_DIRECTORY);\n\tdwNewSectionSize &#x3D; Align(dwNewSectionSize, pOptionHeader-&gt;FileAlignment);\n\t&#x2F;&#x2F;printf(&quot;新增节的大小 &#x3D; %x\\n&quot;, dwNewSectionSize);\n\n\tDWORD dwNewBufferSize &#x3D; AddCodeSection(pFileBuffer, pNewFileBuffer, dwFileBufferSize, dwNewSectionSize);\n\t\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t&#x2F;&#x2F; 修改新增节属性为可读、含已初始化数据\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].Characteristics &#x3D; 0x40000040;\n\n\tpExportTable &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)*pNewFileBuffer + \\\n\t\tRvaToFoa(*pNewFileBuffer, pOptionHeader-&gt;DataDirectory[0].VirtualAddress));\n\n\tpAddressOfFunctions &#x3D; (PDWORD)((DWORD)*pNewFileBuffer + RvaToFoa(*pNewFileBuffer, pExportTable-&gt;AddressOfFunctions));\n\tpAddressOfNameOrdinals &#x3D; (PWORD)((DWORD)*pNewFileBuffer + RvaToFoa(*pNewFileBuffer, pExportTable-&gt;AddressOfNameOrdinals));\n\tpAddressOfNames &#x3D; (PDWORD)((DWORD)*pNewFileBuffer + RvaToFoa(*pNewFileBuffer, pExportTable-&gt;AddressOfNames));\n\t\n\t&#x2F;&#x2F; 把3张子表拷贝到新节，更新指针\n\tLPVOID pInsert &#x3D; (LPVOID)((DWORD)*pNewFileBuffer + pSectionHeader[pPEHeader-&gt;NumberOfSections - 1].PointerToRawData);\n\tmemcpy(pInsert, pAddressOfFunctions, 4 * pExportTable-&gt;NumberOfFunctions);\n\tpAddressOfFunctions &#x3D; (PDWORD)pInsert;\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + 4 * pExportTable-&gt;NumberOfFunctions);\n\tmemcpy(pInsert, pAddressOfNameOrdinals, 2 * pExportTable-&gt;NumberOfNames);\n\tpAddressOfNameOrdinals &#x3D; (PWORD)pInsert;\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + 2 * pExportTable-&gt;NumberOfNames);\n\tmemcpy(pInsert, pAddressOfNames, 4 * pExportTable-&gt;NumberOfNames);\n\tpAddressOfNames &#x3D; (PDWORD)pInsert;\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + 4 * pExportTable-&gt;NumberOfNames);\n\t&#x2F;&#x2F; 拷贝函数名\n\tfor (i &#x3D; 0; i &lt; pExportTable-&gt;NumberOfNames; i++)\n\t&#123;\n\t\tLPCSTR lpszFuncName &#x3D; (LPCSTR)((DWORD)*pNewFileBuffer + RvaToFoa(*pNewFileBuffer, pAddressOfNames[i]));\n\t\tmemcpy(pInsert, lpszFuncName, strlen(lpszFuncName) + 1);&#x2F;&#x2F;FOA!!!!!!!!\n\t\t&#x2F;&#x2F; 更新函数名的RVA地址\n\t\tpAddressOfNames[i] &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pInsert - (DWORD)*pNewFileBuffer);&#x2F;&#x2F;RVA!!!!!!!\n\t\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + strlen(lpszFuncName) + 1);\n\t&#125;\n\t&#x2F;&#x2F; 拷贝导出表\n\tmemcpy(pInsert, pExportTable, sizeof(_IMAGE_EXPORT_DIRECTORY));\n\tpExportTable &#x3D; (PIMAGE_EXPORT_DIRECTORY)pInsert;\n\tpExportTable-&gt;AddressOfFunctions &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pAddressOfFunctions - (DWORD)*pNewFileBuffer);\n\tpExportTable-&gt;AddressOfNameOrdinals &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pAddressOfNameOrdinals - (DWORD)*pNewFileBuffer);\n\tpExportTable-&gt;AddressOfNames &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pAddressOfNames - (DWORD)*pNewFileBuffer);\n\t\n\t&#x2F;&#x2F; 修改目录项，指向新的导出表\n\tpOptionHeader-&gt;DataDirectory[0].VirtualAddress &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pExportTable - (DWORD)*pNewFileBuffer);\n\t\t\n\treturn dwNewBufferSize;\n&#125;\n\n&#x2F;&#x2F; 移动重定位表到新增节，返回新缓冲区的大小\nDWORD MoveRelocationTableToNewSection(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwFileBufferSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPIMAGE_BASE_RELOCATION pRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[5].VirtualAddress));\n\n\t&#x2F;&#x2F;size_t i &#x3D; 0;\n\tDWORD dwRelocationTableSize &#x3D; 0;\n\twhile (pRelocationTable-&gt;VirtualAddress || pRelocationTable-&gt;SizeOfBlock)\n\t&#123;\n\t\tdwRelocationTableSize +&#x3D; pRelocationTable-&gt;SizeOfBlock;\n\t\t&#x2F;&#x2F;printf(&quot;%x\\n&quot;, (pRelocationTable-&gt;SizeOfBlock - 8) &#x2F; 2 );\n\t\tpRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pRelocationTable + pRelocationTable-&gt;SizeOfBlock);\n\t&#125;\n\t\n\tDWORD dwNewBufferSize &#x3D; AddCodeSection(pFileBuffer, pNewFileBuffer, dwFileBufferSize, \\\n\t\tAlign(dwRelocationTableSize, pOptionHeader-&gt;FileAlignment));\n\t\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\t&#x2F;&#x2F; 修改新增节属性为可读、含已初始化数据\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].Characteristics &#x3D; 0x40000040;\n\t&#x2F;&#x2F; 指针指向重定位表\n\tpRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)*pNewFileBuffer + \\\n\t\tRvaToFoa(*pNewFileBuffer, pOptionHeader-&gt;DataDirectory[5].VirtualAddress));\n\t&#x2F;&#x2F; 定义插入点为新增节的起始地址\n\tLPVOID pInsert &#x3D; (LPVOID)((DWORD)*pNewFileBuffer + pSectionHeader[pPEHeader-&gt;NumberOfSections - 1].PointerToRawData);\n\t&#x2F;&#x2F; 拷贝重定位表\n\tmemcpy(pInsert, (LPVOID)pRelocationTable, dwRelocationTableSize);\n\t&#x2F;&#x2F; 更新目录项，指向新的重定位表\n\tpOptionHeader-&gt;DataDirectory[5].VirtualAddress &#x3D; FoaToRva(*pNewFileBuffer, \\\n\t\t(DWORD)pInsert - (DWORD)*pNewFileBuffer);\n\t\n\treturn dwNewBufferSize;\n&#125;\n\n&#x2F;&#x2F; 修改 ImageBase 并修复重定位表\nVOID SetImageBase(LPVOID pFileBuffer, DWORD dwNewImageBase)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPIMAGE_BASE_RELOCATION pRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[5].VirtualAddress));\t\n\tDWORD dwImageBaseDelta &#x3D; dwNewImageBase - pOptionHeader-&gt;ImageBase; &#x2F;&#x2F; 新旧ImageBase 的差值\t\n\t\n\t&#x2F;&#x2F; 【重定位表的 VirtualAddress + 低12位偏移 &#x3D; RVA】8000+23&#x3D;8023！！！！！！！！！！！！！！！！！！！\n\t&#x2F;&#x2F; RVA + ImageBase 这个内存里存储了一个“指针”\n\t&#x2F;&#x2F; 要修改的是这个“指针”的值，要让这个“指针”加上两个ImageBase的差值\n\t&#x2F;&#x2F;Rva2Foa2FileAddr\t\t写死的地址+&#x3D;delta\n\twhile (pRelocationTable-&gt;VirtualAddress || pRelocationTable-&gt;SizeOfBlock)\n\t&#123;\t\t\n\t\tsize_t n &#x3D; (pRelocationTable-&gt;SizeOfBlock - 8) &#x2F; 2; &#x2F;&#x2F; 可能需要修改的地址数量（高4位&#x3D;&#x3D;0011才要修改）\n\t\tPWORD pOffset &#x3D; (PWORD)((DWORD)pRelocationTable + 8); &#x2F;&#x2F; 2字节偏移的数组\n\t\tfor (size_t i &#x3D; 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; 高4位等于0011才需要重定位\n\t\t\tif ((pOffset[i] &amp; 0xF000) &#x3D;&#x3D; 0x3000)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F; 计算需要重定位的数据的RVA地址\n\t\t\t\tDWORD dwRva &#x3D; pRelocationTable-&gt;VirtualAddress + (pOffset[i] &amp; 0x0FFF);\n\t\t\t\t&#x2F;&#x2F; 计算在文件中的偏移\n\t\t\t\tDWORD dwFoa &#x3D; RvaToFoa(pFileBuffer, dwRva);\n\t\t\t\t&#x2F;&#x2F; 计算在文件中的地址\n\t\t\t\tPDWORD pData &#x3D; (PDWORD)((DWORD)pFileBuffer + dwFoa);\n\t\t\t\t&#x2F;&#x2F; 重定位，即修正写死的地址\n\t\t\t\t*pData +&#x3D; dwImageBaseDelta;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\tpRelocationTable &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pRelocationTable + pRelocationTable-&gt;SizeOfBlock);\n\t&#125;\n\t&#x2F;&#x2F; 修改 ImageBase\n\tpOptionHeader-&gt;ImageBase &#x3D; dwNewImageBase;\n&#125;\n\n&#x2F;&#x2F; 打印导入表\nVOID PrintImportTable(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[1].VirtualAddress));\n\n\t&#x2F;&#x2F; 严格来说应该是 sizeof(IMAGE_IMPORT_DESCRIPTOR) 个字节为0表示结束\n\twhile (pImportTable-&gt;OriginalFirstThunk || pImportTable-&gt;FirstThunk)\n\t&#123;\n\t\t&#x2F;&#x2F; 打印模块名\n\t\tprintf(&quot;%s\\n&quot;, (LPCSTR)(RvaToFoa(pFileBuffer, pImportTable-&gt;Name) + (DWORD)pFileBuffer));\n\t\t&#x2F;&#x2F; 遍历INT表(import name table)\n\t\tprintf(&quot;--------------OriginalFirstThunkRVA:%x--%x\\n&quot;, pImportTable-&gt;OriginalFirstThunk,*pImportTable-&gt;OriginalFirstThunk);\n\t\tPIMAGE_THUNK_DATA32 pThunkData &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pFileBuffer + \\\n\t\t\tRvaToFoa(pFileBuffer, pImportTable-&gt;OriginalFirstThunk));\n\t\twhile (*((PDWORD)pThunkData) !&#x3D; 0)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; IMAGE_THUNK_DATA32 是一个4字节数据\n\t\t\t&#x2F;&#x2F; 如果最高位是1，那么除去最高位就是导出序号\n\t\t\t&#x2F;&#x2F; 如果最高位是0，那么这个值是RVA 指向 IMAGE_IMPORT_BY_NAME\n\t\t\tif ((*((PDWORD)pThunkData) &amp; 0x80000000) &#x3D;&#x3D; 0x80000000)&#x2F;&#x2F;IMAGE_ORDINAL_FLAG32 &#x3D;&#x3D; 0x80000000\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;按序号导入 Ordinal:%04x\\n&quot;, (*((PDWORD)pThunkData) &amp; 0x7FFFFFFF));\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tPIMAGE_IMPORT_BY_NAME pIBN &#x3D; (PIMAGE_IMPORT_BY_NAME)(RvaToFoa(pFileBuffer, *((PDWORD)pThunkData)) + \\\n\t\t\t\t\t(DWORD)pFileBuffer);\n\t\t\t\t\n\t\t\t\tprintf(&quot;按名字导入 Hint:%04x Name:%s\\n&quot;, pIBN-&gt;Hint, pIBN-&gt;Name);\n\t\t\t&#125;\n\t\t\tpThunkData++;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 遍历IAT表(import address table)\n\t\tprintf(&quot;--------------FirstThunkRVA:%x--%x\\n&quot;, pImportTable-&gt;FirstThunk,*pImportTable-&gt;FirstThunk);\n\t\tpThunkData &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pFileBuffer + \\\n\t\t\tRvaToFoa(pFileBuffer, pImportTable-&gt;FirstThunk));\n\t\twhile (*((PDWORD)pThunkData) !&#x3D; 0)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F; IMAGE_THUNK_DATA32 是一个4字节数据\n\t\t\t&#x2F;&#x2F; 如果最高位是1，那么除去最高位就是导出序号\n\t\t\t&#x2F;&#x2F; 如果最高位是0，那么这个值是RVA 指向 IMAGE_IMPORT_BY_NAME\n\t\t\tif ((*((PDWORD)pThunkData) &amp; 0x80000000) &#x3D;&#x3D; 0x80000000)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;按序号导入 Ordinal:%04x\\n&quot;, (*((PDWORD)pThunkData) &amp; 0x7FFFFFFF));\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tPIMAGE_IMPORT_BY_NAME pIBN &#x3D; (PIMAGE_IMPORT_BY_NAME)(RvaToFoa(pFileBuffer, *((PDWORD)pThunkData)) + \\\n\t\t\t\t\t(DWORD)pFileBuffer);\n\t\t\t\t\n\t\t\t\tprintf(&quot;按名字导入 Hint:%04x Name:%s\\n&quot;, pIBN-&gt;Hint, pIBN-&gt;Name);\n\t\t\t&#125;\n\t\t\tpThunkData++;\n\t\t&#125;\n\t\tpImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pImportTable + sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 打印绑定导入表\nVOID PrintBoundImportTable(LPVOID pFileBuffer)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t&#x2F;&#x2F; 判断方式\n\t&#x2F;*if (NULL &#x3D;&#x3D; pOptionHeader-&gt;DataDirectory[11].VirtualAddress)\n\t&#123;\n\t\tprintf(&quot;该程序绑定导入表为空\\n&quot;);\n\t\treturn;\n\t&#125;*&#x2F;\n\n\t&#x2F;&#x2F; 判断方式二\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[1].VirtualAddress));\n\tif (pImportTable-&gt;TimeDateStamp &#x3D;&#x3D; 0)&#x2F;&#x2F;\n\t&#123;\n\t\tprintf(&quot;该程序没有绑定导入\\n&quot;);\n\t\treturn;\n\t&#125;\n\t\n\tPIMAGE_BOUND_IMPORT_DESCRIPTOR pBoundImportTable &#x3D; (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[11].VirtualAddress));\n\tPIMAGE_BOUND_IMPORT_DESCRIPTOR pFirstBoundImportTable &#x3D; pBoundImportTable;\n\t\n\twhile (pBoundImportTable-&gt;TimeDateStamp || pBoundImportTable-&gt;OffsetModuleName || pBoundImportTable-&gt;NumberOfModuleForwarderRefs)\n\t&#123;\n\t\t&#x2F;&#x2F; 打印模块名、时间戳、依赖模块数量\n\t\tputs(&quot;-------------------------------------------&quot;);\n\t\tprintf(&quot;%s\\n&quot;, (LPCSTR) ((DWORD)pFirstBoundImportTable + pBoundImportTable-&gt;OffsetModuleName));&#x2F;&#x2F;\n\t\tprintf(&quot;TimeDateStamp:%x\\n&quot;, pBoundImportTable-&gt;TimeDateStamp);\n\t\tprintf(&quot;NumberOfModuleForwarderRefs:%d\\n&quot;, pBoundImportTable-&gt;NumberOfModuleForwarderRefs);\n\t\t&#x2F;&#x2F; 遍历依赖模块\n\t\tputs(&quot;------------------Refs---------------------&quot;);\n\t\tPIMAGE_BOUND_FORWARDER_REF pBFR &#x3D; (PIMAGE_BOUND_FORWARDER_REF)((DWORD)pBoundImportTable + \\\n\t\t\tsizeof(IMAGE_BOUND_IMPORT_DESCRIPTOR));\n\t\tfor (int i &#x3D; 0; i &lt; pBoundImportTable-&gt;NumberOfModuleForwarderRefs; i++)\n\t\t&#123;\n\t\t\tprintf(&quot;\\t%s\\n&quot;, (LPCSTR)((DWORD)pFirstBoundImportTable + pBFR[i].OffsetModuleName));&#x2F;&#x2F;\n\t\t\tprintf(&quot;\\tTimeDateStamp:%x\\n&quot;, pBFR[i].TimeDateStamp);\n\t\t&#125;\n\t\tpBoundImportTable &#x3D; (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((DWORD)pBoundImportTable + \\\n\t\t\tsizeof(IMAGE_BOUND_IMPORT_DESCRIPTOR) + \\\n\t\t\tpBoundImportTable-&gt;NumberOfModuleForwarderRefs * sizeof(IMAGE_BOUND_FORWARDER_REF));\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 导入表注入demo，通过修改导入表，将 InjectDll.dll 添加到导入表\n&#x2F;&#x2F; DLL只有一个导出函数 ExportFunction，保证至少有一个导出函数DLL才会被加载\n&#x2F;&#x2F; DLL的主函数在加载和分离时会弹窗\nDWORD ImportTableInjectDemo(LPVOID pFileBuffer, LPVOID *pNewFileBuffer, DWORD dwFileSize)\n&#123;\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\t\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[1].VirtualAddress));\n\n\t&#x2F;&#x2F; 计算新增节的大小\n\t&#x2F;&#x2F; 新增节存储的内容有：\n\t&#x2F;&#x2F;原来的所有导入表，[新导入表name O F(RVA)] 0，新INT 0, 一个_IMAGE_IMPORT_BY_NAME 0, func_name，新IAT，&quot;模块名.DLL&quot;\n\t&#x2F;&#x2F; 上述容器按0为结束标记的，也要包含结束标记\n\tDWORD dwNewSectionSize &#x3D; 0;\n\tDWORD dwNumberOfDll &#x3D; 0;\n\twhile (pImportTable-&gt;OriginalFirstThunk || pImportTable-&gt;FirstThunk)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;%s\\n&quot;, (LPCSTR)(RvaToFoa(pFileBuffer, pImportTable-&gt;Name) + (DWORD)pFileBuffer));\n\t\tdwNumberOfDll++;\n\t\tpImportTable++;\n\t&#125;\n\tdwNewSectionSize +&#x3D; (dwNumberOfDll + 2) * sizeof(IMAGE_IMPORT_DESCRIPTOR); &#x2F;&#x2F; 原有的和新添加的导入表，以及结束标记\n\tdwNewSectionSize +&#x3D; 16; &#x2F;&#x2F; 这里包括一个INT,一个IAT和两个结束标记\n\tdwNewSectionSize +&#x3D; strlen(&quot;InjectDll.dll&quot;) + 1; &#x2F;&#x2F; 模块名\n\tdwNewSectionSize +&#x3D; 2 + strlen(&quot;ExportFunction&quot;) + 1; &#x2F;&#x2F; _IMAGE_IMPORT_BY_NAME，包括Hint和函数名\n\tDWORD dwNewFileSize &#x3D; AddCodeSection(pFileBuffer, pNewFileBuffer, dwFileSize, dwNewSectionSize);\n\t\n\tpDosHeader &#x3D; (PIMAGE_DOS_HEADER)*pNewFileBuffer;\n\tpPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tpOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader &#x3D; (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\tpImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)*pNewFileBuffer + \\\n\t\tRvaToFoa(*pNewFileBuffer, pOptionHeader-&gt;DataDirectory[1].VirtualAddress));\n\n\t&#x2F;&#x2F; 设置新增节属性\n\tpSectionHeader[pPEHeader-&gt;NumberOfSections - 1].Characteristics &#x3D; 0xC0000040; &#x2F;&#x2F; 可读写，含已初始化数据\n\n\t&#x2F;&#x2F; 定义指针指向新增节首字节\n\tLPVOID pNewSec &#x3D; (LPVOID)((DWORD)*pNewFileBuffer + pSectionHeader[pPEHeader-&gt;NumberOfSections - 1].PointerToRawData);\n\tLPVOID pInsert &#x3D; pNewSec;\n\t&#x2F;&#x2F; 复制原有的导入表\n\tmemcpy(pInsert, pImportTable, dwNumberOfDll * sizeof(IMAGE_IMPORT_DESCRIPTOR));\t\n\t&#x2F;&#x2F; 设置新导入表的时间戳，ForwarderChain\n\tpImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pInsert + dwNumberOfDll * sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\tpImportTable-&gt;TimeDateStamp &#x3D; 0; &#x2F;&#x2F; 表示不使用绑定导入\n\tpImportTable-&gt;ForwarderChain &#x3D; -1;\n\t&#x2F;&#x2F; 设置导入表结束标记\n\tpInsert &#x3D; (LPVOID)((DWORD)pImportTable + sizeof(IMAGE_IMPORT_DESCRIPTOR)); &#x2F;&#x2F; 指向结束标记\n\tmemset(pInsert, 0, sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\t&#x2F;&#x2F; 指定INT表插入点\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + sizeof(IMAGE_IMPORT_DESCRIPTOR)); &#x2F;&#x2F; 现在指向INT表\n\tPIMAGE_THUNK_DATA pINT &#x3D; (PIMAGE_THUNK_DATA)pInsert; &#x2F;&#x2F; 定义指向INT表的指针\n\t&#x2F;&#x2F; 设置INT结束标志\n\tmemset(pINT + 1, 0, sizeof(IMAGE_THUNK_DATA));\n\t&#x2F;&#x2F; 设置 IMPORT_BY_NAME，INT表和IAT表共同指向这块内存\n\tPIMAGE_IMPORT_BY_NAME pImportByName &#x3D; (PIMAGE_IMPORT_BY_NAME)((DWORD)pINT + 8); &#x2F;&#x2F; IMPORT_BY_NAME插入点\n\tpImportByName-&gt;Hint &#x3D; 0; &#x2F;&#x2F; 设置没有用的导出序号\n\tstrcpy((char*)(pImportByName-&gt;Name), &quot;ExportFunction&quot;); &#x2F;&#x2F; 设置函数名\n\t&#x2F;&#x2F; INT表的[值]是 IMPORT_BY_NAME 的[RVA]\n\t*((PDWORD)pINT) &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pImportByName - (DWORD)*pNewFileBuffer); &#x2F;&#x2F; 设置INT的值\n\t&#x2F;&#x2F; 设置IAT表\n\tpInsert &#x3D; (LPVOID)((DWORD)pImportByName + 2 + strlen(&quot;ExportFunction&quot;) + 1); &#x2F;&#x2F; 指向IAT表\n\tPIMAGE_THUNK_DATA  pIAT &#x3D; (PIMAGE_THUNK_DATA)pInsert; &#x2F;&#x2F; IAT插入点\n\tmemcpy(pIAT, pINT, 8);\n\t&#x2F;&#x2F; 分配模块名的内存，并完成导入表剩余属性的赋值\n\tpInsert &#x3D; (LPVOID)((DWORD)pInsert + 8);\n\tstrcpy((char *)pInsert, &quot;InjectDll.dll&quot;);\n\t&#x2F;&#x2F; 设置导入表属性\n\tpImportTable-&gt;OriginalFirstThunk &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pINT - (DWORD)*pNewFileBuffer);\n\tpImportTable-&gt;FirstThunk &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pIAT - (DWORD)*pNewFileBuffer);\n\tpImportTable-&gt;Name &#x3D; FoaToRva(*pNewFileBuffer, (DWORD)pInsert - (DWORD)*pNewFileBuffer);\n\t&#x2F;&#x2F; 更新目录项中导入表的位置\n\tpOptionHeader-&gt;DataDirectory[1].VirtualAddress &#x3D; FoaToRva(*pNewFileBuffer, ((DWORD)pNewSec - (DWORD)*pNewFileBuffer));\n\treturn dwNewFileSize;\n&#125;\n\n&#x2F;&#x2F; 打印资源表\nVOID PrintResourceTable(LPVOID pFileBuffer)\n&#123;\n\t&#x2F;&#x2F;资源的类型\n\tPCHAR lpszResType[17] &#x3D; &#123; &quot;未定义&quot;, &quot;光标&quot;, &quot;位图&quot;, &quot;图标&quot;, &quot;菜单&quot;,\n\t\t&quot;对话框&quot;, &quot;字符串&quot;,&quot;字体目录&quot;, &quot;字体&quot;,\n\t\t&quot;加速键&quot;, &quot;非格式化资源&quot;, &quot;消息列表&quot;, &quot;光标组&quot;,\n\t\t&quot;未定义&quot;, &quot;图标组&quot;,&quot;未定义&quot;, &quot;版本信息&quot; &#125;;\n\n\tPIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_FILE_HEADER pPEHeader &#x3D; (PIMAGE_FILE_HEADER)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader &#x3D; (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader &#x3D; \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);\n\n\t&#x2F;&#x2F; 定义第一层的指针和长度\n\tPIMAGE_RESOURCE_DIRECTORY pResDir1 &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)pFileBuffer + \\\n\t\tRvaToFoa(pFileBuffer, pOptionHeader-&gt;DataDirectory[2].VirtualAddress));\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry1 &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pResDir1 + \\\n\t\tsizeof(IMAGE_RESOURCE_DIRECTORY));\n\tint dwNumberOfResDirEntry1 &#x3D; pResDir1-&gt;NumberOfNamedEntries + pResDir1-&gt;NumberOfIdEntries;\n\tprintf(&quot;资源类型数量: %d\\n&quot;, dwNumberOfResDirEntry1);\n\t&#x2F;&#x2F; 遍历第一层：类型\n\tfor (int i &#x3D; 0; i &lt; dwNumberOfResDirEntry1; i++)\n\t&#123;\n\t\t&#x2F;&#x2F; 如果高位是1，低31位是指针，指向一个Unicode字符串\n\t\tif (pResDirEntry1[i].NameIsString &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tPIMAGE_RESOURCE_DIR_STRING_U uString &#x3D; \n\t\t\t\t(PIMAGE_RESOURCE_DIR_STRING_U)((DWORD)pResDir1 + (pResDirEntry1[i].NameOffset &amp; 0x7FFFFFFF));\n\t\t\tWCHAR *pName &#x3D; (WCHAR *)malloc(2 * (uString-&gt;Length + 1));\n\t\t\tmemset(pName, 0, 2 * (uString-&gt;Length + 1));\n\t\t\tmemcpy(pName, uString-&gt;NameString, 2 * uString-&gt;Length);\n\t\t\twprintf(L&quot;ID:  - 资源类型: \\&quot;%s\\&quot;\\n&quot;, pName);\n\t\t\tfree(pName);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 如果最高位是0，则这是一个序号，是预定义的16种资源之一\n\t\telse\n\t\t&#123;\n\t\t\tif (pResDirEntry1[i].Id &lt;&#x3D; 16)\n\t\t\t\tprintf(&quot;ID: %2d 资源类型: %s\\n&quot;, pResDirEntry1[i].Id, lpszResType[pResDirEntry1[i].Id]);\n\t\t\telse\n\t\t\t\tprintf(&quot;ID: %2d 资源类型: 未定义\\n&quot;, pResDirEntry1[i].Id);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 定义第二层的指针和长度\n\t\tPIMAGE_RESOURCE_DIRECTORY pResDir2 &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)pResDir1 + \\\n\t\t\t(pResDirEntry1[i].OffsetToData &amp; 0x7FFFFFFF));\n\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry2 &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pResDir2 + \\\n\t\t\tsizeof(IMAGE_RESOURCE_DIRECTORY));\n\t\tint dwNumberOfResDirEntry2 &#x3D; pResDir2-&gt;NumberOfNamedEntries + pResDir2-&gt;NumberOfIdEntries;\n\t\t&#x2F;&#x2F; 遍历第二层：编号\n\t\t&#x2F;&#x2F;printf(&quot;第二层项数: %d\\n&quot;, dwNumberOfNumber);\n\t\tfor (int j &#x3D; 0; j &lt; dwNumberOfResDirEntry2; j++)\n\t\t&#123;\n\t\t\tif (pResDirEntry2[j].NameIsString &#x3D;&#x3D; 1)\n\t\t\t&#123;\n\t\t\t\tPIMAGE_RESOURCE_DIR_STRING_U uString &#x3D; \n\t\t\t\t\t(PIMAGE_RESOURCE_DIR_STRING_U)((DWORD)pResDir1 + (pResDirEntry2[j].NameOffset &amp; 0x7FFFFFFF));\n\t\t\t\tWCHAR *pName &#x3D; (WCHAR *)malloc(2 * (uString-&gt;Length + 1));\n\t\t\t\tmemset(pName, 0, 2 * (uString-&gt;Length + 1));\n\t\t\t\tmemcpy(pName, uString-&gt;NameString, 2 * uString-&gt;Length);\n\t\t\t\twprintf(L&quot;\\tName: \\&quot;%s\\&quot;\\n&quot;, pName);\n\t\t\t\tfree(pName);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;\\tID: %d\\n&quot;, pResDirEntry2[j].Id);\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F; 定义第三层的指针和长度\n\t\t\tPIMAGE_RESOURCE_DIRECTORY pResDir3 &#x3D; (PIMAGE_RESOURCE_DIRECTORY)((DWORD)pResDir1 + \\\n\t\t\t\t(pResDirEntry2[j].OffsetToData &amp; 0x7FFFFFFF));\n\t\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry3 &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)pResDir3 + \\\n\t\t\t\tsizeof(IMAGE_RESOURCE_DIRECTORY));\n\t\t\tint dwNumberOfResDirEntry3 &#x3D; pResDir3-&gt;NumberOfNamedEntries + pResDir3-&gt;NumberOfIdEntries;\n\t\t\t&#x2F;&#x2F; 遍历第三层：代码页\n\t\t\t&#x2F;&#x2F; 大多数情况下一个资源的代码页只定义一种，但不是绝对，因此第三层也要循环遍历\n\t\t\t&#x2F;&#x2F;printf(&quot;\\t\\t%d\\n&quot;, dwNumberOfResDirEntry3); &#x2F;&#x2F; 真有不是1的\n\t\t\tfor (int k &#x3D; 0; k &lt; dwNumberOfResDirEntry3; k++)\n\t\t\t&#123;\n\t\t\t\tif (pResDirEntry3[k].Name &amp; 0x80000000)\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;\\t非标准代码页\\n&quot;);\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\tprintf(&quot;\\t代码页: %d\\n&quot;, pResDirEntry3[k].Id &amp; 0x7FFF);\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; 资源数据项，通过这个结构可以找到资源的RVA，以及大小\n\t\t\t\tPIMAGE_RESOURCE_DATA_ENTRY pDataEntry &#x3D; (PIMAGE_RESOURCE_DATA_ENTRY)((DWORD)pResDir1 + \\\n\t\t\t\t\tpResDirEntry3[k].OffsetToData);\n\t\t\t\tprintf(&quot;\\tRVA: %x\\tSIZE: %x\\n&quot;, pDataEntry-&gt;OffsetToData, pDataEntry-&gt;Size);\n\t\t\t&#125;\n\t\t\tprintf(&quot;\\n&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n\n","slug":"PEToolKit","date":"2020-08-14T15:41:26.000Z","categories_index":"逆向","tags_index":"逆向","author_index":"CodingSeed"},{"id":"5c08fcc79221f552ac38df01c4301f35","title":"yxc_share模板","content":"日本信奥网站 Atcoder AGC 思维难度 训练思维 Complexity:AGC 的 D 题《计算概论》，华东师范大学第二附属中学 chen_zhehzwer 发起的的 shareOI、OI Wiki、Loj 与 Uoj、洛谷的集训队 50 题用洛谷的RemoteJudge去评测这些题目（部分带有翻译，需要先绑定UvaOJ账号），体验会好一些，提升刷题效率 CodeForces SPOJ AtCoder UVA欧拉计划OI-Wiki\n\n《C++ 之 unordered_map——哈希表》unordered_map是C++中的哈希表，可以在任意类型与类型之间做映射。\n\n基本操作\n引用头文件(C++11)：#include &lt;unordered_map&gt;\n定义：unordered_map&lt;int,int&gt;、unordered_map&lt;string, double&gt; ...\n插入：例如将(&quot;ABC&quot; -&gt; 5.45) 插入unordered_map&lt;string, double&gt; hash中，hash[&quot;ABC&quot;]&#x3D;5.45\n查询：hash[&quot;ABC&quot;]会返回5.45\n判断key是否存在：hash.count(&quot;ABC&quot;) !&#x3D; 0 或 hash.find(&quot;ABC&quot;) !&#x3D; hash.end()\n遍历\nfor (auto &amp;item : hash)\n&#123;\n    cout &lt;&lt; item.first &lt;&lt; &#39; &#39; &lt;&lt; item.second &lt;&lt; endl;\n&#125;\n或\n\nfor (unordered_map&lt;string, double&gt;::iterator it &#x3D; hash.begin(); it !&#x3D; hash.end(); it ++ )\n&#123;\n    cout &lt;&lt; it-&gt;first &lt;&lt; &#39; &#39; &lt;&lt; it-&gt;second &lt;&lt; endl;\n&#125;\n进阶操作\n如果想让自定义的class作为key（unordered_map&lt;key,value&gt;）来使用unordered_map，需要实现：\n(1) 哈希函数，需要实现一个class重载operator()，将自定义class变量映射到一个size_t类型的数。一般常用std::hash模板来实现。\n(2) 判断两个自定义class类型的变量是否相等的函数，一般在自定义class里重载operator&#x3D;&#x3D;。\n示例代码：\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nclass Myclass\n&#123;\npublic:\n    int first;\n    vector&lt;int&gt; second;\n\n    &#x2F;&#x2F; 重载等号，判断两个Myclass类型的变量是否相等\n    bool operator&#x3D;&#x3D; (const Myclass &amp;other) const\n    &#123;\n        return first &#x3D;&#x3D; other.first &amp;&amp; second &#x3D;&#x3D; other.second;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 实现Myclass类的hash函数\nnamespace std\n&#123;\n    template &lt;&gt;\n    struct hash&lt;Myclass&gt;\n    &#123;\n        size_t operator()(const Myclass &amp;k) const\n        &#123;\n            int h &#x3D; k.first;\n            for (auto x : k.second)\n            &#123;\n                h ^&#x3D; x;\n            &#125;\n            return h;\n        &#125;\n    &#125;;\n&#125;\n\nint main()\n&#123;\n    unordered_map&lt;Myclass, double&gt; S;\n    Myclass a &#x3D; &#123; 2, &#123;3, 4&#125; &#125;;\n    Myclass b &#x3D; &#123; 3, &#123;1, 2, 3, 4&#125; &#125;;\n    S[a] &#x3D; 2.5;\n    S[b] &#x3D; 3.123;\n    cout &lt;&lt; S[a] &lt;&lt; &#39; &#39; &lt;&lt; S[b] &lt;&lt; endl;\n    return 0;\n&#125;\n输出:\n\n2.5 3.123\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;9&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n《由数据范围反推算法复杂度以及算法内容》一般ACM或者笔试题的时间限制是1秒或2秒。在这种情况下，C++代码中的操作次数控制在 10^7 为最佳。\n下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：\nn≤30, 指数级别, dfs+剪枝，状态压缩dpn≤100 &#x3D;&gt; O(n^3)，floyd，dpn≤1000 &#x3D;&gt; O(n^2)，O(n^2logn)，dp，二分n≤10000 &#x3D;&gt; O(n√n)，块状链表n≤100000 &#x3D;&gt; O(nlogn) &#x3D;&gt; 各种sort，线段树、树状数组、set&#x2F;map、heap、dijkstra+heap、spfa、求凸包、求半平面交、二分n≤1000000 &#x3D;&gt; O(n), 以及常数较小的 O(nlogn) 算法 &#x3D;&gt; hash、双指针扫描、kmp、(Trie)AC自动机，常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfan≤10000000 &#x3D;&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数n≤10^9 &#x3D;&gt; O(√n)，判断质数n≤10^18 &#x3D;&gt; O(logn)，最大公约数\n\n《求解斐波那契数列的若干方法》今天来给大家介绍几个在面试中常用的、求解斐波那契数列问题的方法。\n\n首先定义斐波那契数列问题：\n\n定义 a0&#x3D;1a0&#x3D;1, a1&#x3D;1a1&#x3D;1, an&#x3D;an−1+an−2an&#x3D;an−1+an−2，求 anan 是多少。\n为了避免考虑整数溢出问题，我们求 an%pan%p 的值，p&#x3D;109+7p&#x3D;109+7。\n\n算法1\n递归。\n递归计算的节点个数是 O(2n)O(2n) 的级别的，存在大量重复计算。\n时间复杂度是 O(2n)O(2n)，一秒内大约能算到第三四十项。\n\nC++ 代码\nconst int MOD &#x3D; 1000000007;\nint f(int n)\n&#123;\n    if (n &lt;&#x3D; 1) return 1;\n    return (f(n - 1) + f(n - 2)) % MOD;\n&#125;\n算法2\n记忆化搜索。\n开一个大数组记录中间结果，如果一个状态被计算过，则直接查表，否则再递归计算。\n总共有 nn 个状态，计算每个状态的复杂度是 O(1)O(1)，所以时间复杂度是 O(n)O(n)。\n一秒内算 n&#x3D;107n&#x3D;107 毫无压力，但由于是递归计算，递归层数太多会爆栈，大约只能算到 n&#x3D;105n&#x3D;105 级别。\n\nC++ 代码\nconst int N &#x3D; 100000, MOD &#x3D; 1000000007;\nint a[N];\nint f2(int n)\n&#123;\n    if (a[n]) return a[n];\n    if (n &lt;&#x3D; 1) return 1;\n    a[n] &#x3D; f2(n - 1) + f2(n - 2);\n    a[n] %&#x3D; MOD;\n    return a[n];\n&#125;\n算法3\n递推。\n开一个大数组，记录每个数的值。用循环递推计算。\n总共计算 nn 个状态，所以时间复杂度是 O(n)O(n)。\n但需要开一个长度是 nn 的数组，内存将成为瓶颈，当 n&#x3D;108n&#x3D;108 时，需要的内存是 4∗1081024×1024≈381MB4∗1081024×1024≈381MB。\n分子中乘4是因为C++中 int 类型占4字节。\n\nC++代码\nconst int N &#x3D; 100000000, MOD &#x3D; 1000000007;\nint f3(int n)\n&#123;\n    a[0] &#x3D; a[1] &#x3D; 1;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        a[i] &#x3D; a[i - 1] + a[i - 2];\n        a[i] %&#x3D; MOD;\n    &#125;\n    return a[n];\n&#125;\n算法4\n递归+滚动变量。\n仔细观察我们会发现，递推时我们只需要记录前两项的值即可，没有必要记录所有值，所以我们可以用滚动变量递推。\n时间复杂度还是 O(n)O(n)，但空间复杂度变成了 O(1)O(1)。\n\nC++代码：\nconst int MOD &#x3D; 1000000007;\nint f4(int n)\n&#123;\n    int x, y, z;\n    x &#x3D; y &#x3D; 1;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        z &#x3D; (x + y) % MOD;\n        x &#x3D; y;\n        y &#x3D; z;\n    &#125;\n    return z;\n&#125;\n算法5\n矩阵运算 + 快速幂。\n\n快速幂算法的模板可以参考这里。\n用算法4我们1秒内最多可以算到 108108 级别，那当 nn 更大时该怎么办呢？\n可以先利用矩阵运算的性质将通项公式变成幂次形式，然后用平方倍增（快速幂）的方法求解第 nn 项。\n\n首先我们定义向量\nXn&#x3D;[anan−1],边界：X1&#x3D;[a1a0]\nXn&#x3D;[anan−1],边界：X1&#x3D;[a1a0]\n然后我们可以找出矩阵：\nA&#x3D;[1110]\nA&#x3D;[1110]\n则有：\nXn&#x3D;Xn−1×A\nXn&#x3D;Xn−1×A\n所以：\n\nXn&#x3D;X1×An−1\nXn&#x3D;X1×An−1\n由于矩阵具有结合律，所以我们可以先求出 An−1%PAn−1%P，然后再用 X1X1 左乘，即可求出 XnXn，向量 XnXn 的第一个元素就是 anan。\n\n时间复杂度分析：快速幂的时间复杂度是 O(logn)O(logn)，所以算法5的时间复杂度也是 O(logn)O(logn)。\n\nC++代码\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nconst int MOD &#x3D; 1000000007;\n\nvoid mul(int a[][2], int b[][2], int c[][2])\n&#123;\n    int temp[][2] &#x3D; &#123;&#123;0, 0&#125;, &#123;0, 0&#125;&#125;;\n    for (int i &#x3D; 0; i &lt; 2; i ++ )\n        for (int j &#x3D; 0; j &lt; 2; j ++ )\n            for (int k &#x3D; 0; k &lt; 2; k ++ )\n            &#123;\n                long long x &#x3D; temp[i][j] + (long long)a[i][k] * b[k][j];\n                temp[i][j] &#x3D; x % MOD;\n            &#125;\n    for (int i &#x3D; 0; i &lt; 2; i ++ )\n        for (int j &#x3D; 0; j &lt; 2; j ++ )\n            c[i][j] &#x3D; temp[i][j];\n&#125;\n\n\nint f_final(long long n)\n&#123;\n    int x[2] &#x3D; &#123;1, 1&#125;;\n\n    int res[][2] &#x3D; &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;\n    int t[][2] &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;\n    long long k &#x3D; n - 1;\n    while (k)\n    &#123;\n        if (k&amp;1) mul(res, t, res);\n        mul(t, t, t);\n        k &gt;&gt;&#x3D; 1;\n    &#125;\n\n    int c[2] &#x3D; &#123;0, 0&#125;;\n    for (int i &#x3D; 0; i &lt; 2; i ++ )\n        for (int j &#x3D; 0; j &lt; 2; j ++ )\n        &#123;\n            long long r &#x3D; c[i] + (long long)x[j] * res[j][i];\n            c[i] &#x3D; r % MOD;\n        &#125;\n\n    return c[0];\n&#125;\n\n\nint main()\n&#123;\n    long long n ;\n\n    cin &gt;&gt; n;\n    cout &lt;&lt; f_final(n) &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;25&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n《常用代码模板1——基础算法》算法基础课相关代码模板\n活动链接 —— 算法基础课\n快速排序算法模板 —— 模板题 AcWing 785. 快速排序\nvoid quick_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    &#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    &#125;\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n&#125;\n归并排序算法模板 —— 模板题 AcWing 787. 归并排序\nvoid merge_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int mid &#x3D; l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];\n        else tmp[k ++ ] &#x3D; q[j ++ ];\n\n    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];\n    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];\n\n    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];\n&#125;\n整数二分算法模板 —— 模板题 AcWing 789. 数的范围\nbool check(int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质\n        else l &#x3D; mid + 1;\n    &#125;\n    return l;\n&#125;\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l &#x3D; mid;\n        else r &#x3D; mid - 1;\n    &#125;\n    return l;\n&#125;\n浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根\nbool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    &#123;\n        double mid &#x3D; (l + r) &#x2F; 2;\n        if (check(mid)) r &#x3D; mid;\n        else l &#x3D; mid;\n    &#125;\n    return l;\n&#125;\n高精度加法 —— 模板题 AcWing 791. 高精度加法\n&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t +&#x3D; A[i];\n        if (i &lt; B.size()) t +&#x3D; B[i];\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    if (t) C.push_back(t);\n    return C;\n&#125;\n高精度减法 —— 模板题 AcWing 792. 高精度减法\n&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t &#x3D; A[i] - t;\n        if (i &lt; B.size()) t -&#x3D; B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t &#x3D; 1;\n        else t &#x3D; 0;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;\n高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法\n&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n&#123;\n    vector&lt;int&gt; C;\n\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )\n    &#123;\n        if (i &lt; A.size()) t +&#x3D; A[i] * b;\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n    return C;\n&#125;\n高精度除以低精度 —— 模板题 AcWing 794. 高精度除法\n&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int&gt; C;\n    r &#x3D; 0;\n    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )\n    &#123;\n        r &#x3D; r * 10 + A[i];\n        C.push_back(r &#x2F; b);\n        r %&#x3D; b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;\n一维前缀和 —— 模板题 AcWing 795. 前缀和\nS[i] &#x3D; a[1] + a[2] + ... a[i]\na[l] + ... + a[r] &#x3D; S[r] - S[l - 1]\n二维前缀和 —— 模板题 AcWing 796. 子矩阵的和\nS[i, j] &#x3D; 第i行j列格子左上部分所有元素的和\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n一维差分 —— 模板题 AcWing 797. 差分\n给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c\n二维差分 —— 模板题 AcWing 798. 差分矩阵\n给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c\n位运算 —— 模板题 AcWing 801. 二进制中1的个数\n求n的第k位数字: n &gt;&gt; k &amp; 1\n返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n\n双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和\nfor (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;\n\n    &#x2F;&#x2F; 具体问题的逻辑\n&#125;\n常见问题分类：\n    (1) 对于一个序列，用两个指针维护一段区间\n    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\n离散化 —— 模板题 AcWing 802. 区间和\nvector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值\nsort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素\n\n&#x2F;&#x2F; 二分求出x对应的离散化的值\nint find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n\n&#125;\n区间合并 —— 模板题 AcWing 803. 区间合并\n&#x2F;&#x2F; 将所有存在交集的区间合并\nvoid merge(vector&lt;PII&gt; &amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n\n    sort(segs.begin(), segs.end());\n\n    int st &#x3D; -2e9, ed &#x3D; -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)\n        &#123;\n            if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n            st &#x3D; seg.first, ed &#x3D; seg.second;\n        &#125;\n        else ed &#x3D; max(ed, seg.second);\n\n    if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n\n    segs &#x3D; res;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;277&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n《常用代码模板2——数据结构》算法基础课相关代码模板\n活动链接 —— 算法基础课\n单链表 —— 模板题 AcWing 826. 单链表\n&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    head &#x3D; -1;\n    idx &#x3D; 0;\n&#125;\n\n&#x2F;&#x2F; 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head &#x3D; ne[head];\n&#125;\n双链表 —— 模板题 AcWing 827. 双链表\n&#x2F;&#x2F; e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    &#x2F;&#x2F;0是左端点，1是右端点\n    r[0] &#x3D; 1, l[1] &#x3D; 0;\n    idx &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] &#x3D; x;\n    l[idx] &#x3D; a, r[idx] &#x3D; r[a];\n    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] &#x3D; l[a];\n    r[l[a]] &#x3D; r[a];\n&#125;\n栈 —— 模板题 AcWing 828. 模拟栈\n&#x2F;&#x2F; tt表示栈顶\nint stk[N], tt &#x3D; 0;\n\n&#x2F;&#x2F; 向栈顶插入一个数\nstk[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从栈顶弹出一个数\ntt -- ;\n\n&#x2F;&#x2F; 栈顶的值\nstk[tt];\n\n&#x2F;&#x2F; 判断栈是否为空\nif (tt &gt; 0)\n&#123;\n\n&#125;\n队列 —— 模板题 AcWing 829. 模拟队列\n\n1. 普通队列：\n   &#x2F;&#x2F; hh 表示队头，tt表示队尾\n   int q[N], hh &#x3D; 0, tt &#x3D; -1;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh &lt;&#x3D; tt)\n&#123;\n\n&#125;\n\n2. 循环队列\n   &#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置\n   int q[N], hh &#x3D; 0, tt &#x3D; 0;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[tt ++ ] &#x3D; x;\nif (tt &#x3D;&#x3D; N) tt &#x3D; 0;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\nif (hh &#x3D;&#x3D; N) hh &#x3D; 0;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh !&#x3D; tt)\n&#123;\n\n&#125;\n单调栈 —— 模板题 AcWing 830. 单调栈\n常见模型：找出每个数左边离它最近的比它大&#x2F;小的数\nint tt &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n&#123;\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] &#x3D; i;\n&#125;\n单调队列 —— 模板题 AcWing 154. 滑动窗口\n常见模型：找出滑动窗口中的最大值&#x2F;最小值\nint hh &#x3D; 0, tt &#x3D; -1;\nfor (int i &#x3D; 0; i &lt; n; i ++ )\n&#123;\n    while (hh &lt;&#x3D; tt &amp;&amp; check_out(q[hh])) hh ++ ;  &#x2F;&#x2F; 判断队头是否滑出窗口\n    while (hh &lt;&#x3D; tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] &#x3D; i;\n&#125;\nKMP —— 模板题 AcWing 831. KMP字符串\n&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度\n求模式串的Next数组：\nfor (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )\n&#123;\n    while (j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];\n    if (p[i] &#x3D;&#x3D; p[j + 1]) j ++ ;\n    ne[i] &#x3D; j;\n&#125;\n\n&#x2F;&#x2F; 匹配\nfor (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )\n&#123;\n    while (j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];\n    if (s[i] &#x3D;&#x3D; p[j + 1]) j ++ ;\n    if (j &#x3D;&#x3D; m)\n    &#123;\n        j &#x3D; ne[j];\n        &#x2F;&#x2F; 匹配成功后的逻辑\n    &#125;\n&#125;\nTrie树 —— 模板题 AcWing 835. Trie字符串统计\nint son[N][26], cnt[N], idx;\n&#x2F;&#x2F; 0号点既是根节点，又是空节点\n&#x2F;&#x2F; son[][]存储树中每个节点的子节点\n&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量\n\n&#x2F;&#x2F; 插入一个字符串\nvoid insert(char *str)\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) son[p][u] &#x3D; ++ idx;\n        p &#x3D; son[p][u];\n    &#125;\n    cnt[p] ++ ;\n&#125;\n\n&#x2F;&#x2F; 查询字符串出现的次数\nint query(char *str)\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) return 0;\n        p &#x3D; son[p][u];\n    &#125;\n    return cnt[p];\n&#125;\n并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量\n(1)朴素并查集：\n\n    int p[N]; &#x2F;&#x2F;存储每个点的祖宗节点\n    \n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n        return p[x];\n    &#125;\n    \n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;\n    \n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    p[find(a)] &#x3D; find(b);\n\n\n(2)维护size的并查集：\n\n    int p[N], size[N];\n    &#x2F;&#x2F;p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量\n    \n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n        return p[x];\n    &#125;\n    \n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        p[i] &#x3D; i;\n        size[i] &#x3D; 1;\n    &#125;\n    \n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    size[find(b)] +&#x3D; size[find(a)];\n    p[find(a)] &#x3D; find(b);\n\n\n(3)维护到祖宗节点距离的并查集：\n\n    int p[N], d[N];\n    &#x2F;&#x2F;p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离\n    \n    &#x2F;&#x2F; 返回x的祖宗节点\n    int find(int x)\n    &#123;\n        if (p[x] !&#x3D; x)\n        &#123;\n            int u &#x3D; find(p[x]);\n            d[x] +&#x3D; d[p[x]];\n            p[x] &#x3D; u;\n        &#125;\n        return p[x];\n    &#125;\n    \n    &#x2F;&#x2F; 初始化，假定节点编号是1~n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        p[i] &#x3D; i;\n        d[i] &#x3D; 0;\n    &#125;\n    \n    &#x2F;&#x2F; 合并a和b所在的两个集合：\n    p[find(a)] &#x3D; find(b);\n    d[find(a)] &#x3D; distance; &#x2F;&#x2F; 根据具体问题，初始化find(a)的偏移量\n\n堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆\n&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置\n&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n\n&#x2F;&#x2F; 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n&#123;\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n&#125;\n\nvoid down(int u)\n&#123;\n    int t &#x3D; u;\n    if (u * 2 &lt;&#x3D; size &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;\n    if (u * 2 + 1 &lt;&#x3D; size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;\n    if (u !&#x3D; t)\n    &#123;\n        heap_swap(u, t);\n        down(t);\n    &#125;\n&#125;\n\nvoid up(int u)\n&#123;\n    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])\n    &#123;\n        heap_swap(u, u &#x2F; 2);\n        u &gt;&gt;&#x3D; 1;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; O(n)建堆\nfor (int i &#x3D; n &#x2F; 2; i; i -- ) down(i);\n一般哈希 —— 模板题 AcWing 840. 模拟散列表\n(1) 拉链法\n    int h[N], e[N], ne[N], idx;\n\n    &#x2F;&#x2F; 向哈希表中插入一个数\n    void insert(int x)\n    &#123;\n        int k &#x3D; (x % N + N) % N;\n        e[idx] &#x3D; x;\n        ne[idx] &#x3D; h[k];\n        h[k] &#x3D; idx ++ ;\n    &#125;\n    \n    &#x2F;&#x2F; 在哈希表中查询某个数是否存在\n    bool find(int x)\n    &#123;\n        int k &#x3D; (x % N + N) % N;\n        for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i])\n            if (e[i] &#x3D;&#x3D; x)\n                return true;\n    \n        return false;\n    &#125;\n\n(2) 开放寻址法\n    int h[N];\n\n    &#x2F;&#x2F; 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\n    int find(int x)\n    &#123;\n        int t &#x3D; (x % N + N) % N;\n        while (h[t] !&#x3D; null &amp;&amp; h[t] !&#x3D; x)\n        &#123;\n            t ++ ;\n            if (t &#x3D;&#x3D; N) t &#x3D; 0;\n        &#125;\n        return t;\n    &#125;\n\n字符串哈希 —— 模板题 AcWing 841. 字符串哈希\n核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\n\ntypedef unsigned long long ULL;\nULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n\n&#x2F;&#x2F; 初始化\np[0] &#x3D; 1;\nfor (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n&#123;\n    h[i] &#x3D; h[i - 1] * P + str[i];\n    p[i] &#x3D; p[i - 1] * P;\n&#125;\n\n&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n&#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\nC++ STL简介\nvector, 变长数组，倍增的思想\n    size()  返回元素个数\n    empty()  返回是否为空\n    clear()  清空\n    front()&#x2F;back()\n    push_back()&#x2F;pop_back()\n    begin()&#x2F;end()\n    []\n    支持比较运算，按字典序\n\npair&lt;int, int&gt;\n    first, 第一个元素\n    second, 第二个元素\n    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）\n\nstring，字符串\n    size()&#x2F;length()  返回字符串长度\n    empty()\n    clear()\n    substr(起始下标，(子串长度))  返回子串\n    c_str()  返回字符串所在字符数组的起始地址\n\nqueue, 队列\n    size()\n    empty()\n    push()  向队尾插入一个元素\n    front()  返回队头元素\n    back()  返回队尾元素\n    pop()  弹出队头元素\n\npriority_queue, 优先队列，默认是大根堆\n    size()\n    empty()\n    push()  插入一个元素\n    top()  返回堆顶元素\n    pop()  弹出堆顶元素\n    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n\nstack, 栈\n    size()\n    empty()\n    push()  向栈顶插入一个元素\n    top()  返回栈顶元素\n    pop()  弹出栈顶元素\n\ndeque, 双端队列\n    size()\n    empty()\n    clear()\n    front()&#x2F;back()\n    push_back()&#x2F;pop_back()\n    push_front()&#x2F;pop_front()\n    begin()&#x2F;end()\n    []\n\nset, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列\n    size()\n    empty()\n    clear()\n    begin()&#x2F;end()\n    ++, -- 返回前驱和后继，时间复杂度 O(logn)\n\n    set&#x2F;multiset\n        insert()  插入一个数\n        find()  查找一个数\n        count()  返回某一个数的个数\n        erase()\n            (1) 输入是一个数x，删除所有x   O(k + logn)\n            (2) 输入一个迭代器，删除这个迭代器\n        lower_bound()&#x2F;upper_bound()\n            lower_bound(x)  返回大于等于x的最小的数的迭代器\n            upper_bound(x)  返回大于x的最小的数的迭代器\n    map&#x2F;multimap\n        insert()  插入的数是一个pair\n        erase()  输入的参数是pair或者迭代器\n        find()\n        []  注意multimap不支持此操作。 时间复杂度是 O(logn)\n        lower_bound()&#x2F;upper_bound()\n\nunordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表\n    和上面类似，增删改查的时间复杂度是 O(1)\n    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--\n\nbitset, 圧位\n    bitset&lt;10000&gt; s;\n    ~, &amp;, |, ^\n    &gt;&gt;, &lt;&lt;\n    &#x3D;&#x3D;, !&#x3D;\n    []\n\n    count()  返回有多少个1\n    \n    any()  判断是否至少有一个1\n    none()  判断是否全为0\n    \n    set()  把所有位置成1\n    set(k, v)  将第k位变成v\n    reset()  把所有位变成0\n    flip()  等价于~\n    flip(k) 把第k位取反\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;404&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n《常用代码模板3——搜索与图论》算法基础课相关代码模板\n活动链接 —— 算法基础课\n树与图的存储\n树是一种特殊的图，与图的存储方式相同。\n对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。\n因此我们可以只考虑有向图的存储。\n\n(1) 邻接矩阵：g[a][b] 存储边a-&gt;b\n\n(2) 邻接表：\n\n&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n\n&#x2F;&#x2F; 添加一条边a-&gt;b\nvoid add(int a, int b)\n&#123;\n    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 初始化\nidx &#x3D; 0;\nmemset(h, -1, sizeof h);\n树与图的遍历\n时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\n(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心\n\nint dfs(int u)\n&#123;\n    st[u] &#x3D; true; &#x2F;&#x2F; st[u] 表示点u已经被遍历过\n\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j]) dfs(j);\n    &#125;\n&#125;\n(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次\n\nqueue&lt;int&gt; q;\nst[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())\n&#123;\n    int t &#x3D; q.front();\n    q.pop();\n\n    for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true; &#x2F;&#x2F; 表示点j已经被遍历过\n            q.push(j);\n        &#125;\n    &#125;\n&#125;\n拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列\n时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort()\n&#123;\n    int hh &#x3D; 0, tt &#x3D; -1;\n\n    &#x2F;&#x2F; d[i] 存储点i的入度\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (!d[i])\n            q[ ++ tt] &#x3D; i;\n\n    while (hh &lt;&#x3D; tt)\n    &#123;\n        int t &#x3D; q[hh ++ ];\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (-- d[j] &#x3D;&#x3D; 0)\n                q[ ++ tt] &#x3D; j;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt &#x3D;&#x3D; n - 1;\n&#125;\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I\n时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数\nint g[N][N];  &#x2F;&#x2F; 存储每条边\nint dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离\nbool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt; n - 1; i ++ )\n    &#123;\n        int t &#x3D; -1;     &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        &#x2F;&#x2F; 用t更新其他点的距离\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);\n\n        st[t] &#x3D; true;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II\n时间复杂度 O(mlogn)O(mlogn), nn 表示点数，mm 表示边数\ntypedef pair&lt;int, int&gt; PII;\n\nint n;      &#x2F;&#x2F; 点的数量\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定\n\n&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    heap.push(&#123;0, 1&#125;);      &#x2F;&#x2F; first存储距离，second存储节点编号\n\n    while (heap.size())\n    &#123;\n        auto t &#x3D; heap.top();\n        heap.pop();\n\n        int ver &#x3D; t.second, distance &#x3D; t.first;\n\n        if (st[ver]) continue;\n        st[ver] &#x3D; true;\n\n        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; distance + w[i])\n            &#123;\n                dist[j] &#x3D; distance + w[i];\n                heap.push(&#123;dist[j], j&#125;);\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\nBellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路\n时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数\n注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\n\nint n, m;       &#x2F;&#x2F; n表示点数，m表示边数\nint dist[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离\n\nstruct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重\n&#123;\n    int a, b, w;\n&#125;edges[M];\n\n&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    &#x2F;&#x2F; 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        for (int j &#x3D; 0; j &lt; m; j ++ )\n        &#123;\n            int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] &#x3D; dist[a] + w;\n        &#125;\n    &#125;\n\n    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;\n    return dist[n];\n&#125;\nspfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路\n时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] &#x3D; 0;\n\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] &#x3D; true;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                if (!st[j])     &#x2F;&#x2F; 如果队列中已存在j，则不需要将j重复插入\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\nspfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环\n时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n;      &#x2F;&#x2F; 总点数\nint h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边\nint dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中\n\n&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。\nbool spfa()\n&#123;\n    &#x2F;&#x2F; 不需要初始化dist数组\n    &#x2F;&#x2F; 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue&lt;int&gt; q;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n    &#123;\n        q.push(i);\n        st[i] &#x3D; true;\n    &#125;\n\n    while (q.size())\n    &#123;\n        auto t &#x3D; q.front();\n        q.pop();\n\n        st[t] &#x3D; false;\n\n        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])\n        &#123;\n            int j &#x3D; e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            &#123;\n                dist[j] &#x3D; dist[t] + w[i];\n                cnt[j] &#x3D; cnt[t] + 1;\n                if (cnt[j] &gt;&#x3D; n) return true;       &#x2F;&#x2F; 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                &#123;\n                    q.push(j);\n                    st[j] &#x3D; true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\nfloyd算法 —— 模板题 AcWing 854. Floyd求最短路\n时间复杂度是 O(n3)O(n3), nn 表示点数\n初始化：\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;\n            else d[i][j] &#x3D; INF;\n\n&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n&#123;\n    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);\n&#125;\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树\n时间复杂度是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数\nint n;      &#x2F;&#x2F; n表示点数\nint g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边\nint dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离\nbool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中\n\n\n&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n&#123;\n    memset(dist, 0x3f, sizeof dist);\n\n    int res &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n    &#123;\n        int t &#x3D; -1;\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )\n            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))\n                t &#x3D; j;\n\n        if (i &amp;&amp; dist[t] &#x3D;&#x3D; INF) return INF;\n\n        if (i) res +&#x3D; dist[t];\n        st[t] &#x3D; true;\n\n        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) dist[j] &#x3D; min(dist[j], g[t][j]);\n    &#125;\n\n    return res;\n&#125;\nKruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树\n时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数\nint n, m;       &#x2F;&#x2F; n是点数，m是边数\nint p[N];       &#x2F;&#x2F; 并查集的父节点数组\n\nstruct Edge     &#x2F;&#x2F; 存储边\n&#123;\n    int a, b, w;\n\n    bool operator&lt; (const Edge &amp;W)const\n    &#123;\n        return w &lt; W.w;\n    &#125;\n&#125;edges[M];\n\nint find(int x)     &#x2F;&#x2F; 并查集核心操作\n&#123;\n    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);\n    return p[x];\n&#125;\n\nint kruskal()\n&#123;\n    sort(edges, edges + m);\n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;    &#x2F;&#x2F; 初始化并查集\n\n    int res &#x3D; 0, cnt &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; m; i ++ )\n    &#123;\n        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;\n\n        a &#x3D; find(a), b &#x3D; find(b);\n        if (a !&#x3D; b)     &#x2F;&#x2F; 如果两个连通块不连通，则将这两个连通块合并\n        &#123;\n            p[a] &#x3D; b;\n            res +&#x3D; w;\n            cnt ++ ;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1) return INF;\n    return res;\n&#125;\n染色法判别二分图 —— 模板题 AcWing 860. 染色法判定二分图\n时间复杂度是 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nint n;      &#x2F;&#x2F; n表示点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图\nint color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n\n&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n&#123;\n    color[u] &#x3D; c;\n    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (color[j] &#x3D;&#x3D; -1)\n        &#123;\n            if (!dfs(j, !c)) return false;\n        &#125;\n        else if (color[j] &#x3D;&#x3D; c) return false;\n    &#125;\n\n    return true;\n&#125;\n\nbool check()\n&#123;\n    memset(color, -1, sizeof color);\n    bool flag &#x3D; true;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (color[i] &#x3D;&#x3D; -1)\n            if (!dfs(i, 0))\n            &#123;\n                flag &#x3D; false;\n                break;\n            &#125;\n    return flag;\n&#125;\n匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配\n时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过\n\nbool find(int x)\n&#123;\n    for (int i &#x3D; h[x]; i !&#x3D; -1; i &#x3D; ne[i])\n    &#123;\n        int j &#x3D; e[i];\n        if (!st[j])\n        &#123;\n            st[j] &#x3D; true;\n            if (match[j] &#x3D;&#x3D; 0 || find(match[j]))\n            &#123;\n                match[j] &#x3D; x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\nint res &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )\n&#123;\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n&#125;\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;405&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n《常用代码模板4——数学知识》算法基础课相关代码模板\n活动链接 —— 算法基础课\n试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数\nbool is_prime(int x)\n&#123;\n    if (x &lt; 2) return false;\n    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )\n        if (x % i &#x3D;&#x3D; 0)\n            return false;\n    return true;\n&#125;\n试除法分解质因数 —— 模板题 AcWing 867. 分解质因数\nvoid divide(int x)\n&#123;\n    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )\n        if (x % i &#x3D;&#x3D; 0)\n        &#123;\n            int s &#x3D; 0;\n            while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i, s ++ ;\n            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; endl;\n        &#125;\n    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1 &lt;&lt; endl;\n    cout &lt;&lt; endl;\n&#125;\n朴素筛法求素数 —— 模板题 AcWing 868. 筛质数\nint primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数\nbool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n&#123;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        if (st[i]) continue;\n        primes[cnt ++ ] &#x3D; i;\n        for (int j &#x3D; i + i; j &lt;&#x3D; n; j +&#x3D; i)\n            st[j] &#x3D; true;\n    &#125;\n&#125;\n线性筛法求素数 —— 模板题 AcWing 868. 筛质数\nint primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数\nbool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n&#123;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        if (!st[i]) primes[cnt ++ ] &#x3D; i;\n        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )\n        &#123;\n            st[primes[j] * i] &#x3D; true;\n            if (i % primes[j] &#x3D;&#x3D; 0) break;\n        &#125;\n    &#125;\n&#125;\n试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数\nvector&lt;int&gt; get_divisors(int x)\n&#123;\n    vector&lt;int&gt; res;\n    for (int i &#x3D; 1; i &lt;&#x3D; x &#x2F; i; i ++ )\n        if (x % i &#x3D;&#x3D; 0)\n        &#123;\n            res.push_back(i);\n            if (i !&#x3D; x &#x2F; i) res.push_back(x &#x2F; i);\n        &#125;\n    sort(res.begin(), res.end());\n    return res;\n&#125;\n约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和\n如果 N &#x3D; p1^c1 * p2^c2 * ... *pk^ck\n约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)\n约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)\n欧几里得算法 —— 模板题 AcWing 872. 最大公约数\nint gcd(int a, int b)\n&#123;\n    return b ? gcd(b, a % b) : a;\n&#125;\n求欧拉函数 —— 模板题 AcWing 873. 欧拉函数\nint phi(int x)\n&#123;\n    int res &#x3D; x;\n    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )\n        if (x % i &#x3D;&#x3D; 0)\n        &#123;\n            res &#x3D; res &#x2F; i * (i - 1);\n            while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i;\n        &#125;\n    if (x &gt; 1) res &#x3D; res &#x2F; x * (x - 1);\n\n    return res;\n&#125;\n筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数\nint primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数\nint euler[N];           &#x2F;&#x2F; 存储每个数的欧拉函数\nbool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉\n\n\nvoid get_eulers(int n)\n&#123;\n    euler[1] &#x3D; 1;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        if (!st[i])\n        &#123;\n            primes[cnt ++ ] &#x3D; i;\n            euler[i] &#x3D; i - 1;\n        &#125;\n        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )\n        &#123;\n            int t &#x3D; primes[j] * i;\n            st[t] &#x3D; true;\n            if (i % primes[j] &#x3D;&#x3D; 0)\n            &#123;\n                euler[t] &#x3D; euler[i] * primes[j];\n                break;\n            &#125;\n            euler[t] &#x3D; euler[i] * (primes[j] - 1);\n        &#125;\n    &#125;\n&#125;\n快速幂 —— 模板题 AcWing 875. 快速幂\n求 m^k mod p，时间复杂度 O(logk)。\n\nint qmi(int m, int k, int p)\n&#123;\n    int res &#x3D; 1 % p, t &#x3D; m;\n    while (k)\n    &#123;\n        if (k&amp;1) res &#x3D; res * t % p;\n        t &#x3D; t * t % p;\n        k &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;\n扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法\n&#x2F;&#x2F; 求x, y，使得ax + by &#x3D; gcd(a, b)\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n&#123;\n    if (!b)\n    &#123;\n        x &#x3D; 1; y &#x3D; 0;\n        return a;\n    &#125;\n    int d &#x3D; exgcd(b, a % b, y, x);\n    y -&#x3D; (a&#x2F;b) * x;\n    return d;\n&#125;\n高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组\n&#x2F;&#x2F; a[N][N]是增广矩阵\nint gauss()\n&#123;\n    int c, r;\n    for (c &#x3D; 0, r &#x3D; 0; c &lt; n; c ++ )\n    &#123;\n        int t &#x3D; r;\n        for (int i &#x3D; r; i &lt; n; i ++ )   &#x2F;&#x2F; 找到绝对值最大的行\n            if (fabs(a[i][c]) &gt; fabs(a[t][c]))\n                t &#x3D; i;\n\n        if (fabs(a[t][c]) &lt; eps) continue;\n\n        for (int i &#x3D; c; i &lt;&#x3D; n; i ++ ) swap(a[t][i], a[r][i]);      &#x2F;&#x2F; 将绝对值最大的行换到最顶端\n        for (int i &#x3D; n; i &gt;&#x3D; c; i -- ) a[r][i] &#x2F;&#x3D; a[r][c];      &#x2F;&#x2F; 将当前行的首位变成1\n        for (int i &#x3D; r + 1; i &lt; n; i ++ )       &#x2F;&#x2F; 用当前行将下面所有的列消成0\n            if (fabs(a[i][c]) &gt; eps)\n                for (int j &#x3D; n; j &gt;&#x3D; c; j -- )\n                    a[i][j] -&#x3D; a[r][j] * a[i][c];\n\n        r ++ ;\n    &#125;\n\n    if (r &lt; n)\n    &#123;\n        for (int i &#x3D; r; i &lt; n; i ++ )\n            if (fabs(a[i][n]) &gt; eps)\n                return 2; &#x2F;&#x2F; 无解\n        return 1; &#x2F;&#x2F; 有无穷多组解\n    &#125;\n\n    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )\n        for (int j &#x3D; i + 1; j &lt; n; j ++ )\n            a[i][n] -&#x3D; a[i][j] * a[j][n];\n\n    return 0; &#x2F;&#x2F; 有唯一解\n&#125;\n递归法求组合数 —— 模板题 AcWing 885. 求组合数 I\n&#x2F;&#x2F; c[a][b] 表示从a个苹果中选b个的方案数\nfor (int i &#x3D; 0; i &lt; N; i ++ )\n    for (int j &#x3D; 0; j &lt;&#x3D; i; j ++ )\n        if (!j) c[i][j] &#x3D; 1;\n        else c[i][j] &#x3D; (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II\n首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]\n如果取模的数是质数，可以用费马小定理求逆元\nint qmi(int a, int k, int p)    &#x2F;&#x2F; 快速幂模板\n&#123;\n    int res &#x3D; 1;\n    while (k)\n    &#123;\n        if (k &amp; 1) res &#x3D; (LL)res * a % p;\n        a &#x3D; (LL)a * a % p;\n        k &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;\n\n&#x2F;&#x2F; 预处理阶乘的余数和阶乘逆元的余数\nfact[0] &#x3D; infact[0] &#x3D; 1;\nfor (int i &#x3D; 1; i &lt; N; i ++ )\n&#123;\n    fact[i] &#x3D; (LL)fact[i - 1] * i % mod;\n    infact[i] &#x3D; (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;\n&#125;\nLucas定理 —— 模板题 AcWing 887. 求组合数 III\n若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：\n    C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)\n\nint qmi(int a, int k, int p)  &#x2F;&#x2F; 快速幂模板\n&#123;\n    int res &#x3D; 1 % p;\n    while (k)\n    &#123;\n        if (k &amp; 1) res &#x3D; (LL)res * a % p;\n        a &#x3D; (LL)a * a % p;\n        k &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;\n\nint C(int a, int b, int p)  &#x2F;&#x2F; 通过定理求组合数C(a, b)\n&#123;\n    if (a &lt; b) return 0;\n\n    LL x &#x3D; 1, y &#x3D; 1;  &#x2F;&#x2F; x是分子，y是分母\n    for (int i &#x3D; a, j &#x3D; 1; j &lt;&#x3D; b; i --, j ++ )\n    &#123;\n        x &#x3D; (LL)x * i % p;\n        y &#x3D; (LL) y * j % p;\n    &#125;\n\n    return x * (LL)qmi(y, p - 2, p) % p;\n&#125;\n\nint lucas(LL a, LL b, int p)\n&#123;\n    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);\n    return (LL)C(a % p, b % p, p) * lucas(a &#x2F; p, b &#x2F; p, p) % p;\n&#125;\n分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV\n当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\n    1. 筛法求出范围内的所有质数\n    2. 通过 C(a, b) &#x3D; a! &#x2F; b! &#x2F; (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n &#x2F; p + n &#x2F; p^2 + n &#x2F; p^3 + ...\n    3. 用高精度乘法将所有质因子相乘\n\nint primes[N], cnt;     &#x2F;&#x2F; 存储所有质数\nint sum[N];     &#x2F;&#x2F; 存储每个质数的次数\nbool st[N];     &#x2F;&#x2F; 存储每个数是否已被筛掉\n\n\nvoid get_primes(int n)      &#x2F;&#x2F; 线性筛法求素数\n&#123;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n    &#123;\n        if (!st[i]) primes[cnt ++ ] &#x3D; i;\n        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )\n        &#123;\n            st[primes[j] * i] &#x3D; true;\n            if (i % primes[j] &#x3D;&#x3D; 0) break;\n        &#125;\n    &#125;\n&#125;\n\n\nint get(int n, int p)       &#x2F;&#x2F; 求n！中的次数\n&#123;\n    int res &#x3D; 0;\n    while (n)\n    &#123;\n        res +&#x3D; n &#x2F; p;\n        n &#x2F;&#x3D; p;\n    &#125;\n    return res;\n&#125;\n\n\nvector&lt;int&gt; mul(vector&lt;int&gt; a, int b)       &#x2F;&#x2F; 高精度乘低精度模板\n&#123;\n    vector&lt;int&gt; c;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; a.size(); i ++ )\n    &#123;\n        t +&#x3D; a[i] * b;\n        c.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    while (t)\n    &#123;\n        c.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    return c;\n&#125;\n\nget_primes(a);  &#x2F;&#x2F; 预处理范围内的所有质数\n\nfor (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 求每个质因数的次数\n&#123;\n    int p &#x3D; primes[i];\n    sum[i] &#x3D; get(a, p) - get(b, p) - get(a - b, p);\n&#125;\n\nvector&lt;int&gt; res;\nres.push_back(1);\n\nfor (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 用高精度乘法将所有质因子相乘\n    for (int j &#x3D; 0; j &lt; sum[i]; j ++ )\n        res &#x3D; mul(res, primes[i]);\n\n卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列\n给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) &#x3D; C(2n, n) &#x2F; (n + 1)\nNIM游戏 —— 模板题 AcWing 891. Nim游戏\n给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\n\n我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。\n所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。\nNIM博弈不存在平局，只有先手必胜和先手必败两种情况。\n\n定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An !&#x3D; 0\n\n公平组合游戏ICG\n若一个游戏满足：\n\n由两名玩家交替行动；\n在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\n不能行动的玩家判负；\n则称该游戏为一个公平组合游戏。\nNIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。\n\n有向图游戏\n给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。\n任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\n\nMex运算\n设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：\nmex(S) &#x3D; min&#123;x&#125;, x属于自然数，且x不属于S\n\nSG函数\n在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：\nSG(x) &#x3D; mex(&#123;SG(y1), SG(y2), …, SG(yk)&#125;)\n特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) &#x3D; SG(s)。\n\n有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏\n设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。\n有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：\nSG(G) &#x3D; SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\n\n定理\n有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。\n有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\n\n作者：yxc\n链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;blog&#x2F;content&#x2F;406&#x2F;\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n","slug":"yxc-share模板","date":"2020-04-16T14:45:44.000Z","categories_index":"算法","tags_index":"算法","author_index":"CodingSeed"}]